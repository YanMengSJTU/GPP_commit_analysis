diff --git a/CHANGELOG.md b/CHANGELOG.md
index b1bab8fc53..5d909505eb 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,17 +1,80 @@
-## 2.4.0
+## 3.1.0 (YYYY-MM-DD)
 
-## 2.3.2
+### Enhancements
+
+* Now `targetSdkVersion` is 25.
+
+### Bug Fixes
+
+* `Realm.migrateRealm(RealmConfiguration)` now fails correctly with an `IllegalArgumentException` if a `SyncConfiguration` is provided (#4075).
+
+### Deprecated
 
 ### Internal
 
-* Updated to Realm Sync v1.0.4.
-* Updated to Realm Core v2.3.1.
+* Using the Object Store's Session and SyncManager.
+
+## 3.0.0 (2017-02-28)
 
-## 2.3.1
+### Breaking Changes
+
+* `RealmResults.distinct()` returns a new `RealmResults` object instead of filtering on the original object (#2947).
+* `RealmResults` is auto-updated continuously. Any transaction on the current thread which may have an impact on the order or elements of the `RealmResults` will change the `RealmResults` immediately instead of change it in the next event loop. The standard `RealmResults.iterator()` will continue to work as normal, which means that you can still delete or modify elements without impacting the iterator. The same is not true for simple for-loops. In some cases a simple for-loop will not work (https://realm.io/docs/java/3.0.0/api/io/realm/OrderedRealmCollection.html#loops), and you must use the new createSnapshot() method.
+* `RealmChangeListener` on `RealmObject` will now also be triggered when the object is deleted. Use `RealmObject.isValid()` to check this state(#3138).
+* `RealmObject.asObservable()` will now emit the object when it is deleted. Use `RealmObject.isValid()` to check this state (#3138).
+* Removed deprecated classes `Logger` and `AndroidLogger` (#4050).
+
+### Deprecated
+
+* `RealmResults.removeChangeListeners()`. Use `RealmResults.removeAllChangeListeners()` instead.
+* `RealmObject.removeChangeListeners()`. Use `RealmObject.removeAllChangeListeners()` instead.
+* `RealmResults.distinct()` and `RealmResults.distinctAsync()`. Use `RealmQuery.distinct()` and `RealmQuery.distinctAsync()` instead.
+
+### Enhancements
+
+* Added support for sorting by link's field (#672).
+* Added `OrderedRealmCollectionSnapshot` class and `OrderedRealmCollection.createSnapshot()` method. `OrderedRealmCollectionSnapshot` is useful when changing `RealmResults` or `RealmList` in simple loops.
+* Added `OrderedRealmCollectionChangeListener` interface for supporting fine-grained collection notifications.
+* Added support for ChangeListeners on `RealmList`.
+* Added `RealmList.asObservable()`.
+
+### Bug Fixes
+
+* Element type checking in `DynamicRealmObject#setList()` (#4252).
+* Now throws `IllegalStateException` instead of process crash when any of thread confined methods in `RealmQuery` is called from wrong thread (#4228).
+* Now throws `IllegalStateException` when any of thread confined methods in `DynamicRealmObject` is called from wrong thread (#4258).
+
+### Internal
+
+* Use Object Store's `Results` as the backend for `RealmResults` (#3372).
+  - Use Object Store's notification mechanism to trigger listeners.
+  - Local commits triggers Realm global listener and `RealmObject` listener on current thread immediately instead of in the next event loop.
+
+
+## 2.3.2 (2017-02-27)
+
+### Bug fixes
+
+* Log levels in JNI layer were all reported as "Error" (#4204).
+* Encrypted realms can end up corrupted if many threads are reading and writing at the same time (#4128).
+* "Read-only file system" exception when compacting Realm file on external storage (#4140).
+
+### Internal
+
+* Updated to Realm Sync v1.2.1.
+* Updated to Realm Core v2.3.2.
+
+### Enhancements
+
+* Improved performance of getters and setters in proxy classes.
+
+
+## 2.3.1 (2017-02-07)
 
 ### Enhancements
 
 * [ObjectServer] The `serverUrl` given to `SyncConfiguration.Builder()` is now more lenient and will also accept only paths as argument (#4144).
+* [ObjectServer] Add a timer to refresh periodically the access_token.
 
 ### Bug fixes
 
@@ -21,11 +84,8 @@
 * Bug causing classes to be replaced by classes already in Gradle's classpath (#3568).
 * NullPointerException when notifying a single object that it changed (#4086).
 
-### Enhancements
-
-* [ObjectServer] Add a timer to refresh periodically the access_token.
 
-## 2.3.0
+## 2.3.0 (2017-01-19)
 
 ### Object Server API Changes
 
@@ -58,7 +118,7 @@
 * Updated to Realm Sync v1.0.0.
 * Added a Realm backup when receiving a Sync client reset message from the server.
 
-## 2.2.2
+## 2.2.2 (2016-01-16)
 
 ### Object Server API Changes (In Beta)
 
@@ -84,7 +144,7 @@
 * Upgraded Realm Core to 2.3.0.
 * Upgraded Realm Sync to 1.0.0-BETA-6.5.
 
-## 2.2.1
+## 2.2.1 (2016-11-12)
 
 ### Object Server API Changes (In Beta)
 
@@ -95,7 +155,7 @@
 * Added version number to the native library, preventing ReLinker from accidentally loading old code (#3775).
 * `Realm.getLocalInstanceCount(config)` throwing NullPointerException if called after all Realms have been closed (#3791).
 
-## 2.2.0
+## 2.2.0 (2016-11-12)
 
 ### Object Server API Changes (In Beta)
 
@@ -111,7 +171,7 @@
 
 * Added support for the `annotationProcessor` configuration provided by Android Gradle Plugin 2.2.0 or later. Realm plugin adds its annotation processor to the `annotationProcessor` configuration instead of `apt` configuration if it is available and the `com.neenbedankt.android-apt` plugin is not used. In Kotlin projects, `kapt` is used instead of the `annotationProcessor` configuration (#3026).
 
-## 2.1.1
+## 2.1.1 (2016-10-27)
 
 ### Bug fixes
 
@@ -125,7 +185,7 @@
 
 * ProGuard configuration introduced in 2.1.0 unexpectedly kept classes that did not have the @KeepMember annotation (#3689).
 
-## 2.1.0
+## 2.1.0 (2016-10-25)
 
 ### Breaking changes
 
@@ -169,7 +229,7 @@
 
 * Thanks to Max Furman (@maxfurman) for adding support for `first()` and `last()` default values.
 
-## 2.0.2
+## 2.0.2 (2016-10-06)
 
 This release is not protocol-compatible with previous versions of the Realm Mobile Platform. The base library is still fully compatible.
 
@@ -182,7 +242,7 @@ This release is not protocol-compatible with previous versions of the Realm Mobi
 * Upgraded Realm Core to 2.1.0
 * Upgraded Realm Sync to 1.0.0-BETA-2.0.
 
-## 2.0.1
+## 2.0.1 (2016-10-05)
 
 ### Bug fixes
 
@@ -195,7 +255,7 @@ This release is not protocol-compatible with previous versions of the Realm Mobi
 
 * Upgraded to Realm Core 2.0.1 / Realm Sync 1.3-BETA
 
-## 2.0.0
+## 2.0.0 (2016-09-27)
 
 This release introduces support for the Realm Mobile Platform!
 See <https://realm.io/news/introducing-realm-mobile-platform/> for an overview of these great new features.
@@ -241,7 +301,7 @@ See <https://realm.io/news/introducing-realm-mobile-platform/> for an overview o
 * Updated Realm Core to 2.0.0.
 * Updated ReLinker to 1.2.2.
 
-## 1.2.0
+## 1.2.0 (2016-08-19)
 
 ### Bug fixes
 
@@ -266,7 +326,7 @@ See <https://realm.io/news/introducing-realm-mobile-platform/> for an overview o
 
 * Thanks to Brenden Kromhout (@bkromhout) for adding binary array support to `equalTo` and `notEqualTo`.
 
-## 1.1.1
+## 1.1.1 (2016-07-01)
 
 ### Bug fixes
 
@@ -292,7 +352,7 @@ See <https://realm.io/news/introducing-realm-mobile-platform/> for an overview o
 * Updated Realm Core to 1.4.2.
 * Improved sorting speed.
 
-## 1.1.0
+## 1.1.0 (2016-06-30)
 
 ### Bug fixes
 
@@ -318,7 +378,7 @@ See <https://realm.io/news/introducing-realm-mobile-platform/> for an overview o
 
 * Updated Realm Core to 1.2.0.
 
-## 1.0.1
+## 1.0.1 (2016-05-25)
 
 ### Bug fixes
 
@@ -336,11 +396,11 @@ See <https://realm.io/news/introducing-realm-mobile-platform/> for an overview o
 
 * Removes RxJava related APIs during bytecode transforming to make RealmObject plays well with reflection when rx.Observable doesn't exist.
 
-## 1.0.0
+## 1.0.0 (2016-05-25)
 
 No changes since 0.91.1.
 
-## 0.91.1
+## 0.91.1 (2016-05-25)
 
 * Updated Realm Core to 1.0.1.
 
@@ -348,7 +408,7 @@ No changes since 0.91.1.
 
 * Fixed a bug when opening a Realm causes a staled memory mapping. Symptoms are error messages like "Bad or incompatible history type", "File format version doesn't match", and "Encrypted interprocess sharing is currently unsupported".
 
-## 0.91.0
+## 0.91.0 (2016-05-20)
 
 * Updated Realm Core to 1.0.0.
 
@@ -516,7 +576,7 @@ No changes since 0.91.1.
 * now DynamicRealmObject.toString() correctly shows null value as "null" and the format is aligned to the String from typed RealmObject (#2439).
 * Fixed an issue occurring while resolving ReLinker in apps using a library based on Realm (#2415).
 
-## 0.88.0
+## 0.88.0 (2016-03-10)
 
 * Updated Realm Core to 0.97.0.
 
@@ -569,16 +629,16 @@ No changes since 0.91.1.
 * Thanks to Bill Best (@wmbest2) for snapshot testing.
 * Thanks to Graham Smith (@grahamsmith) for a detailed bug report (#2200).
 
-## 0.87.5
+## 0.87.5 (2016-01-29)
 * Updated Realm Core to 0.96.2.
   - IllegalStateException won't be thrown anymore in RealmResults.where() if the RealmList which the RealmResults is created on has been deleted. Instead, the RealmResults will be treated as empty forever.
   - Fixed a bug causing a bad version exception, when using findFirstAsync (#2115).
 
-## 0.87.4
+## 0.87.4 (2016-01-28)
 * Updated Realm Core to 0.96.0.
   - Fixed bug causing BadVersionException or crashing core when running async queries.
 
-## 0.87.3
+## 0.87.3 (2016-01-25)
 * IllegalArgumentException is now properly thrown when calling Realm.copyFromRealm() with a DynamicRealmObject (#2058).
 * Fixed a message in IllegalArgumentException thrown by the accessors of DynamicRealmObject (#2141).
 * Fixed RealmList not returning DynamicRealmObjects of the correct underlying type (#2143).
@@ -587,21 +647,21 @@ No changes since 0.91.1.
   - Fixed a bug where undetected deleted object might lead to seg. fault (#1945).
   - Better performance when deleting objects (#2015).
 
-## 0.87.2
+## 0.87.2 (2016-01-08)
 * Removed explicit GC call when committing a transaction (#1925).
 * Fixed a bug when RealmObjectSchema.addField() was called with the PRIMARY_KEY modifier, the field was not set as a required field (#2001).
 * Fixed a bug which could throw a ConcurrentModificationException in RealmObject's or RealmResults' change listener (#1970).
 * Fixed RealmList.set() so it now correctly returns the old element instead of the new (#2044).
 * Fixed the deployment of source and javadoc jars (#1971).
 
-## 0.87.1
+## 0.87.1 (2015-12-23)
 * Upgraded to NDK R10e. Using gcc 4.9 for all architectures.
 * Updated Realm Core to 0.95.6
   - Fixed a bug where an async query can be copied incomplete in rare cases (#1717).
 * Fixed potential memory leak when using async query.
 * Added a check to prevent removing a RealmChangeListener from a non-Looper thread (#1962). (Thank you @hohnamkung)
 
-## 0.87.0
+## 0.87.0 (2015-12-17)
 * Added Realm.asObservable(), RealmResults.asObservable(), RealmObject.asObservable(), DynamicRealm.asObservable() and DynamicRealmObject.asObservable().
 * Added RealmConfiguration.Builder.rxFactory() and RxObservableFactory for custom RxJava observable factory classes.
 * Added Realm.copyFromRealm() for creating detached copies of Realm objects (#931).
@@ -610,7 +670,7 @@ No changes since 0.91.1.
 * Added support for ISO8601 based dates for JSON import. If JSON dates are invalid a RealmException will be thrown (#1213).
 * Added APK splits to gridViewExample (#1834).
 
-## 0.86.1
+## 0.86.1 (2015-12-11)
 * Improved the performance of removing objects (RealmResults.clear() and RealmResults.remove()).
 * Updated Realm Core to 0.95.5.
 * Updated ProGuard configuration (#1904).
@@ -622,7 +682,7 @@ No changes since 0.91.1.
 * Fixed RealmChangeListener never called inside RealmResults (#1894).
 * Fixed crash when calling clear on a RealmList (#1886).
 
-## 0.86.0
+## 0.86.0 (2015-12-03)
 * BREAKING CHANGE: The Migration API has been replaced with a new API.
 * BREAKING CHANGE: RealmResults.SORT_ORDER_ASCENDING and RealmResults.SORT_ORDER_DESCENDING constants have been replaced by Sort.ASCENDING and Sort.DESCENDING enums.
 * BREAKING CHANGE: RealmQuery.CASE_SENSITIVE and RealmQuery.CASE_INSENSITIVE constants have been replaced by Case.SENSITIVE and Case.INSENSITIVE enums.
@@ -639,10 +699,10 @@ No changes since 0.91.1.
   - Fixed a bug where RealmQuery.average(String) returned a wrong value for a nullable Long/Integer/Short/Byte field (#1803).
   - Fixed a bug where RealmQuery.average(String) wrongly counted the null value for average calculation (#1854).
 
-## 0.85.1
+## 0.85.1 (2015-11-23)
 * Fixed a bug which could corrupt primary key information when updating from a Realm version <= 0.84.1 (#1775).
 
-## 0.85.0
+## 0.85.0 (2016-11-19)
 * BREAKING CHANGE: Removed RealmEncryptionNotSupportedException since the encryption implementation changed in Realm's underlying storage engine. Encryption is now supported on all devices.
 * BREAKING CHANGE: Realm.executeTransaction() now directly throws any RuntimeException instead of wrapping it in a RealmException (#1682).
 * BREAKING CHANGE: RealmQuery.isNull() and RealmQuery.isNotNull() now throw IllegalArgumentException instead of RealmError if the fieldname is a linked field and the last element is a link (#1693).
@@ -660,7 +720,7 @@ No changes since 0.91.1.
 * Fixed a memory leak when using relationships (#1285).
 * Fixed a bug causing cached column indices to be cleared too soon (#1732).
 
-## 0.84.1
+## 0.84.1 (2015-10-28)
 * Updated Realm Core to 0.94.4.
   - Fixed a bug that could cause a crash when running the same query multiple times.
 * Updated ProGuard configuration. See [documentation](https://realm.io/docs/java/latest/#proguard) for more details.
@@ -669,7 +729,7 @@ No changes since 0.91.1.
 * Fixed a bug where simultaneous opening and closing a Realm from different threads might result in a NullPointerException (#1646).
 * Fixed a bug which made it possible to externally modify the encryption key in a RealmConfiguration (#1678).
 
-## 0.84.0
+## 0.84.0 (2015-10-22)
 * Added support for async queries and transactions.
 * Added support for parsing JSON Dates with timezone information. (Thank you @LateralKevin)
 * Added RealmQuery.isEmpty().
@@ -691,12 +751,12 @@ No changes since 0.91.1.
 * Fixed a bug that made it possible to migrate open Realms, which could cause undefined behavior when querying, reading or writing data.
 * Fixed a bug causing column indices to be wrong for some edge cases. See #1611 for details.
 
-## 0.83.1
+## 0.83.1 (2015-10-15)
 * Updated Realm Core to version 0.94.1.
   - Fixed a bug when using Realm.compactRealm() which could make it impossible to open the Realm file again.
   - Fixed a bug, so isNull link queries now always return true if any part is null.
 
-## 0.83
+## 0.83 (2015-10-08)
 * BREAKING CHANGE: Database file format update. The Realm file created by this version cannot be used by previous versions of Realm.
 * BREAKING CHANGE: Removed deprecated methods and constructors from the Realm class.
 * BREAKING CHANGE: Introduced boxed types Boolean, Byte, Short, Integer, Long, Float and Double. Added null support. Introduced annotation @Required to indicate a field is not nullable. String, Date and byte[] became nullable by default which means a RealmMigrationNeededException will be thrown if an previous version of a Realm file is opened.
@@ -707,7 +767,7 @@ No changes since 0.91.1.
 * Opening a Realm file from one thread will no longer be blocked by a transaction from another thread.
 * Range restrictions of Date fields have been removed. Date fields now accepts any value. Milliseconds are still removed.
 
-## 0.82.2
+## 0.82.2 (2015-09-04)
 * Fixed a bug which might cause failure when loading the native library.
 * Fixed a bug which might trigger a timeout in Context.finalize().
 * Fixed a bug which might cause RealmObject.isValid() to throw an exception if the object is deleted.
@@ -716,12 +776,12 @@ No changes since 0.91.1.
   - Embedded crypto functions into Realm dynamic lib to avoid random issues on some devices.
   - Throw RealmEncryptionNotSupportedException if the device doesn't support Realm encryption. At least one device type (HTC One X) contains system bugs that prevents Realm's encryption from functioning properly. This is now detected, and an exception is thrown when trying to open/create an encrypted Realm file. It's up to the application to catch this and decide if it's OK to proceed without encryption instead.
 
-## 0.82.1
+## 0.82.1 (2015-08-06)
 * Fixed a bug where using the wrong encryption key first caused the right key to be seen as invalid.
 * Fixed a bug where String fields were ignored when updating objects from JSON with null values.
 * Fixed a bug when calling System.exit(0), the process might hang.
 
-## 0.82
+## 0.82 (2015-07-28)
 * BREAKING CHANGE: Fields with annotation @PrimaryKey are indexed automatically now. Older schemas require a migration.
 * RealmConfiguration.setModules() now accept ignore null values which Realm.getDefaultModule() might return.
 * Trying to access a deleted Realm object throw throws a proper IllegalStateException.
@@ -732,10 +792,10 @@ No changes since 0.91.1.
 * Fixed a bug where RealmQuery objects are prematurely garbage collected.
 * Removed RealmQuery.between() for link queries.
 
-## 0.81.1
+## 0.81.1 (2015-06-22)
 * Fixed memory leak causing Realm to never release Realm objects.
 
-## 0.81
+## 0.81 (2015-06-19)
 * Introduced RealmModules for working with custom schemas in libraries and apps.
 * Introduced Realm.getDefaultInstance(), Realm.setDefaultInstance(RealmConfiguration) and Realm.getInstance(RealmConfiguration).
 * Deprecated most constructors. They have been been replaced by Realm.getInstance(RealmConfiguration) and Realm.getDefaultInstance().
@@ -750,7 +810,7 @@ No changes since 0.91.1.
 * Cleaned up examples (remove old test project).
 * Added checking for missing generic type in RealmList fields in annotation processor.
 
-## 0.80.3
+## 0.80.3 (2015-05-22)
 * Calling Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
 * Fixed a bug making it impossible to open Realms created by Realm-Cocoa if a model had a primary key defined.
 * Trying to using Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
@@ -763,14 +823,14 @@ No changes since 0.91.1.
 * Solved ConcurrentModificationException thrown when addChangeListener/removeChangeListener got called in the onChange. (Thanks @beeender)
 * Fixed duplicated listeners in the same realm instance. Trying to add duplicated listeners is ignored now. (Thanks @beeender)
 
-## 0.80.2
+## 0.80.2 (2015-05-04)
 * Trying to use Realm.copyToRealmOrUpdate() with an object with a null primary key now throws a proper exception.
 * RealmMigrationNeedException can now return the path to the Realm that needs to be migrated.
 * Fixed bug where creating a Realm instance with a hashcode collision no longer returned the wrong Realm instance.
 * Updated Realm Core to version 0.89.2
   - fixed bug causing a crash when opening an encrypted Realm file on ARM64 devices.
 
-## 0.80.1
+## 0.80.1 (2015-04-16)
 * Realm.createOrUpdateWithJson() no longer resets fields to their default value if they are not found in the JSON input.
 * Realm.compactRealmFile() now uses Realm Core's compact() method which is more failure resilient.
 * Realm.copyToRealm() now correctly handles referenced child objects that are already in the Realm.
@@ -789,7 +849,7 @@ No changes since 0.91.1.
 * Added RealmQuery.isNull() and RealmQuery.isNotNull() for querying relationships.
 * Fixed a potential NPE in the RealmList constructor.
 
-## 0.80
+## 0.80 (2015-03-11)
 * Queries on relationships can be case sensitive.
 * Fixed bug when importing JSONObjects containing NULL values.
 * Fixed crash when trying to remove last element of a RealmList.
@@ -799,11 +859,11 @@ No changes since 0.91.1.
 * Added support for static fields in RealmObjects.
 * Realm.writeEncryptedCopyTo() has been reenabled.
 
-## 0.79.1
+## 0.79.1 (2015-02-20)
 * copyToRealm() no longer crashes on cyclic data structures.
 * Fixed potential crash when using copyToRealmOrUpdate with an object graph containing a mix of elements with and without primary keys.
 
-## 0.79
+## 0.79 (2015-02-16)
 * Added support for ARM64.
 * Added RealmQuery.not() to negate a query condition.
 * Added copyToRealmOrUpdate() and createOrUpdateFromJson() methods, that works for models with primary keys.
@@ -818,7 +878,7 @@ No changes since 0.91.1.
 * Removed methods deprecated in 0.76. Now Realm.allObjectsSorted() and RealmQuery.findAllSorted() need to be used instead.
 * Reimplemented Realm.allObjectSorted() for better performance.
 
-## 0.78
+## 0.78 (2015-01-22)
 * Added proper support for encryption. Encryption support is now included by default. Keys are now 64 bytes long.
 * Added support to write an encrypted copy of a Realm.
 * Realm no longer incorrectly warns that an instance has been closed too many times.
@@ -826,7 +886,7 @@ No changes since 0.91.1.
 * Fixed bug causing Realms to be cached during a RealmMigration resulting in invalid realms being returned from Realm.getInstance().
 * Updated core to 0.88.
 
-## 0.77
+## 0.77 (2015-01-16)
 * Added Realm.allObjectsSorted() and RealmQuery.findAllSorted() and extending RealmResults.sort() for multi-field sorting.
 * Added more logging capabilities at the JNI level.
 * Added proper encryption support. NOTE: The key has been increased from 32 bytes to 64 bytes (see example).
@@ -845,7 +905,7 @@ No changes since 0.91.1.
 * RealmList.remove() now properly returns the removed object.
 * Calling realm.close() no longer prevent updates to other open realm instances on the same thread.
 
-## 0.76.0
+## 0.76.0 (2014-12-19)
 * RealmObjects can now be imported using JSON.
 * Gradle wrapper updated to support Android Studio 1.0.
 * Fixed bug in RealmObject.equals() so it now correctly compares two objects from the same Realm.
@@ -857,13 +917,13 @@ No changes since 0.91.1.
 * Close the Realm instance after migrations.
 * Added a check to deny the writing of objects outside of a transaction.
 
-## 0.75.1 (03 December 2014)
+## 0.75.1 (2014-12-03)
 * Changed sort to be an in-place method.
 * Renamed SORT_ORDER_DECENDING to SORT_ORDER_DESCENDING.
 * Added sorting functionality to allObjects() and findAll().
 * Fixed bug when querying a date column with equalTo(), it would act as lessThan()
 
-## 0.75.0 (28 Nov 2014)
+## 0.75.0 (2014-11-28)
 * Realm now implements Closeable, allowing better cleanup of native resources.
 * Added writeCopyTo() and compactRealmFile() to write and compact a Realm to a new file.
 * RealmObject.toString(), equals() and hashCode() now support models with cyclic references.
@@ -875,7 +935,7 @@ No changes since 0.91.1.
 * Fixed bug so Realm no longer throws an Exception when removing the last object.
 * Fixed bug in RealmResults which prevented sub-querying.
 
-## 0.74.0 (19 Nov 2014)
+## 0.74.0 (2014-11-19)
 * Added support for more field/accessors naming conventions.
 * Added case sensitive versions of string comparison operators equalTo and notEqualTo.
 * Added where() to RealmList to initiate queries.
@@ -888,17 +948,17 @@ No changes since 0.91.1.
 * Consistent handling of UTF-8 strings.
 * removeFromRealm() now calls moveLastOver() which is faster and more reliable when deleting multiple objects.
 
-## 0.73.1 (05 Nov 2014)
+## 0.73.1 (2014-11-05)
 * Fixed a bug that would send infinite notifications in some instances.
 
-## 0.73.0 (04 Nov 2014)
+## 0.73.0 (2014-11-04)
 * Fixed a bug not allowing queries with more than 1024 conditions.
 * Rewritten the notification system. The API did not change but it's now much more reliable.
 * Added support for switching auto-refresh on and off (Realm.setAutoRefresh).
 * Added RealmBaseAdapter and an example using it.
 * Added deleteFromRealm() method to RealmObject.
 
-## 0.72.0 (27 Oct 2014)
+## 0.72.0 (2014-10-27)
 * Extended sorting support to more types: boolean, byte, short, int, long, float, double, Date, and String fields are now supported.
 * Better support for Java 7 and 8 in the annotations processor.
 * Better support for the Eclipse annotations processor.
@@ -908,7 +968,7 @@ No changes since 0.91.1.
 * Faster implementation of RealmQuery.findFirst().
 * Upgraded core to 0.85.1 (deep copying of strings in queries; preparation for link queries).
 
-## 0.71.0 (07 Oct 2014)
+## 0.71.0 (2014-10-07)
 * Simplified the release artifact to a single Jar file.
 * Added support for Eclipse.
 * Added support for deploying to Maven.
@@ -921,9 +981,9 @@ No changes since 0.91.1.
 * Added a new example about concurrency.
 * Upgraded to core 0.84.0.
 
-## 0.70.1 (30 Sep 2014)
+## 0.70.1 (2014-09-30)
 * Enabled unit testing for the realm project.
 * Fixed handling of camel-cased field names.
 
-## 0.70.0 (29 Sep 2014)
+## 0.70.0 (2014-09-29)
 * This is the first public beta release.
diff --git a/Dockerfile b/Dockerfile
index b3a8820a23..47bcded27d 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -48,11 +48,14 @@ RUN cd /opt && \
 
 # Grab what's needed in the SDK
 # ↓ updates tools to at least 25.1.7, but that prints 'Nothing was installed' (so I don't check the outputs).
+RUN mkdir "${ANDROID_HOME}/licenses" && \
+    echo -e "\n8933bad161af4178b1185d1a37fbf41ea5269c55" > "${ANDROID_HOME}/licenses/android-sdk-license" && \
+    echo -en "\nd23d63a1f23e25e2c7a316e29eb60396e7924281" > "${ANDROID_HOME}/licenses/android-sdk-preview-license"
 RUN echo y | android update sdk --no-ui --all --filter tools > /dev/null
 RUN echo y | android update sdk --no-ui --all --filter platform-tools | grep 'package installed'
-RUN echo y | android update sdk --no-ui --all --filter build-tools-24.0.0 | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter build-tools-25.0.2 | grep 'package installed'
 RUN echo y | android update sdk --no-ui --all --filter extra-android-m2repository | grep 'package installed'
-RUN echo y | android update sdk --no-ui --all --filter android-24 | grep 'package installed'
+RUN echo y | android update sdk --no-ui --all --filter android-25 | grep 'package installed'
 
 # Install the NDK
 RUN mkdir /opt/android-ndk-tmp && \
@@ -67,12 +70,13 @@ RUN mkdir /opt/android-ndk-tmp && \
 # Install cmake
 RUN mkdir /opt/cmake-tmp && \
     cd /opt/cmake-tmp && \
-    wget -q https://dl.google.com/android/repository/cmake-3.6.3133135-linux-x86_64.zip -O cmake-linux.zip && \
-    unzip cmake-linux.zip -d ${ANDROID_HOME}/cmake && \
+    wget -q https://dl.google.com/android/repository/cmake-3.6.3155560-linux-x86_64.zip -O cmake-linux.zip && \
+    mkdir -p ${ANDROID_HOME}/cmake/3.6.3155560 && \
+    unzip cmake-linux.zip -d ${ANDROID_HOME}/cmake/3.6.3155560 && \
     rm -rf /opt/cmake-tmp
 
-# Make the SDK universally readable
-RUN chmod -R a+rX ${ANDROID_HOME}
+# Make the SDK universally writable
+RUN chmod -R a+rwX ${ANDROID_HOME}
 
 # Install lcache
 RUN wget -q https://github.com/beeender/lcache/releases/download/v0.0.2/lcache-linux -O /usr/bin/lcache && \
diff --git a/Jenkinsfile b/Jenkinsfile
index 4356ad68aa..f8d9f2dccd 100644
--- a/Jenkinsfile
+++ b/Jenkinsfile
@@ -6,44 +6,45 @@ def buildSuccess = false
 def rosContainer
 try {
   node('android') {
-    // Allocate a custom workspace to avoid having % in the path (it breaks ld)
-    ws('/tmp/realm-java') {
-      stage('SCM') {
-        checkout([
-          $class: 'GitSCM',
-          branches: scm.branches,
-          gitTool: 'native git',
-          extensions: scm.extensions + [
-            [$class: 'CleanCheckout'],
-            [$class: 'SubmoduleOption', recursiveSubmodules: true]
-          ],
-          userRemoteConfigs: scm.userRemoteConfigs
-        ])
-      }
-
-      def buildEnv
-      def rosEnv
-      stage('Docker build') {
-        // Docker image for build
-        buildEnv = docker.build 'realm-java:snapshot'
-        // Docker image for testing Realm Object Server
-        def dependProperties = readProperties file: 'dependencies.list'
-        def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
-        rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
-      }
-
-      rosContainer = rosEnv.run('-v /tmp=/tmp/.ros')
-
-      try {
+    timeout(time: 1, unit: 'HOURS') {
+      // Allocate a custom workspace to avoid having % in the path (it breaks ld)
+      ws('/tmp/realm-java') {
+	stage('SCM') {
+	  checkout([
+		     $class: 'GitSCM',
+		    branches: scm.branches,
+		    gitTool: 'native git',
+		    extensions: scm.extensions + [
+		      [$class: 'CleanCheckout'],
+		      [$class: 'SubmoduleOption', recursiveSubmodules: true]
+		    ],
+		    userRemoteConfigs: scm.userRemoteConfigs
+		   ])
+	}
+
+	def buildEnv
+	def rosEnv
+	stage('Docker build') {
+	  // Docker image for build
+	  buildEnv = docker.build 'realm-java:snapshot'
+	  // Docker image for testing Realm Object Server
+	  def dependProperties = readProperties file: 'dependencies.list'
+	  def rosDeVersion = dependProperties["REALM_OBJECT_SERVER_DE_VERSION"]
+	  rosEnv = docker.build 'ros:snapshot', "--build-arg ROS_DE_VERSION=${rosDeVersion} tools/sync_test_server"
+	}
+
+	rosContainer = rosEnv.run('-v /tmp=/tmp/.ros')
+
+	try {
           buildEnv.inside("-e HOME=/tmp " +
-                  "-e _JAVA_OPTIONS=-Duser.home=/tmp " +
-                  "--privileged " +
-                  "-v /dev/bus/usb:/dev/bus/usb " +
-                  "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
-                  "-v ${env.HOME}/.android:/tmp/.android " +
-                  "-v ${env.HOME}/ccache:/tmp/.ccache " +
-                  "-v ${env.HOME}/lcache:/tmp/.lcache " +
-                  "--network container:${rosContainer.id}") {
+			  "-e _JAVA_OPTIONS=-Duser.home=/tmp " +
+			  "--privileged " +
+			  "-v /dev/bus/usb:/dev/bus/usb " +
+			  "-v ${env.HOME}/gradle-cache:/tmp/.gradle " +
+			  "-v ${env.HOME}/.android:/tmp/.android " +
+			  "-v ${env.HOME}/ccache:/tmp/.ccache " +
+			  "-v ${env.HOME}/lcache:/tmp/.lcache " +
+			  "--network container:${rosContainer.id}") {
             stage('JVM tests') {
               try {
                 withCredentials([[$class: 'FileBinding', credentialsId: 'c0cc8f9e-c3f1-4e22-b22f-6568392e26ae', variable: 'S3CFG']]) {
@@ -63,12 +64,12 @@ try {
                 publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/findbugs', reportFiles: 'findbugs-output.html', reportName: 'Findbugs issues'])
                 publishHTML(target: [allowMissing: false, alwaysLinkToLastBuild: false, keepAll: true, reportDir: 'realm/realm-library/build/reports/pmd', reportFiles: 'pmd.html', reportName: 'PMD Issues'])
                 step([$class: 'CheckStylePublisher',
-                canComputeNew: false,
-                defaultEncoding: '',
-                healthy: '',
-                pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
-                unHealthy: ''
-                ])
+		      canComputeNew: false,
+		      defaultEncoding: '',
+		      healthy: '',
+		      pattern: 'realm/realm-library/build/reports/checkstyle/checkstyle.xml',
+		      unHealthy: ''
+		     ])
               }
             }
 
@@ -102,14 +103,15 @@ try {
               }
             }
           }
-      } finally {
+	} finally {
           sh "docker logs ${rosContainer.id}"
           rosContainer.stop()
+	}
       }
     }
+    currentBuild.rawBuild.setResult(Result.SUCCESS)
+    buildSuccess = true
   }
-  currentBuild.rawBuild.setResult(Result.SUCCESS)
-  buildSuccess = true
 } catch(Exception e) {
   currentBuild.rawBuild.setResult(Result.FAILURE)
   buildSuccess = false
@@ -119,14 +121,14 @@ try {
     node {
       withCredentials([[$class: 'StringBinding', credentialsId: 'slack-java-url', variable: 'SLACK_URL']]) {
         def payload = JsonOutput.toJson([
-          username: 'Mr. Jenkins',
-          icon_emoji: ':jenkins:',
-          attachments: [[
-            'title': "The ${env.BRANCH_NAME} branch is broken!",
-            'text': "<${env.BUILD_URL}|Click here> to check the build.",
-            'color': "danger"
-          ]]
-        ])
+	    username: 'Mr. Jenkins',
+	    icon_emoji: ':jenkins:',
+	    attachments: [[
+	        'title': "The ${env.BRANCH_NAME} branch is broken!",
+		'text': "<${env.BUILD_URL}|Click here> to check the build.",
+		'color': "danger"
+	    ]]
+	])
         sh "curl -X POST --data-urlencode \'payload=${payload}\' ${env.SLACK_URL}"
       }
     }
@@ -151,10 +153,10 @@ def stopLogCatCollector(String backgroundPid, boolean archiveLog) {
   sh "kill ${backgroundPid}"
   if (archiveLog) {
     zip([
-      'zipFile': 'logcat.zip',
-      'archive': true,
-      'glob' : 'logcat.txt'
-    ])
+	  'zipFile': 'logcat.zip',
+	 'archive': true,
+	 'glob' : 'logcat.txt'
+	])
   }
   sh 'rm logcat.txt'
 }
@@ -173,9 +175,9 @@ def getTagsString(Map<String, String> tags) {
 
 def storeJunitResults(String path) {
   step([
-    $class: 'JUnitResultArchiver',
-    testResults: path
-  ])
+	 $class: 'JUnitResultArchiver',
+	testResults: path
+       ])
 }
 
 def collectAarMetrics() {
@@ -198,10 +200,10 @@ def collectAarMetrics() {
 
     def soFiles = findFiles(glob: "realm/realm-library/build/outputs/aar/unzipped${flavor}/jni/*/librealm-jni.so")
     for (def j = 0; j < soFiles.size(); j++) {
-        def soFile = soFiles[j]
-        def abiName = soFile.path.tokenize('/')[-2]
-        def libSize = soFile.length as String
-        sendMetrics('abi_size', libSize, ['flavor':flavor, 'type':abiName])
+      def soFile = soFiles[j]
+      def abiName = soFile.path.tokenize('/')[-2]
+      def libSize = soFile.length as String
+      sendMetrics('abi_size', libSize, ['flavor':flavor, 'type':abiName])
     }
   }
 }
diff --git a/README.md b/README.md
index b4dc035638..37ee3b95d1 100644
--- a/README.md
+++ b/README.md
@@ -60,7 +60,7 @@ In case you don't want to use the precompiled version, you can build Realm yours
 ### Prerequisites
 
  * Download the [**JDK 7**](http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html) or [**JDK 8**](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) from Oracle and install it.
- * Download & install the Android SDK **Build-Tools 24.0.0**, **Android N (API 24)** (for example through Android Studio’s **Android SDK Manager**).
+ * Download & install the Android SDK **Build-Tools 25.0.2**, **Android N (API 25)** (for example through Android Studio’s **Android SDK Manager**).
  * Install CMake from SDK manager in Android Studio ("SDK Tools" -> "CMake").
 
  * Realm currently requires version r10e of the NDK.  Download the one appropriate for your development platform, from the NDK [archive](https://developer.android.com/ndk/downloads/older_releases.html).
@@ -175,11 +175,12 @@ To run these tests you must have a device connected to the build computer and th
 
 1. Connect an Android device and verify that that the command `adb devices` shows a connected device:
 
-        ```sh
-        adb devices
-        List of devices attached
-        004c03eb5615429f	device
-        ```
+	```sh
+	adb devices
+	List of devices attached
+	004c03eb5615429f device
+	```
+   
 2. Run instrumentation tests:
 
 	```sh
diff --git a/dependencies.list b/dependencies.list
index ef11c2e0f6..538519aa4d 100644
--- a/dependencies.list
+++ b/dependencies.list
@@ -1,10 +1,13 @@
 # Realm Sync Core release used by Realm Java
 # https://github.com/realm/realm-sync/releases
-REALM_SYNC_VERSION=1.0.4
-REALM_SYNC_SHA256=a1d00577219b7c2749a0b4baa8b07ead2380bc47907fb2ce4b13cf59d26ca463
+REALM_SYNC_VERSION=1.3.0
+REALM_SYNC_SHA256=0572417435b92e3a9f7de5bd71ed00ca5d4ed24813afeffc7e4e7b7510a9f449
 
 # Object Server Release used by Integration tests
 # `realm` is stable releases, `realm-testing` is developer builds.
 # https://packagecloud.io/realm/realm?filter=debs
 # https://packagecloud.io/realm/realm-testing?filter=debs
-REALM_OBJECT_SERVER_DE_VERSION=1.0.0-BETA-6.1-133
+# /tools/sync_test_server/Dockerfile specify which repo (apt) we should
+# install/use between 'realm' and 'realm-testing', the version below should
+# correspond to an existing version on the *specified* repo.
+REALM_OBJECT_SERVER_DE_VERSION=1.2.1-270
diff --git a/examples/build.gradle b/examples/build.gradle
index 64b863d9f8..32279e957a 100644
--- a/examples/build.gradle
+++ b/examples/build.gradle
@@ -1,5 +1,5 @@
-project.ext.sdkVersion = 24
-project.ext.buildTools = '24.0.0'
+project.ext.sdkVersion = 25
+project.ext.buildTools = '25.0.2'
 
 // Don't cache SNAPSHOT (changing) dependencies.
 configurations.all {
@@ -9,6 +9,12 @@ configurations.all {
 allprojects {
     def currentVersion = file("${rootDir}/../version.txt").text.trim()
 
+    def props = new Properties()
+    props.load(new FileInputStream("${rootDir}/../realm.properties"))
+    props.each { key, val ->
+        project.ext.set(key, val)
+    }
+
     buildscript {
         repositories {
             mavenLocal()
@@ -16,7 +22,7 @@ allprojects {
             maven { url 'https://jitpack.io' }
         }
         dependencies {
-            classpath 'com.android.tools.build:gradle:2.2.0'
+            classpath 'com.android.tools.build:gradle:2.3.0'
             classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6'
             classpath 'com.github.JakeWharton:sdk-manager-plugin:0ce4cdf08009d79223850a59959d9d6e774d0f77'
             classpath 'com.novoda:gradle-android-command-plugin:1.5.0'
@@ -33,3 +39,7 @@ allprojects {
         jcenter()
     }
 }
+
+task wrapper(type: Wrapper) {
+    gradleVersion = project.gradleVersion
+}
diff --git a/examples/gradle/wrapper/gradle-wrapper.jar b/examples/gradle/wrapper/gradle-wrapper.jar
index 3baa851b28..35fb1ae090 100644
Binary files a/examples/gradle/wrapper/gradle-wrapper.jar and b/examples/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/examples/gradle/wrapper/gradle-wrapper.properties b/examples/gradle/wrapper/gradle-wrapper.properties
index f930473763..c7fdbdb551 100644
--- a/examples/gradle/wrapper/gradle-wrapper.properties
+++ b/examples/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Sep 20 14:25:59 CST 2016
+#Fri Mar 03 05:45:58 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
diff --git a/examples/gradlew b/examples/gradlew
index 27309d9231..4453ccea33 100755
--- a/examples/gradlew
+++ b/examples/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save ( ) {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/examples/gradlew.bat b/examples/gradlew.bat
index f6d5974e72..e95643d6a2 100644
--- a/examples/gradlew.bat
+++ b/examples/gradlew.bat
@@ -49,7 +49,6 @@ goto fail
 @rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/examples/kotlinExample/build.gradle b/examples/kotlinExample/build.gradle
index 8034025e63..79d9712d8a 100644
--- a/examples/kotlinExample/build.gradle
+++ b/examples/kotlinExample/build.gradle
@@ -1,5 +1,5 @@
 buildscript {
-    ext.kotlin_version = '1.0.6'
+    ext.kotlin_version = '1.1.0'
     repositories {
         jcenter()
         mavenCentral()
@@ -39,11 +39,6 @@ android {
         events 2000
     }
 
-    // Incremental builds currently doesn't work with Kotlin
-    dexOptions {
-        incremental false
-    }
-
     sourceSets {
         main.java.srcDirs += 'src/main/kotlin'
     }
diff --git a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
index 73f0663136..aba7c85d6e 100644
--- a/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
+++ b/examples/kotlinExample/src/main/kotlin/io/realm/examples/kotlin/KotlinExampleActivity.kt
@@ -64,9 +64,8 @@ class KotlinExampleActivity : Activity() {
 
         // More complex operations can be executed on another thread, for example using
         // Anko's async extension method.
-        async() {
-            var info: String
-            info = complexReadWrite()
+        async {
+            var info = complexReadWrite()
             info += complexQuery()
 
             uiThread {
@@ -134,51 +133,53 @@ class KotlinExampleActivity : Activity() {
         // Open the default realm. All threads must use its own reference to the realm.
         // Those can not be transferred across threads.
         val realm = Realm.getDefaultInstance()
-
-        // Add ten persons in one transaction
-        realm.executeTransaction {
-            val fido = realm.createObject(Dog::class.java)
-            fido.name = "fido"
-            for (i in 1..9) {
-                val person = realm.createObject(Person::class.java, i.toLong())
-                person.name = "Person no. $i"
-                person.age = i
-                person.dog = fido
-
-                // The field tempReference is annotated with @Ignore.
-                // This means setTempReference sets the Person tempReference
-                // field directly. The tempReference is NOT saved as part of
-                // the RealmObject:
-                person.tempReference = 42
-
-                for (j in 0..i - 1) {
-                    val cat = realm.createObject(Cat::class.java)
-                    cat.name = "Cat_$j"
-                    person.cats.add(cat)
+        try {
+            // Add ten persons in one transaction
+            realm.executeTransaction {
+                val fido = realm.createObject(Dog::class.java)
+                fido.name = "fido"
+                for (i in 1..9) {
+                    val person = realm.createObject(Person::class.java, i.toLong())
+                    person.name = "Person no. $i"
+                    person.age = i
+                    person.dog = fido
+
+                    // The field tempReference is annotated with @Ignore.
+                    // This means setTempReference sets the Person tempReference
+                    // field directly. The tempReference is NOT saved as part of
+                    // the RealmObject:
+                    person.tempReference = 42
+
+                    for (j in 0..i - 1) {
+                        val cat = realm.createObject(Cat::class.java)
+                        cat.name = "Cat_$j"
+                        person.cats.add(cat)
+                    }
                 }
             }
-        }
 
-        // Implicit read transactions allow you to access your objects
-        status += "\nNumber of persons: ${realm.where(Person::class.java).count()}"
+            // Implicit read transactions allow you to access your objects
+            status += "\nNumber of persons: ${realm.where(Person::class.java).count()}"
 
-        // Iterate over all objects
-        for (person in realm.where(Person::class.java).findAll()) {
-            val dogName: String = person?.dog?.name ?: "None"
+            // Iterate over all objects
+            for (person in realm.where(Person::class.java).findAll()) {
+                val dogName: String = person?.dog?.name ?: "None"
 
-            status += "\n${person.name}: ${person.age} : $dogName : ${person.cats.size}"
+                status += "\n${person.name}: ${person.age} : $dogName : ${person.cats.size}"
 
-            // The field tempReference is annotated with @Ignore
-            // Though we initially set its value to 42, it has
-            // not been saved as part of the Person RealmObject:
-            check(person.tempReference == 0)
-        }
+                // The field tempReference is annotated with @Ignore
+                // Though we initially set its value to 42, it has
+                // not been saved as part of the Person RealmObject:
+                check(person.tempReference == 0)
+            }
 
-        // Sorting
-        val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING)
-        status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
+            // Sorting
+            val sortedPersons = realm.where(Person::class.java).findAllSorted("age", Sort.DESCENDING)
+            status += "\nSorting ${sortedPersons.last().name} == ${realm.where(Person::class.java).findAll().first().name}"
 
-        realm.close()
+        } finally {
+            realm.close()
+        }
         return status
     }
 
diff --git a/examples/newsreaderExample/build.gradle b/examples/newsreaderExample/build.gradle
index 3809773b25..778186e266 100644
--- a/examples/newsreaderExample/build.gradle
+++ b/examples/newsreaderExample/build.gradle
@@ -34,9 +34,9 @@ android {
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
     //noinspection GradleDependency
-    compile 'com.android.support:appcompat-v7:24.0.0'
+    compile 'com.android.support:appcompat-v7:25.2.0'
     //noinspection GradleDependency
-    compile 'com.android.support:design:24.0.0'
+    compile 'com.android.support:design:25.2.0'
     compile 'io.reactivex:rxjava:1.1.0'
     compile 'io.reactivex:rxandroid:1.1.0'
     compile 'com.squareup.retrofit:retrofit:2.0.0-beta2'
diff --git a/examples/objectServerExample/build.gradle b/examples/objectServerExample/build.gradle
index 52a4c63f4a..8a42675c8a 100644
--- a/examples/objectServerExample/build.gradle
+++ b/examples/objectServerExample/build.gradle
@@ -60,8 +60,8 @@ realm {
 }
 
 dependencies {
-    compile 'com.android.support:support-v4:24.2.0'
-    compile 'com.android.support:design:24.2.0'
+    compile 'com.android.support:support-v4:25.2.0'
+    compile 'com.android.support:design:25.2.0'
     compile 'com.jakewharton:butterknife:8.3.0'
     annotationProcessor 'com.jakewharton:butterknife-compiler:8.3.0'
 }
diff --git a/examples/secureTokenAndroidKeyStore/build.gradle b/examples/secureTokenAndroidKeyStore/build.gradle
index 7222838bea..b523a941c8 100644
--- a/examples/secureTokenAndroidKeyStore/build.gradle
+++ b/examples/secureTokenAndroidKeyStore/build.gradle
@@ -2,13 +2,13 @@ apply plugin: 'com.android.application'
 apply plugin: 'realm-android'
 
 android {
-    compileSdkVersion 24
-    buildToolsVersion "24.0.0"
+    compileSdkVersion rootProject.sdkVersion
+    buildToolsVersion rootProject.buildTools
 
     defaultConfig {
         applicationId "io.realm.examples.securetokenandroidkeystore"
         minSdkVersion 9
-        targetSdkVersion 24
+        targetSdkVersion 25
         versionCode 1
         versionName "1.0"
 
@@ -28,11 +28,11 @@ dependencies {
     androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
         exclude group: 'com.android.support', module: 'support-annotations'
     })
-    compile 'com.android.support:appcompat-v7:24.2.0'
+    compile 'com.android.support:appcompat-v7:25.2.0'
     testCompile 'junit:junit:4.12'
     compile 'io.realm:android-secure-userstore:1.0.0'
 }
 
 realm {
     syncEnabled = true
-}
\ No newline at end of file
+}
diff --git a/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml b/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml
index 15f02a70aa..57be5d1083 100644
--- a/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml
+++ b/examples/secureTokenAndroidKeyStore/src/main/AndroidManifest.xml
@@ -4,8 +4,8 @@
 
     <application android:allowBackup="true" android:icon="@mipmap/ic_launcher"
         android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme"
-        android:name="examples.io.realm.securetokenandroidkeystore.MyApplication">
-        <activity android:name="examples.io.realm.securetokenandroidkeystore.MainActivity">
+        android:name="io.realm.examples.securetokenandroidkeystore.MyApplication">
+        <activity android:name="io.realm.examples.securetokenandroidkeystore.MainActivity">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
 
diff --git a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
index 97b51b752d..e478db6428 100644
--- a/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
+++ b/examples/unitTestExample/src/test/java/io/realm/examples/unittesting/ExampleActivityTest.java
@@ -47,7 +47,6 @@
 import io.realm.examples.unittesting.model.Person;
 import io.realm.internal.RealmCore;
 import io.realm.internal.Util;
-import io.realm.log.Logger;
 import io.realm.log.RealmLog;
 
 import static org.hamcrest.CoreMatchers.is;
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar
index 3baa851b28..d8af58cce0 100644
Binary files a/gradle-plugin/gradle/wrapper/gradle-wrapper.jar and b/gradle-plugin/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
index 4912622457..1e575420eb 100644
--- a/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle-plugin/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Sep 20 14:21:04 CST 2016
+#Thu Mar 02 03:11:23 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
diff --git a/gradle-plugin/gradlew b/gradle-plugin/gradlew
index 27309d9231..4453ccea33 100755
--- a/gradle-plugin/gradlew
+++ b/gradle-plugin/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save ( ) {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradle-plugin/gradlew.bat b/gradle-plugin/gradlew.bat
index f6d5974e72..e95643d6a2 100644
--- a/gradle-plugin/gradlew.bat
+++ b/gradle-plugin/gradlew.bat
@@ -49,7 +49,6 @@ goto fail
 @rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 3baa851b28..48a802eecf 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index bc6b7c4622..e330fabc4f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Sep 20 14:03:29 CST 2016
+#Thu Mar 02 03:10:56 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
diff --git a/gradlew b/gradlew
index 27309d9231..4453ccea33 100755
--- a/gradlew
+++ b/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save ( ) {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/gradlew.bat b/gradlew.bat
index f6d5974e72..e95643d6a2 100644
--- a/gradlew.bat
+++ b/gradlew.bat
@@ -49,7 +49,6 @@ goto fail
 @rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/realm-annotations/build.gradle b/realm-annotations/build.gradle
index a372797de3..40213eb437 100644
--- a/realm-annotations/build.gradle
+++ b/realm-annotations/build.gradle
@@ -8,6 +8,14 @@ buildscript {
     }
 }
 
+allprojects {
+    def props = new Properties()
+    props.load(new FileInputStream("${rootDir}/../realm.properties"))
+    props.each { key, val ->
+        project.ext.set(key, val)
+    }
+}
+
 apply plugin: 'java'
 apply plugin: 'maven'
 apply plugin: 'maven-publish'
@@ -103,3 +111,7 @@ artifactory {
         }
     }
 }
+
+task wrapper(type: Wrapper) {
+    gradleVersion = project.gradleVersion
+}
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.jar b/realm-annotations/gradle/wrapper/gradle-wrapper.jar
index 3baa851b28..366e45e879 100644
Binary files a/realm-annotations/gradle/wrapper/gradle-wrapper.jar and b/realm-annotations/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-annotations/gradle/wrapper/gradle-wrapper.properties b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
index a18e4af3f9..767373dd38 100644
--- a/realm-annotations/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-annotations/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Sep 20 14:22:29 CST 2016
+#Fri Mar 03 05:43:28 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
diff --git a/realm-annotations/gradlew b/realm-annotations/gradlew
index 27309d9231..4453ccea33 100755
--- a/realm-annotations/gradlew
+++ b/realm-annotations/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save ( ) {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/realm-annotations/gradlew.bat b/realm-annotations/gradlew.bat
index f6d5974e72..e95643d6a2 100644
--- a/realm-annotations/gradlew.bat
+++ b/realm-annotations/gradlew.bat
@@ -49,7 +49,6 @@ goto fail
 @rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/realm-transformer/build.gradle b/realm-transformer/build.gradle
index 2dc0dadb96..1c9eeff064 100644
--- a/realm-transformer/build.gradle
+++ b/realm-transformer/build.gradle
@@ -8,6 +8,14 @@ buildscript {
     }
 }
 
+allprojects {
+    def props = new Properties()
+    props.load(new FileInputStream("${rootDir}/../realm.properties"))
+    props.each { key, val ->
+        project.ext.set(key, val)
+    }
+}
+
 apply plugin: 'groovy'
 apply plugin: 'java'
 apply plugin: 'maven'
@@ -153,3 +161,8 @@ artifactory {
         }
     }
 }
+
+task wrapper(type: Wrapper) {
+    gradleVersion = project.gradleVersion
+}
+
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.jar b/realm-transformer/gradle/wrapper/gradle-wrapper.jar
index 3baa851b28..9fe1b93a5f 100644
Binary files a/realm-transformer/gradle/wrapper/gradle-wrapper.jar and b/realm-transformer/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm-transformer/gradle/wrapper/gradle-wrapper.properties b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
index e9bd4ba64f..e5aee03000 100644
--- a/realm-transformer/gradle/wrapper/gradle-wrapper.properties
+++ b/realm-transformer/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Sep 20 14:33:05 CST 2016
+#Fri Mar 03 05:41:34 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
diff --git a/realm-transformer/gradlew b/realm-transformer/gradlew
index 27309d9231..4453ccea33 100755
--- a/realm-transformer/gradlew
+++ b/realm-transformer/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save ( ) {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/realm-transformer/gradlew.bat b/realm-transformer/gradlew.bat
index f6d5974e72..e95643d6a2 100644
--- a/realm-transformer/gradlew.bat
+++ b/realm-transformer/gradlew.bat
@@ -49,7 +49,6 @@ goto fail
 @rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
index 82f3ac292b..d64572ea3c 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/BytecodeModifier.groovy
@@ -85,6 +85,14 @@ class BytecodeModifier {
         clazz.addInterface(proxyInterface)
     }
 
+    public static void callInjectObjectContextFromConstructors(CtClass clazz) {
+        clazz.getConstructors().each {
+            it.insertBeforeBody('if ($0 instanceof io.realm.internal.RealmObjectProxy) {' +
+                    ' ((io.realm.internal.RealmObjectProxy) $0).realm$injectObjectContext();' +
+                    ' }')
+        }
+    }
+
     /**
      * This class goes through all the field access behaviours of a class and replaces field accesses with
      * the appropriate accessor.
diff --git a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
index 94ee5af4f4..d7ca24a76a 100644
--- a/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
+++ b/realm-transformer/src/main/groovy/io/realm/transformer/RealmTransformer.groovy
@@ -26,7 +26,6 @@ import io.realm.annotations.Ignore
 import io.realm.annotations.RealmClass
 import javassist.ClassPool
 import javassist.CtClass
-import javassist.LoaderClassPath
 import org.gradle.api.Project
 import org.slf4j.Logger
 import org.slf4j.LoggerFactory
@@ -131,6 +130,7 @@ class RealmTransformer extends Transform {
         inputModelClasses.each {
             BytecodeModifier.addRealmAccessors(it)
             BytecodeModifier.addRealmProxyInterface(it, classPool)
+            BytecodeModifier.callInjectObjectContextFromConstructors(it)
         }
 
         // Use accessors instead of direct field access
diff --git a/realm.properties b/realm.properties
index 1be5af0639..c2f4f60551 100644
--- a/realm.properties
+++ b/realm.properties
@@ -1,2 +1,2 @@
-gradleVersion=2.14.1
+gradleVersion=3.4
 ndkVersion=r10e
diff --git a/realm/build.gradle b/realm/build.gradle
index d520cb8024..120340d00c 100644
--- a/realm/build.gradle
+++ b/realm/build.gradle
@@ -6,7 +6,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.2.2'
+        classpath 'com.android.tools.build:gradle:2.3.0'
         classpath 'de.undercouch:gradle-download-task:3.1.1'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
         classpath 'com.novoda:gradle-android-command-plugin:1.3.0'
diff --git a/realm/gradle/wrapper/gradle-wrapper.jar b/realm/gradle/wrapper/gradle-wrapper.jar
index 3baa851b28..b3558fded1 100644
Binary files a/realm/gradle/wrapper/gradle-wrapper.jar and b/realm/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/realm/gradle/wrapper/gradle-wrapper.properties b/realm/gradle/wrapper/gradle-wrapper.properties
index 897f3bf902..1f2857b24f 100644
--- a/realm/gradle/wrapper/gradle-wrapper.properties
+++ b/realm/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Tue Sep 20 14:03:59 CST 2016
+#Thu Mar 02 03:14:47 JST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.4-all.zip
diff --git a/realm/gradlew b/realm/gradlew
index 27309d9231..4453ccea33 100755
--- a/realm/gradlew
+++ b/realm/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -154,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save ( ) {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
+
+exec "$JAVACMD" "$@"
diff --git a/realm/gradlew.bat b/realm/gradlew.bat
index f6d5974e72..e95643d6a2 100644
--- a/realm/gradlew.bat
+++ b/realm/gradlew.bat
@@ -49,7 +49,6 @@ goto fail
 @rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/realm/realm-annotations-processor/build.gradle b/realm/realm-annotations-processor/build.gradle
index ac1e0ba50c..67d444c432 100644
--- a/realm/realm-annotations-processor/build.gradle
+++ b/realm/realm-annotations-processor/build.gradle
@@ -11,11 +11,11 @@ dependencies {
     compile group:'com.squareup', name:'javawriter', version:'2.5.0'
     compile "io.realm:realm-annotations:${version}"
 
-    testCompile files('../realm-library/build/intermediates/bundles/base/release/classes.jar') // Java projects cannot depend on AAR files
+    testCompile files('../realm-library/build/intermediates/bundles/baseRelease/classes.jar') // Java projects cannot depend on AAR files
     testCompile files("${System.properties['java.home']}/../lib/tools.jar") // This is needed otherwise compile-testing won't be able to find it
     testCompile group:'junit', name:'junit', version:'4.12'
     testCompile group:'com.google.testing.compile', name:'compile-testing', version:'0.6'
-    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-24/android.jar"))
+    testCompile files(file("${System.env.ANDROID_HOME}/platforms/android-25/android.jar"))
 }
 
 // for Ant filter
@@ -38,7 +38,7 @@ sourceSets {
 }
 
 compileJava.dependsOn generateVersionClass
-compileTestJava.dependsOn ':realm-library:assemble'
+compileTestJava.dependsOn ':realm-library:assembleBaseRelease'
 
 task ojoUpload() {
     dependsOn "artifactoryPublish"
diff --git a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
index eb99fbeb6e..6aa0cf7e0e 100644
--- a/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
+++ b/realm/realm-annotations-processor/src/main/java/io/realm/processor/RealmProxyClassGenerator.java
@@ -73,7 +73,6 @@ public void generate() throws IOException, UnsupportedOperationException {
         imports.add("io.realm.internal.RealmObjectProxy");
         imports.add("io.realm.internal.Row");
         imports.add("io.realm.internal.Table");
-        imports.add("io.realm.internal.TableOrView");
         imports.add("io.realm.internal.SharedRealm");
         imports.add("io.realm.internal.LinkView");
         imports.add("io.realm.internal.android.JsonUtils");
@@ -228,9 +227,6 @@ private void emitClassFields(JavaWriter writer) throws IOException {
     private void emitConstructor(JavaWriter writer) throws IOException {
         // FooRealmProxy(ColumnInfo)
         writer.beginConstructor(EnumSet.noneOf(Modifier.class));
-        writer.beginControlFlow("if (proxyState == null)")
-                .emitStatement("injectObjectContext()")
-                .endControlFlow();
         writer.emitStatement("proxyState.setConstructionFinished()");
         writer.endConstructor();
         writer.emitEmptyLine();
@@ -250,7 +246,6 @@ private void emitAccessors(final JavaWriter writer) throws IOException {
                 // Getter
                 writer.emitAnnotation("SuppressWarnings", "\"cast\"");
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
 
                 // For String and bytes[], null value will be returned by JNI code. Try to save one JNI call here.
@@ -276,7 +271,6 @@ private void emitAccessors(final JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                emitCodeForInjectingObjectContext(writer);
                 emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
                     @Override
                     public void emit(JavaWriter writer) throws IOException {
@@ -331,7 +325,6 @@ public void emit(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.beginControlFlow("if (proxyState.getRow$realm().isNullLink(%s))", fieldIndexVariableReference(field));
                         writer.emitStatement("return null");
@@ -343,7 +336,6 @@ public void emit(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                emitCodeForInjectingObjectContext(writer);
                 emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
                     @Override
                     public void emit(JavaWriter writer) throws IOException {
@@ -395,7 +387,6 @@ public void emit(JavaWriter writer) throws IOException {
 
                 // Getter
                 writer.beginMethod(fieldTypeCanonicalName, metadata.getGetter(fieldName), EnumSet.of(Modifier.PUBLIC));
-                emitCodeForInjectingObjectContext(writer);
                 writer.emitStatement("proxyState.getRealm$realm().checkIfValid()");
                 writer.emitSingleLineComment("use the cached value if available");
                 writer.beginControlFlow("if (" + fieldName + "RealmList != null)");
@@ -412,7 +403,6 @@ public void emit(JavaWriter writer) throws IOException {
 
                 // Setter
                 writer.beginMethod("void", metadata.getSetter(fieldName), EnumSet.of(Modifier.PUBLIC), fieldTypeCanonicalName, "value");
-                emitCodeForInjectingObjectContext(writer);
                 emitCodeForUnderConstruction(writer, metadata.isPrimaryKey(field), new CodeEmitter() {
                     @Override
                     public void emit(JavaWriter writer) throws IOException {
@@ -462,17 +452,6 @@ public void emit(JavaWriter writer) throws IOException {
         }
     }
 
-    private void emitCodeForInjectingObjectContext(JavaWriter writer) throws IOException {
-        // if invoked from model's constructor, inject BaseRealm and Row
-        writer.beginControlFlow("if (proxyState == null)");
-        {
-            writer.emitSingleLineComment("Called from model's constructor. Inject context.");
-            writer.emitStatement("injectObjectContext()");
-        }
-        writer.endControlFlow();
-        writer.emitEmptyLine();
-    }
-
     private interface CodeEmitter {
         void emit(JavaWriter writer) throws IOException;
     }
@@ -494,15 +473,19 @@ private void emitCodeForUnderConstruction(JavaWriter writer, boolean isPrimaryKe
     }
 
     private void emitInjectContextMethod(JavaWriter writer) throws IOException {
+        writer.emitAnnotation("Override");
         writer.beginMethod(
                 "void", // Return type
-                "injectObjectContext", // Method name
-                EnumSet.of(Modifier.PRIVATE) // Modifiers
+                "realm$injectObjectContext", // Method name
+                EnumSet.of(Modifier.PUBLIC) // Modifiers
                 ); // Argument type & argument name
 
+        writer.beginControlFlow("if (this.proxyState != null)");
+        writer.emitStatement("return");
+        writer.endControlFlow();
         writer.emitStatement("final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get()");
         writer.emitStatement("this.columnInfo = (%1$s) context.getColumnInfo()", columnInfoClassName());
-        writer.emitStatement("this.proxyState = new ProxyState<%1$s>(%1$s.class, this)", qualifiedClassName);
+        writer.emitStatement("this.proxyState = new ProxyState<%1$s>(this)", qualifiedClassName);
         writer.emitStatement("proxyState.setRealm$realm(context.getRealm())");
         writer.emitStatement("proxyState.setRow$realm(context.getRow())");
         writer.emitStatement("proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue())");
@@ -512,7 +495,6 @@ private void emitInjectContextMethod(JavaWriter writer) throws IOException {
         writer.emitEmptyLine();
     }
 
-
     private void emitRealmObjectProxyImplementation(JavaWriter writer) throws IOException {
         writer.emitAnnotation("Override");
         writer.beginMethod("ProxyState", "realmGet$proxyState", EnumSet.of(Modifier.PUBLIC));
@@ -734,7 +716,7 @@ private void emitValidateTableMethod(JavaWriter writer) throws IOException {
                     // check before migrating a nullable field containing null value to not-nullable PrimaryKey field for Realm version 0.89+
                     if (metadata.isPrimaryKey(field)) {
                         writer
-                            .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != TableOrView.NO_MATCH)",
+                            .beginControlFlow("if (table.isColumnNullable(%s) && table.findFirstNull(%s) != Table.NO_MATCH)",
                                     fieldIndexVariableReference(field), fieldIndexVariableReference(field))
                             .emitStatement("throw new IllegalStateException(\"Cannot migrate an object with null value in field '%s'." +
                                     " Either maintain the same type for primary key field '%s', or remove the object with null value before migration.\")",
@@ -875,7 +857,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                     if (Utils.isString(primaryKeyElement)) {
                         writer
                             .emitStatement("String value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                            .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                            .emitStatement("long rowIndex = Table.NO_MATCH")
                             .beginControlFlow("if (value == null)")
                                 .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                             .nextControlFlow("else")
@@ -884,7 +866,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                     } else {
                         writer
                             .emitStatement("Number value = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                            .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                            .emitStatement("long rowIndex = Table.NO_MATCH")
                             .beginControlFlow("if (value == null)")
                                 .emitStatement("rowIndex = table.findFirstNull(pkColumnIndex)")
                             .nextControlFlow("else")
@@ -898,7 +880,7 @@ private void emitCopyOrUpdateMethod(JavaWriter writer) throws IOException {
                 }
 
                 writer
-                    .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
+                    .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
                         .beginControlFlow("try")
                             .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
                                     " realm.schema.getColumnInfo(%s.class)," +
@@ -1346,7 +1328,7 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
                 if (Utils.isString(primaryKeyElement)) {
                     writer
                         .emitStatement("String primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                        .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                        .emitStatement("long rowIndex = Table.NO_MATCH")
                         .beginControlFlow("if (primaryKeyValue == null)")
                         .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                         .nextControlFlow("else")
@@ -1355,7 +1337,7 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
                 } else {
                     writer
                         .emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter)
-                        .emitStatement("long rowIndex = TableOrView.NO_MATCH")
+                        .emitStatement("long rowIndex = Table.NO_MATCH")
                         .beginControlFlow("if (primaryKeyValue == null)")
                         .emitStatement("rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex)")
                         .nextControlFlow("else")
@@ -1363,7 +1345,7 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
                         .endControlFlow();
                 }
             } else {
-                writer.emitStatement("long rowIndex = TableOrView.NO_MATCH");
+                writer.emitStatement("long rowIndex = Table.NO_MATCH");
                 writer.emitStatement("Object primaryKeyValue = ((%s) object).%s()", interfaceName, primaryKeyGetter);
                 writer.beginControlFlow("if (primaryKeyValue != null)");
 
@@ -1375,7 +1357,7 @@ private void addPrimaryKeyCheckIfNeeded(ClassMetaData metadata, boolean throwIfP
                 writer.endControlFlow();
             }
 
-            writer.beginControlFlow("if (rowIndex == TableOrView.NO_MATCH)");
+            writer.beginControlFlow("if (rowIndex == Table.NO_MATCH)");
             if (Utils.isString(metadata.getPrimaryKey())) {
                 writer.emitStatement("rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false)");
             } else {
@@ -1744,7 +1726,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                 .beginControlFlow("if (update)")
                     .emitStatement("Table table = realm.getTable(%s.class)", qualifiedClassName)
                     .emitStatement("long pkColumnIndex = table.getPrimaryKey()")
-                    .emitStatement("long rowIndex = TableOrView.NO_MATCH");
+                    .emitStatement("long rowIndex = Table.NO_MATCH");
             if (metadata.isNullable(metadata.getPrimaryKey())) {
                 writer
                     .beginControlFlow("if (json.isNull(\"%s\"))", metadata.getPrimaryKey().getSimpleName())
@@ -1761,7 +1743,7 @@ private void emitCreateOrUpdateUsingJsonObject(JavaWriter writer) throws IOExcep
                     .endControlFlow();
             }
             writer
-                    .beginControlFlow("if (rowIndex != TableOrView.NO_MATCH)")
+                    .beginControlFlow("if (rowIndex != Table.NO_MATCH)")
                         .emitStatement("final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get()")
                         .beginControlFlow("try")
                             .emitStatement("objectContext.set(realm, table.getUncheckedRow(rowIndex)," +
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
index 7bf9205056..7666014010 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/AllTypesRealmProxy.java
@@ -14,7 +14,6 @@
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import io.realm.log.RealmLog;
 import java.io.IOException;
@@ -110,16 +109,17 @@ public final AllTypesColumnInfo clone() {
     }
 
     AllTypesRealmProxy() {
-        if (proxyState == null) {
-            injectObjectContext();
-        }
         proxyState.setConstructionFinished();
     }
 
-    private void injectObjectContext() {
+    @Override
+    public void realm$injectObjectContext() {
+        if (this.proxyState != null) {
+            return;
+        }
         final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
         this.columnInfo = (AllTypesColumnInfo) context.getColumnInfo();
-        this.proxyState = new ProxyState<some.test.AllTypes>(some.test.AllTypes.class, this);
+        this.proxyState = new ProxyState<some.test.AllTypes>(this);
         proxyState.setRealm$realm(context.getRealm());
         proxyState.setRow$realm(context.getRow());
         proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
@@ -128,21 +128,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public String realmGet$columnString() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.columnStringIndex);
     }
 
     public void realmSet$columnString(String value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             // default value of the primary key is always ignored.
             return;
@@ -154,21 +144,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public long realmGet$columnLong() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (long) proxyState.getRow$realm().getLong(columnInfo.columnLongIndex);
     }
 
     public void realmSet$columnLong(long value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -184,21 +164,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public float realmGet$columnFloat() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (float) proxyState.getRow$realm().getFloat(columnInfo.columnFloatIndex);
     }
 
     public void realmSet$columnFloat(float value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -214,21 +184,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public double realmGet$columnDouble() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (double) proxyState.getRow$realm().getDouble(columnInfo.columnDoubleIndex);
     }
 
     public void realmSet$columnDouble(double value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -244,21 +204,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public boolean realmGet$columnBoolean() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.columnBooleanIndex);
     }
 
     public void realmSet$columnBoolean(boolean value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -274,21 +224,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Date realmGet$columnDate() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.columnDateIndex);
     }
 
     public void realmSet$columnDate(Date value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -310,21 +250,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public byte[] realmGet$columnBinary() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.columnBinaryIndex);
     }
 
     public void realmSet$columnBinary(byte[] value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -345,11 +275,6 @@ private void injectObjectContext() {
     }
 
     public some.test.AllTypes realmGet$columnObject() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.columnObjectIndex)) {
             return null;
@@ -358,11 +283,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$columnObject(some.test.AllTypes value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -404,11 +324,6 @@ private void injectObjectContext() {
     }
 
     public RealmList<some.test.AllTypes> realmGet$columnRealmList() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         // use the cached value if available
         if (columnRealmListRealmList != null) {
@@ -421,11 +336,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$columnRealmList(RealmList<some.test.AllTypes> value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -655,13 +565,13 @@ public static String getTableName() {
         if (update) {
             Table table = realm.getTable(some.test.AllTypes.class);
             long pkColumnIndex = table.getPrimaryKey();
-            long rowIndex = TableOrView.NO_MATCH;
+            long rowIndex = Table.NO_MATCH;
             if (json.isNull("columnString")) {
                 rowIndex = table.findFirstNull(pkColumnIndex);
             } else {
                 rowIndex = table.findFirstString(pkColumnIndex, json.getString("columnString"));
             }
-            if (rowIndex != TableOrView.NO_MATCH) {
+            if (rowIndex != Table.NO_MATCH) {
                 final BaseRealm.RealmObjectContext objectContext = BaseRealm.objectContext.get();
                 try {
                     objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.schema.getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
@@ -873,13 +783,13 @@ public static String getTableName() {
                 Table table = realm.getTable(some.test.AllTypes.class);
                 long pkColumnIndex = table.getPrimaryKey();
                 String value = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-                long rowIndex = TableOrView.NO_MATCH;
+                long rowIndex = Table.NO_MATCH;
                 if (value == null) {
                     rowIndex = table.findFirstNull(pkColumnIndex);
                 } else {
                     rowIndex = table.findFirstString(pkColumnIndex, value);
                 }
-                if (rowIndex != TableOrView.NO_MATCH) {
+                if (rowIndex != Table.NO_MATCH) {
                     try {
                         objectContext.set(realm, table.getUncheckedRow(rowIndex), realm.schema.getColumnInfo(some.test.AllTypes.class), false, Collections.<String> emptyList());
                         realmObject = new io.realm.AllTypesRealmProxy();
@@ -954,13 +864,13 @@ public static long insert(Realm realm, some.test.AllTypes object, Map<RealmModel
         AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
         long pkColumnIndex = table.getPrimaryKey();
         String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-        long rowIndex = TableOrView.NO_MATCH;
+        long rowIndex = Table.NO_MATCH;
         if (primaryKeyValue == null) {
             rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
         } else {
             rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
         }
-        if (rowIndex == TableOrView.NO_MATCH) {
+        if (rowIndex == Table.NO_MATCH) {
             rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
         } else {
             Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
@@ -1017,13 +927,13 @@ public static void insert(Realm realm, Iterator<? extends RealmModel> objects, M
                     continue;
                 }
                 String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-                long rowIndex = TableOrView.NO_MATCH;
+                long rowIndex = Table.NO_MATCH;
                 if (primaryKeyValue == null) {
                     rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
                 } else {
                     rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
                 }
-                if (rowIndex == TableOrView.NO_MATCH) {
+                if (rowIndex == Table.NO_MATCH) {
                     rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
                 } else {
                     Table.throwDuplicatePrimaryKeyException(primaryKeyValue);
@@ -1076,13 +986,13 @@ public static long insertOrUpdate(Realm realm, some.test.AllTypes object, Map<Re
         AllTypesColumnInfo columnInfo = (AllTypesColumnInfo) realm.schema.getColumnInfo(some.test.AllTypes.class);
         long pkColumnIndex = table.getPrimaryKey();
         String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-        long rowIndex = TableOrView.NO_MATCH;
+        long rowIndex = Table.NO_MATCH;
         if (primaryKeyValue == null) {
             rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
         } else {
             rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
         }
-        if (rowIndex == TableOrView.NO_MATCH) {
+        if (rowIndex == Table.NO_MATCH) {
             rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
         }
         cache.put(object, rowIndex);
@@ -1144,13 +1054,13 @@ public static void insertOrUpdate(Realm realm, Iterator<? extends RealmModel> ob
                     continue;
                 }
                 String primaryKeyValue = ((AllTypesRealmProxyInterface) object).realmGet$columnString();
-                long rowIndex = TableOrView.NO_MATCH;
+                long rowIndex = Table.NO_MATCH;
                 if (primaryKeyValue == null) {
                     rowIndex = Table.nativeFindFirstNull(tableNativePtr, pkColumnIndex);
                 } else {
                     rowIndex = Table.nativeFindFirstString(tableNativePtr, pkColumnIndex, primaryKeyValue);
                 }
-                if (rowIndex == TableOrView.NO_MATCH) {
+                if (rowIndex == Table.NO_MATCH) {
                     rowIndex = table.addEmptyRowWithPrimaryKey(primaryKeyValue, false);
                 }
                 cache.put(object, rowIndex);
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
index da1971a009..8906eb90e6 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/BooleansRealmProxy.java
@@ -14,7 +14,6 @@
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import io.realm.log.RealmLog;
 import java.io.IOException;
@@ -84,16 +83,17 @@ public final BooleansColumnInfo clone() {
     }
 
     BooleansRealmProxy() {
-        if (proxyState == null) {
-            injectObjectContext();
-        }
         proxyState.setConstructionFinished();
     }
 
-    private void injectObjectContext() {
+    @Override
+    public void realm$injectObjectContext() {
+        if (this.proxyState != null) {
+            return;
+        }
         final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
         this.columnInfo = (BooleansColumnInfo) context.getColumnInfo();
-        this.proxyState = new ProxyState<some.test.Booleans>(some.test.Booleans.class, this);
+        this.proxyState = new ProxyState<some.test.Booleans>(this);
         proxyState.setRealm$realm(context.getRealm());
         proxyState.setRow$realm(context.getRow());
         proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
@@ -102,21 +102,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public boolean realmGet$done() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.doneIndex);
     }
 
     public void realmSet$done(boolean value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -132,21 +122,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public boolean realmGet$isReady() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.isReadyIndex);
     }
 
     public void realmSet$isReady(boolean value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -162,21 +142,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public boolean realmGet$mCompleted() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.mCompletedIndex);
     }
 
     public void realmSet$mCompleted(boolean value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -192,21 +162,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public boolean realmGet$anotherBoolean() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.anotherBooleanIndex);
     }
 
     public void realmSet$anotherBoolean(boolean value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
index 88e3de0cca..a541004034 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/NullTypesRealmProxy.java
@@ -14,7 +14,6 @@
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import io.realm.log.RealmLog;
 import java.io.IOException;
@@ -169,16 +168,17 @@ public final NullTypesColumnInfo clone() {
     }
 
     NullTypesRealmProxy() {
-        if (proxyState == null) {
-            injectObjectContext();
-        }
         proxyState.setConstructionFinished();
     }
 
-    private void injectObjectContext() {
+    @Override
+    public void realm$injectObjectContext() {
+        if (this.proxyState != null) {
+            return;
+        }
         final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
         this.columnInfo = (NullTypesColumnInfo) context.getColumnInfo();
-        this.proxyState = new ProxyState<some.test.NullTypes>(some.test.NullTypes.class, this);
+        this.proxyState = new ProxyState<some.test.NullTypes>(this);
         proxyState.setRealm$realm(context.getRealm());
         proxyState.setRow$realm(context.getRow());
         proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
@@ -187,21 +187,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNotNullIndex);
     }
 
     public void realmSet$fieldStringNotNull(String value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -223,21 +213,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public String realmGet$fieldStringNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.fieldStringNullIndex);
     }
 
     public void realmSet$fieldStringNull(String value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -261,21 +241,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (boolean) proxyState.getRow$realm().getBoolean(columnInfo.fieldBooleanNotNullIndex);
     }
 
     public void realmSet$fieldBooleanNotNull(Boolean value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -297,11 +267,6 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Boolean realmGet$fieldBooleanNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldBooleanNullIndex)) {
             return null;
@@ -310,11 +275,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldBooleanNull(Boolean value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -338,21 +298,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNotNullIndex);
     }
 
     public void realmSet$fieldBytesNotNull(byte[] value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -374,21 +324,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public byte[] realmGet$fieldBytesNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (byte[]) proxyState.getRow$realm().getBinaryByteArray(columnInfo.fieldBytesNullIndex);
     }
 
     public void realmSet$fieldBytesNull(byte[] value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -412,21 +352,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (byte) proxyState.getRow$realm().getLong(columnInfo.fieldByteNotNullIndex);
     }
 
     public void realmSet$fieldByteNotNull(Byte value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -448,11 +378,6 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Byte realmGet$fieldByteNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldByteNullIndex)) {
             return null;
@@ -461,11 +386,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldByteNull(Byte value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -489,21 +409,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (short) proxyState.getRow$realm().getLong(columnInfo.fieldShortNotNullIndex);
     }
 
     public void realmSet$fieldShortNotNull(Short value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -525,11 +435,6 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Short realmGet$fieldShortNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldShortNullIndex)) {
             return null;
@@ -538,11 +443,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldShortNull(Short value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -566,21 +466,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (int) proxyState.getRow$realm().getLong(columnInfo.fieldIntegerNotNullIndex);
     }
 
     public void realmSet$fieldIntegerNotNull(Integer value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -602,11 +492,6 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Integer realmGet$fieldIntegerNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldIntegerNullIndex)) {
             return null;
@@ -615,11 +500,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldIntegerNull(Integer value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -643,21 +523,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (long) proxyState.getRow$realm().getLong(columnInfo.fieldLongNotNullIndex);
     }
 
     public void realmSet$fieldLongNotNull(Long value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -679,11 +549,6 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Long realmGet$fieldLongNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldLongNullIndex)) {
             return null;
@@ -692,11 +557,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldLongNull(Long value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -720,21 +580,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (float) proxyState.getRow$realm().getFloat(columnInfo.fieldFloatNotNullIndex);
     }
 
     public void realmSet$fieldFloatNotNull(Float value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -756,11 +606,6 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Float realmGet$fieldFloatNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldFloatNullIndex)) {
             return null;
@@ -769,11 +614,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldFloatNull(Float value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -797,21 +637,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (double) proxyState.getRow$realm().getDouble(columnInfo.fieldDoubleNotNullIndex);
     }
 
     public void realmSet$fieldDoubleNotNull(Double value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -833,11 +663,6 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Double realmGet$fieldDoubleNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldDoubleNullIndex)) {
             return null;
@@ -846,11 +671,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldDoubleNull(Double value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -874,21 +694,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNotNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (java.util.Date) proxyState.getRow$realm().getDate(columnInfo.fieldDateNotNullIndex);
     }
 
     public void realmSet$fieldDateNotNull(Date value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -910,11 +720,6 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public Date realmGet$fieldDateNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNull(columnInfo.fieldDateNullIndex)) {
             return null;
@@ -923,11 +728,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldDateNull(Date value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -950,11 +750,6 @@ private void injectObjectContext() {
     }
 
     public some.test.NullTypes realmGet$fieldObjectNull() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         if (proxyState.getRow$realm().isNullLink(columnInfo.fieldObjectNullIndex)) {
             return null;
@@ -963,11 +758,6 @@ private void injectObjectContext() {
     }
 
     public void realmSet$fieldObjectNull(some.test.NullTypes value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
diff --git a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
index bd50bf8120..694515e02c 100644
--- a/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
+++ b/realm/realm-annotations-processor/src/test/resources/io/realm/SimpleRealmProxy.java
@@ -14,7 +14,6 @@
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
 import io.realm.internal.android.JsonUtils;
 import io.realm.log.RealmLog;
 import java.io.IOException;
@@ -74,16 +73,17 @@ public final SimpleColumnInfo clone() {
     }
 
     SimpleRealmProxy() {
-        if (proxyState == null) {
-            injectObjectContext();
-        }
         proxyState.setConstructionFinished();
     }
 
-    private void injectObjectContext() {
+    @Override
+    public void realm$injectObjectContext() {
+        if (this.proxyState != null) {
+            return;
+        }
         final BaseRealm.RealmObjectContext context = BaseRealm.objectContext.get();
         this.columnInfo = (SimpleColumnInfo) context.getColumnInfo();
-        this.proxyState = new ProxyState<some.test.Simple>(some.test.Simple.class, this);
+        this.proxyState = new ProxyState<some.test.Simple>(this);
         proxyState.setRealm$realm(context.getRealm());
         proxyState.setRow$realm(context.getRow());
         proxyState.setAcceptDefaultValue$realm(context.getAcceptDefaultValue());
@@ -92,21 +92,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public String realmGet$name() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (java.lang.String) proxyState.getRow$realm().getString(columnInfo.nameIndex);
     }
 
     public void realmSet$name(String value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
@@ -130,21 +120,11 @@ private void injectObjectContext() {
 
     @SuppressWarnings("cast")
     public int realmGet$age() {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         proxyState.getRealm$realm().checkIfValid();
         return (int) proxyState.getRow$realm().getLong(columnInfo.ageIndex);
     }
 
     public void realmSet$age(int value) {
-        if (proxyState == null) {
-            // Called from model's constructor. Inject context.
-            injectObjectContext();
-        }
-
         if (proxyState.isUnderConstruction()) {
             if (!proxyState.getAcceptDefaultValue$realm()) {
                 return;
diff --git a/realm/realm-library/build.gradle b/realm/realm-library/build.gradle
index ac7f1affbd..b7b5097c1f 100644
--- a/realm/realm-library/build.gradle
+++ b/realm/realm-library/build.gradle
@@ -33,12 +33,12 @@ ext.ccachePath = project.findProperty('ccachePath') ?: System.getenv('NDK_CCACHE
 ext.lcachePath = project.findProperty('lcachePath') ?: System.getenv('NDK_LCACHE')
 
 android {
-    compileSdkVersion 24
-    buildToolsVersion '24.0.0'
+    compileSdkVersion 25
+    buildToolsVersion '25.0.2'
 
     defaultConfig {
         minSdkVersion 9
-        targetSdkVersion 24
+        targetSdkVersion 25
         versionName version
         project.archivesBaseName = "realm-android-library"
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
@@ -131,7 +131,7 @@ dependencies {
     compile 'com.getkeepsafe.relinker:relinker:1.2.2'
     objectServerCompile 'com.squareup.okhttp3:okhttp:3.4.1'
     androidTestCompile 'io.reactivex:rxjava:1.1.0'
-    androidTestCompile 'com.android.support:support-annotations:24.0.0'
+    androidTestCompile 'com.android.support:support-annotations:25.2.0'
     androidTestCompile 'com.android.support.test:runner:0.5'
     androidTestCompile 'com.android.support.test:rules:0.5'
     androidTestCompile 'com.google.dexmaker:dexmaker:1.2'
@@ -529,28 +529,30 @@ project.afterEvaluate {
     }
 }
 
-task checkNdk() << {
-    def ndkPathInEnvVariable = System.env.ANDROID_NDK_HOME
-    if (!ndkPathInEnvVariable) {
-        throw new GradleException("The environment variable 'ANDROID_NDK_HOME' must be set.")
-    }
-    checkNdk(ndkPathInEnvVariable)
-
-    def localPropFile = rootProject.file('local.properties')
-    if (!localPropFile.exists()) {
-        // we can skip the checks since 'ANDROID_NDK_HOME' will be used instead.
-    } else {
-        def String ndkPathInLocalProperties = getValueFromPropertiesFile(localPropFile, 'ndk.dir')
-        if (!ndkPathInLocalProperties) {
-            throw new GradleException("'ndk.dir' must be set in ${localPropFile.getAbsolutePath()}.")
-        }
-        checkNdk(ndkPathInLocalProperties)
-        if (new File(ndkPathInLocalProperties).getCanonicalPath()
-                != new File(ndkPathInEnvVariable).getCanonicalPath()) {
-            throw new GradleException(
-                    "The value of environment variable 'ANDROID_NDK_HOME' (${ndkPathInEnvVariable}) and"
-                            + " 'ndk.dir' in 'local.properties' (${ndkPathInLocalProperties}) "
-                            + ' must point the same directory.')
+task checkNdk() {
+    doLast {
+        def ndkPathInEnvVariable = System.env.ANDROID_NDK_HOME
+        if (!ndkPathInEnvVariable) {
+            throw new GradleException("The environment variable 'ANDROID_NDK_HOME' must be set.")
+        }
+        checkNdk(ndkPathInEnvVariable)
+
+        def localPropFile = rootProject.file('local.properties')
+        if (!localPropFile.exists()) {
+            // we can skip the checks since 'ANDROID_NDK_HOME' will be used instead.
+        } else {
+            def String ndkPathInLocalProperties = getValueFromPropertiesFile(localPropFile, 'ndk.dir')
+            if (!ndkPathInLocalProperties) {
+                throw new GradleException("'ndk.dir' must be set in ${localPropFile.getAbsolutePath()}.")
+            }
+            checkNdk(ndkPathInLocalProperties)
+            if (new File(ndkPathInLocalProperties).getCanonicalPath()
+                    != new File(ndkPathInEnvVariable).getCanonicalPath()) {
+                throw new GradleException(
+                        "The value of environment variable 'ANDROID_NDK_HOME' (${ndkPathInEnvVariable}) and"
+                                + " 'ndk.dir' in 'local.properties' (${ndkPathInLocalProperties}) "
+                                + ' must point the same directory.')
+            }
         }
     }
 }
diff --git a/realm/realm-library/proguard-rules-base.pro b/realm/realm-library/proguard-rules-base.pro
index 26e41702f8..19a3b8d3ba 100644
--- a/realm/realm-library/proguard-rules-base.pro
+++ b/realm/realm-library/proguard-rules-base.pro
@@ -1,2 +1,2 @@
 # It's OK not to exist SyncObjectServerFacade in base library.
--dontnote io.realm.internal.objectserver.SyncObjectServerFacade
+-dontnote io.realm.internal.SyncObjectServerFacade
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index 2c0051d66d..3f99fdf619 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -34,7 +34,9 @@
 
     // Enumerates all known collection classes from the Realm API.
     protected enum CollectionClass {
-        MANAGED_REALMLIST, UNMANAGED_REALMLIST, REALMRESULTS
+        MANAGED_REALMLIST, UNMANAGED_REALMLIST, REALMRESULTS,
+        REALMRESULTS_SNAPSHOT_RESULTS_BASE, REALMRESULTS_SNAPSHOT_LIST_BASE
+
     }
 
     // Enumerates all current supported collections that can be in unmanaged mode.
@@ -44,12 +46,11 @@
 
     // Enumerates all current supported collections that can be managed by Realm.
     protected enum ManagedCollection {
-        MANAGED_REALMLIST, REALMRESULTS
+        MANAGED_REALMLIST, REALMRESULTS, REALMRESULTS_SNAPSHOT_RESULTS_BASE, REALMRESULTS_SNAPSHOT_LIST_BASE
     }
 
     // Enumerates all methods from the RealmCollection interface that depend on Realm API's.
-    protected enum RealmCollectionMethod {
-        WHERE, MIN, MAX, SUM, AVERAGE, MIN_DATE, MAX_DATE, DELETE_ALL_FROM_REALM, IS_VALID, IS_MANAGED
+    protected enum RealmCollectionMethod { WHERE, MIN, MAX, SUM, AVERAGE, MIN_DATE, MAX_DATE, DELETE_ALL_FROM_REALM, IS_VALID, IS_MANAGED
     }
 
     // Enumerates all methods from the Collection interface
@@ -67,7 +68,7 @@
 
     // Enumerates all methods from the OrderedRealmCollection interface that depend on Realm API's.
     protected enum OrderedRealmCollectionMethod {
-        DELETE_INDEX, DELETE_FIRST, DELETE_LAST, SORT, SORT_FIELD, SORT_2FIELDS, SORT_MULTI
+        DELETE_INDEX, DELETE_FIRST, DELETE_LAST, SORT, SORT_FIELD, SORT_2FIELDS, SORT_MULTI, CREATE_SNAPSHOT
     }
 
     // Enumerates all methods that can mutate a RealmCollection.
@@ -91,6 +92,8 @@ protected void populateRealm(Realm realm, int objects) {
                 NonLatinFieldNames nonLatinFieldNames = realm.createObject(NonLatinFieldNames.class);
                 nonLatinFieldNames.set델타(i);
                 nonLatinFieldNames.setΔέλτα(i);
+                // Sets the linked object to itself.
+                obj.setFieldObject(obj);
             }
 
             // Adds all items to the RealmList on the first object.
@@ -189,7 +192,9 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
     protected OrderedRealmCollection<AllJavaTypes> createStringCollection(Realm realm, ManagedCollection collectionClass, String... args) {
         realm.beginTransaction();
         realm.deleteAll();
+        OrderedRealmCollection<AllJavaTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 int id = 0;
                 for (String arg : args) {
@@ -197,8 +202,10 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
                     obj.setFieldString(arg);
                 }
                 realm.commitTransaction();
-                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_STRING);
+                orderedCollection = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_STRING);
+                break;
 
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 AllJavaTypes first = realm.createObject(AllJavaTypes.class, 0);
                 first.setFieldString(args[0]);
@@ -209,11 +216,27 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
                     first.getFieldList().add(obj);
                 }
                 realm.commitTransaction();
-                return first.getFieldList();
+                orderedCollection = first.getFieldList();
+                break;
 
             default:
                 throw new AssertionError("Unknown collection: " + collectionClass);
         }
+
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+
+        return orderedCollection;
+    }
+
+    boolean isSnapshot(ManagedCollection collectionClass) {
+        return collectionClass == ManagedCollection.REALMRESULTS_SNAPSHOT_LIST_BASE ||
+                collectionClass == ManagedCollection.REALMRESULTS_SNAPSHOT_RESULTS_BASE;
     }
 
+    boolean isSnapshot(CollectionClass collectionClass) {
+        return collectionClass == CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE ||
+                collectionClass == CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
index b6552f7105..44ee9ddb91 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmObjectTests.java
@@ -25,11 +25,13 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
+import java.lang.reflect.Field;
 import java.text.ParseException;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
@@ -112,6 +114,123 @@ public void tearDown() {
         BOOLEAN, SHORT, INT, LONG, BYTE, FLOAT, DOUBLE, STRING, BINARY, DATE, OBJECT, LIST
     }
 
+    private enum ThreadConfinedMethods {
+        GET_BOOLEAN, GET_BYTE, GET_SHORT, GET_INT, GET_LONG, GET_FLOAT, GET_DOUBLE,
+        GET_BLOB, GET_STRING, GET_DATE, GET_OBJECT, GET_LIST, GET,
+
+        SET_BOOLEAN, SET_BYTE, SET_SHORT, SET_INT, SET_LONG, SET_FLOAT, SET_DOUBLE,
+        SET_BLOB, SET_STRING, SET_DATE, SET_OBJECT, SET_LIST, SET,
+
+        IS_NULL, SET_NULL,
+
+        HAS_FIELD, GET_FIELD_NAMES, GET_TYPE, GET_FIELD_TYPE,
+
+        HASH_CODE, EQUALS, TO_STRING,
+    }
+
+    @SuppressWarnings({"ResultOfMethodCallIgnored", "EqualsWithItself"})
+    private static void callThreadConfinedMethod(DynamicRealmObject obj, ThreadConfinedMethods method) {
+        switch (method) {
+            case GET_BOOLEAN: obj.getBoolean(AllJavaTypes.FIELD_BOOLEAN); break;
+            case GET_BYTE:    obj.getByte(AllJavaTypes.FIELD_BYTE);       break;
+            case GET_SHORT:   obj.getShort(AllJavaTypes.FIELD_SHORT);     break;
+            case GET_INT:     obj.getInt(AllJavaTypes.FIELD_INT);         break;
+            case GET_LONG:    obj.getLong(AllJavaTypes.FIELD_LONG);       break;
+            case GET_FLOAT:   obj.getFloat(AllJavaTypes.FIELD_FLOAT);     break;
+            case GET_DOUBLE:  obj.getDouble(AllJavaTypes.FIELD_DOUBLE);   break;
+            case GET_BLOB:    obj.getBlob(AllJavaTypes.FIELD_BINARY);     break;
+            case GET_STRING:  obj.getString(AllJavaTypes.FIELD_STRING);   break;
+            case GET_DATE:    obj.getDate(AllJavaTypes.FIELD_DATE);       break;
+            case GET_OBJECT:  obj.getObject(AllJavaTypes.FIELD_OBJECT);   break;
+            case GET_LIST:    obj.getList(AllJavaTypes.FIELD_LIST);       break;
+            case GET:         obj.get(AllJavaTypes.FIELD_LONG);           break;
+
+            case SET_BOOLEAN: obj.setBoolean(AllJavaTypes.FIELD_BOOLEAN, true);                 break;
+            case SET_BYTE:    obj.setByte(AllJavaTypes.FIELD_BYTE,       (byte) 1);             break;
+            case SET_SHORT:   obj.setShort(AllJavaTypes.FIELD_SHORT,     (short) 1);            break;
+            case SET_INT:     obj.setInt(AllJavaTypes.FIELD_INT,         1);                    break;
+            case SET_LONG:    obj.setLong(AllJavaTypes.FIELD_LONG,       1L);                   break;
+            case SET_FLOAT:   obj.setFloat(AllJavaTypes.FIELD_FLOAT,     1F);                   break;
+            case SET_DOUBLE:  obj.setDouble(AllJavaTypes.FIELD_DOUBLE,   1D);                   break;
+            case SET_BLOB:    obj.setBlob(AllJavaTypes.FIELD_BINARY,     new byte[] {1, 2, 3}); break;
+            case SET_STRING:  obj.setString(AllJavaTypes.FIELD_STRING,   "12345");              break;
+            case SET_DATE:    obj.setDate(AllJavaTypes.FIELD_DATE,       new Date(1L));         break;
+            case SET_OBJECT:  obj.setObject(AllJavaTypes.FIELD_OBJECT,   obj);                  break;
+            case SET_LIST:    obj.setList(AllJavaTypes.FIELD_LIST,       new RealmList<>(obj)); break;
+            case SET:         obj.set(AllJavaTypes.FIELD_LONG,           1L);                   break;
+
+            case IS_NULL:     obj.isNull(AllJavaTypes.FIELD_OBJECT);           break;
+            case SET_NULL:    obj.setNull(AllJavaTypes.FIELD_OBJECT);          break;
+
+            case HAS_FIELD:       obj.hasField(AllJavaTypes.FIELD_OBJECT);     break;
+            case GET_FIELD_NAMES: obj.getFieldNames();                         break;
+            case GET_TYPE:        obj.getType();                               break;
+            case GET_FIELD_TYPE:  obj.getFieldType(AllJavaTypes.FIELD_OBJECT); break;
+
+            case HASH_CODE:   obj.hashCode();  break;
+            case EQUALS:      obj.equals(obj); break;
+            case TO_STRING:   obj.toString();  break;
+
+            default:
+                throw new AssertionError("missing case for " + method);
+        }
+    }
+
+    @Test
+    public void callThreadConfinedMethodsFromWrongThread() throws Throwable {
+
+        dynamicRealm.beginTransaction();
+        dynamicRealm.deleteAll();
+        final DynamicRealmObject obj = dynamicRealm.createObject(AllJavaTypes.CLASS_NAME, 100L);
+        dynamicRealm.commitTransaction();
+
+        final AtomicReference<Throwable> throwableFromThread = new AtomicReference<Throwable>();
+        final CountDownLatch testFinished = new CountDownLatch(1);
+
+        final String expectedMessage;
+        //noinspection TryWithIdenticalCatches
+        try {
+            final Field expectedMessageField = BaseRealm.class.getDeclaredField("INCORRECT_THREAD_MESSAGE");
+            expectedMessageField.setAccessible(true);
+            expectedMessage = (String) expectedMessageField.get(null);
+        } catch (NoSuchFieldException e) {
+            throw new AssertionError(e);
+        } catch (IllegalAccessException e) {
+            throw new AssertionError(e);
+        }
+
+        final Thread thread = new Thread("callThreadConfinedMethodsFromWrongThread") {
+            @Override
+            public void run() {
+                try {
+                    for (ThreadConfinedMethods method : ThreadConfinedMethods.values()) {
+                        try {
+                            callThreadConfinedMethod(obj, method);
+                            fail("IllegalStateException must be thrown.");
+                        } catch (Throwable e) {
+                            if (e instanceof IllegalStateException && expectedMessage.equals(e.getMessage())) {
+                                // expected exception
+                                continue;
+                            }
+                            throwableFromThread.set(e);
+                            return;
+                        }
+                    }
+                } finally {
+                    testFinished.countDown();
+                }
+            }
+        };
+        thread.start();
+
+        TestHelper.awaitOrFail(testFinished);
+        final Throwable throwable = throwableFromThread.get();
+        if (throwable != null) {
+            throw throwable;
+        }
+    }
+
+
     @Test (expected = IllegalArgumentException.class)
     public void constructor_nullThrows () {
         new DynamicRealmObject((RealmObject)null);
@@ -614,6 +733,7 @@ public void setObject_objectBelongToTypedRealmThrows() {
     @Test
     public void setObject_objectBelongToDiffThreadRealmThrows() {
         final CountDownLatch finishedLatch = new CountDownLatch(1);
+
         new Thread(new Runnable() {
             @Override
             public void run() {
@@ -661,6 +781,51 @@ public void setList_listWithDynamicRealmObject() {
         dynamicRealm.close();
     }
 
+    @Test
+    public void setList_managedRealmList() {
+        dynamicRealm.executeTransaction(new DynamicRealm.Transaction() {
+            @Override
+            public void execute(DynamicRealm realm) {
+                realm.deleteAll();
+
+                DynamicRealmObject allTypes = realm.createObject(AllTypes.CLASS_NAME);
+                allTypes.setString(AllTypes.FIELD_STRING, "bender");
+
+                DynamicRealmObject anotherAllTypes;
+                {
+                    anotherAllTypes = realm.createObject(AllTypes.CLASS_NAME);
+                    anotherAllTypes.setString(AllTypes.FIELD_STRING, "bender2");
+                    DynamicRealmObject dog = realm.createObject(Dog.CLASS_NAME);
+                    dog.setString(Dog.FIELD_NAME, "nibbler");
+                    anotherAllTypes.getList(AllTypes.FIELD_REALMLIST).add(dog);
+                }
+
+                // set managed RealmList
+                allTypes.setList(AllTypes.FIELD_REALMLIST, anotherAllTypes.getList(AllTypes.FIELD_REALMLIST));
+            }
+        });
+
+        DynamicRealmObject allTypes = dynamicRealm.where(AllTypes.CLASS_NAME)
+                .equalTo(AllTypes.FIELD_STRING, "bender")
+                .findFirst();
+        assertEquals(1, allTypes.getList(AllTypes.FIELD_REALMLIST).size());
+        assertEquals("nibbler", allTypes.getList(AllTypes.FIELD_REALMLIST).first().get(Dog.FIELD_NAME));
+
+        // Check if allTypes and anotherAllTypes share the same Dog object.
+        dynamicRealm.executeTransaction(new DynamicRealm.Transaction() {
+            @Override
+            public void execute(DynamicRealm realm) {
+                DynamicRealmObject anotherAllTypes = dynamicRealm.where(AllTypes.CLASS_NAME)
+                        .equalTo(AllTypes.FIELD_STRING, "bender2")
+                        .findFirst();
+                anotherAllTypes.getList(AllTypes.FIELD_REALMLIST).first()
+                        .setString(Dog.FIELD_NAME, "nibbler_modified");
+            }
+        });
+
+        assertEquals("nibbler_modified", allTypes.getList(AllTypes.FIELD_REALMLIST).first().get(Dog.FIELD_NAME));
+    }
+
     @Test
     public void setList_elementBelongToTypedRealmThrows() {
         RealmList<DynamicRealmObject> list = new RealmList<DynamicRealmObject>();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index ca45c3923b..1f82f9326b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -16,7 +16,6 @@
 
 package io.realm;
 
-import android.os.Handler;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
@@ -41,7 +40,6 @@
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.exceptions.RealmException;
-import io.realm.internal.HandlerControllerConstants;
 import io.realm.log.RealmLog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
@@ -341,6 +339,15 @@ public void execute(DynamicRealm realm) {
         assertEquals(0, realm.where("Owner").count());
     }
 
+    @Test
+    public void findFirst() {
+        populateTestRealm(realm, 10);
+        final DynamicRealmObject allTypes = realm.where(AllTypes.CLASS_NAME)
+                .between(AllTypes.FIELD_LONG, 4, 9)
+                .findFirst();
+        assertEquals("test data 4", allTypes.getString(AllTypes.FIELD_STRING));
+    }
+
     @Test
     @RunTestInLooperThread
     public void findFirstAsync() {
@@ -532,41 +539,19 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
     @RunTestInLooperThread
     public void accessingDynamicRealmObjectBeforeAsyncQueryCompleted() {
         final DynamicRealm dynamicRealm = initializeDynamicRealm();
-        final DynamicRealmObject[] dynamicRealmObject = new DynamicRealmObject[1];
-
-        // Intercepts completion of the async DynamicRealmObject query.
-        Handler handler = new HandlerProxy(dynamicRealm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                switch (what) {
-                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT: {
-                        post(new Runnable() {
-                            @Override
-                            public void run() {
-                                assertFalse(dynamicRealmObject[0].isLoaded());
-                                assertFalse(dynamicRealmObject[0].isValid());
-                                try {
-                                    dynamicRealmObject[0].getObject(AllTypes.FIELD_BINARY);
-                                    fail("trying to access a DynamicRealmObject property should throw");
-                                } catch (IllegalStateException ignored) {
-
-                                } finally {
-                                    dynamicRealm.close();
-                                    looperThread.testComplete();
-                                }
-                            }
-                        });
-                        return true;
-                    }
-                }
-                return false;
-            }
-        };
-
-        dynamicRealm.setHandler(handler);
-        dynamicRealmObject[0] = dynamicRealm.where(AllTypes.CLASS_NAME)
+        final DynamicRealmObject dynamicRealmObject = dynamicRealm.where(AllTypes.CLASS_NAME)
                 .between(AllTypes.FIELD_LONG, 4, 9)
                 .findFirstAsync();
+        assertFalse(dynamicRealmObject.isLoaded());
+        assertFalse(dynamicRealmObject.isValid());
+        try {
+            dynamicRealmObject.getObject(AllTypes.FIELD_BINARY);
+            fail("trying to access a DynamicRealmObject property should throw");
+        } catch (IllegalStateException ignored) {
+        } finally {
+            dynamicRealm.close();
+            looperThread.testComplete();
+        }
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java b/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
deleted file mode 100644
index 507e7f8edf..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/HandlerProxy.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.os.Handler;
-import android.os.Message;
-
-/**
- * Handler decorator, to help intercept some messages before they are sent and received.
- */
-abstract class HandlerProxy extends Handler {
-
-    private final HandlerController controller;
-
-    public HandlerProxy(HandlerController controller) {
-        if (null == controller) {
-            throw new IllegalArgumentException("non-null HandlerController required.");
-        }
-        this.controller = controller;
-    }
-
-    /**
-     * @see {@link Handler#postAtFrontOfQueue(Runnable)}
-     */
-    public void postAtFront(Runnable runnable) {
-        if (onInterceptOutMessage(0)) {
-            postAtFrontOfQueue(runnable);
-        }
-    }
-
-    @Override
-    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
-        boolean eventConsumed = onInterceptOutMessage(msg.what);
-        return !eventConsumed && super.sendMessageAtTime(msg, uptimeMillis);
-    }
-
-    @Override
-    public void handleMessage(Message msg) {
-        boolean eventConsumed = onInterceptInMessage(msg.what);
-        if (!eventConsumed) {
-            controller.handleMessage(msg);
-        }
-    }
-
-    /**
-     * Intercepts a message as it is being posted. Return {@code false} to continue sending it. {@code true} to
-     * swallow it.
-     *
-     * This method will be executed on the thread sending the message.
-     *
-     * @return {@code true} if message should be swallowed. {@code false} to continue processing it.
-     */
-    protected boolean onInterceptOutMessage(int what) {
-        return false;
-    }
-
-    /**
-     * Intercepts a message as it is being received. Return {@code false} to let subclasses continue the handling.
-     * {@code true} to swallow it.
-     *
-     * This method will be executed on the thread of the Looper backing the Handler
-     *
-     * @return {@code true} if message should be swallowed. {@code false} to continue processing it.
-     */
-    protected boolean onInterceptInMessage(int what) {
-        return false;
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index 908219ccdb..bb873d1956 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -34,7 +34,6 @@
 import java.util.concurrent.Future;
 
 import io.realm.entities.AllJavaTypes;
-import io.realm.entities.Cat;
 import io.realm.entities.Dog;
 import io.realm.entities.NullTypes;
 import io.realm.entities.Owner;
@@ -151,38 +150,60 @@ public void tearDown() {
     }
 
     OrderedRealmCollection<AllJavaTypes> createCollection(ManagedCollection collectionClass) {
+        OrderedRealmCollection<AllJavaTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
-                return realm.where(AllJavaTypes.class)
+                orderedCollection = realm.where(AllJavaTypes.class)
                         .equalTo(AllJavaTypes.FIELD_LONG, 0)
                         .findFirst()
                         .getFieldList();
+                break;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(AllJavaTypes.class).findAll();
+                orderedCollection = realm.where(AllJavaTypes.class).findAll();
+                break;
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
         }
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     private OrderedRealmCollection<NullTypes> createEmptyCollection(Realm realm, ManagedCollection collectionClass) {
+        OrderedRealmCollection<NullTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
                 NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
-                return obj.getFieldListNull();
+                orderedCollection = obj.getFieldListNull();
+                break;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(NullTypes.class).findAll();
+                orderedCollection = realm.where(NullTypes.class).findAll();
+                break;
+            default:
+                throw new AssertionError("Unknown collection: " + collectionClass);
         }
 
-        throw new AssertionError("Unknown collection: " + collectionClass);
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     @Test
     public void sort_twoFields() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> sortedList = collection.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
         AllJavaTypes obj = sortedList.first();
         assertFalse(obj.isFieldBoolean());
@@ -191,6 +212,9 @@ public void sort_twoFields() {
 
     @Test
     public void sort_boolean() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> sortedList = collection.sort(AllJavaTypes.FIELD_BOOLEAN, Sort.DESCENDING);
         assertEquals(TEST_SIZE, sortedList.size());
         assertEquals(false, sortedList.last().isFieldBoolean());
@@ -212,6 +236,9 @@ public void sort_boolean() {
 
     @Test
     public void sort_string() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> resultList = collection;
         OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
         sortedList = sortedList.sort(AllJavaTypes.FIELD_STRING, Sort.DESCENDING);
@@ -235,6 +262,9 @@ public void sort_string() {
 
     @Test
     public void sort_double() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> resultList = collection;
         OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
         sortedList = sortedList.sort(AllJavaTypes.FIELD_DOUBLE, Sort.DESCENDING);
@@ -253,6 +283,9 @@ public void sort_double() {
 
     @Test
     public void sort_float() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> resultList = collection;
         OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
         sortedList = sortedList.sort(AllJavaTypes.FIELD_FLOAT, Sort.DESCENDING);
@@ -290,10 +323,14 @@ private void doTestSortOnColumnWithPartialNullValues(String fieldName,
     // Tests sort on nullable fields with null values partially.
     @Test
     public void sort_rowsWithPartialNullValues() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         populatePartialNullRowsForNumericTesting(realm);
         OrderedRealmCollection<NullTypes> original;
         OrderedRealmCollection<NullTypes> copy;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
                 RealmResults<NullTypes> objects = realm.where(NullTypes.class).findAll();
@@ -309,6 +346,7 @@ public void sort_rowsWithPartialNullValues() {
                 copy = parent.getFieldListNull();
                 break;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 original = realm.where(NullTypes.class).findAll();
                 copy = realm.where(NullTypes.class).findAll();
@@ -318,6 +356,10 @@ public void sort_rowsWithPartialNullValues() {
                 throw new AssertionError("Unknown collection class: " + collectionClass);
         }
 
+        if (isSnapshot(collectionClass)) {
+            copy = copy.createSnapshot();
+        }
+
         // 1 String
         doTestSortOnColumnWithPartialNullValues(NullTypes.FIELD_STRING_NULL, original, copy);
 
@@ -339,13 +381,19 @@ public void sort_rowsWithPartialNullValues() {
 
     @Test
     public void sort_nonExistingColumn() {
-        RealmResults<AllJavaTypes> resultList = realm.where(AllJavaTypes.class).findAll();
-        thrown.expect(IllegalArgumentException.class);
-        resultList.sort("Non-existing");
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        } else {
+            thrown.expect(IllegalArgumentException.class);
+        }
+        collection.sort("Non-existing");
     }
 
     @Test
     public void sort_danishCharacters() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
                 "Æble",
                 "Øl",
@@ -368,6 +416,9 @@ public void sort_danishCharacters() {
 
     @Test
     public void sort_russianCharacters() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
                 "Санкт-Петербург",
                 "Москва",
@@ -390,6 +441,9 @@ public void sort_russianCharacters() {
 
     @Test
     public void sort_greekCharacters() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
                 "αύριο",
                 "ημέρες",
@@ -413,6 +467,9 @@ public void sort_greekCharacters() {
     // No sorting order defined. There are Korean, Arabic and Chinese characters.
     @Test
     public void sort_manyDifferentCharacters() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
                 "단위",
                 "테스트",
@@ -433,6 +490,9 @@ public void sort_manyDifferentCharacters() {
 
     @Test
     public void sort_twoLanguages() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> collection = createStringCollection(realm, collectionClass,
                 "test",
                 "αύριο",
@@ -448,26 +508,30 @@ public void sort_twoLanguages() {
 
     @Test
     public void sort_usingChildObject() {
-        realm.beginTransaction();
-        Owner owner = realm.createObject(Owner.class);
-        owner.setName("owner");
-        Cat cat = realm.createObject(Cat.class);
-        cat.setName("cat");
-        owner.setCat(cat);
-        realm.commitTransaction();
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
+        OrderedRealmCollection<AllJavaTypes> resultList = collection;
+        OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
+        assertEquals("Should have same size", resultList.size(), sortedList.size());
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals("First excepted to be last", resultList.first().getFieldLong(), sortedList.last().getFieldLong());
 
-        RealmQuery<Owner> query = realm.where(Owner.class);
-        RealmResults<Owner> owners = query.findAll();
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+        assertEquals(TEST_SIZE, sortedList.size());
+        assertEquals("First excepted to be first", resultList.first().getFieldLong(), sortedList.first().getFieldLong());
+        assertEquals("Last excepted to be last", resultList.last().getFieldLong(), sortedList.last().getFieldLong());
 
-        try {
-            owners.sort("cat.name");
-            fail("Sorting by child object properties should result in a IllegalArgumentException");
-        } catch (IllegalArgumentException ignore) {
-        }
+        sortedList = sortedList.sort(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
+        assertEquals(TEST_SIZE, sortedList.size());
     }
 
     @Test
     public void sort_nullArguments() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> result = collection;
         try {
             result.sort((String) null);
@@ -483,6 +547,9 @@ public void sort_nullArguments() {
 
     @Test
     public void sort_emptyResults() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<NullTypes> collection = createEmptyCollection(realm, collectionClass);
         assertEquals(0, collection.size());
         collection.sort(NullTypes.FIELD_STRING_NULL);
@@ -491,6 +558,9 @@ public void sort_emptyResults() {
 
     @Test
     public void sort_singleField() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         RealmResults<AllJavaTypes> sortedList = collection.sort(new String[]{AllJavaTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING});
         assertEquals(TEST_SIZE, sortedList.size());
         assertEquals(TEST_SIZE - 1, sortedList.first().getFieldLong());
@@ -499,6 +569,9 @@ public void sort_singleField() {
 
     @Test
     public void sort_date() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> resultList = collection;
         OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
         sortedList = sortedList.sort(AllJavaTypes.FIELD_DATE, Sort.DESCENDING);
@@ -517,6 +590,9 @@ public void sort_date() {
 
     @Test
     public void sort_long() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         OrderedRealmCollection<AllJavaTypes> resultList = collection;
         OrderedRealmCollection<AllJavaTypes> sortedList = createCollection(collectionClass);
         sortedList = sortedList.sort(AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
@@ -540,8 +616,13 @@ public void deleteFromRealm() {
         realm.beginTransaction();
         collection.deleteFromRealm(0);
         realm.commitTransaction();
-        assertEquals(TEST_SIZE - 1, collection.size());
-        assertEquals(2, collection.get(1).getAge());
+        if (isSnapshot(collectionClass)) {
+            assertEquals(TEST_SIZE, collection.size());
+            assertFalse(collection.get(0).isValid());
+        } else {
+            assertEquals(TEST_SIZE - 1, collection.size());
+            assertEquals(2, collection.get(1).getAge());
+        }
     }
 
     @Test
@@ -567,14 +648,21 @@ public void deleteFirstFromRealm() {
         realm.beginTransaction();
         assertTrue(collection.deleteFirstFromRealm());
         realm.commitTransaction();
-        assertEquals(TEST_SIZE - 1, collection.size());
-        assertEquals(1, collection.get(0).getAge());
+        if (isSnapshot(collectionClass)) {
+            assertEquals(TEST_SIZE, collection.size());
+            assertFalse(collection.first().isValid());
+        } else {
+            assertEquals(TEST_SIZE - 1, collection.size());
+            assertEquals(1, collection.get(0).getAge());
+        }
     }
 
     private OrderedRealmCollection<Dog> createNonCyclicCollection(Realm realm, ManagedCollection collectionClass) {
         realm.beginTransaction();
         realm.deleteAll();
+        OrderedRealmCollection<Dog> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case MANAGED_REALMLIST:
                 Owner owner = realm.createObject(Owner.class);
                 RealmList<Dog> dogs = owner.getDogs();
@@ -585,8 +673,10 @@ public void deleteFirstFromRealm() {
                     dogs.add(dog);
                 }
                 realm.commitTransaction();
-                return dogs;
+                orderedCollection = dogs;
+                break;
 
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case REALMRESULTS:
                 for (int i = 0; i < TEST_SIZE; i++) {
                     Dog dog = realm.createObject(Dog.class);
@@ -594,12 +684,16 @@ public void deleteFirstFromRealm() {
                     dog.setName("Dog " + i);
                 }
                 realm.commitTransaction();
-                return realm.where(Dog.class).findAll();
+                orderedCollection = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
+                break;
 
             default:
                 throw new AssertionError("Unknown collection class: " + collectionClass);
         }
-
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     @Test
@@ -617,8 +711,13 @@ public void deleteLastFromRealm() {
         realm.beginTransaction();
         assertTrue(collection.deleteLastFromRealm());
         realm.commitTransaction();
-        assertEquals(TEST_SIZE - 1, collection.size());
-        assertEquals(TEST_SIZE - 2, collection.last().getFieldLong());
+        if (isSnapshot(collectionClass)) {
+            assertEquals(TEST_SIZE, collection.size());
+            assertFalse(collection.last().isValid());
+        } else {
+            assertEquals(TEST_SIZE - 1, collection.size());
+            assertEquals(TEST_SIZE - 2, collection.last().getFieldLong());
+        }
     }
 
     @Test
@@ -639,7 +738,7 @@ public void mutableMethodsOutsideTransactions() {
 
             // Define expected exception
             Class<? extends Throwable> expected = IllegalStateException.class;
-            if (collectionClass == ManagedCollection.REALMRESULTS) {
+            if (collectionClass == ManagedCollection.REALMRESULTS || isSnapshot(collectionClass)) {
                 switch (method) {
                     case ADD_INDEX:
                     case ADD_ALL_INDEX:
@@ -688,6 +787,20 @@ private boolean runMethodOnWrongThread(final OrderedRealmCollectionMethod method
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
             @Override
             public Boolean call() throws Exception {
+                // Defines expected exception.
+                Class<? extends Throwable> expected = IllegalStateException.class;
+                if (isSnapshot(collectionClass)) {
+                    switch (method) {
+                        case SORT:
+                        case SORT_FIELD:
+                        case SORT_2FIELDS:
+                        case SORT_MULTI:
+                            expected = UnsupportedOperationException.class;
+                        default:
+                            break;
+                    }
+                }
+
                 try {
                     switch (method) {
                         case DELETE_INDEX: collection.deleteFromRealm(0); break;
@@ -697,10 +810,11 @@ public Boolean call() throws Exception {
                         case SORT_FIELD: collection.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING); break;
                         case SORT_2FIELDS: collection.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING); break;
                         case SORT_MULTI: collection.sort(new String[] { AllJavaTypes.FIELD_STRING }, new Sort[] { Sort.ASCENDING }); break;
+                        case CREATE_SNAPSHOT: collection.createSnapshot(); break;
                     }
                     return false;
-                } catch (IllegalStateException ignored) {
-                    return true;
+                } catch (Throwable t) {
+                    return t.getClass().equals(expected);
                 }
             }
         });
@@ -717,7 +831,7 @@ private boolean runMethodOnWrongThread(final ListMethod method) throws Execution
             public Boolean call() throws Exception {
                 // Defines expected exception.
                 Class<? extends Throwable> expected = IllegalStateException.class;
-                if (collectionClass == ManagedCollection.REALMRESULTS) {
+                if (collectionClass == ManagedCollection.REALMRESULTS || isSnapshot(collectionClass)) {
                     switch (method) {
                         case ADD_INDEX:
                         case ADD_ALL_INDEX:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index fa8e7a8d05..809dbdf5f7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -20,6 +20,7 @@
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
@@ -91,6 +92,8 @@
 
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
 
     private final ManagedCollection collectionClass;
     private Realm realm;
@@ -120,39 +123,61 @@ public void tearDown() {
     }
 
     private OrderedRealmCollection<AllJavaTypes> createCollection(ManagedCollection collectionClass) {
+        OrderedRealmCollection<AllJavaTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
-                return realm.where(AllJavaTypes.class)
+                orderedCollection = realm.where(AllJavaTypes.class)
                         .equalTo(AllJavaTypes.FIELD_LONG, 0)
                         .findFirst()
                         .getFieldList();
+                break;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                orderedCollection = realm.where(AllJavaTypes.class)
+                        .findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                break;
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
         }
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     private OrderedRealmCollection<NullTypes> createEmptyCollection(Realm realm, ManagedCollection collectionClass) {
+        OrderedRealmCollection<NullTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
                 NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
-                return obj.getFieldListNull();
+                orderedCollection = obj.getFieldListNull();
+                break;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(NullTypes.class).findAll();
+                orderedCollection = realm.where(NullTypes.class).findAll();
+                break;
+            default:
+                throw new AssertionError("Unknown collection: " + collectionClass);
         }
 
-        throw new AssertionError("Unknown collection: " + collectionClass);
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     private OrderedRealmCollection<NullTypes> createAllNullRowsForNumericTesting(Realm realm, ManagedCollection collectionClass) {
         TestHelper.populateAllNullRowsForNumericTesting(realm);
+        OrderedRealmCollection<NullTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
                 RealmList<NullTypes> list = results.get(0).getFieldListNull();
@@ -161,17 +186,29 @@ public void tearDown() {
                     list.add(results.get(i));
                 }
                 realm.commitTransaction();
-                return list;
+                orderedCollection = list;
+                break;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(NullTypes.class).findAll();
+                orderedCollection = realm.where(NullTypes.class).findAll();
+                break;
+            default:
+                throw new AssertionError("Unknown collection: " + collectionClass);
+        }
+
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
         }
-        throw new AssertionError("Unknown collection: " + collectionClass);
+
+        return orderedCollection;
     }
 
     private OrderedRealmCollection<NullTypes> createPartialNullRowsForNumericTesting(Realm realm, ManagedCollection collectionClass) {
         populatePartialNullRowsForNumericTesting(realm);
+        OrderedRealmCollection<NullTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 RealmResults<NullTypes> results = realm.where(NullTypes.class).findAll();
                 RealmList<NullTypes> list = results.get(0).getFieldListNull();
@@ -181,18 +218,28 @@ public void tearDown() {
                     list.add(results.get(i));
                 }
                 realm.commitTransaction();
-                return list;
+                orderedCollection = list;
+                break;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(NullTypes.class).findAll();
+                orderedCollection = realm.where(NullTypes.class).findAll();
+                break;
+            default:
+                throw new AssertionError("Unknown collection: " + collectionClass);
+        }
+
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
         }
-        throw new AssertionError("Unknown collection: " + collectionClass);
+        return orderedCollection;
     }
 
     // PRE-CONDITION: populateRealm() was called as part of setUp()
     private OrderedRealmCollection<NonLatinFieldNames> createNonLatinCollection(Realm realm, ManagedCollection collectionClass) {
+        OrderedRealmCollection<NonLatinFieldNames> orderedCollection;
         switch (collectionClass) {
-
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
                 RealmResults<NonLatinFieldNames> results = realm.where(NonLatinFieldNames.class).findAll();
@@ -201,18 +248,29 @@ public void tearDown() {
                     list.add(results.get(i));
                 }
                 realm.commitTransaction();
-                return list;
+                orderedCollection = list;
+                break;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(NonLatinFieldNames.class).findAll();
+                orderedCollection = realm.where(NonLatinFieldNames.class).findAll();
+                break;
 
             default:
                 throw new AssertionError("Unknown collection: " + collectionClass);
         }
+
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     @Test
     public void where() {
+        if (isSnapshot(collectionClass)) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
         RealmResults<AllJavaTypes> results = collection.where().findAll();
         assertEquals(TEST_SIZE, results.size());
     }
@@ -500,6 +558,29 @@ public void minDate() {
         assertEquals(new Date(-YEAR_MILLIS * 20 * TEST_SIZE / 2), collection.minDate(AllJavaTypes.FIELD_DATE));
     }
 
+    // Deletes the last row in the collection then tests the aggregates methods.
+    // Since deletion will turn the corresponding object into invalid for collection snapshot, this tests if the
+    // aggregates methods ignore the invalid rows and return the correct result.
+    @Test
+    public void aggregates_deleteLastRow() {
+        assertTrue(TEST_SIZE > 3);
+        assertEquals(TEST_SIZE, collection.size());
+        realm.beginTransaction();
+        realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, TEST_SIZE - 1).findFirst().deleteFromRealm();
+        realm.commitTransaction();
+
+        int sizeAfterRemove = TEST_SIZE - 1;
+
+        assertEquals(0, collection.min(AllJavaTypes.FIELD_LONG).intValue());
+        assertEquals(sizeAfterRemove - 1, collection.max(AllJavaTypes.FIELD_LONG).intValue());
+        // Sum of numbers 0 to M-1: (M-1)*M/2
+        assertEquals((sizeAfterRemove - 1) * sizeAfterRemove / 2, collection.sum(AllJavaTypes.FIELD_LONG).intValue());
+        double average = 3.1415 + (sizeAfterRemove - 1.0) * 0.5;
+        assertEquals(average, collection.average(AllJavaTypes.FIELD_DOUBLE), 0.0001);
+        assertEquals(new Date(YEAR_MILLIS * 20 * (sizeAfterRemove / 2 - 1)), collection.maxDate(AllJavaTypes.FIELD_DATE));
+        assertEquals(new Date(-YEAR_MILLIS * 20 * TEST_SIZE / 2), collection.minDate(AllJavaTypes.FIELD_DATE));
+    }
+
     @Test
     public void realmMethods_invalidFieldNames() {
         String[] fieldNames = new String[] {
@@ -585,7 +666,11 @@ public void deleteAllFromRealm() {
         realm.beginTransaction();
         assertTrue(collection.deleteAllFromRealm());
         realm.commitTransaction();
-        assertEquals(0, collection.size());
+        if (isSnapshot(collectionClass)) {
+            assertEquals(TEST_SIZE, collection.size());
+        } else {
+            assertEquals(0, collection.size());
+        }
     }
 
     @Test(expected = IllegalStateException.class)
@@ -666,7 +751,7 @@ public void mutableMethodsOutsideTransactions() {
 
             // Defines expected exception.
             Class<? extends Throwable> expected = IllegalStateException.class;
-            if (collectionClass == ManagedCollection.REALMRESULTS) {
+            if (collectionClass == ManagedCollection.REALMRESULTS || isSnapshot(collectionClass)) {
                 switch (method) {
                     case ADD_OBJECT:
                     case ADD_ALL_OBJECTS:
@@ -699,15 +784,19 @@ public void mutableMethodsOutsideTransactions() {
 
     @Test
     public void methodsThrowOnWrongThread() throws ExecutionException, InterruptedException {
+        realm.beginTransaction();
+        AllJavaTypes allJavaTypes = realm.createObject(AllJavaTypes.class, 42);
+        realm.commitTransaction();
         for (RealmCollectionMethod method : RealmCollectionMethod.values()) {
             assertTrue(method + " failed", runMethodOnWrongThread(method));
         }
         for (CollectionMethod method : CollectionMethod.values()) {
-            assertTrue(method + " failed", runMethodOnWrongThread(method));
+            assertTrue(method + " failed", runMethodOnWrongThread(method, allJavaTypes));
         }
     }
 
-    private boolean runMethodOnWrongThread(final RealmCollectionMethod method) throws ExecutionException, InterruptedException {
+    private boolean runMethodOnWrongThread(final RealmCollectionMethod method)
+            throws ExecutionException, InterruptedException {
         realm.beginTransaction();
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
@@ -729,6 +818,8 @@ public Boolean call() throws Exception {
                     return false;
                 } catch (IllegalStateException ignored) {
                     return true;
+                } catch (UnsupportedOperationException ignored) {
+                    return (method == RealmCollectionMethod.WHERE && isSnapshot(collectionClass));
                 }
             }
         });
@@ -737,7 +828,8 @@ public Boolean call() throws Exception {
         return result;
     }
 
-    private boolean runMethodOnWrongThread(final CollectionMethod method) throws ExecutionException, InterruptedException {
+    private boolean runMethodOnWrongThread(final CollectionMethod method, final AllJavaTypes tempObject)
+            throws ExecutionException, InterruptedException {
         realm.beginTransaction();
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
@@ -746,7 +838,7 @@ public Boolean call() throws Exception {
 
                 // Defines expected exception.
                 Class<? extends Throwable> expected = IllegalStateException.class;
-                if (collectionClass == ManagedCollection.REALMRESULTS) {
+                if (collectionClass == ManagedCollection.REALMRESULTS || isSnapshot(collectionClass)) {
                     switch (method) {
                         case ADD_OBJECT:
                         case ADD_ALL_OBJECTS:
@@ -762,9 +854,12 @@ public Boolean call() throws Exception {
                     switch (method) {
                         case ADD_OBJECT: collection.add(new AllJavaTypes()); break;
                         case ADD_ALL_OBJECTS: collection.addAll(Collections.singletonList(new AllJavaTypes())); break;
-                        case CLEAR: collection.clear(); case CONTAINS:
-                        case CONTAINS_ALL: collection.containsAll(Collections.singletonList(new AllJavaTypes())); break;
-                        case EQUALS: collection.equals(createCollection(collectionClass)); break;
+                        case CLEAR: collection.clear();
+                        case CONTAINS:
+                        case CONTAINS_ALL: collection.containsAll(Collections.singletonList(tempObject)); break;
+                        case EQUALS:
+                            //noinspection ResultOfMethodCallIgnored
+                            collection.equals(createCollection(collectionClass)); break;
                         case HASHCODE:
                             //noinspection ResultOfMethodCallIgnored
                             collection.hashCode();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
index 9ec3db4f47..fd7d5d8035 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/NotificationsTest.java
@@ -33,7 +33,6 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import java.lang.ref.WeakReference;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutionException;
@@ -47,7 +46,6 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Dog;
-import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
 import io.realm.log.RealmLogger;
 import io.realm.rule.RunInLooperThread;
@@ -87,7 +85,7 @@ public void tearDown() {
     }
 
     @Test
-    public void failingSetAutoRefreshOnNonLooperThread() throws ExecutionException, InterruptedException {
+    public void setAutoRefresh_failsOnNonLooperThread() throws ExecutionException, InterruptedException {
         ExecutorService executorService = Executors.newSingleThreadExecutor();
         Future<Boolean> future = executorService.submit(new Callable<Boolean>() {
             @Override
@@ -318,19 +316,40 @@ public void run() {
 
     @Test
     @RunTestInLooperThread
-    public void commitTransaction_delayChangeListenerOnSameThread() {
+    public void globalListener_looperThread_triggeredByLocalCommit() {
         final AtomicInteger success = new AtomicInteger(0);
         Realm realm = looperThread.realm;
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                assertEquals(1, success.get());
+                assertEquals(0, success.getAndIncrement());
                 looperThread.testComplete();
             }
         });
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
+        assertEquals(1, success.get());
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void globalListener_looperThread_triggeredByRemoteCommit() {
+        final AtomicInteger success = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+        realm.addChangeListener(new RealmChangeListener<Realm>() {
+            @Override
+            public void onChange(Realm object) {
+                assertEquals(1, success.get());
+                looperThread.testComplete();
+            }
+        });
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.createObject(AllTypes.class);
+            }
+        });
         assertEquals(0, success.getAndIncrement());
     }
 
@@ -422,91 +441,6 @@ public void onChange(Realm object) {
         realm.commitTransaction();
     }
 
-    @Test
-    @RunTestInLooperThread
-    public void weakReferenceListener() throws InterruptedException {
-        final AtomicInteger weakCounter = new AtomicInteger(0);
-        final AtomicInteger strongCounter = new AtomicInteger(0);
-
-        final Realm realm = looperThread.realm;
-
-        // Setups weak listener.
-        RealmChangeListener<Realm> weakListener = new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                weakCounter.incrementAndGet();
-            }
-        };
-        realm.handlerController.addChangeListenerAsWeakReference(weakListener);
-        assertEquals(1, realm.handlerController.weakChangeListeners.size());
-
-        // This is not a weak listener so will be called. When this is triggered the weak references have not been
-        // removed yet. So make another change to ensure that they really are removed before validating.
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                int count = strongCounter.incrementAndGet();
-                if (count == 1) {
-                    realm.beginTransaction();
-                    realm.createObject(AllTypes.class);
-                    realm.commitTransaction();
-                } else if (count == 2) {
-                    assertEquals(0, weakCounter.get());
-                    assertEquals(0, realm.handlerController.weakChangeListeners.size());
-                    looperThread.testComplete();
-                }
-            }
-        });
-
-        // Hack: There is no guaranteed way to release the WeakReference, just clear it.
-        for (WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef : realm.handlerController.weakChangeListeners) {
-            weakRef.clear();
-        }
-
-        // Triggers change listeners.
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-    }
-
-
-    // Tests that that a WeakReferenceListener can be removed.
-    // This test is not a proper GC test, but just ensures that listeners can be removed from the list of weak listeners
-    // without throwing an exception.
-    @Test
-    @RunTestInLooperThread
-    public void removingWeakReferenceListener() throws InterruptedException {
-        final AtomicInteger counter = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
-        RealmChangeListener<Realm> listenerA = new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                counter.incrementAndGet();
-            }
-        };
-        RealmChangeListener<Realm> listenerB = new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                assertEquals(0, counter.get());
-                assertEquals(1, realm.handlerController.weakChangeListeners.size());
-                looperThread.testComplete();
-            }
-        };
-        realm.handlerController.addChangeListenerAsWeakReference(listenerA);
-
-        // There is no guaranteed way to release the WeakReference,
-        // just clear it.
-        for (WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef : realm.handlerController.weakChangeListeners) {
-            weakRef.clear();
-        }
-
-        realm.handlerController.addChangeListenerAsWeakReference(listenerB);
-
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-    }
-
     @Test
     @RunTestInLooperThread
     public void realmNotificationOrder() {
@@ -531,14 +465,19 @@ public void onChange(Realm object) {
             @Override
             public void onChange(Realm object) {
                 listenerBCalled.incrementAndGet();
-                if (listenerACalled.get() == 1) {
+                if (listenerBCalled.get() == 1) {
                     // 2. Reverse order.
                     realm.removeAllChangeListeners();
                     realm.addChangeListener(this);
                     realm.addChangeListener(listenerA);
-                    realm.beginTransaction();
-                    realm.commitTransaction();
-
+                    // Async transaction to avoid endless recursion.
+                    realm.executeTransactionAsync(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                        }
+                    });
+                } else if (listenerBCalled.get() == 2) {
+                    assertEquals(1, listenerACalled.get());
                 }
             }
         };
@@ -859,41 +798,10 @@ public void run() {
         });
     }
 
+    // TODO: Fix or delete this test after integration of object notification from Object Store
     @Test
     @RunTestInLooperThread
-    public void realmListenerAddedAfterCommit() {
-        Realm realm = looperThread.realm;
-        realm.beginTransaction();
-        realm.commitTransaction();
-
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void realmResultsListenerAddedAfterCommit() {
-        Realm realm = looperThread.realm;
-        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-
-        looperThread.keepStrongReference.add(results);
-        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread
+    @Ignore
     public void realmObjectListenerAddedAfterCommit() {
         Realm realm = looperThread.realm;
         realm.beginTransaction();
@@ -955,256 +863,6 @@ public void onChange(Realm element) {
         });
     }
 
-    // FIXME check if the SharedRealm Changed in handleAsyncTransactionCompleted and reenable this test.
-    // We precisely depend on the order of triggering change listeners right now.
-    // So it should be:
-    // 1. Synced object listener
-    // 2. Synced results listener
-    // 3. Global listener
-    // Async listeners are not concerned by this test. Since they are triggered by different event and no advance read
-    // involved.
-    // If this case fails on your code, think twice before changing the test!
-    // https://github.com/realm/realm-java/issues/2408 is related to this test!
-    @Test
-    @Ignore("Listener on Realm might be trigger more times, ignore for now")
-    @RunTestInLooperThread
-    public void callingOrdersOfListeners() {
-        final Realm realm = looperThread.realm;
-        final AtomicInteger count = new AtomicInteger(0);
-
-        final RealmChangeListener<RealmResults<AllTypes>> syncedResultsListener =
-                new RealmChangeListener<RealmResults<AllTypes>>() {
-                    @Override
-                    public void onChange(RealmResults<AllTypes> element) {
-                        // First called.
-                        assertEquals(0, count.getAndIncrement());
-                    }
-                };
-
-        final RealmChangeListener<AllTypes> syncedObjectListener = new RealmChangeListener<AllTypes>() {
-            @Override
-            public void onChange(AllTypes element) {
-                // Second called.
-                assertEquals(1, count.getAndIncrement());
-            }
-        };
-        final RealmChangeListener<Realm> globalListener = new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm element) {
-                // Third called.
-                assertEquals(2, count.getAndIncrement());
-                looperThread.testComplete();
-            }
-        };
-
-
-        realm.beginTransaction();
-        final AllTypes allTypes = realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-
-        // We need to create one objects first and let the pass the first change event.
-        final RealmChangeListener<Realm> initListener = new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm element) {
-                looperThread.postRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        // Clears the change listeners.
-                        realm.removeAllChangeListeners();
-
-                        // Now we can start testing.
-                        allTypes.addChangeListener(syncedObjectListener);
-                        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-                        results.addChangeListener(syncedResultsListener);
-                        realm.addChangeListener(globalListener);
-
-                        // Now we trigger those listeners.
-                        realm.executeTransactionAsync(new Realm.Transaction() {
-                            @Override
-                            public void execute(Realm realm) {
-                                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
-                                assertNotNull(allTypes);
-                                allTypes.setColumnLong(42);
-                            }
-                        });
-                    }
-                });
-            }
-        };
-        realm.addChangeListener(initListener);
-    }
-
-    // See https://github.com/realm/realm-android-adapters/issues/48.
-    // Step 1: Populates the db.
-    // Step 2: Posts a runnable to caller thread.
-    //         Event Queue: |Posted Runnable| <- TOP
-    // Step 3: Deletes object which will make the results contain an invalid object at this moment.
-    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
-    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
-    // Step 4: Posted runnable called.
-    @Test
-    @RunTestInLooperThread(/*step1*/ before = PopulateOneAllTypes.class)
-    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueue() {
-        final Realm realm = looperThread.realm;
-        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-        assertEquals(1, results.size());
-
-        // Step 2
-        // The transaction later will trigger the results sync, and it should be run before this runnable.
-        looperThread.postRunnable(new Runnable() {
-            @Override
-            public void run() {
-                // Step 4
-                assertEquals(0, results.size());
-                realm.close();
-                looperThread.testComplete();
-            }
-        });
-
-        // Step 3
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
-                assertNotNull(allTypes);
-                allTypes.deleteFromRealm();
-                assertEquals(0, realm.where(AllTypes.class).count());
-                assertFalse(results.get(0).isValid());
-            }
-        });
-    }
-
-    // See https://github.com/realm/realm-android-adapters/issues/48.
-    // Step 1: Populates the db.
-    // Step 2: Creates a async query, and waits until it finishes.
-    // Step 3: Posts a runnable to caller thread.
-    //         Event Queue: |Posted Runnable| <- TOP
-    // Step 4: Deletes object which will make the results contain a invalid object at this moment.
-    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
-    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
-    // Step 5: Posted runnable called.
-    @Test
-    @RunTestInLooperThread(/*step1*/before = PopulateOneAllTypes.class)
-    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueueWithLoadedAsync() {
-        final AtomicBoolean changedFirstTime = new AtomicBoolean(false);
-        final Realm realm = looperThread.realm;
-        final RealmResults<AllTypes> asyncResults = realm.where(AllTypes.class).findAllAsync();
-        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-
-        assertEquals(1, results.size());
-
-        looperThread.keepStrongReference.add(asyncResults);
-        asyncResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> element) {
-                if (!changedFirstTime.get()) {
-                    // Step 2
-                    // The transaction later will trigger the results sync, and it should be run before this runnable.
-                    looperThread.postRunnable(new Runnable() {
-                        @Override
-                        public void run() {
-                            // Step 5
-                            assertEquals(0, asyncResults.size());
-                            assertEquals(0, results.size());
-                            looperThread.testComplete();
-                        }
-                    });
-
-                    // Step 3
-                    realm.executeTransaction(new Realm.Transaction() {
-                        @Override
-                        public void execute(Realm realm) {
-                            AllTypes allTypes = realm.where(AllTypes.class).findFirst();
-                            assertNotNull(allTypes);
-                            allTypes.deleteFromRealm();
-                            assertEquals(0, realm.where(AllTypes.class).count());
-                            assertFalse(results.get(0).isValid());
-                        }
-                    });
-                    changedFirstTime.set(true);
-                }
-            }
-        });
-    }
-
-    // See https://github.com/realm/realm-android-adapters/issues/48.
-    // Step 1: Populates the db.
-    // Step 2: Creates a async query, and pauses it.
-    // Step 3: Posts a runnable to caller thread.
-    //         Event Queue: |Posted Runnable| <- TOP
-    // Step 4: Deletes object which will make the results contain a invalid object at this moment.
-    //         Right Event Queue: |LOCAL_COMMIT   |   Wrong Event Queue: |Posted Runnable           |  <- TOP
-    //                            |Posted Runnable|                      |REALM_CHANGED/LOCAL_COMMIT|
-    // Step 5: Posted runnable called.
-    //
-    @Test
-    @RunTestInLooperThread(/*step1*/before = PopulateOneAllTypes.class)
-    public void realmListener_localChangeShouldBeSendAtFrontOfTheQueueWithPausedAsync() {
-        final Realm realm = looperThread.realm;
-
-        Realm.asyncTaskExecutor.pause();
-        final RealmResults<AllTypes> asyncResults = realm.where(AllTypes.class).findAllAsync();
-        final RealmResults<AllTypes> results = realm.where(AllTypes.class).findAll();
-
-        assertEquals(1, results.size());
-
-        // Step 2
-        // The transaction later will trigger the results sync, and it should be run before this runnable.
-        looperThread.postRunnable(new Runnable() {
-            @Override
-            public void run() {
-                // Step 5
-                assertFalse(asyncResults.isLoaded());
-                assertEquals(0, results.size());
-                looperThread.testComplete();
-            }
-        });
-
-        // Step 3
-        realm.executeTransaction(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                AllTypes allTypes = realm.where(AllTypes.class).findFirst();
-                assertNotNull(allTypes);
-                allTypes.deleteFromRealm();
-                assertEquals(0, realm.where(AllTypes.class).count());
-                assertFalse(results.get(0).isValid());
-            }
-        });
-    }
-
-    @Test
-    @RunTestInLooperThread
-    public void warnIfMixingSyncWritesAndAsyncQueries() {
-        final Realm realm = looperThread.realm;
-        final AtomicBoolean warningLogged = new AtomicBoolean(false);
-        final TestHelper.TestLogger testLogger = new TestHelper.TestLogger() {
-            @Override
-            public void log(int level, String tag, Throwable throwable, String message) {
-                assertTrue(message.contains("Mixing asynchronous queries with local writes should be avoided."));
-                if (level == LogLevel.WARN) {
-                    warningLogged.set(true);
-                }
-            }
-        };
-        RealmLog.add(testLogger);
-
-        realm.beginTransaction();
-        realm.createObject(AllTypes.class);
-        realm.commitTransaction();
-
-        RealmResults<AllTypes> results = realm.where(AllTypes.class).findAllAsync();
-        looperThread.keepStrongReference.add(results);
-        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> element) {
-                RealmLog.remove(testLogger);
-                assertTrue(warningLogged.get());
-                looperThread.testComplete();
-            }
-        });
-    }
-
     @Test
     @RunTestInLooperThread
     public void accessingSyncRealmResultInsideAsyncResultListener() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
new file mode 100644
index 0000000000..30f6521816
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
@@ -0,0 +1,442 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import io.realm.entities.Dog;
+import io.realm.entities.Owner;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
+import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertSame;
+import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertArrayEquals;
+
+// Tests for the ordered collection fine grained notifications for both RealmResults and RealmList.
+@RunWith(Parameterized.class)
+public class OrderedCollectionChangeSetTests {
+
+    private enum ObservablesType {
+        REALM_RESULTS, REALM_LIST
+    }
+
+    private interface ChangesCheck {
+        void check(OrderedCollectionChangeSet changeSet);
+    }
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private final ObservablesType type;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static List<ObservablesType> data() {
+        return Arrays.asList(ObservablesType.values());
+    }
+
+    public OrderedCollectionChangeSetTests(ObservablesType type) {
+        this.type = type;
+    }
+
+    @Before
+    public void setUp() {
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+    private void populateData(Realm realm, int testSize) {
+        Owner owner = null;
+        realm.beginTransaction();
+        if (type == ObservablesType.REALM_LIST) {
+            owner = realm.createObject(Owner.class);
+        }
+        for (int i = 0; i < testSize; i++) {
+            Dog dog = realm.createObject(Dog.class);
+            dog.setAge(i);
+            if (type == ObservablesType.REALM_LIST) {
+                owner.getDogs().add(dog);
+            }
+        }
+        realm.commitTransaction();
+    }
+
+    // The args should be [startIndex1, length1, startIndex2, length2, ...]
+    private void checkRanges(OrderedCollectionChangeSet.Range[] ranges, int... indexAndLen) {
+        if ((indexAndLen.length % 2 != 0))  {
+            fail("The 'indexAndLen' array length is not an even number.");
+        }
+        if (ranges.length != indexAndLen.length / 2) {
+            fail("The lengths of 'ranges' and 'indexAndLen' don't match.");
+        }
+        for (int i = 0; i < ranges.length; i++) {
+            OrderedCollectionChangeSet.Range range = ranges[i];
+            int startIndex = indexAndLen[i * 2];
+            int length = indexAndLen[i * 2 + 1];
+            if (range.startIndex != startIndex || range.length != length) {
+                fail("Range at index " + i + " doesn't match start index " + startIndex + " length " + length + ".");
+            }
+        }
+    }
+
+    // Re-adds the dogs so they would be sorted by age in the list.
+    private void reorderRealmList(Realm realm) {
+        RealmResults<Dog> dogs = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
+        Owner owner = realm.where(Owner.class).findFirst();
+        owner.getDogs().clear();
+        for (Dog dog : dogs) {
+            owner.getDogs().add(dog);
+        }
+    }
+
+    // Deletes Dogs objects which's columnLong is in the indices array.
+    private void deleteObjects(Realm realm, int... indices) {
+        for (int index : indices) {
+            realm.where(Dog.class).equalTo(Dog.FIELD_AGE, index).findFirst().deleteFromRealm();
+        }
+    }
+
+    // Creates Dogs objects with columnLong set to the value elements in indices array.
+    private void createObjects(Realm realm, int... indices) {
+        for (int index : indices) {
+            realm.createObject(Dog.class).setAge(index);
+        }
+        if (type == ObservablesType.REALM_LIST) {
+            reorderRealmList(realm);
+        }
+    }
+
+    // Modifies Dogs objects which's columnLong is in the indices array.
+    private void modifyObjects(Realm realm, int... indices) {
+        for (int index : indices) {
+            Dog obj = realm.where(Dog.class).equalTo(Dog.FIELD_AGE, index).findFirst();
+            assertNotNull(obj);
+            obj.setName("modified");
+        }
+    }
+
+    private void moveObjects(Realm realm, int originAge, int newAge) {
+        realm.where(Dog.class).equalTo(Dog.FIELD_AGE, originAge).findFirst().setAge(newAge);
+        if (type == ObservablesType.REALM_LIST) {
+            reorderRealmList(realm);
+        }
+    }
+
+    private void registerCheckListener(Realm realm, final ChangesCheck changesCheck) {
+        switch (type) {
+            case REALM_RESULTS:
+                RealmResults<Dog> results = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
+                looperThread.keepStrongReference.add(results);
+                results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
+                    @Override
+                    public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet changeSet) {
+                        changesCheck.check(changeSet);
+                    }
+                });
+                break;
+            case REALM_LIST:
+                RealmList<Dog> list = realm.where(Owner.class).findFirst().getDogs();
+                looperThread.keepStrongReference.add(list);
+                list.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Dog>>() {
+                    @Override
+                    public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet changeSet) {
+                        changesCheck.check(changeSet);
+                    }
+                });
+                break;
+        }
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void deletion() {
+        Realm realm = looperThread.realm;
+        populateData(realm, 10);
+
+        final ChangesCheck changesCheck = new ChangesCheck() {
+            @Override
+            public void check(OrderedCollectionChangeSet changeSet) {
+                checkRanges(changeSet.getDeletionRanges(),
+                        0, 1,
+                        2, 3,
+                        8, 2);
+                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 2, 3, 4, 8, 9});
+                assertEquals(0, changeSet.getChangeRanges().length);
+                assertEquals(0, changeSet.getInsertionRanges().length);
+                assertEquals(0, changeSet.getChanges().length);
+                assertEquals(0, changeSet.getInsertions().length);
+                looperThread.testComplete();
+            }
+        };
+
+        registerCheckListener(realm, changesCheck);
+
+        realm.beginTransaction();
+        deleteObjects(realm,
+                0,
+                2, 3, 4,
+                8, 9);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void insertion() {
+        Realm realm = looperThread.realm;
+        populateData(realm, 0); // We need to create the owner.
+        realm.beginTransaction();
+        createObjects(realm, 0, 2, 5, 6, 7, 9);
+        realm.commitTransaction();
+
+        ChangesCheck changesCheck = new ChangesCheck() {
+            @Override
+            public void check(OrderedCollectionChangeSet changeSet) {
+                checkRanges(changeSet.getInsertionRanges(),
+                        1, 1,
+                        3, 2,
+                        8, 1);
+                assertArrayEquals(changeSet.getInsertions(), new int[]{1, 3, 4, 8});
+                assertEquals(0, changeSet.getChangeRanges().length);
+                assertEquals(0, changeSet.getDeletionRanges().length);
+                assertEquals(0, changeSet.getChanges().length);
+                assertEquals(0, changeSet.getDeletions().length);
+                looperThread.testComplete();
+            }
+        };
+        registerCheckListener(realm, changesCheck);
+
+        realm.beginTransaction();
+        createObjects(realm,
+                1,
+                3, 4,
+                8);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void changes() {
+        Realm realm = looperThread.realm;
+        populateData(realm, 10);
+        ChangesCheck changesCheck = new ChangesCheck() {
+            @Override
+            public void check(OrderedCollectionChangeSet changeSet) {
+                checkRanges(changeSet.getChangeRanges(),
+                        0, 1,
+                        2, 3,
+                        8, 2);
+                assertArrayEquals(changeSet.getChanges(), new int[]{0, 2, 3, 4, 8, 9});
+                assertEquals(0, changeSet.getInsertionRanges().length);
+                assertEquals(0, changeSet.getDeletionRanges().length);
+                assertEquals(0, changeSet.getInsertions().length);
+                assertEquals(0, changeSet.getDeletions().length);
+                looperThread.testComplete();
+            }
+        };
+
+        registerCheckListener(realm, changesCheck);
+
+        realm.beginTransaction();
+        modifyObjects(realm,
+                0,
+                2, 3, 4,
+                8, 9);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void moves() {
+        Realm realm = looperThread.realm;
+        populateData(realm, 10);
+        ChangesCheck changesCheck = new ChangesCheck() {
+            @Override
+            public void check(OrderedCollectionChangeSet changeSet) {
+                checkRanges(changeSet.getDeletionRanges(),
+                        0, 1,
+                        9, 1);
+                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 9});
+                checkRanges(changeSet.getInsertionRanges(),
+                        0, 1,
+                        9, 1);
+                assertArrayEquals(changeSet.getInsertions(), new int[]{0, 9});
+                assertEquals(0, changeSet.getChangeRanges().length);
+                assertEquals(0, changeSet.getChanges().length);
+                looperThread.testComplete();
+            }
+        };
+        registerCheckListener(realm, changesCheck);
+
+        realm.beginTransaction();
+        moveObjects(realm, 0, 10);
+        moveObjects(realm, 9, 0);
+        realm.commitTransaction();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void mixed_changes() {
+        Realm realm = looperThread.realm;
+        populateData(realm, 10);
+        ChangesCheck changesCheck = new ChangesCheck() {
+            @Override
+            public void check(OrderedCollectionChangeSet changeSet) {
+                checkRanges(changeSet.getDeletionRanges(),
+                        0, 2,
+                        5, 1);
+                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 1, 5});
+
+                checkRanges(changeSet.getInsertionRanges(),
+                        0, 2,
+                        9, 2);
+                assertArrayEquals(changeSet.getInsertions(), new int[]{0, 1, 9, 10});
+
+                checkRanges(changeSet.getChangeRanges(),
+                        3, 2,
+                        8, 1);
+                assertArrayEquals(changeSet.getChanges(), new int[]{3, 4, 8});
+
+                looperThread.testComplete();
+            }
+        };
+
+        registerCheckListener(realm, changesCheck);
+
+        realm.beginTransaction();
+        createObjects(realm, 11, 12, -1, -2);
+        deleteObjects(realm, 0, 1, 5);
+        modifyObjects(realm, 12, 3, 4, 9);
+        realm.commitTransaction();
+        // After transaction, '*' means the object has been modified. 12 has been modified as well, but it is created
+        // and modified in the same transaction, should not be counted in the changes range.
+        // [-1, -2, 2, *3, *4, 6, 7, 8, *9, 11, 12]
+    }
+
+    // Change some objects then delete them. Only deletion changes should be sent.
+    @Test
+    @RunTestInLooperThread
+    public void changes_then_delete() {
+        Realm realm = looperThread.realm;
+        populateData(realm, 10);
+        ChangesCheck changesCheck = new ChangesCheck() {
+            @Override
+            public void check(OrderedCollectionChangeSet changeSet) {
+                checkRanges(changeSet.getDeletionRanges(),
+                        0, 2,
+                        5, 1);
+                assertArrayEquals(changeSet.getDeletions(), new int[]{0, 1, 5});
+
+                assertEquals(0, changeSet.getInsertionRanges().length);
+                assertEquals(0, changeSet.getInsertions().length);
+                assertEquals(0, changeSet.getChangeRanges().length);
+                assertEquals(0, changeSet.getChanges().length);
+
+                looperThread.testComplete();
+            }
+        };
+        registerCheckListener(realm, changesCheck);
+
+        realm.beginTransaction();
+        modifyObjects(realm, 0, 1, 5);
+        deleteObjects(realm, 0, 1, 5);
+        realm.commitTransaction();
+    }
+
+    // Insert some objects then delete them in the same transaction, the listener should not be triggered.
+    @Test
+    @RunTestInLooperThread
+    public void insert_then_delete() {
+        Realm realm = looperThread.realm;
+        populateData(realm, 10);
+        ChangesCheck changesCheck = new ChangesCheck() {
+            @Override
+            public void check(OrderedCollectionChangeSet changeSet) {
+                fail("The listener should not be triggered since the collection has no changes compared with before.");
+            }
+        };
+
+        registerCheckListener(realm, changesCheck);
+
+        looperThread.postRunnableDelayed(new Runnable() {
+            @Override
+            public void run() {
+                looperThread.testComplete();
+            }
+        }, 1000);
+
+        realm.beginTransaction();
+        createObjects(realm, 10, 11);
+        deleteObjects(realm, 10, 11);
+        realm.commitTransaction();
+    }
+
+    // The change set should empty when the async query returns at the first time.
+    @Test
+    @RunTestInLooperThread
+    public void emptyChangeSet_findAllAsync(){
+        if (type == ObservablesType.REALM_LIST) {
+            looperThread.testComplete();
+            return;
+        }
+        Realm realm = looperThread.realm;
+        populateData(realm, 10);
+        final RealmResults<Dog> results = realm.where(Dog.class).findAllSortedAsync(Dog.FIELD_AGE);
+        results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
+            @Override
+            public void onChange(RealmResults<Dog> collection, OrderedCollectionChangeSet changeSet) {
+                assertSame(collection, results);
+                assertEquals(9, collection.size());
+                assertNull(changeSet);
+                looperThread.testComplete();
+            }
+        });
+
+        final CountDownLatch bgDeletionLatch = new CountDownLatch(1);
+        // beginTransaction() will make the async query return immediately. So we have to create an object in another
+        // thread. Also, the latch has to be counted down after transaction committed so the async query results can
+        // contain the modification in the background transaction.
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                Realm realm = Realm.getInstance(looperThread.realmConfiguration)      ;
+                realm.beginTransaction();
+                realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 0).findFirst().deleteFromRealm();
+                realm.commitTransaction();
+                realm.close();
+                bgDeletionLatch.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(bgDeletionLatch);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index 3484cb2c1f..ac34cedc51 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -82,15 +82,19 @@ public void tearDown() {
     }
 
     private OrderedRealmCollection<AllJavaTypes> createCollection(Realm realm, CollectionClass collectionClass, int sampleSize) {
+        OrderedRealmCollection<AllJavaTypes> orderedCollection;
+
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 boolean isEmpty = (sampleSize == 0);
                 int newSampleSize = (isEmpty) ? 2 : sampleSize;
                 populateRealm(realm, newSampleSize);
-                return realm.where(AllJavaTypes.class)
-                    .equalTo(AllJavaTypes.FIELD_LONG, isEmpty ? 1 : 0)
-                    .findFirst()
-                    .getFieldList();
+                orderedCollection = realm.where(AllJavaTypes.class)
+                        .equalTo(AllJavaTypes.FIELD_LONG, isEmpty ? 1 : 0)
+                        .findFirst()
+                        .getFieldList();
+                break;
 
             case UNMANAGED_REALMLIST:
                 populateRealm(realm, sampleSize);
@@ -99,30 +103,20 @@ public void tearDown() {
                 inMemoryList.addAll(objects);
                 return inMemoryList;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 populateRealm(realm, sampleSize);
-                return realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                orderedCollection = realm.where(AllJavaTypes.class)
+                        .findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                break;
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
         }
-    }
-
-    private void appendElementToCollection(Realm realm, CollectionClass collection) {
-        realm.beginTransaction();
-        switch (collectionClass) {
-            case MANAGED_REALMLIST:
-                realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 0).findFirst().getFieldList().add(new AllJavaTypes(TEST_SIZE + 1));
-                break;
-
-            case UNMANAGED_REALMLIST:
-            case REALMRESULTS:
-                realm.createObject(AllJavaTypes.class, TEST_SIZE + 1);
-                break;
-            default:
-                fail("Unknown class: " + collection);
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
         }
-        realm.commitTransaction();
+        return orderedCollection;
     }
 
     private void createNewObject() {
@@ -153,6 +147,19 @@ private boolean skipTest(CollectionClass... unsupportedTypes) {
         return false;
     }
 
+    private void assertResultsOrSnapshot() {
+        if (collectionClass != CollectionClass.REALMRESULTS && !isSnapshot(collectionClass))  {
+            fail("Collection class " + collectionClass + "is not results or snapshot.");
+        }
+    }
+
+    private void assertRealmList() {
+        if (collectionClass != CollectionClass.UNMANAGED_REALMLIST &&
+                collectionClass != CollectionClass.MANAGED_REALMLIST)  {
+            fail("Collection class " + collectionClass + "is not RealmList.");
+        }
+    }
+
     @Test
     public void iterator() {
         Iterator<AllJavaTypes> it = collection.iterator();
@@ -229,7 +236,7 @@ public void iterator_closedRealm_methodsThrows() {
         } catch (IllegalStateException e) {
             assertEquals(CollectionClass.MANAGED_REALMLIST, collectionClass);
         } catch (UnsupportedOperationException e) {
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertResultsOrSnapshot();
         }
     }
 
@@ -242,9 +249,9 @@ public void iterator_remove_beforeNext() {
             it.remove();
             fail();
         } catch (UnsupportedOperationException e) {
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertResultsOrSnapshot();
         } catch (IllegalStateException ignored) {
-            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertRealmList();
         }
     }
 
@@ -259,7 +266,7 @@ public void iterator_remove() {
             it.remove();
         } catch (UnsupportedOperationException e) {
             // RealmResults doesn't support remove.
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertResultsOrSnapshot();
             return;
         }
 
@@ -280,16 +287,20 @@ public void iterator_deleteManagedObjectIndirectly() {
         realm.commitTransaction();
 
         switch (collectionClass) {
+            // Snapshot
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
+                assertFalse(collection.get(1).isValid());
+                break;
             // Managed RealmLists are directly associated with their table. Thus any indirect deletion will
             // also remove it from the LinkView.
             case MANAGED_REALMLIST:
+            case REALMRESULTS:
                 assertEquals(TEST_SIZE - 1, collection.size());
                 break;
 
-            // Unmanaged collections are not affected by changes to Realm and RealmResult should maintain a stable
-            // view until next time sync_if_needed is called.
+            // Unmanaged collections are not affected by changes to Realm.
             case UNMANAGED_REALMLIST:
-            case REALMRESULTS:
                 assertEquals(TEST_SIZE, collection.size());
                 break;
 
@@ -300,7 +311,8 @@ public void iterator_deleteManagedObjectIndirectly() {
 
     @Test
     public void iterator_removeCalledTwice() {
-        if (skipTest(CollectionClass.REALMRESULTS)) {
+        if (skipTest(CollectionClass.REALMRESULTS, CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE,
+                CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE)) {
             return; // remove() not supported by RealmResults.
         }
 
@@ -418,9 +430,9 @@ public void listIterator_remove_beforeNext() {
         try {
             it.remove();
         } catch (IllegalStateException e) {
-            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertRealmList();
         } catch (UnsupportedOperationException e) {
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertResultsOrSnapshot();
         }
     }
 
@@ -437,6 +449,8 @@ public void listIterator_remove_calledTwice() {
                 thrown.expect(IllegalStateException.class);
                 it.remove();
                 break;
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 try {
                     it.remove(); // Method not supported.
@@ -506,57 +520,67 @@ public void listIterator_closedRealm_methods() {
             it.remove();
             fail();
         } catch (IllegalStateException e) {
-            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertRealmList();
         } catch (UnsupportedOperationException ignored) {
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertResultsOrSnapshot();
         }
     }
 
     @Test
     public void listIterator_deleteManagedObjectIndirectly() {
         realm.beginTransaction();
-        Iterator<AllJavaTypes> it = collection.iterator();
+        ListIterator<AllJavaTypes> it = collection.listIterator();
         it.next();
         it.next().deleteFromRealm();
         realm.commitTransaction();
 
         switch (collectionClass) {
             case MANAGED_REALMLIST:
+            case REALMRESULTS:
                 assertEquals(TEST_SIZE - 1, collection.size());
                 break;
             case UNMANAGED_REALMLIST:
-            case REALMRESULTS:
                 assertEquals(TEST_SIZE, collection.size());
                 break;
         }
-        it = collection.listIterator();
-        it.next();
-        AllJavaTypes types = it.next(); // Iterator can still access the deleted object.
+        it.previous();
+        AllJavaTypes types = it.next(); // Iterator can still access the deleted object
 
         //noinspection SimplifiableConditionalExpression
         assertTrue(collectionClass == CollectionClass.MANAGED_REALMLIST ? types.isValid() : !types.isValid());
     }
 
     @Test
-    public void listIterator_remove_doesNotDeleteObject() {
+    public void listIterator_remove_realmList_doesNotDeleteObject() {
+        if (skipTest(CollectionClass.REALMRESULTS, CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE,
+                CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE)) {
+            return;
+        }
         ListIterator<AllJavaTypes> it = collection.listIterator();
         AllJavaTypes obj = it.next();
         assertEquals("test data 0", obj.getFieldString());
         realm.beginTransaction();
-        try {
-            it.remove();
-            if (collectionClass == CollectionClass.REALMRESULTS) {
-                fail();
-            }
-            assertTrue(obj.isValid());
-        } catch (UnsupportedOperationException e) {
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+        it.remove();
+        assertTrue(obj.isValid());
+    }
+
+    @Test
+    public void listIterator_remove_nonRealmList_throwUnsupported() {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+           return;
         }
+        ListIterator<AllJavaTypes> it = collection.listIterator();
+        AllJavaTypes obj = it.next();
+        assertEquals("test data 0", obj.getFieldString());
+        realm.beginTransaction();
+        thrown.expect(UnsupportedOperationException.class);
+        it.remove();
     }
 
     @Test
     public void listIterator_set() {
-        if (skipTest(CollectionClass.REALMRESULTS)) {
+        if (skipTest(CollectionClass.REALMRESULTS, CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE,
+                CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE)) {
             return;
         }
 
@@ -609,33 +633,34 @@ public void listIterator_unsupportedMethods() {
             it.remove();
             fail();
         } catch (UnsupportedOperationException e) {
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertResultsOrSnapshot();
         } catch (IllegalStateException e) {
-            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertRealmList();
         }
 
         try {
             it.add(null);
             fail();
         } catch (UnsupportedOperationException e) {
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertResultsOrSnapshot();
         } catch (IllegalArgumentException e) {
-            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertRealmList();
         }
 
         try {
             it.set(new AllJavaTypes());
             fail();
         } catch (UnsupportedOperationException e) {
-            assertEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertResultsOrSnapshot();
         } catch (IllegalStateException e) {
-            assertNotEquals(CollectionClass.REALMRESULTS, collectionClass);
+            assertRealmList();
         }
     }
 
     @Test
     public void iterator_outsideChangeToSizeThrowsConcurrentModification() {
-        if (skipTest(CollectionClass.REALMRESULTS)) {
+        if (skipTest(CollectionClass.REALMRESULTS, CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE,
+                CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE)) {
             return;
         }
 
@@ -701,7 +726,8 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification() {
 
     @Test
     public void iterator_outsideChangeToSizeThrowsConcurrentModification_managedCollection() {
-        if (skipTest(CollectionClass.REALMRESULTS, CollectionClass.UNMANAGED_REALMLIST)) {
+        if (skipTest(CollectionClass.REALMRESULTS, CollectionClass.UNMANAGED_REALMLIST,
+                CollectionClass.REALMRESULTS_SNAPSHOT_LIST_BASE, CollectionClass.REALMRESULTS_SNAPSHOT_RESULTS_BASE)) {
             return;
         }
 
@@ -748,6 +774,7 @@ public void iterator_outsideChangeToSizeThrowsConcurrentModification_managedColl
                 case SORT_FIELD:
                 case SORT_2FIELDS:
                 case SORT_MULTI:
+                case CREATE_SNAPSHOT:
                     realm.cancelTransaction();
                     continue;
                 default:
@@ -771,8 +798,10 @@ private void checkIteratorThrowsConcurrentModification(Realm realm, String metho
         }
     }
 
+    // Accessing RealmResults iterator after receving remote change notification will throw.
+    // But it is valid operation for snapshot.
     @Test
-    public void iterator_realmResultsThrowConcurrentModification() {
+    public void iterator_realmResultsThrowConcurrentModification_snapshotJustWorks() {
         if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
             return;
         }
@@ -795,18 +824,19 @@ public void run() {
         realm.waitForChange();
         try {
             it.next();
-            fail();
+            assertEquals(TEST_SIZE, collection.size());
         } catch (ConcurrentModificationException ignored) {
+            assertEquals(collectionClass, CollectionClass.REALMRESULTS);
         }
     }
 
     @Test
     public void useCase_simpleIterator_modifyQueryResult_innerTransaction() {
-        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST,
+                CollectionClass.REALMRESULTS)) {
             return;
         }
 
-        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(TEST_SIZE, collection.size());
         for (int i = 0; i < collection.size(); i++) {
             realm.beginTransaction();
@@ -821,11 +851,11 @@ public void useCase_simpleIterator_modifyQueryResult_innerTransaction() {
 
     @Test
     public void useCase_simpleIterator_modifyQueryResult_outerTransaction() {
-        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST,
+                CollectionClass.REALMRESULTS)) {
             return;
         }
 
-        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(TEST_SIZE, collection.size());
         realm.beginTransaction();
         for (int i = 0; i < collection.size(); i++) {
@@ -844,7 +874,6 @@ public void useCase_forEachIterator_modifyQueryResult_innerTransaction() {
             return;
         }
 
-        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(TEST_SIZE, collection.size());
         for (AllJavaTypes obj : collection) {
             realm.beginTransaction();
@@ -862,7 +891,6 @@ public void useCase_forEachIterator_modifyQueryResult_outerTransaction() {
             return;
         }
 
-        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(TEST_SIZE, collection.size());
         realm.beginTransaction();
         for (AllJavaTypes obj : collection) {
@@ -877,11 +905,11 @@ public void useCase_forEachIterator_modifyQueryResult_outerTransaction() {
     @Test
     @UiThreadTest
     public void useCase_simpleIterator_modifyQueryResult_innerTransaction_looperThread() {
-        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST,
+                CollectionClass.REALMRESULTS)) {
             return;
         }
 
-        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(TEST_SIZE, collection.size());
         for (int i = 0; i < collection.size(); i++) {
             realm.beginTransaction();
@@ -897,11 +925,11 @@ public void useCase_simpleIterator_modifyQueryResult_innerTransaction_looperThre
     @Test
     @UiThreadTest
     public void useCase_simpleIterator_modifyQueryResult_outerTransaction_looperThread() {
-        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST)) {
+        if (skipTest(CollectionClass.MANAGED_REALMLIST, CollectionClass.UNMANAGED_REALMLIST,
+                CollectionClass.REALMRESULTS)) {
             return;
         }
 
-        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(TEST_SIZE, collection.size());
         realm.beginTransaction();
         for (int i = 0; i < collection.size(); i++) {
@@ -921,7 +949,6 @@ public void useCase_forEachIterator_modifyQueryResult_innerTransaction_looperThr
             return;
         }
 
-        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(TEST_SIZE, collection.size());
         for (AllJavaTypes obj : collection) {
             realm.beginTransaction();
@@ -940,7 +967,6 @@ public void useCase_forEachIterator_modifyQueryResult_outerTransaction_looperThr
             return;
         }
 
-        collection = realm.where(AllJavaTypes.class).lessThan(AllJavaTypes.FIELD_LONG, TEST_SIZE).findAll();
         assertEquals(TEST_SIZE, collection.size());
         realm.beginTransaction();
         for (AllJavaTypes obj : collection) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionSnapshotTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionSnapshotTests.java
new file mode 100644
index 0000000000..6d43158ba5
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionSnapshotTests.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import io.realm.entities.AllTypes;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+
+/**
+ * Unit tests specific for {@link OrderedRealmCollectionSnapshot} that cannot be covered by
+ * {@link OrderedRealmCollectionTests}, {@link ManagedRealmCollectionTests}, {@link UnManagedRealmCollectionTests} or
+ * {@link RealmCollectionTests}.
+ */
+@RunWith(AndroidJUnit4.class)
+public class OrderedRealmCollectionSnapshotTests {
+
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private static final int TEST_SIZE = 10;
+    private Realm realm;
+    private OrderedRealmCollection<AllTypes> snapshot;
+
+    @Before
+    public void setup() {
+        realm = Realm.getInstance(configFactory.createConfiguration());
+        populateRealm(realm, TEST_SIZE);
+        snapshot = realm.where(AllTypes.class).findAll().createSnapshot();
+    }
+
+    @After
+    public void tearDown() {
+        realm.close();
+    }
+
+    private void populateRealm(Realm realm, int testSize) {
+        realm.beginTransaction();
+        for (int i = 0; i < testSize; i++) {
+            AllTypes allTypes = realm.createObject(AllTypes.class);
+            allTypes.setColumnLong(i);
+        }
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void deleteFromRealm_twice() {
+        realm.beginTransaction();
+        snapshot.deleteFromRealm(0);
+        snapshot.deleteFromRealm(0);
+        realm.commitTransaction();
+        assertFalse(snapshot.get(0).isValid());
+    }
+
+    @Test
+    public void deleteFirstFromRealm_twice() {
+        realm.beginTransaction();
+        assertTrue(snapshot.deleteFirstFromRealm());
+        assertFalse(snapshot.deleteFirstFromRealm());
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void deleteLastFromRealm_twice() {
+        realm.beginTransaction();
+        assertTrue(snapshot.deleteLastFromRealm());
+        assertFalse(snapshot.deleteLastFromRealm());
+        realm.commitTransaction();
+    }
+
+    @Test
+    public void deleteAllFromRealmTwice() {
+        realm.beginTransaction();
+        assertTrue(snapshot.deleteAllFromRealm());
+        assertTrue(snapshot.deleteAllFromRealm());
+        realm.commitTransaction();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
index 8bee6afa70..d722f024de 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionTests.java
@@ -34,6 +34,7 @@
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.fail;
 
 /**
@@ -43,15 +44,16 @@
  *
  * # RealmOrderedCollection
  *
- * + E first()
- * + E last()
- * - void sort(String field)
- * - void sort(String field, Sort sortOrder)
- * - void sort(String field1, Sort sortOrder1, String field2, Sort sortOrder2)
- * - void sort(String[] fields, Sort[] sortOrders)
- * - void deleteFromRealm(int location)
- * - void deleteFirstFromRealm()
+ * + E first();
+ * + E last();
+ * - void sort(String field);
+ * - void sort(String field, Sort sortOrder);
+ * - void sort(String field1, Sort sortOrder1, String field2, Sort sortOrder2);
+ * - void sort(String[] fields, Sort[] sortOrders);
+ * - void deleteFromRealm(int location);
+ * - void deleteFirstFromRealm();
  * - void deleteLastFromRealm();
+ * - OrderedRealmCollectionSnapshot createSnapshot();
  *
  * # List
  *
@@ -138,49 +140,69 @@ public void tearDown() {
     }
 
     private OrderedRealmCollection<AllJavaTypes> createCollection(Realm realm, CollectionClass collectionClass) {
+        OrderedRealmCollection<AllJavaTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 populateRealm(realm, TEST_SIZE);
-                return realm.where(AllJavaTypes.class)
+                orderedCollection = realm.where(AllJavaTypes.class)
                         .equalTo(AllJavaTypes.FIELD_LONG, 0)
                         .findFirst()
                         .getFieldList();
+                break;
 
             case UNMANAGED_REALMLIST:
                 return populateInMemoryList(TEST_SIZE);
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 populateRealm(realm, TEST_SIZE);
-                return realm.where(AllJavaTypes.class).findAll();
+                orderedCollection = realm.where(AllJavaTypes.class).findAll();
+                break;
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
         }
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     private OrderedRealmCollection<AllJavaTypes> createEmptyCollection(Realm realm, CollectionClass collectionClass) {
+        OrderedRealmCollection<AllJavaTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
-                return realm.where(AllJavaTypes.class)
+                orderedCollection = realm.where(AllJavaTypes.class)
                         .equalTo(AllJavaTypes.FIELD_LONG, 1)
                         .findFirst()
                         .getFieldList();
+                break;
 
             case UNMANAGED_REALMLIST:
                 return new RealmList<AllJavaTypes>();
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, -1).findAll();
+                orderedCollection = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, -1).findAll();
+                break;
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
         }
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     private Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>> createCollectionWithMultipleCopies(Realm realm, CollectionClass collectionClass) {
 
+        OrderedRealmCollection<AllJavaTypes>  orderedCollection;
         AllJavaTypes obj;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 obj = realm.where(AllJavaTypes.class)
                         .equalTo(AllJavaTypes.FIELD_LONG, 1)
@@ -189,20 +211,29 @@ public void tearDown() {
                 realm.beginTransaction();
                 list.add(obj);
                 realm.commitTransaction();
-                return new Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>>(obj, list);
+                orderedCollection = list;
+                break;
 
             case UNMANAGED_REALMLIST:
                 obj = new AllJavaTypes(1);
                 return new Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>>(obj, new RealmList<AllJavaTypes>(obj, obj));
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 RealmResults<AllJavaTypes> result = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_LONG, 1).findAll();
                 obj = result.first();
-                return new Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>>(obj, result);
+                orderedCollection = result;
+                break;
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
         }
+
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+
+        return new Pair<AllJavaTypes, OrderedRealmCollection<AllJavaTypes>>(obj, orderedCollection);
     }
 
     @Test
@@ -325,7 +356,7 @@ public void subList_invalidEnd() {
         collection.subList(0, TEST_SIZE + 1);
     }
 
-    // Check that all releveant methods throw a correct IndexOutOfBounds
+    // Checks that all relevant methods throw a correct IndexOutOfBounds
     @Test
     public void methods_indexOutOfBounds() {
         collection = createEmptyCollection(realm, collectionClass);
@@ -371,6 +402,7 @@ public void methods_indexOutOfBounds() {
                     case SORT_FIELD:
                     case SORT_2FIELDS:
                     case SORT_MULTI:
+                    case CREATE_SNAPSHOT:
                         continue;
                 }
                 fail(method + " did not throw an exception");
@@ -382,4 +414,24 @@ public void methods_indexOutOfBounds() {
         }
     }
 
+    @Test
+    public void createSnapshot() {
+        if (collectionClass == CollectionClass.UNMANAGED_REALMLIST) {
+            thrown.expect(UnsupportedOperationException.class);
+        }
+        OrderedRealmCollectionSnapshot snapshot = collection.createSnapshot();
+        switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
+                // Creating snapshot from a snapshot will just return the same object.
+                assertSame(collection, snapshot);
+                break;
+            case MANAGED_REALMLIST:
+            case REALMRESULTS:
+                assertEquals(collection.size(), snapshot.size());
+                break;
+            default:
+                break;
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 3e2b84a346..ee1c90b67d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -16,20 +16,16 @@
 
 package io.realm;
 
-import android.os.Handler;
 import android.os.SystemClock;
-import android.support.test.annotation.UiThreadTest;
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
-import java.lang.ref.WeakReference;
 import java.util.Date;
-import java.util.Iterator;
-import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -41,9 +37,6 @@
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
-import io.realm.instrumentation.MockActivityManager;
-import io.realm.internal.HandlerControllerConstants;
-import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLog;
@@ -61,13 +54,14 @@
 
 @RunWith(AndroidJUnit4.class)
 public class RealmAsyncQueryTests {
-
     @Rule
     public final RunInLooperThread looperThread = new RunInLooperThread();
     @Rule
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
     @Rule
     public final UiThreadTestRule uiThreadTestRule = new UiThreadTestRule();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
 
 
     // ****************************
@@ -125,25 +119,78 @@ public void onSuccess() {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_onSuccessCallerRealmClosed() throws Throwable {
+        final Realm realm = looperThread.realm;
+        assertEquals(0, realm.where(Owner.class).count());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                Owner owner = realm.createObject(Owner.class);
+                owner.setName("Owner");
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+                assertTrue(realm.isClosed());
+                Realm newRealm = Realm.getInstance(looperThread.realmConfiguration);
+                assertEquals(1, newRealm.where(Owner.class).count());
+                assertEquals("Owner", newRealm.where(Owner.class).findFirst().getName());
+                looperThread.testComplete();
+            }
+        });
+        realm.close();
+    }
+
     @Test
     @RunTestInLooperThread
     public void executeTransactionAsync_onError() throws Throwable {
         final Realm realm = looperThread.realm;
+        final RuntimeException runtimeException = new RuntimeException("Oh! What a Terrible Failure");
         assertEquals(0, realm.where(Owner.class).count());
 
         realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
             public void execute(Realm realm) {
-                throw new RuntimeException("Oh! What a Terrible Failure");
+                throw runtimeException;
             }
         }, new Realm.Transaction.OnError() {
             @Override
             public void onError(Throwable error) {
                 assertEquals(0, realm.where(Owner.class).count());
                 assertNull(realm.where(Owner.class).findFirst());
+                assertEquals(runtimeException, error);
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void executeTransactionAsync_onErrorCallerRealmClosed() throws Throwable {
+        final Realm realm = looperThread.realm;
+        final RuntimeException runtimeException = new RuntimeException("Oh! What a Terrible Failure");
+        assertEquals(0, realm.where(Owner.class).count());
+
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                throw runtimeException;
+            }
+        }, new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable error) {
+                assertTrue(realm.isClosed());
+                Realm newRealm = Realm.getInstance(looperThread.realmConfiguration);
+                assertEquals(0, newRealm.where(Owner.class).count());
+                assertNull(newRealm.where(Owner.class).findFirst());
+                assertEquals(runtimeException, error);
                 looperThread.testComplete();
             }
         });
+        realm.close();
     }
 
     @Test
@@ -168,10 +215,10 @@ public void onChange(Realm object) {
         });
     }
 
-    // Tests that an async transaction that throws an exception propagate it properly to the user.
+    // Tests that an async transaction that throws when call cancelTransaction manually.
     @Test
     @RunTestInLooperThread
-    public void executeTransactionAsync_exceptionHandling() throws Throwable {
+    public void executeTransactionAsync_cancelTransactionInside() throws Throwable {
         final TestHelper.TestLogger testLogger = new TestHelper.TestLogger(LogLevel.DEBUG);
         RealmLog.add(testLogger);
 
@@ -184,8 +231,7 @@ public void executeTransactionAsync_exceptionHandling() throws Throwable {
             public void execute(Realm realm) {
                 Owner owner = realm.createObject(Owner.class);
                 owner.setName("Owner");
-                realm.cancelTransaction(); // Cancels the transaction then throw.
-                throw new RuntimeException("Boom");
+                realm.cancelTransaction();
             }
         }, new Realm.Transaction.OnSuccess() {
             @Override
@@ -195,8 +241,10 @@ public void onSuccess() {
         }, new Realm.Transaction.OnError() {
             @Override
             public void onError(Throwable error) {
-                // Ensures we are giving developers quality messages in the logs.
-                assertEquals("Could not cancel transaction, not currently in a transaction.", testLogger.message);
+                // Ensure we are giving developers quality messages in the logs.
+                assertTrue(testLogger.message.contains(
+                        "Exception has been thrown: Can't commit a non-existing write transaction"));
+                assertTrue(error instanceof IllegalStateException);
                 RealmLog.remove(testLogger);
                 looperThread.testComplete();
             }
@@ -301,7 +349,12 @@ public void execute(Realm realm) {
             @Override
             public void onSuccess() {
                 assertEquals(1, realm.where(AllTypes.class).count());
-                assertEquals(1, results.size());
+                // We cannot guarantee the async results get delivered from OS.
+                if (results.isLoaded()) {
+                    assertEquals(1, results.size());
+                } else {
+                    assertEquals(0, results.size());
+                }
                 looperThread.testComplete();
             }
         }, new Realm.Transaction.OnError() {
@@ -312,6 +365,38 @@ public void onError(Throwable error) {
         });
     }
 
+    @Test
+    public void executeTransactionAsync_onSuccessOnNonLooperThreadThrows() {
+        Realm realm = Realm.getInstance(configFactory.createConfiguration());
+        thrown.expect(IllegalStateException.class);
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+
+            }
+        }, new Realm.Transaction.OnSuccess() {
+            @Override
+            public void onSuccess() {
+            }
+        });
+    }
+
+    @Test
+    public void executeTransactionAsync_onErrorOnNonLooperThreadThrows() {
+        Realm realm = Realm.getInstance(configFactory.createConfiguration());
+        thrown.expect(IllegalStateException.class);
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+
+            }
+        }, new Realm.Transaction.OnError() {
+            @Override
+            public void onError(Throwable error) {
+            }
+        });
+    }
+
     // ************************************
     // *** promises based async queries ***
     // ************************************
@@ -375,37 +460,15 @@ public void findAllAsync_throwsOnNonLooperThread() throws Throwable {
         Realm realm = Realm.getInstance(configFactory.createConfiguration());
         try {
             realm.where(AllTypes.class).findAllAsync();
+            fail();
         } catch (IllegalStateException ignored) {
         } finally {
             realm.close();
         }
     }
 
-    @Test
-    @RunTestInLooperThread
-    public void findAllAsync_reusingQuery() throws Throwable {
-        Realm realm = looperThread.realm;
-        populateTestRealm(realm, 10);
-
-        RealmQuery<AllTypes> query = realm.where(AllTypes.class)
-                .between("columnLong", 0, 4);
-        RealmResults<AllTypes> queryAllSync = query.findAll();
-        RealmResults<AllTypes> allAsync = query.findAllAsync();
-
-        assertTrue(allAsync.load());
-        assertEquals(allAsync, queryAllSync);
-
-        // The RealmQuery already has an argumentHolder, can't reuse it.
-        try {
-            query.findAllSorted("columnLong");
-            fail("Should throw an exception, can not reuse RealmQuery");
-        } catch (IllegalStateException ignored) {
-            looperThread.testComplete();
-        }
-    }
-
-    // Finds elements [0-4] asynchronously then waits for the promise to be loaded
-    // using a callback to be notified when the data is loaded.
+    // finding elements [0-4] asynchronously then wait for the promise to be loaded
+    // using a callback to be notified when the data is loaded
     @Test
     @RunTestInLooperThread
     public void findAllAsync_withNotification() throws Throwable {
@@ -463,352 +526,6 @@ public void onChange(RealmResults<AllTypes> object) {
         assertEquals(5, realmResults.size());
     }
 
-    // UC:
-    //   1- Inserts 10 objects.
-    //   2- Starts an async query to find object [0-4].
-    //   3- Asserts current RealmResults is empty (Worker Thread didn't complete).
-    //   4- When the worker thread completes, advances the Realm.
-    //   5- The caller thread is ahead of the result provided by the worker thread.
-    //   6- Retries automatically the async query.
-    //   7- The returned RealmResults is now in the same version as the caller thread.
-    //   8- The notification should be called once (when we retry automatically we shouldn't
-    //      notify the user).
-    @Test
-    @RunTestInLooperThread
-    public void findAllAsync_retry() throws Throwable {
-        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
-        final AtomicInteger numberOfInvocation = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
-
-        // 1. Populates initial data.
-        realm.setAutoRefresh(false);
-        populateTestRealm(realm, 10);
-        realm.setAutoRefresh(true);
-
-        // 2. Configures handler interceptor.
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                // Intercepts in order: [QueryComplete, RealmChanged, QueryUpdated].
-                int intercepts = numberOfIntercept.incrementAndGet();
-                switch (what) {
-                    // 5. Intercepts all messages from other threads. On the first complete, we advance the tread
-                    // which will cause the async query to rerun instead of triggering the change listener.
-                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
-                        if (intercepts == 1) {
-                            // We advance the Realm so we can simulate a retry.
-                            realm.beginTransaction();
-                            realm.delete(AllTypes.class);
-                            realm.commitTransaction();
-                        }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        // 3. Creates a async query.
-        final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
-                .between("columnLong", 0, 4)
-                .findAllAsync();
-
-        // 4. Ensures that query isn't loaded yet.
-        assertFalse(realmResults.isLoaded());
-        assertEquals(0, realmResults.size());
-
-        // 6. Callback triggered after retry has completed.
-        looperThread.keepStrongReference.add(realmResults);
-        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                assertEquals(3, numberOfIntercept.get());
-                assertEquals(1, numberOfInvocation.incrementAndGet());
-                assertTrue(realmResults.isLoaded());
-                assertEquals(0, realmResults.size());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    // UC:
-    //   1- Inserts 10 objects.
-    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
-    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
-    //   4- The queries will complete with the same version as the caller thread.
-    //   5- Using a background thread update the Realm.
-    //   6- Now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries.
-    //   7- Callbacks are notified with the latest results (called twice overall).
-    @Test
-    @RunTestInLooperThread
-    public void findAllAsync_batchUpdate() throws Throwable {
-        final AtomicInteger numberOfNotificationsQuery1 = new AtomicInteger(0);
-        final AtomicInteger numberOfNotificationsQuery2 = new AtomicInteger(0);
-        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
-        populateTestRealm(realm, 10);
-
-        // 1. Configures Handler interceptor.
-        Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                int intercepts = numberOfIntercept.getAndIncrement();
-                if (what == HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
-                    // 4. The first time the async queries complete we start an update from
-                    // another background thread. This will cause queries to rerun when the
-                    // background thread notifies this thread.
-                    new RealmBackgroundTask(looperThread.realmConfiguration) {
-                        @Override
-                        public void doInBackground(Realm realm) {
-                            realm.beginTransaction();
-                            realm.where(AllTypes.class)
-                                    .equalTo(AllTypes.FIELD_LONG, 4)
-                                    .findFirst()
-                                    .setColumnString("modified");
-                            realm.createObject(AllTypes.class);
-                            realm.createObject(AllTypes.class);
-                            realm.commitTransaction();
-                        }
-                    }.awaitOrFail();
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        // 2. Creates 2 async queries and check they are not loaded.
-        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class).findAllAsync();
-        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class).between("columnLong", 0, 4).findAllAsync();
-
-        assertFalse(realmResults1.isLoaded());
-        assertFalse(realmResults2.isLoaded());
-        assertEquals(0, realmResults1.size());
-        assertEquals(0, realmResults2.size());
-
-        // 3. Change listeners will be called twice. Once when the first query completely and then
-        // when the background thread has completed, notifying this thread to rerun and then receive
-        // the updated results.
-        final Runnable signalCallbackDone = new Runnable() {
-            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
-            @Override
-            public void run() {
-                if (signalCallbackFinished.decrementAndGet() == 0) {
-                    assertEquals(4, numberOfIntercept.get());
-                    assertEquals(2, numberOfNotificationsQuery1.get());
-                    assertEquals(2, numberOfNotificationsQuery2.get());
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        looperThread.keepStrongReference.add(realmResults1);
-        looperThread.keepStrongReference.add(realmResults2);
-
-        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                switch (numberOfNotificationsQuery1.incrementAndGet()) {
-                    case 1: // First callback invocation
-                        assertTrue(realmResults1.isLoaded());
-                        assertEquals(10, realmResults1.size());
-                        assertEquals("test data 4", realmResults1.get(4).getColumnString());
-                        break;
-
-                    case 2: // Second callback
-                        assertTrue(realmResults1.isLoaded());
-                        assertEquals(12, realmResults1.size());
-                        assertEquals("modified", realmResults1.get(4).getColumnString());
-                        signalCallbackDone.run();
-                        break;
-                }
-            }
-        });
-
-
-        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                switch (numberOfNotificationsQuery2.incrementAndGet()) {
-                    case 1: // First callback invocation
-                        assertTrue(realmResults2.isLoaded());
-                        assertEquals(5, realmResults2.size());
-                        assertEquals("test data 4", realmResults2.get(4).getColumnString());
-                        break;
-
-                    case 2: // Second callback
-                        assertTrue(realmResults2.isLoaded());
-                        assertEquals(7, realmResults2.size());
-                        assertEquals("modified", realmResults2.get(4).getColumnString());
-                        signalCallbackDone.run();
-                        break;
-                }
-            }
-        });
-    }
-
-    // Simulates a use case, when the caller thread advance read, while the background thread
-    // is operating on a previous version, this should retry the query on the worker thread
-    // to deliver the results once (using the latest version of the Realm).
-    @Test
-    @RunTestInLooperThread
-    public void findAllAsync_callerIsAdvanced() throws Throwable {
-        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
-        populateTestRealm(realm, 10);
-
-        // Configures handler interceptor.
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                // Intercepts in order [QueryCompleted, RealmChanged, QueryUpdated].
-                int intercepts = numberOfIntercept.incrementAndGet();
-                switch (what) {
-                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
-                        // We advance the Realm so we can simulate a retry.
-                        if (intercepts == 1) {
-                            realm.beginTransaction();
-                            realm.createObject(AllTypes.class).setColumnLong(0);
-                            realm.commitTransaction();
-                        }
-                    }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        // Creates async query and verify it has not been loaded.
-        final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
-                .between("columnLong", 0, 4)
-                .findAllAsync();
-
-        assertFalse(realmResults.isLoaded());
-        assertEquals(0, realmResults.size());
-
-        looperThread.keepStrongReference.add(realmResults);
-
-        // Adds change listener that should only be called once.
-        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                assertEquals(3, numberOfIntercept.get());
-                assertTrue(realmResults.isLoaded());
-                assertEquals(6, realmResults.size());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    // UC:
-    //   1- Inserts 10 objects.
-    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
-    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
-    //   4- Starts a third thread to insert 2 more elements.
-    //   5- The third thread signal a REALM_CHANGE that should update all async queries.
-    //   6- When the results from step [2] completes they should be ignored, since a pending
-    //      update (using the latest realm) for all async queries is in progress.
-    //   7- onChange notification will be triggered once.
-    @Test
-    @RunTestInLooperThread
-    public void findAllAsync_callerThreadBehind() throws Throwable {
-        final AtomicInteger numberOfCompletedAsyncQuery = new AtomicInteger(0);
-        final AtomicInteger numberOfInterceptedChangeMessage = new AtomicInteger(0);
-        final AtomicInteger maxNumberOfNotificationsQuery1 = new AtomicInteger(1);
-        final AtomicInteger maxNumberOfNotificationsQuery2 = new AtomicInteger(1);
-        final Realm realm = looperThread.realm;
-        populateTestRealm(realm, 10);
-
-        // Configures Handler Interceptor.
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                switch (what) {
-                    case HandlerControllerConstants.REALM_CHANGED: {
-                        // Should only intercept the first REALM_CHANGED coming from the
-                        // background update thread.
-
-                        // Swallows this message, so the caller thread
-                        // remains behind the worker thread. This has as
-                        // a consequence to ignore the delivered result & waits for the
-                        // upcoming REALM_CHANGED to batch update all async queries.
-                        return numberOfInterceptedChangeMessage.getAndIncrement() == 0;
-                    }
-                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
-                        if (numberOfCompletedAsyncQuery.incrementAndGet() == 2) {
-                            // Both queries have completed now (& their results should be ignored)
-                            // now sends the REALM_CHANGED event that should batch update all queries.
-                            sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
-                        }
-                    }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-        Realm.asyncTaskExecutor.pause();
-
-        // Creates async queries and checks they haven't completed.
-        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
-                .findAllAsync();
-        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
-                .between("columnLong", 0, 4).findAllAsync();
-
-        assertFalse(realmResults1.isLoaded());
-        assertFalse(realmResults2.isLoaded());
-        assertEquals(0, realmResults1.size());
-        assertEquals(0, realmResults2.size());
-
-        // Advances the Realm from a background thread.
-        new RealmBackgroundTask(looperThread.realmConfiguration) {
-            @Override
-            public void doInBackground(Realm realm) {
-                realm.beginTransaction();
-                realm.where(AllTypes.class).equalTo("columnLong", 4).findFirst().setColumnString("modified");
-                realm.createObject(AllTypes.class);
-                realm.createObject(AllTypes.class);
-                realm.commitTransaction();
-            }
-        }.awaitOrFail();
-        Realm.asyncTaskExecutor.resume();
-
-        // Setups change listeners.
-        final Runnable signalCallbackDone = new Runnable() {
-            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
-            @Override
-            public void run() {
-                if (signalCallbackFinished.decrementAndGet() == 0) {
-                    assertEquals(0, maxNumberOfNotificationsQuery1.get());
-                    assertEquals(0, maxNumberOfNotificationsQuery2.get());
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        looperThread.keepStrongReference.add(realmResults1);
-        looperThread.keepStrongReference.add(realmResults2);
-
-        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                assertTrue(maxNumberOfNotificationsQuery1.getAndDecrement() > 0);
-                assertTrue(realmResults1.isLoaded());
-                assertEquals(12, realmResults1.size());
-                assertEquals("modified", realmResults1.get(4).getColumnString());
-                signalCallbackDone.run();
-            }
-        });
-
-        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                assertTrue(maxNumberOfNotificationsQuery2.getAndDecrement() > 0);
-                assertTrue(realmResults2.isLoaded());
-                assertEquals(7, realmResults2.size());// the 2 add rows has columnLong == 0
-                assertEquals("modified", realmResults2.get(4).getColumnString());
-                signalCallbackDone.run();
-            }
-        });
-    }
-
     // **********************************
     // *** 'findFirst' async queries  ***
     // **********************************
@@ -850,13 +567,13 @@ public void onChange(AllTypes object) {
                 looperThread.testComplete();
             }
         });
-        assertTrue(firstAsync.load());
-        assertTrue(firstAsync.isLoaded());
-        assertFalse(firstAsync.isValid());
 
         realm.beginTransaction();
         realm.createObject(AllTypes.class).setColumnLong(0);
         realm.commitTransaction();
+
+        assertTrue(firstAsync.load());
+        assertTrue(firstAsync.isLoaded());
     }
 
     @Test
@@ -938,551 +655,59 @@ public void findFirstAsync_forceLoad() throws Throwable {
         looperThread.testComplete();
     }
 
-    // Similar UC as #testFindAllAsyncRetry using 'findFirst'.
-    // UC:
-    //   1- Inserts 10 objects.
-    //   2- Starts an async query to find object [0-4].
-    //   3- Asserts current RealmResults is empty (Worker Thread didn't complete).
-    //   4- When the worker thread completes, advances the Realm.
-    //   5- The caller thread is ahead of the result provided by the worker thread.
-    //   6- Retries automatically the async query.
-    //   7- The returned RealmResults is now in the same version as the caller thread.
-    //   8- The notification should be called once (when we retry automatically we shouldn't
-    //      notify the user).
+    // **************************************
+    // *** 'findAllSorted' async queries  ***
+    // **************************************
+
+    // similar UC as #testFindAllAsync using 'findAllSorted'
     @Test
     @RunTestInLooperThread
-    public void findFirstAsync_retry() throws Throwable {
-        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
+    public void findAllSortedAsync() throws Throwable {
         final Realm realm = looperThread.realm;
         populateTestRealm(realm, 10);
 
-        // Configures interceptor handler.
-        final Handler handler = new HandlerProxy(realm.handlerController) {
+        final RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .between("columnLong", 0, 4)
+                .findAllSortedAsync("columnString", Sort.DESCENDING);
+
+        assertFalse(results.isLoaded());
+        assertEquals(0, results.size());
+
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
-            public boolean onInterceptInMessage(int what) {
-                int intercepts = numberOfIntercept.incrementAndGet();
-                switch (what) {
-                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT: {
-                        if (intercepts == 1) {
-                            // We advance the Realm so we can simulate a retry.
-                            realm.beginTransaction();
-                            realm.delete(AllTypes.class);
-                            AllTypes object = realm.createObject(AllTypes.class);
-                            object.setColumnString("The Endless River");
-                            object.setColumnLong(5);
-                            realm.commitTransaction();
-                        }
-                    }
+            public void onChange(RealmResults<AllTypes> object) {
+                assertTrue(results.isLoaded());
+                assertEquals(5, results.size());
+                for (int i = 0; i < 5; i++) {
+                    int iteration = (4 - i);
+                    assertEquals("test data " + iteration, results.get(4 - iteration).getColumnString());
                 }
-                return false;
+                looperThread.testComplete();
             }
-        };
-        realm.setHandler(handler);
-
-        // Creates a async query and verifies it is not still loaded.
-        final AllTypes realmResults = realm.where(AllTypes.class)
-                .between("columnLong", 4, 6)
-                .findFirstAsync();
-
-        assertFalse(realmResults.isLoaded());
-
-        try {
-            realmResults.getColumnString();
-            fail("Accessing property on an empty row");
-        } catch (IllegalStateException ignored) {
-        }
-
-        // Adds change listener that should only be called once after the retry completed.
-        looperThread.keepStrongReference.add(realmResults);
-        realmResults.addChangeListener(new RealmChangeListener<AllTypes>() {
-            @Override
-            public void onChange(AllTypes object) {
-                assertEquals(3, numberOfIntercept.get());
-                assertTrue(realmResults.isLoaded());
-                assertEquals(5, realmResults.getColumnLong());
-                assertEquals("The Endless River", realmResults.getColumnString());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    // **************************************
-    // *** 'findAllSorted' async queries  ***
-    // **************************************
-
-    // Similar UC as #testFindAllAsync using 'findAllSorted'.
-    @Test
-    @RunTestInLooperThread
-    public void findAllSortedAsync() throws Throwable {
-        final Realm realm = looperThread.realm;
-        populateTestRealm(realm, 10);
-
-        final RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .between("columnLong", 0, 4)
-                .findAllSortedAsync("columnString", Sort.DESCENDING);
-
-        assertFalse(results.isLoaded());
-        assertEquals(0, results.size());
-
-        looperThread.keepStrongReference.add(results);
-        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                assertTrue(results.isLoaded());
-                assertEquals(5, results.size());
-                for (int i = 0; i < 5; i++) {
-                    int iteration = (4 - i);
-                    assertEquals("test data " + iteration, results.get(4 - iteration).getColumnString());
-                }
-                looperThread.testComplete();
-            }
-        });
-    }
-
-
-    // Finds elements [4-8] asynchronously then waits for the promise to be loaded
-    // using a callback to be notified when the data is loaded.
-    @Test
-    @RunTestInLooperThread
-    public void findAllSortedAsync_retry() throws Throwable {
-        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
-        final Realm realm = looperThread.realm;
-
-        // 1. Populates the Realm without triggering a RealmChangeEvent.
-        realm.setAutoRefresh(false);
-        populateTestRealm(realm, 10);
-        realm.setAutoRefresh(true);
-
-        // 2. Configures proxy handler to intercept messages.
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                // In order [QueryCompleted, RealmChanged, QueryUpdated].
-                int intercepts = numberOfIntercept.incrementAndGet();
-                switch (what) {
-                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
-                        if (intercepts == 1) {
-                            // We advance the Realm so we can simulate a retry before listeners are
-                            // called.
-                            realm.beginTransaction();
-                            realm.where(AllTypes.class).equalTo(AllTypes.FIELD_LONG, 8).findFirst().deleteFromRealm();
-                            realm.commitTransaction();
-                        }
-                        break;
-                    }
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        // 3. This will add a task to the paused asyncTaskExecutor.
-        final RealmResults<AllTypes> realmResults = realm.where(AllTypes.class)
-                .between("columnLong", 4, 8)
-                .findAllSortedAsync("columnString", Sort.ASCENDING);
-
-        assertFalse(realmResults.isLoaded());
-        assertEquals(0, realmResults.size());
-
-        // 4. Intercepting the query completed event the first time will
-        // cause a commit that should cause the findAllSortedAsync to be re-run.
-        // This change listener should only be called with the final result.
-        looperThread.keepStrongReference.add(realmResults);
-        realmResults.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                assertEquals(3, numberOfIntercept.get());
-                looperThread.testComplete();
-            }
-        });
-    }
-
-    // Similar UC as #testFindAllAsyncBatchUpdate using 'findAllSorted'.
-    // UC:
-    //   1- Inserts 10 objects.
-    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
-    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
-    //   4- The queries will complete with the same version as the caller thread.
-    //   5- Using a background thread update the Realm.
-    //   6- Now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries.
-    //   7- Callbacks are notified with the latest results (called twice overall).
-    @Test
-    @RunTestInLooperThread
-    public void findAllSortedAsync_batchUpdate() {
-        final AtomicInteger numberOfNotificationsQuery1 = new AtomicInteger(0);
-        final AtomicInteger numberOfNotificationsQuery2 = new AtomicInteger(0);
-        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
-
-        // 1. Adds initial 10 objects.
-        realm.setAutoRefresh(false);
-        populateTestRealm(realm, 10);
-        realm.setAutoRefresh(true);
-
-        // 2. Configures interceptor.
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                switch (what) {
-                    case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS: {
-                        if (numberOfIntercept.incrementAndGet() == 2 /* 2 queries are both completed */) {
-                            // 6. The first time the async queries complete we start an update from
-                            // another background thread. This will cause queries to rerun when the
-                            // background thread notifies this thread.
-                            final CountDownLatch bgThreadLatch = new CountDownLatch(1);
-                            new Thread() {
-                                @Override
-                                public void run() {
-                                    Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
-                                    bgRealm.beginTransaction();
-                                    bgRealm.where(AllTypes.class).equalTo("columnLong", 4).findFirst().setColumnString("modified");
-                                    bgRealm.createObject(AllTypes.class);
-                                    bgRealm.createObject(AllTypes.class);
-                                    bgRealm.commitTransaction();
-                                    bgRealm.close();
-                                    bgThreadLatch.countDown();
-                                }
-                            }.start();
-                            TestHelper.awaitOrFail(bgThreadLatch);
-                        }
-                    }
-                    break;
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        // 3. Creates 2 async queries.
-        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
-                .findAllSortedAsync("columnString", Sort.ASCENDING);
-        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
-                .between("columnLong", 0, 4)
-                .findAllSortedAsync("columnString", Sort.DESCENDING);
-
-        // 4. Asserts that queries have not finished.
-        assertFalse(realmResults1.isLoaded());
-        assertFalse(realmResults2.isLoaded());
-        assertEquals(0, realmResults1.size());
-        assertEquals(0, realmResults2.size());
-
-        // 5. Change listeners will be called twice. Once when the first query has completed and then
-        // when the background thread has completed, notifies this thread to rerun and then receives
-        // the updated results.
-        final Runnable signalCallbackDone = new Runnable() {
-            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
-            @Override
-            public void run() {
-                if (signalCallbackFinished.decrementAndGet() == 0) {
-                    assertEquals(2, numberOfNotificationsQuery1.get());
-                    assertEquals(2, numberOfNotificationsQuery2.get());
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        looperThread.keepStrongReference.add(realmResults1);
-        looperThread.keepStrongReference.add(realmResults2);
-
-        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                switch (numberOfNotificationsQuery1.incrementAndGet()) {
-                    case 1: { // First callback invocation
-                        assertTrue(realmResults1.isLoaded());
-                        assertEquals(10, realmResults1.size());
-                        assertEquals("test data 4", realmResults1.get(4).getColumnString());
-                        break;
-                    }
-                    case 2: { // Second callback
-                        assertTrue(realmResults1.isLoaded());
-                        assertEquals(12, realmResults1.size());
-                        assertEquals("modified", realmResults1.get(2).getColumnString());
-                        signalCallbackDone.run();
-                        break;
-                    }
-                }
-            }
-        });
-
-        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                switch (numberOfNotificationsQuery2.incrementAndGet()) {
-                    case 1: { // First callback invocation
-                        assertTrue(realmResults2.isLoaded());
-                        assertEquals(5, realmResults2.size());
-                        assertEquals("test data 4", realmResults2.get(0).getColumnString());
-                        break;
-                    }
-                    case 2: { // Second callback
-                        assertTrue(realmResults2.isLoaded());
-                        assertEquals(7, realmResults2.size());
-                        assertEquals("modified", realmResults2.get(4).getColumnString());
-                        signalCallbackDone.run();
-                        break;
-                    }
-                }
-            }
-        });
-    }
-
-    // Similar UC as #testFindAllAsyncBatchUpdate using 'findAllSortedMulti'.
-    // UC:
-    //   1- Inserts 10 objects.
-    //   2- Starts 2 async queries to find all objects [0-9] & objects[0-4].
-    //   3- Asserts both RealmResults are empty (Worker Thread didn't complete).
-    //   4- The queries will complete with the same version as the caller thread.
-    //   5- Using a background thread updates the Realm.
-    //   6- Now REALM_CHANGED will trigger a COMPLETED_UPDATE_ASYNC_QUERIES that should update all queries.
-    //   7- Callbacks are notified with the latest results (called twice overall).
-    @Test
-    @RunTestInLooperThread
-    public void findAllSortedAsync_multipleFields_batchUpdate() throws Throwable {
-        final AtomicInteger numberOfNotificationsQuery1 = new AtomicInteger(0);
-        final AtomicInteger numberOfNotificationsQuery2 = new AtomicInteger(0);
-        final AtomicInteger numberOfIntercept = new AtomicInteger(0);
-        Realm realm = looperThread.realm;
-
-        // 1. Adds initial objects.
-        realm.setAutoRefresh(false);
-        realm.beginTransaction();
-        for (int i = 0; i < 5; ) {
-            AllTypes allTypes = realm.createObject(AllTypes.class);
-            allTypes.setColumnLong(i);
-            allTypes.setColumnString("data " + i % 3);
-
-            allTypes = realm.createObject(AllTypes.class);
-            allTypes.setColumnLong(i);
-            allTypes.setColumnString("data " + (++i % 3));
-        }
-        realm.commitTransaction();
-        realm.setAutoRefresh(true);
-
-        // 2. Configures interceptor.
-        final Handler handler = new HandlerProxy(realm.handlerController) {
-            @Override
-            public boolean onInterceptInMessage(int what) {
-                int intercepts = numberOfIntercept.incrementAndGet();
-                if (what == HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS && intercepts == 1) {
-                    // 6. The first time the async queries complete we start an update from
-                    // another background thread. This will cause queries to rerun when the
-                    // background thread notifies this thread.
-                    new RealmBackgroundTask(looperThread.realmConfiguration) {
-                        @Override
-                        public void doInBackground(Realm realm) {
-                            realm.beginTransaction();
-                            realm.where(AllTypes.class)
-                                    .equalTo("columnString", "data 1")
-                                    .equalTo("columnLong", 0)
-                                    .findFirst().setColumnDouble(Math.PI);
-                            AllTypes allTypes = realm.createObject(AllTypes.class);
-                            allTypes.setColumnLong(2);
-                            allTypes.setColumnString("data " + 5);
-
-                            allTypes = realm.createObject(AllTypes.class);
-                            allTypes.setColumnLong(0);
-                            allTypes.setColumnString("data " + 5);
-                            realm.commitTransaction();
-                        }
-                    }.awaitOrFail();
-                }
-                return false;
-            }
-        };
-        realm.setHandler(handler);
-
-        // 3. Creates 2 async queries.
-        final RealmResults<AllTypes> realmResults1 = realm.where(AllTypes.class)
-                .findAllSortedAsync("columnString", Sort.ASCENDING, "columnLong", Sort.DESCENDING);
-        final RealmResults<AllTypes> realmResults2 = realm.where(AllTypes.class)
-                .between("columnLong", 0, 5)
-                .findAllSortedAsync("columnString", Sort.DESCENDING, "columnLong", Sort.ASCENDING);
-
-        // 4. Asserts that queries have not finished.
-        assertFalse(realmResults1.isLoaded());
-        assertFalse(realmResults2.isLoaded());
-        assertEquals(0, realmResults1.size());
-        assertEquals(0, realmResults2.size());
-        assertFalse(realmResults1.isLoaded());
-        assertFalse(realmResults2.isLoaded());
-        assertEquals(0, realmResults1.size());
-        assertEquals(0, realmResults2.size());
-
-        // 5. Changes listeners will be called twice. Once when the first query has completed and then
-        // when the background thread has completed, notifies this thread to rerun and then receives
-        // the updated results.
-        final Runnable signalCallbackDone = new Runnable() {
-            private AtomicInteger signalCallbackFinished = new AtomicInteger(2);
-            @Override
-            public void run() {
-                if (signalCallbackFinished.decrementAndGet() == 0) {
-                    assertEquals(4, numberOfIntercept.get());
-                    assertEquals(2, numberOfNotificationsQuery1.get());
-                    assertEquals(2, numberOfNotificationsQuery2.get());
-                    looperThread.testComplete();
-                }
-            }
-        };
-
-        looperThread.keepStrongReference.add(realmResults1);
-        looperThread.keepStrongReference.add(realmResults2);
-
-        realmResults1.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                switch (numberOfNotificationsQuery1.incrementAndGet()) {
-                    case 1: // First callback invocation
-                        assertTrue(realmResults1.isLoaded());
-                        assertEquals(10, realmResults1.size());
-
-                        assertEquals("data 0", realmResults1.get(0).getColumnString());
-                        assertEquals(3, realmResults1.get(0).getColumnLong());
-                        assertEquals("data 0", realmResults1.get(1).getColumnString());
-                        assertEquals(2, realmResults1.get(1).getColumnLong());
-                        assertEquals("data 0", realmResults1.get(2).getColumnString());
-                        assertEquals(0, realmResults1.get(2).getColumnLong());
-
-                        assertEquals("data 1", realmResults1.get(3).getColumnString());
-                        assertEquals(4, realmResults1.get(3).getColumnLong());
-                        assertEquals("data 1", realmResults1.get(4).getColumnString());
-                        assertEquals(3, realmResults1.get(4).getColumnLong());
-                        assertEquals("data 1", realmResults1.get(5).getColumnString());
-                        assertEquals(1, realmResults1.get(5).getColumnLong());
-                        assertEquals("data 1", realmResults1.get(6).getColumnString());
-                        assertEquals(0, realmResults1.get(6).getColumnLong());
-
-                        assertEquals("data 2", realmResults1.get(7).getColumnString());
-                        assertEquals(4, realmResults1.get(7).getColumnLong());
-                        assertEquals("data 2", realmResults1.get(8).getColumnString());
-                        assertEquals(2, realmResults1.get(8).getColumnLong());
-                        assertEquals("data 2", realmResults1.get(9).getColumnString());
-                        assertEquals(1, realmResults1.get(9).getColumnLong());
-                        break;
-
-                    case 2: // Second callback
-                        assertTrue(realmResults1.isLoaded());
-                        assertEquals(12, realmResults1.size());
-                        // First
-                        assertEquals("data 0", realmResults1.get(0).getColumnString());
-                        assertEquals(3, realmResults1.get(0).getColumnLong());
-
-                        // Last
-                        assertEquals("data 5", realmResults1.get(11).getColumnString());
-                        assertEquals(0, realmResults1.get(11).getColumnLong());
-
-                        signalCallbackDone.run();
-                        break;
-                }
-            }
-        });
-
-        realmResults2.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> object) {
-                switch (numberOfNotificationsQuery2.incrementAndGet()) {
-                    case 1: // First callback invocation
-                        assertTrue(realmResults2.isLoaded());
-                        assertEquals(10, realmResults2.size());
-
-                        assertEquals("data 2", realmResults2.get(0).getColumnString());
-                        assertEquals(1, realmResults2.get(0).getColumnLong());
-                        assertEquals("data 2", realmResults2.get(1).getColumnString());
-                        assertEquals(2, realmResults2.get(1).getColumnLong());
-                        assertEquals("data 2", realmResults2.get(2).getColumnString());
-                        assertEquals(4, realmResults2.get(2).getColumnLong());
-
-                        assertEquals("data 1", realmResults2.get(3).getColumnString());
-                        assertEquals(0, realmResults2.get(3).getColumnLong());
-                        assertEquals("data 1", realmResults2.get(4).getColumnString());
-                        assertEquals(1, realmResults2.get(4).getColumnLong());
-                        assertEquals("data 1", realmResults2.get(5).getColumnString());
-                        assertEquals(3, realmResults2.get(5).getColumnLong());
-                        assertEquals("data 1", realmResults2.get(6).getColumnString());
-                        assertEquals(4, realmResults2.get(6).getColumnLong());
-
-                        assertEquals("data 0", realmResults2.get(7).getColumnString());
-                        assertEquals(0, realmResults2.get(7).getColumnLong());
-                        assertEquals("data 0", realmResults2.get(8).getColumnString());
-                        assertEquals(2, realmResults2.get(8).getColumnLong());
-                        assertEquals("data 0", realmResults2.get(9).getColumnString());
-                        assertEquals(3, realmResults2.get(9).getColumnLong());
-                        break;
-
-                    case 2: // Second callback
-                        assertTrue(realmResults2.isLoaded());
-                        assertEquals(12, realmResults2.size());
-
-                        assertEquals("data 5", realmResults2.get(0).getColumnString());
-                        assertEquals(0, realmResults2.get(0).getColumnLong());
-
-                        assertEquals("data 0", realmResults2.get(11).getColumnString());
-                        assertEquals(3, realmResults2.get(11).getColumnLong());
-
-                        assertEquals("data 1", realmResults2.get(5).getColumnString());
-                        assertEquals(Math.PI, realmResults2.get(5).getColumnDouble(), 0.000000000001D);
-
-                        signalCallbackDone.run();
-                        break;
-                }
-            }
-        });
-    }
-
-    // Makes sure the notification listener does not leak the enclosing class
-    // if unregistered properly.
-    @Test
-    @RunTestInLooperThread
-    public void listenerShouldNotLeak() {
-        populateTestRealm(looperThread.realm, 10);
-
-        // Simulates the ActivityManager by creating 1 instance responsible
-        // of attaching an onChange listener, then simulates a configuration
-        // change (ex: screen rotation), this change will create a new instance.
-        // We make sure that the GC enqueues the reference of the destroyed instance
-        // which indicate no memory leak.
-        MockActivityManager mockActivityManager =
-                MockActivityManager.newInstance(looperThread.realm.getConfiguration());
-
-        mockActivityManager.sendConfigurationChange();
-
-        assertEquals(1, mockActivityManager.numberOfInstances());
-        // Removes GC'd reference & asserts that one instance should remain.
-        Iterator<Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>>> iterator =
-                looperThread.realm.handlerController.asyncRealmResults.entrySet().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmResults<?>>, RealmQuery<?>> entry = iterator.next();
-            RealmResults<?> weakReference = entry.getKey().get();
-            if (weakReference == null) {
-                iterator.remove();
-            }
-        }
-
-        assertEquals(1, looperThread.realm.handlerController.asyncRealmResults.size());
-        mockActivityManager.onStop();// To close the Realm.
-        looperThread.testComplete();
-    }
+        });
+    }
 
     @Test
     @RunTestInLooperThread
     public void combiningAsyncAndSync() {
         populateTestRealm(looperThread.realm, 10);
 
-        Realm.asyncTaskExecutor.pause();
         final RealmResults<AllTypes> allTypesAsync = looperThread.realm.where(AllTypes.class).greaterThan("columnLong", 5).findAllAsync();
         final RealmResults<AllTypes> allTypesSync = allTypesAsync.where().greaterThan("columnLong", 3).findAll();
 
+        // Call where() on an async results will load query. But to maintain the pre version 2.4.0 behaviour of
+        // RealmResults.load(), we still treat it as a not loaded results.
         assertEquals(0, allTypesAsync.size());
-        assertEquals(6, allTypesSync.size());
+        assertEquals(4, allTypesSync.size()); // columnLong > 5 && columnLong > 3
         allTypesAsync.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
                 assertEquals(4, allTypesAsync.size());
-                assertEquals(6, allTypesSync.size());
+                assertEquals(4, allTypesSync.size());
                 looperThread.testComplete();
             }
         });
-        Realm.asyncTaskExecutor.resume();
         looperThread.keepStrongReference.add(allTypesAsync);
     }
 
@@ -1864,157 +1089,14 @@ public void doInBackground(Realm realm) {
         });
     }
 
-    // Makes sure we don't get the run into the IllegalStateException.
-    // (Caller thread behind the worker thread)
-    // Scenario:
-    // - Caller thread is in version 1, starts an asyncFindFirst.
-    // - Another thread advances the Realm, now the latest version = 2.
-    // - The worker thread should query against version 1 not version 2.
-    // Otherwise the caller thread wouldn't be able to import the result.
-    // - The notification mechanism will guarantee that the REALM_CHANGE triggered by
-    // the background thread, will update the caller thread (advancing it to version 2).
-    @Test
-    @RunTestInLooperThread
-    public void testFindFirstUsesCallerThreadVersion() throws Throwable {
-        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-
-        populateTestRealm(looperThread.realm, 10);
-        Realm.asyncTaskExecutor.pause();
-
-        final AllTypes firstAsync = looperThread.realm.where(AllTypes.class).findFirstAsync();
-        looperThread.keepStrongReference.add(firstAsync);
-        firstAsync.addChangeListener(new RealmChangeListener<AllTypes>() {
-            @Override
-            public void onChange(AllTypes object) {
-                assertNotNull(firstAsync);
-                assertEquals("test data 0", firstAsync.getColumnString());
-                looperThread.testComplete(signalClosedRealm);
-            }
-        });
-
-        // Advances the background Realm.
-        new Thread() {
-            @Override
-            public void run() {
-                Realm bgRealm = Realm.getInstance(looperThread.realmConfiguration);
-                // Advances the Realm without generating notifications.
-                bgRealm.sharedRealm.beginTransaction();
-                bgRealm.sharedRealm.commitTransaction();
-                Realm.asyncTaskExecutor.resume();
-                bgRealm.close();
-                signalClosedRealm.countDown();
-            }
-        }.start();
-    }
-
-    // Test case for https://github.com/realm/realm-java/issues/2417
-    // Ensures that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
-    @Test
-    @UiThreadTest
-    public void badVersion_findAll() throws NoSuchFieldException, IllegalAccessException {
-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
-        RealmConfiguration config = configFactory.createConfiguration();
-        Realm realm = Realm.getInstance(config);
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        boolean result = realm.where(AllTypes.class).findAllAsync().load();
-        try {
-            assertFalse(result);
-        } finally {
-            realm.close();
-        }
-        TestHelper.resetRealmThreadExecutor();
-    }
-
-    // Test case for https://github.com/realm/realm-java/issues/2417
-    // Ensures that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
-    @Test
-    @UiThreadTest
-    public void badVersion_findAllSortedAsync() throws NoSuchFieldException, IllegalAccessException {
-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
-        RealmConfiguration config = configFactory.createConfiguration();
-        Realm realm = Realm.getInstance(config);
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        realm.where(AllTypes.class)
-                .findAllSortedAsync(AllTypes.FIELD_STRING, Sort.ASCENDING, AllTypes.FIELD_LONG, Sort.DESCENDING)
-                .load();
-        realm.close();
-        TestHelper.resetRealmThreadExecutor();
-    }
-
-    // Test case for https://github.com/realm/realm-java/issues/2417
-    // Ensures that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
-    @Test
-    @UiThreadTest
-    public void badVersion_distinct() throws NoSuchFieldException, IllegalAccessException {
-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
-        RealmConfiguration config = configFactory.createConfiguration();
-        Realm realm = Realm.getInstance(config);
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        realm.executeTransactionAsync(new Realm.Transaction() {
-            @Override
-            public void execute(Realm realm) {
-                realm.deleteAll();
-            }
-        });
-        realm.where(AllJavaTypes.class)
-                .distinctAsync(AllJavaTypes.FIELD_STRING)
-                .load();
-
-        realm.close();
-        TestHelper.resetRealmThreadExecutor();
-    }
-
     // Test case for https://github.com/realm/realm-java/issues/2417
     // Ensures that a UnreachableVersion exception during handover doesn't crash the app or cause a segfault.
+    // NOTE: This test is not checking the same thing after the OS results integration. Just keep it for an additional
+    // test for async.
     @Test
     @RunTestInLooperThread
     public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAccessException {
-        TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor());
+        final AtomicInteger listenerCount = new AtomicInteger(0);
         Realm realm = looperThread.realm;
 
         // 1. Makes sure that async query is not started.
@@ -2023,124 +1105,43 @@ public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAcc
         result.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
             public void onChange(RealmResults<AllTypes> object) {
-                // 4. The commit in #2, should result in a refresh being triggered, which means this callback will
-                // be notified once the updated async queries has run.
                 assertTrue(result.isValid());
                 assertTrue(result.isLoaded());
-                assertEquals(1, result.size());
-                looperThread.testComplete();
+                switch (listenerCount.getAndIncrement()) {
+                    case 0:
+                        // Triggered by beginTransaction
+                        assertEquals(0, result.size());
+                        break;
+                    case 1:
+                        // 4. The commit in #2, should result in a refresh being triggered, which means this callback will
+                        // be notified once the updated async queries has run.
+                        assertEquals(1, result.size());
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail();
+                        break;
+                }
             }
         });
 
-        // 2. Advances the callee Realm, invalidating the version in the handover object.
+        // 2. Advances the caller Realm, invalidating the version in the handover object.
         realm.beginTransaction();
+        assertTrue(result.isLoaded());
         realm.createObject(AllTypes.class);
         realm.commitTransaction();
 
         // 3. The async query should now (hopefully) fail with a BadVersion.
+        // NOTE: Step 3 is from the original test. After integration of Object Store Results, it has been loaded already
+        //       when beginTransaction.
         result.load();
-        TestHelper.resetRealmThreadExecutor();
-    }
-
-    // handlerController#emptyAsyncRealmObject is accessed from different threads.
-    // Makes sure that we iterate over it safely without any race condition (ConcurrentModification).
-    @Test
-    @UiThreadTest
-    public void concurrentModificationEmptyAsyncRealmObject() {
-        RealmConfiguration config  = configFactory.createConfiguration();
-        final Realm realm = Realm.getInstance(config);
-        Dog dog1 = new Dog();
-        dog1.setName("Dog 1");
-
-        Dog dog2 = new Dog();
-        dog2.setName("Dog 2");
-
-        realm.beginTransaction();
-        dog1 = realm.copyToRealm(dog1);
-        dog2 = realm.copyToRealm(dog2);
-        realm.commitTransaction();
-
-        final WeakReference<RealmObjectProxy> weakReference1 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog1);
-        final WeakReference<RealmObjectProxy> weakReference2 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog2);
-
-        final RealmQuery<Dog> dummyQuery = RealmQuery.createQuery(realm, Dog.class);
-        // Initializes the emptyAsyncRealmObject map, to make sure that iterating is safe
-        // even if we modify the map from a background thread (in case of an empty findFirstAsync).
-        realm.handlerController.emptyAsyncRealmObject.put(weakReference1, dummyQuery);
-
-        final CountDownLatch dogAddFromBg = new CountDownLatch(1);
-        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>> iterator = realm.handlerController.emptyAsyncRealmObject.entrySet().iterator();
-        AtomicBoolean fireOnce = new AtomicBoolean(true);
-        while (iterator.hasNext()) {
-            Dog next = (Dog) iterator.next().getKey().get();
-            // Adds a new Dog from a background thread.
-            if (fireOnce.compareAndSet(true, false)) {
-                new Thread() {
-                    @Override
-                    public void run() {
-                        // Adds a WeakReference to simulate an empty row using a findFirstAsync.
-                        // This is added on an Executor thread, hence the dedicated thread.
-                        realm.handlerController.emptyAsyncRealmObject.put(weakReference2, dummyQuery);
-                        dogAddFromBg.countDown();
-                    }
-                }.start();
-                TestHelper.awaitOrFail(dogAddFromBg);
-            }
-            assertEquals("Dog 1", next.getName());
-            assertFalse(iterator.hasNext());
-        }
-        realm.close();
-    }
-
-    // handlerController#realmObjects is accessed from different threads.
-    // Makes sure that we iterate over it safely without any race condition (ConcurrentModification).
-    @Test
-    @UiThreadTest
-    public void concurrentModificationRealmObjects() {
-        RealmConfiguration config  = configFactory.createConfiguration();
-        final Realm realm = Realm.getInstance(config);
-        Dog dog1 = new Dog();
-        dog1.setName("Dog 1");
-
-        Dog dog2 = new Dog();
-        dog2.setName("Dog 2");
-
-        realm.beginTransaction();
-        dog1 = realm.copyToRealm(dog1);
-        dog2 = realm.copyToRealm(dog2);
-        realm.commitTransaction();
-
-        final WeakReference<RealmObjectProxy> weakReference1 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog1);
-        final WeakReference<RealmObjectProxy> weakReference2 = new WeakReference<RealmObjectProxy>((RealmObjectProxy)dog2);
-
-        realm.handlerController.realmObjects.put(weakReference1, Boolean.TRUE);
-
-        final CountDownLatch dogAddFromBg = new CountDownLatch(1);
-        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, Object>> iterator = realm.handlerController.realmObjects.entrySet().iterator();
-        AtomicBoolean fireOnce = new AtomicBoolean(true);
-        while (iterator.hasNext()) {
-            Dog next = (Dog) iterator.next().getKey().get();
-            // Adds a new Dog from a background thread.
-            if (fireOnce.compareAndSet(true, false)) {
-                new Thread() {
-                    @Override
-                    public void run() {
-                        realm.handlerController.realmObjects.put(weakReference2, Boolean.TRUE);
-                        dogAddFromBg.countDown();
-                    }
-                }.start();
-                TestHelper.awaitOrFail(dogAddFromBg);
-            }
-            assertEquals("Dog 1", next.getName());
-            assertFalse(iterator.hasNext());
-        }
-
-        realm.close();
     }
 
     // This test reproduces the issue in https://secure.helpscout.net/conversation/244053233/6163/?folderId=366141
-    // First it creates 512 async queries, then triggers a transaction to make the queries gets update with
+    // First it creates 512 async queries, then trigger a transaction to make the queries gets update with
     // nativeBatchUpdateQueries. It should not exceed the limits of local ref map size in JNI.
+    // NOTE: This test is not checking the same thing after the OS results integration. Just keep it for an additional
+    // test for async.
     @Test
     @RunTestInLooperThread
     public void batchUpdate_localRefIsDeletedInLoopOfNativeBatchUpdateQueries() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
index e3c1e2f2b6..f72137c2c2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmCollectionTests.java
@@ -114,28 +114,40 @@ public void tearDown() {
     }
     
     private RealmCollection<AllJavaTypes> createCollection(CollectionClass collectionClass) {
+        OrderedRealmCollection<AllJavaTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 populateRealm(realm, TEST_SIZE);
-                return realm.where(AllJavaTypes.class)
+                orderedCollection = realm.where(AllJavaTypes.class)
                         .equalTo(AllJavaTypes.FIELD_LONG, 0)
                         .findFirst()
                         .getFieldList();
+                break;
 
             case UNMANAGED_REALMLIST:
                 return populateInMemoryList(TEST_SIZE);
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 populateRealm(realm, TEST_SIZE);
-                return realm.where(AllJavaTypes.class).findAll();
+                orderedCollection = realm.where(AllJavaTypes.class).findAll();
+                break;
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
         }
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     private RealmCollection<CustomMethods> createCustomMethodsCollection(Realm realm, CollectionClass collectionClass) {
+        OrderedRealmCollection<CustomMethods> orderedCollection;
+
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
                 CustomMethods top = realm.createObject(CustomMethods.class);
@@ -144,7 +156,8 @@ public void tearDown() {
                     top.getMethods().add(new CustomMethods("Child" + i));
                 }
                 realm.commitTransaction();
-                return top.getMethods();
+                orderedCollection = top.getMethods();
+                break;
 
             case UNMANAGED_REALMLIST:
                 RealmList<CustomMethods> list = new RealmList<CustomMethods>();
@@ -153,35 +166,53 @@ public void tearDown() {
                 }
                 return list;
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 realm.beginTransaction();
                 for (int i = 0; i < TEST_SIZE; i++) {
                     realm.copyToRealm(new CustomMethods("Child" + i));
                 }
                 realm.commitTransaction();
-                return realm.where(CustomMethods.class).findAll();
+                orderedCollection = realm.where(CustomMethods.class).findAll();
+                break;
 
             default:
                 throw new AssertionError("Unsupported class: " + collectionClass);
         }
+
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     private OrderedRealmCollection<NullTypes> createEmptyCollection(Realm realm, CollectionClass collectionClass) {
+        OrderedRealmCollection<NullTypes> orderedCollection;
         switch (collectionClass) {
+            case REALMRESULTS_SNAPSHOT_LIST_BASE:
             case MANAGED_REALMLIST:
                 realm.beginTransaction();
                 NullTypes obj = realm.createObject(NullTypes.class, 0);
                 realm.commitTransaction();
-                return obj.getFieldListNull();
+                orderedCollection = obj.getFieldListNull();
+                break;
 
             case UNMANAGED_REALMLIST:
                 return new RealmList<NullTypes>();
 
+            case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
-                return realm.where(NullTypes.class).findAll();
+                orderedCollection = realm.where(NullTypes.class).findAll();
+                break;
+
+            default:
+                throw new AssertionError("Unknown collection: " + collectionClass);
         }
 
-        throw new AssertionError("Unknown collection: " + collectionClass);
+        if (isSnapshot(collectionClass)) {
+            orderedCollection = orderedCollection.createSnapshot();
+        }
+        return orderedCollection;
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
index 5106b86cb8..cd9d35516a 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmListTests.java
@@ -25,10 +25,11 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.Cat;
@@ -37,6 +38,8 @@
 import io.realm.entities.Dog;
 import io.realm.entities.Owner;
 import io.realm.internal.RealmObjectProxy;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static org.junit.Assert.assertEquals;
@@ -58,6 +61,8 @@
     public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
     @Rule
     public ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
 
     private Realm realm;
     private RealmList<Dog> collection;
@@ -580,7 +585,7 @@ public void remove_objectAfterContainerObjectRemoved() {
     @Test
     public void removeAll_managedMode() {
         realm.beginTransaction();
-        List<Dog> objectsToRemove = Arrays.asList(collection.get(0));
+        List<Dog> objectsToRemove = Collections.singletonList(collection.get(0));
         assertTrue(collection.removeAll(objectsToRemove));
         assertFalse(collection.contains(objectsToRemove.get(0)));
     }
@@ -742,6 +747,7 @@ public void realmMethods_onDeletedLinkView() {
                     case SORT_FIELD: results.sort(CyclicType.FIELD_NAME, Sort.ASCENDING); break;
                     case SORT_2FIELDS: results.sort(CyclicType.FIELD_NAME, Sort.ASCENDING, CyclicType.FIELD_DATE, Sort.DESCENDING); break;
                     case SORT_MULTI: results.sort(new String[] { CyclicType.FIELD_NAME, CyclicType.FIELD_DATE }, new Sort[] { Sort.ASCENDING, Sort.DESCENDING});
+                    case CREATE_SNAPSHOT: results.createSnapshot();
                 }
                 fail(method + " should have thrown an Exception");
             } catch (IllegalStateException ignored) {
@@ -854,49 +860,60 @@ public void run() {
     }
 
     @Test
-    public void add_set_dynamicObjectFromOtherThread() {
+    public void add_set_dynamicObjectFromOtherThread() throws Throwable {
         final CountDownLatch finishedLatch = new CountDownLatch(1);
         DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
         final DynamicRealmObject dynDog = dynamicRealm.where(Dog.CLASS_NAME).findFirst();
         final String expectedMsg = "Cannot copy an object to a Realm instance created in another thread.";
 
+        final AtomicReference<Throwable> thrownErrorRef = new AtomicReference<Throwable>();
+
         new Thread(new Runnable() {
             @Override
             public void run() {
                 DynamicRealm dynamicRealm = DynamicRealm.getInstance(realm.getConfiguration());
                 dynamicRealm.beginTransaction();
-                RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
-                        .getList(Owner.FIELD_DOGS);
-                list.add(dynamicRealm.createObject(Dog.CLASS_NAME));
-
-                try {
-                    list.add(dynDog);
-                    fail();
-                } catch (IllegalStateException expected) {
-                    assertEquals(expectedMsg, expected.getMessage());
-                }
-
                 try {
-                    list.add(0, dynDog);
-                    fail();
-                } catch (IllegalStateException expected) {
-                    assertEquals(expectedMsg, expected.getMessage());
-                }
-
-                try {
-                    list.set(0, dynDog);
-                    fail();
-                } catch (IllegalStateException expected) {
-                    assertEquals(expectedMsg, expected.getMessage());
+                    RealmList<DynamicRealmObject> list = dynamicRealm.createObject(Owner.CLASS_NAME)
+                            .getList(Owner.FIELD_DOGS);
+                    list.add(dynamicRealm.createObject(Dog.CLASS_NAME));
+
+                    try {
+                        list.add(dynDog);
+                        fail();
+                    } catch (IllegalStateException expected) {
+                        assertEquals(expectedMsg, expected.getMessage());
+                    }
+
+                    try {
+                        list.add(0, dynDog);
+                        fail();
+                    } catch (IllegalStateException expected) {
+                        assertEquals(expectedMsg, expected.getMessage());
+                    }
+
+                    try {
+                        list.set(0, dynDog);
+                        fail();
+                    } catch (IllegalStateException expected) {
+                        assertEquals(expectedMsg, expected.getMessage());
+                    }
+                } catch (Throwable throwable) {
+                    thrownErrorRef.set(throwable);
+                } finally {
+                    dynamicRealm.cancelTransaction();
+                    dynamicRealm.close();
+                    finishedLatch.countDown();
                 }
-
-                dynamicRealm.cancelTransaction();
-                dynamicRealm.close();
-                finishedLatch.countDown();
             }
         }).start();
         TestHelper.awaitOrFail(finishedLatch);
         dynamicRealm.close();
+
+        final Throwable thrown = thrownErrorRef.get();
+        if (thrown != null) {
+            throw thrown;
+        }
     }
 
     @Test
@@ -973,4 +990,112 @@ public void add_set_dynamicObjectCreatedFromTypedRealm() {
         dynamicRealm.close();
     }
 
+    private RealmList<Dog> prepareRealmListInLooperThread() {
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        Owner owner = realm.createObject(Owner.class);
+        owner.setName("Owner");
+        for (int i = 0; i < TEST_SIZE; i++) {
+            Dog dog = realm.createObject(Dog.class);
+            dog.setName("Dog " + i);
+            owner.getDogs().add(dog);
+        }
+        realm.commitTransaction();
+        return owner.getDogs();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener() {
+        collection = prepareRealmListInLooperThread();
+        Realm realm = looperThread.realm;
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        collection.addChangeListener(new RealmChangeListener<RealmList<Dog>>() {
+            @Override
+            public void onChange(RealmList<Dog> element) {
+                assertEquals(0, listenerCalledCount.getAndIncrement());
+            }
+        });
+        collection.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Dog>>() {
+            @Override
+            public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet changes) {
+                assertEquals(1, listenerCalledCount.getAndIncrement());
+            }
+        });
+        realm.beginTransaction();
+        collection.get(0).setAge(42);
+        realm.commitTransaction();
+
+        // This should trigger the listener.
+        realm.beginTransaction();
+        realm.cancelTransaction();
+        assertEquals(2, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeAllChangeListeners() {
+        collection = prepareRealmListInLooperThread();
+        Realm realm = looperThread.realm;
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        collection.addChangeListener(new RealmChangeListener<RealmList<Dog>>() {
+            @Override
+            public void onChange(RealmList<Dog> element) {
+                fail();
+            }
+        });
+        collection.addChangeListener(new OrderedRealmCollectionChangeListener<RealmList<Dog>>() {
+            @Override
+            public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet changes) {
+                fail();
+            }
+        });
+        realm.beginTransaction();
+        collection.get(0).setAge(42);
+        realm.commitTransaction();
+
+        collection.removeAllChangeListeners();
+
+        // This should trigger the listener if there is any.
+        realm.beginTransaction();
+        realm.cancelTransaction();
+        assertEquals(0, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListener() {
+        collection = prepareRealmListInLooperThread();
+        Realm realm = looperThread.realm;
+        final AtomicInteger listenerCalledCount = new AtomicInteger(0);
+        RealmChangeListener<RealmList<Dog>> listener1 = new RealmChangeListener<RealmList<Dog>>() {
+            @Override
+            public void onChange(RealmList<Dog> element) {
+                fail();
+            }
+        };
+        OrderedRealmCollectionChangeListener<RealmList<Dog>> listener2 =
+                new OrderedRealmCollectionChangeListener<RealmList<Dog>>() {
+                    @Override
+                    public void onChange(RealmList<Dog> collection, OrderedCollectionChangeSet changes) {
+                        assertEquals(0, listenerCalledCount.getAndIncrement());
+                    }
+                };
+
+        collection.addChangeListener(listener1);
+        collection.addChangeListener(listener2);
+        realm.beginTransaction();
+        collection.get(0).setAge(42);
+        realm.commitTransaction();
+
+        collection.removeChangeListener(listener1);
+
+        // This should trigger the listener if there is any.
+        realm.beginTransaction();
+        realm.cancelTransaction();
+        assertEquals(1, listenerCalledCount.get());
+        looperThread.testComplete();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
index e91ae3ba16..c10ebbbb5b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmLogTests.java
@@ -8,7 +8,6 @@
 import org.junit.runner.RunWith;
 
 import io.realm.log.LogLevel;
-import io.realm.log.Logger;
 import io.realm.log.RealmLog;
 
 import static junit.framework.Assert.assertEquals;
@@ -92,65 +91,4 @@ public void throwable_passedToTheJavaLogger() {
         assertTrue(testLogger.message.contains("RealmLogTests.java"));
         RealmLog.remove(testLogger);
     }
-
-    static class TestOldLogger implements Logger {
-        String message;
-        Throwable throwable;
-
-        @Override
-        public int getMinimumNativeDebugLevel() {
-            return 0;
-        }
-
-        @Override
-        public void trace(Throwable throwable, String message, Object... args) {
-        }
-
-        @Override
-        public void debug(Throwable throwable, String message, Object... args) {
-        }
-
-        @Override
-        public void info(Throwable throwable, String message, Object... args) {
-        }
-
-        @Override
-        public void warn(Throwable throwable, String message, Object... args) {
-        }
-
-        @Override
-        public void error(Throwable throwable, String message, Object... args) {
-        }
-
-        @Override
-        public void fatal(Throwable throwable, String message, Object... args) {
-            this.throwable = throwable;
-            this.message = message;
-        }
-    }
-
-    @Test
-    public void loggerAdaptor() {
-        TestOldLogger testLogger = new TestOldLogger();
-        RealmLog.add(testLogger);
-        Throwable throwable;
-
-        try {
-            throw new RuntimeException("Test exception.");
-        } catch (RuntimeException e) {
-            throwable = e;
-            RealmLog.fatal(e);
-        }
-
-        // Throwable has been passed.
-        assertEquals(throwable, testLogger.throwable);
-        assertTrue(testLogger.message.contains("RealmLogTests.java"));
-
-        RealmLog.remove(testLogger);
-        RealmLog.fatal("new string");
-
-        // Logger has been removed, nothing should be changed.
-        assertEquals(throwable, testLogger.throwable);
-        assertTrue(testLogger.message.contains("RealmLogTests.java"));
-    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
index c8d3a4025f..2feb6876e7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectTests.java
@@ -22,13 +22,13 @@
 
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
 import java.io.FileNotFoundException;
-import java.lang.ref.WeakReference;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.concurrent.Callable;
@@ -38,6 +38,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllJavaTypes;
@@ -280,20 +281,21 @@ private void removeOneByOne(boolean removeFromFront) {
 
         // Checks initial size.
         RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
-        assertEquals(TEST_SIZE, dogs.size());
+        OrderedRealmCollectionSnapshot<Dog> snapshot = dogs.createSnapshot();
+        assertEquals(TEST_SIZE, snapshot.size());
 
         // Checks that calling deleteFromRealm doesn't remove the object from the RealmResult.
         realm.beginTransaction();
         for (int i = 0; i < TEST_SIZE; i++) {
-            dogs.get(removeFromFront ? i : TEST_SIZE - 1 - i).deleteFromRealm();
+            snapshot.get(removeFromFront ? i : TEST_SIZE - 1 - i).deleteFromRealm();
         }
         realm.commitTransaction();
 
-        assertEquals(TEST_SIZE, dogs.size());
-        assertEquals(0, realm.where(Dog.class).count());
+        assertEquals(TEST_SIZE, snapshot.size());
+        assertEquals(0, dogs.size());
     }
 
-    // Tests calling deleteFromRealm on a RealmResults instead of RealmResults.remove().
+    // Tests calling deleteFromRealm on a OrderedRealmCollectionSnapshot instead of RealmResults.remove().
     @Test
     public void deleteFromRealm_atPosition() {
         removeOneByOne(REMOVE_FIRST);
@@ -1601,6 +1603,27 @@ public void run() throws Exception {
         });
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void changeListener_triggeredWhenObjectIsdeleted() {
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        obj.addChangeListener(new RealmChangeListener<AllTypes>() {
+            @Override
+            public void onChange(AllTypes obj) {
+                assertFalse(obj.isValid());
+                looperThread.testComplete();
+            }
+        });
+
+        realm.beginTransaction();
+        obj.deleteFromRealm();
+        realm.commitTransaction();
+    }
+
     @Test
     @RunTestInLooperThread
     public void addChangeListener_throwOnUnmanagedObject() {
@@ -1659,7 +1682,7 @@ public void run() throws Exception {
      */
     @Test
     @RunTestInLooperThread
-    public void removeChangeListeners() {
+    public void removeAllChangeListeners() {
         final Realm realm = looperThread.realm;
         realm.beginTransaction();
         Dog dog = realm.createObject(Dog.class);
@@ -1671,7 +1694,7 @@ public void onChange(Dog object) {
                 assertTrue(false);
             }
         });
-        dog.removeChangeListeners();
+        dog.removeAllChangeListeners();
 
         realm.beginTransaction();
         Dog sameDog = realm.where(Dog.class).equalTo(Dog.FIELD_AGE, 13).findFirst();
@@ -1700,11 +1723,11 @@ public void onChange(Dog object) {
 
     @Test
     @RunTestInLooperThread
-    public void removeChangeListeners_throwOnUnmanagedObject() {
+    public void removeAllChangeListeners_throwOnUnmanagedObject() {
         Dog dog = new Dog();
 
         try {
-            dog.removeChangeListeners();
+            dog.removeAllChangeListeners();
             fail("Failed to remove null listener.");
         } catch (IllegalArgumentException ignore) {
             looperThread.testComplete();
@@ -1721,7 +1744,7 @@ public void addChangeListener_returnedObjectOfCopyToRealmOrUpdate() {
 
         AllTypesPrimaryKey allTypesPrimaryKey = new AllTypesPrimaryKey();
         allTypesPrimaryKey.setColumnLong(1);
-        allTypesPrimaryKey.setColumnFloat(42f);
+        allTypesPrimaryKey.setColumnFloat(0f);
         allTypesPrimaryKey = realm.copyToRealmOrUpdate(allTypesPrimaryKey);
         realm.commitTransaction();
 
@@ -1733,93 +1756,48 @@ public void onChange(AllTypesPrimaryKey element) {
                 looperThread.testComplete();
             }
         });
-    }
 
-    // The object should be added to HandlerController.realmObjects only when the first time addListener called.
-    @Test
-    @UiThreadTest
-    public void addChangeListener_shouldAddTheObjectToHandlerRealmObjects() {
+        // Change the object to trigger the listener.
         realm.beginTransaction();
-        AllTypesPrimaryKey allTypesPrimaryKey = realm.createObject(AllTypesPrimaryKey.class, 1);
-        realm.commitTransaction();
-        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
-                realm.handlerController.realmObjects;
-
-        assertTrue(realmObjects.isEmpty());
-
-        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
-            @Override
-            public void onChange(AllTypesPrimaryKey element) {
-            }
-        });
-
-        assertEquals(1, realmObjects.size());
-        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
-            assertTrue(ref.get() == allTypesPrimaryKey);
-        }
-    }
-
-    // The object should be added to HandlerController.realmObjects only once.
-    @Test
-    @UiThreadTest
-    public void addChangeListener_shouldNotAddDupEntriesToHandlerRealmObjects() {
-        realm.beginTransaction();
-        AllTypesPrimaryKey allTypesPrimaryKey = realm.createObject(AllTypesPrimaryKey.class, 1);
+        allTypesPrimaryKey.setColumnFloat(42f);
         realm.commitTransaction();
-        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
-                realm.handlerController.realmObjects;
-
-        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
-            assertFalse(ref.get() == allTypesPrimaryKey);
-        }
-
-        // Adds different listeners twice.
-        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
-            @Override
-            public void onChange(AllTypesPrimaryKey element) {
-            }
-        });
-        allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
-            @Override
-            public void onChange(AllTypesPrimaryKey element) {
-            }
-        });
-
-        assertEquals(1, realmObjects.size());
-        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
-            assertTrue(ref.get() == allTypesPrimaryKey);
-        }
     }
 
-    // The object should not be added to HandlerController again after the async query loaded.
+    // step 1: findFirstAsync
+    // step 2: async query returns, change the object in the listener
+    // step 3: listener gets called again
     @Test
     @RunTestInLooperThread
-    public void addChangeListener_checkHandlerRealmObjectsWhenCallingOnAsyncObject() {
-        Realm realm = looperThread.realm;
+    public void addChangeListener_listenerShouldBeCalledIfObjectChangesAfterAsyncReturn() {
+        final AtomicInteger listenerCounter = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
         realm.beginTransaction();
         realm.createObject(AllTypesPrimaryKey.class, 1);
         realm.commitTransaction();
-        final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
-                realm.handlerController.realmObjects;
 
+        // Step 1
         final AllTypesPrimaryKey allTypesPrimaryKey = realm.where(AllTypesPrimaryKey.class).findFirstAsync();
         looperThread.keepStrongReference.add(allTypesPrimaryKey);
         allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
             @Override
             public void onChange(AllTypesPrimaryKey element) {
-                allTypesPrimaryKey.addChangeListener(new RealmChangeListener<AllTypesPrimaryKey>() {
-                    @Override
-                    public void onChange(AllTypesPrimaryKey element) {
-
-                    }
-                });
-                assertEquals(1, realmObjects.size());
-                looperThread.testComplete();
+                int count = listenerCounter.getAndAdd(1);
+                if (count == 0) {
+                    // Step 2
+                    realm.executeTransactionAsync(new Realm.Transaction() {
+                        @Override
+                        public void execute(Realm realm) {
+                            realm.where(AllTypesPrimaryKey.class).findFirst().setColumnFloat(42f);
+                        }
+                    });
+                } else if (count == 1) {
+                    // Step 3
+                    assertEquals(allTypesPrimaryKey.getColumnFloat(), 42f, 0);
+                    looperThread.testComplete();
+                } else {
+                    fail();
+                }
             }
         });
-        assertEquals(1, realmObjects.size());
-        for (Object query : realmObjects.values()) {
-            assertNotNull(query);
-        }
     }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index b1dbf6c3f4..c1939d26aa 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -16,7 +16,6 @@
 
 package io.realm;
 
-import android.os.Looper;
 import android.support.test.runner.AndroidJUnit4;
 
 import org.junit.After;
@@ -26,15 +25,15 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
+import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
@@ -108,6 +107,11 @@ private void populateTestRealm(Realm testRealm, int dataSize) {
             nonLatinFieldNames.setΔέλτα(i);
             nonLatinFieldNames.set베타(1.234567f + i);
             nonLatinFieldNames.setΒήτα(1.234567f + i);
+
+            Dog dog = testRealm.createObject(Dog.class);
+            dog.setAge(i);
+            dog.setName("test data " + i);
+            allTypes.setColumnRealmObject(dog);
         }
         testRealm.commitTransaction();
     }
@@ -147,6 +151,291 @@ private void populateNoPrimaryKeyNullTypesRows() {
         populateNoPrimaryKeyNullTypesRows(realm, TEST_NO_PRIMARY_KEY_NULL_TYPES_SIZE);
     }
 
+    private enum ThreadConfinedMethods {
+        EQUAL_TO_STRING,
+        EQUAL_TO_STRING_WITH_CASE,
+        EQUAL_TO_BYTE,
+        EQUAL_TO_BYTE_ARRAY,
+        EQUAL_TO_SHORT,
+        EQUAL_TO_INTEGER,
+        EQUAL_TO_LONG,
+        EQUAL_TO_DOUBLE,
+        EQUAL_TO_FLOAT,
+        EQUAL_TO_BOOLEAN,
+        EQUAL_TO_DATE,
+
+        IN_STRING,
+        IN_STRING_WITH_CASE,
+        IN_BYTE,
+        IN_SHORT,
+        IN_INTEGER,
+        IN_LONG,
+        IN_DOUBLE,
+        IN_FLOAT,
+        IN_BOOLEAN,
+        IN_DATE,
+
+        NOT_EQUAL_TO_STRING,
+        NOT_EQUAL_TO_STRING_WITH_CASE,
+        NOT_EQUAL_TO_BYTE,
+        NOT_EQUAL_TO_BYTE_ARRAY,
+        NOT_EQUAL_TO_SHORT,
+        NOT_EQUAL_TO_INTEGER,
+        NOT_EQUAL_TO_LONG,
+        NOT_EQUAL_TO_DOUBLE,
+        NOT_EQUAL_TO_FLOAT,
+        NOT_EQUAL_TO_BOOLEAN,
+        NOT_EQUAL_TO_DATE,
+
+        GREATER_THAN_INTEGER,
+        GREATER_THAN_LONG,
+        GREATER_THAN_DOUBLE,
+        GREATER_THAN_FLOAT,
+        GREATER_THAN_DATE,
+
+        GREATER_THAN_OR_EQUAL_TO_INTEGER,
+        GREATER_THAN_OR_EQUAL_TO_LONG,
+        GREATER_THAN_OR_EQUAL_TO_DOUBLE,
+        GREATER_THAN_OR_EQUAL_TO_FLOAT,
+        GREATER_THAN_OR_EQUAL_TO_DATE,
+
+        LESS_THAN_INTEGER,
+        LESS_THAN_LONG,
+        LESS_THAN_DOUBLE,
+        LESS_THAN_FLOAT,
+        LESS_THAN_DATE,
+
+        LESS_THAN_OR_EQUAL_TO_INTEGER,
+        LESS_THAN_OR_EQUAL_TO_LONG,
+        LESS_THAN_OR_EQUAL_TO_DOUBLE,
+        LESS_THAN_OR_EQUAL_TO_FLOAT,
+        LESS_THAN_OR_EQUAL_TO_DATE,
+
+        BETWEEN_INTEGER,
+        BETWEEN_LONG,
+        BETWEEN_DOUBLE,
+        BETWEEN_FLOAT,
+        BETWEEN_DATE,
+
+        CONTAINS_STRING,
+        CONTAINS_STRING_WITH_CASE,
+
+        BEGINS_WITH_STRING,
+        BEGINS_WITH_STRING_WITH_CASE,
+
+        ENDS_WITH_STRING,
+        ENDS_WITH_STRING_WITH_CASE,
+
+        LIKE_STRING,
+        LIKE_STRING_WITH_CASE,
+
+        BEGIN_GROUP,
+        END_GROUP,
+        OR,
+        NOT,
+        IS_NULL,
+        IS_NOT_NULL,
+        IS_EMPTY,
+        IS_NOT_EMPTY,
+
+        IS_VALID,
+        DISTINCT,
+        DISTINCT_BY_MULTIPLE_FIELDS,
+        DISTINCT_ASYNC,
+
+        SUM,
+        AVERAGE,
+        MIN,
+        MINIMUM_DATE,
+        MAX,
+        MAXIMUM_DATE,
+        COUNT,
+
+        FIND_ALL,
+        FIND_ALL_ASYNC,
+        FIND_ALL_SORTED,
+        FIND_ALL_SORTED_ASYNC,
+        FIND_ALL_SORTED_WITH_ORDER,
+        FIND_ALL_SORTED_ASYNC_WITH_ORDER,
+        FIND_ALL_SORTED_WITH_TWO_ORDERS,
+        FIND_ALL_SORTED_ASYNC_WITH_TWO_ORDERS,
+        FIND_ALL_SORTED_WITH_MANY_ORDERS,
+        FIND_ALL_SORTED_ASYNC_WITH_MANY_ORDERS,
+
+        FIND_FIRST,
+        FIND_FIRST_ASYNC,
+    }
+
+    private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfinedMethods method) {
+        switch (method) {
+            case EQUAL_TO_STRING: query.equalTo(           AllJavaTypes.FIELD_STRING,  "dummy value"); break;
+            case EQUAL_TO_STRING_WITH_CASE: query.equalTo( AllJavaTypes.FIELD_STRING,  "dummy value", Case.INSENSITIVE); break;
+            case EQUAL_TO_BYTE: query.equalTo(             AllJavaTypes.FIELD_BYTE,    (byte) 1); break;
+            case EQUAL_TO_BYTE_ARRAY: query.equalTo(       AllJavaTypes.FIELD_BINARY,  new byte[] {0, 1, 2}); break;
+            case EQUAL_TO_SHORT: query.equalTo(            AllJavaTypes.FIELD_SHORT,   (short) 1); break;
+            case EQUAL_TO_INTEGER: query.equalTo(          AllJavaTypes.FIELD_INT,     1); break;
+            case EQUAL_TO_LONG: query.equalTo(             AllJavaTypes.FIELD_LONG,    1L); break;
+            case EQUAL_TO_DOUBLE: query.equalTo(           AllJavaTypes.FIELD_DOUBLE,  1D); break;
+            case EQUAL_TO_FLOAT: query.equalTo(            AllJavaTypes.FIELD_FLOAT,   1F); break;
+            case EQUAL_TO_BOOLEAN: query.equalTo(          AllJavaTypes.FIELD_BOOLEAN, true); break;
+            case EQUAL_TO_DATE: query.equalTo(             AllJavaTypes.FIELD_DATE,    new Date(0L)); break;
+
+            case IN_STRING: query.in(           AllJavaTypes.FIELD_STRING,  new String[] {"dummy value1", "dummy value2"}); break;
+            case IN_STRING_WITH_CASE: query.in( AllJavaTypes.FIELD_STRING,  new String[] {"dummy value1", "dummy value2"}, Case.INSENSITIVE); break;
+            case IN_BYTE: query.in(             AllJavaTypes.FIELD_BYTE,    new Byte[] {1, 2, 3}); break;
+            case IN_SHORT: query.in(            AllJavaTypes.FIELD_SHORT,   new Short[] {1, 2, 3}); break;
+            case IN_INTEGER: query.in(          AllJavaTypes.FIELD_INT,     new Integer[] {1, 2, 3}); break;
+            case IN_LONG: query.in(             AllJavaTypes.FIELD_LONG,    new Long[] {1L, 2L, 3L}); break;
+            case IN_DOUBLE: query.in(           AllJavaTypes.FIELD_DOUBLE,  new Double[] {1D, 2D, 3D}); break;
+            case IN_FLOAT: query.in(            AllJavaTypes.FIELD_FLOAT,   new Float[] {1F, 2F, 3F}); break;
+            case IN_BOOLEAN: query.in(          AllJavaTypes.FIELD_BOOLEAN, new Boolean[] {true, false}); break;
+            case IN_DATE: query.in(             AllJavaTypes.FIELD_DATE,    new Date[] {new Date(0L)}); break;
+
+            case NOT_EQUAL_TO_STRING: query.notEqualTo(           AllJavaTypes.FIELD_STRING,  "dummy value"); break;
+            case NOT_EQUAL_TO_STRING_WITH_CASE: query.notEqualTo( AllJavaTypes.FIELD_STRING,  "dummy value", Case.INSENSITIVE); break;
+            case NOT_EQUAL_TO_BYTE: query.notEqualTo(             AllJavaTypes.FIELD_BYTE,    (byte) 1); break;
+            case NOT_EQUAL_TO_BYTE_ARRAY: query.notEqualTo(       AllJavaTypes.FIELD_BINARY,  new byte[] {1,2,3}); break;
+            case NOT_EQUAL_TO_SHORT: query.notEqualTo(            AllJavaTypes.FIELD_SHORT,   (short) 1); break;
+            case NOT_EQUAL_TO_INTEGER: query.notEqualTo(          AllJavaTypes.FIELD_INT,     1); break;
+            case NOT_EQUAL_TO_LONG: query.notEqualTo(             AllJavaTypes.FIELD_LONG,    1L); break;
+            case NOT_EQUAL_TO_DOUBLE: query.notEqualTo(           AllJavaTypes.FIELD_DOUBLE,  1D); break;
+            case NOT_EQUAL_TO_FLOAT: query.notEqualTo(            AllJavaTypes.FIELD_FLOAT,   1F); break;
+            case NOT_EQUAL_TO_BOOLEAN: query.notEqualTo(          AllJavaTypes.FIELD_BOOLEAN, true); break;
+            case NOT_EQUAL_TO_DATE: query.notEqualTo(             AllJavaTypes.FIELD_DATE,    new Date(0L)); break;
+
+            case GREATER_THAN_INTEGER: query.greaterThan( AllJavaTypes.FIELD_INT,    1); break;
+            case GREATER_THAN_LONG: query.greaterThan(    AllJavaTypes.FIELD_LONG,   1L); break;
+            case GREATER_THAN_DOUBLE: query.greaterThan(  AllJavaTypes.FIELD_DOUBLE, 1D); break;
+            case GREATER_THAN_FLOAT: query.greaterThan(   AllJavaTypes.FIELD_FLOAT,  1F); break;
+            case GREATER_THAN_DATE: query.greaterThan(    AllJavaTypes.FIELD_DATE,   new Date(0L)); break;
+
+            case GREATER_THAN_OR_EQUAL_TO_INTEGER: query.greaterThanOrEqualTo( AllJavaTypes.FIELD_INT,    1); break;
+            case GREATER_THAN_OR_EQUAL_TO_LONG: query.greaterThanOrEqualTo(    AllJavaTypes.FIELD_LONG,   1L); break;
+            case GREATER_THAN_OR_EQUAL_TO_DOUBLE: query.greaterThanOrEqualTo(  AllJavaTypes.FIELD_DOUBLE, 1D); break;
+            case GREATER_THAN_OR_EQUAL_TO_FLOAT: query.greaterThanOrEqualTo(   AllJavaTypes.FIELD_FLOAT,  1F); break;
+            case GREATER_THAN_OR_EQUAL_TO_DATE: query.greaterThanOrEqualTo(    AllJavaTypes.FIELD_DATE,   new Date(0L)); break;
+
+            case LESS_THAN_INTEGER: query.lessThan( AllJavaTypes.FIELD_INT,    1); break;
+            case LESS_THAN_LONG: query.lessThan(    AllJavaTypes.FIELD_LONG,   1L); break;
+            case LESS_THAN_DOUBLE: query.lessThan(  AllJavaTypes.FIELD_DOUBLE, 1D); break;
+            case LESS_THAN_FLOAT: query.lessThan(   AllJavaTypes.FIELD_FLOAT,  1F); break;
+            case LESS_THAN_DATE: query.lessThan(    AllJavaTypes.FIELD_DATE,   new Date(0L)); break;
+
+            case LESS_THAN_OR_EQUAL_TO_INTEGER: query.lessThanOrEqualTo( AllJavaTypes.FIELD_INT,    1); break;
+            case LESS_THAN_OR_EQUAL_TO_LONG: query.lessThanOrEqualTo(    AllJavaTypes.FIELD_LONG,   1L); break;
+            case LESS_THAN_OR_EQUAL_TO_DOUBLE: query.lessThanOrEqualTo(  AllJavaTypes.FIELD_DOUBLE, 1D); break;
+            case LESS_THAN_OR_EQUAL_TO_FLOAT: query.lessThanOrEqualTo(   AllJavaTypes.FIELD_FLOAT,  1F); break;
+            case LESS_THAN_OR_EQUAL_TO_DATE: query.lessThanOrEqualTo(    AllJavaTypes.FIELD_DATE,   new Date(0L)); break;
+
+            case BETWEEN_INTEGER: query.between( AllJavaTypes.FIELD_INT,    1, 100); break;
+            case BETWEEN_LONG: query.between(    AllJavaTypes.FIELD_LONG,   1L, 100L); break;
+            case BETWEEN_DOUBLE: query.between(  AllJavaTypes.FIELD_DOUBLE, 1D, 100D); break;
+            case BETWEEN_FLOAT: query.between(   AllJavaTypes.FIELD_FLOAT,  1F, 100F); break;
+            case BETWEEN_DATE: query.between(    AllJavaTypes.FIELD_DATE,   new Date(0L), new Date(10000L)); break;
+
+            case CONTAINS_STRING: query.contains(           AllJavaTypes.FIELD_STRING, "dummy value"); break;
+            case CONTAINS_STRING_WITH_CASE: query.contains( AllJavaTypes.FIELD_STRING, "dummy value", Case.INSENSITIVE); break;
+
+            case BEGINS_WITH_STRING: query.beginsWith(           AllJavaTypes.FIELD_STRING, "dummy value"); break;
+            case BEGINS_WITH_STRING_WITH_CASE: query.beginsWith( AllJavaTypes.FIELD_STRING, "dummy value", Case.INSENSITIVE); break;
+
+            case ENDS_WITH_STRING: query.endsWith(           AllJavaTypes.FIELD_STRING, "dummy value"); break;
+            case ENDS_WITH_STRING_WITH_CASE: query.endsWith( AllJavaTypes.FIELD_STRING, "dummy value", Case.INSENSITIVE); break;
+
+            case LIKE_STRING: query.like(           AllJavaTypes.FIELD_STRING, "dummy value"); break;
+            case LIKE_STRING_WITH_CASE: query.like( AllJavaTypes.FIELD_STRING, "dummy value", Case.INSENSITIVE); break;
+
+            case BEGIN_GROUP: query.beginGroup(); break;
+            case END_GROUP: query.endGroup(); break;
+            case OR: query.or(); break;
+            case NOT: query.not(); break;
+            case IS_NULL: query.isNull(          AllJavaTypes.FIELD_DATE); break;
+            case IS_NOT_NULL: query.isNotNull(   AllJavaTypes.FIELD_DATE); break;
+            case IS_EMPTY: query.isEmpty(        AllJavaTypes.FIELD_STRING); break;
+            case IS_NOT_EMPTY: query.isNotEmpty( AllJavaTypes.FIELD_STRING); break;
+
+            case IS_VALID: query.isValid(); break;
+            case DISTINCT: query.distinct(                    AllJavaTypes.FIELD_STRING); break;
+            case DISTINCT_BY_MULTIPLE_FIELDS: query.distinct( AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID); break;
+            case DISTINCT_ASYNC: query.distinctAsync(         AllJavaTypes.FIELD_STRING); break;
+
+            case SUM: query.sum(                  AllJavaTypes.FIELD_INT); break;
+            case AVERAGE: query.average(          AllJavaTypes.FIELD_INT); break;
+            case MIN: query.min(                  AllJavaTypes.FIELD_INT); break;
+            case MINIMUM_DATE: query.minimumDate( AllJavaTypes.FIELD_INT); break;
+            case MAX: query.max(                  AllJavaTypes.FIELD_INT); break;
+            case MAXIMUM_DATE: query.maximumDate( AllJavaTypes.FIELD_INT); break;
+            case COUNT: query.count(); break;
+
+            case FIND_ALL: query.findAll(); break;
+            case FIND_ALL_ASYNC: query.findAllAsync(); break;
+            case FIND_ALL_SORTED: query.findAllSorted(                             AllJavaTypes.FIELD_STRING); break;
+            case FIND_ALL_SORTED_ASYNC: query.findAllSortedAsync(                  AllJavaTypes.FIELD_STRING); break;
+            case FIND_ALL_SORTED_WITH_ORDER: query.findAllSorted(                  AllJavaTypes.FIELD_STRING, Sort.DESCENDING); break;
+            case FIND_ALL_SORTED_ASYNC_WITH_ORDER: query.findAllSortedAsync(       AllJavaTypes.FIELD_STRING, Sort.DESCENDING); break;
+            case FIND_ALL_SORTED_WITH_TWO_ORDERS: query.findAllSorted(             AllJavaTypes.FIELD_STRING, Sort.DESCENDING, AllJavaTypes.FIELD_ID, Sort.DESCENDING); break;
+            case FIND_ALL_SORTED_ASYNC_WITH_TWO_ORDERS: query.findAllSortedAsync(  AllJavaTypes.FIELD_STRING, Sort.DESCENDING, AllJavaTypes.FIELD_ID, Sort.DESCENDING); break;
+            case FIND_ALL_SORTED_WITH_MANY_ORDERS: query.findAllSorted(            new String[] {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID}, new Sort[] {Sort.DESCENDING, Sort.DESCENDING}); break;
+            case FIND_ALL_SORTED_ASYNC_WITH_MANY_ORDERS: query.findAllSortedAsync( new String[] {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID}, new Sort[] {Sort.DESCENDING, Sort.DESCENDING}); break;
+
+            case FIND_FIRST: query.findFirst(); break;
+            case FIND_FIRST_ASYNC: query.findFirstAsync(); break;
+
+            default:
+                throw new AssertionError("missing case for " + method);
+        }
+    }
+
+    @Test
+    public void callThreadConfinedMethodsFromWrongThread() throws Throwable {
+        final RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class);
+
+        final AtomicReference<Throwable> throwableFromThread = new AtomicReference<Throwable>();
+        final CountDownLatch testFinished = new CountDownLatch(1);
+
+        final String expectedMessage;
+        //noinspection TryWithIdenticalCatches
+        try {
+            final Field expectedMessageField = BaseRealm.class.getDeclaredField("INCORRECT_THREAD_MESSAGE");
+            expectedMessageField.setAccessible(true);
+            expectedMessage = (String) expectedMessageField.get(null);
+        } catch (NoSuchFieldException e) {
+            throw new AssertionError(e);
+        } catch (IllegalAccessException e) {
+            throw new AssertionError(e);
+        }
+
+        final Thread thread = new Thread("callThreadConfinedMethodsFromWrongThread") {
+            @Override
+            public void run() {
+                try {
+                    for (ThreadConfinedMethods method : ThreadConfinedMethods.values()) {
+                        try {
+                            callThreadConfinedMethod(query, method);
+                            fail("IllegalStateException must be thrown.");
+                        } catch (Throwable e) {
+                            if (e instanceof IllegalStateException && expectedMessage.equals(e.getMessage())) {
+                                // expected exception
+                                continue;
+                            }
+                            throwableFromThread.set(e);
+                            return;
+                        }
+                    }
+                } finally {
+                    testFinished.countDown();
+                }
+            }
+        };
+        thread.start();
+
+        TestHelper.awaitOrFail(testFinished);
+        final Throwable throwable = throwableFromThread.get();
+        if (throwable != null) {
+            throw throwable;
+        }
+    }
+
     @Test
     public void between() {
         final int TEST_OBJECTS_COUNT = 200;
@@ -263,6 +552,21 @@ public void or() {
         assertEquals(22, resultList.size());
     }
 
+    @Test(expected = UnsupportedOperationException.class)
+    public void or_missingFilters() {
+        realm.where(AllTypes.class).or().findAll();
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void or_missingFilterBefore() {
+        realm.where(AllTypes.class).or().equalTo(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void or_missingFilterAfter() {
+        realm.where(AllTypes.class).or().equalTo(AllTypes.FIELD_FLOAT, 31.234567f).findAll();
+    }
+
     @Test
     public void not() {
         populateTestRealm(); // create TEST_DATA_SIZE objects
@@ -2678,40 +2982,73 @@ public void execute(Realm realm) {
     }
 
     @Test
-    public void findAllSorted_onSubObjectFieldThrows() {
-        thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Sorting using child object fields is not supported: ");
-        realm.where(AllTypes.class).findAllSorted(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN);
+    public void findAllSorted_onSubObjectField() {
+        populateTestRealm(realm, TEST_DATA_SIZE);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .findAllSorted(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE);
+        assertEquals(0, results.get(0).getColumnRealmObject().getAge());
+        assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
     }
 
     @Test
-    public void findAllSortedAsync_onSubObjectFieldThrows() {
-        thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Sorting using child object fields is not supported: ");
-        realm.where(AllTypes.class).findAllSortedAsync(
-                AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN);
+    @RunTestInLooperThread
+    public void findAllSortedAsync_onSubObjectField() {
+        Realm realm = looperThread.realm;
+        populateTestRealm(realm, TEST_DATA_SIZE);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .findAllSortedAsync(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE);
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> results) {
+                assertEquals(0, results.get(0).getColumnRealmObject().getAge());
+                assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
+                looperThread.testComplete();
+            }
+        });
     }
 
     @Test
-    public void findAllSorted_listOnSubObjectFieldThrows() {
-        thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Sorting using child object fields is not supported: ");
-        String[] fieldNames = new String[1];
-        fieldNames[0] = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN;
-        Sort[] sorts = new Sort[1];
+    public void findAllSorted_listOnSubObjectField() {
+        String[] fieldNames = new String[2];
+        fieldNames[0] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
+        fieldNames[1] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
+
+        Sort[] sorts = new Sort[2];
         sorts[0] = Sort.ASCENDING;
-        realm.where(AllTypes.class).findAllSorted(fieldNames, sorts);
+        sorts[1] = Sort.ASCENDING;
+
+        populateTestRealm(realm, TEST_DATA_SIZE);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .findAllSorted(fieldNames, sorts);
+        assertEquals(0, results.get(0).getColumnRealmObject().getAge());
+        assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
     }
 
     @Test
-    public void findAllSortedAsync_listOnSubObjectFieldThrows() {
-        thrown.expect(IllegalArgumentException.class);
-        thrown.expectMessage("Sorting using child object fields is not supported: ");
-        String[] fieldNames = new String[1];
-        fieldNames[0] = AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BOOLEAN;
-        Sort[] sorts = new Sort[1];
+    @RunTestInLooperThread
+    public void findAllSortedAsync_listOnSubObjectField() {
+        Realm realm = looperThread.realm;
+        String[] fieldNames = new String[2];
+        fieldNames[0] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
+        fieldNames[1] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
+
+        Sort[] sorts = new Sort[2];
         sorts[0] = Sort.ASCENDING;
-        realm.where(AllTypes.class).findAllSortedAsync(fieldNames, sorts);
+        sorts[1] = Sort.ASCENDING;
+
+        populateTestRealm(realm, TEST_DATA_SIZE);
+        RealmResults<AllTypes> results = realm.where(AllTypes.class)
+                .findAllSortedAsync(fieldNames, sorts);
+        looperThread.keepStrongReference.add(results);
+        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
+            @Override
+            public void onChange(RealmResults<AllTypes> results) {
+                assertEquals(0, results.get(0).getColumnRealmObject().getAge());
+                assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
+                looperThread.testComplete();
+            }
+        });
     }
 
     // RealmQuery.distinct(): requires indexing, and type = boolean, integer, date, string.
@@ -2850,13 +3187,6 @@ public void distinct_invalidTypesLinkedFields() {
         }
     }
 
-    // distinctAsync
-    private Realm openRealmInstance(String name) {
-        RealmConfiguration config = configFactory.createConfiguration(name);
-        Realm.deleteRealm(config);
-        return Realm.getInstance(config);
-    }
-
     @Test
     @RunTestInLooperThread
     public void distinctAsync() throws Throwable {
@@ -2934,91 +3264,50 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_withNullValues() throws Throwable {
-        final CountDownLatch signalCallbackFinished = new CountDownLatch(2);
-        final CountDownLatch signalClosedRealm = new CountDownLatch(1);
-        final Throwable[] threadAssertionError = new Throwable[1];
-        final Looper[] backgroundLooper = new Looper[1];
-        final ExecutorService executorService = Executors.newSingleThreadExecutor();
-        executorService.submit(new Runnable() {
-            @Override
-            public void run() {
-                Looper.prepare();
-                backgroundLooper[0] = Looper.myLooper();
-
-                Realm asyncRealm = null;
-                try {
-                    Realm.asyncTaskExecutor.pause();
-                    asyncRealm = openRealmInstance("testDistinctAsyncQueryWithNull");
-                    final long numberOfBlocks = 25;
-                    final long numberOfObjects = 10; // Must be greater than 1
-                    populateForDistinct(asyncRealm, numberOfBlocks, numberOfObjects, true);
-
-                    final RealmResults<AnnotationIndexTypes> distinctDate = asyncRealm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
-                    final RealmResults<AnnotationIndexTypes> distinctString = asyncRealm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
-
-                    assertFalse(distinctDate.isLoaded());
-                    assertTrue(distinctDate.isValid());
-                    assertTrue(distinctDate.isEmpty());
-
-                    assertFalse(distinctString.isLoaded());
-                    assertTrue(distinctString.isValid());
-                    assertTrue(distinctString.isEmpty());
-
-                    Realm.asyncTaskExecutor.resume();
-
-                    distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-                        @Override
-                        public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                            assertEquals(1, distinctDate.size());
-                            signalCallbackFinished.countDown();
-                        }
-                    });
-
-                    distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
-                        @Override
-                        public void onChange(RealmResults<AnnotationIndexTypes> object) {
-                            assertEquals(1, distinctString.size());
-                            signalCallbackFinished.countDown();
-                        }
-                    });
+        final AtomicInteger changeListenerCalled = new AtomicInteger(2);
+        final Realm realm = looperThread.realm;
+        final long numberOfBlocks = 25;
+        final long numberOfObjects = 10; // must be greater than 1
+        populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
-                    Looper.loop();
-                } catch (Throwable e) {
-                    e.printStackTrace();
-                    threadAssertionError[0] = e;
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
+                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
 
-                } finally {
-                    if (signalCallbackFinished.getCount() > 0) {
-                        signalCallbackFinished.countDown();
-                    }
-                    if (asyncRealm != null) {
-                        asyncRealm.close();
-                    }
-                    signalClosedRealm.countDown();
+        final Runnable endTest = new Runnable() {
+            @Override
+            public void run() {
+                if (changeListenerCalled.decrementAndGet() == 0) {
+                    looperThread.testComplete();
                 }
             }
-        });
+        };
 
-        TestHelper.exitOrThrow(executorService, signalCallbackFinished, signalClosedRealm, backgroundLooper, threadAssertionError);
-    }
+        looperThread.keepStrongReference.add(distinctDate);
+        looperThread.keepStrongReference.add(distinctString);
 
-    @Test
-    public void distinctAsync_notIndexedFields() {
-        final long numberOfBlocks = 25;
-        final long numberOfObjects = 10;
-        populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
+        distinctDate.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(1, distinctDate.size());
+                endTest.run();
+            }
+        });
 
-        for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
-            try {
-                realm.where(AnnotationIndexTypes.class).distinctAsync(field);
-                fail(field);
-            } catch (IllegalArgumentException ignored) {
+        distinctString.addChangeListener(new RealmChangeListener<RealmResults<AnnotationIndexTypes>>() {
+            @Override
+            public void onChange(RealmResults<AnnotationIndexTypes> object) {
+                assertEquals(1, distinctString.size());
+                endTest.run();
             }
-        }
+        });
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_doesNotExist() {
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10;
@@ -3028,9 +3317,11 @@ public void distinctAsync_doesNotExist() {
             realm.where(AnnotationIndexTypes.class).distinctAsync("doesNotExist");
         } catch (IllegalArgumentException ignored) {
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_invalidTypes() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
@@ -3040,9 +3331,11 @@ public void distinctAsync_invalidTypes() {
             } catch (IllegalArgumentException ignored) {
             }
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_indexedLinkedFields() {
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10;
@@ -3055,9 +3348,11 @@ public void distinctAsync_indexedLinkedFields() {
             } catch (IllegalArgumentException ignored) {
             }
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_notIndexedLinkedFields() {
         populateForDistinctInvalidTypesLinked(realm);
 
@@ -3065,6 +3360,7 @@ public void distinctAsync_notIndexedLinkedFields() {
             realm.where(AllJavaTypes.class).distinctAsync(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
         } catch (IllegalArgumentException ignored) {
         }
+        looperThread.testComplete();
     }
 
     @Test
@@ -3230,4 +3526,14 @@ public void distinctMultiArgs_invalidTypesLinkedFields() {
         } catch (IllegalArgumentException ignored) {
         }
     }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void beginGroup_missingEndGroup() {
+        realm.where(AllTypes.class).beginGroup().findAll();
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void endGroup_missingBeginGroup() {
+        realm.where(AllTypes.class).endGroup().findAll();
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 312b93fe66..78946420d6 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -37,14 +37,13 @@
 import io.realm.entities.AllJavaTypes;
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationIndexTypes;
-import io.realm.entities.CyclicType;
 import io.realm.entities.DefaultValueOfField;
 import io.realm.entities.Dog;
 import io.realm.entities.NonLatinFieldNames;
 import io.realm.entities.Owner;
 import io.realm.entities.RandomPrimaryKey;
 import io.realm.entities.StringOnly;
-import io.realm.internal.Table;
+import io.realm.internal.Collection;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -103,14 +102,15 @@ public void findFirst() {
 
     @Test
     public void size_returns_Integer_MAX_VALUE_for_huge_results() {
-        final Table table = Mockito.mock(Table.class);
-        final RealmResults<AllTypes> targetResult = TestHelper.newRealmResults(realm, table, AllTypes.class);
+        final Collection collection = Mockito.mock(Collection.class);
+        final RealmResults<AllTypes> targetResult = TestHelper.newRealmResults(realm, collection, AllTypes.class);
 
-        Mockito.when(table.size()).thenReturn(((long) Integer.MAX_VALUE) - 1);
+        Mockito.when(collection.isLoaded()).thenReturn(true);
+        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE) - 1);
         assertEquals(Integer.MAX_VALUE - 1, targetResult.size());
-        Mockito.when(table.size()).thenReturn(((long) Integer.MAX_VALUE));
+        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE));
         assertEquals(Integer.MAX_VALUE, targetResult.size());
-        Mockito.when(table.size()).thenReturn(((long) Integer.MAX_VALUE) + 1);
+        Mockito.when(collection.size()).thenReturn(((long) Integer.MAX_VALUE) + 1);
         assertEquals(Integer.MAX_VALUE, targetResult.size());
     }
 
@@ -243,9 +243,9 @@ public void distinct_restrictedByPreviousDistinct() {
         // Distinctive Booleans
         RealmResults<AnnotationIndexTypes> distinctBooleans = distinctDates.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
         assertEquals("Distinctive Booleans", 2, distinctBooleans.size());
-        // All three results are the same object
-        assertTrue(allResults == distinctDates);
-        assertTrue(allResults == distinctBooleans);
+        // distinct results are not the same object
+        assertTrue(allResults != distinctDates);
+        assertTrue(allResults != distinctBooleans);
     }
 
     @Test
@@ -539,6 +539,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_notIndexedFields() {
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10;
@@ -551,9 +552,11 @@ public void distinctAsync_notIndexedFields() {
             } catch (IllegalArgumentException ignored) {
             }
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_doesNotExist() {
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10;
@@ -563,9 +566,11 @@ public void distinctAsync_doesNotExist() {
             realm.where(AnnotationIndexTypes.class).findAll().distinctAsync("doesNotExist");
         } catch (IllegalArgumentException ignored) {
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_invalidTypes() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
@@ -575,9 +580,11 @@ public void distinctAsync_invalidTypes() {
             } catch (IllegalArgumentException ignored) {
             }
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_indexedLinkedFields() {
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10;
@@ -590,9 +597,11 @@ public void distinctAsync_indexedLinkedFields() {
             } catch (IllegalArgumentException ignored) {
             }
         }
+        looperThread.testComplete();
     }
 
     @Test
+    @RunTestInLooperThread
     public void distinctAsync_notIndexedLinkedFields() {
         populateForDistinctInvalidTypesLinked(realm);
 
@@ -600,6 +609,7 @@ public void distinctAsync_notIndexedLinkedFields() {
             realm.where(AllJavaTypes.class).findAll().distinctAsync(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
         } catch (IllegalArgumentException ignored) {
         }
+        looperThread.testComplete();
     }
 
     @Test
@@ -766,97 +776,142 @@ public void distinctMultiArgs_invalidTypesLinkedFields() {
         }
     }
 
-    private RealmResults<Dog> populateRealmResultsOnDeletedLinkView() {
+    private RealmResults<Dog> populateRealmResultsOnLinkView(Realm realm) {
         realm.beginTransaction();
         Owner owner = realm.createObject(Owner.class);
         for (int i = 0; i < 10; i++) {
             Dog dog = new Dog();
             dog.setName("name_" + i);
             dog.setOwner(owner);
+            dog.setAge(i);
+            dog.setBirthday(new Date(i));
             owner.getDogs().add(dog);
         }
         realm.commitTransaction();
 
 
-        RealmResults<Dog> dogs = owner.getDogs().where().equalTo(Dog.FIELD_NAME, "name_0").findAll();
-
-        realm.beginTransaction();
-        owner.deleteFromRealm();
-        realm.commitTransaction();
-        return dogs;
+        return owner.getDogs().where().lessThan(Dog.FIELD_AGE, 5).findAll();
     }
 
-    // It will still be treated as valid table view in core, just always be empty.
+    // If a RealmResults is built on a link view, when the link view is deleted on the same thread, within the same
+    // event loop, the RealmResults stays without changes since it is detached until the next event loop. In the next
+    // event loop, the results will be empty because of the parent link view is deleted.
+    // 1. Create results from link view.
+    // 2. Delete the parent link view by a local transaction.
+    // 3. Within the same event loop, the results stays the same.
+    // 4. The results change listener called, the results becomes empty.
     @Test
-    public void isValid_resultsBuiltOnDeletedLinkView() {
-        assertEquals(true, populateRealmResultsOnDeletedLinkView().isValid());
-    }
+    @RunTestInLooperThread
+    public void accessors_resultsBuiltOnDeletedLinkView_deletionAsALocalCommit() {
+        Realm realm = looperThread.realm;
+        // Step 1
+        RealmResults<Dog> dogs = populateRealmResultsOnLinkView(realm);
+        looperThread.keepStrongReference.add(dogs);
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
+            @Override
+            public void onChange(RealmResults<Dog> dogs) {
+                // Step 4.
+                // The results is still valid, but empty.
+                assertEquals(true, dogs.isValid());
+                assertEquals(true, dogs.isEmpty());
+                assertEquals(0, dogs.size());
+                try {
+                    dogs.first();
+                    fail();
+                } catch (IndexOutOfBoundsException ignored) {
+                }
 
-    @Test
-    public void size_resultsBuiltOnDeletedLinkView() {
-        assertEquals(0, populateRealmResultsOnDeletedLinkView().size());
-    }
+                assertEquals(0, dogs.sum(Dog.FIELD_AGE).intValue());
+                assertEquals(0f, dogs.sum(Dog.FIELD_HEIGHT).floatValue(), 0f);
+                assertEquals(0d, dogs.sum(Dog.FIELD_WEIGHT).doubleValue(), 0d);
+                assertEquals(0d, dogs.average(Dog.FIELD_AGE), 0d);
+                assertEquals(0d, dogs.average(Dog.FIELD_HEIGHT), 0d);
+                assertEquals(0d, dogs.average(Dog.FIELD_WEIGHT), 0d);
+                assertEquals(null, dogs.min(Dog.FIELD_AGE));
+                assertEquals(null, dogs.max(Dog.FIELD_AGE));
+                assertEquals(null, dogs.minDate(Dog.FIELD_BIRTHDAY));
+                assertEquals(null, dogs.maxDate(Dog.FIELD_BIRTHDAY));
 
-    @Test
-    public void first_resultsBuiltOnDeletedLinkView() {
-        try {
-            populateRealmResultsOnDeletedLinkView().first();
-        } catch (IndexOutOfBoundsException ignored) {
-        }
-    }
+                assertEquals(0, dogs.where().findAll().size());
 
-    @Test
-    public void last_resultsBuiltOnDeletedLinkView() {
-        try {
-            populateRealmResultsOnDeletedLinkView().last();
-        } catch (IndexOutOfBoundsException ignored) {
-        }
-    }
+                looperThread.testComplete();
+            }
+        });
 
-    @Test
-    public void sum_resultsBuiltOnDeletedLinkView() {
-        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
-        assertEquals(0, dogs.sum(Dog.FIELD_AGE).intValue());
-        assertEquals(0f, dogs.sum(Dog.FIELD_HEIGHT).floatValue(), 0f);
-        assertEquals(0d, dogs.sum(Dog.FIELD_WEIGHT).doubleValue(), 0d);
-    }
+        // Step 2
+        realm.executeTransaction(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.where(Owner.class).findAll().deleteAllFromRealm();
+            }
+        });
 
-    @Test
-    public void average_resultsBuiltOnDeletedLinkView() {
-        RealmResults<Dog> dogs = populateRealmResultsOnDeletedLinkView();
-        assertEquals(0d, dogs.average(Dog.FIELD_AGE), 0d);
-        assertEquals(0d, dogs.average(Dog.FIELD_HEIGHT), 0d);
-        assertEquals(0d, dogs.average(Dog.FIELD_WEIGHT), 0d);
+        // Step 3
+        assertEquals(true, dogs.isValid());
+        assertEquals(0, dogs.size());
+        // The link view has been deleted.
+        assertEquals(0, dogs.where().findAll().size());
     }
 
+    // If a RealmResults is built on a link view, when the link view is deleted on a remote thread, within the same
+    // event loop, the RealmResults stays without changes since the Realm version doesn't change. In the next
+    // event loop, the results will be empty because of the parent link view is deleted.
+    // 1. Create results from link view.
+    // 2. Delete the parent link view by a remote transaction.
+    // 3. Within the same event loop, the results stays the same.
+    // 4. The results change listener called, the results becomes empty.
     @Test
-    public void where_resultsBuiltOnDeletedLinkView() {
-        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
-        assertEquals(0, results.where().findAll().size());
-    }
+    @RunTestInLooperThread
+    public void accessors_resultsBuiltOnDeletedLinkView_deletionAsARemoteCommit() {
+        // Step 1
+        Realm realm = looperThread.realm;
+        RealmResults<Dog> dogs = populateRealmResultsOnLinkView(realm);
+        looperThread.keepStrongReference.add(dogs);
+        dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
+            @Override
+            public void onChange(RealmResults<Dog> dogs) {
+                // Step 4
+                // The results is still valid, but empty.
+                assertEquals(true, dogs.isValid());
+                assertEquals(true, dogs.isEmpty());
+                assertEquals(0, dogs.size());
+                try {
+                    dogs.first();
+                    fail();
+                } catch (IndexOutOfBoundsException ignored) {
+                }
 
-    @Test
-    public void min_resultsBuiltOnDeletedLinkView() {
-        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
-        assertNull(results.min(CyclicType.FIELD_ID));
-    }
+                assertEquals(0, dogs.sum(Dog.FIELD_AGE).intValue());
+                assertEquals(0f, dogs.sum(Dog.FIELD_HEIGHT).floatValue(), 0f);
+                assertEquals(0d, dogs.sum(Dog.FIELD_WEIGHT).doubleValue(), 0d);
+                assertEquals(0d, dogs.average(Dog.FIELD_AGE), 0d);
+                assertEquals(0d, dogs.average(Dog.FIELD_HEIGHT), 0d);
+                assertEquals(0d, dogs.average(Dog.FIELD_WEIGHT), 0d);
+                assertEquals(null, dogs.min(Dog.FIELD_AGE));
+                assertEquals(null, dogs.max(Dog.FIELD_AGE));
+                assertEquals(null, dogs.minDate(Dog.FIELD_BIRTHDAY));
+                assertEquals(null, dogs.maxDate(Dog.FIELD_BIRTHDAY));
 
-    @Test
-    public void min_dateResultsBuiltOnDeletedLinkView() {
-        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
-        assertEquals(null, results.minDate(CyclicType.FIELD_DATE));
-    }
+                assertEquals(0, dogs.where().findAll().size());
 
-    @Test
-    public void max_dateResultsBuiltOnDeletedLinkView() {
-        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
-        assertEquals(null, results.maxDate(CyclicType.FIELD_DATE));
-    }
+                looperThread.testComplete();
+            }
+        });
 
-    @Test
-    public void max_resultsBuiltOnDeletedLinkView() {
-        OrderedRealmCollection<CyclicType> results = populateCollectionOnDeletedLinkView(realm, ManagedCollection.REALMRESULTS);
-        assertNull(results.max(CyclicType.FIELD_ID));
+
+        // Step 2
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.where(Owner.class).findAll().deleteAllFromRealm();
+            }
+        });
+
+        // Step 3
+        assertEquals(true, dogs.isValid());
+        assertEquals(5, dogs.size());
+        // The link view still exists
+        assertEquals(5, dogs.where().findAll().size());
     }
 
     @Test
@@ -924,7 +979,7 @@ public void run() {
     @UiThreadTest
     public void addChangeListener_null() {
         try {
-            collection.addChangeListener(null);
+            collection.addChangeListener((RealmChangeListener<RealmResults<AllTypes>>) null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -969,7 +1024,7 @@ public void run() {
     @UiThreadTest
     public void removeChangeListener_null() {
         try {
-            collection.removeChangeListener(null);
+            collection.removeChangeListener((RealmChangeListener) null);
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -998,7 +1053,7 @@ public void onChange(RealmResults<AllTypes> object) {
         looperThread.keepStrongReference.add(collection);
         collection.addChangeListener(listenerA);
         collection.addChangeListener(listenerB);
-        collection.removeChangeListeners();
+        collection.removeAllChangeListeners();
 
         realm.beginTransaction();
         realm.createObject(AllTypes.class);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 4337317fcc..37aaa12769 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -67,6 +67,7 @@
 import io.realm.entities.CyclicType;
 import io.realm.entities.CyclicTypePrimaryKey;
 import io.realm.entities.DefaultValueConstructor;
+import io.realm.entities.DefaultValueFromOtherConstructor;
 import io.realm.entities.DefaultValueOfField;
 import io.realm.entities.DefaultValueOverwriteNullLink;
 import io.realm.entities.DefaultValueSetter;
@@ -1031,6 +1032,22 @@ public void compactRealm_populatedRealm() throws IOException {
         assertTrue(before >= after);
     }
 
+    @Test
+    public void compactRealm_onExternalStorage() {
+        final File externalFilesDir = context.getExternalFilesDir(null);
+        final RealmConfiguration config = new RealmConfiguration.Builder()
+                .directory(externalFilesDir)
+                .name("external.realm")
+                .build();
+        Realm.deleteRealm(config);
+        Realm realm = Realm.getInstance(config);
+        realm.close();
+        assertTrue(Realm.compactRealm(config));
+        realm = Realm.getInstance(config);
+        realm.close();
+        Realm.deleteRealm(config);
+    }
+
     @Test
     public void copyToRealm_null() {
         realm.beginTransaction();
@@ -2409,6 +2426,15 @@ public void execute(Realm realm) {
                         RandomPrimaryKey.FIELD_INT_DEFAULT_VALUE + 1);
     }
 
+    @Test
+    public void createObject_defaultValueFromOtherConstructor() {
+        realm.beginTransaction();
+        DefaultValueFromOtherConstructor obj = realm.createObject(DefaultValueFromOtherConstructor.class);
+        realm.commitTransaction();
+
+        assertEquals(42, obj.getFieldLong());
+    }
+
     @Test
     public void copyToRealm_defaultValuesAreIgnored() {
         final String fieldIgnoredValue = DefaultValueOfField.FIELD_IGNORED_DEFAULT_VALUE + ".modified";
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
index 09b5ebba2f..f2a3e78586 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RxJavaTests.java
@@ -33,6 +33,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.CyclicType;
+import io.realm.entities.Dog;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -43,6 +44,7 @@
 import rx.functions.Func1;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -183,6 +185,44 @@ public void call(AllTypes rxObject) {
         realm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void findFirstAsync_emittedOnDelete() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        final Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        final AllTypes obj = realm.createObject(AllTypes.class);
+        realm.commitTransaction();
+
+        subscription = realm.where(AllTypes.class).findFirstAsync().<AllTypes>asObservable().subscribe(new Action1<AllTypes>() {
+            @Override
+            public void call(final AllTypes rxObject) {
+                switch (subscriberCalled.incrementAndGet()) {
+                    case 1:
+                        assertFalse(rxObject.isLoaded());
+                        break;
+                    case 2:
+                        assertTrue(rxObject.isLoaded());
+                        assertTrue(rxObject.isValid());
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                                realm.delete(AllTypes.class);
+                            }
+                        });
+                        break;
+                    case 3:
+                        assertTrue(rxObject.isLoaded());
+                        assertFalse(rxObject.isValid());
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail();
+                }
+            }
+        });
+    }
+
     @Test
     @UiThreadTest
     public void realmResults_emittedOnSubscribe() {
@@ -199,6 +239,24 @@ public void call(RealmResults<AllTypes> rxResults) {
         subscription.unsubscribe();
     }
 
+    @Test
+    @UiThreadTest
+    public void realmList_emittedOnSubscribe() {
+        final AtomicBoolean subscribedNotified = new AtomicBoolean(false);
+        realm.beginTransaction();
+        final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
+        realm.commitTransaction();
+        subscription = list.asObservable().subscribe(new Action1<RealmList<Dog>>() {
+            @Override
+            public void call(RealmList<Dog> rxList) {
+                assertTrue(rxList == list);
+                subscribedNotified.set(true);
+            }
+        });
+        assertTrue(subscribedNotified.get());
+        subscription.unsubscribe();
+    }
+
     @Test
     @UiThreadTest
     public void dynamicRealmResults_emittedOnSubscribe() {
@@ -240,6 +298,30 @@ public void call(RealmResults<AllTypes> allTypes) {
         realm.commitTransaction();
     }
 
+    @Test
+    @RunTestInLooperThread
+    public void realmList_emittedOnUpdate() {
+        final AtomicInteger subscriberCalled = new AtomicInteger(0);
+        Realm realm = looperThread.realm;
+        realm.beginTransaction();
+        final RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
+        realm.commitTransaction();
+
+        subscription = list.asObservable().subscribe(new Action1<RealmList<Dog>>() {
+            @Override
+            public void call(RealmList<Dog> dogs) {
+                if (subscriberCalled.incrementAndGet() == 2) {
+                    assertEquals(1, list.size());
+                    looperThread.testComplete();
+                }
+            }
+        });
+
+        realm.beginTransaction();
+        list.add(new Dog());
+        realm.commitTransaction();
+    }
+
     @Test
     @RunTestInLooperThread
     public void dynamicRealmResults_emittedOnUpdate() {
@@ -387,9 +469,9 @@ public void call(Realm rxRealm) {
                 subscribedNotified.set(true);
             }
         });
-        assertEquals(1, realm.handlerController.changeListeners.size());
+        assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
         subscription.unsubscribe();
-        assertEquals(0, realm.handlerController.changeListeners.size());
+        assertEquals(0, realm.sharedRealm.realmNotifier.getListenersListSize());
     }
 
     @Test
@@ -405,7 +487,7 @@ public void call(Realm rxRealm) {
             }
         });
         assertTrue(subscribedNotified.get());
-        assertEquals(1, realm.handlerController.changeListeners.size());
+        assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
         new Thread(new Runnable() {
             @Override
             public void run() {
@@ -419,7 +501,7 @@ public void run() {
             }
         }).start();
         TestHelper.awaitOrFail(unsubscribeCompleted);
-        assertEquals(1, realm.handlerController.changeListeners.size());
+        assertEquals(1, realm.sharedRealm.realmNotifier.getListenersListSize());
         // We cannot call subscription.unsubscribe() again, so manually close the extra Realm instance opened by
         // the Observable.
         realm.close();
@@ -510,6 +592,29 @@ public void call(RealmResults<AllTypes> allTypes) {
         assertTrue(realm.isClosed());
     }
 
+    @Test
+    @UiThreadTest
+    public void realmList_closeInDoOnUnsubscribe() {
+        realm.beginTransaction();
+        RealmList<Dog> list = realm.createObject(AllTypes.class).getColumnRealmList();
+        realm.commitTransaction();
+
+        Observable<RealmList<Dog>> observable = list.asObservable().doOnUnsubscribe(new Action0() {
+            @Override
+            public void call() {
+                realm.close();
+            }
+        });
+        subscription = observable.subscribe(new Action1<RealmList<Dog>>() {
+            @Override
+            public void call(RealmList<Dog> dogs) {
+            }
+        });
+
+        subscription.unsubscribe();
+        assertTrue(realm.isClosed());
+    }
+
     @Test
     @UiThreadTest
     public void dynamicRealmResults_closeInDoOnUnsubscribe() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 0dabb5911e..6e95a08106 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -30,7 +30,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
-import io.realm.internal.TableView;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
@@ -153,19 +152,19 @@ private void checkSortTwoFieldsStringAscendingIntAscending(RealmResults<AllTypes
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
+        assertEquals(0, results.getCollection().indexOf(2));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
+        assertEquals(1, results.getCollection().indexOf(0));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
+        assertEquals(2, results.getCollection().indexOf(3));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
+        assertEquals(3, results.getCollection().indexOf(1));
     }
 
     private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
@@ -179,19 +178,19 @@ private void checkSortTwoFieldsIntString(RealmResults<AllTypes> results) {
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
+        assertEquals(0, results.getCollection().indexOf(2));
 
         assertEquals("Brian", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
+        assertEquals(1, results.getCollection().indexOf(1));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
+        assertEquals(2, results.getCollection().indexOf(0));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
+        assertEquals(3, results.getCollection().indexOf(3));
     }
 
     private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllTypes> results) {
@@ -205,19 +204,19 @@ private void checkSortTwoFieldsIntAscendingStringDescending(RealmResults<AllType
 
         assertEquals("Brian", results.get(0).getColumnString());
         assertEquals(4, results.get(0).getColumnLong());
-        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
+        assertEquals(0, results.getCollection().indexOf(1));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(4, results.get(1).getColumnLong());
-        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
+        assertEquals(1, results.getCollection().indexOf(2));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(5, results.get(2).getColumnLong());
-        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
+        assertEquals(2, results.getCollection().indexOf(0));
 
         assertEquals("Adam", results.get(3).getColumnString());
         assertEquals(5, results.get(3).getColumnLong());
-        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
+        assertEquals(3, results.getCollection().indexOf(3));
     }
 
     private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllTypes> results) {
@@ -231,19 +230,19 @@ private void checkSortTwoFieldsStringAscendingIntDescending(RealmResults<AllType
 
         assertEquals("Adam", results.get(0).getColumnString());
         assertEquals(5, results.get(0).getColumnLong());
-        assertEquals(0, ((TableView) results.getTableOrView()).getSourceRowIndex(0));
+        assertEquals(0, results.getCollection().indexOf(0));
 
         assertEquals("Adam", results.get(1).getColumnString());
         assertEquals(5, results.get(1).getColumnLong());
-        assertEquals(3, ((TableView) results.getTableOrView()).getSourceRowIndex(1));
+        assertEquals(1, results.getCollection().indexOf(3));
 
         assertEquals("Adam", results.get(2).getColumnString());
         assertEquals(4, results.get(2).getColumnLong());
-        assertEquals(2, ((TableView) results.getTableOrView()).getSourceRowIndex(2));
+        assertEquals(2, results.getCollection().indexOf(2));
 
         assertEquals("Brian", results.get(3).getColumnString());
         assertEquals(4, results.get(3).getColumnLong());
-        assertEquals(1, ((TableView) results.getTableOrView()).getSourceRowIndex(3));
+        assertEquals(3, results.getCollection().indexOf(1));
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
index 72de604064..92059c90cc 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TestHelper.java
@@ -56,8 +56,8 @@
 import io.realm.entities.PrimaryKeyAsBoxedShort;
 import io.realm.entities.PrimaryKeyAsString;
 import io.realm.entities.StringOnly;
+import io.realm.internal.Collection;
 import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
 import io.realm.internal.async.RealmThreadPoolExecutor;
 import io.realm.log.LogLevel;
 import io.realm.log.RealmLogger;
@@ -847,19 +847,19 @@ public static void quitLooperOrFail() {
      * This helper method is useful to create a mocked {@link RealmResults}.
      *
      * @param realm a {@link Realm} or a {@link DynamicRealm} instance.
-     * @param table a {@link Table} or a {@link io.realm.internal.TableView} instance.
+     * @param collection a {@link Collection} instance.
      * @param tableClass a Class of Table.
      * @return a created {@link RealmResults} instance.
      */
     public static <T extends RealmObject> RealmResults<T> newRealmResults(
-            BaseRealm realm, TableOrView table, Class<T> tableClass) {
+            BaseRealm realm, Collection collection, Class<T> tableClass) {
         //noinspection TryWithIdenticalCatches
         try {
             final Constructor<RealmResults> c = RealmResults.class.getDeclaredConstructor(
-                    BaseRealm.class, TableOrView.class, Class.class);
+                    BaseRealm.class, Collection.class, Class.class);
             c.setAccessible(true);
             //noinspection unchecked
-            return c.newInstance(realm, table, tableClass);
+            return c.newInstance(realm, collection, tableClass);
         } catch (NoSuchMethodException e) {
             throw new RuntimeException(e);
         } catch (InstantiationException e) {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
index 54fb15250f..c219ab9742 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/TypeBasedNotificationsTests.java
@@ -17,8 +17,6 @@
 
 import android.content.Context;
 import android.os.Build;
-import android.os.Handler;
-import android.os.HandlerThread;
 import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 import android.util.Base64;
@@ -26,32 +24,28 @@
 import org.json.JSONException;
 import org.json.JSONObject;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.ref.WeakReference;
 import java.util.Date;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AllTypesPrimaryKey;
-import io.realm.entities.Cat;
 import io.realm.entities.Dog;
-import io.realm.entities.Owner;
 import io.realm.entities.PrimaryKeyAsLong;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
-import io.realm.util.RealmBackgroundTask;
 
 import static org.hamcrest.number.OrderingComparison.greaterThanOrEqualTo;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -486,7 +480,7 @@ public void onChange(AllTypesPrimaryKey object) {
     public void callback_with_relevant_commit_realmobject_sync() {
         final Realm realm = looperThread.realm;
 
-        // Step 1: Triggers global Realm change listener.
+        // Step 1: Creates object
         realm.beginTransaction();
         final Dog akamaru = realm.createObject(Dog.class);
         akamaru.setName("Akamaru");
@@ -497,42 +491,25 @@ public void callback_with_relevant_commit_realmobject_sync() {
         dog.addChangeListener(new RealmChangeListener<Dog>() {
             @Override
             public void onChange(Dog object) {
-                // Step 4: Responds to relevant change.
+                // Step 3: Responds to relevant change.
                 typebasedCommitInvocations.incrementAndGet();
                 assertEquals("Akamaru", dog.getName());
                 assertEquals(17, dog.getAge());
+                looperThread.testComplete();
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
+        // Step 2: Trigger non-related commit
+        realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
-            public void onChange(Realm object) {
-                int commits = globalCommitInvocations.incrementAndGet();
-                switch (commits) {
-                    case 1:
-                        // Step 2: Triggers non-related commit.
-                        realm.beginTransaction();
-                        realm.commitTransaction();
-                        break;
-
-                    case 2:
-                        // Step 3: Triggers related commit.
-                        realm.beginTransaction();
-                        akamaru.setAge(17);
-                        realm.commitTransaction();
-                        break;
-
-                    case 3:
-                        // Step 5: Completes test.
-                        looperThread.postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                assertEquals(1, typebasedCommitInvocations.get());
-                                looperThread.testComplete();
-                            }
-                        });
+            public void execute(Realm realm) {
+            }
+        });
 
-                }
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.where(Dog.class).findFirst().setAge(17);
             }
         });
     }
@@ -543,14 +520,13 @@ public void run() {
     public void callback_with_relevant_commit_realmobject_async() {
         final Realm realm = looperThread.realm;
 
-        // Step 1: Triggers global Realm change listener.
+        // Step 1: Creates object.
         realm.beginTransaction();
         final Dog akamaru = realm.createObject(Dog.class);
         akamaru.setName("Akamaru");
         realm.commitTransaction();
 
         final Dog dog = realm.where(Dog.class).findFirstAsync();
-        assertTrue(dog.load());
 
         looperThread.keepStrongReference.add(dog);
         dog.addChangeListener(new RealmChangeListener<Dog>() {
@@ -558,246 +534,33 @@ public void callback_with_relevant_commit_realmobject_async() {
             public void onChange(Dog object) {
                 switch (typebasedCommitInvocations.incrementAndGet()) {
                     case 1:
+                        // Async query returns.
                         assertEquals("Akamaru", dog.getName());
                         assertEquals(0, dog.getAge());
-                        break;
-
-                    case 2:
-                        // Step 4: Responds to relevant change.
-                        assertEquals(17, dog.getAge());
-                        break;
-                }
-            }
-        });
 
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                int commits = globalCommitInvocations.incrementAndGet();
-                switch (commits) {
-                    case 1:
                         // Step 2: Triggers non-related commit.
-                        realm.beginTransaction();
-                        realm.commitTransaction();
-                        break;
-
-                    case 2:
-                        // Step 3: Triggers related commit.
-                        realm.beginTransaction();
-                        akamaru.setAge(17);
-                        realm.commitTransaction();
-                        break;
-
-                    case 3:
-                        // Step 5: Completes test.
-                        looperThread.postRunnable(new Runnable() {
+                        realm.executeTransactionAsync(new Realm.Transaction() {
                             @Override
-                            public void run() {
-                                assertEquals(3, globalCommitInvocations.get());
-                                assertEquals(2, typebasedCommitInvocations.get());
-                                looperThread.testComplete();
+                            public void execute(Realm realm) {
                             }
                         });
 
-                }
-            }
-        });
-    }
-
-    // UC 1 Async RealmObject.
-    @Test
-    @RunTestInLooperThread
-    public void callback_with_relevant_commit_from_different_looper_realmobject_async() {
-        final CountDownLatch looperThread1Done = new CountDownLatch(1);
-        final CountDownLatch looperThread2Done = new CountDownLatch(1);
-        final CountDownLatch looperThread3Done = new CountDownLatch(1);
-        final HandlerThread looperThread1 = new HandlerThread("looperThread1");
-        final HandlerThread looperThread2 = new HandlerThread("looperThread2");
-        final HandlerThread looperThread3 = new HandlerThread("looperThread3");
-        looperThread1.start();
-        looperThread2.start();
-        looperThread3.start();
-        final Handler looperHandler1 = new Handler(looperThread1.getLooper());
-        final Handler looperHandler2 = new Handler(looperThread2.getLooper());
-        final Handler looperHandler3 = new Handler(looperThread3.getLooper());
-        final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                globalCommitInvocations.incrementAndGet();
-            }
-        });
-
-        final Dog dog = realm.where(Dog.class).findFirstAsync();
-        assertTrue(dog.load());
-        looperThread.keepStrongReference.add(dog);
-        dog.addChangeListener(new RealmChangeListener<Dog>() {
-            @Override
-            public void onChange(Dog object) {
-                switch (typebasedCommitInvocations.incrementAndGet()) {
-                    case 1: // Triggered by COMPLETED_ASYNC_REALM_OBJECT from calling dog.load().
-                        assertTrue(dog.isLoaded());
-                        assertFalse(dog.isValid());
-
-                        looperHandler1.post(new Runnable() {
-                            @Override
-                            public void run() {
-                                Realm realmLooperThread1 = Realm.getInstance(realm.getConfiguration());
-                                realmLooperThread1.beginTransaction();
-                                realmLooperThread1.commitTransaction();
-                                realmLooperThread1.close();
-                                looperThread1Done.countDown();
-                            }
-                        });
-                        break;
-                    case 2: // Triggered by the irrelevant commit (not affecting Dog table) from LooperThread1.
-                        assertTrue(dog.isLoaded());
-                        assertFalse(dog.isValid());
-
-                        looperHandler2.post(new Runnable() {
-                            @Override
-                            public void run() {
-                                Realm realmLooperThread2 = Realm.getInstance(realm.getConfiguration());
-                                // Triggers first callback invocation.
-                                realmLooperThread2.beginTransaction();
-                                Dog dog = realmLooperThread2.createObject(Dog.class);
-                                dog.setName("Akamaru");
-                                realmLooperThread2.commitTransaction();
-                                realmLooperThread2.close();
-                                looperThread2Done.countDown();
-                            }
-                        });
-                        break;
-
-                    case 3: // Triggered by relevant commit from LooperThread2.
-                        assertEquals("Akamaru", dog.getName());
-                        looperThread.postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                // Triggers second callback invocation.
-                                looperHandler3.post(new Runnable() {
-                                    @Override
-                                    public void run() {
-                                        Realm realmLooperThread3 = Realm.getInstance(realm.getConfiguration());
-                                        realmLooperThread3.beginTransaction();
-                                        realmLooperThread3.where(Dog.class).findFirst().setAge(17);
-                                        realmLooperThread3.commitTransaction();
-                                        realmLooperThread3.close();
-                                        looperThread3Done.countDown();
-                                    }
-                                });
-                            }
-                        });
-                        break;
-                    case 4:
-                        assertEquals("Akamaru", dog.getName());
-                        assertEquals(17, dog.getAge());
-                        // Posting as an event will give the handler a chance
-                        // to deliver the notification for globalCommitInvocations.
-                        // Otherwise, test will exit before the callback get a chance to be invoked.
-                        looperThread.postRunnable(new Runnable() {
+                        // Step 3: Triggers related commit.
+                        realm.executeTransactionAsync(new Realm.Transaction() {
                             @Override
-                            public void run() {
-                                assertEquals(3, globalCommitInvocations.get());
-                                assertEquals(4, typebasedCommitInvocations.get());
-                                looperThread1.quit();
-                                looperThread2.quit();
-                                looperThread3.quit();
-                                TestHelper.awaitOrFail(looperThread1Done);
-                                TestHelper.awaitOrFail(looperThread2Done);
-                                TestHelper.awaitOrFail(looperThread3Done);
-                                looperThread.testComplete();
+                            public void execute(Realm realm) {
+                                realm.where(Dog.class).findFirst().setAge(17);
                             }
                         });
                         break;
-                }
-            }
-        });
-
-    }
-
-    // UC 1 Async RealmObject.
-    @Test
-    @RunTestInLooperThread
-    public void callback_with_relevant_commit_from_different_non_looper_realmobject_async() throws Throwable {
-        final CountDownLatch nonLooperThread3CloseLatch = new CountDownLatch(1);
-        final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                globalCommitInvocations.incrementAndGet();
-            }
-        });
-
-        final Dog dog = realm.where(Dog.class).findFirstAsync();
-        assertTrue(dog.load());
-        looperThread.keepStrongReference.add(dog);
-        dog.addChangeListener(new RealmChangeListener<Dog>() {
-            @Override
-            public void onChange(Dog object) {
-                switch (typebasedCommitInvocations.incrementAndGet()) {
-                    case 1:  // Triggered by COMPLETED_ASYNC_REALM_OBJECT.
-                        new RealmBackgroundTask(realm.configuration) {
-                            @Override
-                            protected void doInBackground(Realm realm) {
-                                realm.beginTransaction();
-                                realm.commitTransaction();
-                            }
-                        }.awaitOrFail();
-                        break;
-
-                    case 2: {// Triggered by the irrelevant commit (not affecting Dog table).
-                        assertTrue(dog.isLoaded());
-                        assertFalse(dog.isValid());
-                        new RealmBackgroundTask(realm.configuration) {
-                            @Override
-                            protected void doInBackground(Realm realm) {
-                                realm.beginTransaction();
-                                realm.createObject(Dog.class).setName("Akamaru");
-                                realm.commitTransaction();
 
-                            }
-                        }.awaitOrFail();
-                        break;
-                    }
-                    case 3: {
-                        assertEquals("Akamaru", dog.getName());
-                        looperThread.postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                // Triggers second callback invocation.
-                                new Thread() {
-                                    @Override
-                                    public void run() {
-                                        Realm realmNonLooperThread3 = Realm.getInstance(realm.getConfiguration());
-                                        realmNonLooperThread3.beginTransaction();
-                                        realmNonLooperThread3.where(Dog.class).findFirst().setAge(17);
-                                        realmNonLooperThread3.commitTransaction();
-                                        realmNonLooperThread3.close();
-                                        nonLooperThread3CloseLatch.countDown();
-                                    }
-                                }.start();
-                            }
-                        });
-                        break;
-                    }
-                    case 4: {
-                        assertEquals("Akamaru", dog.getName());
+                    case 2:
+                        // Step 4: Responds to relevant change.
                         assertEquals(17, dog.getAge());
-                        // Posting as an event will give the handler a chance
-                        // to deliver the notification for globalCommitInvocations.
-                        // Otherwise, test will exit before the callback get a chance to be invoked.
-                        looperThread.postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                assertEquals(3, globalCommitInvocations.get());
-                                assertEquals(4, typebasedCommitInvocations.get());
-                                TestHelper.awaitOrFail(nonLooperThread3CloseLatch);
-                                looperThread.testComplete();
-                            }
-                        });
+                        looperThread.testComplete();
                         break;
-                    }
+                    default:
+                        fail();
                 }
             }
         });
@@ -809,7 +572,7 @@ public void run() {
     public void callback_with_relevant_commit_realmresults_sync() {
         final Realm realm = looperThread.realm;
 
-        // Step 1: Triggers global Realm change listener.
+        // Step 1: Creates object.
         realm.beginTransaction();
         final Dog akamaru = realm.createObject(Dog.class);
         akamaru.setName("Akamaru");
@@ -825,37 +588,22 @@ public void onChange(RealmResults<Dog> object) {
                 assertEquals(1, dogs.size());
                 assertEquals("Akamaru", dogs.get(0).getName());
                 assertEquals(17, dogs.get(0).getAge());
+                looperThread.testComplete();
             }
         });
 
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
+        // Step 2: Trigger non-related commit. If this triggered the results listener, assertion will happen there.
+        realm.executeTransactionAsync(new Realm.Transaction() {
             @Override
-            public void onChange(Realm object) {
-                int commits = globalCommitInvocations.incrementAndGet();
-                switch (commits) {
-                    case 1:
-                        // Step 2: Triggers non-related commit.
-                        realm.beginTransaction();
-                        realm.commitTransaction();
-                        break;
-
-                    case 2:
-                        // Step 3: Triggers related commit.
-                        realm.beginTransaction();
-                        akamaru.setAge(17);
-                        realm.commitTransaction();
-                        break;
+            public void execute(Realm realm) {
+            }
+        });
 
-                    case 3:
-                        // Step 5: Completes test.
-                        looperThread.postRunnable(new Runnable() {
-                            @Override
-                            public void run() {
-                                assertEquals(1, typebasedCommitInvocations.get());
-                                looperThread.testComplete();
-                            }
-                        });
-                }
+        // Step 3: Triggers related commit.
+        realm.executeTransactionAsync(new Realm.Transaction() {
+            @Override
+            public void execute(Realm realm) {
+                realm.where(Dog.class).findFirst().setAge(17);
             }
         });
     }
@@ -866,14 +614,13 @@ public void run() {
     public void callback_with_relevant_commit_realmresults_async() {
         final Realm realm = looperThread.realm;
 
-        // Step 1: Triggers global Realm change listener.
+        // Step 1: Creates object.
         realm.beginTransaction();
         final Dog akamaru = realm.createObject(Dog.class);
         akamaru.setName("Akamaru");
         realm.commitTransaction();
 
         final RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
-        assertTrue(dogs.load());
         looperThread.keepStrongReference.add(dogs);
         dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
             @Override
@@ -881,43 +628,32 @@ public void onChange(RealmResults<Dog> object) {
                 // Step 4: Responds to relevant change.
                 int commits = typebasedCommitInvocations.incrementAndGet();
                 switch (commits) {
-                    case 2:
-                        assertEquals(17, dogs.get(0).getAge());
                     case 1:
+                        // Async query returns.
                         assertEquals(1, dogs.size());
                         assertEquals("Akamaru", dogs.get(0).getName());
+                        // Step 2: Trigger non-related commit. If this triggered the results listener,
+                        // assertion will happen there.
+                        realm.executeTransactionAsync(new Realm.Transaction() {
+                            @Override
+                            public void execute(Realm realm) {
+                            }
+                        });
 
-                }
-            }
-        });
-
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                int commits = globalCommitInvocations.incrementAndGet();
-                switch (commits) {
-                    case 1:
-                        // Step 2: Triggers non-related commit.
-                        realm.beginTransaction();
-                        realm.commitTransaction();
-                        break;
-
-                    case 2:
                         // Step 3: Triggers related commit.
-                        realm.beginTransaction();
-                        akamaru.setAge(17);
-                        realm.commitTransaction();
-                        break;
-
-                    case 3:
-                        // Step 5: Completes test.
-                        looperThread.postRunnable(new Runnable() {
+                        realm.executeTransactionAsync(new Realm.Transaction() {
                             @Override
-                            public void run() {
-                                assertEquals(2, typebasedCommitInvocations.get());
-                                looperThread.testComplete();
+                            public void execute(Realm realm) {
+                                realm.where(Dog.class).findFirst().setAge(17);
                             }
                         });
+                        break;
+                    case 2:
+                        assertEquals(17, dogs.get(0).getAge());
+                        looperThread.testComplete();
+                        break;
+                    default:
+                        fail();
                 }
             }
         });
@@ -1014,18 +750,6 @@ public void onChange(Dog object) {
     public void multiple_callbacks_should_be_invoked_realmresults_sync() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
-        realm.addChangeListener(new RealmChangeListener<Realm>() {
-            @Override
-            public void onChange(Realm object) {
-                looperThread.postRunnable(new Runnable() {
-                    @Override
-                    public void run() {
-                        assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
-                        looperThread.testComplete();
-                    }
-                });
-            }
-        });
 
         realm.beginTransaction();
         Dog akamaru = realm.createObject(Dog.class);
@@ -1036,8 +760,12 @@ public void run() {
         for (int i = 0; i < NUMBER_OF_LISTENERS; i++) {
             dogs.addChangeListener(new RealmChangeListener<RealmResults<Dog>>() {
                 @Override
-                public void onChange(RealmResults<Dog> object) {
-                    typebasedCommitInvocations.incrementAndGet();
+                public void onChange(RealmResults<Dog> results) {
+                    assertEquals(17, results.first().getAge());
+                    if (typebasedCommitInvocations.incrementAndGet() == NUMBER_OF_LISTENERS) {
+                        looperThread.testComplete();
+                    }
+                    assertTrue(typebasedCommitInvocations.get() <= NUMBER_OF_LISTENERS);
                 }
             });
         }
@@ -1053,23 +781,24 @@ public void onChange(RealmResults<Dog> object) {
     public void multiple_callbacks_should_be_invoked_realmresults_async() {
         final int NUMBER_OF_LISTENERS = 7;
         final Realm realm = looperThread.realm;
+
+        realm.beginTransaction();
+        Dog akamaru = realm.createObject(Dog.class);
+        realm.commitTransaction();
+
         realm.addChangeListener(new RealmChangeListener<Realm>() {
             @Override
             public void onChange(Realm object) {
-                looperThread.postRunnable(new Runnable() {
+                looperThread.postRunnableDelayed(new Runnable() {
                     @Override
                     public void run() {
                         assertEquals(NUMBER_OF_LISTENERS, typebasedCommitInvocations.get());
                         looperThread.testComplete();
                     }
-                });
+                }, 100L /* wait for listeners in RealmResults. Next run loop is not enough. */);
             }
         });
 
-        realm.beginTransaction();
-        Dog akamaru = realm.createObject(Dog.class);
-        realm.commitTransaction();
-
         RealmResults<Dog> dogs = realm.where(Dog.class).findAllAsync();
         assertTrue(dogs.load());
 
@@ -1426,46 +1155,7 @@ public void onChange(RealmResults<Dog> object) {
         TestHelper.awaitOrFail(signalTestFinished);
     }
 
-    // Tests modifying syncRealmResults in RealmResults's change listener.
-    @Test
-    @RunTestInLooperThread
-    public void change_realm_results_map_in_listener() throws InterruptedException {
-        final CountDownLatch finishedLatch = new CountDownLatch(2);
-
-        final Realm realm = looperThread.realm;
-        // Two results needed to make sure list modification happen while iterating.
-        RealmResults<Owner> results1 = realm.where(Owner.class).findAll();
-        RealmResults<Cat> results2 = realm.where(Cat.class).findAll();
-        RealmChangeListener listener = new RealmChangeListener() {
-            @Override
-            public void onChange(Object object) {
-                RealmResults<Owner> results = realm.where(Owner.class).findAll();
-                boolean foundKey = false;
-                // Checks if the results has been added to the syncRealmResults in case of the behaviour of
-                // allObjects changes.
-                for (WeakReference<RealmResults<? extends RealmModel>> weakReference :
-                        realm.handlerController.syncRealmResults.keySet()) {
-                    if (weakReference.get() == results) {
-                        foundKey = true;
-                        break;
-                    }
-                }
-                assertTrue(foundKey);
-                looperThread.testComplete();
-                finishedLatch.countDown();
-            }
-        };
-        looperThread.keepStrongReference.add(results1);
-        looperThread.keepStrongReference.add(results2);
-        results1.addChangeListener(listener);
-        results2.addChangeListener(listener);
-
-        realm.beginTransaction();
-        realm.createObject(Owner.class);
-        realm.commitTransaction();
-    }
-
-    // Builds a RealmResults from a RealmList, and deletes the RealmList. Tests the behavior of ChangeListener on the
+    // Builds a RealmResults from a RealmList, and delete the RealmList. Test the behavior of ChangeListener on the
     // "invalid" RealmResults.
     @Test
     @RunTestInLooperThread
diff --git a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
index 20df1cb38a..e45adfa721 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/UnManagedOrderedRealmCollectionTests.java
@@ -153,6 +153,7 @@ public void unsupportedMethods_unManagedCollections() {
                     case SORT_FIELD: collection.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING); break;
                     case SORT_2FIELDS: collection.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING, AllJavaTypes.FIELD_LONG, Sort.DESCENDING); break;
                     case SORT_MULTI: collection.sort(new String[] { AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_LONG }, new Sort[] { Sort.ASCENDING, Sort.DESCENDING }); break;
+                    case CREATE_SNAPSHOT: collection.createSnapshot();
                 }
                 fail(method + " should have thrown an exception.");
             } catch (UnsupportedOperationException ignored) {
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueFromOtherConstructor.java
similarity index 50%
rename from realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java
rename to realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueFromOtherConstructor.java
index a4af906d3b..3ce4078ad8 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmAction.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/entities/DefaultValueFromOtherConstructor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2016 Realm Inc.
+ * Copyright 2017 Realm Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,22 +14,26 @@
  * limitations under the License.
  */
 
-package io.realm.internal.objectserver;
+package io.realm.entities;
 
-import io.realm.ObjectServerError;
-import io.realm.SyncSession;
+import io.realm.RealmObject;
 
-/**
- * As {@link SyncSession} is modeled as a state machine, this interface describe all
- * possible actions in that machine.
- * <p>
- * All states should implement this interface so all possible permutations of state/actions are covered.
- *
- */
-interface FsmAction {
-    void onStart();
-    void onBind();
-    void onUnbind();
-    void onStop();
-    void onError(ObjectServerError error);
+public class DefaultValueFromOtherConstructor extends RealmObject {
+
+    public static final String CLASS_NAME = "DefaultValueOfField";
+    public static String FIELD_LONG = "fieldLong";
+
+    private long fieldLong;
+
+    public DefaultValueFromOtherConstructor() {
+        this(42);
+    }
+
+    public DefaultValueFromOtherConstructor(long fieldLong) {
+        this.fieldLong = fieldLong;
+    }
+
+    public long getFieldLong() {
+        return fieldLong;
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
new file mode 100644
index 0000000000..e63fd0fb1a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/CollectionTests.java
@@ -0,0 +1,520 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.lang.ref.WeakReference;
+import java.util.ConcurrentModificationException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.RealmChangeListener;
+import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
+import io.realm.TestHelper;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+
+@RunWith(AndroidJUnit4.class)
+public class CollectionTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private RealmConfiguration config;
+    private SharedRealm sharedRealm;
+    private Table table;
+
+    @Before
+    public void setUp() {
+        config = configFactory.createConfiguration();
+        sharedRealm = getSharedRealm();
+        populateData();
+    }
+
+    @After
+    public void tearDown() {
+        sharedRealm.close();
+    }
+
+    private SharedRealm getSharedRealm() {
+        return SharedRealm.getInstance(config, null, true);
+    }
+
+    private void populateData() {
+        sharedRealm.beginTransaction();
+        table = sharedRealm.getTable("test_table");
+        // Specify the column types and names
+        long columnIdx = table.addColumn(RealmFieldType.STRING, "firstName");
+        table.addSearchIndex(columnIdx);
+        table.addColumn(RealmFieldType.STRING, "lastName");
+        table.addColumn(RealmFieldType.INTEGER, "age");
+
+        // Add data to the table
+        long row = table.addEmptyRow();
+        table.setString(0, row, "John", false);
+        table.setString(1, row, "Lee", false);
+        table.setLong(2, row, 4, false);
+
+        row = table.addEmptyRow();
+        table.setString(0, row, "John", false);
+        table.setString(1, row, "Anderson", false);
+        table.setLong(2, row, 3, false);
+
+        row = table.addEmptyRow();
+        table.setString(0, row, "Erik", false);
+        table.setString(1, row, "Lee", false);
+        table.setLong(2, row, 1, false);
+
+        row = table.addEmptyRow();
+        table.setString(0, row, "Henry", false);
+        table.setString(1, row, "Anderson", false);
+        table.setLong(2, row, 1, false);
+        sharedRealm.commitTransaction();
+    }
+
+    private void addRowAsync() {
+        final CountDownLatch latch = new CountDownLatch(1);
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                SharedRealm sharedRealm = getSharedRealm();
+                addRow(sharedRealm);
+                sharedRealm.close();
+                latch.countDown();
+            }
+        }).start();
+        TestHelper.awaitOrFail(latch);
+    }
+
+    private void addRow(SharedRealm sharedRealm) {
+        sharedRealm.beginTransaction();
+        table = sharedRealm.getTable("test_table");
+        table.addEmptyRow();
+        sharedRealm.commitTransaction();
+    }
+
+    @Test
+    public void constructor_withDistinct() {
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(table, "firstName");
+        Collection collection = new Collection(sharedRealm, table.where(), null, distinctDescriptor);
+
+        assertEquals(collection.size(), 3);
+        assertEquals(collection.getUncheckedRow(0).getString(0), "John");
+        assertEquals(collection.getUncheckedRow(1).getString(0), "Erik");
+        assertEquals(collection.getUncheckedRow(2).getString(0), "Henry");
+    }
+
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void constructor_queryIsValidated() {
+        // Collection's constructor should call TableQuery.validateQuery()
+        new Collection(sharedRealm, table.where().or());
+    }
+
+    @Test
+    public void constructor_queryOnDeletedTable() {
+        TableQuery query = table.where();
+        sharedRealm.beginTransaction();
+        sharedRealm.removeTable(table.getName());
+        sharedRealm.commitTransaction();
+        // Query should be checked before creating OS Results.
+        thrown.expect(IllegalStateException.class);
+        new Collection(sharedRealm, query);
+    }
+
+    @Test
+    public void size() {
+        Collection collection = new Collection(sharedRealm, table.where());
+        assertEquals(4, collection.size());
+    }
+
+    @Test
+    public void where() {
+        Collection collection = new Collection(sharedRealm, table.where());
+        Collection collection2 = new Collection(sharedRealm, collection.where().equalTo(new long[]{0}, "John"));
+        Collection collection3 =new Collection(sharedRealm, collection2.where().equalTo(new long[]{1}, "Anderson"));
+
+        // A new native Results should be created.
+        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
+        assertTrue(collection2.getNativePtr() != collection3.getNativePtr());
+
+        assertEquals(4, collection.size());
+        assertEquals(2, collection2.size());
+        assertEquals(1, collection3.size());
+    }
+
+    @Test
+    public void sort() {
+        Collection collection = new Collection(sharedRealm, table.where().greaterThan(new long[]{2}, 1));
+        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
+
+        Collection collection2 = collection.sort(sortDescriptor);
+
+        // A new native Results should be created.
+        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
+        assertEquals(2, collection.size());
+        assertEquals(2, collection2.size());
+
+        assertEquals(collection2.getUncheckedRow(0).getLong(2), 3);
+        assertEquals(collection2.getUncheckedRow(1).getLong(2), 4);
+    }
+
+    @Test
+    public void clear() {
+        assertEquals(table.size(), 4);
+        Collection collection = new Collection(sharedRealm, table.where());
+        sharedRealm.beginTransaction();
+        collection.clear();
+        sharedRealm.commitTransaction();
+        assertEquals(table.size(), 0);
+    }
+
+    @Test
+    public void contains() {
+        Collection collection = new Collection(sharedRealm, table.where());
+        UncheckedRow row = table.getUncheckedRow(0);
+        assertTrue(collection.contains(row));
+    }
+
+    @Test
+    public void indexOf() {
+        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
+
+        Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
+        UncheckedRow row = table.getUncheckedRow(0);
+        assertEquals(collection.indexOf(row), 3);
+    }
+
+    @Test
+    public void indexOf_long() {
+        SortDescriptor sortDescriptor = new SortDescriptor(table, new long[] {2});
+
+        Collection collection = new Collection(sharedRealm, table.where(), sortDescriptor);
+        assertEquals(collection.indexOf(0), 3);
+    }
+
+    @Test
+    public void distinct() {
+        Collection collection = new Collection(sharedRealm, table.where().lessThan(new long[]{2}, 4));
+
+        SortDescriptor distinctDescriptor = new SortDescriptor(table, new long[] {2});
+        Collection collection2 = collection.distinct(distinctDescriptor);
+
+        // A new native Results should be created.
+        assertTrue(collection.getNativePtr() != collection2.getNativePtr());
+        assertEquals(3, collection.size());
+        assertEquals(2, collection2.size());
+
+        assertEquals(collection2.getUncheckedRow(0).getLong(2), 3);
+        assertEquals(collection2.getUncheckedRow(1).getLong(2), 1);
+    }
+
+    // 1. Create a results and add listener.
+    // 2. Query results should be returned in the next loop.
+    @Test
+    @RunTestInLooperThread
+    public void addListener_shouldBeCalledToReturnTheQueryResults() {
+        final SharedRealm sharedRealm = getSharedRealm();
+        Table table = sharedRealm.getTable("test_table");
+
+        final Collection collection = new Collection(sharedRealm, table.where());
+        looperThread.keepStrongReference.add(collection);
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection collection1) {
+                assertEquals(collection1, collection);
+                assertEquals(collection1.size(), 4);
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // 1. Create a results and add listener on a non-looper thread.
+    // 2. Query results should be returned when refresh() called.
+    @Test
+    public void addListener_shouldBeCalledWhenRefreshToReturnTheQueryResults() {
+        final AtomicBoolean onChangeCalled = new AtomicBoolean(false);
+        final SharedRealm sharedRealm = getSharedRealm();
+        Table table = sharedRealm.getTable("test_table");
+
+        final Collection collection = new Collection(sharedRealm, table.where());
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection collection1) {
+                assertEquals(collection1, collection);
+                assertEquals(collection1.size(), 4);
+                sharedRealm.close();
+                onChangeCalled.set(true);
+            }
+        });
+        sharedRealm.refresh();
+        assertTrue(onChangeCalled.get());
+    }
+
+    @Test
+    public void addListener_shouldBeCalledWhenRefreshAfterLocalCommit() {
+        final CountDownLatch latch = new CountDownLatch(2);
+        final Collection collection = new Collection(sharedRealm, table.where());
+        assertEquals(4, collection.size()); // See `populateData()`
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection element) {
+                if (latch.getCount() == 2) {
+                    // triggered by beginTransaction
+                    assertEquals(4, collection.size());
+                } else if (latch.getCount() == 1) {
+                    // triggered by refresh
+                    assertEquals(5, collection.size());
+                } else {
+                    fail();
+                }
+                latch.countDown();
+            }
+        });
+        sharedRealm.beginTransaction();
+        table.addEmptyRow();
+        sharedRealm.commitTransaction();
+        sharedRealm.refresh();
+        TestHelper.awaitOrFail(latch);
+    }
+
+    // Local commit will trigger the listener first when beginTransaction gets called then again when call refresh.
+    @Test
+    public void addListener_triggeredByRefresh() {
+        final CountDownLatch latch = new CountDownLatch(1);
+        Collection collection = new Collection(sharedRealm, table.where());
+        collection.size();
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection element) {
+                assertEquals(latch.getCount(), 1);
+                latch.countDown();
+            }
+        });
+
+        addRowAsync();
+
+        sharedRealm.waitForChange();
+        sharedRealm.refresh();
+        TestHelper.awaitOrFail(latch);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addListener_queryNotReturned() {
+        final SharedRealm sharedRealm = getSharedRealm();
+        Table table = sharedRealm.getTable("test_table");
+
+        final Collection collection = new Collection(sharedRealm, table.where());
+        looperThread.keepStrongReference.add(collection);
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection collection1) {
+                assertEquals(collection1, collection);
+                assertEquals(collection1.size(), 5);
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        addRowAsync();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addListener_queryReturned() {
+        final SharedRealm sharedRealm = getSharedRealm();
+        Table table = sharedRealm.getTable("test_table");
+
+        final Collection collection = new Collection(sharedRealm, table.where());
+        looperThread.keepStrongReference.add(collection);
+        assertEquals(collection.size(), 4); // Trigger the query to run.
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection collection1) {
+                assertEquals(collection1, collection);
+                assertEquals(collection1.size(), 5);
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        addRowAsync();
+    }
+
+    // Local commit will trigger the listener first when beginTransaction gets called then again in the next event loop.
+    @Test
+    @RunTestInLooperThread
+    public void addListener_triggeredByLocalCommit() {
+        final SharedRealm sharedRealm = getSharedRealm();
+        Table table = sharedRealm.getTable("test_table");
+        final AtomicInteger listenerCounter = new AtomicInteger(0);
+
+        final Collection collection = new Collection(sharedRealm, table.where());
+        looperThread.keepStrongReference.add(collection);
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection collection1) {
+                switch (listenerCounter.getAndIncrement()) {
+                    case 0:
+                        assertEquals(collection1.size(), 4);
+                        break;
+                    case 1:
+                        assertEquals(collection1.size(), 5);
+                        sharedRealm.close();
+                        looperThread.testComplete();
+                        break;
+                }
+            }
+        });
+        addRow(sharedRealm);
+        assertEquals(collection.size(), 5);
+    }
+
+    private static class TestIterator extends Collection.Iterator<Integer> {
+        TestIterator(Collection collection) {
+            super(collection);
+        }
+
+        @Override
+        protected Integer convertRowToObject(UncheckedRow row) {
+            return null;
+        }
+
+        boolean isDetached(SharedRealm sharedRealm) {
+            for (WeakReference<Collection.Iterator> iteratorRef : sharedRealm.iterators) {
+                Collection.Iterator iterator = iteratorRef.get();
+                if (iterator == this) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    @Test
+    public void collectionIterator_detach_byBeginTransaction() {
+        final Collection collection = new Collection(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(collection);
+        assertFalse(iterator.isDetached(sharedRealm));
+        sharedRealm.beginTransaction();
+        assertTrue(iterator.isDetached(sharedRealm));
+        sharedRealm.commitTransaction();
+        assertTrue(iterator.isDetached(sharedRealm));
+    }
+
+    @Test
+    public void collectionIterator_detach_createdInTransaction() {
+        sharedRealm.beginTransaction();
+        final Collection collection = new Collection(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(collection);
+        assertTrue(iterator.isDetached(sharedRealm));
+    }
+
+    @Test
+    public void collectionIterator_invalid_nonLooperThread_byRefresh() {
+        final Collection collection = new Collection(sharedRealm, table.where());
+        TestIterator iterator = new TestIterator(collection);
+        assertFalse(iterator.isDetached(sharedRealm));
+        sharedRealm.refresh();
+        thrown.expect(ConcurrentModificationException.class);
+        iterator.checkValid();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void collectionIterator_invalid_looperThread_byRemoteTransaction() {
+        final SharedRealm sharedRealm = getSharedRealm();
+        Table table = sharedRealm.getTable("test_table");
+        final Collection collection = new Collection(sharedRealm, table.where());
+        final TestIterator iterator = new TestIterator(collection);
+        looperThread.keepStrongReference.add(collection);
+        assertFalse(iterator.isDetached(sharedRealm));
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection element) {
+                try {
+                    iterator.checkValid();
+                    fail();
+                } catch (ConcurrentModificationException ignored) {
+                }
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        addRowAsync();
+    }
+
+    @Test
+    public void getMode() {
+        Collection collection = new Collection(sharedRealm, table.where());
+        assertTrue(Collection.Mode.QUERY == collection.getMode());
+        collection.firstUncheckedRow(); // Run the query
+        assertTrue(Collection.Mode.TABLEVIEW == collection.getMode());
+    }
+
+    @Test
+    public void createSnapshot() {
+        Collection collection = new Collection(sharedRealm, table.where());
+        Collection snapshot = collection.createSnapshot();
+        assertTrue(Collection.Mode.TABLEVIEW == snapshot.getMode());
+        thrown.expect(IllegalStateException.class);
+        snapshot.addListener(snapshot, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection element) {
+            }
+        });
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void load() {
+        final Collection collection = new Collection(sharedRealm, table.where());
+        collection.addListener(collection, new RealmChangeListener<Collection>() {
+            @Override
+            public void onChange(Collection element) {
+                assertTrue(collection.isLoaded());
+                looperThread.testComplete();
+            }
+        });
+        assertFalse(collection.isLoaded());
+        collection.load();
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
index 30c64ac29c..a44043f00b 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIColumnInfoTest.java
@@ -16,8 +16,11 @@
 
 package io.realm.internal;
 
+import android.support.test.InstrumentationRegistry;
+
 import junit.framework.TestCase;
 
+import io.realm.Realm;
 import io.realm.RealmFieldType;
 
 public class JNIColumnInfoTest extends TestCase {
@@ -26,6 +29,7 @@
 
     @Override
     public void setUp() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
         table = new Table();
         table.addColumn(RealmFieldType.STRING, "firstName");
         table.addColumn(RealmFieldType.STRING, "lastName");
@@ -45,15 +49,13 @@ public void testShouldGetColumnInformation() {
 
     public void testValidateColumnInfo() {
 
-        TableView view = table.where().findAll();
-
-        assertEquals(2, view.getColumnCount());
+        assertEquals(2, table.getColumnCount());
 
-        assertEquals("lastName", view.getColumnName(1));
+        assertEquals("lastName", table.getColumnName(1));
 
-        assertEquals(1, view.getColumnIndex("lastName"));
+        assertEquals(1, table.getColumnIndex("lastName"));
 
-        assertEquals(RealmFieldType.STRING, view.getColumnType(1));
+        assertEquals(RealmFieldType.STRING, table.getColumnType(1));
 
     }
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
deleted file mode 100644
index 1759b9d8c4..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIDistinctTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-// TODO: Check that Index can be set on multiple columns.
-
-import junit.framework.TestCase;
-
-import io.realm.RealmFieldType;
-
-@SuppressWarnings("unused")
-public class JNIDistinctTest extends TestCase {
-    Table table;
-
-    void init() {
-        table = new Table();
-        table.addColumn(RealmFieldType.INTEGER, "number");
-        table.addColumn(RealmFieldType.STRING, "name");
-
-        long i = 0;
-        table.add(0, "A");
-        table.add(1, "B");
-        table.add(2, "C");
-        table.add(3, "B");
-        table.add(4, "D");
-        table.add(5, "D");
-        table.add(6, "D");
-        assertEquals(7, table.size());
-    }
-
-    public void testShouldTestDistinct() {
-        init();
-
-        // Must set index before using distinct()
-        table.addSearchIndex(1);
-        assertEquals(true, table.hasSearchIndex(1));
-
-        TableView view = table.getDistinctView(1);
-        assertEquals(4, view.size());
-        assertEquals(0, view.getLong(0, 0));
-        assertEquals(1, view.getLong(0, 1));
-        assertEquals(2, view.getLong(0, 2));
-        assertEquals(4, view.getLong(0, 3));
-    }
-
-    public void testShouldTestDistinctErrorWhenNoIndex() {
-        init();
-        try {
-            TableView view = table.getDistinctView(1);
-            fail();
-        } catch (UnsupportedOperationException e) {
-            assertNotNull(e);
-        }
-    }
-
-    public void testShouldTestDistinctErrorWhenIndexOutOfBounds() {
-        init();
-        try {
-            TableView view = table.getDistinctView(3);
-            fail();
-        } catch (Exception e) {
-            assertNotNull(e);
-        }
-    }
-
-    public void testShouldTestDistinctErrorWhenWrongColumnType() {
-        init();
-        table.addSearchIndex(1);
-        try {
-            TableView view = table.getDistinctView(0);
-            fail();
-        } catch (Exception e) {
-            assertNotNull(e);
-        }
-    }
-
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
index e7d133b948..7f9042057d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIQueryTest.java
@@ -16,12 +16,15 @@
 
 package io.realm.internal;
 
+import android.support.test.InstrumentationRegistry;
+
 import junit.framework.TestCase;
 
 import java.util.Date;
 import java.util.concurrent.TimeUnit;
 
 import io.realm.Case;
+import io.realm.Realm;
 import io.realm.RealmFieldType;
 import io.realm.TestHelper;
 
@@ -29,6 +32,12 @@
 
     Table table;
 
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
+    }
+
     void init() {
         table = new Table();
         table.addColumn(RealmFieldType.INTEGER, "number");
@@ -70,38 +79,24 @@ public void testNonCompleteQuery() {
         init();
 
         // All the following queries are not valid, e.g contain a group but not a closing group, an or() but not a second filter etc
-        try { table.where().equalTo(new long[]{0}, 1).or().findAll();       fail("missing a second filter"); }      catch (UnsupportedOperationException ignore) {}
-        try { table.where().or().findAll();                                 fail("just an or()"); }                 catch (UnsupportedOperationException ignore) {}
-        try { table.where().group().equalTo(new long[]{0}, 1).findAll();    fail("missing a closing group"); }      catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, 1).or().validateQuery();       fail("missing a second filter"); }      catch (UnsupportedOperationException ignore) {}
+        try { table.where().or().validateQuery();                                 fail("just an or()"); }                 catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().equalTo(new long[]{0}, 1).validateQuery();    fail("missing a closing group"); }      catch (UnsupportedOperationException ignore) {}
 
         try { table.where().group().count();                                fail(); }                               catch (UnsupportedOperationException ignore) {}
-        try { table.where().group().findAll();                              fail(); }                               catch (UnsupportedOperationException ignore) {}
+        try { table.where().group().validateQuery();                              fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().find();                                 fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().minimumInt(0);                          fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().maximumInt(0);                          fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().sumInt(0);                              fail(); }                               catch (UnsupportedOperationException ignore) {}
         try { table.where().group().averageInt(0);                          fail(); }                               catch (UnsupportedOperationException ignore) {}
 
-        try { table.where().endGroup().equalTo(new long[]{0}, 1).findAll(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().findAll(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().endGroup().equalTo(new long[]{0}, 1).validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
+        try { table.where().equalTo(new long[]{0}, 1).endGroup().validateQuery(); fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
 
         try { table.where().equalTo(new long[]{0}, 1).endGroup().find();    fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
         try { table.where().equalTo(new long[]{0}, 1).endGroup().find(0);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
         try { table.where().equalTo(new long[]{0}, 1).endGroup().find(1);   fail("ends group, no start"); }         catch (UnsupportedOperationException ignore) {}
-
-        try { table.where().equalTo(new long[]{0}, 1).endGroup().findAll(0, -1, -1); fail("ends group, no start"); } catch (UnsupportedOperationException ignore) {}
-
-
-
-        // step by step buildup
-        TableQuery q = table.where().equalTo(new long[]{0}, 1); // valid
-        q.findAll();
-        q.or();                                                 // not valid
-        try { q.findAll();     fail("no start group"); }         catch (UnsupportedOperationException ignore) { }
-        q.equalTo(new long[]{0}, 100);                          // valid again
-        q.findAll();
-        q.equalTo(new long[]{0}, 200);                          // still valid
-        q.findAll();
     }
 
     public void testInvalidColumnIndexEqualTo() {
@@ -109,45 +104,45 @@ public void testInvalidColumnIndexEqualTo() {
         TableQuery query = table.where();
 
         // Boolean
-        try { query.equalTo(new long[]{-1}, true).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, true).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, true).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, true); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, true);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, true); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Date
-        try { query.equalTo(new long[]{-1}, new Date()).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, new Date()).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, new Date()).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.equalTo(new long[]{-1}, 4.5d).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 4.5d).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 4.5d).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.equalTo(new long[]{-1}, 1.4f).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 1.4f).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 1.4f).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.equalTo(new long[]{-1}, 1).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, 1).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, 1).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String
-        try { query.equalTo(new long[]{-1}, "a").findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a").findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a").findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.equalTo(new long[]{-1}, "a", Case.SENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a", Case.SENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a", Case.SENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, "a", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.equalTo(new long[]{-1}, "a", Case.INSENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{9}, "a", Case.INSENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.equalTo(new long[]{10}, "a", Case.INSENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{-1}, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{9}, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.equalTo(new long[]{10}, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testInvalidColumnIndexNotEqualTo() {
@@ -156,40 +151,40 @@ public void testInvalidColumnIndexNotEqualTo() {
 
 
         // Date
-        try { query.notEqualTo(new long[]{-1}, new Date()).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, new Date()).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, new Date()).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.notEqualTo(new long[]{-1}, 4.5d).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 4.5d).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 4.5d).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.notEqualTo(new long[]{-1}, 1.4f).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 1.4f).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 1.4f).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.notEqualTo(new long[]{-1}, 1).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, 1).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, 1).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String
-        try { query.notEqualTo(new long[]{-1}, "a").findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a").findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a").findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, "a"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, "a");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, "a"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.notEqualTo(new long[]{-1}, "a", Case.SENSITIVE).findAll(); fail("-1column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a", Case.SENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a", Case.SENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, "a", Case.SENSITIVE); fail("-1column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, "a", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, "a", Case.SENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.notEqualTo(new long[]{-1}, "a", Case.INSENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{9}, "a", Case.INSENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.notEqualTo(new long[]{10}, "a", Case.INSENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{-1}, "a", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{9}, "a", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.notEqualTo(new long[]{10}, "a", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -198,25 +193,25 @@ public void testInvalidColumnIndexGreaterThan() {
         TableQuery query = table.where();
 
         // Date
-        try { query.greaterThan(new long[]{-1}, new Date()).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, new Date()).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, new Date()).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.greaterThan(new long[]{-1}, 4.5d).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 4.5d).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 4.5d).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.greaterThan(new long[]{-1}, 1.4f).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 1.4f).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 1.4f).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.greaterThan(new long[]{-1}, 1).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{9}, 1).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThan(new long[]{10}, 1).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThan(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -225,25 +220,25 @@ public void testInvalidColumnIndexGreaterThanOrEqual() {
         TableQuery query = table.where();
 
         // Date
-        try { query.greaterThanOrEqual(new long[]{-1}, new Date()).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, new Date()).findAll(); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, new Date()).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{9}, new Date()); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.greaterThanOrEqual(new long[]{-1}, 4.5d).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 4.5d).findAll(); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 4.5d).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{9}, 4.5d); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.greaterThanOrEqual(new long[]{-1}, 1.4f).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 1.4f).findAll(); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 1.4f).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{9}, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.greaterThanOrEqual(new long[]{-1}, 1).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{9}, 1).findAll(); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.greaterThanOrEqual(new long[]{10}, 1).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{9}, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.greaterThanOrEqual(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -252,25 +247,25 @@ public void testInvalidColumnIndexLessThan() {
         TableQuery query = table.where();
 
         // Date
-        try { query.lessThan(new long[]{-1}, new Date()).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, new Date()).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, new Date()).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.lessThan(new long[]{-1}, 4.5d).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 4.5d).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 4.5d).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.lessThan(new long[]{-1}, 1.4f).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 1.4f).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 1.4f).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{9}, 1.4f);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.lessThan(new long[]{-1}, 1).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{9}, 1).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThan(new long[]{10}, 1).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{9}, 1);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThan(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testInvalidColumnIndexLessThanOrEqual() {
@@ -278,25 +273,25 @@ public void testInvalidColumnIndexLessThanOrEqual() {
         TableQuery query = table.where();
 
         // Date
-        try { query.lessThanOrEqual(new long[]{-1}, new Date()).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, new Date()).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, new Date()).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{9}, new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{10}, new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.lessThanOrEqual(new long[]{-1}, 4.5d).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 4.5d).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 4.5d).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, 4.5d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{9}, 4.5d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{10}, 4.5d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.lessThanOrEqual(new long[]{-1}, 1.4f).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 1.4f).findAll(); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 1.4f).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, 1.4f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{9}, 1.4f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{10}, 1.4f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.lessThanOrEqual(new long[]{-1}, 1).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{9}, 1).findAll(); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.lessThanOrEqual(new long[]{10}, 1).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{-1}, 1); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{9}, 1); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.lessThanOrEqual(new long[]{10}, 1); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -305,25 +300,25 @@ public void testInvalidColumnIndexBetween() {
         TableQuery query = table.where();
 
         // Date
-        try { query.between(new long[]{-1}, new Date(), new Date()).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, new Date(), new Date()).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{10}, new Date(), new Date()).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{-1}, new Date(), new Date()); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{9}, new Date(), new Date());  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{10}, new Date(), new Date()); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Double
-        try { query.between(new long[]{-1}, 4.5d, 6.0d).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 4.5d, 6.0d).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{10}, 4.5d, 6.0d).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{-1}, 4.5d, 6.0d); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{9}, 4.5d, 6.0d);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{10}, 4.5d, 6.0d); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
 
         // Float
-        try { query.between(new long[]{-1}, 1.4f, 5.8f).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 1.4f, 5.8f).findAll(); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{10}, 1.4f, 5.8f).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{-1}, 1.4f, 5.8f); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{9}, 1.4f, 5.8f); fail("9 column index"); }   catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{10}, 1.4f, 5.8f); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // Int / long
-        try { query.between(new long[]{-1}, 1, 10).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{9}, 1, 10).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.between(new long[]{10}, 1, 10).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{-1}, 1, 10); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{9}, 1, 10);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.between(new long[]{10}, 1, 10); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
 
@@ -332,19 +327,19 @@ public void testInvalidColumnIndexContains() {
         TableQuery query = table.where();
 
         // String
-        try { query.contains(new long[]{-1}, "hey").findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey").findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey").findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, "hey"); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{9}, "hey");  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{10}, "hey"); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case true
-        try { query.contains(new long[]{-1}, "hey", Case.SENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey", Case.SENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey", Case.SENSITIVE).findAll(); fail("-0 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, "hey", Case.SENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{9}, "hey", Case.SENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{10}, "hey", Case.SENSITIVE); fail("-0 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
 
         // String case false
-        try { query.contains(new long[]{-1}, "hey", Case.INSENSITIVE).findAll(); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{9}, "hey", Case.INSENSITIVE).findAll();  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
-        try { query.contains(new long[]{10}, "hey", Case.INSENSITIVE).findAll(); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{-1}, "hey", Case.INSENSITIVE); fail("-1 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{9}, "hey", Case.INSENSITIVE);  fail("9 column index"); }  catch (ArrayIndexOutOfBoundsException e) {}
+        try { query.contains(new long[]{10}, "hey", Case.INSENSITIVE); fail("10 column index"); } catch (ArrayIndexOutOfBoundsException e) {}
     }
 
     public void testNullInputQuery() {
@@ -617,56 +612,6 @@ public void testColumnIndexOutOfBounds() {
         try { query.equalTo(new long[]{7}, true);                     assert(false); } catch(ArrayIndexOutOfBoundsException e) {}
     }
 
-
-    public void testQueryOnView() {
-        Table table = new Table();
-
-        // Specifies the column types and names.
-        table.addColumn(RealmFieldType.STRING, "firstName");
-        table.addColumn(RealmFieldType.STRING, "lastName");
-        table.addColumn(RealmFieldType.INTEGER, "salary");
-
-        // Adds data to the table.
-        table.add("John", "Lee", 10000);
-        table.add("Jane", "Lee", 15000);
-        table.add("John", "Anderson", 20000);
-        table.add("Erik", "Lee", 30000);
-        table.add("Henry", "Anderson", 10000);
-
-        TableView view = table.where().findAll();
-
-        TableView view2 = view.where().equalTo(new long[]{0}, "John").findAll();
-
-        assertEquals(2, view2.size());
-
-        TableView view3 = view2.where().equalTo(new long[]{1}, "Anderson").findAll();
-
-        assertEquals(1, view3.size());
-    }
-
-
-    public void testQueryOnViewWithAlreadyQueriedTable() {
-        Table table = new Table();
-
-        // Specifies the column types and names.
-        table.addColumn(RealmFieldType.STRING, "firstName");
-        table.addColumn(RealmFieldType.STRING, "lastName");
-        table.addColumn(RealmFieldType.INTEGER, "salary");
-
-        // Adds data to the table.
-        table.add("John", "Lee", 10000);
-        table.add("Jane", "Lee", 15000);
-        table.add("John", "Anderson", 20000);
-        table.add("Erik", "Lee", 30000);
-        table.add("Henry", "Anderson", 10000);
-
-        TableView view = table.where().equalTo(new long[]{0}, "John").findAll();
-
-        TableView view2 = view.where().equalTo(new long[]{1}, "Anderson").findAll();
-
-        assertEquals(1, view2.size());
-    }
-
     public void testMaximumDate() {
 
         Table table = new Table();
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
index ae15cbc29d..6c14e963b4 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNISortedLongTest.java
@@ -16,15 +16,18 @@
 
 package io.realm.internal;
 
+import android.support.test.InstrumentationRegistry;
+
 import junit.framework.TestCase;
 
+import io.realm.Realm;
 import io.realm.RealmFieldType;
 
 public class JNISortedLongTest extends TestCase {
     Table table;
-    TableView view;
 
     void init() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
         table = new Table();
         table.addColumn(RealmFieldType.INTEGER, "number");
         table.addColumn(RealmFieldType.STRING, "name");
@@ -39,11 +42,6 @@ void init() {
         table.add(60, "D");
 
         assertEquals(8, table.size());
-
-        view = table.where().findAll();
-
-        assertEquals(view.size(), table.size());
-
     }
 
     public void testShouldTestSortedIntTable() {
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
index ed9f4c41a7..bbe3cbfa19 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableTest.java
@@ -294,8 +294,6 @@ public void tableNumbers() {
         assertEquals(3, t.count(2, 3.0f));
         assertEquals(3, t.count(3, "s1"));
 
-        assertEquals(3, t.findAllDouble(1, 2.0d).size());
-        assertEquals(3, t.findAllFloat(2, 3.0f).size());
 
         assertEquals(3, t.findFirstDouble(1, 20.0d)); // Find rows index for first double value of 20.0 in column 1.
         assertEquals(4, t.findFirstFloat(2, 300.0f)); // Find rows index for first float value of 300.0 in column 2.
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
deleted file mode 100644
index fa366ed50d..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNITableViewTest.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.support.test.InstrumentationRegistry;
-import android.support.test.runner.AndroidJUnit4;
-
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-
-import io.realm.Realm;
-import io.realm.RealmFieldType;
-import io.realm.rule.TestRealmConfigurationFactory;
-
-import static junit.framework.Assert.assertEquals;
-
-@RunWith(AndroidJUnit4.class)
-public class JNITableViewTest {
-    static {
-        Realm.init(InstrumentationRegistry.getInstrumentation().getTargetContext());
-    }
-
-    @Rule
-    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
-
-    private static final String TABLE_NAME = Table.TABLE_PREFIX + "JNITableViewTest";
-    private static final int ROW_COUNT = 10;
-
-    private static final List<RealmFieldType> FIELDS = Arrays.asList(
-            RealmFieldType.INTEGER,
-            RealmFieldType.BOOLEAN,
-            RealmFieldType.STRING,
-            RealmFieldType.BINARY,
-            RealmFieldType.DATE,
-            RealmFieldType.FLOAT,
-            RealmFieldType.DOUBLE);
-    private static final long INTEGER_COLUMN_INDEX = 0;
-    private static final long STRING_COLUMN_INDEX = 2;
-
-    private SharedRealm sharedRealm;
-
-    private Table table;
-
-    @Before
-    public void setUp() {
-        sharedRealm = SharedRealm.getInstance(configFactory.createConfiguration());
-        sharedRealm.beginTransaction();
-        try {
-            table = sharedRealm.getTable(TABLE_NAME);
-
-            for (RealmFieldType field : FIELDS) {
-                final long index = table.addColumn(field, field.name().toLowerCase(Locale.ENGLISH) + "Column");
-                table.convertColumnToNullable(index);
-            }
-
-            for (int i = 0; i < ROW_COUNT; i++) {
-                table.add(i, true, "abcd", new byte[]{123, -123}, new Date(12345), 1.234f, 3.446d);
-            }
-        } finally {
-            sharedRealm.commitTransaction();
-        }
-    }
-
-    @Test
-    public void setNull() {
-        TableQuery query = table.where();
-        for (int i = 0; i < ROW_COUNT; i++) {
-            if (isOdd(i)) {
-                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
-            }
-        }
-        final TableView oddRows = query.findAll();
-
-        sharedRealm.beginTransaction();
-        for (int i = 0; i < oddRows.size(); i++) {
-            oddRows.setNull(STRING_COLUMN_INDEX, i, false);
-        }
-        sharedRealm.commitTransaction();
-
-        // Checks if TableView#setNull() worked as expected
-        for (int i = 0; i < table.size(); i++) {
-            assertEquals("index: " + i, isOdd(i), table.isNull(STRING_COLUMN_INDEX, i));
-        }
-    }
-
-    @Test
-    public void isNull() {
-
-        sharedRealm.beginTransaction();
-        for (int i = 0; i < table.size(); i++) {
-            if (isOdd(i)) {
-                table.setNull(STRING_COLUMN_INDEX, i, false);
-            }
-        }
-        sharedRealm.commitTransaction();
-
-        TableQuery query = table.where();
-        for (int i = 0; i < ROW_COUNT; i++) {
-            if (isOdd(i)) {
-                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
-            }
-        }
-        final TableView oddRows = query.findAll();
-        for (int i = 0; i < oddRows.size(); i++) {
-            assertEquals("index: " + i, true, oddRows.isNull(STRING_COLUMN_INDEX, i));
-        }
-
-        query = table.where();
-        for (int i = 0; i < ROW_COUNT; i++) {
-            if (isEven(i)) {
-                query = query.or().equalTo(new long[]{INTEGER_COLUMN_INDEX}, (long) i);
-            }
-        }
-        final TableView evenRows = query.findAll();
-        for (int i = 0; i < evenRows.size(); i++) {
-            assertEquals("index: " + i, false, evenRows.isNull(STRING_COLUMN_INDEX, i));
-        }
-    }
-
-    private static boolean isEven(int i) {
-        return i % 2 == 0;
-    }
-    private static boolean isOdd(int i) {
-        return i % 2 == 1;
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
deleted file mode 100644
index 8ab65d077b..0000000000
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/JNIViewTest.java
+++ /dev/null
@@ -1,420 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import android.test.MoreAsserts;
-
-import junit.framework.TestCase;
-
-import java.util.Date;
-
-import io.realm.RealmFieldType;
-import io.realm.Sort;
-import io.realm.TestHelper;
-
-@SuppressWarnings("deprecation")
-public class JNIViewTest extends TestCase {
-    Table t;
-    Date date1 = new Date(2010-1900,  1,  5);
-    Date date2 = new Date(1999-1900, 12,  1);
-    Date date3 = new Date(1990-1900, 12, 24);
-    Date date4 = new Date(2010-1900,  1,  4);
-
-    @Override
-    public void setUp() {
-        // Specifies table.
-        t = new Table();
-        t.addColumn(RealmFieldType.STRING, "Name");
-        t.addColumn(RealmFieldType.BOOLEAN,   "Study");
-        t.addColumn(RealmFieldType.INTEGER,    "Age");
-        t.addColumn(RealmFieldType.DATE,   "Birthday");
-
-        // Adds data.
-        t.add("cc", true,  24, date1);
-        t.add("dd", false, 35, date2);
-        t.add("bb", true,  22, date3);
-        t.add("aa", false, 22, date4);
-
-        assertEquals(date1, t.getDate(3, 0));
-        assertEquals(date2, t.getDate(3, 1));
-        assertEquals(date3, t.getDate(3, 2));
-        assertEquals(date4, t.getDate(3, 3));
-    }
-
-    public void testUnimplementedMethodsShouldFail() {
-        // Gets a view containing all rows in table since you can only sort views currently.
-        TableView view = t.where().findAll();
-
-        try { view.upperBoundLong(0, 0); fail("Not implemented yet"); } catch (RuntimeException e ) { }
-        try { view.lowerBoundLong(0, 0); fail("Not implemented yet"); } catch (RuntimeException e ) { }
-      //  try { view.lookup("Some String"); fail("Not implemented yet"); } catch (RuntimeException e ) { }
-        try { view.count(0, "Some String"); fail("Not implemented yet"); } catch (RuntimeException e ) { }
-    }
-
-
-    public void testShouldSortViewDate() {
-        // Gets a view containing all rows in table since you can only sort views currently.
-        TableView view = t.where().findAll();
-
-        // Sorts without specifying the order, should default to ascending.
-        view.sort(3);
-        assertEquals(date3, view.getDate(3, 0));
-        assertEquals(date2, view.getDate(3, 1));
-        assertEquals(date4, view.getDate(3, 2));
-        assertEquals(date1, view.getDate(3, 3));
-        assertEquals("cc", view.getString(0, 3));
-    }
-
-
-    public void testShouldSortViewIntegers() {
-        // Gets a view containing all rows in table since you can only sort views currently.
-        TableView view = t.where().findAll();
-
-        // Sorts without specifying the order, should default to ascending.
-        view.sort(2);
-        assertEquals(22, view.getLong(2, 0));
-        assertEquals(22, view.getLong(2, 1));
-        assertEquals(24, view.getLong(2, 2));
-        assertEquals(35, view.getLong(2, 3));
-        assertEquals("dd", view.getString(0, 3));
-
-        // Sorts descending - creating a new view.
-        view.sort(2, Sort.DESCENDING);
-        assertEquals(35, view.getLong(2, 0));
-        assertEquals(24, view.getLong(2, 1));
-        assertEquals(22, view.getLong(2, 2));
-        assertEquals(22, view.getLong(2, 3));
-        assertEquals("dd", view.getString(0, 0));
-
-        // Sorts ascending.
-        TableView view2 = t.where().findAll();
-        view2.sort(2, Sort.ASCENDING);
-        assertEquals(22, view2.getLong(2, 0));
-        assertEquals(22, view2.getLong(2, 1));
-        assertEquals(24, view2.getLong(2, 2));
-        assertEquals(35, view2.getLong(2, 3));
-        assertEquals("dd", view2.getString(0, 3));
-
-        // Checks that old view is still the same.
-        assertEquals(35, view.getLong(2, 0));
-        assertEquals(24, view.getLong(2, 1));
-        assertEquals(22, view.getLong(2, 2));
-        assertEquals(22, view.getLong(2, 3));
-        assertEquals("dd", view.getString(0, 0));
-    }
-
-
-    public void testSetBinary() {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.BINARY, "binary");
-
-        byte[] arr1 = new byte[] {1,2,3};
-        table.add(new Object[]{arr1});
-        MoreAsserts.assertEquals(arr1, table.getBinaryByteArray(0, 0));
-
-        TableView view = table.where().findAll();
-
-        byte[] arr2 = new byte[] {1,2,3, 4, 5};
-
-        view.setBinaryByteArray(0, 0, arr2, false);
-
-        MoreAsserts.assertEquals(arr2, view.getBinaryByteArray(0, 0));
-    }
-
-    public void testSortOnNonexistingColumn() {
-        TableView view = t.where().findAll();
-
-        try { view.sort(-1); fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.sort(-100); fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.sort(100); fail("Column is 100, column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-    }
-
-
-    public void testFindFirstNonExisting() {
-        Table tt = TestHelper.getTableWithAllColumnTypes();
-        tt.add(new byte[]{1,2,3}, true, new Date(1384423149761l), 4.5d, 5.7f, 100, "string");
-        TableView v = tt.where().findAll();
-
-        assertEquals(-1, v.findFirstBoolean(1, false));
-        //FIXME: enable when find_first_timestamp() is implemented: assertEquals(-1, v.findFirstDate(2, new Date(138442314986l)));
-        assertEquals(-1, v.findFirstDouble(3, 1.0d));
-        assertEquals(-1, v.findFirstFloat(4, 1.0f));
-        assertEquals(-1, v.findFirstLong(5, 50));
-    }
-
-
-    public void testGetValuesFromNonExistingColumn() {
-        Table table = TestHelper.getTableWithAllColumnTypes();
-        TableView view = table.where().findAll();
-
-        try { view.getBinaryByteArray(-1, 0);   fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getBinaryByteArray(-10, 0);  fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getBinaryByteArray(100, 0);  fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { view.getBoolean(-1, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getBoolean(-10, 0);          fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getBoolean(100, 0);          fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { view.getDate(-1, 0);              fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getDate(-10, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getDate(100, 0);             fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { view.getDouble(-1, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getDouble(-10, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getDouble(100, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { view.getFloat(-1, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getFloat(-10, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getFloat(100, 0);            fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { view.getLong(-1, 0);              fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getLong(-10, 0);             fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getLong(100, 0);             fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-
-        try { view.getString(-1, 0);            fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getString(-10, 0);           fail("Column is less than 0"); } catch (ArrayIndexOutOfBoundsException e) { }
-        try { view.getString(100, 0);           fail("Column does not exist"); } catch (ArrayIndexOutOfBoundsException e) { }
-    }
-
-
-    public void testGetSourceRow() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.STRING, "");
-        t.addColumn(RealmFieldType.INTEGER, "");
-        t.addColumn(RealmFieldType.BOOLEAN, "");
-
-        t.add("1", 1, true);
-        t.add("2", 2, true);
-        t.add("3", 3, false);
-        t.add("4", 5, false);
-
-        TableView v = t.where().equalTo(new long[]{2}, false).findAll();
-
-        assertEquals(2, v.getSourceRowIndex(0));
-        assertEquals(3, v.getSourceRowIndex(1));
-
-        // Out of bound
-        try { assertEquals(0, v.getSourceRowIndex(2));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
-        try { assertEquals(0, v.getSourceRowIndex(100));    fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
-        try { assertEquals(0, v.getSourceRowIndex(-1));     fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
-        try { assertEquals(0, v.getSourceRowIndex(-100));   fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
-    }
-
-
-    public void testGetSourceRowNoRows() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.STRING, "");
-        t.addColumn(RealmFieldType.INTEGER, "");
-        t.addColumn(RealmFieldType.BOOLEAN, "");
-        // No data is added.
-        TableView v = t.where().findAll();
-
-        // Out of bound.
-        try { assertEquals(0, v.getSourceRowIndex(0));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
-        try { assertEquals(0, v.getSourceRowIndex(1));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
-    }
-
-
-    public void testGetSourceRowEmptyTable() {
-        Table t = new Table();
-        // No columns.
-        TableView v = t.where().findAll();
-
-        // Out of bound.
-        try { assertEquals(0, v.getSourceRowIndex(0));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
-        try { assertEquals(0, v.getSourceRowIndex(1));      fail("index ot of bounds"); } catch (IndexOutOfBoundsException e) { }
-    }
-
-
-    public void testShouldSortViewBool() {
-        // Gets a view containing all rows in table since you can only sort views currently.
-        TableView view = t.where().findAll();
-
-        // Sorts without specifying the order, should default to ascending.
-        view.sort(1);
-        assertEquals(false, view.getBoolean(1, 0));
-        assertEquals(false, view.getBoolean(1, 1));
-        assertEquals(true, view.getBoolean(1, 2));
-        assertEquals(true, view.getBoolean(1, 3));
-        assertEquals("bb", view.getString(0, 3));
-    }
-
-    public void testShouldSearchByColumnValue() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.STRING, "name");
-
-        table.add("Foo");
-        table.add("Bar");
-
-        TableQuery query = table.where();
-        TableView view = query.findAll(0, table.size(), Integer.MAX_VALUE);
-        assertEquals(2, view.size());
-
-        view.findAllString(0, "Foo");
-    }
-
-    public void testShouldQueryInView() {
-        Table table = new Table();
-        table.addColumn(RealmFieldType.STRING, "name");
-
-        table.add("A1");
-        table.add("B");
-        table.add("A2");
-        table.add("B");
-        table.add("A3");
-        table.add("B");
-        table.add("A3");
-
-        TableQuery query = table.where();
-        TableView view = query.beginsWith(new long[]{0}, "A").findAll(0, table.size(), Table.INFINITE);
-        assertEquals(4, view.size());
-
-        TableQuery query2 = table.where();
-        TableView view2 = query2.tableview(view).contains(new long[]{0}, "3").findAll();
-        assertEquals(2, view2.size());
-    }
-
-    public void testGetNonExistingColumn() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.INTEGER, "int");
-        TableView view = t.where().findAll();
-        assertEquals(-1, view.getColumnIndex("non-existing column"));
-    }
-
-    public void testGetNullColumn() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.INTEGER, "");
-        TableView view = t.where().findAll();
-        try { view.getColumnIndex(null); fail("Getting null column"); } catch(IllegalArgumentException e) { }
-    }
-
-
-    public void testViewToString() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.STRING, "stringCol");
-        t.addColumn(RealmFieldType.INTEGER, "intCol");
-        t.addColumn(RealmFieldType.BOOLEAN, "boolCol");
-
-        t.add("s1", 1, true);
-        t.add("s2", 2, false);
-
-        TableView view = t.where().findAll();
-
-        String expected = "The TableView contains 3 columns: stringCol, intCol, boolCol. And 2 rows.";
-
-        assertEquals(expected, view.toString());
-    }
-
-    void accessingViewOk(TableView view)
-    {
-        view.size();
-        view.isEmpty();
-        view.getLong(0, 0);
-        view.getColumnCount();
-        view.getColumnName(0);
-        view.getColumnIndex("");
-        view.getColumnType(0);
-        view.averageLong(0);
-        view.maximumLong(0);
-        view.minimumLong(0);
-        view.sumLong(0);
-        view.findAllLong(0, 2);
-        view.findFirstLong(0, 2);
-        view.where();
-        view.toJson();
-        view.toString();
-    }
-
-    void accessingViewMustThrow(TableView view)
-    {
-        try { view.size();              assert(false); } catch (IllegalStateException e) {}
-        try { view.isEmpty();           assert(false); } catch (IllegalStateException e) {}
-        try { view.getLong(0,0);        assert(false); } catch (IllegalStateException e) {}
-        try { view.getColumnCount();    assert(false); } catch (IllegalStateException e) {}
-        try { view.getColumnName(0);    assert(false); } catch (IllegalStateException e) {}
-        try { view.getColumnIndex("");  assert(false); } catch (IllegalStateException e) {}
-        try { view.getColumnType(0);    assert(false); } catch (IllegalStateException e) {}
-        try { view.averageLong(0);      assert(false); } catch (IllegalStateException e) {}
-        try { view.maximumLong(0);      assert(false); } catch (IllegalStateException e) {}
-        try { view.minimumLong(0);      assert(false); } catch (IllegalStateException e) {}
-        try { view.sumLong(0);          assert(false); } catch (IllegalStateException e) {}
-        try { view.findAllLong(0, 2);   assert(false); } catch (IllegalStateException e) {}
-        try { view.findFirstLong(0, 2); assert(false); } catch (IllegalStateException e) {}
-        try { view.where();             assert(false); } catch (IllegalStateException e) {}
-        try { view.toJson();            assert(false); } catch (IllegalStateException e) {}
-        try { view.toString();          assert(false); } catch (IllegalStateException e) {}
-    }
-
-    public void testViewShouldInvalidate() {
-        Table t = new Table();
-        t.addColumn(RealmFieldType.INTEGER, "intCol");
-        t.add(1);
-        t.add(2);
-        t.add(3);
-
-        TableView view = t.where().equalTo(new long[]{0}, 2).findAll();
-        // Access view is ok.
-        assertEquals(1, view.size());
-
-        // Access view after change in value is ok.
-        t.setLong(0, 0, 3, false);
-        accessingViewOk(view);
-
-        // Access view after additions to table must fail.
-        t.add(4);
-        accessingViewMustThrow(view);
-
-        // Recreates view to access again.
-        view = t.where().equalTo(new long[]{0}, 2).findAll();
-        accessingViewOk(view);
-
-        // Removing any row in Table should invalidate view.
-        t.remove(3);
-        accessingViewMustThrow(view);
-    }
-
-    public void testMaximumDate() {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.DATE, "date");
-
-        table.add(new Date(0));
-        table.add(new Date(10000));
-        table.add(new Date(1000));
-
-        TableView view = table.where().findAll();
-
-        assertEquals(new Date(10000), view.maximumDate(0));
-
-    }
-
-    public void testMinimumDate() {
-
-        Table table = new Table();
-        table.addColumn(RealmFieldType.DATE, "date");
-
-        table.add(new Date(10000));
-        table.add(new Date(0));
-        table.add(new Date(1000));
-
-        TableView view = table.where().findAll();
-
-        assertEquals(new Date(0), view.minimumDate(0));
-
-    }
-}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java
new file mode 100644
index 0000000000..c06aa13900
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/ObserverPairListTests.java
@@ -0,0 +1,318 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.annotation.SuppressLint;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+/**
+ * We are testing characteristic of the {@link ObserverPairList} here, such as:
+ * Ownership of the listeners, equality of the pair and all public APIs for the class.
+ */
+@RunWith(AndroidJUnit4.class)
+public class ObserverPairListTests {
+
+    private static class TestListener<Integer> {
+        void onChange(Integer integer) {
+        }
+    }
+
+    private static class TestObserverPair extends ObserverPairList.ObserverPair<Integer, TestListener>  {
+        TestObserverPair(Integer observer, TestListener listener) {
+            super(observer, listener);
+        }
+    }
+
+    private ObserverPairList<TestObserverPair> observerPairs;
+    private TestListener testListener = new TestListener<Integer>();
+
+    private static final Integer ONE = 1;
+    private static final Integer TWO = 2;
+    private static final Integer THREE = 3;
+
+    @Before
+    public void setUp() {
+        observerPairs = new ObserverPairList<TestObserverPair>();
+    }
+
+    @After
+    public void tearDown() {
+        observerPairs = null;
+    }
+
+    @Test
+    public void add() {
+        TestObserverPair pair = new TestObserverPair(ONE, testListener);
+        observerPairs.add(pair);
+        assertEquals(1, observerPairs.size());
+
+        // Same observer object, different listener.
+        pair = new TestObserverPair(ONE, new TestListener<Integer>());
+        observerPairs.add(pair);
+        assertEquals(2, observerPairs.size());
+
+        // Different observer object, different listener.
+        pair = new TestObserverPair(TWO, new TestListener<Integer>());
+        observerPairs.add(pair);
+        assertEquals(3, observerPairs.size());
+
+        // Different observer object, same listener.
+        pair = new TestObserverPair(TWO, testListener);
+        observerPairs.add(pair);
+        assertEquals(4, observerPairs.size());
+    }
+
+    @Test
+    // The Observer pair is treated as the same when the observer is the same object and the listener is the same too.
+    public void add_noDuplicate() {
+        TestObserverPair pair = new TestObserverPair(ONE, testListener);
+        observerPairs.add(pair);
+        assertEquals(1, observerPairs.size());
+
+        pair = new TestObserverPair(ONE, testListener);
+        observerPairs.add(pair);
+        assertEquals(1, observerPairs.size());
+    }
+
+    // 1. add 2. clear 3. add 4. Check if the last listener can still be called.
+    @Test
+    public void add_worksAfterClears() {
+        final AtomicBoolean foreachCalled = new AtomicBoolean(false);
+        TestObserverPair pair = new TestObserverPair(ONE, testListener);
+        observerPairs.add(pair);
+        assertEquals(1, observerPairs.size());
+
+        observerPairs.clear();
+
+        observerPairs.add(pair);
+        assertEquals(1, observerPairs.size());
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                assertEquals(ONE, observer);
+                foreachCalled.set(true);
+            }
+        });
+        assertTrue(foreachCalled.get());
+    }
+
+    @SuppressLint("UseValueOf")
+    @Test
+    public void remove() {
+        TestObserverPair pair = new TestObserverPair(ONE, testListener);
+        observerPairs.add(pair);
+        assertEquals(1, observerPairs.size());
+
+        // Create a new Integer 1 to see if the equality is checked by the same object.
+        //noinspection UnnecessaryBoxing
+        observerPairs.remove(new Integer(1), testListener);
+        assertEquals(1, observerPairs.size());
+
+        // Different listener
+        observerPairs.remove(ONE, new TestListener());
+        assertEquals(1, observerPairs.size());
+
+        // Should remove now
+        observerPairs.remove(ONE, testListener);
+        assertEquals(0, observerPairs.size());
+    }
+
+    @Test
+    public void removeByObserver() {
+        TestObserverPair pair = new TestObserverPair(ONE, testListener);
+        observerPairs.add(pair);
+        pair = new TestObserverPair(ONE, new TestListener());
+        observerPairs.add(pair);
+        assertEquals(2, observerPairs.size());
+
+        // An different observer
+        //noinspection UnnecessaryBoxing
+        pair = new TestObserverPair(TWO, testListener);
+        observerPairs.add(pair);
+        assertEquals(3, observerPairs.size());
+
+        observerPairs.removeByObserver(ONE);
+        assertEquals(1, observerPairs.size());
+
+        observerPairs.removeByObserver(TWO);
+        assertEquals(0, observerPairs.size());
+    }
+
+    @Test
+    public void clear() {
+        TestObserverPair pair = new TestObserverPair(ONE, new TestListener());
+        observerPairs.add(pair);
+        assertEquals(1, observerPairs.size());
+        observerPairs.clear();
+        assertEquals(0, observerPairs.size());
+    }
+
+    @Test
+    public void isEmpty() {
+        assertTrue(observerPairs.isEmpty());
+        TestObserverPair pair = new TestObserverPair(ONE, new TestListener());
+        observerPairs.add(pair);
+        assertFalse(observerPairs.isEmpty());
+        observerPairs.clear();
+        assertTrue(observerPairs.isEmpty());
+    }
+
+    @Test
+    public void foreach() {
+        final boolean[] onChangesCalled = {false, false};
+        TestListener<Integer> listener = new TestListener<Integer>() {
+            @Override
+            void onChange(Integer i) {
+                onChangesCalled[i-1] = true;
+            }
+        };
+
+        TestObserverPair pair = new TestObserverPair(ONE, listener);
+        observerPairs.add(pair);
+        pair = new TestObserverPair(TWO, listener);
+        observerPairs.add(pair);
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                //noinspection unchecked
+                pair.listener.onChange(observer);
+            }
+        });
+        assertTrue(onChangesCalled[0] && onChangesCalled[1]);
+    }
+
+    // Test if the observer is GCed, the relevant listener should be removed when foreach called.
+    @Test
+    public void foreach_shouldRemoveWeakRefs() {
+        TestObserverPair pair = new TestObserverPair(ONE, new TestListener());
+        observerPairs.add(pair);
+        assertEquals(1, observerPairs.size());
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                // There is no guaranteed way to release the WeakReference,
+                // just clear it.
+                pair.observerRef.clear();
+            }
+        });
+        assertEquals(1, observerPairs.size());
+
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                fail();
+            }
+        });
+        assertEquals(0, observerPairs.size());
+    }
+
+    @Test
+    public void foreach_canRemove() {
+        final AtomicInteger count = new AtomicInteger(0);
+        final TestObserverPair pair1 = new TestObserverPair(ONE, new TestListener());
+        final TestListener listener2 = new TestListener();
+        final TestObserverPair pair2 = new TestObserverPair(TWO, listener2);
+        final TestObserverPair pair3 = new TestObserverPair(THREE, new TestListener());
+        observerPairs.add(pair1);
+        observerPairs.add(pair2);
+        observerPairs.add(pair3);
+        assertEquals(3, observerPairs.size());
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                assertFalse(((Integer) observer) == 2);
+                observerPairs.remove(TWO, listener2);
+                count.getAndIncrement();
+            }
+        });
+        assertEquals(2, observerPairs.size());
+        assertEquals(2, count.get());
+    }
+
+    @Test
+    public void foreach_canClear() {
+        final AtomicInteger count = new AtomicInteger(0);
+        final TestObserverPair pair1 = new TestObserverPair(ONE, new TestListener());
+        final TestObserverPair pair2 = new TestObserverPair(TWO, new TestListener());
+        final TestObserverPair pair3 = new TestObserverPair(THREE, new TestListener());
+        observerPairs.add(pair1);
+        observerPairs.add(pair2);
+        observerPairs.add(pair3);
+        assertEquals(3, observerPairs.size());
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                assertFalse(((Integer) observer) == 2);
+                assertFalse(((Integer) observer) == 3);
+                observerPairs.clear();
+                count.getAndIncrement();
+            }
+        });
+        assertEquals(0, observerPairs.size());
+        assertEquals(1, count.get());
+
+        observerPairs.add(pair1);
+        assertEquals(1, observerPairs.size());
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                assertTrue(((Integer) observer) == 1);
+            }
+        });
+    }
+
+    @Test
+    public void foreach_canAdd() {
+        final AtomicInteger count = new AtomicInteger(0);
+        final TestObserverPair pair1 = new TestObserverPair(ONE, new TestListener());
+        final TestObserverPair pair2 = new TestObserverPair(TWO, new TestListener());
+        observerPairs.add(pair1);
+        assertEquals(1, observerPairs.size());
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                observerPairs.add(pair2);
+                count.getAndIncrement();
+            }
+        });
+        assertEquals(2, observerPairs.size());
+        assertEquals(1, count.get());
+
+        count.set(0);
+        assertEquals(2, observerPairs.size());
+        observerPairs.foreach(new ObserverPairList.Callback<TestObserverPair>() {
+            @Override
+            public void onCalled(TestObserverPair pair, Object observer) {
+                count.getAndIncrement();
+            }
+        });
+        assertEquals(2, count.get());
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
index 1ee36c4c23..67006b5592 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/PivotTest.java
@@ -16,10 +16,13 @@
 
 package io.realm.internal;
 
+import android.support.test.InstrumentationRegistry;
+
 import junit.framework.TestCase;
 
+import io.realm.Realm;
 import io.realm.RealmFieldType;
-import io.realm.internal.TableOrView.PivotType;
+import io.realm.internal.Table.PivotType;
 
 public class PivotTest extends TestCase {
 
@@ -30,6 +33,7 @@
 
     @Override
     public void setUp() {
+        Realm.init(InstrumentationRegistry.getInstrumentation().getContext());
         t = new Table();
         colIndexSex = t.addColumn(RealmFieldType.STRING, "sex");
         colIndexAge = t.addColumn(RealmFieldType.INTEGER, "age");
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
new file mode 100644
index 0000000000..6c70f71d1a
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/RealmNotifierTests.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import io.realm.RealmChangeListener;
+import io.realm.RealmConfiguration;
+import io.realm.internal.android.AndroidRealmNotifier;
+import io.realm.rule.RunInLooperThread;
+import io.realm.rule.RunTestInLooperThread;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class RealmNotifierTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final RunInLooperThread looperThread = new RunInLooperThread();
+
+    private Capabilities capabilitiesCanDeliver = new Capabilities() {
+        @Override
+        public boolean canDeliverNotification() {
+            return true;
+        }
+
+        @Override
+        public void checkCanDeliverNotification(String exceptionMessage) {
+        }
+    };
+
+    @Before
+    public void setUp() throws Exception {
+    }
+
+    @After
+    public void tearDown() {
+    }
+
+    private SharedRealm getSharedRealm(RealmConfiguration config) {
+        return SharedRealm.getInstance(config, null, true);
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void post() {
+        RealmNotifier notifier = new AndroidRealmNotifier(null, capabilitiesCanDeliver);
+        notifier.post(new Runnable() {
+            @Override
+            public void run() {
+                looperThread.testComplete();
+            }
+        });
+    }
+
+    // Callback is immediately called when commitTransaction for local changes.
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_byLocalChanges() {
+        final AtomicBoolean commitReturns = new AtomicBoolean(false);
+        SharedRealm sharedRealm = getSharedRealm(looperThread.realmConfiguration);
+        sharedRealm.realmNotifier.addChangeListener(sharedRealm, new RealmChangeListener<SharedRealm>() {
+            @Override
+            public void onChange(SharedRealm sharedRealm) {
+                // Transaction has been committed in core, but commitTransaction hasn't returned in java.
+                assertFalse(commitReturns.get());
+                looperThread.testComplete();
+                sharedRealm.close();
+            }
+        });
+        sharedRealm.beginTransaction();
+        sharedRealm.commitTransaction();
+        commitReturns.set(true);
+    }
+
+    private void makeRemoteChanges(final RealmConfiguration config) {
+        new Thread(new Runnable() {
+            @Override
+            public void run() {
+                SharedRealm sharedRealm = getSharedRealm(config);
+                sharedRealm.beginTransaction();
+                sharedRealm.commitTransaction();
+                sharedRealm.close();
+            }
+        }).start();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void addChangeListener_byRemoteChanges() {
+        // To catch https://github.com/realm/realm-java/pull/4037 CI failure.
+        // In this case, object store should not send more than 100 notifications.
+        final int TIMES = 100;
+        final AtomicInteger commitCounter = new AtomicInteger(0);
+        final AtomicInteger listenerCounter = new AtomicInteger(0);
+
+        looperThread.realm.close();
+
+        SharedRealm sharedRealm = getSharedRealm(looperThread.realmConfiguration);
+        looperThread.keepStrongReference.add(sharedRealm);
+        sharedRealm.realmNotifier.addChangeListener(sharedRealm, new RealmChangeListener<SharedRealm>() {
+            @Override
+            public void onChange(SharedRealm sharedRealm) {
+                int commits = commitCounter.get();
+                int listenerCount = listenerCounter.addAndGet(1);
+                assertEquals(commits, listenerCount);
+                if (commits == TIMES) {
+                    sharedRealm.close();
+                    looperThread.testComplete();
+                } else {
+                    makeRemoteChanges(looperThread.realmConfiguration);
+                    commitCounter.getAndIncrement();
+                }
+            }
+        });
+        makeRemoteChanges(looperThread.realmConfiguration);
+        commitCounter.getAndIncrement();
+    }
+
+    @Test
+    @RunTestInLooperThread
+    public void removeChangeListeners() {
+        SharedRealm sharedRealm = getSharedRealm(looperThread.realmConfiguration);
+        Integer dummyObserver = 1;
+        looperThread.keepStrongReference.add(dummyObserver);
+        sharedRealm.realmNotifier.addChangeListener(dummyObserver, new RealmChangeListener<Integer>() {
+            @Override
+            public void onChange(Integer dummy) {
+                fail();
+            }
+        });
+        sharedRealm.realmNotifier.addChangeListener(sharedRealm, new RealmChangeListener<SharedRealm>() {
+            @Override
+            public void onChange(SharedRealm sharedRealm) {
+                sharedRealm.close();
+                looperThread.testComplete();
+            }
+        });
+
+        // This should only remove the listeners related with dummyObserver
+        sharedRealm.realmNotifier.removeChangeListeners(dummyObserver);
+
+        makeRemoteChanges(looperThread.realmConfiguration);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
index 074f535542..fde073a78c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SharedRealmTests.java
@@ -163,7 +163,7 @@ public void beginTransaction_SchemaVersionListener() {
         final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
 
         sharedRealm.close();
-        sharedRealm = SharedRealm.getInstance(config, null, new SharedRealm.SchemaVersionListener() {
+        sharedRealm = SharedRealm.getInstance(config, new SharedRealm.SchemaVersionListener() {
             @Override
             public void onSchemaVersionChanged(long currentVersion) {
                 listenerCalled.set(true);
@@ -202,7 +202,7 @@ public void refresh_SchemaVersionListener() {
         final AtomicLong schemaVersionFromListener = new AtomicLong(-1L);
 
         sharedRealm.close();
-        sharedRealm = SharedRealm.getInstance(config, null, new SharedRealm.SchemaVersionListener() {
+        sharedRealm = SharedRealm.getInstance(config, new SharedRealm.SchemaVersionListener() {
             @Override
             public void onSchemaVersionChanged(long currentVersion) {
                 listenerCalled.set(true);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
new file mode 100644
index 0000000000..b5c26f71fd
--- /dev/null
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/SortDescriptorTests.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import io.realm.RealmConfiguration;
+import io.realm.RealmFieldType;
+import io.realm.Sort;
+import io.realm.rule.TestRealmConfigurationFactory;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertFalse;
+import static junit.framework.Assert.assertNull;
+import static junit.framework.Assert.assertTrue;
+import static junit.framework.Assert.fail;
+
+@RunWith(AndroidJUnit4.class)
+public class SortDescriptorTests {
+    @Rule
+    public final TestRealmConfigurationFactory configFactory = new TestRealmConfigurationFactory();
+    @Rule
+    public final ExpectedException thrown = ExpectedException.none();
+
+    private SharedRealm sharedRealm;
+    private Table table;
+
+    @Before
+    public void setUp() {
+        RealmConfiguration config = configFactory.createConfiguration();
+        sharedRealm = SharedRealm.getInstance(config);
+        sharedRealm.beginTransaction();
+        table = sharedRealm.getTable("test_table");
+    }
+
+    @After
+    public void tearDown() {
+        sharedRealm.close();
+    }
+
+    @Test
+    public void getInstanceForDistinct() {
+        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
+            long column = table.addColumn(type, type.name());
+            table.addSearchIndex(column);
+        }
+
+        long i = 0;
+        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(table, type.name());
+            assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
+            assertEquals(i, sortDescriptor.getColumnIndices()[0][0]);
+            assertNull(sortDescriptor.getAscendings());
+            i++;
+        }
+    }
+
+    @Test
+    public void getInstanceForDistinct_shouldThrowOnLinkAndListListField() {
+        RealmFieldType type = RealmFieldType.STRING;
+        RealmFieldType objectType = RealmFieldType.OBJECT;
+        RealmFieldType listType = RealmFieldType.LIST;
+        table.addColumn(type, type.name());
+        table.addColumnLink(objectType, objectType.name(), table);
+        table.addColumnLink(listType, listType.name(), table);
+
+        try {
+            SortDescriptor.getInstanceForDistinct(table, String.format("%s.%s", listType.name(), type.name()));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+
+        try {
+            SortDescriptor.getInstanceForDistinct(table, String.format("%s.%s", objectType.name(), type.name()));
+            fail();
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+    @Test
+    public void getInstanceForDistinct_multipleFields() {
+        RealmFieldType stringType = RealmFieldType.STRING;
+        long stringColumn = table.addColumn(stringType, stringType.name());
+        table.addSearchIndex(stringColumn);
+        RealmFieldType intType = RealmFieldType.INTEGER;
+        long intColumn = table.addColumn(intType, intType.name());
+        table.addSearchIndex(intColumn);
+
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForDistinct(table, new String[] {
+               stringType.name(), intType.name()});
+        assertEquals(2, sortDescriptor.getColumnIndices().length);
+        assertNull(sortDescriptor.getAscendings());
+        assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
+        assertEquals(stringColumn, sortDescriptor.getColumnIndices()[0][0]);
+        assertEquals(1, sortDescriptor.getColumnIndices()[1].length);
+        assertEquals(intColumn, sortDescriptor.getColumnIndices()[1][0]);
+    }
+
+    @Test
+    public void getInstanceForDistinct_shouldThrowIfNoSearchIndex() {
+        RealmFieldType type = RealmFieldType.STRING;
+        table.addColumn(type, type.name());
+
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("must be indexed");
+        SortDescriptor.getInstanceForDistinct(table, type.name());
+    }
+
+    @Test
+    public void getInstanceForDistinct_shouldThrowOnInvalidField() {
+        List<RealmFieldType> types = new ArrayList<RealmFieldType>();
+        for (RealmFieldType type : RealmFieldType.values()) {
+            if (!SortDescriptor.validFieldTypesForDistinct.contains(type) &&
+                    type != RealmFieldType.UNSUPPORTED_DATE &&
+                    type != RealmFieldType.UNSUPPORTED_TABLE &&
+                    type != RealmFieldType.UNSUPPORTED_MIXED) {
+                if (type == RealmFieldType.LIST || type == RealmFieldType.OBJECT) {
+                    table.addColumnLink(type, type.name(), table);
+                } else {
+                    table.addColumn(type, type.name());
+                }
+                types.add(type);
+            }
+        }
+
+        for (RealmFieldType type : types) {
+            try {
+                SortDescriptor.getInstanceForDistinct(table, type.name());
+                fail();
+            } catch (IllegalArgumentException ignored) {
+                assertTrue(ignored.getMessage().contains("Distinct is not supported"));
+            }
+        }
+    }
+
+    @Test
+    public void getInstanceForSort() {
+        for (RealmFieldType type : SortDescriptor.validFieldTypesForSort) {
+            table.addColumn(type, type.name());
+        }
+
+        long i = 0;
+        for (RealmFieldType type : SortDescriptor.validFieldTypesForSort) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table, type.name(), Sort.DESCENDING);
+            assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
+            assertEquals(i, sortDescriptor.getColumnIndices()[0][0]);
+            assertFalse(sortDescriptor.getAscendings()[0]);
+            i++;
+        }
+    }
+
+    @Test
+    public void getInstanceForSort_linkField() {
+        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
+            long column = table.addColumn(type, type.name());
+            table.addSearchIndex(column);
+        }
+        RealmFieldType objectType = RealmFieldType.OBJECT;
+        long columnLink = table.addColumnLink(objectType, objectType.name(), table);
+
+        long i = 0;
+        for (RealmFieldType type : SortDescriptor.validFieldTypesForDistinct) {
+            SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table,
+                    String.format("%s.%s", objectType.name(), type.name()), Sort.ASCENDING);
+            assertEquals(2, sortDescriptor.getColumnIndices()[0].length);
+            assertEquals(columnLink, sortDescriptor.getColumnIndices()[0][0]);
+            assertEquals(i, sortDescriptor.getColumnIndices()[0][1]);
+            assertTrue(sortDescriptor.getAscendings()[0]);
+            i++;
+        }
+    }
+
+    @Test
+    public void getInstanceForSort_multipleFields() {
+        RealmFieldType stringType = RealmFieldType.STRING;
+        long stringColumn = table.addColumn(stringType, stringType.name());
+        RealmFieldType intType = RealmFieldType.INTEGER;
+        long intColumn = table.addColumn(intType, intType.name());
+
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(table, new String[] {
+                stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING, Sort.DESCENDING});
+
+        assertEquals(2, sortDescriptor.getAscendings().length);
+        assertEquals(2, sortDescriptor.getColumnIndices().length);
+
+        assertEquals(1, sortDescriptor.getColumnIndices()[0].length);
+        assertEquals(stringColumn, sortDescriptor.getColumnIndices()[0][0]);
+        assertTrue(sortDescriptor.getAscendings()[0]);
+
+        assertEquals(1, sortDescriptor.getColumnIndices()[1].length);
+        assertEquals(intColumn, sortDescriptor.getColumnIndices()[1][0]);
+        assertFalse(sortDescriptor.getAscendings()[1]);
+
+    }
+
+    @Test
+    public void getInstanceForSort_numOfFeildsAndSortOrdersNotMatch() {
+        RealmFieldType stringType = RealmFieldType.STRING;
+        table.addColumn(stringType, stringType.name());
+        RealmFieldType intType = RealmFieldType.INTEGER;
+        table.addColumn(intType, intType.name());
+
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("Number of fields and sort orders do not match.");
+        SortDescriptor.getInstanceForSort(table,
+                new String[] { stringType.name(), intType.name()}, new Sort[] {Sort.ASCENDING});
+
+    }
+
+    @Test
+    public void getInstanceForSort_shouldThrowOnInvalidField() {
+        List<RealmFieldType> types = new ArrayList<RealmFieldType>();
+        for (RealmFieldType type : RealmFieldType.values()) {
+            if (!SortDescriptor.validFieldTypesForSort.contains(type) &&
+                    type != RealmFieldType.UNSUPPORTED_DATE &&
+                    type != RealmFieldType.UNSUPPORTED_TABLE&&
+                    type != RealmFieldType.UNSUPPORTED_MIXED) {
+                if (type == RealmFieldType.LIST || type == RealmFieldType.OBJECT) {
+                    table.addColumnLink(type, type.name(), table);
+                } else {
+                    table.addColumn(type, type.name());
+                }
+                types.add(type);
+            }
+        }
+
+        for (RealmFieldType type : types) {
+            try {
+                SortDescriptor.getInstanceForSort(table, type.name(), Sort.ASCENDING);
+                fail();
+            } catch (IllegalArgumentException ignored) {
+                assertTrue(ignored.getMessage().contains("Sort is not supported"));
+            }
+        }
+    }
+
+    @Test
+    public void getInstanceForSort_shouldThrowOnLinkListField() {
+        RealmFieldType type = RealmFieldType.STRING;
+        RealmFieldType listType = RealmFieldType.LIST;
+        table.addColumn(type, type.name());
+        table.addColumnLink(listType, listType.name(), table);
+
+        thrown.expect(IllegalArgumentException.class);
+        thrown.expectMessage("is not a supported link field");
+        SortDescriptor.getInstanceForSort(table, String.format("%s.%s", listType.name(), type.name()), Sort.ASCENDING);
+    }
+}
diff --git a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
index ab4261f680..041c45ced3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/internal/TableIndexAndDistinctTest.java
@@ -39,47 +39,6 @@ void init() {
         assertEquals(7, table.size());
     }
 
-    public void testShouldTestDistinct() {
-        init();
-
-        // Must set index before using distinct().
-        table.addSearchIndex(1);
-        assertEquals(true, table.hasSearchIndex(1));
-
-        TableView view = table.getDistinctView(1);
-        assertEquals(4, view.size());
-        assertEquals(0, view.getLong(0, 0));
-        assertEquals(1, view.getLong(0, 1));
-        assertEquals(2, view.getLong(0, 2));
-        assertEquals(4, view.getLong(0, 3));
-    }
-
-// TODO: parametric test
-/*    *//**
-     * Should throw exception if trying to get distinct on columns where index has not been set.
-     * @param index
-     *//*
-
-    @Test(expectedExceptions = UnsupportedOperationException.class, dataProvider = "columnIndex")
-    public void shouldTestDistinctErrorWhenNoIndex(Long index) {
-
-        // Gets a table with all available column types.
-        Table t = TestHelper.getTableWithAllColumnTypes();
-
-        TableView view = table.getDistinctView(1);
-    }*/
-
-    public void testShouldTestDistinctErrorWhenIndexOutOfBounds() {
-        init();
-
-        try {
-            TableView view = table.getDistinctView(3);
-            fail();
-        } catch (ArrayIndexOutOfBoundsException e) {
-            assertNotNull(e);
-        }
-    }
-
     /**
      * Checks that Index can be set on multiple columns, with the String.
      * @param
@@ -131,17 +90,6 @@ public void testShouldCheckIndexIsOkOnColumn() {
         table.addSearchIndex(1);
     }
 
-    public void testShouldThrowDistinctErrorWhenWrongColumnType() {
-        init();
-        table.addSearchIndex(1);
-        try {
-            TableView view = table.getDistinctView(0);
-            fail();
-        } catch (UnsupportedOperationException e) {
-            assertNotNull(e);
-        }
-    }
-
     public void testRemoveSearchIndex() {
         init();
         table.addSearchIndex(1);
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
index 66a072e05f..537dfb67e5 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SessionTests.java
@@ -16,32 +16,23 @@
 
 package io.realm;
 
-import android.content.Context;
-import android.support.test.InstrumentationRegistry;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import io.realm.internal.network.AuthenticationServer;
-import io.realm.internal.network.OkHttpAuthenticationServer;
-import io.realm.internal.objectserver.ObjectServerSession;
 import io.realm.rule.TestRealmConfigurationFactory;
 
 import static io.realm.util.SyncTestUtils.createTestUser;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
 
 @RunWith(AndroidJUnit4.class)
 public class SessionTests {
 
     private static String REALM_URI = "realm://objectserver.realm.io/~/default";
 
-    private Context context;
-    private AuthenticationServer authServer;
     private SyncConfiguration configuration;
     private SyncUser user;
 
@@ -50,30 +41,15 @@
 
     @Before
     public void setUp() {
-        context = InstrumentationRegistry.getContext();
         user = createTestUser();
-        authServer = new OkHttpAuthenticationServer();
         configuration = new SyncConfiguration.Builder(user, REALM_URI).build();
     }
 
-    @After
-    public void tearDown() throws Exception {
-    }
-
     @Test
     public void get_syncValues() {
-        ObjectServerSession internalSession = new ObjectServerSession(
-                configuration,
-                authServer,
-                configuration.getUser().getSyncUser(),
-                configuration.getSyncPolicy(),
-                configuration.getErrorHandler()
-        );
-        SyncSession session = new SyncSession(internalSession);
-
+        SyncSession session = new SyncSession(configuration);
         assertEquals("realm://objectserver.realm.io/JohnDoe/default", session.getServerUrl().toString());
         assertEquals(user, session.getUser());
         assertEquals(configuration, session.getConfiguration());
-        assertNull(session.getState());
     }
 }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
index 35038d786a..3b7a2a466f 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncConfigurationTests.java
@@ -70,6 +70,7 @@ public void setUp() {
 
     @After
     public void tearDown() throws Exception {
+        SyncManager.reset();
     }
 
     @Test
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
index 47fb8dd437..25caf4fb6a 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncManagerTests.java
@@ -24,8 +24,8 @@
 import org.junit.rules.ExpectedException;
 import org.junit.runner.RunWith;
 
+import java.io.IOException;
 import java.util.Collection;
-import java.util.Set;
 
 import io.realm.rule.TestRealmConfigurationFactory;
 
@@ -71,20 +71,6 @@ public void remove(String identity) {}
         };
     }
 
-    @Test
-    public void init() {
-        // Realm.init() calls SyncManager.init() which will start a thread for the sync client
-        boolean found = false;
-        Set<Thread> threads = Thread.getAllStackTraces().keySet();
-        for (Thread thread : threads) {
-            if (thread.getName().equals("RealmSyncClient")) {
-                found = true;
-                break;
-            }
-        }
-        assertTrue(found);
-    }
-
     @Test
     public void set_userStore() {
         SyncManager.setUserStore(userStore);
@@ -153,14 +139,14 @@ public void loggedOut(SyncUser user) {
         assertEquals(0, counter[0]);
         assertEquals(0, counter[1]);
     }
-
     @Test
-    public void session() {
+    public void session() throws IOException {
         SyncUser user = createTestUser();
         String url = "realm://objectserver.realm.io/default";
         SyncConfiguration config = new SyncConfiguration.Builder(user, url)
                 .build();
-
+        // This will trigger the creation of the session
+        Realm.getInstance(config);
         SyncSession session = SyncManager.getSession(config);
         assertEquals(user, session.getUser()); // see also SessionTests
     }
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
index 116fab3a23..3e2c69544c 100644
--- a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncUserTests.java
@@ -63,7 +63,7 @@ public static void initUserStore() {
 
     @After
     public void tearDown() {
-        RealmFileUserStore.nativeResetForTesting();
+        SyncManager.reset();
     }
 
     @Test
@@ -89,6 +89,7 @@ public void currentUser_throwsIfMultipleUsersLoggedIn() {
         AuthenticationServer originalAuthServer = SyncManager.getAuthServer();
         AuthenticationServer authServer = Mockito.mock(AuthenticationServer.class);
         SyncManager.setAuthServerImpl(authServer);
+
         try {
             // 1. Login two random users
             when(authServer.loginUser(any(SyncCredentials.class), any(URL.class))).thenAnswer(new Answer<AuthenticateResponse>() {
diff --git a/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
new file mode 100644
index 0000000000..28f2e3984b
--- /dev/null
+++ b/realm/realm-library/src/androidTestObjectServer/java/io/realm/SyncedRealmMigrationTests.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+import org.junit.runner.RunWith;
+
+import java.io.FileNotFoundException;
+
+import io.realm.rule.TestRealmConfigurationFactory;
+import io.realm.rule.TestSyncConfigurationFactory;
+import io.realm.util.SyncTestUtils;
+
+import static org.junit.Assert.fail;
+
+/**
+ * Testing methods around migrations for Realms using a {@link SyncConfiguration}.
+ */
+@RunWith(AndroidJUnit4.class)
+public class SyncedRealmMigrationTests {
+
+    @Rule
+    public final TestSyncConfigurationFactory configFactory = new TestSyncConfigurationFactory();
+
+    @Test
+    public void migrateRealm_syncConfigurationThrows() {
+        SyncConfiguration config = configFactory.createSyncConfigurationBuilder(SyncTestUtils.createTestUser(), "http://foo.com/auth").build();
+        try {
+            Realm.migrateRealm(config);
+            fail();
+        } catch (FileNotFoundException e) {
+            fail(e.toString());
+        } catch (IllegalArgumentException ignored) {
+        }
+    }
+
+}
diff --git a/realm/realm-library/src/main/cpp/CMakeLists.txt b/realm/realm-library/src/main/cpp/CMakeLists.txt
index 5b84b34a76..1b44bb360b 100644
--- a/realm/realm-library/src/main/cpp/CMakeLists.txt
+++ b/realm/realm-library/src/main/cpp/CMakeLists.txt
@@ -33,18 +33,19 @@ endif()
 string(TOLOWER ${CMAKE_BUILD_TYPE} build_type_FOLDER)
 set(classes_PATH ${CMAKE_SOURCE_DIR}/../../../build/intermediates/classes/${REALM_FLAVOR}/${build_type_FOLDER}/)
 set(classes_LIST
-    io.realm.internal.Table io.realm.internal.TableView io.realm.internal.CheckedRow
+    io.realm.internal.Table io.realm.internal.CheckedRow
     io.realm.internal.LinkView io.realm.internal.Util io.realm.internal.UncheckedRow
     io.realm.internal.TableQuery io.realm.internal.SharedRealm io.realm.internal.TestUtil
     io.realm.log.LogLevel io.realm.log.RealmLog io.realm.Property io.realm.RealmSchema
-    io.realm.RealmObjectSchema io.realm.internal.NativeObjectReference
+    io.realm.RealmObjectSchema io.realm.internal.Collection
+    io.realm.internal.NativeObjectReference io.realm.internal.CollectionChangeSet
 )
 # /./ is the workaround for the problem that AS cannot find the jni headers.
 # See https://github.com/googlesamples/android-ndk/issues/319
 set(jni_headers_PATH /./${PROJECT_BINARY_DIR}/jni_include)
 if (build_SYNC)
     list(APPEND classes_LIST
-        io.realm.SyncManager io.realm.internal.objectserver.ObjectServerSession io.realm.RealmFileUserStore)
+        io.realm.SyncManager io.realm.SyncSession io.realm.RealmFileUserStore)
 endif()
 create_javah(TARGET jni_headers
     CLASSES ${classes_LIST}
@@ -94,7 +95,7 @@ if (NOT EXISTS ${sync_lib_PATH})
     elseif (ARM64_V8A)
         set(sync_lib_PATH ${REALM_CORE_DIST_DIR}/librealm-sync-android-arm64.a)
     else()
-        message(FATAL_ERROR "Cannot find core lib file: ${core_lib_PATH}")
+        message(FATAL_ERROR "Cannot find core lib file: ${sync_lib_PATH}")
     endif()
 endif()
 add_library(lib_realm_sync STATIC IMPORTED)
@@ -153,7 +154,7 @@ file(GLOB jni_SRC
 if (NOT build_SYNC)
     list(REMOVE_ITEM jni_SRC
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncManager.cpp
-        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_internal_objectserver_ObjectServerSession.cpp
+        ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_SyncSession.cpp
         ${CMAKE_CURRENT_SOURCE_DIR}/io_realm_RealmFileUserStore.cpp)
 endif()
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
index 076fb54292..348693b7dc 100644
--- a/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_RealmFileUserStore.cpp
@@ -105,11 +105,3 @@ Java_io_realm_RealmFileUserStore_nativeGetAllUsers (JNIEnv *env, jclass)
     }
     return nullptr;
 }
-
-JNIEXPORT void JNICALL
-Java_io_realm_RealmFileUserStore_nativeResetForTesting (JNIEnv *, jclass)
-{
-    TR_ENTER();
-    SyncManager::shared().reset_for_testing();
-}
-
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
index fb45d1936f..a4056c74e5 100644
--- a/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncManager.cpp
@@ -25,41 +25,60 @@
 #include <realm/sync/history.hpp>
 #include <realm/sync/client.hpp>
 
-#include "objectserver_shared.hpp"
-
 #include "io_realm_SyncManager.h"
 
-#include "jni_util/log.hpp"
-#include "jni_util/jni_utils.hpp"
-#include "sync/sync_manager.hpp"
-#include "sync/sync_user.hpp"
+#include "object-store/src/sync/sync_manager.hpp"
+
+#include "binding_callback_thread_observer.hpp"
 #include "util.hpp"
 
+#include "jni_util/jni_utils.hpp"
+#include "jni_util/java_method.hpp"
+
 using namespace realm;
 using namespace realm::sync;
 using namespace realm::jni_util;
 
 std::unique_ptr<Client> sync_client;
 
+struct AndroidClientListener : public realm::BindingCallbackThreadObserver {
+
+    void did_create_thread() override {
+        Log::d("SyncClient thread created");
+        // Attach the sync client thread to the JVM so errors can be returned properly
+        JniUtils::get_env(true);
+    }
+
+    void will_destroy_thread() override {
+        Log::d("SyncClient thread destroyed");
+        // Failing to detach the JVM before closing the thread will crash on ART
+        JniUtils::detach_current_thread();
+    }
+} s_client_thread_listener;
+
 JNIEXPORT void JNICALL Java_io_realm_SyncManager_nativeInitializeSyncClient
-    (JNIEnv *env, jclass)
+    (JNIEnv* env, jclass)
 {
     TR_ENTER()
     if (sync_client) return;
 
     try {
+        // Setup SyncManager
+        g_binding_callback_thread_observer = &s_client_thread_listener;
+
+        // Create SyncClient
         sync::Client::Config config;
         config.logger = &CoreLoggerBridge::shared();
         sync_client = std::make_unique<Client>(std::move(config)); // Throws
     } CATCH_STD()
 }
 
-// Create the thread from java side to avoid some strange errors when native throws.
 JNIEXPORT void JNICALL
-Java_io_realm_SyncManager_nativeRunClient(JNIEnv *env, jclass)
-{
+Java_io_realm_SyncManager_nativeReset(JNIEnv* env, jclass) {
+
+    TR_ENTER()
     try {
-        sync_client->run();
+        SyncManager::shared().reset_for_testing();
     } CATCH_STD()
 }
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
new file mode 100644
index 0000000000..e3a58bbad2
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_SyncSession.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+
+#include "io_realm_SyncSession.h"
+
+#include "object-store/src/sync/sync_manager.hpp"
+#include "object-store/src/sync/sync_session.hpp"
+
+#include "util.hpp"
+
+using namespace std;
+using namespace realm;
+using namespace sync;
+
+JNIEXPORT jboolean JNICALL Java_io_realm_SyncSession_nativeRefreshAccessToken(JNIEnv* env, jclass,
+                                                                              jstring localRealmPath,
+                                                                              jstring accessToken,
+                                                                              jstring sync_realm_url)
+{
+    TR_ENTER()
+    try {
+        JStringAccessor local_realm_path(env, localRealmPath);
+        auto session = SyncManager::shared().get_existing_session(local_realm_path);
+        if (session) {
+            JStringAccessor access_token(env, accessToken);
+            JStringAccessor realm_url(env, sync_realm_url);
+            session->refresh_access_token(access_token, std::string(realm_url));
+            return JNI_TRUE;
+        }
+        else {
+            realm::jni_util::Log::d("no active/inactive session found");
+        }
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
new file mode 100644
index 0000000000..e17d47f692
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Collection.cpp
@@ -0,0 +1,435 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <jni.h>
+#include "io_realm_internal_Collection.h"
+
+#include <shared_realm.hpp>
+#include <results.hpp>
+
+#include "java_sort_descriptor.hpp"
+#include "util.hpp"
+
+#include "jni_util/java_global_weak_ref.hpp"
+#include "jni_util/java_method.hpp"
+
+using namespace realm;
+using namespace realm::jni_util;
+using namespace realm::_impl;
+
+// We need to control the life cycle of Results, weak ref of Java Collection object and the NotificationToken.
+// Wrap all three together, so when the Java Collection object gets GCed, all three of them will be invalidated.
+struct ResultsWrapper {
+    JavaGlobalWeakRef m_collection_weak_ref;
+    NotificationToken m_notification_token;
+    Results m_results;
+
+    ResultsWrapper(Results& results)
+    : m_collection_weak_ref(), m_notification_token(), m_results(std::move(results)) {}
+
+    ResultsWrapper(ResultsWrapper&&) = delete;
+    ResultsWrapper& operator=(ResultsWrapper&&) = delete;
+
+    ResultsWrapper(ResultsWrapper const&) = delete;
+    ResultsWrapper& operator=(ResultsWrapper const&) = delete;
+
+    ~ResultsWrapper() {}
+};
+
+static void finalize_results(jlong ptr);
+
+static void finalize_results(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<ResultsWrapper*>(ptr);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeCreateResults(JNIEnv* env, jclass, jlong shared_realm_ptr, jlong query_ptr,
+        jobject sort_desc, jobject distinct_desc)
+{
+    TR_ENTER()
+    try {
+        auto query = reinterpret_cast<Query*>(query_ptr);
+        if (!QUERY_VALID(env, query)) {
+            return reinterpret_cast<jlong>(nullptr);
+        }
+
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        Results results(shared_realm, *query,
+                        SortDescriptor(JavaSortDescriptor(env, sort_desc)),
+                        SortDescriptor(JavaSortDescriptor(env, distinct_desc)));
+        auto wrapper = new ResultsWrapper(results);
+
+        return reinterpret_cast<jlong>(wrapper);
+    } CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeCreateResultsFromLinkView(JNIEnv* env, jclass, jlong shared_realm_ptr,
+                                                                  jlong link_view_ptr, jobject sort_desc)
+{
+    TR_ENTER()
+    try {
+        auto link_view_ref = reinterpret_cast<LinkViewRef*>(link_view_ptr);
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        Results results(shared_realm, *link_view_ref, util::none,
+                        SortDescriptor(JavaSortDescriptor(env, sort_desc)));
+        auto wrapper = new ResultsWrapper(results);
+
+        return reinterpret_cast<jlong>(wrapper);
+    } CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeCreateSnapshot(JNIEnv* env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr);
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto snapshot_results = wrapper->m_results.snapshot();
+        auto snapshot_wrapper = new ResultsWrapper(snapshot_results);
+        return reinterpret_cast<jlong>(snapshot_wrapper);
+    } CATCH_STD();
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_Collection_nativeContains(JNIEnv *env, jclass, jlong native_ptr, jlong native_row_ptr)
+{
+    TR_ENTER_PTR(native_ptr);
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto row = reinterpret_cast<Row*>(native_row_ptr);
+        size_t index = wrapper->m_results.index_of(*row);
+        return to_jbool(index != not_found);
+    } CATCH_STD();
+    return JNI_FALSE;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeGetRow(JNIEnv *env, jclass, jlong native_ptr, jint index)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto row = wrapper->m_results.get(static_cast<size_t>(index));
+        return reinterpret_cast<jlong>(new Row(std::move(row)));
+    } CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeFirstRow(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto optional_row = wrapper->m_results.first();
+        if (optional_row) {
+            return reinterpret_cast<jlong>(new Row(std::move(optional_row.value())));
+        }
+    } CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeLastRow(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto optional_row = wrapper->m_results.last();
+        if (optional_row) {
+            return reinterpret_cast<jlong>(new Row(std::move(optional_row.value())));
+        }
+    } CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Collection_nativeClear(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        wrapper->m_results.clear();
+    } CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeSize(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        return static_cast<jlong>(wrapper->m_results.size());
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jobject JNICALL
+Java_io_realm_internal_Collection_nativeAggregate(JNIEnv *env, jclass, jlong native_ptr, jlong column_index,
+        jbyte agg_func)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+
+        size_t index = S(column_index);
+        Optional<Mixed> value;
+        switch (agg_func) {
+            case io_realm_internal_Collection_AGGREGATE_FUNCTION_MINIMUM:
+                value = wrapper->m_results.min(index);
+                break;
+            case io_realm_internal_Collection_AGGREGATE_FUNCTION_MAXIMUM:
+                value = wrapper->m_results.max(index);
+                break;
+            case io_realm_internal_Collection_AGGREGATE_FUNCTION_AVERAGE:
+                value = wrapper->m_results.average(index);
+                if (!value) {
+                    value = Optional<Mixed>(0.0);
+                }
+                break;
+            case io_realm_internal_Collection_AGGREGATE_FUNCTION_SUM:
+                value = wrapper->m_results.sum(index);
+                break;
+            default:
+                REALM_UNREACHABLE();
+        }
+
+        if (!value) {
+            return static_cast<jobject>(nullptr);
+        }
+
+        Mixed m = *value;
+        switch (m.get_type()) {
+            case type_Int:
+                return NewLong(env, m.get_int());
+            case type_Float:
+                return NewFloat(env, m.get_float());
+            case type_Double:
+                return NewDouble(env, m.get_double());
+            case type_Timestamp:
+                return NewDate(env, m.get_timestamp());
+            default:
+                throw std::invalid_argument("Excepted numeric type");
+        }
+    } CATCH_STD()
+    return static_cast<jobject>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeSort(JNIEnv *env, jclass, jlong native_ptr, jobject sort_desc)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto sorted_result = wrapper->m_results.sort(JavaSortDescriptor(env, sort_desc));
+        return reinterpret_cast<jlong>(new ResultsWrapper(sorted_result));
+    } CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeDistinct(JNIEnv *env, jclass, jlong native_ptr, jobject distinct_desc) {
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto distinct_result = wrapper->m_results.distinct(JavaSortDescriptor(env, distinct_desc));
+        return reinterpret_cast<jlong>(new ResultsWrapper(distinct_result));
+    } CATCH_STD()
+    return reinterpret_cast<jlong>(nullptr);
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Collection_nativeStartListening(JNIEnv* env, jobject instance, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    static JavaMethod notify_change_listeners(env, instance, "notifyChangeListeners", "(J)V");
+
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        if (!wrapper->m_collection_weak_ref) {
+            wrapper->m_collection_weak_ref = JavaGlobalWeakRef(env, instance);
+        }
+
+        auto cb = [=](CollectionChangeSet const& changes, std::exception_ptr err) {
+            // OS will call all notifiers' callback in one run, so check the Java exception first!!
+            if (env->ExceptionCheck()) return;
+
+            if (err) {
+                try {
+                    std::rethrow_exception(err);
+                } catch(const std::exception& e) {
+                    realm::jni_util::Log::e("Caught exception in collection change callback %1", e.what());
+                    return;
+                }
+            }
+
+            wrapper->m_collection_weak_ref.call_with_local_ref(env, [&] (JNIEnv* local_env, jobject collection_obj) {
+                local_env->CallVoidMethod(collection_obj, notify_change_listeners,
+                                          reinterpret_cast<jlong>(changes.empty() ? 0 : new CollectionChangeSet(changes)));
+            });
+        };
+
+        wrapper->m_notification_token =  wrapper->m_results.add_notification_callback(cb);
+    } CATCH_STD()
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Collection_nativeStopListening(JNIEnv *env, jobject, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        wrapper->m_notification_token = {};
+    } CATCH_STD()
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeGetFinalizerPtr(JNIEnv *, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_results);
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeWhere(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+
+        auto table_view = wrapper->m_results.get_tableview();
+        Query *query = new Query(table_view.get_parent(),
+                                 std::unique_ptr<TableViewBase>(new TableView(std::move(table_view))));
+        return reinterpret_cast<jlong>(query);
+    } CATCH_STD()
+    return 0;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeIndexOf(JNIEnv *env, jclass, jlong native_ptr, jlong row_native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto row = reinterpret_cast<Row*>(row_native_ptr);
+
+        return static_cast<jlong>(wrapper->m_results.index_of(*row));
+    } CATCH_STD()
+    return npos;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_Collection_nativeIndexOfBySourceRowIndex(JNIEnv *env, jclass, jlong native_ptr,
+                                                                jlong source_row_index)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto index = static_cast<size_t>(source_row_index);
+
+        return static_cast<jlong>(wrapper->m_results.index_of(index));
+    } CATCH_STD()
+    return npos;
+
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_Collection_nativeDeleteLast(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto row = wrapper->m_results.last();
+        if (row && row->is_attached()) {
+            row->move_last_over();
+            return JNI_TRUE;
+        }
+    } CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_Collection_nativeDeleteFirst(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto row = wrapper->m_results.first();
+        if (row && row->is_attached()) {
+            row->move_last_over();
+            return JNI_TRUE;
+        }
+    } CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT void JNICALL
+Java_io_realm_internal_Collection_nativeDelete(JNIEnv *env, jclass, jlong native_ptr, jlong index)
+{
+    TR_ENTER_PTR(native_ptr)
+
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        auto row = wrapper->m_results.get(index);
+        if (row.is_attached()) {
+            row.move_last_over();
+        }
+    } CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL
+Java_io_realm_internal_Collection_nativeIsValid(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        return wrapper->m_results.is_valid();
+    } CATCH_STD()
+    return JNI_FALSE;
+}
+
+JNIEXPORT jbyte JNICALL
+Java_io_realm_internal_Collection_nativeGetMode(JNIEnv *env, jclass, jlong native_ptr)
+{
+    TR_ENTER_PTR(native_ptr)
+    try {
+        auto wrapper = reinterpret_cast<ResultsWrapper*>(native_ptr);
+        switch (wrapper->m_results.get_mode()) {
+            case Results::Mode::Empty:
+                return io_realm_internal_Collection_MODE_EMPTY;
+            case Results::Mode::Table:
+                return io_realm_internal_Collection_MODE_TABLE;
+            case Results::Mode::Query:
+                return io_realm_internal_Collection_MODE_QUERY;
+            case Results::Mode::LinkView:
+                return io_realm_internal_Collection_MODE_LINKVIEW;
+            case Results::Mode::TableView:
+                return io_realm_internal_Collection_MODE_TABLEVIEW;
+        }
+    } CATCH_STD()
+    return -1; // Invalid mode value
+}
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp
new file mode 100644
index 0000000000..450324c171
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_CollectionChangeSet.cpp
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "io_realm_internal_CollectionChangeSet.h"
+
+#include <collection_notifications.hpp>
+
+#include "util.hpp"
+
+using namespace realm;
+
+static void finalize_changeset(jlong ptr);
+static jintArray index_set_to_jint_array(JNIEnv* env, const IndexSet& index_set);
+static jintArray index_set_to_indices_array(JNIEnv* env, const IndexSet& index_set);
+
+static void finalize_changeset(jlong ptr)
+{
+    TR_ENTER_PTR(ptr);
+    delete reinterpret_cast<CollectionChangeSet*>(ptr);
+}
+
+static jintArray index_set_to_jint_array(JNIEnv* env, const IndexSet& index_set)
+{
+    if (index_set.empty()) {
+        return env->NewIntArray(0);
+    }
+
+    std::vector<jint> ranges_vector;
+    for (auto& changes : index_set) {
+        ranges_vector.push_back(changes.first);
+        ranges_vector.push_back(changes.second - changes.first);
+    }
+
+    if (ranges_vector.size() > io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH) {
+        std::ostringstream error_msg;
+        error_msg << "There are too many ranges changed in this change set. They cannot fit into an array." <<
+            " ranges_vector's size: " << ranges_vector.size() <<
+            " Java array's max size: " << io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH << ".";
+        ThrowException(env, IllegalState, error_msg.str());
+        return nullptr;
+    }
+    jintArray jint_array = env->NewIntArray(static_cast<jsize>(ranges_vector.size()));
+    env->SetIntArrayRegion(jint_array, 0, ranges_vector.size(), ranges_vector.data());
+    return jint_array;
+}
+
+static jintArray index_set_to_indices_array(JNIEnv* env, const IndexSet& index_set)
+{
+    if (index_set.empty()) {
+        return env->NewIntArray(0);
+    }
+
+    std::vector<jint> indices_vector;
+    for (auto index : index_set.as_indexes()) {
+        indices_vector.push_back(index);
+    }
+    if (indices_vector.size() > io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH) {
+        std::ostringstream error_msg;
+        error_msg << "There are too many indices in this change set. They cannot fit into an array." <<
+            " indices_vector's size: " << indices_vector.size() <<
+            " Java array's max size: " << io_realm_internal_CollectionChangeSet_MAX_ARRAY_LENGTH << ".";
+        ThrowException(env, IllegalState, error_msg.str());
+        return nullptr;
+    }
+    jintArray jint_array = env->NewIntArray(static_cast<jsize>(indices_vector.size()));
+    env->SetIntArrayRegion(jint_array, 0, indices_vector.size(), indices_vector.data());
+    return jint_array;
+}
+
+JNIEXPORT jlong JNICALL
+Java_io_realm_internal_CollectionChangeSet_nativeGetFinalizerPtr(JNIEnv*, jclass)
+{
+    TR_ENTER()
+    return reinterpret_cast<jlong>(&finalize_changeset);
+}
+
+JNIEXPORT jintArray JNICALL
+Java_io_realm_internal_CollectionChangeSet_nativeGetRanges(JNIEnv *env, jclass, jlong native_ptr, jint type)
+{
+    TR_ENTER_PTR(native_ptr)
+    // no throws
+    auto& change_set = *reinterpret_cast<CollectionChangeSet*>(native_ptr);
+    switch (type) {
+        case io_realm_internal_CollectionChangeSet_TYPE_DELETION:
+            return index_set_to_jint_array(env, change_set.deletions);
+        case io_realm_internal_CollectionChangeSet_TYPE_INSERTION:
+            return index_set_to_jint_array(env, change_set.insertions);
+        case io_realm_internal_CollectionChangeSet_TYPE_MODIFICATION:
+            return index_set_to_jint_array(env, change_set.modifications_new);
+        default:
+            REALM_UNREACHABLE();
+            break;
+    }
+}
+
+JNIEXPORT jintArray JNICALL
+Java_io_realm_internal_CollectionChangeSet_nativeGetIndices(JNIEnv *env, jclass, jlong native_ptr, jint type)
+{
+    TR_ENTER_PTR(native_ptr)
+    // no throws
+    auto& change_set = *reinterpret_cast<CollectionChangeSet*>(native_ptr);
+    switch (type) {
+        case io_realm_internal_CollectionChangeSet_TYPE_DELETION:
+            return index_set_to_indices_array(env, change_set.deletions);
+        case io_realm_internal_CollectionChangeSet_TYPE_INSERTION:
+            return index_set_to_indices_array(env, change_set.insertions);
+        case io_realm_internal_CollectionChangeSet_TYPE_MODIFICATION:
+            return index_set_to_indices_array(env, change_set.modifications_new);
+        default:
+            REALM_UNREACHABLE();
+            break;
+    }
+}
+
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
index 1e320e876b..ab6f952cdd 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_SharedRealm.cpp
@@ -1,102 +1,214 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include "io_realm_internal_SharedRealm.h"
-#ifdef REALM_ENABLE_SYNC
+#if REALM_ENABLE_SYNC
 #include "object-store/src/sync/sync_manager.hpp"
 #include "object-store/src/sync/sync_config.hpp"
+#include "object-store/src/sync/sync_session.hpp"
 #endif
 
-#include <realm/util/features.h>
+#include <shared_realm.hpp>
 
 #include "object_store.hpp"
-#include "shared_realm.hpp"
-
 #include "java_binding_context.hpp"
 #include "util.hpp"
-#if REALM_ENABLE_SYNC
-#include "sync/sync_manager.hpp"
-#endif
+
+#include "jni_util/java_method.hpp"
 
 using namespace realm;
 using namespace realm::_impl;
+using namespace realm::jni_util;
 
 static_assert(SchemaMode::Automatic ==
-                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_AUTOMATIC), "");
+                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_AUTOMATIC),
+              "");
 static_assert(SchemaMode::ReadOnly ==
-                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_READONLY), "");
+                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_READONLY),
+              "");
 static_assert(SchemaMode::ResetFile ==
-                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_RESET_FILE), "");
+                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_RESET_FILE),
+              "");
 static_assert(SchemaMode::Additive ==
-                      static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_ADDITIVE), "");
-static_assert(SchemaMode::Manual ==
-              static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_MANUAL), "");
+                  static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_ADDITIVE),
+              "");
+static_assert(SchemaMode::Manual == static_cast<SchemaMode>(io_realm_internal_SharedRealm_SCHEMA_MODE_VALUE_MANUAL),
+              "");
 
 static void finalize_shared_realm(jlong ptr);
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv *env, jclass, jstring temporary_directory_path)
+// Wrapper class for SyncConfig. This is required as we need to keep track of the Java session
+// object as part of the configuration.
+class JniConfigWrapper {
+
+public:
+    JniConfigWrapper(const JniConfigWrapper&) = delete;
+
+    JniConfigWrapper& operator=(const JniConfigWrapper&) = delete;
+    JniConfigWrapper(JniConfigWrapper&&) = delete;
+    JniConfigWrapper& operator=(JniConfigWrapper&&) = delete;
+
+    // Non-sync constructor
+    JniConfigWrapper(JNIEnv*, Realm::Config& config)
+        : m_config(std::move(config))
+    {
+    }
+
+    // Sync constructor
+    JniConfigWrapper(REALM_UNUSED JNIEnv* env, REALM_UNUSED Realm::Config& config,
+                     REALM_UNUSED jstring sync_realm_url, REALM_UNUSED jstring sync_realm_auth_url,
+                     REALM_UNUSED jstring sync_user_identity, REALM_UNUSED jstring sync_refresh_token)
+        : m_config(std::move(config))
+    {
+#if REALM_ENABLE_SYNC
+        // Doing the methods lookup from the thread that loaded the lib, to avoid
+        // https://developer.android.com/training/articles/perf-jni.html#faq_FindClass
+        static JavaMethod java_error_callback_method(env, java_syncmanager, "notifyErrorHandler",
+                                                     "(ILjava/lang/String;Ljava/lang/String;)V", true);
+        static JavaMethod java_bind_session_method(env, java_syncmanager, "bindSessionWithConfig",
+                                                   "(Ljava/lang/String;)Ljava/lang/String;", true);
+
+        // error handler will be called form the sync client thread
+        auto error_handler = [=](std::shared_ptr<SyncSession> session, SyncError error) {
+            realm::jni_util::Log::d("error_handler lambda invoked");
+
+            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+
+            env->CallStaticVoidMethod(java_syncmanager, java_error_callback_method, error.error_code.value(),
+                                      to_jstring(env, error.message), to_jstring(env, session.get()->path()));
+        };
+
+        // path on disk of the Realm file.
+        // the sync configuration object.
+        // the session which should be bound.
+        auto bind_handler = [=](const std::string& path, const SyncConfig& syncConfig,
+                                std::shared_ptr<SyncSession> session) {
+            realm::jni_util::Log::d("Callback to Java requesting token for path");
+
+            JNIEnv* env = realm::jni_util::JniUtils::get_env(true);
+
+            jstring access_token_string = (jstring)env->CallStaticObjectMethod(
+                java_syncmanager, java_bind_session_method, to_jstring(env, path.c_str()));
+            if (access_token_string) {
+                // reusing cached valid token
+                JStringAccessor access_token(env, access_token_string);
+                session->refresh_access_token(access_token, realm::util::Optional<std::string>(syncConfig.realm_url));
+            }
+        };
+        // Get logged in user
+        JStringAccessor user_identity(env, sync_user_identity);
+        JStringAccessor realm_url(env, sync_realm_url);
+        std::shared_ptr<SyncUser> user = SyncManager::shared().get_existing_logged_in_user(user_identity);
+        if (!user) {
+            JStringAccessor realm_auth_url(env, sync_realm_auth_url);
+            JStringAccessor refresh_token(env, sync_refresh_token);
+            user = SyncManager::shared().get_user(user_identity, refresh_token,
+                                                  realm::util::Optional<std::string>(realm_auth_url));
+        }
+        m_config.sync_config = std::make_shared<SyncConfig>(SyncConfig{
+            user, realm_url, SyncSessionStopPolicy::Immediately, std::move(bind_handler), std::move(error_handler)});
+#else
+        REALM_UNREACHABLE();
+#endif
+    }
+
+    inline Realm::Config& get_config()
+    {
+        return m_config;
+    }
+
+    ~JniConfigWrapper()
+    {
+    }
+
+private:
+    Realm::Config m_config;
+};
+
+
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeInit(JNIEnv* env, jclass,
+                                                                     jstring temporary_directory_path)
 {
     TR_ENTER()
 
     try {
-        JStringAccessor path(env, temporary_directory_path); // throws
-        realm::set_temporary_directory(std::string(path)); // throws
-    } CATCH_STD()
+        JStringAccessor path(env, temporary_directory_path);    // throws
+        SharedGroupOptions::set_sys_tmp_dir(std::string(path)); // throws
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_SharedRealm_nativeCreateConfig(JNIEnv *env, jclass, jstring realm_path, jbyteArray key,
-        jbyte schema_mode, jboolean in_memory, jboolean cache, jlong /* schema_version */, jboolean disable_format_upgrade,
-        jboolean auto_change_notification, REALM_UNUSED jstring sync_server_url, jstring /*sync_user_token*/)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeCreateConfig(
+    JNIEnv* env, jclass, jstring realm_path, jbyteArray key, jbyte schema_mode, jboolean in_memory, jboolean cache,
+    jlong /* schema_version */, jboolean disable_format_upgrade, jboolean auto_change_notification,
+    REALM_UNUSED jstring sync_server_url, REALM_UNUSED jstring sync_server_auth_url,
+    REALM_UNUSED jstring sync_user_identity, REALM_UNUSED jstring sync_refresh_token)
 {
     TR_ENTER()
 
     try {
         JStringAccessor path(env, realm_path); // throws
         JniByteArray key_array(env, key);
-        Realm::Config *config = new Realm::Config();
-        config->path = path;
+        Realm::Config config;
+        config.path = path;
         // config->schema_version = schema_version; TODO: Disabled until we remove version handling from Java
-        config->encryption_key = key_array;
-        config->schema_mode = static_cast<SchemaMode>(schema_mode);
-        config->in_memory = in_memory;
-        config->cache = cache;
-        config->disable_format_upgrade = disable_format_upgrade;
-        config->automatic_change_notifications = auto_change_notification;
+        config.encryption_key = key_array;
+        config.schema_mode = static_cast<SchemaMode>(schema_mode);
+        config.in_memory = in_memory;
+        config.cache = cache;
+        config.disable_format_upgrade = disable_format_upgrade;
+        config.automatic_change_notifications = auto_change_notification;
         if (sync_server_url) {
-            config->force_sync_history = true;
+            return reinterpret_cast<jlong>(new JniConfigWrapper(env, config, sync_server_url, sync_server_auth_url,
+                                                                sync_user_identity, sync_refresh_token));
+        }
+        else {
+            return reinterpret_cast<jlong>(new JniConfigWrapper(env, config));
         }
-        return reinterpret_cast<jlong>(config);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 
     return static_cast<jlong>(NULL);
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeCloseConfig(JNIEnv*, jclass, jlong config_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseConfig(JNIEnv*, jclass, jlong config_ptr)
 {
     TR_ENTER_PTR(config_ptr)
 
-    auto config = reinterpret_cast<realm::Realm::Config*>(config_ptr);
+    auto config = reinterpret_cast<JniConfigWrapper*>(config_ptr);
     delete config;
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_SharedRealm_nativeGetSharedRealm(JNIEnv *env, jclass, jlong config_ptr, jobject notifier)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetSharedRealm(JNIEnv* env, jclass, jlong config_ptr,
+                                                                                jobject realm_notifier)
 {
     TR_ENTER_PTR(config_ptr)
 
-    auto config = reinterpret_cast<realm::Realm::Config*>(config_ptr);
+    auto config = reinterpret_cast<JniConfigWrapper*>(config_ptr);
     try {
-        auto shared_realm = Realm::get_shared_realm(*config);
-        shared_realm->m_binding_context = JavaBindingContext::create(env, notifier);
-        // advance_read needs to be handled by Java because of async query.
-        shared_realm->set_auto_refresh(false);
+        auto shared_realm = Realm::get_shared_realm(config->get_config());
+        shared_realm->m_binding_context = JavaBindingContext::create(env, realm_notifier);
         return reinterpret_cast<jlong>(new SharedRealm(std::move(shared_realm)));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return static_cast<jlong>(NULL);
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv*, jclass, jlong shared_realm_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv*, jclass,
+                                                                                 jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -105,42 +217,45 @@ Java_io_realm_internal_SharedRealm_nativeCloseSharedRealm(JNIEnv*, jclass, jlong
     shared_realm->close();
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeBeginTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeBeginTransaction(JNIEnv* env, jclass,
+                                                                                 jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->begin_transaction();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeCommitTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCommitTransaction(JNIEnv* env, jclass,
+                                                                                  jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->commit_transaction();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeCancelTransaction(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeCancelTransaction(JNIEnv* env, jclass,
+                                                                                  jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->cancel_transaction();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_SharedRealm_nativeIsInTransaction(JNIEnv*, jclass, jlong shared_realm_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsInTransaction(JNIEnv*, jclass,
+                                                                                    jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -148,34 +263,35 @@ Java_io_realm_internal_SharedRealm_nativeIsInTransaction(JNIEnv*, jclass, jlong
     return static_cast<jboolean>(shared_realm->is_in_transaction());
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEnv *env, jclass , jlong shared_realm_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeReadGroup(JNIEnv* env, jclass,
+                                                                           jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return reinterpret_cast<jlong>(&shared_realm->read_group());
-    } CATCH_STD()
+    }
+    CATCH_STD()
 
     return static_cast<jlong>(NULL);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetVersion(JNIEnv* env, jclass,
+                                                                            jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jlong>(ObjectStore::get_schema_version(shared_realm->read_group()));
-    } CATCH_STD()
-
+    }
+    CATCH_STD()
     return static_cast<jlong>(ObjectStore::NotVersioned);
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv *env, jclass, jlong shared_realm_ptr, jlong version)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv* env, jclass,
+                                                                           jlong shared_realm_ptr, jlong version)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -189,50 +305,36 @@ Java_io_realm_internal_SharedRealm_nativeSetVersion(JNIEnv *env, jclass, jlong s
         }
 
         ObjectStore::set_schema_version(shared_realm->read_group(), static_cast<uint64_t>(version));
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsEmpty(JNIEnv* env, jclass,
+                                                                            jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jboolean>(ObjectStore::is_empty(shared_realm->read_group()));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return JNI_FALSE;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeRefresh__J(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRefresh(JNIEnv* env, jclass, jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         shared_realm->refresh();
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeRefresh__JJJ(JNIEnv *env, jclass, jlong shared_realm_ptr, jlong version,
-        jlong index)
-{
-    TR_ENTER_PTR(shared_realm_ptr)
-
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-    SharedGroup::VersionID version_id(static_cast<SharedGroup::version_type>(version),
-                                     static_cast<uint32_t>(index));
-    try {
-        using rf = realm::_impl::RealmFriend;
-        auto& shared_group = rf::get_shared_group(*shared_realm);
-        LangBindHelper::advance_read(shared_group, version_id);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jlongArray JNICALL
-Java_io_realm_internal_SharedRealm_nativeGetVersionID(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT jlongArray JNICALL Java_io_realm_internal_SharedRealm_nativeGetVersionID(JNIEnv* env, jclass,
+                                                                                   jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -253,13 +355,13 @@ Java_io_realm_internal_SharedRealm_nativeGetVersionID(JNIEnv *env, jclass, jlong
         env->SetLongArrayRegion(version_data, 0, 2, version_array);
 
         return version_data;
-    } CATCH_STD ()
+    }
+    CATCH_STD()
 
     return NULL;
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_SharedRealm_nativeIsClosed(JNIEnv*, jclass, jlong shared_realm_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsClosed(JNIEnv*, jclass, jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -268,8 +370,8 @@ Java_io_realm_internal_SharedRealm_nativeIsClosed(JNIEnv*, jclass, jlong shared_
 }
 
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv* env, jclass, jlong shared_realm_ptr,
+                                                                          jstring table_name)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -284,13 +386,14 @@ Java_io_realm_internal_SharedRealm_nativeGetTable(JNIEnv *env, jclass, jlong sha
         }
         Table* pTable = LangBindHelper::get_or_add_table(shared_realm->read_group(), name);
         return reinterpret_cast<jlong>(pTable);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 
     return static_cast<jlong>(NULL);
 }
 
-JNIEXPORT jstring JNICALL
-Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv *env, jclass, jlong shared_realm_ptr, jint index)
+JNIEXPORT jstring JNICALL Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv* env, jclass,
+                                                                                jlong shared_realm_ptr, jint index)
 {
 
     TR_ENTER_PTR(shared_realm_ptr)
@@ -298,12 +401,14 @@ Java_io_realm_internal_SharedRealm_nativeGetTableName(JNIEnv *env, jclass, jlong
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return to_jstring(env, shared_realm->read_group().get_table_name(static_cast<size_t>(index)));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return NULL;
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_SharedRealm_nativeHasTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeHasTable(JNIEnv* env, jclass,
+                                                                             jlong shared_realm_ptr,
+                                                                             jstring table_name)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -311,13 +416,15 @@ Java_io_realm_internal_SharedRealm_nativeHasTable(JNIEnv *env, jclass, jlong sha
     try {
         JStringAccessor name(env, table_name);
         return static_cast<jboolean>(shared_realm->read_group().has_table(name));
-    } CATCH_STD()
+    }
+    CATCH_STD()
     return JNI_FALSE;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIEnv *env, jclass, jlong shared_realm_ptr,
-        jstring old_table_name, jstring new_table_name)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIEnv* env, jclass,
+                                                                            jlong shared_realm_ptr,
+                                                                            jstring old_table_name,
+                                                                            jstring new_table_name)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -332,11 +439,13 @@ Java_io_realm_internal_SharedRealm_nativeRenameTable(JNIEnv *env, jclass, jlong
         }
         JStringAccessor new_name(env, new_table_name);
         shared_realm->read_group().rename_table(old_name, new_name);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring table_name)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv* env, jclass,
+                                                                            jlong shared_realm_ptr,
+                                                                            jstring table_name)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
@@ -350,25 +459,25 @@ Java_io_realm_internal_SharedRealm_nativeRemoveTable(JNIEnv *env, jclass, jlong
             return;
         }
         shared_realm->read_group().remove_table(name);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_SharedRealm_nativeSize(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeSize(JNIEnv* env, jclass, jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr)
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jlong>(shared_realm->read_group().size());
-    } CATCH_STD()
+    }
+    CATCH_STD()
 
     return 0;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv *env, jclass, jlong shared_realm_ptr, jstring path,
-        jbyteArray key)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv* env, jclass, jlong shared_realm_ptr,
+                                                                          jstring path, jbyteArray key)
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
@@ -377,11 +486,12 @@ Java_io_realm_internal_SharedRealm_nativeWriteCopy(JNIEnv *env, jclass, jlong sh
         JStringAccessor path_str(env, path);
         JniByteArray key_buffer(env, key);
         shared_realm->write_copy(path_str, key_buffer);
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_SharedRealm_nativeWaitForChange(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeWaitForChange(JNIEnv* env, jclass,
+                                                                                  jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
@@ -389,13 +499,14 @@ Java_io_realm_internal_SharedRealm_nativeWaitForChange(JNIEnv *env, jclass, jlon
     try {
         using rf = realm::_impl::RealmFriend;
         return static_cast<jboolean>(rf::get_shared_group(*shared_realm).wait_for_change());
-    } CATCH_STD()
+    }
+    CATCH_STD()
 
     return JNI_FALSE;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeStopWaitForChange(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeStopWaitForChange(JNIEnv* env, jclass,
+                                                                                  jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
@@ -403,57 +514,62 @@ Java_io_realm_internal_SharedRealm_nativeStopWaitForChange(JNIEnv *env, jclass,
     try {
         using rf = realm::_impl::RealmFriend;
         rf::get_shared_group(*shared_realm).wait_for_change_release();
-    } CATCH_STD()
+    }
+    CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_SharedRealm_nativeCompact(JNIEnv *env, jclass, jlong shared_realm_ptr)
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeCompact(JNIEnv* env, jclass,
+                                                                            jlong shared_realm_ptr)
 {
     TR_ENTER_PTR(shared_realm_ptr);
 
     auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         return static_cast<jboolean>(shared_realm->compact());
-    } CATCH_STD()
+    }
+    CATCH_STD()
 
     return JNI_FALSE;
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_SharedRealm_nativeGetSnapshotVersion(JNIEnv *env, jclass, jlong sharedRealmPtr)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetSnapshotVersion(JNIEnv* env, jclass,
+                                                                                    jlong shared_realm_ptr)
 {
-    TR_ENTER_PTR(sharedRealmPtr)
+    TR_ENTER_PTR(shared_realm_ptr)
 
-    auto shared_realm = *(reinterpret_cast<SharedRealm*>(sharedRealmPtr));
+    auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
     try {
         using rf = realm::_impl::RealmFriend;
         auto& shared_group = rf::get_shared_group(*shared_realm);
         return LangBindHelper::get_version_of_latest_snapshot(shared_group);
-    } CATCH_STD ()
+    }
+    CATCH_STD()
     return 0;
 }
 
-JNIEXPORT void JNICALL
-Java_io_realm_internal_SharedRealm_nativeUpdateSchema(JNIEnv *env, jclass, jlong nativePtr,
-                                                      jlong nativeSchemaPtr, jlong version) {
-    TR_ENTER()
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeUpdateSchema(JNIEnv* env, jclass,
+                                                                             jlong shared_realm_ptr, jlong schema_ptr,
+                                                                             jlong version)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
     try {
-        auto shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
-        auto *schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        auto* schema = reinterpret_cast<Schema*>(schema_ptr);
         shared_realm->update_schema(*schema, static_cast<uint64_t>(version), nullptr, true);
     }
     CATCH_STD()
 }
 
-JNIEXPORT jboolean JNICALL
-Java_io_realm_internal_SharedRealm_nativeRequiresMigration(JNIEnv *env, jclass, jlong nativePtr,
-                                                           jlong nativeSchemaPtr) {
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeRequiresMigration(JNIEnv* env, jclass,
+                                                                                      jlong nativePtr,
+                                                                                      jlong nativeSchemaPtr)
+{
 
     TR_ENTER()
     try {
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(nativePtr));
-        auto *schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
-        const std::vector<SchemaChange> &change_list = shared_realm->schema().compare(*schema);
+        auto* schema = reinterpret_cast<Schema*>(nativeSchemaPtr);
+        const std::vector<SchemaChange>& change_list = shared_realm->schema().compare(*schema);
         return static_cast<jboolean>(!change_list.empty());
     }
     CATCH_STD()
@@ -466,10 +582,32 @@ static void finalize_shared_realm(jlong ptr)
     delete reinterpret_cast<SharedRealm*>(ptr);
 }
 
-JNIEXPORT jlong JNICALL
-Java_io_realm_internal_SharedRealm_nativeGetFinalizerPtr(JNIEnv*, jclass)
+JNIEXPORT jlong JNICALL Java_io_realm_internal_SharedRealm_nativeGetFinalizerPtr(JNIEnv*, jclass)
 {
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_shared_realm);
 }
 
+JNIEXPORT void JNICALL Java_io_realm_internal_SharedRealm_nativeSetAutoRefresh(JNIEnv* env, jclass,
+                                                                               jlong shared_realm_ptr,
+                                                                               jboolean enabled)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        shared_realm->set_auto_refresh(to_bool(enabled));
+    }
+    CATCH_STD()
+}
+
+JNIEXPORT jboolean JNICALL Java_io_realm_internal_SharedRealm_nativeIsAutoRefresh(JNIEnv* env, jclass,
+                                                                                  jlong shared_realm_ptr)
+{
+    TR_ENTER_PTR(shared_realm_ptr)
+    try {
+        auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
+        return to_jbool(shared_realm->auto_refresh());
+    }
+    CATCH_STD()
+    return JNI_FALSE;
+}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
index c42b2b23ad..60e7bcf85a 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Table.cpp
@@ -1178,52 +1178,8 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindFirstNull(
 
 // FindAll
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllInt(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jlong value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Int))
-        return 0;
-    try {
-        TableView* pTableView = new TableView( TBL(nativeTablePtr)->find_all_int( S(columnIndex), value) );
-        return reinterpret_cast<jlong>(pTableView);
-    } CATCH_STD()
-    return 0;
-}
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllFloat(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jfloat value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Float))
-        return 0;
-    try {
-        TableView* pTableView = new TableView( TBL(nativeTablePtr)->find_all_float( S(columnIndex), value) );
-        return reinterpret_cast<jlong>(pTableView);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllDouble(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jdouble value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Double))
-        return 0;
-    try {
-        TableView* pTableView = new TableView( TBL(nativeTablePtr)->find_all_double( S(columnIndex), value) );
-        return reinterpret_cast<jlong>(pTableView);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllBool(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jboolean value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_Bool))
-        return 0;
 
-    TableView* pTableView = new TableView( TBL(nativeTablePtr)->find_all_bool( S(columnIndex),
-                                           value != 0 ? true : false) );
-    return reinterpret_cast<jlong>(pTableView);
-}
 
 // FIXME: reenable when find_first_timestamp() is implemented
 /*
@@ -1240,20 +1196,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllTimestamp(
 }
 */
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeFindAllString(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex, jstring value)
-{
-    if (!TBL_AND_COL_INDEX_AND_TYPE_VALID(env, TBL(nativeTablePtr), columnIndex, type_String))
-        return 0;
-
-    Table* pTable = TBL(nativeTablePtr);
-    try {
-        JStringAccessor value2(env, value); // throws
-        TableView* pTableView = new TableView( pTable->find_all_string( S(columnIndex), value2) );
-        return reinterpret_cast<jlong>(pTableView);
-    } CATCH_STD()
-    return 0;
-}
 
 
 // experimental
@@ -1287,35 +1229,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeUpperBoundInt(
 
 //
 
-JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetDistinctView(
-    JNIEnv* env, jobject, jlong nativeTablePtr, jlong columnIndex)
-{
-    Table* pTable = TBL(nativeTablePtr);
-    if (!TBL_AND_COL_INDEX_VALID(env, pTable, columnIndex))
-        return 0;
-    if (!pTable->has_search_index(S(columnIndex))) {
-        ThrowException(env, UnsupportedOperation, "The field must be indexed before distinct() can be used.");
-        return 0;
-    }
-    switch (pTable->get_column_type(S(columnIndex))) {
-        case type_Bool:
-        case type_Int:
-        case type_String:
-        case type_Timestamp:
-            try {
-                TableView* pTableView = new TableView( pTable->get_distinct_view(S(columnIndex)) );
-                return reinterpret_cast<jlong>(pTableView);
-            } CATCH_STD()
-            break;
-        default:
-            ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, byte, short, int, long and their boxed variants are supported.");
-            return 0;
-        break;
-    }
-    return 0;
-}
-
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_Table_nativeGetSortedViewMulti(
    JNIEnv *env, jobject, jlong nativeTablePtr, jlongArray columnIndices, jbooleanArray ascending)
 {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
index 7a9bd522c8..e7583bf7fc 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_TableQuery.cpp
@@ -14,32 +14,28 @@
  * limitations under the License.
  */
 
+#include "io_realm_internal_TableQuery.h"
+
 #include <realm.hpp>
 #include <realm/group_shared.hpp>
+
 #include <shared_realm.hpp>
 #include <object_store.hpp>
+#include <results.hpp>
+
 #include "util.hpp"
-#include "jni_util/java_local_ref.hpp"
-#include "io_realm_internal_TableQuery.h"
 
 using namespace realm;
 using namespace realm::jni_util;
 
 #if 1
 #define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  query_col_type_valid(env, jPtr, col, type)
-#define QUERY_VALID(env, pQuery)                    query_valid(env, pQuery)
 #else
 #define QUERY_COL_TYPE_VALID(env, jPtr, col, type)  (true)
-#define QUERY_VALID(env, pQuery)                    (true)
 #endif
 
 static void finalize_table_query(jlong ptr);
 
-inline bool query_valid(JNIEnv* env, Query* pQuery)
-{
-    return TABLE_VALID(env, pQuery->get_table().get());
-}
-
 inline bool query_col_type_valid(JNIEnv* env, jlong nativeQueryPtr, jlong colIndex, DataType type)
 {
     return TBL_AND_COL_INDEX_AND_TYPE_VALID(env, Q(nativeQueryPtr)->get_table().get(), colIndex, type);
@@ -84,156 +80,6 @@ static TableRef getTableByArray(jlong nativeQueryPtr, JniLongArray& indicesArray
     return table_ref;
 }
 
-static jlong findAllWithHandover(JNIEnv* env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit)
-{
-    TR_ENTER()
-    TableRef table = query.get()->get_table();
-    if (!QUERY_VALID(env, query.get()) ||
-        !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
-        return 0;
-    }
-    // run the query
-    TableView tableView(query->find_all(S(start), S(end), S(limit)));
-
-    // handover the result
-    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-    using rf = realm::_impl::RealmFriend;
-    auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
-    return reinterpret_cast<jlong>(handover.release());
-}
-
-static jlong getDistinctViewWithHandover
-        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong columnIndex)
-{
-        TableRef table = query->get_table();
-        if (!QUERY_VALID(env, query.get()) ||
-            !TBL_AND_COL_INDEX_VALID(env, table.get(), columnIndex)) {
-            return 0;
-        }
-        switch (table->get_column_type(S(columnIndex))) {
-            case type_Bool:
-            case type_Int:
-            case type_Timestamp:
-            case type_String: {
-                TableView tableView(query->find_all());
-                tableView.distinct(S(columnIndex));
-
-                // handover the result
-                auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-                using rf = realm::_impl::RealmFriend;
-                auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(
-                        tableView, MutableSourcePayload::Move);
-                return reinterpret_cast<jlong>(handover.release());
-            }
-            default:
-                ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, short, int, long and their boxed variants are supported.");
-                return 0;
-        }
-    return 0;
-}
-
-static jlong findAllSortedWithHandover
-        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
-{
-        TableRef table =  query->get_table();
-
-        if (!(QUERY_VALID(env, query.get()) && ROW_INDEXES_VALID(env, table.get(), start, end, limit))) {
-            return 0;
-        }
-
-        // run the query
-        TableView tableView( query->find_all(S(start), S(end), S(limit)) );
-
-        // sorting the results
-        if (!COL_INDEX_VALID(env, &tableView, columnIndex)) {
-            return 0;
-        }
-
-        int colType = tableView.get_column_type( S(columnIndex) );
-        switch (colType) {
-            case type_Bool:
-            case type_Int:
-            case type_Float:
-            case type_Double:
-            case type_String:
-            case type_Timestamp:
-                tableView.sort( S(columnIndex), ascending != 0);
-                break;
-            default:
-                ThrowException(env, IllegalArgument, ERR_SORT_NOT_SUPPORTED);
-                return 0;
-        }
-
-        // handover the result
-        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-        using rf = realm::_impl::RealmFriend;
-        auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
-        return reinterpret_cast<jlong>(handover.release());
-}
-
-static jlong findAllMultiSortedWithHandover
-        (JNIEnv *env, jlong bgSharedRealmPtr, std::unique_ptr<Query> query, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
-{
-    JniLongArray long_arr(env, columnIndices);
-    JniBooleanArray bool_arr(env, ascending);
-    jsize arr_len = long_arr.len();
-    jsize asc_len = bool_arr.len();
-
-    if (arr_len == 0) {
-        ThrowException(env, IllegalArgument, "You must provide at least one field name.");
-        return 0;
-    }
-    if (asc_len == 0) {
-        ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
-        return 0;
-    }
-    if (arr_len != asc_len) {
-        ThrowException(env, IllegalArgument, "Number of fields and sort orders do not match.");
-        return 0;
-    }
-
-    TableRef table = query->get_table();
-
-    if (!QUERY_VALID(env, query.get()) || !ROW_INDEXES_VALID(env, table.get(), start, end, limit)) {
-        return 0;
-    }
-
-    // run the query
-    TableView tableView( query->find_all(S(start), S(end), S(limit)) );
-
-    // sorting the results
-    std::vector<std::vector<size_t>> indices;
-    std::vector<bool> ascendings;
-    for (int i = 0; i < arr_len; ++i) {
-        if (!COL_INDEX_VALID(env, &tableView, long_arr[i])) {
-            return -1;
-        }
-        int colType = tableView.get_column_type( S(long_arr[i]) );
-        switch (colType) {
-            case type_Bool:
-            case type_Int:
-            case type_Float:
-            case type_Double:
-            case type_String:
-            case type_Timestamp:
-                indices.push_back(std::vector<size_t> { S(long_arr[i]) });
-                ascendings.push_back( B(bool_arr[i]) );
-                break;
-            default:
-                ThrowException(env, IllegalArgument, ERR_SORT_NOT_SUPPORTED);
-                return 0;
-        }
-    }
-
-    tableView.sort(SortDescriptor(*table, indices, ascendings));
-
-    // handover the result
-    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-    using rf = realm::_impl::RealmFriend;
-    auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(tableView, MutableSourcePayload::Move);
-    return reinterpret_cast<jlong>(handover.release());
-}
-
 template <typename coretype, typename cpptype, typename javatype>
 Query numeric_link_equal(TableRef tbl, jlong columnIndex, javatype value) {
     return tbl->column<coretype>(size_t(columnIndex)) == cpptype(value);
@@ -1006,17 +852,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeNotEqual__J_3J_3B
 // as they are called for each method when building up the query.
 // Consider to reduce to just the "action" methods on Query
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeTableview(
-    JNIEnv* env, jobject, jlong nativeQueryPtr, jlong nativeTableViewPtr)
-{
-    Query* pQuery = Q(nativeQueryPtr);
-    if (!QUERY_VALID(env, pQuery))
-        return;
-    try {
-        pQuery->get_table()->where(TV(nativeTableViewPtr));
-    } CATCH_STD()
-}
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeGroup(
     JNIEnv* env, jobject, jlong nativeQueryPtr)
 {
@@ -1086,65 +921,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFind(
     return -1;
 }
 
-// Returns a pointer to query on the worker SharedRealm or throw a BadVersion if the SharedRealm version required
-// for the handover is no longer available.
-static std::unique_ptr<Query> handoverQueryToWorker(jlong bgSharedRealmPtr, jlong queryPtr, bool advanceToLatestVersion)
-{
-    SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, queryPtr);
-    std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
-
-    // The Handover object doesn't prevent a SharedGroup version from no longer being accessible. In rare
-    // cases this means that the version in the Handover object is invalid and Realm Core will throw a
-    // BadVersion as result.
-    auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-    using rf = realm::_impl::RealmFriend;
-    rf::read_group_to(*sharedRealm, handoverQuery->version);
-    auto query = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
-
-    if (advanceToLatestVersion) {
-        sharedRealm->refresh();
-    }
-
-    return query;
-}
-
-// queryPtr would be owned and released by this function
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindWithHandover(
-    JNIEnv* env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong fromTableRow)
-{
-    TR_ENTER()
-    try {
-        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, false); // throws
-        TableRef table = query->get_table();
-
-        if (!QUERY_VALID(env, query.get())) {
-            return 0;
-        }
-
-        // It's valid to go 1 past the end index
-        if ((fromTableRow < 0) || (S(fromTableRow) > table->size())) {
-            // below check will fail with appropriate exception
-            (void) ROW_INDEX_VALID(env, table.get(), fromTableRow);
-            return 0;
-        }
-
-        size_t r = query->find(S(fromTableRow));
-        if (r == not_found) {
-            return 0;
-        } else {
-            // handover the result
-            Row row = (*table)[r];
-            auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-            using rf = realm::_impl::RealmFriend;
-            auto handover = rf::get_shared_group(*sharedRealm).export_for_handover(row);
-            return reinterpret_cast<jlong>(handover.release());
-        }
-
-    } CATCH_STD()
-    return 0;
-}
-
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
     JNIEnv* env, jobject, jlong nativeQueryPtr, jlong start, jlong end, jlong limit)
 {
@@ -1161,178 +937,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAll(
     return -1;
 }
 
-// queryPtr would be owned and released by this function
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllWithHandover
-  (JNIEnv* env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit)
-  {
-      TR_ENTER()
-      try {
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
-          return findAllWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit);
-      } CATCH_STD()
-      return 0;
-  }
-
-
-
-// Should match the values in Java ArgumentsHolder class
-enum query_type {QUERY_TYPE_FIND_ALL = 0, QUERY_TYPE_DISTINCT = 4, QUERY_TYPE_FIND_ALL_SORTED = 1, QUERY_TYPE_FIND_ALL_MULTI_SORTED = 2};
-
-// batch update of async queries
-JNIEXPORT jlongArray JNICALL Java_io_realm_internal_TableQuery_nativeBatchUpdateQueries
-        (JNIEnv *env, jclass, jlong bgSharedRealmPtr,
-         jlongArray  handover_queries_array /*list of handover queries*/,
-         jobjectArray  query_param_matrix /*type & params of the query to be updated*/,
-         jobjectArray  multi_sorted_indices_matrix,
-         jobjectArray  multi_sorted_order_matrix)
-{
-    TR_ENTER()
-    try {
-        JniLongArray handover_queries_pointer_array(env, handover_queries_array);
-
-        const size_t number_of_queries = env->GetArrayLength(query_param_matrix);
-
-        std::vector<jlong> exported_handover_tableview_array(number_of_queries);
-
-        // Step1: Position the shared group at the handover query version so we can import all queries
-        // read the first query to determine the version we should use
-        SharedGroup::Handover<Query> *handoverQueryPtr = HO(Query, handover_queries_pointer_array[0]);
-        std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(handoverQueryPtr);
-
-        // if the SharedGroup is not in Read Transaction, we position it at the same version as the handover
-        // The Handover object doesn't prevent a SharedGroup version from no longer being accessible. In rare
-        // cases this means that the version in the Handover object is invalid and Realm Core will throw a
-        // BadVersion as result.
-        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(bgSharedRealmPtr));
-        using rf = realm::_impl::RealmFriend;
-        rf::read_group_to(*sharedRealm, handoverQuery->version);
-
-        std::vector<std::unique_ptr<Query>> queries(number_of_queries);
-
-        // import the first query
-        queries[0] = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
-
-        // import the rest of the queries
-        for (size_t i = 1; i < number_of_queries; ++i) {
-            std::unique_ptr<SharedGroup::Handover<Query>> handoverQuery(HO(Query, handover_queries_pointer_array[i]));
-            using rf = realm::_impl::RealmFriend;
-            queries[i] = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverQuery));
-        }
-
-        // Step2: Bring the queries into the latest shared group version
-        sharedRealm->refresh();
-
-        // Step3: Run & export the queries against the latest shared group
-        for (size_t i = 0; i < number_of_queries; ++i) {
-            // Delete the local ref since we might have a long loop
-            JavaLocalRef<jlongArray> local_ref(env, (jlongArray) env->GetObjectArrayElement(query_param_matrix, i));
-            JniLongArray query_param_array(env, local_ref);
-
-            switch (query_param_array[0]) { // 0, index of the type of query, the next indicies are parameters
-                case QUERY_TYPE_FIND_ALL: {// nativeFindAllWithHandover
-                    exported_handover_tableview_array[i] =
-                            findAllWithHandover
-                                    (env,
-                                     bgSharedRealmPtr,
-                                     std::move(queries[i]),
-                                     query_param_array[1]/*start*/,
-                                     query_param_array[2]/*end*/,
-                                     query_param_array[3]/*limit*/);
-                    break;
-                }
-                case QUERY_TYPE_DISTINCT: {// nativeGetDistinctViewWithHandover
-                    exported_handover_tableview_array[i] =
-                            getDistinctViewWithHandover
-                                    (env,
-                                     bgSharedRealmPtr,
-                                     std::move(queries[i]),
-                                     query_param_array[1]/*columnIndex*/);
-                    break;
-                }
-                case QUERY_TYPE_FIND_ALL_SORTED: {// nativeFindAllSortedWithHandover
-                    exported_handover_tableview_array[i] =
-                            findAllSortedWithHandover
-                                    (env,
-                                     bgSharedRealmPtr,
-                                     std::move(queries[i]),
-                                     query_param_array[1]/*start*/,
-                                     query_param_array[2]/*end*/,
-                                     query_param_array[3]/*limit*/,
-                                     query_param_array[4]/*columnIndex*/,
-                                     query_param_array[5] == 1/*ascending order*/);
-                    break;
-                }
-                case QUERY_TYPE_FIND_ALL_MULTI_SORTED: {// nativeFindAllMultiSortedWithHandover
-                    jlongArray column_indices_array = (jlongArray) env->GetObjectArrayElement(
-                            multi_sorted_indices_matrix, i);
-                    jbooleanArray column_order_array = (jbooleanArray) env->GetObjectArrayElement(
-                            multi_sorted_order_matrix, i);
-                    exported_handover_tableview_array[i] =
-                            findAllMultiSortedWithHandover
-                                    (env,
-                                     bgSharedRealmPtr,
-                                     std::move(queries[i]),
-                                     query_param_array[1]/*start*/,
-                                     query_param_array[2]/*end*/,
-                                     query_param_array[3]/*limit*/,
-                                     column_indices_array/*columnIndices*/,
-                                     column_order_array/*ascending orders*/);
-                    break;
-                }
-                default:
-                    ThrowException(env, FatalError, "Unknown type of query.");
-                    return NULL;
-            }
-        }
-
-        jlongArray exported_handover_tableview = env->NewLongArray(number_of_queries);
-        if (exported_handover_tableview == NULL) {
-            ThrowException(env, OutOfMemory, "Could not allocate memory to return updated queries.");
-            return NULL;
-        }
-        env->SetLongArrayRegion(exported_handover_tableview, 0, number_of_queries,
-                exported_handover_tableview_array.data());
-        return exported_handover_tableview;
-
-    } CATCH_STD()
-    return NULL;
-}
-
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetDistinctViewWithHandover
-        (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong columnIndex)
-{
-    TR_ENTER()
-    try {
-        std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
-        return getDistinctViewWithHandover(env, bgSharedRealmPtr, std::move(query), columnIndex);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllSortedWithHandover
-  (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlong columnIndex, jboolean ascending)
-  {
-      TR_ENTER()
-      try {
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
-          return findAllSortedWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit, columnIndex, ascending);
-      } CATCH_STD()
-      return 0;
-  }
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeFindAllMultiSortedWithHandover
-  (JNIEnv *env, jclass, jlong bgSharedRealmPtr, jlong queryPtr, jlong start, jlong end, jlong limit, jlongArray columnIndices, jbooleanArray ascending)
-  {
-      TR_ENTER()
-      try {
-          // import the handover query pointer using the background SharedRealm
-          std::unique_ptr<Query> query = handoverQueryToWorker(bgSharedRealmPtr, queryPtr, true); // throws
-          return findAllMultiSortedWithHandover(env, bgSharedRealmPtr, std::move(query), start, end, limit,columnIndices, ascending);
-      } CATCH_STD()
-      return 0;
-  }
-
 // Integer Aggregates
 
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeSumInt(
@@ -1718,27 +1322,6 @@ JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNull(
     } CATCH_STD()
 }
 
-// handoverPtr will be released in this function
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverTableViewIntoSharedGroup
-  (JNIEnv *env, jobject, jlong handoverPtr, jlong callerSharedGrpPtr)
-  {
-    TR_ENTER_PTR(handoverPtr)
-    SharedGroup::Handover<TableView> *handoverTableViewPtr = HO(TableView, handoverPtr);
-    std::unique_ptr<SharedGroup::Handover<TableView>> handoverTableView(handoverTableViewPtr);
-    try {
-        // import_from_handover will free (delete) the handover
-        auto sharedRealm = *(reinterpret_cast<SharedRealm*>(callerSharedGrpPtr));
-        if (!sharedRealm->is_closed()) {
-            using rf = realm::_impl::RealmFriend;
-            auto tableView = rf::get_shared_group(*sharedRealm).import_from_handover(std::move(handoverTableView));
-            return reinterpret_cast<jlong>(tableView.release());
-        } else {
-            ThrowException(env, RuntimeError, ERR_IMPORT_CLOSED_REALM);
-        }
-    } CATCH_STD()
-    return 0;
-  }
-
 JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeImportHandoverRowIntoSharedGroup
   (JNIEnv *env, jclass, jlong handoverPtr, jlong callerSharedGrpPtr)
   {
@@ -1777,13 +1360,6 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeHandoverQuery
 }
 
 
-JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeCloseQueryHandover
-  (JNIEnv*, jclass, jlong nativeHandoverQuery)
-  {
-    TR_ENTER_PTR(nativeHandoverQuery)
-    delete HO(Query, nativeHandoverQuery);
-  }
-
 JNIEXPORT void JNICALL Java_io_realm_internal_TableQuery_nativeIsNotNull
   (JNIEnv *env, jobject, jlong nativeQueryPtr, jlongArray columnIndexes) {
     JniLongArray arr(env, columnIndexes);
@@ -1937,4 +1513,3 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_TableQuery_nativeGetFinalizerPtr
     TR_ENTER()
     return reinterpret_cast<jlong>(&finalize_table_query);
 }
-
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
deleted file mode 100644
index 563054f643..0000000000
--- a/realm/realm-library/src/main/cpp/io_realm_internal_TableView.cpp
+++ /dev/null
@@ -1,993 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "util.hpp"
-#include "tablebase_tpl.hpp"
-#include "io_realm_internal_TableView.h"
-#include "realm/array.hpp"
-#include <ostream>
-
-using namespace realm;
-
-// if you disable the validation, please remember to call sync_in_needed() 
-#define VIEW_VALID_AND_IN_SYNC(env, ptr) view_valid_and_in_sync(env, ptr)
-
-static void finalize_table_view(jlong ptr);
-
-inline bool view_valid_and_in_sync(JNIEnv* env, jlong nativeViewPtr) {
-    bool valid = (TV(nativeViewPtr) != NULL);
-    if (valid) {
-        if (!TV(nativeViewPtr)->is_attached()) {
-            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
-            return false;
-        }
-        // depends_on_deleted_linklist() will return true if and only if the current TableView was created from a
-        // query on a RealmList and that RealmList was then deleted (as a result of the object being deleted).
-        if (!TV(nativeViewPtr)->is_in_sync() && TV(nativeViewPtr)->depends_on_deleted_object()) {
-            // This table view is no longer valid. By calling sync_if_needed we ensure it behaves
-            // properly as a 0-size TableView.
-            TV(nativeViewPtr)->sync_if_needed();
-        }
-    }
-    return valid;
-}
-
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_createNativeTableView(
-    JNIEnv* env, jobject, jobject, jlong)
-{
-    try {
-        return reinterpret_cast<jlong>( new TableView() );
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinct(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-        return;
-    if (!COL_INDEX_VALID(env, TV(nativeViewPtr), columnIndex))
-        return;
-    if (!TV(nativeViewPtr)->get_parent().has_search_index(S(columnIndex))) {
-        ThrowException(env, UnsupportedOperation, "The field must be indexed before distinct() can be used.");
-        return;
-    }
-    try {
-        switch (TV(nativeViewPtr)->get_column_type(S(columnIndex))) {
-            case type_Bool:
-            case type_Int:
-            case type_String:
-            case type_Timestamp:
-                TV(nativeViewPtr)->distinct(S(columnIndex));
-                break;
-            default:
-                ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, byte, short, int, long and their boxed variants are supported.");
-                break;
-        }
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeDistinctMulti(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlongArray columnIndexes)
-{
-    if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-        return;
-    try {
-        TableView* tv = TV(nativeViewPtr);
-        JniLongArray indexes(env, columnIndexes);
-        jsize indexes_len = indexes.len();
-        std::vector<std::vector<size_t>> columns;
-        std::vector<bool> ascending;
-        for (int i = 0; i < indexes_len; ++i) {
-            if (!COL_INDEX_VALID(env, tv, indexes[i])) {
-                return;
-            }
-            if (!tv->get_parent().has_search_index(S(indexes[i]))) {
-                ThrowException(env, IllegalArgument, "The field must be indexed before distinct(...) can be used.");
-                return;
-            }
-            switch (tv->get_column_type(S(indexes[i]))) {
-                case type_Bool:
-                case type_Int:
-                case type_String:
-                case type_Timestamp:
-                    columns.push_back(std::vector<size_t> { S(indexes[i]) });
-                    ascending.push_back(true);
-                    break;
-                default:
-                    ThrowException(env, IllegalArgument, "Invalid type - Only String, Date, boolean, byte, short, int, long and their boxed variants are supported.");
-                    return;
-            }
-        }
-        tv->distinct(SortDescriptor(tv->get_parent(), columns, ascending));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativePivot(
-    JNIEnv *env, jobject, jlong dataTablePtr, jlong stringCol, jlong intCol, jint operation, jlong resultTablePtr)
-{
-
-    try {
-        TV(dataTablePtr)->sync_if_needed();
-        TableView* dataTable = TV(dataTablePtr);
-        Table* resultTable = TBL(resultTablePtr);
-        Table::AggrType pivotOp;
-        switch (operation) {
-        case 0:
-            pivotOp = Table::aggr_count;
-            break;
-        case 1:
-            pivotOp = Table::aggr_sum;
-            break;
-        case 2:
-            pivotOp = Table::aggr_avg;
-            break;
-        case 3:
-            pivotOp = Table::aggr_min;
-            break;
-        case 4:
-            pivotOp = Table::aggr_max;
-            break;
-        default:
-            ThrowException(env, UnsupportedOperation, "No pivot operation specified.");
-            return;
-        }
-        dataTable->aggregate(S(stringCol), S(intCol), pivotOp, *resultTable);
-    } CATCH_STD()
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSize(
-    JNIEnv* env, jobject, jlong nativeViewPtr)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->size();   // noexcept
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetSourceRowIndex
-(JNIEnv *env, jobject, jlong nativeViewPtr, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return to_jlong_or_not_found(-1);
-        if (!ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
-            return to_jlong_or_not_found(-1);
-        if (!TV(nativeViewPtr)->is_row_attached(rowIndex))
-            return to_jlong_or_not_found(-1);
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_source_ndx(S(rowIndex));   // noexcept
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetColumnCount
-  (JNIEnv *env, jobject, jlong nativeViewPtr)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_column_count();
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetColumnName
-  (JNIEnv *env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !COL_INDEX_VALID(env, TV(nativeViewPtr), columnIndex))
-            return NULL;
-        return to_jstring(env, TV(nativeViewPtr)->get_column_name( S(columnIndex)));
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetColumnIndex
-   (JNIEnv *env, jobject, jlong nativeViewPtr, jstring columnName)
-
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return 0;
-        JStringAccessor columnName2(env, columnName); // throws
-        return to_jlong_or_not_found( TV(nativeViewPtr)->get_column_index(columnName2) ); // noexcept
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jint JNICALL Java_io_realm_internal_TableView_nativeGetColumnType
-  (JNIEnv *env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !COL_INDEX_VALID(env, TV(nativeViewPtr), columnIndex))
-            return 0;
-    } CATCH_STD()
-    return static_cast<int>( TV(nativeViewPtr)->get_column_type( S(columnIndex)) );
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLong(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Int))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_int( S(columnIndex), S(rowIndex));  // noexcept
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeGetBoolean(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Bool))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_bool( S(columnIndex), S(rowIndex));  // noexcept
-}
-
-JNIEXPORT jfloat JNICALL Java_io_realm_internal_TableView_nativeGetFloat(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Float))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_float( S(columnIndex), S(rowIndex));  // noexcept
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeGetDouble(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Double))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_double( S(columnIndex), S(rowIndex));  // noexcept
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetTimestamp(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Timestamp))
-            return 0;
-    } CATCH_STD()
-    return to_milliseconds(TV(nativeViewPtr)->get_timestamp( S(columnIndex), S(rowIndex)));
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeGetString(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_String))
-            return NULL;
-        
-        return to_jstring(env, TV(nativeViewPtr)->get_string( S(columnIndex), S(rowIndex)) // noexcept
-                          );
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jbyteArray JNICALL Java_io_realm_internal_TableView_nativeGetByteArray(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Binary))
-            return NULL;
-        return tbl_GetByteArray<TableView>(env, nativeViewPtr, columnIndex, rowIndex);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetLink
-  (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Link))
-            return 0;
-    } CATCH_STD()
-    return TV(nativeViewPtr)->get_link( S(columnIndex), S(rowIndex));  // noexcept
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeIsNull
-        (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return 0;
-        return TV(nativeViewPtr)->get_parent().is_null( S(columnIndex), TV(nativeViewPtr)->get_source_ndx(S(rowIndex))) ? JNI_TRUE : JNI_FALSE;  // noexcept
-    } CATCH_STD()
-    return 0;
-}
-
-// Setters
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLong(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Int))
-            return;
-        TV(nativeViewPtr)->set_int( S(columnIndex), S(rowIndex), value);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetBoolean(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jboolean value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Bool))
-            return;
-        TV(nativeViewPtr)->set_bool( S(columnIndex), S(rowIndex), value != 0 ? true : false);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetFloat(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jfloat value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Float))
-            return;
-        TV(nativeViewPtr)->set_float( S(columnIndex), S(rowIndex), value);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetDouble(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jdouble value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Double))
-            return;
-        TV(nativeViewPtr)->set_double( S(columnIndex), S(rowIndex), value);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetTimestampValue(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong timestampValue)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Timestamp))
-            return;
-        TV(nativeViewPtr)->set_timestamp( S(columnIndex), S(rowIndex), from_milliseconds(timestampValue));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetString(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jstring value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_String))
-            return;
-        if (!TV(nativeViewPtr)->get_parent().is_nullable(S(columnIndex))) {
-            ThrowNullValueException(env, &(TV(nativeViewPtr)->get_parent()), S(columnIndex));
-            return;
-        }
-        JStringAccessor value2(env, value);  // throws
-        TV(nativeViewPtr)->set_string( S(columnIndex), S(rowIndex), value2);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetByteArray(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jbyteArray byteArray)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Binary))
-            return;
-
-        JniByteArray bytesAccessor(env, byteArray);
-        TV(nativeViewPtr)->set_binary(S(columnIndex), S(rowIndex), bytesAccessor);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSetLink
-  (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex, jlong targetIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Link))
-            return;
-        TV(nativeViewPtr)->set_link( S(columnIndex), S(rowIndex), S(targetIndex));
-    } CATCH_STD()
-}
-
-JNIEXPORT jboolean JNICALL Java_io_realm_internal_TableView_nativeIsNullLink
-  (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Link))
-            return 0;
-        return TV(nativeViewPtr)->is_null_link( S(columnIndex), S(rowIndex));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeNullifyLink
-  (JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, rowIndex, type_Link))
-            return;
-        TV(nativeViewPtr)->nullify_link( S(columnIndex), S(rowIndex));
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeClear(
-    JNIEnv* env, jobject, jlong nativeViewPtr)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return;
-        TV(nativeViewPtr)->clear(RemoveMode::unordered);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeRemoveRow(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong rowIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !ROW_INDEX_VALID(env, TV(nativeViewPtr), rowIndex))
-            return;
-        TV(nativeViewPtr)->remove( S(rowIndex), RemoveMode::unordered);
-    } CATCH_STD()
-}
-
-// FindFirst*
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstInt(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
-            return 0;
-        return to_jlong_or_not_found( TV(nativeViewPtr)->find_first_int( S(columnIndex), value) );
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstBool(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jboolean value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Bool))
-            return 0;
-        size_t res = TV(nativeViewPtr)->find_first_bool( S(columnIndex), value != 0 ? true : false);
-        return to_jlong_or_not_found( res );
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstFloat(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jfloat value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
-            return 0;
-        return to_jlong_or_not_found( TV(nativeViewPtr)->find_first_float( S(columnIndex), value) );
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDouble(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jdouble value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
-            return 0;
-        return to_jlong_or_not_found( (TV(nativeViewPtr)->find_first_double( S(columnIndex), value)) );
-    } CATCH_STD()
-    return 0;
-}
-
-// FIXME: find_first_timestamp() isn't implemented
-/*
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstDate(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong dateTimeValue)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
-            return 0;
-        return to_jlong_or_not_found( TV(nativeViewPtr)->find_first_datetime( S(columnIndex), DateTime(dateTimeValue)) );
-    } CATCH_STD()
-    return 0;
-}
-*/
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindFirstString(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jstring value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_String))
-            return 0;
-        JStringAccessor value2(env, value); // throws
-        size_t searchIndex = TV(nativeViewPtr)->find_first_string( S(columnIndex), value2);
-        return to_jlong_or_not_found( searchIndex );
-    } CATCH_STD()
-    return 0;
-}
-
-// FindAll*
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllInt(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
-            return 0;
-        TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_int( S(columnIndex), value) );
-        return reinterpret_cast<jlong>(pResultView);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllBool(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jboolean value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Bool))
-            return 0;
-        TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_bool( S(columnIndex),
-                                                value != 0 ? true : false) );
-        return reinterpret_cast<jlong>(pResultView);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllFloat(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jfloat value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
-            return 0;
-        TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_float( S(columnIndex), value) );
-        return reinterpret_cast<jlong>(pResultView);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDouble(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jdouble value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
-            return 0;
-        TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_double( S(columnIndex), value) );
-        return reinterpret_cast<jlong>(pResultView);
-    } CATCH_STD()
-    return 0;
-}
-
-// FIXME: find_all_timestamp() isn't implemented
-/*
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllDate(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jlong dateTimeValue)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_DateTime))
-            return 0;
-        TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_datetime( S(columnIndex),
-                                                DateTime(dateTimeValue)) );
-        return reinterpret_cast<jlong>(pResultView);
-    } CATCH_STD()
-    return 0;
-}
-*/
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindAllString(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jstring value)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_String))
-            return 0;
-        JStringAccessor value2(env, value); // throws
-        TableView* pResultView = new TableView( TV(nativeViewPtr)->find_all_string( S(columnIndex), value2) );
-        return reinterpret_cast<jlong>(pResultView);
-    } CATCH_STD()
-    return 0;
-}
-
-// Integer aggregates
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSumInt(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
-            return 0;
-        return TV(nativeViewPtr)->sum_int( S(columnIndex));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageInt(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
-            return 0;
-        return static_cast<jdouble>( TV(nativeViewPtr)->average_int( S(columnIndex)));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumInt(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
-            return NULL;
-        size_t return_ndx;
-        int64_t result = TV(nativeViewPtr)->maximum_int( S(columnIndex), &return_ndx);
-        if (return_ndx != npos) {
-            return NewLong(env, result);
-        }
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumInt(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Int))
-            return NULL;
-        size_t return_ndx;
-        int64_t result = TV(nativeViewPtr)->minimum_int( S(columnIndex), &return_ndx);
-        if (return_ndx != npos) {
-            return NewLong(env, result);
-        }
-    } CATCH_STD()
-    return NULL;
-}
-
-// float aggregates
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeSumFloat(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
-            return 0;
-        return TV(nativeViewPtr)->sum_float( S(columnIndex));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageFloat(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
-            return 0;
-        return TV(nativeViewPtr)->average_float( S(columnIndex));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumFloat(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
-            return NULL;
-        size_t return_ndx;
-        float result = TV(nativeViewPtr)->maximum_float( S(columnIndex), &return_ndx);
-        if (return_ndx != npos) {
-            return NewFloat(env, result);
-        }
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumFloat(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Float))
-            return NULL;
-        size_t return_ndx;
-        float result = TV(nativeViewPtr)->minimum_float( S(columnIndex), &return_ndx);
-        if (return_ndx != npos) {
-            return NewFloat(env, result);
-        }
-    } CATCH_STD()
-    return NULL;
-}
-
-// double aggregates
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeSumDouble(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
-            return 0;
-        return TV(nativeViewPtr)->sum_double( S(columnIndex));
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jdouble JNICALL Java_io_realm_internal_TableView_nativeAverageDouble(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
-            return 0;
-        return static_cast<jdouble>( TV(nativeViewPtr)->average_double( S(columnIndex)) );
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumDouble(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
-            return NULL;
-        size_t return_ndx;
-        double result = TV(nativeViewPtr)->maximum_double( S(columnIndex), &return_ndx);
-        if (return_ndx != npos) {
-            return NewDouble(env, result);
-        }
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumDouble(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Double))
-            return NULL;
-        size_t return_ndx;
-        double result = TV(nativeViewPtr)->minimum_double( S(columnIndex), &return_ndx);
-        if (return_ndx != npos) {
-            return NewDouble(env, result);
-        }
-    } CATCH_STD()
-    return NULL;
-}
-
-
-// date aggregates
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMaximumTimestamp(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Timestamp))
-            return NULL;
-
-        size_t return_ndx;
-        Timestamp result = TV(nativeViewPtr)->maximum_timestamp( S(columnIndex), &return_ndx);
-        if (return_ndx != npos) {
-            return NewLong(env, to_milliseconds(result));
-        }
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jobject JNICALL Java_io_realm_internal_TableView_nativeMinimumTimestamp(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_AND_TYPE_VALID(env, TV(nativeViewPtr), columnIndex, type_Timestamp))
-            return NULL;
-
-        size_t return_ndx;
-        Timestamp result = TV(nativeViewPtr)->minimum_timestamp( S(columnIndex), &return_ndx);
-        if (return_ndx != npos) {
-            return NewLong(env, to_milliseconds(result));
-        }
-    } CATCH_STD()
-    return NULL;
-}
-
-// sort
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSort(
-    JNIEnv* env, jobject, jlong nativeViewPtr, jlong columnIndex, jboolean ascending)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) ||
-            !COL_INDEX_VALID(env, TV(nativeViewPtr), columnIndex))
-            return;
-        int colType = TV(nativeViewPtr)->get_column_type( S(columnIndex) );
-    
-        switch (colType) {
-            case type_Bool:
-            case type_Int:
-            case type_Float:
-            case type_Double:
-            case type_String:
-            case type_Timestamp:
-                TV(nativeViewPtr)->sort( S(columnIndex), ascending != 0 ? true : false);
-                break;
-            default:
-                ThrowException(env, IllegalArgument, "Sort is not supported on binary data, object references and RealmList.");
-                return;
-        }
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_TableView_nativeSortMulti(
-  JNIEnv* env, jobject, jlong nativeViewPtr, jlongArray columnIndices, jbooleanArray ascending)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return;
-
-        JniLongArray long_arr(env, columnIndices);
-        JniBooleanArray bool_arr(env, ascending);
-        jsize arr_len = long_arr.len();
-        jsize asc_len = bool_arr.len();
-
-        if (arr_len == 0) {
-            ThrowException(env, IllegalArgument, "You must provide at least one field name.");
-            return;
-        }
-        if (asc_len == 0) {
-            ThrowException(env, IllegalArgument, "You must provide at least one sort order.");
-            return;
-        }
-        if (arr_len != asc_len) {
-            ThrowException(env, IllegalArgument, "Number of fields and sort orders do not match.");
-            return;
-        }
-
-        TableView* tv = TV(nativeViewPtr);
-        std::vector<std::vector<size_t>> indices;
-        std::vector<bool> ascendings;
-
-        for (int i = 0; i < arr_len; ++i) {
-            if (!COL_INDEX_VALID(env, tv, long_arr[i])) {
-                return;
-            }
-            int colType = tv->get_column_type( S(long_arr[i]) );
-            switch (colType) {
-                case type_Bool:
-                case type_Int:
-                case type_Float:
-                case type_Double:
-                case type_String:
-                case type_Timestamp:
-                    indices.push_back(std::vector<size_t> { S(long_arr[i]) });
-                    ascendings.push_back( B(bool_arr[i]) );
-                    break;
-                default:
-                    ThrowException(env, IllegalArgument, "Sort is not supported on binary data, object references and RealmList.");
-                    return;
-            }
-        }
-        tv->sort(SortDescriptor(tv->get_parent(), indices, ascendings));
-    } CATCH_STD()
-}
-
-JNIEXPORT jstring JNICALL Java_io_realm_internal_TableView_nativeToJson(
-    JNIEnv *env, jobject, jlong nativeViewPtr)
-{
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return NULL;
-        
-        // Write table to string in JSON format
-        std::stringstream ss;
-        ss.sync_with_stdio(false); // for performance
-        TV(nativeViewPtr)->to_json(ss);
-        const std::string str = ss.str();
-        return to_jstring(env, str);
-    } CATCH_STD()
-    return NULL;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeWhere(
-    JNIEnv *env, jobject, jlong nativeViewPtr)
-{
-    TR_ENTER_PTR(nativeViewPtr)
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr))
-            return 0;
-
-        Query *queryPtr = new Query(TV(nativeViewPtr)->get_parent().where(TV(nativeViewPtr)));
-        return reinterpret_cast<jlong>(queryPtr);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeSyncIfNeeded(
-    JNIEnv* env, jobject, jlong nativeViewPtr)
-{
-    bool valid = (TV(nativeViewPtr) != NULL);
-    if (valid) {
-        if (!TV(nativeViewPtr)->is_attached()) {
-            ThrowException(env, IllegalState, "The Realm has been closed and is no longer accessible.");
-            return 0;
-        }
-    }
-    try {
-        return (jlong) TV(nativeViewPtr)->sync_if_needed();
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeFindBySourceNdx
-        (JNIEnv *env, jobject, jlong nativeViewPtr, jlong sourceIndex)
-{
-    TR_ENTER_PTR(nativeViewPtr);
-    try {
-        if (!VIEW_VALID_AND_IN_SYNC(env, nativeViewPtr) || !ROW_INDEX_VALID(env, &(TV(nativeViewPtr)->get_parent()), sourceIndex))
-            return -1;
-
-        size_t ndx = TV(nativeViewPtr)->find_by_source_ndx(sourceIndex);
-        return to_jlong_or_not_found(ndx);
-    } CATCH_STD()
-    return -1;
-}
-
-static void finalize_table_view(jlong ptr)
-{
-    TR_ENTER_PTR(ptr)
-    delete TV(ptr);
-}
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_TableView_nativeGetFinalizerPtr
-  (JNIEnv *, jclass)
-{
-    TR_ENTER()
-    return reinterpret_cast<jlong>(&finalize_table_view);
-}
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
index 03241982e0..fbd421bc9b 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_Util.cpp
@@ -16,14 +16,14 @@
 
 #include <jni.h>
 
+#include "jni_util/jni_utils.hpp"
+
 #include <realm/string_data.hpp>
 #include <realm/unicode.hpp>
 
 #include "mem_usage.hpp"
 #include "util.hpp"
 
-#include "jni_util/jni_utils.hpp"
-
 using std::string;
 using namespace realm::jni_util;
 
@@ -51,6 +51,12 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*)
         java_lang_double      = GetClass(env, "java/lang/Double");
         java_lang_string      = GetClass(env, "java/lang/String");
         java_lang_double_init = env->GetMethodID(java_lang_double, "<init>", "(D)V");
+        java_util_date        = GetClass(env, "java/util/Date");
+        java_util_date_init   = env->GetMethodID(java_util_date, "<init>", "(J)V");
+#if REALM_ENABLE_SYNC
+        java_syncmanager = GetClass(env, "io/realm/SyncManager");
+#endif
+
     }
 
     return JNI_VERSION_1_6;
@@ -66,7 +72,11 @@ JNIEXPORT void JNI_OnUnload(JavaVM* vm, void*)
         env->DeleteGlobalRef(java_lang_long);
         env->DeleteGlobalRef(java_lang_float);
         env->DeleteGlobalRef(java_lang_double);
+        env->DeleteGlobalRef(java_util_date);
         env->DeleteGlobalRef(java_lang_string);
+#if REALM_ENABLE_SYNC
+        env->DeleteGlobalRef(java_syncmanager);
+#endif
     }
 }
 
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
deleted file mode 100644
index 0caa7acccc..0000000000
--- a/realm/realm-library/src/main/cpp/io_realm_internal_objectserver_ObjectServerSession.cpp
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <jni.h>
-
-#include "io_realm_internal_objectserver_ObjectServerSession.h"
-#include "objectserver_shared.hpp"
-#include "util.hpp"
-#include <realm/group_shared.hpp>
-#include <realm/replication.hpp>
-
-#include <realm/sync/history.hpp>
-#include <realm/sync/client.hpp>
-#include <realm/util/logger.hpp>
-#include <mutex>
-#include <thread>
-#include <vector>
-#include <chrono>
-#include <functional>
-#include <android/log.h>
-
-using namespace std;
-using namespace realm;
-using namespace sync;
-
-
-JNIEXPORT jlong JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeCreateSession
-  (JNIEnv *env, jobject obj, jstring localRealmPath)
-{
-    TR_ENTER()
-    try {
-        JStringAccessor local_path(env, localRealmPath);
-        JniSession* jni_session = new JniSession(env, local_path, obj);
-        return reinterpret_cast<jlong>(jni_session);
-    } CATCH_STD()
-    return 0;
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeBind
-  (JNIEnv *env, jobject, jlong sessionPointer, jstring remoteUrl, jstring accessToken)
-{
-    TR_ENTER()
-    try {
-        auto *session_wrapper = reinterpret_cast<JniSession*>(sessionPointer);
-
-        const char *token_tmp = env->GetStringUTFChars(accessToken, NULL);
-        std::string access_token(token_tmp);
-        env->ReleaseStringUTFChars(accessToken, token_tmp);
-
-        JStringAccessor url_tmp(env, remoteUrl); // throws
-        StringData remote_url = StringData(url_tmp);
-
-        // Bind the local Realm to the remote one
-        session_wrapper->get_session()->bind(remote_url, access_token);
-    } CATCH_STD()
-}
-
-
-JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeUnbind
-  (JNIEnv *, jobject, jlong sessionPointer)
-{
-    TR_ENTER()
-    JniSession* session = SS(sessionPointer);
-    delete session; // TODO Can we avoid killing the session here?
-}
-
-JNIEXPORT void JNICALL Java_io_realm_internal_objectserver_ObjectServerSession_nativeRefresh
-  (JNIEnv *env, jobject, jlong sessionPointer, jstring accessToken)
-{
-    TR_ENTER()
-    try {
-        JniSession* session_wrapper = SS(sessionPointer);
-
-        JStringAccessor token_tmp(env, accessToken); // throws
-        StringData access_token = StringData(token_tmp);
-
-        session_wrapper->get_session()->refresh(access_token);
-    } CATCH_STD()
-}
-
-JNIEXPORT void JNICALL
-Java_io_realm_internal_objectserver_ObjectServerSession_nativeNotifyCommitHappened
-  (JNIEnv *env, jobject, jlong sessionPointer, jlong version)
-{
-    TR_ENTER()
-    try {
-        JniSession* session_wrapper = SS(sessionPointer);
-        session_wrapper->get_session()->nonsync_transact_notify(version);
-    } CATCH_STD()
-}
-
-
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.cpp b/realm/realm-library/src/main/cpp/java_binding_context.cpp
index f876847b86..525c70fc36 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.cpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.cpp
@@ -17,18 +17,40 @@
 #include "java_binding_context.hpp"
 #include "jni_util/java_method.hpp"
 
+#include "util.hpp"
+
 using namespace realm;
 using namespace realm::_impl;
 using namespace realm::jni_util;
 
-void JavaBindingContext::changes_available()
+void JavaBindingContext::before_notify()
 {
+    if (JniUtils::get_env()->ExceptionCheck()) {
+        return;
+    }
     if (m_java_notifier) {
         m_java_notifier.call_with_local_ref([&] (JNIEnv* env, jobject notifier_obj) {
             // Method IDs from RealmNotifier implementation. Cache them as member vars.
-            static JavaMethod notify_by_other_method(env, notifier_obj, "notifyCommitByOtherThread", "()V");
+            static JavaMethod notify_by_other_method(env, notifier_obj, "beforeNotify", "()V");
             env->CallVoidMethod(notifier_obj, notify_by_other_method);
         });
     }
 }
 
+void JavaBindingContext::did_change(std::vector<BindingContext::ObserverState> const&,
+                        std::vector<void*> const&,
+                        bool version_changed)
+{
+    auto env = JniUtils::get_env();
+
+    if (JniUtils::get_env()->ExceptionCheck()) {
+        return;
+    }
+    if (version_changed) {
+        m_java_notifier.call_with_local_ref(env, [&] (JNIEnv*, jobject notifier_obj) {
+            static JavaMethod realm_notifier_did_change_method(env, notifier_obj, "didChange", "()V");
+            env->CallVoidMethod(notifier_obj, realm_notifier_did_change_method);
+        });
+    }
+}
+
diff --git a/realm/realm-library/src/main/cpp/java_binding_context.hpp b/realm/realm-library/src/main/cpp/java_binding_context.hpp
index cba34dedba..a459058c36 100644
--- a/realm/realm-library/src/main/cpp/java_binding_context.hpp
+++ b/realm/realm-library/src/main/cpp/java_binding_context.hpp
@@ -34,8 +34,6 @@ class JavaBindingContext final : public BindingContext {
     struct ConcreteJavaBindContext {
         JNIEnv* jni_env;
         jobject java_notifier;
-        explicit ConcreteJavaBindContext(JNIEnv* env, jobject notifier)
-            :jni_env(env), java_notifier(notifier) { }
     };
 
     // A weak global ref to the implementation of RealmNotifier
@@ -43,11 +41,14 @@ class JavaBindingContext final : public BindingContext {
     jni_util::JavaGlobalWeakRef m_java_notifier;
 
 public:
-    virtual ~JavaBindingContext() {};
-    virtual void changes_available();
+    virtual ~JavaBindingContext() { };
+    virtual void before_notify();
+    virtual void did_change(std::vector<ObserverState> const& observers,
+                            std::vector<void*> const& invalidated,
+                            bool version_changed=true);
 
     explicit JavaBindingContext(const ConcreteJavaBindContext& concrete_context)
-            : m_java_notifier(concrete_context.jni_env, concrete_context.java_notifier) {}
+            : m_java_notifier(concrete_context.jni_env, concrete_context.java_notifier) { }
     JavaBindingContext(const JavaBindingContext&) = delete;
     JavaBindingContext& operator=(const JavaBindingContext&) = delete;
     JavaBindingContext(JavaBindingContext&&) = delete;
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp b/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
new file mode 100644
index 0000000000..5c894bc73f
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_sort_descriptor.cpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#include "java_sort_descriptor.hpp"
+#include "util.hpp"
+#include "jni_util/java_method.hpp"
+
+using namespace realm;
+using namespace realm::_impl;
+using namespace realm::jni_util;
+
+JavaSortDescriptor::operator realm::SortDescriptor() const noexcept
+{
+    if (m_sort_desc_obj == nullptr) {
+        return SortDescriptor();
+    }
+
+    // Cache the method IDs.
+    static JavaMethod getColumnIndices(m_env, m_sort_desc_obj, "getColumnIndices", "()[[J");
+    static JavaMethod getAscendings(m_env, m_sort_desc_obj, "getAscendings", "()[Z");
+    static JavaMethod getTablePtr(m_env, m_sort_desc_obj, "getTablePtr", "()J");
+
+    jobjectArray column_indices =
+            static_cast<jobjectArray>(m_env->CallObjectMethod(m_sort_desc_obj, getColumnIndices));
+    jbooleanArray ascendings =
+            static_cast<jbooleanArray >(m_env->CallObjectMethod(m_sort_desc_obj, getAscendings));
+    jlong table_ptr = m_env->CallLongMethod(m_sort_desc_obj, getTablePtr);
+
+    JniArrayOfArrays<JniLongArray, jlongArray> arrays(m_env, column_indices);
+    JniBooleanArray ascending_array(m_env, ascendings);
+    jsize arr_len = arrays.len();
+
+    std::vector<std::vector<size_t>> indices;
+    std::vector<bool> ascending_list;
+
+    for (int i = 0; i < arr_len; ++i) {
+        JniLongArray& jni_long_array = arrays[i];
+        std::vector<size_t> col_indices;
+        for (int j = 0; j < jni_long_array.len(); ++j) {
+            col_indices.push_back(static_cast<size_t >(jni_long_array[j]));
+        }
+        indices.push_back(std::move(col_indices));
+        if (ascendings) {
+            ascending_list.push_back(static_cast<bool>(ascending_array[i]));
+        }
+    }
+
+    return ascendings ?
+           SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices), std::move(ascending_list))
+                      : SortDescriptor(*reinterpret_cast<Table*>(table_ptr), std::move(indices));
+}
+
+
diff --git a/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp b/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
new file mode 100644
index 0000000000..613b16ece7
--- /dev/null
+++ b/realm/realm-library/src/main/cpp/java_sort_descriptor.hpp
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef JAVA_SORT_DESCRIPTOR_HPP
+#define JAVA_SORT_DESCRIPTOR_HPP
+
+#include <jni.h>
+#include <realm/views.hpp>
+
+namespace realm {
+namespace _impl {
+
+// For converting a Java SortDescriptor object to realm::SortDescriptor.
+// This class is not designed to be used across JNI calls. So it doesn't acquire a reference to the given Java object.
+// We don't hold a pointer to the SortDescriptor in the Java object like normally we do, because the ObjectStore
+// always consumes the SortDescriptor by calling the move constructor. Holding an empty SortDescriptor in Java level
+// doesn't make too much sense and causes troubles with memory management.
+class JavaSortDescriptor {
+public:
+    JavaSortDescriptor(JNIEnv* env, jobject sort_desc_obj) : m_env(env), m_sort_desc_obj(sort_desc_obj) {}
+
+    JavaSortDescriptor(const JavaSortDescriptor&) = delete;
+    JavaSortDescriptor& operator=(const JavaSortDescriptor&) = delete;
+    JavaSortDescriptor(JavaSortDescriptor&&) = delete;
+    JavaSortDescriptor& operator=(JavaSortDescriptor&&) = delete;
+
+    operator realm::SortDescriptor() const noexcept;
+
+private:
+    JNIEnv* m_env;
+    jobject m_sort_desc_obj;
+};
+
+} // namespace _impl
+} // namespace realm
+#endif //JAVA_SORT_DESCRIPTOR_HPP
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
index 676f92b37f..59b50c36b0 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_global_weak_ref.hpp
@@ -37,11 +37,15 @@ class JavaGlobalWeakRef {
         }
     }
 
-    // Implement those when needed.
+    JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs) : m_weak(rhs.m_weak) { rhs.m_weak = nullptr; }
+    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&& rhs) {
+        this->~JavaGlobalWeakRef();
+        new(this) JavaGlobalWeakRef(std::move(rhs));
+        return *this;
+    }
+
     JavaGlobalWeakRef(const JavaGlobalWeakRef&) = delete;
     JavaGlobalWeakRef& operator=(const JavaGlobalWeakRef&) = delete;
-    JavaGlobalWeakRef(JavaGlobalWeakRef&& rhs) = delete;
-    JavaGlobalWeakRef& operator=(JavaGlobalWeakRef&& rhs) = delete;
 
     inline operator bool() const noexcept
     {
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_method.cpp b/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
index 61f37748cd..e28bfc184a 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_method.cpp
@@ -20,13 +20,19 @@
 
 using namespace realm::jni_util;
 
-JavaMethod::JavaMethod(JNIEnv *env, jclass cls, const char* method_name, const char* signature)
+JavaMethod::JavaMethod(JNIEnv* env, jclass cls, const char* method_name, const char* signature, bool static_method)
 {
-    m_method_id = env->GetMethodID(cls, method_name, signature);
+    if (static_method) {
+        m_method_id = env->GetStaticMethodID(cls, method_name, signature);
+    }
+    else {
+        m_method_id = env->GetMethodID(cls, method_name, signature);
+    }
+
     REALM_ASSERT_DEBUG(m_method_id != nullptr);
 }
 
-JavaMethod::JavaMethod(JNIEnv *env, jobject obj, const char* method_name, const char* signature)
+JavaMethod::JavaMethod(JNIEnv* env, jobject obj, const char* method_name, const char* signature)
 {
     jclass cls = env->GetObjectClass(obj);
     m_method_id = env->GetMethodID(cls, method_name, signature);
@@ -34,10 +40,15 @@ JavaMethod::JavaMethod(JNIEnv *env, jobject obj, const char* method_name, const
     env->DeleteLocalRef(cls);
 }
 
-JavaMethod::JavaMethod(JNIEnv *env, const char* class_name, const char* method_name, const char* signature)
+JavaMethod::JavaMethod(JNIEnv* env, const char* class_name, const char* method_name, const char* signature,
+                       bool static_method)
 {
     jclass cls = env->FindClass(class_name);
     REALM_ASSERT_DEBUG(cls != nullptr);
-    m_method_id = env->GetMethodID(cls, method_name, signature);
+    if (static_method) {
+        m_method_id = env->GetStaticMethodID(cls, method_name, signature);
+    }
+    else {
+        m_method_id = env->GetMethodID(cls, method_name, signature);
+    }
 }
-
diff --git a/realm/realm-library/src/main/cpp/jni_util/java_method.hpp b/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
index 81c3fd64a4..d6829d9871 100644
--- a/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/java_method.hpp
@@ -27,9 +27,9 @@ namespace jni_util {
 class JavaMethod {
 public:
     JavaMethod() : m_method_id(nullptr) {}
-    JavaMethod(JNIEnv *env, jclass cls, const char* method_name, const char* signature);
+    JavaMethod(JNIEnv *env, jclass cls, const char* method_name, const char* signature, bool static_method = false);
     JavaMethod(JNIEnv *env, jobject obj, const char* method_name, const char* signature);
-    JavaMethod(JNIEnv *env, const char* class_name, const char* method_name, const char* signature);
+    JavaMethod(JNIEnv *env, const char* class_name, const char* method_name, const char* signature, bool static_method = false);
 
     JavaMethod(const JavaMethod&) = default;
     JavaMethod& operator=(const JavaMethod&) = default;
diff --git a/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp b/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
index 7db8ce14d9..64088750ca 100644
--- a/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/jni_utils.cpp
@@ -46,3 +46,6 @@ JNIEnv* JniUtils::get_env(bool attach_if_needed) {
     return env;
 }
 
+void JniUtils::detach_current_thread()  {
+    s_instance->m_vm->DetachCurrentThread();
+}
diff --git a/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp b/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
index 61d8fbddfb..a8d9303786 100644
--- a/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/jni_utils.hpp
@@ -32,6 +32,9 @@ class JniUtils {
     // When attach_if_needed is false, returns the JNIEnv if there is one attached to this thread. Assert if there is
     // none. When attach_if_needed is true, try to attach and return a JNIEnv if necessary.
     static JNIEnv* get_env(bool attach_if_needed = false);
+    // Detach the current thread from the JVM. Only required for C++ threads that where attached in the first place.
+    // Failing to do so is a resource leak.
+    static void detach_current_thread();
 
 private:
     JniUtils(JavaVM* vm, jint vm_version) noexcept : m_vm(vm), m_vm_version(vm_version) {}
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.cpp b/realm/realm-library/src/main/cpp/jni_util/log.cpp
index d4dfbefbc6..b22b45fd41 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.cpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.cpp
@@ -17,7 +17,6 @@
 #include <algorithm>
 
 #include "jni_util/log.hpp"
-#include "util/format.hpp"
 
 using namespace realm;
 using namespace realm::jni_util;
diff --git a/realm/realm-library/src/main/cpp/jni_util/log.hpp b/realm/realm-library/src/main/cpp/jni_util/log.hpp
index ad29c6ede7..930fe81889 100644
--- a/realm/realm-library/src/main/cpp/jni_util/log.hpp
+++ b/realm/realm-library/src/main/cpp/jni_util/log.hpp
@@ -87,19 +87,19 @@ class Log {
     // Helper functions for logging with REALM_JNI tag.
     inline static void t(const char* message)
     {
-        shared().log(error, REALM_JNI_TAG, nullptr, message);
+        shared().log(trace, REALM_JNI_TAG, nullptr, message);
     }
     inline static void d(const char* message)
     {
-        shared().log(error, REALM_JNI_TAG, nullptr, message);
+        shared().log(debug, REALM_JNI_TAG, nullptr, message);
     }
     inline static void i(const char* message)
     {
-        shared().log(error, REALM_JNI_TAG, nullptr, message);
+        shared().log(info, REALM_JNI_TAG, nullptr, message);
     }
     inline static void w(const char* message)
     {
-        shared().log(error, REALM_JNI_TAG, nullptr, message);
+        shared().log(warn, REALM_JNI_TAG, nullptr, message);
     }
     inline static void e(const char* message)
     {
@@ -107,7 +107,7 @@ class Log {
     }
     inline static void f(const char* message)
     {
-        shared().log(error, REALM_JNI_TAG, nullptr, message);
+        shared().log(fatal, REALM_JNI_TAG, nullptr, message);
     }
 
     template<typename... Args>
diff --git a/realm/realm-library/src/main/cpp/object-store b/realm/realm-library/src/main/cpp/object-store
index 2950979535..14c2c7e703 160000
--- a/realm/realm-library/src/main/cpp/object-store
+++ b/realm/realm-library/src/main/cpp/object-store
@@ -1 +1 @@
-Subproject commit 29509795357df374f88950ee471a57900b97ecdf
+Subproject commit 14c2c7e7038850302f60f6fa1e36a22bceb3ab94
diff --git a/realm/realm-library/src/main/cpp/objectserver_shared.hpp b/realm/realm-library/src/main/cpp/objectserver_shared.hpp
deleted file mode 100644
index 2efb7c8b74..0000000000
--- a/realm/realm-library/src/main/cpp/objectserver_shared.hpp
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef REALM_OBJECTSERVER_SHARED_HPP
-#define REALM_OBJECTSERVER_SHARED_HPP
-
-#include <jni.h>
-#include <string>
-#include <thread>
-#include <memory>
-
-#include <realm/sync/history.hpp>
-#include <realm/sync/client.hpp>
-#include <realm/sync/protocol.hpp>
-#include <realm/util/logger.hpp>
-
-#include <impl/realm_coordinator.hpp>
-#include <sync/sync_manager.hpp>
-#include <object-store/src/sync/impl/sync_metadata.hpp>
-#include <object-store/src/sync/impl/sync_file.hpp>
-
-#include "util.hpp"
-#include "jni_util/jni_utils.hpp"
-#include "jni_util/java_global_weak_ref.hpp"
-#include "jni_util/java_method.hpp"
-
-
-// Wrapper class for realm::Session. This allows us to manage the C++ session and callback lifecycle correctly.
-// TODO Use OS SyncSession instead
-class JniSession {
-
-public:
-    JniSession(const JniSession&) = delete;
-    JniSession& operator=(const JniSession&) = delete;
-    JniSession(JniSession&&) = delete;
-    JniSession& operator=(JniSession&&) = delete;
-
-    JniSession(JNIEnv* env, std::string local_realm_path, jobject java_session_obj)
-    : m_java_session_ref(std::make_shared<realm::jni_util::JavaGlobalWeakRef>(env, java_session_obj))
-    {
-        extern std::unique_ptr<realm::sync::Client> sync_client;
-        // Get the coordinator for the given path, or null if there is none
-        m_sync_session = new realm::sync::Session(*sync_client, local_realm_path);
-        // error_handler could be called after JniSession destructed. So we need to pass a weak ref to lambda to avoid
-        // the corrupted pointer.
-        std::weak_ptr<realm::jni_util::JavaGlobalWeakRef> weak_session_ref(m_java_session_ref);
-        auto sync_transact_callback = [local_realm_path](realm::VersionID, realm::VersionID) {
-            auto coordinator = realm::_impl::RealmCoordinator::get_existing_coordinator(
-                    realm::StringData(local_realm_path));
-            if (coordinator) {
-                coordinator->wake_up_notifier_worker();
-            }
-        };
-        auto error_handler = [weak_session_ref, local_realm_path](std::error_code error_code, bool is_fatal, const std::string message) {
-            if (error_code.category() != realm::sync::protocol_error_category() &&
-                    error_code.category() != realm::sync::client_error_category()) {
-                // FIXME: Consider below when moving to the OS sync manager.
-                // Ignore this error since it may cause exceptions in java ErrorCode.fromInt(). Throwing exception there
-                // will trigger "called with pending exception" later since the thread is created by java, and the
-                // endless loop is in native code. The java exception will never be thrown because of the endless loop
-                // will never quit to java land.
-                realm::jni_util::Log::e("Unhandled sync client error code %1, %2. is_fatal: %3.",
-                                        error_code.value(), error_code.message(), is_fatal);
-                return;
-            }
-
-            // Handle client reset, without returning to Java
-
-            // we don't have the original SyncError so we can't call SyncError#is_client_reset_requested
-            // we need to transform the error code to an enum, then do the check manually
-            using ProtocolError = realm::sync::ProtocolError;
-            auto protocol_error = static_cast<ProtocolError>(error_code.value());
-
-            // Documented here: https://realm.io/docs/realm-object-server/#client-recovery-from-a-backup
-            if (protocol_error == ProtocolError::bad_server_file_ident
-                || protocol_error == ProtocolError::bad_client_file_ident
-                || protocol_error == ProtocolError::bad_server_version
-                || protocol_error == ProtocolError::diverging_histories) {
-
-                // Add a SyncFileActionMetadata marking the Realm as needing to be deleted.
-                auto recovery_path = realm::util::reserve_unique_file_name(
-                        realm::SyncManager::shared().recovery_directory_path(),
-                        realm::util::create_timestamped_template("recovered_realm"));
-                auto original_path = local_realm_path;
-
-                realm::jni_util::Log::d("A client reset is scheduled for the next app start");
-                realm::SyncManager::shared().perform_metadata_update([original_path = std::move(original_path),
-                        recovery_path = std::move(recovery_path)](const auto &manager) {
-                    realm::SyncFileActionMetadata(manager,
-                                                  realm::SyncFileActionMetadata::Action::HandleRealmForClientReset,
-                                                  original_path,
-                                                  "",
-                                                  "",
-                                                  realm::util::Optional<std::string>(
-                                                          std::move(recovery_path)));
-                });
-
-            } else {
-                auto session_ref = weak_session_ref.lock();
-                if (session_ref) {
-                        session_ref.get()->call_with_local_ref([&](JNIEnv* local_env, jobject obj) {
-                            static realm::jni_util::JavaMethod notify_error_handler(
-                                    local_env, obj, "notifySessionError", "(ILjava/lang/String;)V");
-                            local_env->CallVoidMethod(
-                                    obj, notify_error_handler, error_code.value(), local_env->NewStringUTF(message.c_str()));
-                        });
-                }
-            }
-        };
-        m_sync_session->set_sync_transact_callback(sync_transact_callback);
-        m_sync_session->set_error_handler(std::move(error_handler));
-    }
-
-    inline realm::sync::Session* get_session() const noexcept
-    {
-        return m_sync_session;
-    }
-
-    ~JniSession()
-    {
-        delete m_sync_session;
-    }
-
-private:
-    realm::sync::Session* m_sync_session;
-    std::shared_ptr<realm::jni_util::JavaGlobalWeakRef> m_java_session_ref;
-};
-
-#endif // REALM_OBJECTSERVER_SHARED_HPP
diff --git a/realm/realm-library/src/main/cpp/util.cpp b/realm/realm-library/src/main/cpp/util.cpp
index 15da4a803c..93c6875949 100644
--- a/realm/realm-library/src/main/cpp/util.cpp
+++ b/realm/realm-library/src/main/cpp/util.cpp
@@ -26,6 +26,7 @@
 #include "io_realm_internal_Util.h"
 #include "io_realm_internal_SharedRealm.h"
 #include "shared_realm.hpp"
+#include "results.hpp"
 
 using namespace std;
 using namespace realm;
@@ -40,8 +41,11 @@ jmethodID java_lang_float_init;
 jclass java_lang_double;
 jclass java_lang_string;
 jmethodID java_lang_double_init;
-jclass session_class_ref;
-jmethodID session_error_handler;
+jclass java_util_date;
+jmethodID java_util_date_init;
+#if REALM_ENABLE_SYNC
+jclass java_syncmanager;
+#endif
 
 void ThrowRealmFileException(JNIEnv* env, const std::string& message, realm::RealmFileException::Kind kind);
 
@@ -83,6 +87,29 @@ void ConvertException(JNIEnv* env, const char *file, int line)
         ss << e.what() << " in " << file << " line " << line;
         ThrowException(env, IllegalArgument, ss.str());
     }
+    catch (Results::OutOfBoundsIndexException& e) {
+        ss << "Out of range  in " << file << " line " << line
+           << "(requested: " << e.requested << " valid: " << e.valid_count << ")";
+        ThrowException(env, IndexOutOfBounds, ss.str());
+    }
+    catch (Results::IncorrectTableException& e) {
+        ss << "Incorrect class in " << file << " line " << line
+           << "(actual: " << e.actual << " expected: " << e.expected << ")";
+        ThrowException(env, IllegalArgument, ss.str());
+    }
+    catch (Results::UnsupportedColumnTypeException& e) {
+        ss << "Unsupported type in " << file << " line " << line
+           << "(field name: " << e.column_name << ")";
+        ThrowException(env, IllegalArgument, ss.str());
+    }
+    catch (Results::InvalidatedException& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, IllegalState, ss.str());
+    }
+    catch (IncorrectThreadException& e) {
+        ss << e.what() << " in " << file << " line " << line;
+        ThrowException(env, IllegalState, ss.str());
+    }
     catch (std::logic_error e) {
         ThrowException(env, IllegalState, e.what());
     }
diff --git a/realm/realm-library/src/main/cpp/util.hpp b/realm/realm-library/src/main/cpp/util.hpp
index 021752f6c3..06c574c3ea 100644
--- a/realm/realm-library/src/main/cpp/util.hpp
+++ b/realm/realm-library/src/main/cpp/util.hpp
@@ -31,7 +31,6 @@
 #include <realm/timestamp.hpp>
 #include <realm/util/meta.hpp>
 #include <realm/util/safe_int_ops.hpp>
-#include <realm/sync/client.hpp>
 
 #include <util/format.hpp>
 
@@ -51,9 +50,6 @@ JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved);
 }
 #endif
 
-// Use this macro when logging a pointer using '%p'
-#define VOID_PTR(ptr) reinterpret_cast<void*>(ptr)
-
 #define STRINGIZE_DETAIL(x) #x
 #define STRINGIZE(x) STRINGIZE_DETAIL(x)
 
@@ -75,8 +71,9 @@ std::string num_to_string(T pNumber)
 #define MAX_JINT   0x7FFFFFFFL
 #define MAX_JSIZE  MAX_JINT
 
+// TODO: Clean up those marcos. Casting with marcos reduces the readability, and it is actually breaking the C++ type
+// conversion. e.g.: You cannot cast a pointer with S64 below.
 // Helper macros for better readability
-// Use S64() when logging
 #define S(x)    static_cast<size_t>(x)
 #define B(x)    static_cast<bool>(x)
 #define S64(x)  static_cast<int64_t>(x)
@@ -86,8 +83,6 @@ std::string num_to_string(T pNumber)
 #define Q(x)    reinterpret_cast<realm::Query*>(x)
 #define ROW(x)  reinterpret_cast<realm::Row*>(x)
 #define HO(T, ptr) reinterpret_cast<realm::SharedGroup::Handover <T>* >(ptr)
-#define SC(ptr) reinterpret_cast<realm::sync::Client*>(ptr)
-#define SS(ptr) reinterpret_cast<JniSession*>(ptr)
 
 // Exception handling
 enum ExceptionKind {
@@ -120,6 +115,7 @@ jclass GetClass(JNIEnv* env, const char* classStr);
 
 #define TABLE_VALID(env,ptr)    TableIsValid(env, ptr)
 #define ROW_VALID(env,ptr)      RowIsValid(env, ptr)
+#define QUERY_VALID(env, ptr)   QueryIsValid(env, ptr)
 
 #if CHECK_PARAMETERS
 
@@ -187,7 +183,7 @@ inline bool TableIsValid(JNIEnv* env, T* objPtr)
 
     }
     if (!valid) {
-        realm::jni_util::Log::e("Table %1 is no longer attached!", VOID_PTR(objPtr));
+        realm::jni_util::Log::e("Table %1 is no longer attached!", reinterpret_cast<int64_t>(objPtr));
         ThrowException(env, IllegalState, "Table is no longer valid to operate on.");
     }
     return valid;
@@ -197,12 +193,18 @@ inline bool RowIsValid(JNIEnv* env, realm::Row* rowPtr)
 {
     bool valid = (rowPtr != NULL && rowPtr->is_attached());
     if (!valid) {
-        realm::jni_util::Log::e("Row %1 is no longer attached!", VOID_PTR(rowPtr));
+        realm::jni_util::Log::e("Row %1 is no longer attached!", reinterpret_cast<int64_t>(rowPtr));
         ThrowException(env, IllegalState, "Object is no longer valid to operate on. Was it deleted by another thread?");
     }
     return valid;
 }
 
+inline bool QueryIsValid(JNIEnv* env, realm::Query* query)
+{
+    return TableIsValid(env, query->get_table().get());
+}
+
+
 // Requires an attached Table
 template <class T>
 bool RowIndexesValid(JNIEnv* env, T* pTable, jlong startIndex, jlong endIndex, jlong range)
@@ -493,6 +495,21 @@ class JniLongArray {
         , m_releaseMode(JNI_ABORT) {
     }
 
+    JniLongArray(JniLongArray& other) = delete;
+
+    JniLongArray(JniLongArray&& other)
+            : m_env(other.m_env)
+            , m_javaArray(other.m_javaArray)
+            , m_arrayLength(other.m_arrayLength)
+            , m_array(other.m_array)
+            , m_releaseMode(other.m_releaseMode)
+    {
+        other.m_env = nullptr;
+        other.m_javaArray = nullptr;
+        other.m_arrayLength = 0;
+        other.m_array = nullptr;
+    }
+
     ~JniLongArray()
     {
         if (m_array) {
@@ -521,11 +538,47 @@ class JniLongArray {
     }
 
 private:
-    JNIEnv*    const m_env;
-    jlongArray const m_javaArray;
-    jsize      const m_arrayLength;
-    jlong*     const m_array;
-    jint             m_releaseMode;
+    JNIEnv*    m_env;
+    jlongArray m_javaArray;
+    jsize      m_arrayLength;
+    jlong*     m_array;
+    jint       m_releaseMode;
+};
+
+template <typename T, typename J>
+class JniArrayOfArrays {
+public:
+    JniArrayOfArrays(JNIEnv* env, jobjectArray javaArray)
+            : m_env(env)
+            , m_javaArray(javaArray)
+            , m_arrayLength(javaArray == nullptr ? 0 : env->GetArrayLength(javaArray))
+    {
+        for (int i = 0; i < m_arrayLength; ++i) {
+            // No type checking. Internal use only.
+            J j_array = static_cast<J>(env->GetObjectArrayElement(m_javaArray, i));
+            m_array.push_back(T(env, j_array));
+        }
+    }
+
+    ~JniArrayOfArrays()
+    {
+    }
+
+    inline jsize len() const noexcept
+    {
+        return m_arrayLength;
+    }
+
+    inline T& operator[](const int index) noexcept
+    {
+        return m_array[index];
+    }
+
+private:
+    JNIEnv* const m_env;
+    jobjectArray const m_javaArray;
+    jsize const m_arrayLength;
+    std::vector<T> m_array;
 };
 
 class JniByteArray {
@@ -643,10 +696,11 @@ extern jmethodID java_lang_float_init;
 extern jclass java_lang_double;
 extern jclass java_lang_string;
 extern jmethodID java_lang_double_init;
-
-// FIXME Move to own library
-extern jclass session_class_ref;
-extern jmethodID session_error_handler;
+extern jclass java_util_date;
+extern jmethodID java_util_date_init;
+#if REALM_ENABLE_SYNC
+extern jclass java_syncmanager;
+#endif
 
 inline jobject NewLong(JNIEnv* env, int64_t value)
 {
@@ -681,10 +735,18 @@ inline realm::Timestamp from_milliseconds(jlong milliseconds)
     return realm::Timestamp(seconds, nanoseconds);
 }
 
+inline jobject NewDate(JNIEnv* env, const realm::Timestamp& ts) {
+    return env->NewObject(java_util_date, java_util_date_init, to_milliseconds(ts));
+}
+
 extern const std::string TABLE_PREFIX;
 
 static inline bool to_bool(jboolean b) {
     return b == JNI_TRUE;
 }
 
+static inline jboolean to_jbool(bool b) {
+    return b?JNI_TRUE:JNI_FALSE;
+}
+
 #endif // REALM_JAVA_UTIL_HPP
diff --git a/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java b/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
deleted file mode 100644
index f54d8bc330..0000000000
--- a/realm/realm-library/src/main/java/io/realm/AndroidNotifier.java
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-
-import io.realm.internal.HandlerControllerConstants;
-import io.realm.internal.RealmNotifier;
-import io.realm.internal.async.QueryUpdateTask;
-import io.realm.log.RealmLog;
-
-/**
- * Implementation of {@link RealmNotifier} for Android based on {@link Handler}.
- */
-class AndroidNotifier implements RealmNotifier {
-    private Handler handler;
-
-    public AndroidNotifier(HandlerController handlerController) {
-        if (isAutoRefreshAvailable()) {
-            handler = new Handler(handlerController);
-        }
-    }
-
-    // Called by Java when transaction committed to send LOCAL_COMMIT to current thread's handler.
-    @Override
-    public void notifyCommitByLocalThread() {
-        if (handler == null) {
-            return;
-        }
-
-        // Forces any updates on the current thread to the front the queue. Doing this is mostly
-        // relevant on the UI thread where it could otherwise process a motion event before the
-        // REALM_CHANGED event. This could in turn cause a UI component like ListView to crash. See
-        // https://github.com/realm/realm-android-adapters/issues/11 for such a case.
-        // Other Looper threads could process similar events. For that reason all looper threads will
-        // prioritize local commits.
-        //
-        // If a user is doing commits inside a RealmChangeListener this can cause the Looper thread to get
-        // event starved as it only starts handling Realm events instead. This is an acceptable risk as
-        // that behaviour indicate a user bug. Previously this would be hidden as the UI would still
-        // be responsive.
-        Message msg = Message.obtain();
-        msg.what = HandlerControllerConstants.LOCAL_COMMIT;
-        if (!handler.hasMessages(HandlerControllerConstants.LOCAL_COMMIT)) {
-            handler.removeMessages(HandlerControllerConstants.REALM_CHANGED);
-            handler.sendMessageAtFrontOfQueue(msg);
-        }
-    }
-
-    // This is called by OS when other thread/process changes the Realm.
-    // This is getting called on the same thread which created the Realm.
-    // |---------------------------------------------------------------+--------------+------------------------------------------------|
-    // | Thread A                                                      | Thread B     | Daemon Thread                                  |
-    // |---------------------------------------------------------------+--------------+------------------------------------------------|
-    // |                                                               | Make changes |                                                |
-    // |                                                               |              | Detect and notify thread A through JNI ALooper |
-    // | Call OS's Realm::notify() from OS's ALooper callback          |              |                                                |
-    // | Realm::notify() calls JavaBindingContext:change_available()   |              |                                                |
-    // | change_available calls into this method to send REALM_CHANGED |              |                                                |
-    // |---------------------------------------------------------------+--------------+------------------------------------------------|
-    @Override
-    public void notifyCommitByOtherThread() {
-        if (handler == null) {
-            return;
-        }
-
-        // Note there is a race condition with handler.hasMessages() and handler.sendEmptyMessage()
-        // as the target thread consumes messages at the same time. In this case it is not a problem as worst
-        // case we end up with two REALM_CHANGED messages in the queue.
-        boolean messageHandled = true;
-        if (!handler.hasMessages(HandlerControllerConstants.REALM_CHANGED) &&
-                !handler.hasMessages(HandlerControllerConstants.LOCAL_COMMIT)) {
-            messageHandled = handler.sendEmptyMessage(HandlerControllerConstants.REALM_CHANGED);
-        }
-        if (!messageHandled) {
-            RealmLog.warn("Cannot update Looper threads when the Looper has quit. Use realm.setAutoRefresh(false) " +
-                    "to prevent this.");
-        }
-    }
-
-    @Override
-    public void post(Runnable runnable) {
-        Looper looper = handler.getLooper();
-        if (looper.getThread().isAlive()) {     // The receiving thread is alive
-            handler.post(runnable);
-        }
-    }
-
-    @Override
-    public boolean isValid() {
-        return handler != null;
-    }
-
-    @Override
-    public void close() {
-        if (handler != null) {
-            handler.removeCallbacksAndMessages(null);
-            handler = null;
-        }
-    }
-
-    @Override
-    public void completeAsyncResults(QueryUpdateTask.Result result) {
-        Looper looper = handler.getLooper();
-        if (looper.getThread().isAlive()) {     // The receiving thread is alive
-            handler.obtainMessage(HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS, result).sendToTarget();
-        }
-    }
-
-    @Override
-    public void completeAsyncObject(QueryUpdateTask.Result result) {
-        Looper looper = handler.getLooper();
-        if (looper.getThread().isAlive()) {     // The receiving thread is alive
-            handler.obtainMessage(HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT, result).sendToTarget();
-        }
-    }
-
-    @Override
-    public void throwBackgroundException(Throwable throwable) {
-        Looper looper = handler.getLooper();
-        if (looper.getThread().isAlive()) {     // The receiving thread is alive
-            handler.obtainMessage(
-                    HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION, new Error(throwable)).sendToTarget();
-        }
-    }
-
-    @Override
-    public void completeUpdateAsyncQueries(QueryUpdateTask.Result result) {
-        Looper looper = handler.getLooper();
-        if (looper.getThread().isAlive()) {     // The receiving thread is alive
-            handler.obtainMessage(HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES, result).sendToTarget();
-        }
-    }
-
-    private static boolean isAutoRefreshAvailable() {
-        return (Looper.myLooper() != null && !isIntentServiceThread());
-    }
-
-    private static boolean isIntentServiceThread() {
-        // Tries to determine if a thread is an IntentService thread. No public API can detect this,
-        // so use the thread name as a heuristic:
-        // https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/IntentService.java#108
-        String threadName = Thread.currentThread().getName();
-        return threadName != null && threadName.startsWith("IntentService[");
-    }
-
-    // For testing purpose only. Should be removed ideally.
-    public void setHandler(Handler handler) {
-        this.handler = handler;
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/BaseRealm.java b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
index d3f1a7f70c..9bdadab377 100644
--- a/realm/realm-library/src/main/java/io/realm/BaseRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/BaseRealm.java
@@ -17,7 +17,6 @@
 package io.realm;
 
 import android.content.Context;
-import android.os.Handler;
 import android.os.Looper;
 
 import java.io.Closeable;
@@ -29,9 +28,9 @@
 
 import io.realm.exceptions.RealmFileException;
 import io.realm.exceptions.RealmMigrationNeededException;
+import io.realm.internal.CheckedRow;
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.InvalidRow;
-import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
 import io.realm.internal.SharedRealm;
@@ -59,6 +58,7 @@
             "This Realm instance has already been closed, making it unusable.";
     private static final String NOT_IN_TRANSACTION_MESSAGE =
             "Changing Realm data can only be done from inside a transaction.";
+    static final String LISTENER_NOT_ALLOWED_MESSAGE = "Listeners cannot be used on current thread.";
 
 
     volatile static Context applicationContext;
@@ -71,15 +71,12 @@
     protected SharedRealm sharedRealm;
 
     RealmSchema schema;
-    HandlerController handlerController;
-
 
     protected BaseRealm(RealmConfiguration configuration) {
         this.threadId = Thread.currentThread().getId();
         this.configuration = configuration;
 
-        this.handlerController = new HandlerController(this);
-        this.sharedRealm = SharedRealm.getInstance(configuration, new AndroidNotifier(this.handlerController),
+        this.sharedRealm = SharedRealm.getInstance(configuration,
                 !(this instanceof Realm) ? null :
                 new SharedRealm.SchemaVersionListener() {
                     @Override
@@ -88,10 +85,6 @@ public void onSchemaVersionChanged(long currentVersion) {
                     }
                 }, true);
         this.schema = new RealmSchema(this);
-
-        if (handlerController.isAutoRefreshAvailable()) {
-            setAutoRefresh(true);
-        }
     }
 
     /**
@@ -107,8 +100,7 @@ public void onSchemaVersionChanged(long currentVersion) {
      */
     public void setAutoRefresh(boolean autoRefresh) {
         checkIfValid();
-        handlerController.checkCanBeAutoRefreshed();
-        handlerController.setAutoRefresh(autoRefresh);
+        sharedRealm.setAutoRefresh(autoRefresh);
     }
 
     /**
@@ -117,7 +109,7 @@ public void setAutoRefresh(boolean autoRefresh) {
      * @return the auto-refresh status.
      */
     public boolean isAutoRefresh() {
-        return handlerController.isAutoRefreshEnabled();
+        return sharedRealm.isAutoRefresh();
     }
 
     /**
@@ -130,15 +122,14 @@ public boolean isInTransaction() {
         return sharedRealm.isInTransaction();
     }
 
-    protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
+    protected <T extends BaseRealm> void addListener(RealmChangeListener<T> listener) {
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
         checkIfValid();
-        if (!handlerController.isAutoRefreshEnabled()) {
-            throw new IllegalStateException("You can't register a listener from a non-Looper or IntentService thread.");
-        }
-        handlerController.addChangeListener(listener);
+        sharedRealm.capabilities.checkCanDeliverNotification(LISTENER_NOT_ALLOWED_MESSAGE);
+        //noinspection unchecked
+        sharedRealm.realmNotifier.addChangeListener((T) this, listener);
     }
 
     /**
@@ -149,15 +140,14 @@ protected void addListener(RealmChangeListener<? extends BaseRealm> listener) {
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
      */
-    public void removeChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
+    protected <T extends BaseRealm> void removeListener(RealmChangeListener<T> listener) {
         if (listener == null) {
             throw new IllegalArgumentException("Listener should not be null");
         }
         checkIfValid();
-        if (!handlerController.isAutoRefreshEnabled()) {
-            throw new IllegalStateException("You can't remove a listener from a non-Looper thread ");
-        }
-        handlerController.removeChangeListener(listener);
+        sharedRealm.capabilities.checkCanDeliverNotification(LISTENER_NOT_ALLOWED_MESSAGE);
+        //noinspection unchecked
+        sharedRealm.realmNotifier.removeChangeListener((T) this, listener);
     }
 
     /**
@@ -186,21 +176,12 @@ public void removeChangeListener(RealmChangeListener<? extends BaseRealm> listen
      * @throws IllegalStateException if you try to remove listeners from a non-Looper Thread.
      * @see io.realm.RealmChangeListener
      */
-    public void removeAllChangeListeners() {
+    protected void removeAllListeners() {
         checkIfValid();
-        if (!handlerController.isAutoRefreshEnabled()) {
-            throw new IllegalStateException("You can't remove listeners from a non-Looper thread ");
-        }
-        handlerController.removeAllChangeListeners();
-    }
-
-    // WARNING: If this method is used after calling any async method, the old handler will still be used.
-    //          package private, for test purpose only
-    void setHandler(Handler handler) {
-        ((AndroidNotifier)sharedRealm.realmNotifier).setHandler(handler);
+        sharedRealm.capabilities.checkCanDeliverNotification("removeListener cannot be called on current thread.");
+        sharedRealm.realmNotifier.removeChangeListeners(this);
     }
 
-
     /**
      * Writes a compacted copy of the Realm to the given destination File.
      * <p>
@@ -263,7 +244,6 @@ public boolean waitForChange() {
         if (hasChanged) {
             // Since this Realm instance has been waiting for change, advance realm & refresh realm.
             sharedRealm.refresh();
-            handlerController.refreshSynchronousTableViews();
         }
         return hasChanged;
     }
@@ -335,26 +315,8 @@ public void beginTransaction() {
      * changes from this commit.
      */
     public void commitTransaction() {
-        commitTransaction(true);
-    }
-
-    /**
-     * Commits transaction and sends notifications to local thread.
-     *
-     * @param notifyLocalThread set to {@code false} to prevent this commit from triggering thread local change
-     *                          listeners.
-     */
-    void commitTransaction(boolean notifyLocalThread) {
         checkIfValid();
         sharedRealm.commitTransaction();
-        ObjectServerFacade.getFacade(configuration.isSyncConfiguration())
-                .notifyCommit(configuration, sharedRealm.getLastSnapshotVersion());
-
-        // Sometimes we don't want to notify the local thread about commits, e.g. creating a completely new Realm
-        // file will make a commit in order to create the schema. Users should not be notified about that.
-        if (notifyLocalThread) {
-            sharedRealm.realmNotifier.notifyCommitByLocalThread();
-        }
     }
 
     /**
@@ -505,6 +467,24 @@ public RealmSchema getSchema() {
         return schema;
     }
 
+    // Used by RealmList/RealmResults, to create RealmObject from a Collection.
+    // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
+    <E extends RealmModel> E get(Class<E> clazz, String dynamicClassName, UncheckedRow row) {
+        final boolean isDynamicRealmObject = dynamicClassName != null;
+
+        E result;
+        if (isDynamicRealmObject) {
+            //noinspection unchecked
+            result = (E) new DynamicRealmObject(this, CheckedRow.getFromRow(row));
+        } else {
+            result = configuration.getSchemaMediator().newInstance(clazz, this, row, schema.getColumnInfo(clazz),
+                    false, Collections.<String> emptyList());
+        }
+        RealmObjectProxy proxy = (RealmObjectProxy) result;
+        proxy.realmGet$proxyState().setTableVersion$realm();
+        return result;
+    }
+
     <E extends RealmModel> E get(Class<E> clazz, long rowIndex, boolean acceptDefaultValue, List<String> excludeFields) {
         Table table = schema.getTable(clazz);
         UncheckedRow row = table.getUncheckedRow(rowIndex);
@@ -517,6 +497,7 @@ public RealmSchema getSchema() {
 
     // Used by RealmList/RealmResults
     // Invariant: if dynamicClassName != null -> clazz == DynamicRealmObject
+    // TODO: Remove this after RealmList is backed by OS Results.
     <E extends RealmModel> E get(Class<E> clazz, String dynamicClassName, long rowIndex) {
         final boolean isDynamicRealmObject = dynamicClassName != null;
         final Table table = isDynamicRealmObject ? schema.getTable(dynamicClassName) : schema.getTable(clazz);
@@ -597,6 +578,7 @@ static boolean compactRealm(final RealmConfiguration configuration) {
      * @param callback callback for specific Realm type behaviors.
      * @param cause which triggers this migration.
      * @throws FileNotFoundException if the Realm file doesn't exist.
+     * @throws IllegalArgumentException if the provided configuration is a {@link SyncConfiguration}.
      */
     protected static void migrateRealm(final RealmConfiguration configuration, final RealmMigration migration,
                                        final MigrationCallback callback, final RealmMigrationNeededException cause)
@@ -606,7 +588,7 @@ protected static void migrateRealm(final RealmConfiguration configuration, final
             throw new IllegalArgumentException("RealmConfiguration must be provided");
         }
         if (configuration.isSyncConfiguration()) {
-            return;
+            throw new IllegalArgumentException("Manual migrations are not supported for synced Realms");
         }
         if (migration == null && configuration.getMigration() == null) {
             throw new RealmMigrationNeededException(configuration.getPath(), "RealmMigration must be provided", cause);
@@ -657,11 +639,6 @@ public void onResult(int count) {
         }
     }
 
-    // Returns true if this Realm can receive notifications.
-    boolean hasValidNotifier() {
-        return sharedRealm.realmNotifier != null && sharedRealm.realmNotifier.isValid();
-    }
-
     @Override
     protected void finalize() throws Throwable {
         if (sharedRealm != null && !sharedRealm.isClosed()) {
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
index 6df8fea533..30d66ad0e5 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealm.java
@@ -16,8 +16,6 @@
 
 package io.realm;
 
-import android.app.IntentService;
-
 import io.realm.exceptions.RealmException;
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.Table;
@@ -123,8 +121,7 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
     /**
      * Adds a change listener to the Realm.
      * <p>
-     * The listeners will be executed on every loop of a Handler thread if changes are committed by
-     * this or another thread.
+     * The listeners will be executed when changes are committed by this or another thread.
      * <p>
      * Realm instances are cached per thread. For that reason it is important to
      * remember to remove listeners again either using {@link #removeChangeListener(RealmChangeListener)}
@@ -132,13 +129,35 @@ public DynamicRealmObject createObject(String className, Object primaryKeyValue)
      *
      * @param listener the change listener.
      * @throws IllegalArgumentException if the change listener is {@code null}.
-     * @throws IllegalStateException if you try to register a listener from a non-Looper or {@link IntentService} thread.
      * @see io.realm.RealmChangeListener
      * @see #removeChangeListener(RealmChangeListener)
      * @see #removeAllChangeListeners()
+     * @see #waitForChange()
      */
     public void addChangeListener(RealmChangeListener<DynamicRealm> listener) {
-        super.addListener(listener);
+        addListener(listener);
+    }
+
+    /**
+     * Removes the specified change listener.
+     *
+     * @param listener the change listener to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     */
+    public void removeChangeListener(RealmChangeListener<DynamicRealm> listener) {
+        removeListener(listener);
+    }
+
+    /**
+     * Removes all user-defined change listeners.
+     *
+     * @throws IllegalStateException if you try to remove listeners from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     */
+    public void removeAllChangeListeners() {
+        removeAllListeners();
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
index 1d35df1b8c..7488623c72 100644
--- a/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/DynamicRealmObject.java
@@ -75,14 +75,6 @@ public DynamicRealmObject(RealmModel obj) {
         proxyState.setConstructionFinished();
     }
 
-    // row must not be an instance of UncheckedRow
-    DynamicRealmObject(String className, BaseRealm realm, Row row) {
-        proxyState.setClassName(className);
-        proxyState.setRealm$realm(realm);
-        proxyState.setRow$realm(row);
-        proxyState.setConstructionFinished();
-    }
-
     /**
      * Returns the value for the given field.
      *
@@ -92,6 +84,8 @@ public DynamicRealmObject(RealmModel obj) {
      */
     @SuppressWarnings("unchecked")
     public <E> E get(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
         switch (type) {
@@ -123,6 +117,8 @@ public DynamicRealmObject(RealmModel obj) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public boolean getBoolean(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
             return proxyState.getRow$realm().getBoolean(columnIndex);
@@ -174,6 +170,8 @@ public short getShort(String fieldName) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public long getLong(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
             return proxyState.getRow$realm().getLong(columnIndex);
@@ -210,6 +208,8 @@ public byte getByte(String fieldName) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public float getFloat(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
             return proxyState.getRow$realm().getFloat(columnIndex);
@@ -231,6 +231,8 @@ public float getFloat(String fieldName) {
      * @throws io.realm.exceptions.RealmException if the return value would be {@code null}.
      */
     public double getDouble(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
             return proxyState.getRow$realm().getDouble(columnIndex);
@@ -248,6 +250,8 @@ public double getDouble(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain binary data.
      */
     public byte[] getBlob(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
             return proxyState.getRow$realm().getBinaryByteArray(columnIndex);
@@ -265,6 +269,8 @@ public double getDouble(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain Strings.
      */
     public String getString(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
             return proxyState.getRow$realm().getString(columnIndex);
@@ -282,6 +288,8 @@ public String getString(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain Dates.
      */
     public Date getDate(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         checkFieldType(fieldName, columnIndex, RealmFieldType.DATE);
         if (proxyState.getRow$realm().isNull(columnIndex)) {
@@ -299,6 +307,8 @@ public Date getDate(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain links to other objects.
      */
     public DynamicRealmObject getObject(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         checkFieldType(fieldName, columnIndex, RealmFieldType.OBJECT);
         if (proxyState.getRow$realm().isNullLink(columnIndex)) {
@@ -318,6 +328,8 @@ public DynamicRealmObject getObject(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist or it doesn't contain a list of links.
      */
     public RealmList<DynamicRealmObject> getList(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         try {
             LinkView linkView = proxyState.getRow$realm().getLinkList(columnIndex);
@@ -337,6 +349,8 @@ public DynamicRealmObject getObject(String fieldName) {
      * @throws IllegalArgumentException if field name doesn't exist.
      */
     public boolean isNull(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
         switch (type) {
@@ -365,6 +379,8 @@ public boolean isNull(String fieldName) {
      * @return {@code true} if the object has a field with the given name, {@code false} otherwise.
      */
     public boolean hasField(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         //noinspection SimplifiableIfStatement
         if (fieldName == null || fieldName.isEmpty()) {
             return false;
@@ -378,6 +394,8 @@ public boolean hasField(String fieldName) {
      * @return list of field names on this objects or the empty list if the object doesn't have any fields.
      */
     public String[] getFieldNames() {
+        proxyState.getRealm$realm().checkIfValid();
+
         String[] keys = new String[(int) proxyState.getRow$realm().getColumnCount()];
         for (int i = 0; i < keys.length; i++) {
             keys[i] = proxyState.getRow$realm().getColumnName(i);
@@ -399,6 +417,8 @@ public boolean hasField(String fieldName) {
      */
     @SuppressWarnings("unchecked")
     public void set(String fieldName, Object value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         boolean isString = (value instanceof String);
         String strValue = isString ? (String) value : null;
 
@@ -468,6 +488,8 @@ private void setValue(String fieldName, Object value) {
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a boolean field.
      */
     public void setBoolean(String fieldName, boolean value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setBoolean(columnIndex, value);
     }
@@ -481,6 +503,8 @@ public void setBoolean(String fieldName, boolean value) {
      * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setShort(String fieldName, short value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
@@ -495,6 +519,8 @@ public void setShort(String fieldName, short value) {
      * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setInt(String fieldName, int value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
@@ -509,6 +535,8 @@ public void setInt(String fieldName, int value) {
      * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setLong(String fieldName, long value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
@@ -523,6 +551,8 @@ public void setLong(String fieldName, long value) {
      * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setByte(String fieldName, byte value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setLong(columnIndex, value);
@@ -536,6 +566,8 @@ public void setByte(String fieldName, byte value) {
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a float field.
      */
     public void setFloat(String fieldName, float value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setFloat(columnIndex, value);
     }
@@ -548,6 +580,8 @@ public void setFloat(String fieldName, float value) {
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a double field.
      */
     public void setDouble(String fieldName, double value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setDouble(columnIndex, value);
     }
@@ -561,6 +595,8 @@ public void setDouble(String fieldName, double value) {
      * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setString(String fieldName, String value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         checkIsPrimaryKey(fieldName);
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setString(columnIndex, value);
@@ -574,6 +610,8 @@ public void setString(String fieldName, String value) {
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a binary field.
      */
     public void setBlob(String fieldName, byte[] value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         proxyState.getRow$realm().setBinaryByteArray(columnIndex, value);
     }
@@ -586,6 +624,8 @@ public void setBlob(String fieldName, byte[] value) {
      * @throws IllegalArgumentException if field name doesn't exist or field isn't a Date field.
      */
     public void setDate(String fieldName, Date value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         if (value == null) {
             proxyState.getRow$realm().setNull(columnIndex);
@@ -603,6 +643,8 @@ public void setDate(String fieldName, Date value) {
      * of DynamicRealmObject doesn't match or it belongs to a different Realm.
      */
     public void setObject(String fieldName, DynamicRealmObject value) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         if (value == null) {
             proxyState.getRow$realm().nullifyLink(columnIndex);
@@ -633,30 +675,37 @@ public void setObject(String fieldName, DynamicRealmObject value) {
      * different Realm.
      */
     public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
+        proxyState.getRealm$realm().checkIfValid();
+
         if (list == null) {
             throw new IllegalArgumentException("Null values not allowed for lists");
         }
 
-        String tableName = proxyState.getRow$realm().getTable().getName();
+        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
+        LinkView links = proxyState.getRow$realm().getLinkList(columnIndex);
+        Table linkTargetTable = links.getTargetTable();
+        final String linkTargetTableName = Table.tableNameToClassName(linkTargetTable.getName());
+
         boolean typeValidated;
         if (list.className == null && list.clazz == null) {
             // Unmanaged lists don't know anything about the types they contain. They might even hold objects of
             // multiple types :(, so we have to check each item in the list.
             typeValidated = false;
         } else {
-            String listType = list.className != null ? list.className : proxyState.getRealm$realm().schema.getTable(list.clazz).getName();
-            if (!tableName.equals(listType)) {
-                throw new IllegalArgumentException(String.format("The elements in the list is not the proper type. " +
-                        "Was %s expected %s.", listType, tableName));
+            String listType = list.className != null ? list.className
+                    : Table.tableNameToClassName(proxyState.getRealm$realm().schema.getTable(list.clazz).getName());
+            if (!linkTargetTableName.equals(listType)) {
+                throw new IllegalArgumentException(String.format(Locale.ENGLISH,
+                        "The elements in the list are not the proper type. " +
+                        "Was %s expected %s.", listType, linkTargetTableName));
             }
             typeValidated = true;
         }
 
-        long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
-        LinkView links = proxyState.getRow$realm().getLinkList(columnIndex);
-        links.clear();
-        Table linkTargetTable = links.getTargetTable();
-        for (int i = 0; i < list.size(); i++) {
+        final int listLength = list.size();
+        final long[] indices = new long[listLength];
+
+        for (int i = 0; i < listLength; i++) {
             RealmObjectProxy obj = list.get(i);
             if (obj.realmGet$proxyState().getRealm$realm() != proxyState.getRealm$realm()) {
                 throw new IllegalArgumentException("Each element in 'list' must belong to the same Realm instance.");
@@ -664,9 +713,17 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
             if (!typeValidated && !linkTargetTable.hasSameSchema(obj.realmGet$proxyState().getRow$realm().getTable())) {
                 throw new IllegalArgumentException(String.format(Locale.ENGLISH,
                         "Element at index %d is not the proper type. " +
-                                "Was '%s' expected '%s'.", i, obj.realmGet$proxyState().getRow$realm().getTable().getName(), linkTargetTable.getName()));
+                                "Was '%s' expected '%s'.",
+                        i,
+                        Table.tableNameToClassName(obj.realmGet$proxyState().getRow$realm().getTable().getName()),
+                        linkTargetTableName));
             }
-            links.add(obj.realmGet$proxyState().getRow$realm().getIndex());
+            indices[i] = obj.realmGet$proxyState().getRow$realm().getIndex();
+        }
+
+        links.clear();
+        for (int i = 0; i < listLength; i++) {
+            links.add(indices[i]);
         }
     }
 
@@ -678,6 +735,8 @@ public void setList(String fieldName, RealmList<DynamicRealmObject> list) {
      * @throws RealmException if the field is a {@link io.realm.annotations.PrimaryKey} field.
      */
     public void setNull(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         RealmFieldType type = proxyState.getRow$realm().getColumnType(columnIndex);
         if (type == RealmFieldType.OBJECT) {
@@ -695,6 +754,8 @@ public void setNull(String fieldName) {
      * @return this objects type.
      */
     public String getType() {
+        proxyState.getRealm$realm().checkIfValid();
+
         return RealmSchema.getSchemaForTable(proxyState.getRow$realm().getTable());
     }
 
@@ -704,6 +765,8 @@ public String getType() {
      * @return the underlying type used by Realm to represent this field.
      */
     public RealmFieldType getFieldType(String fieldName) {
+        proxyState.getRealm$realm().checkIfValid();
+
         long columnIndex = proxyState.getRow$realm().getColumnIndex(fieldName);
         return proxyState.getRow$realm().getColumnType(columnIndex);
     }
@@ -739,6 +802,8 @@ private void checkFieldType(String fieldName, long columnIndex, RealmFieldType e
      */
     @Override
     public int hashCode() {
+        proxyState.getRealm$realm().checkIfValid();
+
         String realmName = proxyState.getRealm$realm().getPath();
         String tableName = proxyState.getRow$realm().getTable().getName();
         long rowIndex = proxyState.getRow$realm().getIndex();
@@ -752,12 +817,15 @@ public int hashCode() {
 
     @Override
     public boolean equals(Object o) {
+        proxyState.getRealm$realm().checkIfValid();
+
         if (this == o) {
             return true;
         }
         if (o == null || getClass() != o.getClass()) {
             return false;
         }
+
         DynamicRealmObject other = (DynamicRealmObject) o;
 
         String path = proxyState.getRealm$realm().getPath();
@@ -778,7 +846,9 @@ public boolean equals(Object o) {
 
     @Override
     public String toString() {
-        if (proxyState.getRealm$realm() == null || !proxyState.getRow$realm().isAttached()) {
+        proxyState.getRealm$realm().checkIfValid();
+
+        if (!proxyState.getRow$realm().isAttached()) {
             return "Invalid object";
         }
 
@@ -835,6 +905,11 @@ public String toString() {
         return sb.toString();
     }
 
+    @Override
+    public void realm$injectObjectContext() {
+        // nothing to do for DynamicRealmObject
+    }
+
     @Override
     public ProxyState realmGet$proxyState() {
         return proxyState;
diff --git a/realm/realm-library/src/main/java/io/realm/HandlerController.java b/realm/realm-library/src/main/java/io/realm/HandlerController.java
deleted file mode 100644
index db6c1d3f1b..0000000000
--- a/realm/realm-library/src/main/java/io/realm/HandlerController.java
+++ /dev/null
@@ -1,833 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-
-import java.lang.ref.Reference;
-import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.Future;
-
-import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
-import io.realm.internal.HandlerControllerConstants;
-import io.realm.internal.IdentitySet;
-import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Row;
-import io.realm.internal.SharedRealm;
-import io.realm.internal.async.BadVersionException;
-import io.realm.internal.async.QueryUpdateTask;
-import io.realm.log.RealmLog;
-
-import static io.realm.internal.HandlerControllerConstants.LOCAL_COMMIT;
-import static io.realm.internal.HandlerControllerConstants.REALM_CHANGED;
-
-/**
- * Centralises all Handler callbacks, including updating async queries and refreshing the Realm.
- */
-final class HandlerController implements Handler.Callback {
-
-    private final static Boolean NO_REALM_QUERY = Boolean.TRUE;
-
-    // Keeps a strong reference to the registered RealmChangeListener.
-    // User should unregister those listeners.
-    final CopyOnWriteArrayList<RealmChangeListener<? extends BaseRealm>> changeListeners = new CopyOnWriteArrayList<RealmChangeListener<? extends BaseRealm>>();
-
-    // Keeps a weak reference to the registered RealmChangeListener those are Weak since
-    // for some UC (ex: RealmBaseAdapter) we don't know when it's the best time to unregister the listener.
-    final List<WeakReference<RealmChangeListener<? extends BaseRealm>>> weakChangeListeners =
-            new CopyOnWriteArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>();
-
-    final BaseRealm realm;
-    private boolean autoRefresh; // Requires a Looper thread to be true.
-
-    // Pending update of async queries.
-    private Future updateAsyncQueriesTask;
-
-    private final ReferenceQueue<RealmResults<? extends RealmModel>> referenceQueueAsyncRealmResults =
-            new ReferenceQueue<RealmResults<? extends RealmModel>>();
-    private final ReferenceQueue<RealmResults<? extends RealmModel>> referenceQueueSyncRealmResults =
-            new ReferenceQueue<RealmResults<? extends RealmModel>>();
-    final ReferenceQueue<RealmModel> referenceQueueRealmObject = new ReferenceQueue<RealmModel>();
-    // Keeps a WeakReference list to RealmResults obtained asynchronously in order to update them
-    // RealmQuery is not WeakReferenced to prevent it from being GC'd. RealmQuery should be
-    // cleaned if RealmResults is cleaned. we need to keep RealmQuery because it contains the query
-    // pointer (to handover for each update) + all the arguments necessary to rerun the query:
-    // sorting orders, soring columns, type (findAll, findFirst, findAllSorted etc.)
-    final Map<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<? extends RealmModel>> asyncRealmResults =
-            new IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<? extends RealmModel>>();
-    // Keeps a WeakReference to the currently empty RealmObjects obtained asynchronously. We need to keep re-running
-    // the query in the background for each commit, until we got a valid Row (pointer)
-    final Map<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>> emptyAsyncRealmObject =
-            new ConcurrentHashMap<WeakReference<RealmObjectProxy>, RealmQuery<? extends RealmModel>>();
-
-    // Keeps a reference to the list of sync RealmResults, we'll use it
-    // to deliver type based notification once the shared_group advance
-    final IdentitySet<WeakReference<RealmResults<? extends RealmModel>>> syncRealmResults =
-            new IdentitySet<WeakReference<RealmResults<? extends RealmModel>>>();
-
-    // Since ConcurrentHashMap doesn't support null value, and since java.util.Optional are not
-    // yet an option (using Java 6) we use an Object with the dummy value Boolean.TRUE to indicate
-    // a null value (no RealmQuery<? extends RealmModel>) this is the same approach used in the JDK
-    // ex here https://android.googlesource.com/platform/libcore/+/refs/heads/master/luni/src/main/java/java/util/concurrent/ConcurrentSkipListSet.java#214
-    final ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object> realmObjects =
-            new ConcurrentHashMap<WeakReference<RealmObjectProxy>, Object>();
-
-    // List of onSuccess callbacks from async transactions. We need to track all callbacks as notifying listeners might
-    // be delayed due to the presence of async queries. This can mean that multiple async transactions can complete
-    // before we are ready to notify all of them.
-    private final List<Runnable> pendingOnSuccessAsyncTransactionCallbacks = new ArrayList<Runnable>();
-
-    public HandlerController(BaseRealm realm) {
-        this.realm = realm;
-    }
-
-    @Override
-    public boolean handleMessage(Message message) {
-        // Due to how a ConcurrentHashMap iterator is created we cannot be sure that other threads are
-        // aware when this threads handler is removed before they send messages to it. We don't wish to synchronize
-        // access to the handlers as they are the prime mean of notifying about updates. Instead we make sure
-        // that if a message does slip though (however unlikely), it will not try to update a SharedGroup that no
-        // longer exists. `sharedRealm` will only be null if a Realm is really closed.
-        if (realm.sharedRealm != null) {
-            QueryUpdateTask.Result result;
-            switch (message.what) {
-
-                case LOCAL_COMMIT:
-                case REALM_CHANGED:
-                    realmChanged(message.what == LOCAL_COMMIT);
-                    break;
-
-                case HandlerControllerConstants.COMPLETED_ASYNC_REALM_RESULTS:
-                    result = (QueryUpdateTask.Result) message.obj;
-                    completedAsyncRealmResults(result);
-                    break;
-
-                case HandlerControllerConstants.COMPLETED_ASYNC_REALM_OBJECT:
-                    result = (QueryUpdateTask.Result) message.obj;
-                    completedAsyncRealmObject(result);
-                    break;
-
-                case HandlerControllerConstants.COMPLETED_UPDATE_ASYNC_QUERIES:
-                    // This is called once the background thread completed the update of the async queries.
-                    result = (QueryUpdateTask.Result) message.obj;
-                    completedAsyncQueriesUpdate(result);
-                    break;
-
-                case HandlerControllerConstants.REALM_ASYNC_BACKGROUND_EXCEPTION:
-                    // Doesn't fail silently in the background in case of Core exception.
-                    throw (Error) message.obj;
-
-                default:
-                    throw new IllegalArgumentException("Unknown message: " + message.what);
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Properly handles when an async transaction completes. This will be treated as a REALM_CHANGED event when
-     * determining which queries to re-run and when to notify listeners.
-     * <p>
-     * NOTE: This is needed as it is not possible to combine a `Message.what` value and a callback runnable. So instead
-     * of posting two messages, we post a runnable that runs this method. This means it is possible to interpret
-     * `REALM_CHANGED + Runnable` as one atomic message.
-     *
-     * @param onSuccess onSuccess callback to run for the async transaction that completed.
-     */
-    public void handleAsyncTransactionCompleted(Runnable onSuccess) {
-        // Same reason as handleMessage().
-        if (realm.sharedRealm != null) {
-            if (onSuccess != null) {
-                pendingOnSuccessAsyncTransactionCallbacks.add(onSuccess);
-            }
-            realmChanged(false);
-        }
-    }
-
-    void addChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
-        changeListeners.addIfAbsent(listener);
-    }
-
-    /**
-     * For internal use only.
-     * <p>
-     * Sometimes we don't know when to unregister listeners (e.g., {@code RealmBaseAdapter}). Using
-     * a WeakReference the listener doesn't need to be explicitly unregistered.
-     *
-     * @param listener the change listener.
-     */
-    void addChangeListenerAsWeakReference(RealmChangeListener<? extends BaseRealm> listener) {
-        Iterator<WeakReference<RealmChangeListener<? extends BaseRealm>>> iterator = weakChangeListeners.iterator();
-        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
-        boolean addListener = true;
-        while (iterator.hasNext()) {
-            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = iterator.next();
-            RealmChangeListener<? extends BaseRealm> weakListener = weakRef.get();
-
-            // Collects all listeners that are GC'ed.
-            if (weakListener == null) {
-                if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
-                }
-                toRemoveList.add(weakRef);
-            }
-
-            // Checks if Listener already exists.
-            if (weakListener == listener) {
-                addListener = false;
-            }
-        }
-        if (toRemoveList != null) {
-            weakChangeListeners.removeAll(toRemoveList);
-        }
-        if (addListener) {
-            weakChangeListeners.add(new WeakReference<RealmChangeListener<? extends BaseRealm>>(listener));
-        }
-    }
-
-    @SuppressWarnings("unused")
-    void removeWeakChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
-        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
-        for (int i = 0; i < weakChangeListeners.size(); i++) {
-            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = weakChangeListeners.get(i);
-            RealmChangeListener<? extends BaseRealm> weakListener = weakRef.get();
-
-            // Collects all listeners that are GC'ed or we need to remove.
-            if (weakListener == null || weakListener == listener) {
-                if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
-                }
-                toRemoveList.add(weakRef);
-            }
-        }
-
-        weakChangeListeners.removeAll(toRemoveList);
-    }
-
-    void removeChangeListener(RealmChangeListener<? extends BaseRealm> listener) {
-        changeListeners.remove(listener);
-    }
-
-    void removeAllChangeListeners() {
-        changeListeners.clear();
-    }
-
-    /**
-     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
-     */
-    private void notifyGlobalListeners() {
-        // Notifies strong reference listener.
-        Iterator<RealmChangeListener<? extends BaseRealm>> iteratorStrongListeners = changeListeners.iterator();
-        while (!realm.isClosed() && iteratorStrongListeners.hasNext()) { // Every callback could close the realm.
-            RealmChangeListener listener = iteratorStrongListeners.next();
-            listener.onChange(realm);
-        }
-        // Notifies weak reference listener (internals).
-        Iterator<WeakReference<RealmChangeListener<? extends BaseRealm>>> iteratorWeakListeners = weakChangeListeners.iterator();
-        List<WeakReference<RealmChangeListener<? extends BaseRealm>>> toRemoveList = null;
-        while (!realm.isClosed() && iteratorWeakListeners.hasNext()) {
-            WeakReference<RealmChangeListener<? extends BaseRealm>> weakRef = iteratorWeakListeners.next();
-            RealmChangeListener listener = weakRef.get();
-            if (listener == null) {
-                if (toRemoveList == null) {
-                    toRemoveList = new ArrayList<WeakReference<RealmChangeListener<? extends BaseRealm>>>(weakChangeListeners.size());
-                }
-                toRemoveList.add(weakRef);
-            } else {
-                listener.onChange(realm);
-            }
-        }
-        if (toRemoveList != null) {
-            weakChangeListeners.removeAll(toRemoveList);
-        }
-    }
-
-    private void updateAsyncEmptyRealmObject() {
-        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>>> iterator = emptyAsyncRealmObject.entrySet().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>> next = iterator.next();
-            if (next.getKey().get() != null) {
-                Realm.asyncTaskExecutor
-                        .submitQueryUpdate(QueryUpdateTask.newBuilder()
-                                .realmConfiguration(realm.getConfiguration())
-                                .addObject(next.getKey(),
-                                        next.getValue().handoverQueryPointer(),
-                                        next.getValue().getArgument())
-                                .sendToNotifier(realm.sharedRealm.realmNotifier,
-                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT)
-                                .build());
-
-            } else {
-                iterator.remove();
-            }
-        }
-    }
-
-    /**
-     * This method calls all registered listeners for Realm, RealmResults and RealmObjects, and callbacks for async
-     * transactions.
-     *
-     * PREREQUISITE: Only call this method after all objects are up to date. This means:
-     * - `advance_read` was called on the Realm.
-     * - `RealmResults.syncIfNeeded()` was called when collecting RealmResults listeners.
-     *
-     * @param realmResultsToBeNotified list of all RealmResults listeners that can be notified.
-     */
-    void notifyAllListeners(List<RealmResults<? extends RealmModel>> realmResultsToBeNotified) {
-
-        // Notifies all RealmResults (async and synchronous).
-        for (Iterator<RealmResults<? extends RealmModel>> it = realmResultsToBeNotified.iterator(); !realm.isClosed() && it.hasNext(); ) {
-            RealmResults<? extends RealmModel> realmResults = it.next();
-            realmResults.notifyChangeListeners(false);
-        }
-
-        // Notifies all loaded RealmObjects.
-        notifyRealmObjectCallbacks();
-
-        // Re-runs any async single objects that are still not loaded.
-        // TODO: Why is this here? This was not called in `completedAsyncQueriesUpdate()`. Problem?
-        if (!realm.isClosed() && threadContainsAsyncEmptyRealmObject()) {
-            updateAsyncEmptyRealmObject();
-        }
-
-        // Notifies any completed async transactions.
-        notifyAsyncTransactionCallbacks();
-
-        // Triggers global listeners last.
-        // Note that NotificationTest.callingOrdersOfListeners will fail if orders change.
-        notifyGlobalListeners();
-    }
-
-    private void collectAsyncRealmResultsCallbacks(List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
-        collectRealmResultsCallbacks(asyncRealmResults.keySet().iterator(), resultsToBeNotified);
-    }
-
-    private void collectSyncRealmResultsCallbacks(List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
-        collectRealmResultsCallbacks(syncRealmResults.keySet().iterator(), resultsToBeNotified);
-    }
-
-
-    private void collectRealmResultsCallbacks(Iterator<WeakReference<RealmResults<? extends RealmModel>>> iterator,
-                                              List<RealmResults<? extends RealmModel>> resultsToBeNotified) {
-        while (iterator.hasNext()) {
-            WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = iterator.next();
-            RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
-            if (realmResults == null) {
-                iterator.remove();
-            } else {
-                // Syncs the RealmResult so it is completely up to date.
-                // This is a prerequisite to calling the listener, so when the listener is finally triggered, all
-                // RealmResults will be up to date.
-                // Local commits can accidentially cause async RealmResults to be notified, so we only want to
-                // include those that are actually done loading.
-                if (realmResults.isLoaded()) {
-                    realmResults.syncIfNeeded();
-                    resultsToBeNotified.add(realmResults);
-                }
-            }
-        }
-    }
-
-    /**
-     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
-     */
-    private void notifyRealmObjectCallbacks() {
-        List<RealmObjectProxy> objectsToBeNotified = new ArrayList<RealmObjectProxy>();
-        Iterator<WeakReference<RealmObjectProxy>> iterator = realmObjects.keySet().iterator();
-        while (iterator.hasNext()) {
-            WeakReference<RealmObjectProxy> weakRealmObject = iterator.next();
-            RealmObjectProxy realmObject = weakRealmObject.get();
-            if (realmObject == null) {
-                iterator.remove();
-
-            } else {
-                if (realmObject.realmGet$proxyState().getRow$realm().isAttached()) {
-                    // It should be legal to modify realmObjects in the listener.
-                    objectsToBeNotified.add(realmObject);
-                } else if (realmObject.realmGet$proxyState().getRow$realm() != Row.EMPTY_ROW) {
-                    iterator.remove();
-                }
-            }
-        }
-
-        for (Iterator<RealmObjectProxy> it = objectsToBeNotified.iterator(); !realm.isClosed() && it.hasNext(); ) {
-            RealmObjectProxy realmObject = it.next();
-            realmObject.realmGet$proxyState().notifyChangeListeners$realm();
-        }
-    }
-
-    private void updateAsyncQueries() {
-        if (updateAsyncQueriesTask != null && !updateAsyncQueriesTask.isDone()) {
-            // Tries to cancel any pending update since we're submitting a new one anyway.
-            updateAsyncQueriesTask.cancel(true);
-            Realm.asyncTaskExecutor.getQueue().remove(updateAsyncQueriesTask);
-            RealmLog.trace("REALM_CHANGED realm: %s cancelling pending COMPLETED_UPDATE_ASYNC_QUERIES updates", HandlerController.this);
-        }
-        RealmLog.trace("REALM_CHANGED realm: %s updating async queries, total: %d", HandlerController.this, asyncRealmResults.size());
-        // Prepares a QueryUpdateTask to current async queries in this thread.
-        QueryUpdateTask.Builder.UpdateQueryStep updateQueryStep = QueryUpdateTask.newBuilder()
-                .realmConfiguration(realm.getConfiguration());
-        QueryUpdateTask.Builder.RealmResultsQueryStep realmResultsQueryStep = null;
-
-        // We iterate over non GC'd async RealmResults then add them to the list to be updated (in a batch).
-        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>> entry = iterator.next();
-            WeakReference<RealmResults<? extends RealmModel>> weakReference = entry.getKey();
-            RealmResults<? extends RealmModel> realmResults = weakReference.get();
-            if (realmResults == null) {
-                // GC'd instance remove from the list.
-                iterator.remove();
-
-            } else {
-                realmResultsQueryStep = updateQueryStep.add(weakReference,
-                        entry.getValue().handoverQueryPointer(),
-                        entry.getValue().getArgument());
-            }
-
-            // Note: We're passing an WeakRef of a RealmResults to another thread.
-            //       This is safe as long as we don't invoke any of the RealmResults methods.
-            //       We're just using it as a Key in an IdentityHashMap (i.e doesn't call
-            //       AbstractList's hashCode, that require accessing objects from another thread)
-            //
-            //       Watch out when you debug, as you're IDE try to evaluate RealmResults
-            //       which break the Thread confinement constraints.
-        }
-        if (realmResultsQueryStep != null) {
-            QueryUpdateTask queryUpdateTask = realmResultsQueryStep
-                    .sendToNotifier(realm.sharedRealm.realmNotifier,
-                            QueryUpdateTask.NotifyEvent.COMPLETE_UPDATE_ASYNC_QUERIES)
-                    .build();
-            updateAsyncQueriesTask = Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
-        }
-    }
-
-    private void realmChanged(boolean localCommit) {
-        RealmLog.debug("%s : %s", (localCommit ? "LOCAL_COMMIT" : "REALM_CHANGED"), HandlerController.this);
-        deleteWeakReferences();
-        boolean threadContainsAsyncQueries = threadContainsAsyncQueries();
-
-        // Mixing local transactions and async queries has unavoidable race conditions.
-        if (localCommit && threadContainsAsyncQueries) {
-            RealmLog.warn("Mixing asynchronous queries with local writes should be avoided. " +
-                    "Realm will convert any async queries to synchronous in order to remain consistent. Use " +
-                    "asynchronous writes instead. You can read more here: " +
-                    "https://realm.io/docs/java/latest/#asynchronous-transactions");
-        }
-
-        if (!localCommit && threadContainsAsyncQueries) {
-            // For changes from other threads, swallows the change and re-runs async queries first.
-            updateAsyncQueries();
-        } else {
-            // Following cases handled by this:
-            // localCommit && threadContainsAsyncQueries (This is the case the warning above is about.)
-            // localCommit && !threadContainsAsyncQueries
-            // !localCommit && !threadContainsAsyncQueries
-            realm.sharedRealm.refresh();
-
-            List<RealmResults<? extends RealmModel>> resultsToBeNotified = new ArrayList<RealmResults<? extends RealmModel>>();
-            collectAsyncRealmResultsCallbacks(resultsToBeNotified);
-            collectSyncRealmResultsCallbacks(resultsToBeNotified);
-            notifyAllListeners(resultsToBeNotified);
-        }
-    }
-
-    private void completedAsyncRealmResults(QueryUpdateTask.Result result) {
-        Set<WeakReference<RealmResults<? extends RealmModel>>> updatedTableViewsKeys = result.updatedTableViews.keySet();
-        if (updatedTableViewsKeys.size() > 0) {
-            WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = updatedTableViewsKeys.iterator().next();
-
-            RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
-            if (realmResults == null) {
-                asyncRealmResults.remove(weakRealmResults);
-                RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] realm: %s RealmResults GC'd ignore results",
-                        weakRealmResults, HandlerController.this);
-            } else {
-                SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
-                int compare = callerVersionID.compareTo(result.versionID);
-                if (compare == 0) {
-                    // If the RealmResults is empty (has not completed yet) then uses the value,
-                    // Otherwise a task (grouped update) has already updated this RealmResults.
-                    if (!realmResults.isLoaded()) {
-                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , realm: %s same versions, using results (RealmResults is not loaded)",
-                                weakRealmResults, HandlerController.this);
-                        // Swaps pointer.
-                        realmResults.swapTableViewPointer(result.updatedTableViews.get(weakRealmResults));
-                        // Notifies callbacks.
-                        realmResults.syncIfNeeded();
-                        realmResults.notifyChangeListeners(false);
-                    } else {
-                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , realm: %s ignoring result the RealmResults (is already loaded)",
-                                weakRealmResults, HandlerController.this);
-                    }
-
-                } else if (compare > 0) {
-                    // We have two use cases:
-                    // 1- This RealmResults is not empty, this means that after we started the async
-                    //    query, we received a REALM_CHANGE that triggered an update of all async queries
-                    //    including the last async submitted, so no need to use the provided TableView pointer
-                    //    (or the user forced the sync behaviour .load()).
-                    // 2- This RealmResults is still empty but this caller thread is advanced than the worker thread.
-                    //    This could happen if the current thread advanced the shared_group (via a write or refresh).
-                    //    This means that we need to rerun the query against a newer worker thread.
-
-                    if (!realmResults.isLoaded()) { // UC2
-                        // UC covered by this test: RealmAsyncQueryTests#testFindAllAsyncRetry
-                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s ] , %s caller is more advanced & RealmResults is not loaded, rerunning the query against the latest version", weakRealmResults, HandlerController.this);
-
-                        RealmQuery<?> query = asyncRealmResults.get(weakRealmResults);
-                        QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
-                                .realmConfiguration(realm.getConfiguration())
-                                .add(weakRealmResults,
-                                        query.handoverQueryPointer(),
-                                        query.getArgument())
-                                .sendToNotifier(realm.sharedRealm.realmNotifier,
-                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS)
-                                .build();
-
-                        Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
-
-                    } else {
-                        // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerIsAdvanced
-                        RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , %s caller is more advanced & RealmResults is loaded ignore the outdated result", weakRealmResults, HandlerController.this);
-                    }
-
-                } else {
-                    // The caller thread is behind the worker thread,
-                    // no need to rerun the query, since we're going to receive the update signal
-                    // & batch update all async queries including this one
-                    // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
-                    RealmLog.trace("[COMPLETED_ASYNC_REALM_RESULTS %s] , %s caller thread behind worker thread, ignore results (a batch update will update everything including this query)", weakRealmResults, HandlerController.this);
-                }
-            }
-        }
-    }
-
-    private void completedAsyncQueriesUpdate(QueryUpdateTask.Result result) {
-        SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
-        int compare = callerVersionID.compareTo(result.versionID);
-        if (compare > 0) {
-            // If the caller thread is more advanced than the worker thread, it means it did a local commit.
-            // This should also have put a REALM_CHANGED event on the Looper queue, so ignoring this result should
-            // be safe as all async queries will be rerun when processing the REALM_CHANGED event.
-            RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES %s caller is more advanced, Looper will updates queries", HandlerController.this);
-
-        } else {
-            // We're behind or on the same version as the worker thread.
-
-            // Only advances if we're behind.
-            if (compare != 0) {
-                // No need to remove old pointers from TableView, since they're
-                // imperative TV, they will not rerun if the SharedGroup advance.
-
-                // UC covered by this test: RealmAsyncQueryTests#testFindAllCallerThreadBehind
-                RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES %s caller is behind advance_read", HandlerController.this);
-                // Refreshes the Realm to the version provided by the worker thread
-                // (advanceRead to the latest version may cause a version mismatch error) preventing us
-                // from importing correctly the handover table view.
-                try {
-                    realm.sharedRealm.refresh(result.versionID);
-                } catch (BadVersionException e) {
-                    // The version comparison above should have ensured that that the Caller version is less than the
-                    // Worker version. In that case it should always be safe to advance_read.
-                    throw new IllegalStateException("Failed to advance Caller Realm to Worker Realm version", e);
-                }
-            }
-
-            // It's dangerous to notify the callback about new results before updating
-            // the pointers, because the callback may use another RealmResults not updated yet
-            // this is why we defer the notification until we're done updating all pointers.
-            ArrayList<RealmResults<? extends RealmModel>> resultsToBeNotified = new ArrayList<RealmResults<? extends RealmModel>>(result.updatedTableViews.size());
-            for (Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, Long> query : result.updatedTableViews.entrySet()) {
-                WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = query.getKey();
-                RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
-                if (realmResults == null) {
-                    // Doesn't update GC'd instance.
-                    asyncRealmResults.remove(weakRealmResults);
-
-                } else {
-                    // Updates the instance with the new pointer.
-                    realmResults.swapTableViewPointer(query.getValue());
-                    realmResults.syncIfNeeded();
-                    resultsToBeNotified.add(realmResults);
-
-                    RealmLog.trace("COMPLETED_UPDATE_ASYNC_QUERIES updating RealmResults %s", HandlerController.this, weakRealmResults);
-                }
-            }
-            collectSyncRealmResultsCallbacks(resultsToBeNotified);
-
-            // We need to notify all listeners, since the original REALM_CHANGE
-            // was delayed/swallowed in order to be able to update the async queries.
-            notifyAllListeners(resultsToBeNotified);
-
-            updateAsyncQueriesTask = null;
-        }
-    }
-
-    /**
-     * Triggers onSuccess for all completed async transaction.
-     * <p>
-     * NOTE: Should only be called from {@link #notifyAllListeners(List)}.
-     */
-    private void notifyAsyncTransactionCallbacks() {
-        if (!pendingOnSuccessAsyncTransactionCallbacks.isEmpty()) {
-            for (Runnable callback : pendingOnSuccessAsyncTransactionCallbacks) {
-                callback.run();
-            }
-            pendingOnSuccessAsyncTransactionCallbacks.clear();
-        }
-    }
-
-    @SuppressFBWarnings("RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN")
-    private void completedAsyncRealmObject(QueryUpdateTask.Result result) {
-        Set<WeakReference<RealmObjectProxy>> updatedRowKey = result.updatedRow.keySet();
-        if (updatedRowKey.size() > 0) {
-            WeakReference<RealmObjectProxy> realmObjectWeakReference = updatedRowKey.iterator().next();
-            RealmObjectProxy proxy = realmObjectWeakReference.get();
-
-            if (proxy != null) {
-                SharedRealm.VersionID callerVersionID = realm.sharedRealm.getVersionID();
-                int compare = callerVersionID.compareTo(result.versionID);
-                // We always query on the same version.
-                // Only two use cases could happen 1. We're on the same version or 2. The caller has advanced in the meanwhile.
-                if (compare == 0) { // Same version import the handover.
-                    long rowPointer = result.updatedRow.get(realmObjectWeakReference);
-                    if (rowPointer != 0 && emptyAsyncRealmObject.containsKey(realmObjectWeakReference)) {
-                        // Cleanups a previously empty async RealmObject.
-                        emptyAsyncRealmObject.remove(realmObjectWeakReference);
-                        realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
-                    }
-                    proxy.realmGet$proxyState().onCompleted$realm(rowPointer);
-                    proxy.realmGet$proxyState().notifyChangeListeners$realm();
-
-                } else if (compare > 0) {
-                    // The caller has advanced we need to
-                    // retry against the current version of the caller if it's still empty.
-                    if (RealmObject.isValid(proxy)) { // Already completed & has a valid pointer no need to re-run.
-                        if (RealmObject.isValid(proxy)) {
-                            RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s], realm: %s. " +
-                                            "RealmObject is already loaded, just notify it",
-                                    realm, HandlerController.this);
-                            proxy.realmGet$proxyState().notifyChangeListeners$realm();
-                        }
-                    } else {
-                        RealmLog.trace("[COMPLETED_ASYNC_REALM_OBJECT %s, realm: %s. " +
-                                "RealmObject is not loaded yet. Rerun the query.",
-                                proxy, HandlerController.this);
-                        Object value = realmObjects.get(realmObjectWeakReference);
-                        RealmQuery<? extends RealmModel> realmQuery;
-                        if (value == null || value == NO_REALM_QUERY) { // This is a retry of an empty RealmObject.
-                            realmQuery = emptyAsyncRealmObject.get(realmObjectWeakReference);
-
-                        } else {
-                            realmQuery = (RealmQuery<? extends RealmModel>) value;
-                        }
-
-                        QueryUpdateTask queryUpdateTask = QueryUpdateTask.newBuilder()
-                                .realmConfiguration(realm.getConfiguration())
-                                .addObject(realmObjectWeakReference,
-                                        realmQuery.handoverQueryPointer(),
-                                        realmQuery.getArgument())
-                                .sendToNotifier(realm.sharedRealm.realmNotifier,
-                                        QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT)
-                                .build();
-
-                        Realm.asyncTaskExecutor.submitQueryUpdate(queryUpdateTask);
-                    }
-                } else {
-                    // Should not happen, since the the background thread position itself against the provided version
-                    // and the caller thread can only go forward (advance_read).
-                    throw new IllegalStateException("Caller thread behind the Worker thread");
-                }
-            } // else: Element GC'd in the meanwhile.
-        }
-    }
-
-    /**
-     * Indicate the presence of {@code RealmResults} obtained asynchronously, this will prevent advancing the Realm
-     * before updating the {@code RealmResults}, otherwise we will potentially re-run the queries in this thread.
-     *
-     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmResults} {@code false}
-     * otherwise.
-     */
-    private boolean threadContainsAsyncQueries() {
-        boolean isEmpty = true;
-        Iterator<Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>>> iterator = asyncRealmResults.entrySet().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmResults<? extends RealmModel>>, RealmQuery<?>> next = iterator.next();
-            if (next.getKey().get() == null) {
-                iterator.remove();
-            } else {
-                isEmpty = false;
-            }
-        }
-
-        return !isEmpty;
-    }
-
-    /**
-     * Indicates the presence of empty {@code RealmObject} obtained asynchronously using {@link RealmQuery#findFirstAsync()}.
-     * Empty means no pointer to a valid Row. This will help caller to decide when to rerun the query.
-     *
-     * @return {@code true} if there is at least one (non GC'ed) instance of {@link RealmObject}, {@code false} otherwise.
-     */
-    boolean threadContainsAsyncEmptyRealmObject() {
-        boolean isEmpty = true;
-        Iterator<Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>>> iterator = emptyAsyncRealmObject.entrySet().iterator();
-        while (iterator.hasNext()) {
-            Map.Entry<WeakReference<RealmObjectProxy>, RealmQuery<?>> next = iterator.next();
-            if (next.getKey().get() == null) {
-                iterator.remove();
-            } else {
-                isEmpty = false;
-            }
-        }
-
-        return !isEmpty;
-    }
-
-    private void deleteWeakReferences() {
-        Reference<? extends RealmResults<? extends RealmModel>> weakReferenceResults;
-        Reference<? extends RealmModel> weakReferenceObject;
-        while ((weakReferenceResults = referenceQueueAsyncRealmResults.poll()) != null ) { // Does not wait for a reference to become available.
-            asyncRealmResults.remove(weakReferenceResults);
-        }
-        while ((weakReferenceResults = referenceQueueSyncRealmResults.poll()) != null ) {
-            syncRealmResults.remove(weakReferenceResults);
-        }
-        while ((weakReferenceObject = referenceQueueRealmObject.poll()) != null ) {
-            realmObjects.remove(weakReferenceObject);
-        }
-    }
-
-    WeakReference<RealmResults<? extends RealmModel>> addToAsyncRealmResults(RealmResults<? extends RealmModel> realmResults, RealmQuery<? extends RealmModel> realmQuery) {
-        WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = new WeakReference<RealmResults<? extends RealmModel>>(realmResults,
-                referenceQueueAsyncRealmResults);
-        asyncRealmResults.put(weakRealmResults, realmQuery);
-        return weakRealmResults;
-    }
-
-    void addToRealmResults(RealmResults<? extends RealmModel> realmResults) {
-        WeakReference<RealmResults<? extends RealmModel>> realmResultsWeakReference
-                = new WeakReference<RealmResults<? extends RealmModel>>(realmResults, referenceQueueSyncRealmResults);
-        syncRealmResults.add(realmResultsWeakReference);
-    }
-
-    // Adds to the list of RealmObject to be notified after a commit.
-    // This method will check if the object exists in the list. It won't add the same object multiple times.
-    <E extends RealmObjectProxy> void addToRealmObjects(E realmObject) {
-        for (WeakReference<RealmObjectProxy> ref : realmObjects.keySet()) {
-            if (ref.get() == realmObject) {
-                return;
-            }
-        }
-        final WeakReference<RealmObjectProxy> realmObjectWeakReference =
-                new WeakReference<RealmObjectProxy>(realmObject, referenceQueueRealmObject);
-        realmObjects.put(realmObjectWeakReference, NO_REALM_QUERY);
-    }
-
-    <E extends RealmObjectProxy> WeakReference<RealmObjectProxy> addToAsyncRealmObject(E realmObject, RealmQuery<? extends RealmModel> realmQuery) {
-        final WeakReference<RealmObjectProxy> realmObjectWeakReference = new WeakReference<RealmObjectProxy>(realmObject, referenceQueueRealmObject);
-        realmObjects.put(realmObjectWeakReference, realmQuery);
-        return realmObjectWeakReference;
-    }
-
-    void removeFromAsyncRealmObject(WeakReference<RealmObjectProxy> realmObjectWeakReference) {
-        realmObjects.remove(realmObjectWeakReference);
-    }
-
-    void addToEmptyAsyncRealmObject(WeakReference<RealmObjectProxy> realmObjectWeakReference, RealmQuery<? extends RealmModel> realmQuery) {
-        emptyAsyncRealmObject.put(realmObjectWeakReference, realmQuery);
-    }
-
-    /**
-     * Refreshes all synchronous RealmResults by calling {@code sync_if_needed} on them. This will cause any backing queries
-     * to rerun and any deleted objects will be removed from the TableView.
-     * <p>
-     * WARNING: This will _NOT_ refresh TableViews created from async queries.
-     * <p>
-     * Note this will _not_ notify any registered listeners.
-     */
-    public void refreshSynchronousTableViews() {
-        Iterator<WeakReference<RealmResults<? extends RealmModel>>> iterator = syncRealmResults.keySet().iterator();
-        while (iterator.hasNext()) {
-            WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = iterator.next();
-            RealmResults<? extends RealmModel> realmResults = weakRealmResults.get();
-            if (realmResults == null) {
-                iterator.remove();
-            } else {
-                realmResults.syncIfNeeded();
-            }
-        }
-    }
-
-    /**
-     * Toggles the auto refresh flag. Will throw an {@link IllegalStateException} if auto-refresh is not available.
-     */
-    public void setAutoRefresh(boolean autoRefresh) {
-        checkCanBeAutoRefreshed();
-        this.autoRefresh = autoRefresh;
-    }
-
-    public boolean isAutoRefreshEnabled() {
-        return autoRefresh;
-    }
-
-    /**
-     * Validates that the current thread can enable auto refresh. An {@link IllegalStateException} will be thrown if that
-     * is not the case.
-     */
-    public void checkCanBeAutoRefreshed() {
-        if (Looper.myLooper() == null) {
-            throw new IllegalStateException("Cannot set auto-refresh in a Thread without a Looper");
-        }
-        if (isIntentServiceThread()) {
-            throw new IllegalStateException("Cannot set auto-refresh in an IntentService thread.");
-        }
-    }
-
-    /**
-     * Checks if the auto-refresh feature is available on this thread. Calling {@link #setAutoRefresh(boolean)}
-     * will throw if this method return {@code false}.
-     */
-    public boolean isAutoRefreshAvailable() {
-        if (Looper.myLooper() == null || isIntentServiceThread()) {
-            return false;
-        }
-
-        return true;
-    }
-
-    private static boolean isIntentServiceThread() {
-        // Tries to determine if a thread is an IntentService thread. No public API can detect this,
-        // so use the thread name as a heuristic:
-        // https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/IntentService.java#108
-        String threadName = Thread.currentThread().getName();
-        return threadName != null && threadName.startsWith("IntentService[");
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java
new file mode 100644
index 0000000000..a162848569
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OrderedCollectionChangeSet.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * This interface describes the changes made to a collection during the last update.
+ * <p>
+ * {@link OrderedCollectionChangeSet} is passed to the {@link OrderedRealmCollectionChangeListener} which is registered
+ * by {@link RealmResults#addChangeListener(OrderedRealmCollectionChangeListener)}.
+ * <p>
+ * The change information is available in two formats: a simple array of row indices in the collection for each type of
+ * change, or an array of {@link Range}s.
+ */
+public interface OrderedCollectionChangeSet {
+    /**
+     * The deleted indices in the previous version of the collection.
+     *
+     * @return the indices array. A zero-sized array will be returned if no objects were deleted.
+     */
+    int[] getDeletions();
+
+    /**
+     * The inserted indices in the new version of the collection.
+     *
+     * @return the indices array. A zero-sized array will be returned if no objects were inserted.
+     */
+    int[] getInsertions();
+
+    /**
+     * The modified indices in the new version of the collection.
+     * <p>
+     * For {@link RealmResults}, this means that one or more of the properties of the object at the given index were
+     * modified (or an object linked to by that object was modified).
+     *
+     * @return the indices array. A zero-sized array will be returned if objects were modified.
+     */
+    int[] getChanges();
+
+    /**
+     * The deleted ranges of objects in the previous version of the collection.
+     *
+     * @return the {@link Range} array. A zero-sized array will be returned if no objects were deleted.
+     */
+    Range[] getDeletionRanges();
+
+    /**
+     * The inserted ranges of objects in the new version of the collection.
+     *
+     * @return the {@link Range} array. A zero-sized array will be returned if no objects were inserted.
+     */
+    Range[] getInsertionRanges();
+
+    /**
+     * The modified ranges of objects in the new version of the collection.
+     *
+     * @return the {@link Range} array. A zero-sized array will be returned if no objects were modified.
+     */
+    Range[] getChangeRanges();
+
+    /**
+     *
+     */
+    class Range {
+        /**
+         * The start index of this change range.
+         */
+        public final int startIndex;
+
+        /**
+         * How many elements are inside this range.
+         */
+        public final int length;
+
+        /**
+         * Creates a {@link Range} with given start index and length.
+         *
+         * @param startIndex the start index of this change range.
+         * @param length how many elements are inside this range.
+         */
+        public Range(int startIndex, int length) {
+            this.startIndex = startIndex;
+            this.length = length;
+        }
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
index 724ec56cf5..a05a132c8b 100644
--- a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollection.java
@@ -23,6 +23,79 @@
  * element in the {@code OrderedRealmCollection} has an index. Each element can thus be accessed by its
  * index, with the first index being zero. Normally, {@code OrderedRealmCollection}s allow duplicate
  * elements, as compared to Sets, where elements have to be unique.
+ *
+ * <p>
+ *
+ * There are three types of {@link OrderedRealmCollection}. {@link RealmResults} and {@link RealmList} are live
+ * collections. They are up-to-date all the time and they will never contain an invalid {@link RealmObject}.
+ * {@link OrderedRealmCollectionSnapshot} is different. An {@link OrderedRealmCollectionSnapshot} can be created from
+ * another {@link OrderedRealmCollection}. Its size and elements order stay the same as the original collection's when
+ * it was created. {@link OrderedRealmCollectionSnapshot} may contain invalid {@link RealmObject}s if the objects get
+ * deleted.
+ *
+ * <p>
+ *
+ * <div class="loops"></div>
+ * Using iterators to iterate on {@link OrderedRealmCollection} will always work. You can delete or modify the elements
+ * without impacting the iterator. See below example:
+ *
+ * <pre>
+ * {@code
+ * RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+ * int s = dogs.size(); // 10
+ * realm.beginTransaction();
+ * for (Dog dog : dogs) {
+ *     dog.deleteFromRealm();
+ *     s = dogs.size(); // This will be decreased by 1 every time after a dog is removed.
+ * }
+ * realm.commitTransaction();
+ * s = dogs.size(); // 0
+ * }
+ * </pre>
+ *
+ * An iterator created from a live collection will create a stable view when the iterator is created, allowing you to
+ * delete and modify elements while iterating without impacting the iterator. However, the {@code RealmResults} backing
+ * the iterator will still be live updated meaning that size and order of elements can change when iterating.
+ * {@link RealmList} has the same behaviour as {@link RealmResults} since they are both live collections.
+ *
+ * <p>
+ *
+ * A simple for-loop is different. See below example:
+ *
+ * <pre>
+ * {@code
+ * RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+ * realm.beginTransaction();
+ * for (int i = 0; i < dogs.size(); i++) {
+ *     dogs.get(i).deleteFromRealm();
+ * }
+ * realm.commitTransaction();
+ * s = dogs.size(); // 5
+ * }
+ * </pre>
+ *
+ * The above example only deletes half of elements in the {@link RealmResults}. This is because of {@code dogs.size()}
+ * decreased by 1 for every loop. The deletion happens in the loop will immediately impact the size of
+ * {@code RealmResults}. To solve this problem, you can create a {@link OrderedRealmCollectionSnapshot} from the
+ * {@link RealmResults} or {@link RealmList} and do simple for-loop on that instead:
+ *
+ * <pre>
+ * {@code
+ * RealmResults<Dog> dogs = realm.where(Dog.class).findAll();
+ * OrderedRealmCollectionSnapshot snapshot = dogs.createSnapshot();
+ * // dogs.size() == 10 && snapshot.size() == 10
+ * realm.beginTransaction();
+ * for (int i = 0; i < snapshot.size(); i++) {
+ *     snapshot.get(0).deleteFromRealm();
+ *     // snapshot.get(0).isValid() == false
+ * }
+ * realm.commitTransaction();
+ * // dogs.size() == 0 && snapshot.size() == 10
+ * }
+ * </pre>
+ *
+ * As you can see, after deletion, the size and elements order of snapshot stay the same as before. But the element at
+ * the position becomes invalid.
  */
 public interface OrderedRealmCollection<E extends RealmModel> extends List<E>, RealmCollection<E> {
 
@@ -137,4 +210,14 @@
      * @throws UnsupportedOperationException if the collection is unmanaged.
      */
     boolean deleteLastFromRealm();
+
+    /**
+     * Creates a snapshot from this {@link OrderedRealmCollection}.
+     *
+     * @return the snapshot of this collection.
+     * @see OrderedRealmCollectionSnapshot
+     * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
+     * @throws UnsupportedOperationException if the collection is unmanaged.
+     */
+    OrderedRealmCollectionSnapshot<E> createSnapshot();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
new file mode 100644
index 0000000000..8c51f2a570
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionChangeListener.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+/**
+ * {@link OrderedRealmCollectionChangeListener} can be registered with a {@link RealmResults} to receive a notification
+ * with a {@link OrderedCollectionChangeSet} to describe the details of what have been changed in the collection from
+ * last time.
+ * <p>
+ * Realm instances on a thread without an {@link android.os.Looper} cannot register a
+ * {@link OrderedRealmCollectionChangeListener}.
+ * <p>
+ *
+ * @see RealmResults#addChangeListener(OrderedRealmCollectionChangeListener)
+ */
+public interface OrderedRealmCollectionChangeListener<T> {
+
+    /**
+     * This will be called when the async query is finished the first time or the collection of objects has changed.
+     *
+     * @param collection the collection this listener is registered to.
+     * @param changeSet object with information about which rows in the collection were added, removed or modified.
+     * {@code null} is returned the first time an async query is completed.
+     */
+    void onChange(T collection, OrderedCollectionChangeSet changeSet);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
new file mode 100644
index 0000000000..63cbb78484
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionImpl.java
@@ -0,0 +1,560 @@
+package io.realm;
+
+import java.util.AbstractList;
+import java.util.ConcurrentModificationException;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.ListIterator;
+
+import io.realm.internal.Collection;
+import io.realm.internal.InvalidRow;
+import io.realm.internal.RealmObjectProxy;
+import io.realm.internal.SortDescriptor;
+import io.realm.internal.Table;
+import io.realm.internal.UncheckedRow;
+
+/**
+ * General implementation for {@link OrderedRealmCollection} which is based on the {@code Collection}.
+ */
+abstract class OrderedRealmCollectionImpl<E extends RealmModel>
+        extends AbstractList<E> implements OrderedRealmCollection<E> {
+    private final static String NOT_SUPPORTED_MESSAGE = "This method is not supported by 'RealmResults' or" +
+            " 'OrderedRealmCollectionSnapshot'.";
+
+    final BaseRealm realm;
+    Class<E> classSpec;   // Return type
+    String className;     // Class name used by DynamicRealmObjects
+
+    final Collection collection;
+
+    OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, Class<E> clazz) {
+        this.realm = realm;
+        this.classSpec = clazz;
+        this.collection = collection;
+    }
+
+    OrderedRealmCollectionImpl(BaseRealm realm, Collection collection, String className) {
+        this.realm = realm;
+        this.className = className;
+        this.collection = collection;
+    }
+
+    Table getTable() {
+        return collection.getTable();
+    }
+
+    Collection getCollection() {
+        return collection;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isValid() {
+        return collection.isValid();
+    }
+
+    /**
+     * A {@link RealmResults} or a {@link OrderedRealmCollectionSnapshot} is always a managed collection.
+     *
+     * @return {@code true}.
+     * @see RealmCollection#isManaged()
+     */
+    @Override
+    public boolean isManaged() {
+        return true;
+    }
+
+    /**
+     * Searches this {@link OrderedRealmCollection} for the specified object.
+     *
+     * @param object the object to search for.
+     * @return {@code true} if {@code object} is an element of this {@code OrderedRealmCollection},
+     *         {@code false} otherwise.
+     */
+    @Override
+    public boolean contains(Object object) {
+        if (isLoaded()) {
+            // Deleted objects can never be part of a RealmResults
+            if (object instanceof RealmObjectProxy) {
+                RealmObjectProxy proxy = (RealmObjectProxy) object;
+                if (proxy.realmGet$proxyState().getRow$realm() == InvalidRow.INSTANCE) {
+                    return false;
+                }
+            }
+
+            for (E e : this) {
+                if (e.equals(object)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Returns the element at the specified location in this list.
+     *
+     * @param location the index of the element to return.
+     * @return the element at the specified index.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
+     */
+    @Override
+    public E get(int location) {
+        realm.checkIfValid();
+        return realm.get(classSpec, className, collection.getUncheckedRow(location));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E first() {
+        return firstImpl(true, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E first(E defaultValue) {
+        return firstImpl(false, defaultValue);
+    }
+
+    private E firstImpl(boolean shouldThrow, E defaultValue) {
+        UncheckedRow row = collection.firstUncheckedRow();
+
+        if (row != null) {
+            return realm.get(classSpec, className, row);
+        } else {
+            if (shouldThrow) {
+                throw new IndexOutOfBoundsException("No results were found.");
+            } else {
+                return defaultValue;
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E last() {
+        return lastImpl(true, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E last(E defaultValue) {
+        return lastImpl(false, defaultValue);
+
+    }
+
+    private E lastImpl(boolean shouldThrow, E defaultValue) {
+        UncheckedRow row = collection.lastUncheckedRow();
+
+        if (row != null) {
+            return realm.get(classSpec, className, row);
+        } else {
+            if (shouldThrow) {
+                throw new IndexOutOfBoundsException("No results were found.");
+            } else {
+                return defaultValue;
+            }
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void deleteFromRealm(int location) {
+        // TODO: Implement the delete in OS level and do check there!
+        realm.checkIfValidAndInTransaction();
+        collection.delete(location);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean deleteAllFromRealm() {
+        realm.checkIfValid();
+        if (size() > 0) {
+            collection.clear();
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Returns an iterator for the results of a query. Any change to Realm while iterating will cause this iterator to
+     * throw a {@link ConcurrentModificationException} if accessed.
+     *
+     * @return an iterator on the elements of this list.
+     * @see Iterator
+     */
+    @SuppressWarnings("NullableProblems")
+    @Override
+    public Iterator<E> iterator() {
+        return new RealmCollectionIterator();
+    }
+
+    /**
+     * Returns a list iterator for the results of a query. Any change to Realm while iterating will cause the iterator
+     * to throw a {@link ConcurrentModificationException} if accessed.
+     *
+     * @return a ListIterator on the elements of this list.
+     * @see ListIterator
+     */
+    @Override
+    public ListIterator<E> listIterator() {
+        return new RealmCollectionListIterator(0);
+    }
+
+    /**
+     * Returns a list iterator on the results of a query. Any change to Realm while iterating will cause the iterator to
+     * throw a {@link ConcurrentModificationException} if accessed.
+     *
+     * @param location the index at which to start the iteration.
+     * @return a ListIterator on the elements of this list.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location > size()}.
+     * @see ListIterator
+     */
+    @SuppressWarnings("NullableProblems")
+    @Override
+    public ListIterator<E> listIterator(int location) {
+        return new RealmCollectionListIterator(location);
+    }
+
+    // Sorting
+
+    // aux. method used by sort methods
+    private long getColumnIndexForSort(String fieldName) {
+        if (fieldName == null || fieldName.isEmpty()) {
+            throw new IllegalArgumentException("Non-empty field name required.");
+        }
+        if (fieldName.contains(".")) {
+            throw new IllegalArgumentException("Aggregates on child object fields are not supported: " + fieldName);
+        }
+        long columnIndex = collection.getTable().getColumnIndex(fieldName);
+        if (columnIndex < 0) {
+            throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldName));
+        }
+        return columnIndex;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName) {
+        SortDescriptor sortDescriptor =
+                SortDescriptor.getInstanceForSort(collection.getTable(), fieldName, Sort.ASCENDING);
+
+        Collection sortedCollection = collection.sort(sortDescriptor);
+        return createLoadedResults(sortedCollection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName, Sort sortOrder) {
+        SortDescriptor sortDescriptor =
+                SortDescriptor.getInstanceForSort(collection.getTable(), fieldName, sortOrder);
+
+        Collection sortedCollection = collection.sort(sortDescriptor);
+        return createLoadedResults(sortedCollection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RealmResults<E> sort(String fieldNames[], Sort sortOrders[]) {
+        SortDescriptor sortDescriptor =
+                SortDescriptor.getInstanceForSort(collection.getTable(), fieldNames, sortOrders);
+
+        Collection sortedCollection = collection.sort(sortDescriptor);
+        return createLoadedResults(sortedCollection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
+        return sort(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
+    }
+
+    // Aggregates
+
+    /**
+     * Returns the number of elements in this query result.
+     *
+     * @return the number of elements in this query result.
+     */
+    @Override
+    public int size() {
+        if (isLoaded()) {
+            long size = collection.size();
+            return (size > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) size;
+        }
+        return 0;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Number min(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = getColumnIndexForSort(fieldName);
+        return collection.aggregateNumber(io.realm.internal.Collection.Aggregate.MINIMUM, columnIndex);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Date minDate(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = getColumnIndexForSort(fieldName);
+        return collection.aggregateDate(Collection.Aggregate.MINIMUM, columnIndex);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Number max(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = getColumnIndexForSort(fieldName);
+        return collection.aggregateNumber(Collection.Aggregate.MAXIMUM, columnIndex);
+    }
+
+    /**
+     * Finds the maximum date.
+     *
+     * @param fieldName the field to look for the maximum date. If fieldName is not of Date type, an exception is
+     *                  thrown.
+     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
+     * will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with
+     * {@code null} values are ignored.
+     * @throws IllegalArgumentException if fieldName is not a Date field.
+     */
+    @Override
+    public Date maxDate(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = getColumnIndexForSort(fieldName);
+        return collection.aggregateDate(Collection.Aggregate.MAXIMUM, columnIndex);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Number sum(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = getColumnIndexForSort(fieldName);
+        return collection.aggregateNumber(Collection.Aggregate.SUM, columnIndex);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public double average(String fieldName) {
+        realm.checkIfValid();
+        long columnIndex = getColumnIndexForSort(fieldName);
+
+        Number avg = collection.aggregateNumber(Collection.Aggregate.AVERAGE, columnIndex);
+        return avg.doubleValue();
+    }
+
+    // Deleting
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Deprecated
+    @Override
+    public E remove(int index) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Deprecated
+    @Override
+    public boolean remove(Object object) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Deprecated
+    @Override
+    public boolean removeAll(@SuppressWarnings("NullableProblems") java.util.Collection<?> collection) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Deprecated
+    @Override
+    public E set(int location, E object) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Deprecated
+    @Override
+    public boolean retainAll(@SuppressWarnings("NullableProblems") java.util.Collection<?> collection) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Removes the last object in the list. This also deletes the object from the underlying Realm.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    @Override
+    public boolean deleteLastFromRealm() {
+        // TODO: Implement the deleteLast in OS level and do check there!
+        realm.checkIfValidAndInTransaction();
+        return collection.deleteLast();
+    }
+
+    /**
+     * Removes the first object in the list. This also deletes the object from the underlying Realm.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     */
+    @Override
+    public boolean deleteFirstFromRealm() {
+        // TODO: Implement the deleteLast in OS level and do check there!
+        realm.checkIfValidAndInTransaction();
+        return collection.deleteFirst();
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Override
+    @Deprecated
+    public void clear() {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Override
+    @Deprecated
+    public boolean add(E element) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Override
+    @Deprecated
+    public void add(int index, E element) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Override
+    @Deprecated
+    public boolean addAll(int location,
+                          @SuppressWarnings("NullableProblems") java.util.Collection<? extends E> collection) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    /**
+     * Not supported by {@link RealmResults} and {@link OrderedRealmCollectionSnapshot}.
+     *
+     * @throws UnsupportedOperationException always.
+     */
+    @Deprecated
+    @Override
+    public boolean addAll(@SuppressWarnings("NullableProblems") java.util.Collection<? extends E> collection) {
+        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    }
+
+    // Custom RealmResults iterator. It ensures that we only iterate on a Realm that hasn't changed.
+    private class RealmCollectionIterator extends Collection.Iterator<E> {
+        RealmCollectionIterator() {
+            super(OrderedRealmCollectionImpl.this.collection);
+        }
+
+        @Override
+        protected E convertRowToObject(UncheckedRow row) {
+            return realm.get(classSpec, className, row);
+        }
+    }
+
+    @Override
+    public OrderedRealmCollectionSnapshot<E> createSnapshot() {
+        if (className != null) {
+            return new OrderedRealmCollectionSnapshot<E>(realm, collection, className);
+        } else {
+            return new OrderedRealmCollectionSnapshot<E>(realm, collection, classSpec);
+        }
+    }
+
+    // Custom RealmResults list iterator.
+    private class RealmCollectionListIterator extends Collection.ListIterator<E> {
+        RealmCollectionListIterator(int start) {
+            super(OrderedRealmCollectionImpl.this.collection, start);
+        }
+
+        @Override
+        protected E convertRowToObject(UncheckedRow row) {
+            return realm.get(classSpec, className, row);
+        }
+    }
+
+    RealmResults<E> createLoadedResults(Collection newCollection) {
+        RealmResults<E> results;
+        if (className != null) {
+            results = new RealmResults<E>(realm, newCollection, className);
+        } else {
+            results = new RealmResults<E>(realm, newCollection, classSpec);
+        }
+        results.load();
+        return results;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
new file mode 100644
index 0000000000..5c8067faf1
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/OrderedRealmCollectionSnapshot.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm;
+
+import io.realm.internal.Collection;
+import io.realm.internal.UncheckedRow;
+
+/**
+ * An {@link OrderedRealmCollectionSnapshot} is a special type of {@link OrderedRealmCollection}. It can be created by
+ * calling {@link OrderedRealmCollection#createSnapshot()}. Unlike {@link RealmResults} and {@link RealmList}, its
+ * size and order of elements will never be changed after creation.
+ * <p>
+ * {@link OrderedRealmCollectionSnapshot} is useful when making changes which may impact the size or order of the
+ * collection in simple loops. For example:
+ * <pre>
+ * {@code
+ * final RealmResults<Dog>  dogs = realm.where(Dog.class).findAll();
+ * final OrderedRealmCollectionSnapshot<Dog> snapshot = dogs.createSnapshot();
+ * final int dogsCount = snapshot.size(); // dogs.size() == snapshot.size() == 10
+ * realm.executeTransaction(new Realm.Transaction() {
+ *     /@Override
+ *     public void execute(Realm realm) {
+ *         for (int i = 0; i < dogsCount; i++) {
+ *         // This won't work since RealmResults is always up-to-date, its size gets decreased by 1 after every loop. An
+ *         // IndexOutOfBoundsException will be thrown after 5 loops.
+ *         // dogs.deleteFromRealm(i);
+ *         snapshot.deleteFromRealm(i); // Deletion on OrderedRealmCollectionSnapshot won't change the size of it.
+ *         }
+ *     }
+ * });
+ * }
+ * </pre>
+ */
+public class OrderedRealmCollectionSnapshot<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
+
+    private int size = -1;
+
+    OrderedRealmCollectionSnapshot(BaseRealm realm, Collection collection, Class<E> clazz) {
+        super(realm, collection.createSnapshot(), clazz);
+    }
+
+    OrderedRealmCollectionSnapshot(BaseRealm realm, Collection collection, String className) {
+        super(realm, collection.createSnapshot(), className);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int size() {
+        // Optimization for simple loops. The size of snapshot will never be changed.
+        if (size == -1) {
+            size = super.size();
+        }
+        return size;
+    }
+
+    /**
+     * Not supported by {@link OrderedRealmCollectionSnapshot}. Use 'sort()' on the original
+     * {@link OrderedRealmCollection} instead.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName) {
+        throw getUnsupportedException("sort");
+    }
+
+    /**
+     * Not supported by {@link OrderedRealmCollectionSnapshot}. Use 'sort()' on the original
+     * {@link OrderedRealmCollection} instead.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName, Sort sortOrder) {
+        throw getUnsupportedException("sort");
+    }
+
+    /**
+     * Not supported by {@link OrderedRealmCollectionSnapshot}. Use 'sort()' on the original
+     * {@link OrderedRealmCollection} instead.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Override
+    public RealmResults<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
+        throw getUnsupportedException("sort");
+    }
+
+    /**
+     * Not supported by {@link OrderedRealmCollectionSnapshot}. Use 'sort()' on the original
+     * {@link OrderedRealmCollection} instead.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Override
+    public RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders) {
+        throw getUnsupportedException("sort");
+    }
+
+    /**
+     * Not supported by {@link OrderedRealmCollectionSnapshot}. Use 'where()' on the original
+     * {@link OrderedRealmCollection} instead.
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Deprecated
+    @Override
+    public RealmQuery<E> where() {
+        throw getUnsupportedException("where");
+    }
+
+    private UnsupportedOperationException getUnsupportedException(String methodName) {
+        return new UnsupportedOperationException(
+                String.format("'%s()' is not supported by OrderedRealmCollectionSnapshot. " +
+                        "Call '%s()' on the original 'RealmCollection' instead.", methodName, methodName));
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isLoaded() {
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean load() {
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public OrderedRealmCollectionSnapshot<E> createSnapshot() {
+        realm.checkIfValid();
+        return this;
+    }
+
+    /**
+     * Deletes the object at the given index from the Realm. The object at the given index will become invalid. Just
+     * returns if the object is invalid already.
+     *
+     * @param location the array index identifying the object to be removed.
+     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
+     * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
+     */
+    @Override
+    public void deleteFromRealm(int location) {
+        realm.checkIfValidAndInTransaction();
+        UncheckedRow row = collection.getUncheckedRow(location);
+        if (row.isAttached()) {
+            collection.delete(location);
+        }
+    }
+
+    /**
+     * Deletes the first object from the Realm. The first object will become invalid.
+     *
+     * @return {@code true} if an object was deleted, {@code false} otherwise.
+     * @throws java.lang.IllegalStateException if the Realm is closed or the method is called on the wrong thread.
+     */
+    @Override
+    public boolean deleteFirstFromRealm() {
+        realm.checkIfValidAndInTransaction();
+        UncheckedRow row = collection.firstUncheckedRow();
+        return row != null && row.isAttached() && collection.deleteFirst();
+    }
+
+    /**
+     * Deletes the last object from the Realm. The last object will become invalid.
+     *
+     * @return {@code true} if an object was deleted, {@code false} otherwise.
+     * @throws java.lang.IllegalStateException if the Realm is closed or the method is called from the wrong thread.
+     */
+    @Override
+    public boolean deleteLastFromRealm() {
+        realm.checkIfValidAndInTransaction();
+        UncheckedRow row = collection.lastUncheckedRow();
+        return row != null && row.isAttached() && collection.deleteLast();
+    }
+
+    /**
+     * This deletes all objects in the collection from the underlying Realm. All objects in the collection snapshot
+     * will become invalid.
+     *
+     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     * @return {@code true} if objects was deleted, {@code false} otherwise.
+     * @throws java.lang.IllegalStateException if the Realm has been closed or called from an incorrect thread.
+     */
+    @Override
+    public boolean deleteAllFromRealm() {
+        return super.deleteAllFromRealm();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/ProxyState.java b/realm/realm-library/src/main/java/io/realm/ProxyState.java
index 188753d0c2..843fb229c4 100644
--- a/realm/realm-library/src/main/java/io/realm/ProxyState.java
+++ b/realm/realm-library/src/main/java/io/realm/ProxyState.java
@@ -18,21 +18,18 @@
 
 import java.util.List;
 import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.Future;
 
+import io.realm.internal.InvalidRow;
+import io.realm.internal.PendingRow;
 import io.realm.internal.Row;
-import io.realm.internal.Table;
-import io.realm.internal.TableQuery;
-import io.realm.log.RealmLog;
+import io.realm.internal.UncheckedRow;
 
 /**
  * This implements {@code RealmObjectProxy} interface, to eliminate copying logic between
  * {@link RealmObject} and {@link DynamicRealmObject}.
  */
-public final class ProxyState<E extends RealmModel> {
+public final class ProxyState<E extends RealmModel> implements PendingRow.FrontEnd {
     private E model;
-    private String className;
-    private Class<? extends RealmModel> clazzName;
 
     // true only while executing the constructor of the enclosing proxy object
     private boolean underConstruction = true;
@@ -43,8 +40,6 @@
     private List<String> excludeFields;
 
     private final List<RealmChangeListener<E>> listeners = new CopyOnWriteArrayList<RealmChangeListener<E>>();
-    private Future<Long> pendingQuery;
-    private boolean isCompleted = false;
     protected long currentTableVersion = -1;
 
     public ProxyState() {}
@@ -53,28 +48,6 @@ public ProxyState(E model) {
         this.model = model;
     }
 
-    public ProxyState(Class<? extends RealmModel> clazzName, E model) {
-        this.clazzName = clazzName;
-        this.model = model;
-    }
-
-    /**
-     * Sets the Future instance returned by the worker thread, we need this instance to force {@link RealmObject#load()} an async
-     * query, we use it to determine if the current RealmResults is a sync or async one.
-     *
-     * @param pendingQuery pending query.
-     */
-    public void setPendingQuery$realm(Future<Long> pendingQuery) {
-        this.pendingQuery = pendingQuery;
-        if (isLoaded()) {
-            // The query completed before RealmQuery
-            // had a chance to call setPendingQuery to register the pendingQuery (used btw
-            // to determine isLoaded behaviour).
-            onCompleted$realm();
-
-        } // Else, it will be handled by the Realm#handler.
-    }
-
     public BaseRealm getRealm$realm() {
         return realm;
     }
@@ -107,84 +80,41 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
         this.excludeFields = excludeFields;
     }
 
-    public Object getPendingQuery$realm() {
-        return pendingQuery;
-    }
-
-    public boolean isCompleted$realm() {
-        return isCompleted;
-    }
-
     /**
-     * Called to import the handover row pointer and notify listeners.
-     *
-     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
+     * Notifies all registered listeners.
      */
-    public boolean onCompleted$realm() {
-        try {
-            Long handoverResult = pendingQuery.get();// make the query blocking
-            if (handoverResult != 0) {
-                // This may fail with BadVersionException if the caller and/or the worker thread
-                // are not in sync (same shared_group version).
-                // COMPLETED_ASYNC_REALM_OBJECT will be fired by the worker thread.
-                // This should handle more complex use cases like retry, ignore etc.
-                onCompleted$realm(handoverResult);
-                notifyChangeListeners$realm();
-            } else {
-                isCompleted = true;
+    private void notifyChangeListeners() {
+        if (!listeners.isEmpty()) {
+            for (RealmChangeListener<E> listener : listeners) {
+                if (realm.sharedRealm == null || realm.sharedRealm.isClosed()) {
+                    return;
+                }
+                listener.onChange(model);
             }
-        } catch (Exception e) {
-            RealmLog.debug(e);
-            return false;
         }
-        return true;
     }
 
-    public List<RealmChangeListener<E>> getListeners$realm() {
-        return listeners;
+    public void addChangeListener(RealmChangeListener<E> listener) {
+        if (!listeners.contains(listener)) {
+            listeners.add(listener);
+        }
+        // this might be called after query returns. So it is still necessary to register.
+        if (row instanceof UncheckedRow) {
+            registerToRealmNotifier();
+        }
     }
 
-    public void onCompleted$realm(long handoverRowPointer) {
-        if (handoverRowPointer == 0) {
-            // We'll retry later to update the row pointer, but we consider
-            // the query done.
-            isCompleted = true;
-
-        } else if (!isCompleted || row == Row.EMPTY_ROW) {
-            isCompleted = true;
-            long nativeRowPointer = TableQuery.importHandoverRow(handoverRowPointer, realm.sharedRealm);
-            Table table = getTable();
-            this.row = table.getUncheckedRowByPointer(nativeRowPointer);
-        } // else: Already loaded query no need to import again the pointer.
+    public void removeChangeListener(RealmChangeListener<E> listener) {
+        listeners.remove(listener);
+        if (listeners.isEmpty() && row instanceof UncheckedRow) {
+            realm.sharedRealm.realmNotifier.removeChangeListeners(this);
+        }
     }
 
-    /**
-     * Notifies all registered listeners.
-     */
-    void notifyChangeListeners$realm() {
-        if (!listeners.isEmpty()) {
-            boolean notify = false;
-
-            Table table = row.getTable();
-            if (table == null) {
-                // Completed async queries might result in `table == null`, `isCompleted == true` and `row == Row.EMPTY_ROW`
-                // We still want to trigger change notifications for these cases.
-                // isLoaded / isValid should be considered properties on RealmObjects as well so any change to these
-                // should trigger a RealmChangeListener.
-                notify = true;
-            } else {
-                long version = table.getVersion();
-                if (currentTableVersion != version) {
-                    currentTableVersion = version;
-                    notify = true;
-                }
-            }
-
-            if (notify) {
-                for (RealmChangeListener listener : listeners) {
-                    listener.onChange(model);
-                }
-            }
+    public void removeAllChangeListeners() {
+        listeners.clear();
+        if (row instanceof UncheckedRow) {
+            realm.sharedRealm.realmNotifier.removeChangeListeners(this);
         }
     }
 
@@ -194,10 +124,6 @@ public ProxyState(Class<? extends RealmModel> clazzName, E model) {
         }
     }
 
-    public void setClassName(String className) {
-        this.className = className;
-    }
-
     public boolean isUnderConstruction() {
         return underConstruction;
     }
@@ -208,15 +134,47 @@ public void setConstructionFinished() {
         excludeFields = null;
     }
 
-    private Table getTable () {
-        if (className != null) {
-            return getRealm$realm().schema.getTable(className);
+    private void registerToRealmNotifier() {
+        if (realm.sharedRealm == null || realm.sharedRealm.isClosed()) {
+            return;
+        }
+
+        realm.sharedRealm.realmNotifier.addChangeListener(this, new RealmChangeListener<ProxyState<E>>() {
+            @Override
+            public void onChange(ProxyState<E> element) {
+                long tableVersion = -1;
+                if (row.isAttached()) {
+                    // If the Row gets detached, table version will be -1 and it is different from current value.
+                    tableVersion = row.getTable().getVersion();
+                }
+                if (currentTableVersion != tableVersion)  {
+                    currentTableVersion = tableVersion;
+                    notifyChangeListeners();
+                }
+            }
+        });
+    }
+
+    public boolean isLoaded() {
+        return !(row instanceof PendingRow);
+    }
+
+    public void load() {
+        if (row instanceof PendingRow) {
+            row = ((PendingRow) row).executeQuery();
+            if (!(row instanceof InvalidRow)) {
+                registerToRealmNotifier();
+            }
+            notifyChangeListeners();
         }
-        return getRealm$realm().schema.getTable(clazzName);
     }
 
-    private boolean isLoaded() {
-        realm.checkIfValid();
-        return getPendingQuery$realm() == null || isCompleted$realm();
+    @Override
+    public void onQueryFinished(Row row) {
+        this.row = row;
+        // getTable should return a non-null table since the row should always be valid here.
+        currentTableVersion = row.getTable().getVersion();
+        notifyChangeListeners();
+        registerToRealmNotifier();
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/Realm.java b/realm/realm-library/src/main/java/io/realm/Realm.java
index 2f483be270..0369321866 100644
--- a/realm/realm-library/src/main/java/io/realm/Realm.java
+++ b/realm/realm-library/src/main/java/io/realm/Realm.java
@@ -51,6 +51,7 @@
 import io.realm.internal.ColumnInfo;
 import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.RealmCore;
+import io.realm.internal.RealmNotifier;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.SharedRealm;
@@ -279,7 +280,7 @@ static Realm createInstance(RealmConfiguration configuration, ColumnIndices[] gl
         }
     }
 
-    static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
+    private static Realm createAndValidate(RealmConfiguration configuration, ColumnIndices[] globalCacheArray) {
         Realm realm = new Realm(configuration);
 
         final long currentVersion = realm.getVersion();
@@ -362,7 +363,7 @@ private static void initializeRealm(Realm realm) {
             throw e;
         } finally {
             if (commitChanges) {
-                realm.commitTransaction(false);
+                realm.commitTransaction();
             } else {
                 realm.cancelTransaction();
             }
@@ -421,7 +422,7 @@ private static void initializeSyncedRealm(Realm realm) {
             throw e;
         } finally {
             if (commitChanges) {
-                realm.commitTransaction(false);
+                realm.commitTransaction();
             } else {
                 realm.cancelTransaction();
             }
@@ -667,8 +668,7 @@ private static void initializeSyncedRealm(Realm realm) {
         checkIfValid();
         checkHasPrimaryKey(clazz);
         try {
-            E realmObject = configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
-            return realmObject;
+            return configuration.getSchemaMediator().createOrUpdateUsingJsonObject(clazz, this, json, true);
         } catch (JSONException e) {
             throw new RealmException("Could not map JSON", e);
         }
@@ -1267,8 +1267,7 @@ public void insertOrUpdate(RealmModel object) {
     /**
      * Adds a change listener to the Realm.
      * <p>
-     * The listeners will be executed on every loop of a Handler thread if
-     * the current thread or other threads committed changes to the Realm.
+     * The listeners will be executed when changes are committed by this or another thread.
      * <p>
      * Realm instances are per thread singletons and cached, so listeners should be
      * removed manually even if calling {@link #close()}. Otherwise there is a
@@ -1282,7 +1281,29 @@ public void insertOrUpdate(RealmModel object) {
      * @see #removeAllChangeListeners()
      */
     public void addChangeListener(RealmChangeListener<Realm> listener) {
-        super.addListener(listener);
+        addListener(listener);
+    }
+
+    /**
+     * Removes the specified change listener.
+     *
+     * @param listener the change listener to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     */
+    public void removeChangeListener(RealmChangeListener<Realm> listener) {
+        removeListener(listener);
+    }
+
+    /**
+     * Removes all user-defined change listeners.
+     *
+     * @throws IllegalStateException if you try to remove listeners from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     */
+    public void removeAllChangeListeners() {
+        removeAllListeners();
     }
 
     /**
@@ -1369,23 +1390,29 @@ public RealmAsyncTask executeTransactionAsync(final Transaction transaction, fin
      * @throws IllegalArgumentException if the {@code transaction} is {@code null}, or if the realm is opened from
      *                                  another thread.
      */
-    public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnSuccess onSuccess, final Realm.Transaction.OnError onError) {
+    public RealmAsyncTask executeTransactionAsync(final Transaction transaction,
+                                                  final Realm.Transaction.OnSuccess onSuccess,
+                                                  final Realm.Transaction.OnError onError) {
         checkIfValid();
 
         if (transaction == null) {
             throw new IllegalArgumentException("Transaction should not be null");
         }
 
-        // If the user provided a Callback then we make sure, the current Realm has a Handler
-        // we can use to deliver the result
-        if ((onSuccess != null || onError != null) && !hasValidNotifier()) {
-            throw new IllegalStateException("Your Realm is opened from a thread without a Looper" +
-                    " and you provided a callback, we need a Handler to invoke your callback");
+        // Avoid to call canDeliverNotification() in bg thread.
+        final boolean canDeliverNotification = sharedRealm.capabilities.canDeliverNotification();
+
+        // If the user provided a Callback then we have to make sure the current Realm has an events looper to deliver
+        // the results.
+        if ((onSuccess != null || onError != null)) {
+            sharedRealm.capabilities.checkCanDeliverNotification("Callback cannot be delivered on current thread.");
         }
 
         // We need to use the same configuration to open a background SharedRealm (i.e Realm)
         // to perform the transaction
         final RealmConfiguration realmConfiguration = getConfiguration();
+        // We need to deliver the callback even if the Realm is closed. So acquire a reference to the notifier here.
+        final RealmNotifier realmNotifier = sharedRealm.realmNotifier;
 
         final Future<?> pendingTransaction = asyncTaskExecutor.submitTransaction(new Runnable() {
             @Override
@@ -1394,93 +1421,76 @@ public void run() {
                     return;
                 }
 
-                boolean transactionCommitted = false;
+                final SharedRealm.VersionID[] versionID = new SharedRealm.VersionID[1];
                 final Throwable[] exception = new Throwable[1];
+
                 final Realm bgRealm = Realm.getInstance(realmConfiguration);
                 bgRealm.beginTransaction();
                 try {
                     transaction.execute(bgRealm);
 
-                    if (!Thread.currentThread().isInterrupted()) {
-                        // No need to send change notification to the work thread.
-                        bgRealm.commitTransaction(false);
-                        // The bgRealm needs to be closed before post event to caller's handler to avoid concurrency
-                        // problem. This is currently guaranteed by posting handleAsyncTransactionCompleted below.
-                        bgRealm.close();
-                        transactionCommitted = true;
+                    if (Thread.currentThread().isInterrupted()) {
+                        return;
                     }
+
+                    bgRealm.commitTransaction();
+                    // The bgRealm needs to be closed before post event to caller's handler to avoid concurrency
+                    // problem. This is currently guaranteed by posting callbacks later below.
+                    versionID[0] = bgRealm.sharedRealm.getVersionID();
                 } catch (final Throwable e) {
                     exception[0] = e;
                 } finally {
-                    if (!bgRealm.isClosed()) {
-                        if (bgRealm.isInTransaction()) {
-                            bgRealm.cancelTransaction();
-                        } else if (exception[0] != null) {
-                            RealmLog.warn("Could not cancel transaction, not currently in a transaction.");
-                        }
-                        bgRealm.close();
-                    }
+                    // SharedGroup::close() will cancel the transaction if needed.
+                    bgRealm.close();
+                }
 
-                    final Throwable backgroundException = exception[0];
-                    // Sends response as the final step to ensure the bg thread quit before others get the response!
-                    if (hasValidNotifier() && !Thread.currentThread().isInterrupted()) {
+                final Throwable backgroundException = exception[0];
+                // Cannot be interrupted anymore.
+                if (canDeliverNotification ) {
+                    if (versionID[0] != null && onSuccess != null) {
+                        realmNotifier.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (isClosed()) {
+                                    // The caller Realm is closed. Just call the onSuccess. Since the new created Realm
+                                    // cannot be behind the background one.
+                                    onSuccess.onSuccess();
+                                    return;
+                                }
 
-                        if (transactionCommitted) {
-                            // This will be treated like a special REALM_CHANGED event
-                            sharedRealm.realmNotifier.post(new Runnable() {
-                                @Override
-                                public void run() {
-                                    handlerController.handleAsyncTransactionCompleted(onSuccess != null ? new Runnable() {
+                                if (sharedRealm.getVersionID().compareTo(versionID[0]) < 0) {
+                                    sharedRealm.realmNotifier.addTransactionCallback(new Runnable() {
                                         @Override
                                         public void run() {
                                             onSuccess.onSuccess();
                                         }
-                                    } : null);
+                                    });
+                                } else {
+                                    onSuccess.onSuccess();
                                 }
-                            });
-                        }
-
-                        // Sends errors directly to the looper, so they don't get intercepted by the HandlerController.
-                        if (backgroundException != null) {
-                            if (onError != null) {
-                                sharedRealm.realmNotifier.post(new Runnable() {
-                                    @Override
-                                    public void run() {
-                                        onError.onError(backgroundException);
-                                    }
-                                });
-                            } else {
-                                sharedRealm.realmNotifier.post(new Runnable() {
-                                    @Override
-                                    public void run() {
-                                        if (backgroundException instanceof RuntimeException) {
-                                            throw (RuntimeException) backgroundException;
-                                        } else if (backgroundException instanceof Exception) {
-                                            throw new RealmException("Async transaction failed", backgroundException);
-                                        } else if (backgroundException instanceof Error) {
-                                            throw (Error) backgroundException;
-                                        }
-                                    }
-                                });
                             }
-                        }
-
-                    } else {
-                        // Throws exception in the worker thread if the caller thread terminated.
-                        if (backgroundException != null) {
-                            if (backgroundException instanceof RuntimeException) {
-                                //noinspection ThrowFromFinallyBlock
-                                throw (RuntimeException) backgroundException;
-                            } else if (backgroundException instanceof Exception) {
-                                //noinspection ThrowFromFinallyBlock
-                                throw new RealmException("Async transaction failed", backgroundException);
-                            } else if (backgroundException instanceof Error) {
-                                //noinspection ThrowFromFinallyBlock
-                                throw (Error) backgroundException;
+                        });
+                    } else if (backgroundException != null) {
+                        realmNotifier.post(new Runnable() {
+                            @Override
+                            public void run() {
+                                if (onError != null) {
+                                    onError.onError(backgroundException);
+                                } else {
+                                    throw new RealmException("Async transaction failed", backgroundException);
+                                }
                             }
-                        }
+                        });
+                    }
+                } else {
+                    if (backgroundException != null) {
+                        // FIXME: ThreadPoolExecutor will never throw the exception in the background. We need a
+                        //        redesign of the async transaction API.
+                        // Throw in the worker thread since the caller thread cannot get notifications.
+                        throw new RealmException("Async transaction failed", backgroundException);
                     }
                 }
+
             }
         });
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmCache.java b/realm/realm-library/src/main/java/io/realm/RealmCache.java
index 0fa7fbf371..de3559da42 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmCache.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmCache.java
@@ -26,10 +26,10 @@
 
 import io.realm.exceptions.RealmFileException;
 import io.realm.internal.ColumnIndices;
+import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.SharedRealm;
 import io.realm.internal.Table;
 import io.realm.log.RealmLog;
-import io.realm.internal.ObjectServerFacade;
 
 /**
  * To cache {@link Realm}, {@link DynamicRealm} instances and related resources.
@@ -137,7 +137,6 @@ private RealmCache(RealmConfiguration config) {
             // Creates a new local Realm instance
             BaseRealm realm;
 
-
             if (realmClass == Realm.class) {
                 // RealmMigrationNeededException might be thrown here.
                 realm = Realm.createInstance(configuration, cache.typedColumnIndicesArray);
@@ -172,10 +171,6 @@ private RealmCache(RealmConfiguration config) {
         @SuppressWarnings("unchecked")
         E realm = (E) refAndCount.localRealm.get();
 
-        // Notifies SyncPolicy that the Realm has been opened for the first time
-        if (refAndCount.globalCount == 1) {
-            ObjectServerFacade.getFacade(configuration.isSyncConfiguration()).realmOpened(configuration);
-        }
         return realm;
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
index 0a006b559b..cb6bddc599 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmConfiguration.java
@@ -429,7 +429,7 @@ public Builder name(String filename) {
         }
 
         /**
-         * Specifies the directory where the Realm file will be saved. The default value is {@code context.getFiles()}.
+         * Specifies the directory where the Realm file will be saved. The default value is {@code context.getFilesDir()}.
          * If the directory does not exist, it will be created.
          *
          * @param directory the directory to save the Realm file in. Directory must be writable.
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index d909155433..d3ede7d912 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -30,6 +30,7 @@
 import io.realm.internal.InvalidRow;
 import io.realm.internal.LinkView;
 import io.realm.internal.RealmObjectProxy;
+import rx.Observable;
 
 /**
  * RealmList is used to model one-to-many relationships in a {@link io.realm.RealmObject}.
@@ -55,10 +56,10 @@
     private static final String NULL_OBJECTS_NOT_ALLOWED_MESSAGE = "RealmList does not accept null values";
     public static final String REMOVE_OUTSIDE_TRANSACTION_ERROR = "Objects can only be removed from inside a write transaction";
 
-    private final boolean managedMode;
+    private final io.realm.internal.Collection collection;
     protected Class<E> clazz;
     protected String className;
-    protected LinkView view;
+    final LinkView view;
     protected BaseRealm realm;
     private List<E> unmanagedList;
 
@@ -70,7 +71,8 @@
      * Use {@link io.realm.Realm#copyToRealm(Iterable)} to properly persist its elements in Realm.
      */
     public RealmList() {
-        managedMode = false;
+        collection = null;
+        view = null;
         unmanagedList = new ArrayList<E>();
     }
 
@@ -87,7 +89,8 @@ public RealmList(E... objects) {
         if (objects == null) {
             throw new IllegalArgumentException("The objects argument cannot be null");
         }
-        managedMode = false;
+        collection = null;
+        view = null;
         unmanagedList = new ArrayList<E>(objects.length);
         Collections.addAll(unmanagedList, objects);
     }
@@ -100,14 +103,14 @@ public RealmList(E... objects) {
      * @param realm reference to Realm containing the data.
      */
     RealmList(Class<E> clazz, LinkView linkView, BaseRealm realm) {
-        this.managedMode = true;
+        this.collection = new io.realm.internal.Collection(realm.sharedRealm, linkView, null);
         this.clazz = clazz;
         this.view = linkView;
         this.realm = realm;
     }
 
     RealmList(String className, LinkView linkView, BaseRealm realm) {
-        this.managedMode = true;
+        this.collection = new io.realm.internal.Collection(realm.sharedRealm, linkView, null);
         this.view = linkView;
         this.realm = realm;
         this.className = className;
@@ -160,7 +163,7 @@ private boolean isAttached() {
     @Override
     public void add(int location, E object) {
         checkValidObject(object);
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             if (location < 0 || location > size()) {
                 throw new IndexOutOfBoundsException("Invalid index " + location + ", size is " + size());
@@ -192,7 +195,7 @@ public void add(int location, E object) {
     @Override
     public boolean add(E object) {
         checkValidObject(object);
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
             view.add(proxy.realmGet$proxyState().getRow$realm().getIndex());
@@ -225,7 +228,7 @@ public boolean add(E object) {
     public E set(int location, E object) {
         checkValidObject(object);
         E oldObject;
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             RealmObjectProxy proxy = (RealmObjectProxy) copyToRealmIfNeeded(object);
             oldObject = get(location);
@@ -244,8 +247,8 @@ private E copyToRealmIfNeeded(E object) {
 
             if (proxy instanceof DynamicRealmObject) {
                 String listClassName = RealmSchema.getSchemaForTable(view.getTargetTable());
-                String objectClassName = ((DynamicRealmObject) object).getType();
                 if (proxy.realmGet$proxyState().getRealm$realm() == realm) {
+                    String objectClassName = ((DynamicRealmObject) object).getType();
                     if (listClassName.equals(objectClassName)) {
                         // Same Realm instance and same target table
                         return object;
@@ -293,7 +296,7 @@ private E copyToRealmIfNeeded(E object) {
      * @throws java.lang.IndexOutOfBoundsException if any position is outside [0, size()].
      */
     public void move(int oldPos, int newPos) {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             view.move(oldPos, newPos);
         } else {
@@ -318,7 +321,7 @@ public void move(int oldPos, int newPos) {
      */
     @Override
     public void clear() {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             view.clear();
         } else {
@@ -338,7 +341,7 @@ public void clear() {
     @Override
     public E remove(int location) {
         E removedItem;
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             removedItem = get(location);
             view.remove(location);
@@ -368,7 +371,7 @@ public E remove(int location) {
      */
     @Override
     public boolean remove(Object object) {
-        if (managedMode && !realm.isInTransaction()) {
+        if (isManaged() && !realm.isInTransaction()) {
             throw new IllegalStateException(REMOVE_OUTSIDE_TRANSACTION_ERROR);
         }
         return super.remove(object);
@@ -392,7 +395,7 @@ public boolean remove(Object object) {
      */
     @Override
     public boolean removeAll(Collection<?> collection) {
-        if (managedMode && !realm.isInTransaction()) {
+        if (isManaged() && !realm.isInTransaction()) {
             throw new IllegalStateException(REMOVE_OUTSIDE_TRANSACTION_ERROR);
         }
         return super.removeAll(collection);
@@ -403,7 +406,7 @@ public boolean removeAll(Collection<?> collection) {
      */
     @Override
     public boolean deleteFirstFromRealm() {
-        if (managedMode) {
+        if (isManaged()) {
             if (size() > 0) {
                 deleteFromRealm(0);
                 modCount++;
@@ -421,7 +424,7 @@ public boolean deleteFirstFromRealm() {
      */
     @Override
     public boolean deleteLastFromRealm() {
-        if (managedMode) {
+        if (isManaged()) {
             if (size() > 0) {
                 deleteFromRealm(size() - 1);
                 modCount++;
@@ -444,7 +447,7 @@ public boolean deleteLastFromRealm() {
      */
     @Override
     public E get(int location) {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             long rowIndex = view.getTargetRowIndex(location);
             return realm.get(clazz, className, rowIndex);
@@ -468,7 +471,7 @@ public E first(E defaultValue) {
     }
 
     private E firstImpl(boolean shouldThrow, E defaultValue) {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             if (!view.isEmpty()) {
                 return get(0);
@@ -499,7 +502,7 @@ public E last(E defaultValue) {
     }
 
     private E lastImpl(boolean shouldThrow, E defaultValue) {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             if (!view.isEmpty()) {
                 return get((int) view.size() - 1);
@@ -528,7 +531,7 @@ private E lastImpl(boolean shouldThrow, E defaultValue) {
      */
     @Override
     public RealmResults<E> sort(String fieldName, Sort sortOrder) {
-        if (managedMode) {
+        if (isManaged()) {
             return this.where().findAllSorted(fieldName, sortOrder);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -548,7 +551,7 @@ private E lastImpl(boolean shouldThrow, E defaultValue) {
      */
     @Override
     public RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders) {
-        if (managedMode) {
+        if (isManaged()) {
             return where().findAllSorted(fieldNames, sortOrders);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -560,7 +563,7 @@ private E lastImpl(boolean shouldThrow, E defaultValue) {
      */
     @Override
     public void deleteFromRealm(int location) {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             view.removeTargetRow(location);
             modCount++;
@@ -577,7 +580,7 @@ public void deleteFromRealm(int location) {
      */
     @Override
     public int size() {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             long size = view.size();
             return size < Integer.MAX_VALUE ? (int) size : Integer.MAX_VALUE;
@@ -594,7 +597,7 @@ public int size() {
      * @see io.realm.RealmQuery
      */
     public RealmQuery<E> where() {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             return RealmQuery.createQueryFromList(this);
         } else {
@@ -607,7 +610,7 @@ public int size() {
      */
     @Override
     public Number min(String fieldName) {
-        if (managedMode) {
+        if (isManaged()) {
             return this.where().min(fieldName);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -619,7 +622,7 @@ public Number min(String fieldName) {
      */
     @Override
     public Number max(String fieldName) {
-        if (managedMode) {
+        if (isManaged()) {
             return this.where().max(fieldName);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -631,7 +634,7 @@ public Number max(String fieldName) {
      */
     @Override
     public Number sum(String fieldName) {
-        if (managedMode) {
+        if (isManaged()) {
             return this.where().sum(fieldName);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -643,7 +646,7 @@ public Number sum(String fieldName) {
      */
     @Override
     public double average(String fieldName) {
-        if (managedMode) {
+        if (isManaged()) {
             return this.where().average(fieldName);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -655,7 +658,7 @@ public double average(String fieldName) {
      */
     @Override
     public Date maxDate(String fieldName) {
-        if (managedMode) {
+        if (isManaged()) {
             return this.where().maximumDate(fieldName);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -667,7 +670,7 @@ public Date maxDate(String fieldName) {
      */
     @Override
     public Date minDate(String fieldName) {
-        if (managedMode) {
+        if (isManaged()) {
             return this.where().minimumDate(fieldName);
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
@@ -679,7 +682,7 @@ public Date minDate(String fieldName) {
      */
     @Override
     public boolean deleteAllFromRealm() {
-        if (managedMode) {
+        if (isManaged()) {
             checkValidView();
             if (size() > 0) {
                 view.removeAllTargetRows();
@@ -721,7 +724,7 @@ public boolean load() {
      */
     @Override
     public boolean contains(Object object) {
-        if (managedMode) {
+        if (isManaged()) {
             realm.checkIfValid();
 
             // Deleted objects can never be part of a RealmList
@@ -748,7 +751,7 @@ public boolean contains(Object object) {
      */
     @Override
     public Iterator<E> iterator() {
-        if (managedMode) {
+        if (isManaged()) {
             return new RealmItr();
         } else {
             return super.iterator();
@@ -768,7 +771,7 @@ public boolean contains(Object object) {
      */
     @Override
     public ListIterator<E> listIterator(int location) {
-        if (managedMode) {
+        if (isManaged()) {
             return new RealmListItr(location);
         } else {
             return super.listIterator(location);
@@ -795,16 +798,36 @@ private void checkValidView() {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public OrderedRealmCollectionSnapshot<E> createSnapshot() {
+        if (!isManaged()) {
+            throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
+        }
+        checkValidView();
+        if (className != null) {
+            return new OrderedRealmCollectionSnapshot<E>(realm,
+                    new io.realm.internal.Collection(realm.sharedRealm, view, null),
+                    className);
+        } else {
+            return new OrderedRealmCollectionSnapshot<E>(realm,
+                    new io.realm.internal.Collection(realm.sharedRealm, view, null),
+                    clazz);
+        }
+    }
+
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder();
-        sb.append(managedMode ? clazz.getSimpleName() : getClass().getSimpleName());
+        sb.append(isManaged() ? clazz.getSimpleName() : getClass().getSimpleName());
         sb.append("@[");
-        if (managedMode && !isAttached()) {
+        if (isManaged() && !isAttached()) {
             sb.append("invalid");
         } else {
             for (int i = 0; i < size(); i++) {
-                if (managedMode) {
+                if (isManaged()) {
                     sb.append(((RealmObjectProxy) get(i)).realmGet$proxyState().getRow$realm().getIndex());
                 } else {
                     sb.append(System.identityHashCode(get(i)));
@@ -818,6 +841,118 @@ public String toString() {
         return sb.toString();
     }
 
+
+    /**
+     * Returns an Rx Observable that monitors changes to this RealmList. It will emit the current RealmList when
+     * subscribed to. RealmList will continually be emitted as the RealmList is updated -
+     * {@code onComplete} will never be called.
+     *
+     * If you would like the {@code asObservable()} to stop emitting items you can instruct RxJava to
+     * only emit only the first item by using the {@code first()} operator:
+     *
+     *<pre>
+     * {@code
+     * list.asObservable()
+     *      .first()
+     *      .subscribe( ... ) // You only get the results once
+     * }
+     * </pre>
+     *
+     * <p>Note that when the {@link Realm} is accessed from threads other than where it was created,
+     * {@link IllegalStateException} will be thrown. Care should be taken when using different schedulers
+     * with {@code subscribeOn()} and {@code observeOn()}.
+     *
+     * @return RxJava Observable that only calls {@code onNext}. It will never call {@code onComplete} or {@code OnError}.
+     * @throws UnsupportedOperationException if the required RxJava framework is not on the classpath or the
+     * corresponding Realm instance doesn't support RxJava.
+     * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
+     */
+    @SuppressWarnings("unchecked")
+    public Observable<RealmList<E>> asObservable() {
+        if (realm instanceof Realm) {
+            return realm.configuration.getRxFactory().from((Realm) realm, this);
+        } else if (realm instanceof DynamicRealm) {
+            DynamicRealm dynamicRealm = (DynamicRealm) realm;
+            RealmList<DynamicRealmObject> dynamicList = (RealmList<DynamicRealmObject>) this;
+            @SuppressWarnings("UnnecessaryLocalVariable")
+            Observable results = realm.configuration.getRxFactory().from(dynamicRealm, dynamicList);
+            return results;
+        } else {
+            throw new UnsupportedOperationException(realm.getClass() + " does not support RxJava.");
+        }
+    }
+
+    private void checkForAddRemoveListener(Object listener, boolean checkListener) {
+        if (checkListener && listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
+        }
+        realm.checkIfValid();
+        realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);
+    }
+
+    /**
+     * Adds a change listener to this {@link RealmList}.
+     *
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or
+     * {@link android.app.IntentService} thread.
+     */
+    public void addChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>> listener) {
+        checkForAddRemoveListener(listener, true);
+        collection.addListener(this, listener);
+    }
+
+    /**
+     * Removes the specified change listener.
+     *
+     * @param listener the change listener to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     */
+    public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmList<E>> listener) {
+        checkForAddRemoveListener(listener, true);
+        collection.removeListener(this, listener);
+    }
+
+    /**
+     * Adds a change listener to this {@link RealmList}.
+     *
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or
+     * {@link android.app.IntentService} thread.
+     */
+    public void addChangeListener(RealmChangeListener<RealmList<E>> listener) {
+        checkForAddRemoveListener(listener, true);
+        collection.addListener(this, listener);
+    }
+
+    /**
+     * Removes the specified change listener.
+     *
+     * @param listener the change listener to be removed.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     */
+    public void removeChangeListener(RealmChangeListener<RealmList<E>> listener) {
+        checkForAddRemoveListener(listener, true);
+        collection.removeListener(this, listener);
+    }
+
+    /**
+     * Removes all user-defined change listeners.
+     *
+     * @throws IllegalStateException if you try to remove listeners from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
+     */
+    public void removeAllChangeListeners() {
+        checkForAddRemoveListener(null, false);
+        collection.removeAllListeners();
+    }
+
     // Custom RealmList iterator.
     private class RealmItr implements Iterator<E> {
         /**
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObject.java b/realm/realm-library/src/main/java/io/realm/RealmObject.java
index f9ff0a7490..7b942c51ee 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObject.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObject.java
@@ -18,8 +18,6 @@
 
 import android.app.IntentService;
 
-import java.util.List;
-
 import io.realm.annotations.RealmClass;
 import io.realm.internal.InvalidRow;
 import io.realm.internal.RealmObjectProxy;
@@ -235,10 +233,9 @@ public final boolean isLoaded() {
         if (object instanceof RealmObjectProxy) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
             proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
-            return proxy.realmGet$proxyState().getPendingQuery$realm() == null || proxy.realmGet$proxyState().isCompleted$realm();
-        } else {
-            return true;
+            return proxy.realmGet$proxyState().isLoaded();
         }
+        return true;
     }
 
     /**
@@ -309,15 +306,11 @@ public final boolean load() {
     public static <E extends RealmModel> boolean load(E object) {
         if (RealmObject.isLoaded(object)) {
             return true;
-        } else {
-            if (object instanceof RealmObjectProxy) {
-                // doesn't guarantee to import correctly the result (because the user may have advanced)
-                // in this case the Realm#handler will be responsible of retrying
-                return ((RealmObjectProxy) object).realmGet$proxyState().onCompleted$realm();
-            } else {
-                return false;
-            }
+        } else if (object instanceof RealmObjectProxy) {
+            ((RealmObjectProxy) object).realmGet$proxyState().load();
+            return true;
         }
+        return false;
     }
 
     /**
@@ -329,6 +322,7 @@ public final boolean load() {
      * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
      */
     public final <E extends RealmModel> void addChangeListener(RealmChangeListener<E> listener) {
+        //noinspection unchecked
         RealmObject.addChangeListener((E) this, listener);
     }
 
@@ -352,25 +346,14 @@ public final boolean load() {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
             BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
             realm.checkIfValid();
-            if (!realm.handlerController.isAutoRefreshEnabled()) {
-                throw new IllegalStateException("You can't register a listener from a non-Looper thread or IntentService thread.");
-            }
-            List<RealmChangeListener> listeners = proxy.realmGet$proxyState().getListeners$realm();
-            if (!listeners.contains(listener)) {
-                listeners.add(listener);
-            }
-            if (isLoaded(proxy)) {
-                // Tries to add this object to the realmObjects if it has already been loaded.
-                // For newly created async objects, it will be handled in RealmQuery.findFirstAsync &
-                // HandlerController.completedAsyncRealmObject.
-                realm.handlerController.addToRealmObjects(proxy);
-            }
+            realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);
+            //noinspection unchecked
+            proxy.realmGet$proxyState().addChangeListener(listener);
         } else {
             throw new IllegalArgumentException("Cannot add listener from this unmanaged RealmObject (created outside of Realm)");
         }
     }
 
-
     /**
      * Removes a previously registered listener.
      *
@@ -400,8 +383,11 @@ public final void removeChangeListener(RealmChangeListener listener) {
         }
         if (object instanceof RealmObjectProxy) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
-            proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
-            proxy.realmGet$proxyState().getListeners$realm().remove(listener);
+            BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
+            realm.checkIfValid();
+            realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);
+            //noinspection unchecked
+            proxy.realmGet$proxyState().removeChangeListener(listener);
         } else {
             throw new IllegalArgumentException("Cannot remove listener from this unmanaged RealmObject (created outside of Realm)");
         }
@@ -409,22 +395,46 @@ public final void removeChangeListener(RealmChangeListener listener) {
 
     /**
      * Removes all registered listeners.
+     *
+     * @deprecated Use {@link #removeAllChangeListeners()} instead.
      */
+    @Deprecated
     public final void removeChangeListeners() {
         RealmObject.removeChangeListeners(this);
     }
 
+    /**
+     * Removes all registered listeners.
+     */
+    public final void removeAllChangeListeners() {
+        RealmObject.removeAllChangeListeners(this);
+    }
+
     /**
      * Removes all registered listeners from the given RealmObject.
      *
      * @param object RealmObject to remove all listeners from.
      * @throws IllegalArgumentException if object is {@code null} or isn't managed by Realm.
+     * @deprecated Use {@link RealmObject#removeAllChangeListeners(RealmModel)} instead.
      */
+    @Deprecated
     public static <E extends RealmModel> void removeChangeListeners(E object) {
+        removeAllChangeListeners(object);
+    }
+
+    /**
+     * Removes all registered listeners from the given RealmObject.
+     *
+     * @param object RealmObject to remove all listeners from.
+     * @throws IllegalArgumentException if object is {@code null} or isn't managed by Realm.
+     */
+    public static <E extends RealmModel> void removeAllChangeListeners(E object) {
         if (object instanceof RealmObjectProxy) {
             RealmObjectProxy proxy = (RealmObjectProxy) object;
-            proxy.realmGet$proxyState().getRealm$realm().checkIfValid();
-            proxy.realmGet$proxyState().getListeners$realm().clear();
+            BaseRealm realm = proxy.realmGet$proxyState().getRealm$realm();
+            realm.checkIfValid();
+            realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);
+            proxy.realmGet$proxyState().removeAllChangeListeners();
         } else {
             throw new IllegalArgumentException("Cannot remove listeners from this unmanaged RealmObject (created outside of Realm)");
         }
@@ -463,6 +473,7 @@ public final void removeChangeListeners() {
      * @see <a href="https://realm.io/docs/java/latest/#rxjava">RxJava and Realm</a>
      */
     public final <E extends RealmObject> Observable<E> asObservable() {
+        //noinspection unchecked
         return (Observable<E>) RealmObject.asObservable(this);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
index 9e2322d723..f52e59c2db 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmObjectSchema.java
@@ -26,7 +26,6 @@
 
 import io.realm.annotations.Required;
 import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
 
 /**
  * Class for interacting with the schema for a given RealmObject class. This makes it possible to
@@ -334,7 +333,7 @@ public RealmObjectSchema renameField(String currentFieldName, String newFieldNam
      * @return {@code true} if the field exists, {@code false} otherwise.
      */
     public boolean hasField(String fieldName) {
-        return table.getColumnIndex(fieldName) != TableOrView.NO_MATCH;
+        return table.getColumnIndex(fieldName) != Table.NO_MATCH;
     }
 
     /**
@@ -636,13 +635,13 @@ private void checkLegalName(String fieldName) {
     }
 
     private void checkFieldNameIsAvailable(String fieldName) {
-        if (table.getColumnIndex(fieldName) != TableOrView.NO_MATCH) {
+        if (table.getColumnIndex(fieldName) != Table.NO_MATCH) {
             throw new IllegalArgumentException("Field already exists in '" + getClassName() + "': " + fieldName);
         }
     }
 
     private void checkFieldExists(String fieldName) {
-        if (table.getColumnIndex(fieldName) == TableOrView.NO_MATCH) {
+        if (table.getColumnIndex(fieldName) == Table.NO_MATCH) {
             throw new IllegalArgumentException("Field name doesn't exist on object '" + getClassName() + "': " + fieldName);
         }
     }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 29e6f09d4b..04de504455 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -17,29 +17,18 @@
 package io.realm;
 
 
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Future;
 
 import io.realm.annotations.Required;
+import io.realm.internal.Collection;
 import io.realm.internal.LinkView;
-import io.realm.internal.RealmNotifier;
+import io.realm.internal.PendingRow;
 import io.realm.internal.RealmObjectProxy;
 import io.realm.internal.Row;
-import io.realm.internal.SharedRealm;
+import io.realm.internal.SortDescriptor;
 import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
 import io.realm.internal.TableQuery;
-import io.realm.internal.TableView;
-import io.realm.internal.async.ArgumentsHolder;
-import io.realm.internal.async.BadVersionException;
-import io.realm.internal.async.QueryUpdateTask;
-import io.realm.log.RealmLog;
 
 /**
  * A RealmQuery encapsulates a query on a {@link io.realm.Realm} or a {@link io.realm.RealmResults} using the Builder
@@ -64,16 +53,13 @@
     private BaseRealm realm;
     private Class<E> clazz;
     private String className;
-    private TableOrView table;
+    private Table table;
     private RealmObjectSchema schema;
     private LinkView linkView;
     private TableQuery query;
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
-
-
-    private final static Long INVALID_NATIVE_POINTER = 0L;
-    private ArgumentsHolder argumentsHolder;
+    static final String ASYNC_QUERY_WRONG_THREAD_MESSAGE = "Async query cannot be created on current thread.";
 
     /**
      * Creates a query for objects of a given class from a {@link Realm}.
@@ -145,9 +131,9 @@ private RealmQuery(RealmResults<E> queryResults, Class<E> clazz) {
         this.realm = queryResults.realm;
         this.clazz = clazz;
         this.schema = realm.schema.getSchemaForClass(clazz);
-        this.table = queryResults.getTableOrView();
+        this.table = queryResults.getTable();
         this.linkView = null;
-        this.query = this.table.where();
+        this.query = queryResults.getCollection().where();
     }
 
     private RealmQuery(BaseRealm realm, LinkView linkView, Class<E> clazz) {
@@ -172,7 +158,7 @@ private RealmQuery(RealmResults<DynamicRealmObject> queryResults, String classNa
         this.className = className;
         this.schema = realm.schema.getSchemaForClass(className);
         this.table = schema.table;
-        this.query = queryResults.getTableOrView().where();
+        this.query = queryResults.getCollection().where();
     }
 
     private RealmQuery(BaseRealm realm, LinkView linkView, String className) {
@@ -191,7 +177,7 @@ private RealmQuery(BaseRealm realm, LinkView linkView, String className) {
      * @return {@code true} if still valid to use, {@code false} otherwise.
      */
     public boolean isValid() {
-        if (realm == null || realm.isClosed()) {
+        if (realm == null || realm.isClosed() /* this includes thread checking */) {
             return false;
         }
 
@@ -214,6 +200,8 @@ public boolean isValid() {
      * @see Required for further infomation.
      */
     public RealmQuery<E> isNull(String fieldName) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
@@ -230,6 +218,8 @@ public boolean isValid() {
      * @see Required for further infomation.
      */
     public RealmQuery<E> isNotNull(String fieldName) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName);
 
         // Checks that fieldName has the correct type is done in C++.
@@ -237,8 +227,6 @@ public boolean isValid() {
         return this;
     }
 
-    // Equal
-
     /**
      * Equal-to comparison.
      *
@@ -261,6 +249,12 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, String value, Case casing) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value, casing);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, String value, Case casing) {
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.equalTo(columnIndices, value, casing);
         return this;
@@ -275,6 +269,12 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, Byte value) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Byte value) {
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
             this.query.isNull(columnIndices);
@@ -293,6 +293,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, byte[] value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
         if (value == null) {
             this.query.isNull(columnIndices);
@@ -311,6 +313,12 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, Short value) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Short value) {
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
             this.query.isNull(columnIndices);
@@ -329,6 +337,12 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, Integer value) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Integer value) {
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
             this.query.isNull(columnIndices);
@@ -347,6 +361,12 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, Long value) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Long value) {
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
             this.query.isNull(columnIndices);
@@ -355,6 +375,7 @@ public boolean isValid() {
         }
         return this;
     }
+
     /**
      * Equal-to comparison.
      *
@@ -364,6 +385,12 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, Double value) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Double value) {
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         if (value == null) {
             this.query.isNull(columnIndices);
@@ -382,6 +409,12 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, Float value) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Float value) {
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         if (value == null) {
             this.query.isNull(columnIndices);
@@ -400,6 +433,12 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, Boolean value) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Boolean value) {
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
         if (value == null) {
             this.query.isNull(columnIndices);
@@ -418,13 +457,17 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> equalTo(String fieldName, Date value) {
+        realm.checkIfValid();
+
+        return equalToWithoutThreadValidation(fieldName, value);
+    }
+
+    private RealmQuery<E> equalToWithoutThreadValidation(String fieldName, Date value) {
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.equalTo(columnIndices, value);
         return this;
     }
 
-    // In
-
     /**
      * In comparison. This allows you to test if objects match any value in an array of values.
      *
@@ -449,14 +492,16 @@ public boolean isValid() {
      * empty.
      */
     public RealmQuery<E> in(String fieldName, String[] values, Case casing) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0], casing);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0], casing);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i], casing);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i], casing);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
     /**
@@ -469,14 +514,16 @@ public boolean isValid() {
      * empty.
      */
     public RealmQuery<E> in(String fieldName, Byte[] values) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0]);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i]);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
     /**
@@ -489,14 +536,16 @@ public boolean isValid() {
      * empty.
      */
     public RealmQuery<E> in(String fieldName, Short[] values) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0]);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i]);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
     /**
@@ -509,14 +558,16 @@ public boolean isValid() {
      * or empty.
      */
     public RealmQuery<E> in(String fieldName, Integer[] values) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0]);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i]);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
     /**
@@ -529,14 +580,16 @@ public boolean isValid() {
      * empty.
      */
     public RealmQuery<E> in(String fieldName, Long[] values) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0]);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i]);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
     /**
@@ -549,14 +602,16 @@ public boolean isValid() {
      * empty.
      */
     public RealmQuery<E> in(String fieldName, Double[] values) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0]);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i]);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
     /**
@@ -569,14 +624,16 @@ public boolean isValid() {
      * empty.
      */
     public RealmQuery<E> in(String fieldName, Float[] values) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0]);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i]);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
     /**
@@ -589,14 +646,16 @@ public boolean isValid() {
      * or empty.
      */
     public RealmQuery<E> in(String fieldName, Boolean[] values) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0]);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i]);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
     /**
@@ -609,18 +668,18 @@ public boolean isValid() {
      * empty.
      */
     public RealmQuery<E> in(String fieldName, Date[] values) {
+        realm.checkIfValid();
+
         if (values == null || values.length == 0) {
             throw new IllegalArgumentException(EMPTY_VALUES);
         }
-        beginGroup().equalTo(fieldName, values[0]);
+        beginGroupWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[0]);
         for (int i = 1; i < values.length; i++) {
-            or().equalTo(fieldName, values[i]);
+            orWithoutThreadValidation().equalToWithoutThreadValidation(fieldName, values[i]);
         }
-        return endGroup();
+        return endGroupWithoutThreadValidation();
     }
 
-    // Not Equal
-
     /**
      * Not-equal-to comparison.
      *
@@ -643,6 +702,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, String value, Case casing) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         if (columnIndices.length > 1 && !casing.getValue()) {
             throw new IllegalArgumentException("Link queries cannot be case insensitive - coming soon.");
@@ -660,6 +721,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, Byte value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -678,6 +741,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, byte[] value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BINARY);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -696,6 +761,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, Short value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -714,6 +781,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, Integer value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -732,6 +801,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, Long value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -750,6 +821,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, Double value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -768,6 +841,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, Float value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -786,6 +861,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, Boolean value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.BOOLEAN);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -804,6 +881,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> notEqualTo(String fieldName, Date value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         if (value == null) {
             this.query.isNotNull(columnIndices);
@@ -813,8 +892,6 @@ public boolean isValid() {
         return this;
     }
 
-    // Greater Than
-
     /**
      * Greater-than comparison.
      *
@@ -824,6 +901,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThan(String fieldName, int value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.greaterThan(columnIndices, value);
         return this;
@@ -838,6 +917,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThan(String fieldName, long value) {
+        realm.checkIfValid();
+
         long[] columnIndices = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.greaterThan(columnIndices, value);
         return this;
@@ -852,6 +933,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThan(String fieldName, double value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.greaterThan(columnIndices, value);
         return this;
@@ -866,6 +949,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThan(String fieldName, float value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.greaterThan(columnIndices, value);
         return this;
@@ -880,6 +965,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThan(String fieldName, Date value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.greaterThan(columnIndices, value);
         return this;
@@ -894,6 +981,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, int value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
@@ -908,6 +997,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, long value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
@@ -922,6 +1013,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, double value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
@@ -936,6 +1029,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, float value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
@@ -950,13 +1045,13 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> greaterThanOrEqualTo(String fieldName, Date value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.greaterThanOrEqual(columnIndices, value);
         return this;
     }
 
-    // Less Than
-
     /**
      * Less-than comparison.
      *
@@ -966,6 +1061,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThan(String fieldName, int value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThan(columnIndices, value);
         return this;
@@ -980,6 +1077,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThan(String fieldName, long value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThan(columnIndices, value);
         return this;
@@ -994,6 +1093,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThan(String fieldName, double value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.lessThan(columnIndices, value);
         return this;
@@ -1008,6 +1109,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThan(String fieldName, float value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.lessThan(columnIndices, value);
         return this;
@@ -1022,6 +1125,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThan(String fieldName, Date value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.lessThan(columnIndices, value);
         return this;
@@ -1036,6 +1141,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, int value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
@@ -1050,6 +1157,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, long value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
@@ -1064,6 +1173,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, double value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
@@ -1078,6 +1189,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, float value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
@@ -1092,13 +1205,13 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> lessThanOrEqualTo(String fieldName, Date value) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.lessThanOrEqual(columnIndices, value);
         return this;
     }
 
-    // Between
-
     /**
      * Between condition.
      *
@@ -1109,6 +1222,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> between(String fieldName, int from, int to) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.between(columnIndices, from, to);
         return this;
@@ -1124,6 +1239,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> between(String fieldName, long from, long to) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.INTEGER);
         this.query.between(columnIndices, from, to);
         return this;
@@ -1139,6 +1256,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> between(String fieldName, double from, double to) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DOUBLE);
         this.query.between(columnIndices, from, to);
         return this;
@@ -1154,6 +1273,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> between(String fieldName, float from, float to) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.FLOAT);
         this.query.between(columnIndices, from, to);
         return this;
@@ -1169,14 +1290,14 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> between(String fieldName, Date from, Date to) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.DATE);
         this.query.between(columnIndices, from, to);
         return this;
     }
 
 
-    // Contains
-
     /**
      * Condition that value of field contains the specified substring.
      *
@@ -1199,6 +1320,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> contains(String fieldName, String value, Case casing) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.contains(columnIndices, value, casing);
         return this;
@@ -1226,6 +1349,8 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> beginsWith(String fieldName, String value, Case casing) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.beginsWith(columnIndices, value, casing);
         return this;
@@ -1253,13 +1378,13 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> endsWith(String fieldName, String value, Case casing) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.endsWith(columnIndices, value, casing);
         return this;
     }
 
-    // Like
-
     /**
      * Condition that the value of field matches with the specified substring, with wildcards:
      * <ul>
@@ -1290,14 +1415,14 @@ public boolean isValid() {
      * @throws java.lang.IllegalArgumentException if one or more arguments do not match class or field type.
      */
     public RealmQuery<E> like(String fieldName, String value, Case casing) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING);
         this.query.like(columnIndices, value, casing);
         return this;
     }
 
 
-    // Grouping
-
     /**
      * Begin grouping of conditions ("left parenthesis"). A group must be closed with a call to {@code endGroup()}.
      *
@@ -1305,6 +1430,12 @@ public boolean isValid() {
      * @see #endGroup()
      */
     public RealmQuery<E> beginGroup() {
+        realm.checkIfValid();
+
+        return beginGroupWithoutThreadValidation();
+    }
+
+    private RealmQuery<E> beginGroupWithoutThreadValidation() {
         this.query.group();
         return this;
     }
@@ -1316,6 +1447,12 @@ public boolean isValid() {
      * @see #beginGroup()
      */
     public RealmQuery<E> endGroup() {
+        realm.checkIfValid();
+
+        return endGroupWithoutThreadValidation();
+    }
+
+    private RealmQuery<E> endGroupWithoutThreadValidation() {
         this.query.endGroup();
         return this;
     }
@@ -1326,6 +1463,12 @@ public boolean isValid() {
      * @return the query object.
      */
     public RealmQuery<E> or() {
+        realm.checkIfValid();
+
+        return orWithoutThreadValidation();
+    }
+
+    private RealmQuery<E> orWithoutThreadValidation() {
         this.query.or();
         return this;
     }
@@ -1336,6 +1479,8 @@ public boolean isValid() {
      * @return the query object.
      */
     public RealmQuery<E> not() {
+        realm.checkIfValid();
+
         this.query.not();
         return this;
     }
@@ -1349,6 +1494,8 @@ public boolean isValid() {
      * String or byte array.
      */
     public RealmQuery<E> isEmpty(String fieldName) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
         this.query.isEmpty(columnIndices);
         return this;
@@ -1363,6 +1510,8 @@ public boolean isValid() {
      * String or byte array.
      */
     public RealmQuery<E> isNotEmpty(String fieldName) {
+        realm.checkIfValid();
+
         long columnIndices[] = schema.getColumnIndices(fieldName, RealmFieldType.STRING, RealmFieldType.BINARY, RealmFieldType.LIST);
         this.query.isNotEmpty(columnIndices);
         return this;
@@ -1379,19 +1528,10 @@ public boolean isValid() {
      * is not indexed, or points to linked fields.
      */
     public RealmResults<E> distinct(String fieldName) {
-        checkQueryIsNotReused();
-        long columnIndex = getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
-        TableView tableView = this.query.findAll();
-        tableView.distinct(columnIndex);
+        realm.checkIfValid();
 
-        RealmResults<E> realmResults;
-        if (isDynamicQuery()) {
-            //noinspection unchecked
-            realmResults = (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, tableView, className);
-        } else {
-            realmResults = RealmResults.createFromTableOrView(realm, tableView, clazz);
-        }
-        return realmResults;
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(query.getTable(), fieldName);
+        return createRealmResults(query, null, distinctDescriptor, true);
     }
 
     /**
@@ -1407,95 +1547,11 @@ public boolean isValid() {
      * is not indexed, or points to linked fields.
      */
     public RealmResults<E> distinctAsync(String fieldName) {
-        checkQueryIsNotReused();
-        final long columnIndex = getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
-        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
-
-        // Handovers the query (to be used by a worker thread).
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
-
-        // Saves query arguments (for future update).
-        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_DISTINCT);
-        argumentsHolder.columnIndex = columnIndex;
-
-        // We need to use the same configuration to open a background SharedRealm (i.e Realm)
-        // to perform the query.
-        final RealmConfiguration realmConfiguration = realm.getConfiguration();
-
-        // Prepares an empty reference of the RealmResults, so we can return it immediately (promise)
-        // then update it once the query completes in the background.
-        RealmResults<E> realmResults;
-        if (isDynamicQuery()) {
-            //noinspection unchecked
-            realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
-        } else {
-            realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
-        }
+        realm.checkIfValid();
 
-        final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
-
-        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
-            @Override
-            public Long call() throws Exception {
-                if (!Thread.currentThread().isInterrupted()) {
-                    SharedRealm sharedRealm = null;
-
-                    try {
-                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
-
-                        long handoverTableViewPointer = TableQuery.
-                                findDistinctWithHandover(sharedRealm,
-                                        handoverQueryPointer,
-                                        columnIndex);
-
-                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
-                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedRealm.getVersionID();
-                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
-
-                        return handoverTableViewPointer;
-                    } catch (Throwable e) {
-                        RealmLog.error(e);
-                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
-                    } finally {
-                        if (sharedRealm != null && !sharedRealm.isClosed()) {
-                            sharedRealm.close();
-                        }
-                    }
-                } else {
-                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
-                }
-
-                return INVALID_NATIVE_POINTER;
-            }
-        });
-
-        realmResults.setPendingQuery(pendingQuery);
-        return realmResults;
-    }
-
-    // Finds and validates the column index for the field name used to create a distinctive TableView.
-    static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
-        // Checks empty field name.
-        if (fieldName == null || fieldName.isEmpty()) {
-            throw new IllegalArgumentException("Non-empty field name must be provided.");
-        }
-        long columnIndex = table.getColumnIndex(fieldName);
-        // Checks if field exists.
-        if (columnIndex == -1) {
-            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-        }
-        // Checks linked fields.
-        if (fieldName.contains(".")) {
-            throw new IllegalArgumentException("Distinct operation on linked properties is not supported: " + fieldName);
-        }
-        // Checks if the field is indexed.
-        if (!table.hasSearchIndex(columnIndex)) {
-            throw new IllegalArgumentException(String.format("Field name '%s' must be indexed in order to use it for distinct queries.", fieldName));
-        }
-        return columnIndex;
+        realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(query.getTable(), fieldName);
+        return createRealmResults(query, null, distinctDescriptor, false);
     }
 
     /**
@@ -1511,40 +1567,15 @@ static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
      * is an unsupported type, or points to a linked field.
      */
     public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
-        checkQueryIsNotReused();
-        List<Long> columnIndexes = getValidatedColumIndexes(this.table.getTable(), firstFieldName, remainingFieldNames);
-        TableView tableView = this.query.findAll();
-        tableView.distinct(columnIndexes);
-
-        RealmResults<E> realmResults;
-        if (isDynamicQuery()) {
-            //noinspection unchecked
-            realmResults = (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, tableView, className);
-        } else {
-            realmResults = RealmResults.createFromTableOrView(realm, tableView, clazz);
-        }
-        return realmResults;
-    }
-
-    // Finds and validates the column indices of fields for building a distinctive TableView with multi-args.
-    static List<Long> getValidatedColumIndexes(Table table, String firstFieldName, String... remainingFieldNames) {
-        List<Long> columnIndexes = new ArrayList<Long>();
-        // Finds the first index.
-        long firstIndex = getAndValidateDistinctColumnIndex(firstFieldName, table);
-        columnIndexes.add(firstIndex);
-        // Adds remaining of indexes.
-        if (remainingFieldNames != null && 0 < remainingFieldNames.length) {
-            for (String field : remainingFieldNames) {
-                long index = getAndValidateDistinctColumnIndex(field, table);
-                columnIndexes.add(index);
-            }
-        }
-        return columnIndexes;
-    }
+        realm.checkIfValid();
 
-    // Aggregates
+        String[] fieldNames = new String[1 + remainingFieldNames.length];
 
-    // Sum
+        fieldNames[0] = firstFieldName;
+        System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(table.getTable(), fieldNames);
+        return createRealmResults(query, null, distinctDescriptor, true);
+    }
 
     /**
      * Calculates the sum of a given field.
@@ -1556,6 +1587,8 @@ static long getAndValidateDistinctColumnIndex(String fieldName, Table table) {
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      */
     public Number sum(String fieldName) {
+        realm.checkIfValid();
+
         long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
@@ -1569,8 +1602,6 @@ public Number sum(String fieldName) {
         }
     }
 
-    // Average
-
     /**
      * Returns the average of a given field.
      *
@@ -1581,6 +1612,8 @@ public Number sum(String fieldName) {
      * @throws java.lang.IllegalArgumentException if the field is not a number type.
      */
     public double average(String fieldName) {
+        realm.checkIfValid();
+
         long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
@@ -1594,8 +1627,6 @@ public double average(String fieldName) {
         }
     }
 
-    // Min
-
     /**
      * Finds the minimum value of a field.
      *
@@ -1607,6 +1638,7 @@ public double average(String fieldName) {
      */
     public Number min(String fieldName) {
         realm.checkIfValid();
+
         long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
@@ -1630,12 +1662,12 @@ public Number min(String fieldName) {
      * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
      */
     public Date minimumDate(String fieldName) {
+        realm.checkIfValid();
+
         long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         return this.query.minimumDate(columnIndex);
     }
 
-    // Max
-
     /**
      * Finds the maximum value of a field.
      *
@@ -1647,6 +1679,7 @@ public Date minimumDate(String fieldName) {
      */
     public Number max(String fieldName) {
         realm.checkIfValid();
+
         long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         switch (table.getColumnType(columnIndex)) {
             case INTEGER:
@@ -1670,6 +1703,8 @@ public Number max(String fieldName) {
      * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
      */
     public Date maximumDate(String fieldName) {
+        realm.checkIfValid();
+
         long columnIndex = schema.getAndCheckFieldIndex(fieldName);
         return this.query.maximumDate(columnIndex);
     }
@@ -1681,6 +1716,8 @@ public Date maximumDate(String fieldName) {
      * @throws java.lang.UnsupportedOperationException if the query is not valid ("syntax error").
      */
     public long count() {
+        realm.checkIfValid();
+
         return this.query.count();
     }
 
@@ -1693,14 +1730,9 @@ public long count() {
      */
     @SuppressWarnings("unchecked")
     public RealmResults<E> findAll() {
-        checkQueryIsNotReused();
-        RealmResults<E> realmResults;
-        if (isDynamicQuery()) {
-            realmResults =  (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, query.findAll(), className);
-        } else {
-            realmResults = RealmResults.createFromTableOrView(realm, query.findAll(), clazz);
-        }
-        return realmResults;
+        realm.checkIfValid();
+
+        return createRealmResults(query, null, null, true);
     }
 
     /**
@@ -1712,78 +1744,10 @@ public long count() {
      * @see io.realm.RealmResults
      */
     public RealmResults<E> findAllAsync() {
-        checkQueryIsNotReused();
-        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
-
-        // Handovers the query (to be used by a worker thread).
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
-
-        // Saves query arguments (for future update).
-        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL);
-
-        // We need to use the same configuration to open a background SharedRealm (i.e Realm)
-        // to perform the query.
-        final RealmConfiguration realmConfiguration = realm.getConfiguration();
-
-        // Prepares an empty reference of the RealmResults, so we can return it immediately (promise)
-        // then update it once the query completes in the background.
-        RealmResults<E> realmResults;
-        if (isDynamicQuery()) {
-            //noinspection unchecked
-            realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
-        } else {
-            realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
-        }
-
-        final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
-
-        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
-            @Override
-            public Long call() throws Exception {
-                if (!Thread.currentThread().isInterrupted()) {
-                    SharedRealm sharedRealm = null;
-
-                    try {
-                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
-
-                        // Runs the query & handover the table view for the caller thread.
-                        // Note: the handoverQueryPointer contains the versionID needed by the SG in order
-                        // to import it.
-                        long handoverTableViewPointer = TableQuery.findAllWithHandover(sharedRealm,
-                                handoverQueryPointer);
-
-                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
-                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedRealm.getVersionID();
-                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
-
-                        return handoverTableViewPointer;
-
-                    } catch (BadVersionException e) {
-                        // In some rare race conditions, this can happen. In that case, just ignore the error.
-                        RealmLog.debug("findAllAsync handover could not complete due to a BadVersionException. " +
-                                "Retry is scheduled by a REALM_CHANGED event.");
-
-                    } catch (Throwable e) {
-                        RealmLog.error(e);
-                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
-                    } finally {
-                        if (sharedRealm != null && !sharedRealm.isClosed()) {
-                            sharedRealm.close();
-                        }
-                    }
-                } else {
-                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
-                }
-
-                return INVALID_NATIVE_POINTER;
-            }
-        });
+        realm.checkIfValid();
 
-        realmResults.setPendingQuery(pendingQuery);
-        return realmResults;
+        realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
+        return createRealmResults(query, null, null, false);
     }
 
     /**
@@ -1801,23 +1765,15 @@ public Long call() throws Exception {
      */
     @SuppressWarnings("unchecked")
     public RealmResults<E> findAllSorted(String fieldName, Sort sortOrder) {
-        checkQueryIsNotReused();
-        TableView tableView = query.findAll();
-        long columnIndex = getColumnIndexForSort(fieldName);
-        tableView.sort(columnIndex, sortOrder);
+        realm.checkIfValid();
 
-        RealmResults<E> realmResults;
-        if (isDynamicQuery()) {
-            realmResults = (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, tableView, className);
-        } else {
-            realmResults = RealmResults.createFromTableOrView(realm, tableView, clazz);
-        }
-        return realmResults;
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldName, sortOrder);
+        return createRealmResults(query, sortDescriptor, null, true);
     }
 
     /**
      * Similar to {@link #findAllSorted(String, Sort)} but runs asynchronously on a worker thread
-     * (Need a Realm opened from a looper thread to work).
+     * (need a Realm opened from a looper thread to work).
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
      *         {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the query completes.
@@ -1825,79 +1781,11 @@ public Long call() throws Exception {
      * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSortedAsync(final String fieldName, final Sort sortOrder) {
-        checkQueryIsNotReused();
-        long columnIndex = getColumnIndexForSort(fieldName);
-
-        // Captures the query arguments for future retries & updates.
-        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_SORTED);
-        argumentsHolder.sortOrder = sortOrder;
-        argumentsHolder.columnIndex = columnIndex;
-
-        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
-
-        // Handovers the query (to be used by a worker thread).
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
-
-        // We need to use the same configuration to open a background SharedRealm to perform the query.
-        final RealmConfiguration realmConfiguration = realm.getConfiguration();
-
-        RealmResults<E> realmResults;
-        if (isDynamicQuery()) {
-            //noinspection unchecked
-            realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
-        } else {
-            realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
-        }
-
-        final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults =
-                realm.handlerController.addToAsyncRealmResults(realmResults, this);
-
-        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
-            @Override
-            public Long call() throws Exception {
-                if (!Thread.currentThread().isInterrupted()) {
-                    SharedRealm sharedRealm = null;
-
-                    try {
-                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
-
-                        long columnIndex = getColumnIndexForSort(fieldName);
-
-                        // Runs the query & handover the table view for the caller thread.
-                        long handoverTableViewPointer = TableQuery.findAllSortedWithHandover(sharedRealm,
-                                 handoverQueryPointer, columnIndex, sortOrder);
-
-                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
-                        result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                        result.versionID = sharedRealm.getVersionID();
-                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
-
-                        return handoverTableViewPointer;
-                    } catch (BadVersionException e) {
-                        // In some rare race conditions, this can happen. In that case, just ignore the error.
-                        RealmLog.debug("findAllSortedAsync handover could not complete due to a BadVersionException. " +
-                                "Retry is scheduled by a REALM_CHANGED event.");
-
-                    } catch (Throwable e) {
-                        RealmLog.error(e);
-                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
-
-                    } finally {
-                        if (sharedRealm!= null && !sharedRealm.isClosed()) {
-                            sharedRealm.close();
-                        }
-                    }
-                } else {
-                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
-                }
+        realm.checkIfValid();
 
-                return INVALID_NATIVE_POINTER;
-            }
-        });
-        realmResults.setPendingQuery(pendingQuery);
-        return realmResults;
+        realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldName, sortOrder);
+        return createRealmResults(query, sortDescriptor, null, false);
     }
 
 
@@ -1918,7 +1806,7 @@ public Long call() throws Exception {
     }
 
     /**
-     * Similar to {@link #findAllSorted(String)} but runs asynchronously on a worker thread
+     * Similar to {@link #findAllSorted(String)} but runs asynchronously on a worker thread.
      * This method is only available from a Looper thread.
      *
      * @return immediately an empty {@link RealmResults}. Users need to register a listener
@@ -1943,31 +1831,11 @@ public Long call() throws Exception {
      * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
-    @SuppressWarnings("unchecked")
     public RealmResults<E> findAllSorted(String fieldNames[], Sort sortOrders[]) {
-        checkSortParameters(fieldNames, sortOrders);
+        realm.checkIfValid();
 
-        if (fieldNames.length == 1 && sortOrders.length == 1) {
-            return findAllSorted(fieldNames[0], sortOrders[0]);
-        } else {
-            TableView tableView = query.findAll();
-            List<Long> columnIndices = new ArrayList<Long>();
-            //noinspection ForLoopReplaceableByForEach
-            for (int i = 0; i < fieldNames.length; i++) {
-                String fieldName = fieldNames[i];
-                long columnIndex = getColumnIndexForSort(fieldName);
-                columnIndices.add(columnIndex);
-            }
-            tableView.sort(columnIndices, sortOrders);
-
-            RealmResults<E> realmResults;
-            if (isDynamicQuery()) {
-                realmResults = (RealmResults<E>) RealmResults.createFromDynamicTableOrView(realm, tableView, className);
-            } else {
-                realmResults = RealmResults.createFromTableOrView(realm, tableView, clazz);
-            }
-            return realmResults;
-        }
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldNames, sortOrders);
+        return createRealmResults(query, sortDescriptor, null, true);
     }
 
     private boolean isDynamicQuery() {
@@ -1975,7 +1843,7 @@ private boolean isDynamicQuery() {
     }
 
     /**
-     * Similar to {@link #findAllSorted(String[], Sort[])} but runs asynchronously
+     * Similar to {@link #findAllSorted(String[], Sort[])} but runs asynchronously.
      * from a worker thread.
      * This method is only available from a Looper thread.
      *
@@ -1986,89 +1854,11 @@ private boolean isDynamicQuery() {
      * {@link RealmObject} or a child {@link RealmList}.
      */
     public RealmResults<E> findAllSortedAsync(String fieldNames[], final Sort[] sortOrders) {
-        checkQueryIsNotReused();
-        checkSortParameters(fieldNames, sortOrders);
-
-        if (fieldNames.length == 1 && sortOrders.length == 1) {
-            return findAllSortedAsync(fieldNames[0], sortOrders[0]);
+        realm.checkIfValid();
 
-        } else {
-            final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
-
-            // Handovers the query (to be used by a worker thread).
-            final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
-
-            // We need to use the same configuration to open a background SharedRealm to perform the query.
-            final RealmConfiguration realmConfiguration = realm.getConfiguration();
-
-            final long indices[] = new long[fieldNames.length];
-            for (int i = 0; i < fieldNames.length; i++) {
-                String fieldName = fieldNames[i];
-                long columnIndex = getColumnIndexForSort(fieldName);
-                indices[i] = columnIndex;
-            }
-
-            // Captures the query arguments for future retries & update.
-            argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_ALL_MULTI_SORTED);
-            argumentsHolder.sortOrders = sortOrders;
-            argumentsHolder.columnIndices = indices;
-
-            // Prepares the promise result.
-            RealmResults<E> realmResults;
-            if (isDynamicQuery()) {
-                //noinspection unchecked
-                realmResults = (RealmResults<E>) RealmResults.createFromDynamicClass(realm, query, className);
-            } else {
-                realmResults = RealmResults.createFromTableQuery(realm, query, clazz);
-            }
-
-            final WeakReference<RealmResults<? extends RealmModel>> weakRealmResults = realm.handlerController.addToAsyncRealmResults(realmResults, this);
-
-            final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
-                @Override
-                public Long call() throws Exception {
-                    if (!Thread.currentThread().isInterrupted()) {
-                        SharedRealm sharedRealm = null;
-
-                        try {
-                            sharedRealm = SharedRealm.getInstance(realmConfiguration);
-
-                            // Runs the query & handover the table view for the caller thread.
-                            long handoverTableViewPointer = TableQuery.findAllMultiSortedWithHandover(sharedRealm,
-                                    handoverQueryPointer, indices, sortOrders);
-
-                            QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmResultsResponse();
-                            result.updatedTableViews.put(weakRealmResults, handoverTableViewPointer);
-                            result.versionID = sharedRealm.getVersionID();
-                            closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                    weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_RESULTS, result);
-
-                            return handoverTableViewPointer;
-                        } catch (BadVersionException e) {
-                            // In some rare race conditions, this can happen. In that case, just ignore the error.
-                            RealmLog.debug("findAllSortedAsync handover could not complete due to a BadVersionException. " +
-                                    "Retry is scheduled by a REALM_CHANGED event.");
-
-                        } catch (Throwable e) {
-                            RealmLog.error(e);
-                            closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                    weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
-                        } finally {
-                            if (sharedRealm != null && !sharedRealm.isClosed()) {
-                                sharedRealm.close();
-                            }
-                        }
-                    } else {
-                        TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
-                    }
-
-                    return INVALID_NATIVE_POINTER;
-                }
-            });
-
-            realmResults.setPendingQuery(pendingQuery);
-            return realmResults;
-        }
+        realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
+        SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(query.getTable(), fieldNames, sortOrders);
+        return createRealmResults(query, sortDescriptor, null, false);
     }
 
     /**
@@ -2112,7 +1902,8 @@ public Long call() throws Exception {
      * @see io.realm.RealmObject
      */
     public E findFirst() {
-        checkQueryIsNotReused();
+        realm.checkIfValid();
+
         long tableRowIndex = getSourceRowIndexForFirstObject();
         if (tableRowIndex >= 0) {
             E realmObject = realm.get(clazz, className, tableRowIndex);
@@ -2134,169 +1925,59 @@ public E findFirst() {
      * {@code false}.
      */
     public E findFirstAsync() {
-        checkQueryIsNotReused();
-        final WeakReference<RealmNotifier> weakNotifier = getWeakReferenceNotifier();
-
-        // Handovers the query (to be used by a worker thread).
-        final long handoverQueryPointer = query.handoverQuery(realm.sharedRealm);
-
-        // Saves query arguments (for future update).
-        argumentsHolder = new ArgumentsHolder(ArgumentsHolder.TYPE_FIND_FIRST);
+        realm.checkIfValid();
 
-        final RealmConfiguration realmConfiguration = realm.getConfiguration();
+        realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
+        Row row;
+        if (realm.isInTransaction()) {
+            // It is not possible to create async query inside a transaction. So immediately query the first object.
+            // See OS Results::prepare_async()
+            row = new Collection(realm.sharedRealm, query).firstUncheckedRow();
+        } else {
+            // prepares an empty reference of the RealmObject which is backed by a pending query,
+            // then update it once the query complete in the background.
 
-        // Prepares an empty reference of the RealmObject, so we can return it immediately (promise)
-        // then update it once the query complete in the background.
+            // TODO: The performance by the pending query will be a little bit worse than directly calling core's
+            // Query.find(). The overhead comes with core needs to add all the row indices to the vector. However this
+            // can be optimized by adding support of limit in OS's Results which is supported by core already.
+            row = new PendingRow(realm.sharedRealm, query, null, isDynamicQuery());
+        }
         final E result;
         if (isDynamicQuery()) {
             //noinspection unchecked
-            result = (E) new DynamicRealmObject(className, realm, Row.EMPTY_ROW);
+            result = (E) new DynamicRealmObject(realm, row);
         } else {
             result = realm.getConfiguration().getSchemaMediator().newInstance(
-                    clazz, realm, Row.EMPTY_ROW, realm.getSchema().getColumnInfo(clazz),
+                    clazz, realm, row, realm.getSchema().getColumnInfo(clazz),
                     false, Collections.<String>emptyList());
         }
 
-        final RealmObjectProxy proxy = (RealmObjectProxy) result;
-        final WeakReference<RealmObjectProxy> realmObjectWeakReference = realm.handlerController.addToAsyncRealmObject(proxy, this);
-
-        final Future<Long> pendingQuery = Realm.asyncTaskExecutor.submitQuery(new Callable<Long>() {
-            @Override
-            public Long call() throws Exception {
-                if (!Thread.currentThread().isInterrupted()) {
-                    SharedRealm sharedRealm = null;
-
-                    try {
-                        sharedRealm = SharedRealm.getInstance(realmConfiguration);
-
-                        long handoverRowPointer = TableQuery.findWithHandover(sharedRealm, handoverQueryPointer);
-                        if (handoverRowPointer == 0) { // Empty row.
-                            realm.handlerController.addToEmptyAsyncRealmObject(realmObjectWeakReference, RealmQuery.this);
-                            realm.handlerController.removeFromAsyncRealmObject(realmObjectWeakReference);
-                        }
-
-                        QueryUpdateTask.Result result = QueryUpdateTask.Result.newRealmObjectResponse();
-                        result.updatedRow.put(realmObjectWeakReference, handoverRowPointer);
-                        result.versionID = sharedRealm.getVersionID();
-                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                weakNotifier, QueryUpdateTask.NotifyEvent.COMPLETE_ASYNC_OBJECT, result);
-
-                        return handoverRowPointer;
-
-                    } catch (Throwable e) {
-                        RealmLog.error(e);
-                        // Handler can't throw a checked exception need to wrap it into unchecked Exception.
-                        closeSharedRealmAndSendEventToNotifier(sharedRealm,
-                                weakNotifier, QueryUpdateTask.NotifyEvent.THROW_BACKGROUND_EXCEPTION, e);
-                    } finally {
-                        if (sharedRealm != null && !sharedRealm.isClosed()) {
-                            sharedRealm.close();
-                        }
-                    }
-                } else {
-                    TableQuery.nativeCloseQueryHandover(handoverQueryPointer);
-                }
-
-                return INVALID_NATIVE_POINTER;
-            }
-        });
-        proxy.realmGet$proxyState().setPendingQuery$realm(pendingQuery);
-
-        return result;
-    }
-
-    private void checkSortParameters(String fieldNames[], final Sort[] sortOrders) {
-        if (fieldNames == null) {
-            throw new IllegalArgumentException("fieldNames cannot be 'null'.");
-        } else if (sortOrders == null) {
-            throw new IllegalArgumentException("sortOrders cannot be 'null'.");
-        } else if (fieldNames.length == 0) {
-            throw new IllegalArgumentException("At least one field name must be specified.");
-        } else if (fieldNames.length != sortOrders.length) {
-            throw new IllegalArgumentException(String.format(Locale.ENGLISH,
-                    "Number of field names (%d) and sort orders (%d) does not match.",
-                    fieldNames.length, sortOrders.length));
+        if (row instanceof PendingRow) {
+            final RealmObjectProxy proxy = (RealmObjectProxy) result;
+            ((PendingRow) row).setFrontEnd(proxy.realmGet$proxyState());
         }
-    }
 
-    private WeakReference<RealmNotifier> getWeakReferenceNotifier() {
-        if (realm.sharedRealm.realmNotifier == null || !realm.sharedRealm.realmNotifier.isValid()) {
-            throw new IllegalStateException("Your Realm is opened from a thread without a Looper." +
-                    " Async queries need a Handler to send results of your query");
-        }
-        return new WeakReference<RealmNotifier>(realm.sharedRealm.realmNotifier); // Uses caller Realm's Looper.
+        return result;
     }
 
-    // The shared group needs to be closed before sending the message to other threads to avoid timing problems.
-    // eg.: The other thread wants to delete Realm when getting notified.
-    private void closeSharedRealmAndSendEventToNotifier(SharedRealm sharedRealm,
-                                                         WeakReference<RealmNotifier> weakNotifier,
-                                                        QueryUpdateTask.NotifyEvent event, Object obj) {
-        if (sharedRealm != null) {
-            sharedRealm.close();
+    private RealmResults<E> createRealmResults(TableQuery query,
+                                               SortDescriptor sortDescriptor,
+                                               SortDescriptor distinctDescriptor,
+                                               boolean loadResults) {
+        RealmResults<E> results;
+        Collection collection = new Collection(realm.sharedRealm, query, sortDescriptor, distinctDescriptor);
+        if (isDynamicQuery()) {
+            results = new RealmResults<E>(realm, collection, className);
+        } else {
+            results = new RealmResults<E>(realm, collection, clazz);
         }
-
-        RealmNotifier notifier = weakNotifier.get();
-        if (notifier!= null) {
-            switch (event) {
-                case COMPLETE_ASYNC_RESULTS:
-                    notifier.completeAsyncResults((QueryUpdateTask.Result)obj);
-                    break;
-                case COMPLETE_ASYNC_OBJECT:
-                    notifier.completeAsyncObject((QueryUpdateTask.Result)obj);
-                    break;
-                case THROW_BACKGROUND_EXCEPTION:
-                    notifier.throwBackgroundException((Throwable)obj);
-                    break;
-                default:
-                    // Should not get here.
-                    throw new IllegalStateException(String.format("%s is not handled here.", event));
-            }
-        }
-    }
-
-    // We need to prevent the user from using the query again (mostly for async).
-    // Ex: If the first query fail with findFirstAsync, if the user reuse the same RealmQuery
-    //     with findAllSorted, argumentsHolder of the first query will be overridden,
-    //     which cause any retry to use the findAllSorted argumentsHolder.
-    private void checkQueryIsNotReused() {
-        if (argumentsHolder != null) {
-            throw new IllegalStateException("This RealmQuery is already used by a find* query, please create a new query");
+        if (loadResults) {
+            results.load();
         }
+        return results;
     }
 
     private long getSourceRowIndexForFirstObject() {
-        long tableRowIndex = this.query.find();
-        return tableRowIndex;
-    }
-    // Gets the column index for sorting related functions. A proper exception will be thrown if the field doesn't exist
-    // or it belongs to the child object.
-    private long getColumnIndexForSort(String fieldName) {
-        if (fieldName == null || fieldName.isEmpty()) {
-            throw new IllegalArgumentException("Non-empty fieldname required.");
-        }
-        if (fieldName.contains(".")) {
-            throw new IllegalArgumentException("Sorting using child object fields is not supported: " + fieldName);
-        }
-
-        Long columnIndex = schema.getFieldIndex(fieldName);
-        if (columnIndex == null) {
-            throw new IllegalArgumentException(String.format("Field name '%s' does not exist.", fieldName));
-        }
-
-        return columnIndex;
-    }
-
-    public ArgumentsHolder getArgument() {
-        return argumentsHolder;
-    }
-
-    /**
-     * Exports & handovers the query to be used by a worker thread.
-     *
-     * @return the exported handover pointer for this RealmQuery.
-     */
-    long handoverQueryPointer() {
-        return query.handoverQuery(realm.sharedRealm);
+        return this.query.find();
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmResults.java b/realm/realm-library/src/main/java/io/realm/RealmResults.java
index 0624795949..e6a55ab77e 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmResults.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmResults.java
@@ -17,36 +17,18 @@
 package io.realm;
 
 
-import android.app.IntentService;
+import android.os.Looper;
 
-import java.util.AbstractList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.ConcurrentModificationException;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.NoSuchElementException;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.Future;
-
-import io.realm.internal.InvalidRow;
-import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.Table;
-import io.realm.internal.TableOrView;
-import io.realm.internal.TableQuery;
-import io.realm.internal.TableView;
-import io.realm.internal.async.BadVersionException;
-import io.realm.log.RealmLog;
+import io.realm.internal.Collection;
+import io.realm.internal.SortDescriptor;
 import rx.Observable;
 
 /**
- * This class holds all the matches of a {@link io.realm.RealmQuery} for a given Realm. The objects are not copied from
+ * This class holds all the matches of a {@link RealmQuery} for a given Realm. The objects are not copied from
  * the Realm to the RealmResults list, but are just referenced from the RealmResult instead. This saves memory and
  * increases speed.
  * <p>
- * RealmResults are live views, which means that if it is on an {@link android.os.Looper} thread, it will automatically
+ * RealmResults are live views, which means that if it is on an {@link Looper} thread, it will automatically
  * update its query results after a transaction has been committed. If on a non-looper thread, {@link Realm#waitForChange()}
  * must be called to update the results.
  * <p>
@@ -66,109 +48,16 @@
  *
  * @param <E> The class of objects in this list.
  * @see RealmQuery#findAll()
- * @see io.realm.Realm#executeTransaction(Realm.Transaction)
+ * @see Realm#executeTransaction(Realm.Transaction)
  */
-public class RealmResults<E extends RealmModel> extends AbstractList<E> implements OrderedRealmCollection<E> {
-
-    private final static String NOT_SUPPORTED_MESSAGE = "This method is not supported by RealmResults.";
-
-    final BaseRealm realm;
-    Class<E> classSpec;   // Return type
-    String className;     // Class name used by DynamicRealmObjects
-    private TableOrView table = null;
-
-    private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
-    private static final long TABLE_VIEW_VERSION_NONE = -1;
-
-    private long currentTableViewVersion = TABLE_VIEW_VERSION_NONE;
-    private final TableQuery query;
-    private final List<RealmChangeListener<RealmResults<E>>> listeners = new CopyOnWriteArrayList<RealmChangeListener<RealmResults<E>>>();
-    private Future<Long> pendingQuery;
-    private boolean asyncQueryCompleted = false;
-    // Keeps track of changes to the RealmResult. Is updated after a call to `syncIfNeeded()`. Calling notifyListeners
-    // will clear it.
-    private boolean viewUpdated = false;
-
-
-    static <E extends RealmModel> RealmResults<E> createFromTableQuery(BaseRealm realm, TableQuery query, Class<E> clazz) {
-        return new RealmResults<E>(realm, query, clazz);
-    }
-
-    static <E extends RealmModel> RealmResults<E> createFromTableOrView(BaseRealm realm, TableOrView table, Class<E> clazz) {
-        RealmResults<E> realmResults = new RealmResults<E>(realm, table, clazz);
-        realm.handlerController.addToRealmResults(realmResults);
-        return realmResults;
-    }
-
-    static RealmResults<DynamicRealmObject> createFromDynamicClass(BaseRealm realm, TableQuery query, String className) {
-        return new RealmResults<DynamicRealmObject>(realm, query, className);
-    }
-
-    static RealmResults<DynamicRealmObject> createFromDynamicTableOrView(BaseRealm realm, TableOrView table, String className) {
-        RealmResults<DynamicRealmObject> realmResults = new RealmResults<DynamicRealmObject>(realm, table, className);
-        realm.handlerController.addToRealmResults(realmResults);
-        return realmResults;
-    }
-
-    private RealmResults(BaseRealm realm, TableQuery query, Class<E> clazz) {
-        this.realm = realm;
-        this.classSpec = clazz;
-        this.query = query;
-    }
+public class RealmResults<E extends RealmModel> extends OrderedRealmCollectionImpl<E> {
 
-    private RealmResults(BaseRealm realm, TableQuery query, String className) {
-        this.realm = realm;
-        this.query = query;
-        this.className = className;
+    RealmResults(BaseRealm realm, Collection collection, Class<E> clazz) {
+        super(realm, collection, clazz);
     }
 
-    private RealmResults(BaseRealm realm, TableOrView table, Class<E> classSpec) {
-        this.realm = realm;
-        this.classSpec = classSpec;
-        this.table = table;
-
-        this.pendingQuery = null;
-        this.query = null;
-        this.currentTableViewVersion = table.syncIfNeeded();
-    }
-
-    private RealmResults(BaseRealm realm, String className) {
-        this.realm = realm;
-        this.className = className;
-
-        pendingQuery = null;
-        query = null;
-    }
-
-    private RealmResults(BaseRealm realm, TableOrView table, String className) {
-        this(realm, className);
-        this.table = table;
-        this.currentTableViewVersion = table.syncIfNeeded();
-    }
-
-    TableOrView getTableOrView() {
-        if (table == null) {
-            return realm.schema.getTable(classSpec);
-        } else {
-            return table;
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public boolean isValid() {
-        return !realm.isClosed();
-    }
-
-    /**
-     * A {@link RealmResults} is always a managed collection.
-     *
-     * @return {@code true}.
-     * @see RealmCollection#isManaged()
-     */
-    public boolean isManaged() {
-        return true;
+    RealmResults(BaseRealm realm, Collection collection, String className) {
+        super(realm, collection, className);
     }
 
     /**
@@ -180,226 +69,6 @@ public boolean isManaged() {
         return RealmQuery.createQueryFromResult(this);
     }
 
-    /**
-     * Searches this {@link RealmResults} for the specified object.
-     *
-     * @param object the object to search for.
-     * @return {@code true} if {@code object} is an element of this {@code RealmResults},
-     *         {@code false} otherwise
-     */
-    @Override
-    public boolean contains(Object object) {
-        if (isLoaded()) {
-            // Deleted objects can never be part of a RealmResults
-            if (object instanceof RealmObjectProxy) {
-                RealmObjectProxy proxy = (RealmObjectProxy) object;
-                if (proxy.realmGet$proxyState().getRow$realm() == InvalidRow.INSTANCE) {
-                    return false;
-                }
-            }
-
-            for (E e : this) {
-                if (e.equals(object)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Returns the element at the specified location in this list.
-     *
-     * @param location the index of the element to return.
-     * @return the element at the specified index.
-     * @throws IndexOutOfBoundsException if {@code location < 0 || location >= size()}.
-     */
-    @Override
-    public E get(int location) {
-        E obj;
-        realm.checkIfValid();
-        TableOrView table = getTableOrView();
-        if (table instanceof TableView) {
-            obj = realm.get(classSpec, className, ((TableView) table).getSourceRowIndex(location));
-        } else {
-            obj = realm.get(classSpec, className, location);
-        }
-
-        return obj;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public E first() {
-        return firstImpl(true, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public E first(E defaultValue) {
-        return firstImpl(false, defaultValue);
-    }
-
-    private E firstImpl(boolean shouldThrow, E defaultValue) {
-        if (!isEmpty()) {
-            return get(0);
-        } else {
-            if (shouldThrow) {
-                throw new IndexOutOfBoundsException("No results were found.");
-            } else {
-                return defaultValue;
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public E last() {
-        return lastImpl(true, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public E last(E defaultValue) {
-        return lastImpl(false, defaultValue);
-        
-    }
-
-    private E lastImpl(boolean shouldThrow, E defaultValue) {
-        if (!isEmpty()) {
-            return get(size() - 1);
-        } else {
-            if (shouldThrow) {
-                throw new IndexOutOfBoundsException("No results were found.");
-            } else {
-                return defaultValue;
-            }
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void deleteFromRealm(int location) {
-        realm.checkIfValid();
-        TableOrView table = getTableOrView();
-        table.remove(location);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean deleteAllFromRealm() {
-        realm.checkIfValid();
-        if (size() > 0) {
-            TableOrView table = getTableOrView();
-            table.clear();
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Returns an iterator for the results of a query. Any change to Realm while iterating will cause this iterator to
-     * throw a {@link java.util.ConcurrentModificationException} if accessed.
-     *
-     * @return an iterator on the elements of this list.
-     * @see Iterator
-     */
-    @Override
-    public Iterator<E> iterator() {
-        if (!isLoaded()) {
-            // Collections.emptyIterator(); is only available since API 19
-            return Collections.<E>emptyList().iterator();
-        }
-        return new RealmResultsIterator();
-    }
-
-    /**
-     * Returns a list iterator for the results of a query. Any change to Realm while iterating will cause the iterator
-     * to throw a {@link java.util.ConcurrentModificationException} if accessed.
-     *
-     * @return a ListIterator on the elements of this list.
-     * @see ListIterator
-     */
-    @Override
-    public ListIterator<E> listIterator() {
-        if (!isLoaded()) {
-            // Collections.emptyListIterator() is only available since API 19
-            return Collections.<E>emptyList().listIterator();
-        }
-        return new RealmResultsListIterator(0);
-    }
-
-    /**
-     * Returns a list iterator on the results of a query. Any change to Realm while iterating will cause the iterator to
-     * throw a {@link java.util.ConcurrentModificationException} if accessed.
-     *
-     * @param location the index at which to start the iteration.
-     * @return a ListIterator on the elements of this list.
-     * @throws IndexOutOfBoundsException if {@code location < 0 || location > size()}.
-     * @see ListIterator
-     */
-    @Override
-    public ListIterator<E> listIterator(int location) {
-        if (!isLoaded()) {
-            // Collections.emptyListIterator() is only available since API 19
-            return Collections.<E>emptyList().listIterator(location);
-        }
-        return new RealmResultsListIterator(location);
-    }
-
-    // Sorting
-
-    // aux. method used by sort methods
-    private long getColumnIndexForSort(String fieldName) {
-        if (fieldName == null || fieldName.isEmpty()) {
-            throw new IllegalArgumentException("Non-empty field name required.");
-        }
-        if (fieldName.contains(".")) {
-            throw new IllegalArgumentException("Sorting using child object fields is not supported: " + fieldName);
-        }
-        long columnIndex = table.getColumnIndex(fieldName);
-        if (columnIndex < 0) {
-            throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldName));
-        }
-        return columnIndex;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public RealmResults<E> sort(String fieldName) {
-        return this.sort(fieldName, Sort.ASCENDING);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public RealmResults<E> sort(String fieldName, Sort sortOrder) {
-        return where().findAllSorted(fieldName, sortOrder);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public RealmResults<E> sort(String fieldNames[], Sort sortOrders[]) {
-        return where().findAllSorted(fieldNames, sortOrders);
-    }
 
     /**
      * {@inheritDoc}
@@ -409,600 +78,111 @@ private long getColumnIndexForSort(String fieldName) {
         return sort(new String[]{fieldName1, fieldName2}, new Sort[]{sortOrder1, sortOrder2});
     }
 
-    // Aggregates
-
-    /**
-     * Returns the number of elements in this query result.
-     *
-     * @return the number of elements in this query result.
-     */
-    @Override
-    public int size() {
-        if (!isLoaded()) {
-            return 0;
-        } else {
-            long size = getTableOrView().size();
-            return (size > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) size;
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public Number min(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = getColumnIndexForSort(fieldName);
-        switch (table.getColumnType(columnIndex)) {
-            case INTEGER:
-                return table.minimumLong(columnIndex);
-            case FLOAT:
-                return table.minimumFloat(columnIndex);
-            case DOUBLE:
-                return table.minimumDouble(columnIndex);
-            default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public Date minDate(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = getColumnIndexForSort(fieldName);
-        if (table.getColumnType(columnIndex) == RealmFieldType.DATE) {
-            return table.minimumDate(columnIndex);
-        }
-        else {
-            throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "Date"));
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public Number max(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = getColumnIndexForSort(fieldName);
-        switch (table.getColumnType(columnIndex)) {
-            case INTEGER:
-                return table.maximumLong(columnIndex);
-            case FLOAT:
-                return table.maximumFloat(columnIndex);
-            case DOUBLE:
-                return table.maximumDouble(columnIndex);
-            default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
-        }
-    }
-
-    /**
-     * Finds the maximum date.
-     *
-     * @param fieldName the field to look for the maximum date. If fieldName is not of Date type, an exception is
-     *                  thrown.
-     * @return if no objects exist or they all have {@code null} as the value for the given date field, {@code null}
-     * will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with
-     * {@code null} values are ignored.
-     * @throws java.lang.IllegalArgumentException if fieldName is not a Date field.
-     */
-    public Date maxDate(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = getColumnIndexForSort(fieldName);
-        if (table.getColumnType(columnIndex) == RealmFieldType.DATE) {
-            return table.maximumDate(columnIndex);
-        }
-        else {
-            throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "Date"));
-        }
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    public Number sum(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = getColumnIndexForSort(fieldName);
-        switch (table.getColumnType(columnIndex)) {
-            case INTEGER:
-                return table.sumLong(columnIndex);
-            case FLOAT:
-                return table.sumFloat(columnIndex);
-            case DOUBLE:
-                return table.sumDouble(columnIndex);
-            default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    public double average(String fieldName) {
-        realm.checkIfValid();
-        long columnIndex = getColumnIndexForSort(fieldName);
-        switch (table.getColumnType(columnIndex)) {
-            case INTEGER:
-                return table.averageLong(columnIndex);
-            case DOUBLE:
-                return table.averageDouble(columnIndex);
-            case FLOAT:
-                return table.averageFloat(columnIndex);
-            default:
-                throw new IllegalArgumentException(String.format(TYPE_MISMATCH, fieldName, "int, float or double"));
-        }
-    }
-
     /**
-     * Returns a distinct set of objects of a specific class. If the result is sorted, the first
-     * object will be returned in case of multiple occurrences, otherwise it is undefined which
-     * object is returned.
+     * Returns {@code false} if the results are not yet loaded, {@code true} if they are loaded.
      *
-     * @param fieldName the field name.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
+     * @return {@code true} if the query has completed and the data is available, {@code false} if the query is still
+     * running in the background.
      */
-    public RealmResults<E> distinct(String fieldName) {
+    public boolean isLoaded() {
         realm.checkIfValid();
-        long columnIndex = RealmQuery.getAndValidateDistinctColumnIndex(fieldName, this.table.getTable());
-
-        TableOrView tableOrView = getTableOrView();
-        if (tableOrView instanceof Table) {
-            this.table = ((Table) tableOrView).getDistinctView(columnIndex);
-        } else {
-            ((TableView) tableOrView).distinct(columnIndex);
-        }
-        return this;
-    }
-
-    /**
-     * Asynchronously returns a distinct set of objects of a specific class. If the result is
-     * sorted, the first object will be returned in case of multiple occurrences, otherwise it is
-     * undefined which object is returned.
-     *
-     * @param fieldName the field name.
-     * @return immediately a {@link RealmResults}. Users need to register a listener
-     * {@link io.realm.RealmResults#addChangeListener(RealmChangeListener)} to be notified when the
-     * query completes.
-     * @throws IllegalArgumentException if a field is null, does not exist, is an unsupported type,
-     * is not indexed, or points to linked fields.
-     */
-    public RealmResults<E> distinctAsync(String fieldName) {
-        return where().distinctAsync(fieldName);
-    }
-
-    /**
-     * Returns a distinct set of objects from a specific class. When multiple distinct fields are
-     * given, all unique combinations of values in the fields will be returned. In case of multiple
-     * matches, it is undefined which object is returned. Unless the result is sorted, then the
-     * first object will be returned.
-     *
-     * @param firstFieldName first field name to use when finding distinct objects.
-     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
-     * @return a non-null {@link RealmResults} containing the distinct objects.
-     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
-     * is an unsupported type, or points to a linked field.
-     */
-    public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
-        return where().distinct(firstFieldName, remainingFieldNames);
-    }
-
-    // Deleting
-
-    /**
-     * Not supported by RealmResults.
-     *
-     * @throws UnsupportedOperationException
-     */
-    @Deprecated
-    @Override
-    public E remove(int index) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
-    }
-
-    /**
-     * Not supported by RealmResults.
-     *
-     * @throws UnsupportedOperationException
-     */
-    @Deprecated
-    @Override
-    public boolean remove(Object object) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
-    }
-
-    /**
-     * Not supported by RealmResults.
-     *
-     * @throws UnsupportedOperationException
-     */
-    @Deprecated
-    @Override
-    public boolean removeAll(Collection<?> collection) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
-    }
-
-    /**
-     * Not supported by RealmResults.
-     *
-     * @throws UnsupportedOperationException
-     */
-    @Deprecated
-    @Override
-    public E set(int location, E object) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
-    }
-
-
-
-    /**
-     * Not supported by RealmResults.
-     *
-     * @throws UnsupportedOperationException
-     */
-    @Deprecated
-    @Override
-    public boolean retainAll(Collection<?> collection) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+        return collection.isLoaded();
     }
 
     /**
-     * Removes the last object in the list. This also deletes the object from the underlying Realm.
+     * Makes an asynchronous query blocking. This will also trigger any registered {@link RealmChangeListener} when
+     * the query completes.
      *
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
+     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
      */
-    @Override
-    public boolean deleteLastFromRealm() {
+    public boolean load() {
+        // The Collection doesn't have to be loaded before accessing it if the query has not returned.
+        // Instead, accessing the Collection will just trigger the execution of query if needed. We add this flag is
+        // only to keep the original behavior of those APIs. eg.: For a async RealmResults, before query returns, the
+        // size() call should return 0 instead of running the query get the real size.
         realm.checkIfValid();
-        if (size() > 0) {
-            TableOrView table = getTableOrView();
-            table.removeLast();
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Syncs this RealmResults, so it is up to date after `advance_read` has been called.
-     * Not doing so can leave detached accessors in the table view.
-     *
-     * By design, we should only call this on looper events.
-     *
-     * NOTE: Calling this is a prerequisite to calling {@link #notifyChangeListeners(boolean)}.
-     */
-    void syncIfNeeded() {
-        long newVersion = table.syncIfNeeded();
-        viewUpdated = newVersion != currentTableViewVersion;
-        currentTableViewVersion = newVersion;
-    }
-
-    /**
-     * Removes the first object in the list. This also deletes the object from the underlying Realm.
-     *
-     * @throws IllegalStateException if the corresponding Realm is closed or in an incorrect thread.
-     */
-    @Override
-    public boolean deleteFirstFromRealm() {
-        if (size() > 0) {
-            TableOrView table = getTableOrView();
-            table.removeFirst();
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    /**
-     * Not supported by RealmResults.
-     *
-     * @throws UnsupportedOperationException always.
-     */
-    @Override
-    @Deprecated
-    public void clear() {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
-    }
-
-    /**
-     * Not supported by RealmResults.
-     *
-     * @throws UnsupportedOperationException always.
-     */
-    @Override
-    @Deprecated
-    public boolean add(E element) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
-    }
-
-    /**
-     * Not supported by RealmResults.
-     *
-     * @throws UnsupportedOperationException always.
-     */
-    @Override
-    @Deprecated
-    public void add(int index, E element) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+        collection.load();
+        return true;
     }
 
     /**
-     * Not supported by RealmResults.
+     * Adds a change listener to this {@link RealmResults}.
      *
-     * @throws UnsupportedOperationException always.
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or
+     * {@link android.app.IntentService} thread.
      */
-    @Override
-    @Deprecated
-    public boolean addAll(int location, Collection<? extends E> collection) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
+    public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
+        checkForAddRemoveListener(listener, true);
+        collection.addListener(this, listener);
     }
 
     /**
-     * Not supported by RealmResults.
+     * Adds a change listener to this {@link RealmResults}.
      *
-     * @throws UnsupportedOperationException always.
+     * @param listener the change listener to be notified.
+     * @throws IllegalArgumentException if the change listener is {@code null}.
+     * @throws IllegalStateException if you try to add a listener from a non-Looper or
+     * {@link android.app.IntentService} thread.
      */
-    @Deprecated
-    @Override
-    public boolean addAll(Collection<? extends E> collection) {
-        throw new UnsupportedOperationException(NOT_SUPPORTED_MESSAGE);
-    }
-
-    // Custom RealmResults iterator. It ensures that we only iterate on a Realm that hasn't changed.
-    private class RealmResultsIterator implements Iterator<E> {
-        long tableViewVersion = 0;
-        int pos = -1;
-
-        RealmResultsIterator() {
-            tableViewVersion = currentTableViewVersion;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public boolean hasNext() {
-            return pos + 1 < size();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        public E next() {
-            realm.checkIfValid();
-            checkRealmIsStable();
-            pos++;
-            if (pos >= size()) {
-                throw new NoSuchElementException("Cannot access index " + pos + " when size is " + size() +  ". Remember to check hasNext() before using next().");
-            }
-            return get(pos);
-        }
-
-        /**
-         * Not supported by RealmResults iterators.
-         *
-         * @throws UnsupportedOperationException
-         */
-        @Deprecated
-        public void remove() {
-            throw new UnsupportedOperationException("remove() is not supported by RealmResults iterators.");
-        }
-
-        void checkRealmIsStable() {
-            long version = table.getVersion();
-            // Any change within a write transaction will immediately update the table version. This means that we
-            // cannot depend on the tableVersion heuristic in that case.
-            // You could argue that in that case it is not really a "ConcurrentModification", but this interpretation
-            // is still more lax than what the standard Java Collection API gives.
-            // TODO: Try to come up with a better scheme
-            if (!realm.isInTransaction() && tableViewVersion > -1 && version != tableViewVersion) {
-                throw new ConcurrentModificationException("No outside changes to a Realm is allowed while iterating a RealmResults. Don't call Realm.refresh() while iterating.");
-            }
-            tableViewVersion = version;
-        }
-    }
-
-    // Custom RealmResults list iterator.
-    private class RealmResultsListIterator extends RealmResultsIterator implements ListIterator<E> {
-
-        RealmResultsListIterator(int start) {
-            if (start >= 0 && start <= size()) {
-                pos = start - 1;
-            } else {
-                throw new IndexOutOfBoundsException("Starting location must be a valid index: [0, " + (size() - 1) + "]. Yours was " + start);
-            }
-        }
-
-        /**
-         * Unsupported by RealmResults iterators.
-         *
-         * @throws UnsupportedOperationException
-         */
-        @Override
-        @Deprecated
-        public void add(E object) {
-            throw new UnsupportedOperationException("Adding an element is not supported. Use Realm.createObject() instead.");
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public boolean hasPrevious() {
-            return pos >= 0;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public int nextIndex() {
-            return pos + 1;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public E previous() {
-            realm.checkIfValid();
-            checkRealmIsStable();
-            try {
-                E obj = get(pos);
-                pos--;
-                return obj;
-            } catch (IndexOutOfBoundsException e) {
-                throw new NoSuchElementException("Cannot access index less than zero. This was " + pos + ". Remember to check hasPrevious() before using previous().");
-            }
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public int previousIndex() {
-            return pos;
-        }
-
-        /**
-         * Unsupported by RealmResults iterators.
-         *
-         * @throws UnsupportedOperationException
-         */
-        @Override
-        @Deprecated
-        public void set(E object) {
-            throw new UnsupportedOperationException("Replacing and element is not supported.");
-        }
+    public void addChangeListener(OrderedRealmCollectionChangeListener<RealmResults<E>> listener) {
+        checkForAddRemoveListener(listener, true);
+        collection.addListener(this, listener);
     }
 
-    /**
-     * Swaps the table_view pointer used by this RealmResults mostly called when updating the RealmResults from a worker
-     * thread.
-     *
-     * @param handoverTableViewPointer handover pointer to the new table_view.
-     * @throws IllegalStateException if caller and worker are not at the same version.
-     */
-    void swapTableViewPointer(long handoverTableViewPointer) {
-        try {
-            table = query.importHandoverTableView(handoverTableViewPointer, realm.sharedRealm);
-            asyncQueryCompleted = true;
-        } catch (BadVersionException e) {
-            throw new IllegalStateException("Caller and Worker Realm should have been at the same version");
+    private void checkForAddRemoveListener(Object listener, boolean checkListener) {
+        if (checkListener && listener == null) {
+            throw new IllegalArgumentException("Listener should not be null");
         }
-    }
-
-    /**
-     * Sets the Future instance returned by the worker thread, we need this instance to force {@link #load()} an async
-     * query, we use it to determine if the current RealmResults is a sync or async one.
-     *
-     * @param pendingQuery pending query.
-     */
-    void setPendingQuery(Future<Long> pendingQuery) {
-        this.pendingQuery = pendingQuery;
-        if (isLoaded()) {
-            // the query completed before RealmQuery
-            // had a chance to call setPendingQuery to register the pendingQuery (used
-            // to determine isLoaded behaviour)
-            onAsyncQueryCompleted();
-        } // else, it will be handled by the {@link BaseRealm#handlerController#handleMessage}
-    }
-
-    /**
-     * Returns {@code false} if the results are not yet loaded, {@code true} if they are loaded. Synchronous
-     * query methods like findAll() will always return {@code true}, while asynchronous query methods like
-     * findAllAsync() will return {@code false} until the results are available.
-     *
-     * @return {@code true} if the query has completed and the data is available, {@code false} if the query is still
-     * running.
-     */
-    public boolean isLoaded() {
         realm.checkIfValid();
-        return pendingQuery == null || asyncQueryCompleted;
+        realm.sharedRealm.capabilities.checkCanDeliverNotification(BaseRealm.LISTENER_NOT_ALLOWED_MESSAGE);
     }
 
     /**
-     * Makes an asynchronous query blocking. This will also trigger any registered {@link RealmChangeListener} when
-     * the query completes.
+     * Removes all user-defined change listeners.
      *
-     * @return {@code true} if it successfully completed the query, {@code false} otherwise. {@code true} will always
-     *         be returned for unmanaged objects.
+     * @throws IllegalStateException if you try to remove listeners from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
      */
-    public boolean load() {
-        //noinspection SimplifiableIfStatement
-        if (isLoaded()) {
-            return true;
-        } else {
-            // doesn't guarantee to correctly import the result (because the user may have advanced)
-            // in this case the Realm#handler will be responsible of retrying
-            return onAsyncQueryCompleted();
-        }
+    public void removeAllChangeListeners() {
+        checkForAddRemoveListener(null, false);
+        collection.removeAllListeners();
     }
 
     /**
-     * Called to import the handover table_view pointer & notify listeners.
-     * This should be invoked once the {@link #pendingQuery} finish, unless the user force {@link #load()}.
-     *
-     * @return {@code true} if it successfully completed the query, {@code false} otherwise.
+     * Use {@link #removeAllChangeListeners()} instead.
      */
-    private boolean onAsyncQueryCompleted() {
-        try {
-            long tvHandover = pendingQuery.get();// make the query blocking
-            // this may fail with BadVersionException if the caller and/or the worker thread
-            // are not in sync. COMPLETED_ASYNC_REALM_RESULTS will be fired by the worker thread
-            // this should handle more complex use cases like retry, ignore etc
-            table = query.importHandoverTableView(tvHandover, realm.sharedRealm);
-            asyncQueryCompleted = true;
-            notifyChangeListeners(true);
-        } catch (Exception e) {
-            RealmLog.debug(e.getMessage());
-            return false;
-        }
-        return true;
+    @SuppressWarnings("unused")
+    @Deprecated
+    public void removeChangeListeners() {
+        removeAllChangeListeners();
     }
 
     /**
-     * Adds a change listener to this RealmResults.
+     * Removes the specified change listener.
      *
-     * @param listener the change listener to be notified.
+     * @param listener the change listener to be removed.
      * @throws IllegalArgumentException if the change listener is {@code null}.
-     * @throws IllegalStateException if you try to add a listener from a non-Looper or {@link IntentService} thread.
+     * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
      */
-    public void addChangeListener(RealmChangeListener<RealmResults<E>> listener) {
-        if (listener == null) {
-            throw new IllegalArgumentException("Listener should not be null");
-        }
-        realm.checkIfValid();
-        if (!realm.handlerController.isAutoRefreshEnabled()) {
-            throw new IllegalStateException("You can't register a listener from a non-Looper thread or IntentService thread. ");
-        }
-        if (!listeners.contains(listener)) {
-            listeners.add(listener);
-        }
+    public void removeChangeListener(RealmChangeListener<RealmResults<E>> listener) {
+        checkForAddRemoveListener(listener, true);
+        collection.removeListener(this, listener);
     }
 
     /**
-     * Removes a previously registered listener.
+     * Removes the specified change listener.
      *
-     * @param listener the instance to be removed.
+     * @param listener the change listener to be removed.
      * @throws IllegalArgumentException if the change listener is {@code null}.
      * @throws IllegalStateException if you try to remove a listener from a non-Looper Thread.
+     * @see io.realm.RealmChangeListener
      */
-    public void removeChangeListener(RealmChangeListener listener) {
-        if (listener == null) {
-            throw new IllegalArgumentException("Listener should not be null");
-        }
-        realm.checkIfValid();
-        listeners.remove(listener);
-    }
-
-    /**
-     * Removes all registered listeners.
-     */
-    public void removeChangeListeners() {
-        realm.checkIfValid();
-        listeners.clear();
+    public void removeChangeListener(OrderedRealmCollectionChangeListener<RealmResults<E>> listener) {
+        checkForAddRemoveListener(listener, true);
+        collection.removeListener(this, listener);
     }
 
     /**
@@ -1048,20 +228,31 @@ public void removeChangeListeners() {
     }
 
     /**
-     * Notifies all registered listeners.
-     *
-     * NOTE: Remember to call `syncIfNeeded` before calling this method.
+     * @deprecated use {@link RealmQuery#distinct(String)} on the return value of {@link #where()} instead. This will
+     * be removed in coming 3.x.x minor releases.
      */
-    void notifyChangeListeners(boolean forceNotify) {
-        if (!listeners.isEmpty()) {
-            // table might be null (if the async query didn't complete
-            // but we have already registered listeners for it)
-            if (pendingQuery != null && !asyncQueryCompleted) return;
-            if (!viewUpdated && !forceNotify) return;
-            viewUpdated = false;
-            for (RealmChangeListener listener : listeners) {
-                listener.onChange(this);
-            }
-        }
+    @Deprecated
+    public RealmResults<E> distinct(String fieldName) {
+        SortDescriptor distinctDescriptor = SortDescriptor.getInstanceForDistinct(collection.getTable(), fieldName);
+        Collection distinctCollection = collection.distinct(distinctDescriptor);
+        return createLoadedResults(distinctCollection);
+    }
+
+    /**
+     * @deprecated use {@link RealmQuery#distinctAsync(String)} on the return value of {@link #where()} instead. This
+     * will be removed in coming 3.x.x minor releases.
+     */
+    @Deprecated
+    public RealmResults<E> distinctAsync(String fieldName) {
+        return where().distinctAsync(fieldName);
+    }
+
+    /**
+     * @deprecated use {@link RealmQuery#distinct(String, String...)} on the return value of {@link #where()} instead.
+     * This will be removed in coming 3.x.x minor releases.
+     */
+    @Deprecated
+    public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
+        return where().distinct(firstFieldName, remainingFieldNames);
     }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java b/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java
new file mode 100644
index 0000000000..5eaa72a770
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/Capabilities.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+/**
+ * To describe what the Realm instance can do associated with the thread it is created on.
+ * The capabilities are determined when the Realm gets created. This interface could be called from another thread which
+ * is different from where the Realm is created on.
+ */
+public interface Capabilities {
+    /**
+     * Return true if this Realm can be notified by another thread.
+     *
+     * @return true if this Realm can be notified from an other thread.
+     */
+    boolean canDeliverNotification();
+
+    /**
+     * Check if a Realm is able to receive a notification. If not, an {@link IllegalStateException} should be be thrown.
+     *
+     * @param exceptionMessage message which is contained in the exception.
+     */
+    void checkCanDeliverNotification(String exceptionMessage);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
index 7c36e57512..9e0e762086 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/CheckedRow.java
@@ -50,7 +50,7 @@ private CheckedRow(UncheckedRow row) {
      * @return an instance of Row for the table and index specified.
      */
     public static CheckedRow get(Context context, Table table, long index) {
-        long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
+        long nativeRowPointer = table.nativeGetRowPtr(table.getNativePtr(), index);
         return new CheckedRow(context, table, nativeRowPointer);
     }
 
@@ -72,7 +72,7 @@ public static CheckedRow get(Context context, LinkView linkView, long index) {
      *
      * @return an checked instance of {@link Row}.
      */
-    static CheckedRow getFromRow(UncheckedRow row) {
+    public static CheckedRow getFromRow(UncheckedRow row) {
         return new CheckedRow(row);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Collection.java b/realm/realm-library/src/main/java/io/realm/internal/Collection.java
new file mode 100644
index 0000000000..704e8cbdff
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/Collection.java
@@ -0,0 +1,563 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.util.ConcurrentModificationException;
+import java.util.Date;
+import java.util.NoSuchElementException;
+
+import io.realm.OrderedCollectionChangeSet;
+import io.realm.OrderedRealmCollectionChangeListener;
+import io.realm.RealmChangeListener;
+
+/**
+ * Java wrapper of Object Store Results class.
+ * It is the backend of binding's query results, link lists and back links.
+ */
+@Keep
+public class Collection implements NativeObject {
+
+    private class CollectionObserverPair<T> extends ObserverPairList.ObserverPair<T, Object> {
+        public CollectionObserverPair(T observer, Object listener) {
+            super(observer, listener);
+        }
+
+        public void onChange(T observer, OrderedCollectionChangeSet changes) {
+            if (listener instanceof OrderedRealmCollectionChangeListener) {
+                //noinspection unchecked
+                ((OrderedRealmCollectionChangeListener<T>)listener).onChange(observer, changes);
+            } else if (listener instanceof RealmChangeListener) {
+                //noinspection unchecked
+                ((RealmChangeListener<T>)listener).onChange(observer);
+            } else {
+                throw new RuntimeException("Unsupported listener type: " + listener);
+            }
+        }
+    }
+
+    private static class RealmChangeListenerWrapper<T> implements OrderedRealmCollectionChangeListener<T> {
+        private final RealmChangeListener<T> listener;
+
+        RealmChangeListenerWrapper(RealmChangeListener<T> listener) {
+            this.listener = listener;
+        }
+
+        @Override
+        public void onChange(T collection, OrderedCollectionChangeSet changes) {
+            listener.onChange(collection);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return obj instanceof RealmChangeListenerWrapper &&
+                    listener == ((RealmChangeListenerWrapper) obj).listener;
+        }
+
+        @Override
+        public int hashCode() {
+            return listener.hashCode();
+        }
+    }
+
+    private static class Callback implements ObserverPairList.Callback<CollectionObserverPair> {
+        private final OrderedCollectionChangeSet changeSet;
+
+        Callback(OrderedCollectionChangeSet changeSet) {
+            this.changeSet = changeSet;
+        }
+
+        @Override
+        public void onCalled(CollectionObserverPair pair, Object observer) {
+            //noinspection unchecked
+            pair.onChange(observer, changeSet);
+        }
+    }
+
+    // Custom Collection iterator. It ensures that we only iterate on a Realm collection that hasn't changed.
+    public static abstract class Iterator<T> implements java.util.Iterator<T> {
+        Collection iteratorCollection;
+        protected int pos = -1;
+
+        public Iterator(Collection collection) {
+            this.iteratorCollection = collection;
+
+            if (collection.isSnapshot) {
+                // No need to detach a snapshot.
+                return;
+            }
+
+            if (collection.sharedRealm.isInTransaction()) {
+                detach();
+            } else {
+                iteratorCollection.sharedRealm.addIterator(this);
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean hasNext() {
+            checkValid();
+            return pos + 1 < iteratorCollection.size();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public T next() {
+            checkValid();
+            pos++;
+            if (pos >= iteratorCollection.size()) {
+                throw new NoSuchElementException("Cannot access index " + pos + " when size is " + iteratorCollection.size() +
+                        ". Remember to check hasNext() before using next().");
+            }
+            return get(pos);
+        }
+
+        /**
+         * Not supported by Realm collection iterators.
+         *
+         * @throws UnsupportedOperationException
+         */
+        @Deprecated
+        public void remove() {
+            throw new UnsupportedOperationException("remove() is not supported by RealmResults iterators.");
+        }
+
+        void detach() {
+            iteratorCollection = iteratorCollection.createSnapshot();
+        }
+
+        // The iterator becomes invalid after receiving a remote change notification. In Java, the destruction of
+        // iterator totally depends on GC. If we just detach those iterators when remote change notification received
+        // like what realm-cocoa does, we will have a massive overhead since all the iterators created in the previous
+        // event loop need to be detached.
+        void invalidate() {
+            iteratorCollection = null;
+        }
+
+        void checkValid() {
+            if (iteratorCollection == null)  {
+                throw new ConcurrentModificationException(
+                        "No outside changes to a Realm is allowed while iterating a living Realm collection.");
+            }
+        }
+
+        T get(int pos) {
+            return convertRowToObject(iteratorCollection.getUncheckedRow(pos));
+        }
+
+        // Returns the RealmModel by given row in this list. This has to be implemented in the upper layer since
+        // we don't have information about the object types in the internal package.
+        protected abstract T convertRowToObject(UncheckedRow row);
+    }
+
+    // Custom Realm collection list iterator.
+    public static abstract class ListIterator<T> extends Iterator<T> implements java.util.ListIterator<T> {
+
+        public ListIterator(Collection collection, int start) {
+            super(collection);
+            if (start >= 0 && start <= iteratorCollection.size()) {
+                pos = start - 1;
+            } else {
+                throw new IndexOutOfBoundsException("Starting location must be a valid index: [0, "
+                        + (iteratorCollection.size() - 1) + "]. Yours was " + start);
+            }
+        }
+
+        /**
+         * Unsupported by Realm collection iterators.
+         *
+         * @throws UnsupportedOperationException
+         */
+        @Override
+        @Deprecated
+        public void add(T object) {
+            throw new UnsupportedOperationException("Adding an element is not supported. Use Realm.createObject() instead.");
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean hasPrevious() {
+            checkValid();
+            return pos >= 0;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int nextIndex() {
+            checkValid();
+            return pos + 1;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public T previous() {
+            checkValid();
+            try {
+                T obj = get(pos);
+                pos--;
+                return obj;
+            } catch (IndexOutOfBoundsException e) {
+                throw new NoSuchElementException("Cannot access index less than zero. This was " + pos +
+                        ". Remember to check hasPrevious() before using previous().");
+            }
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int previousIndex() {
+            checkValid();
+            return pos;
+        }
+
+        /**
+         * Unsupported by RealmResults iterators.
+         *
+         * @throws UnsupportedOperationException
+         */
+        @Override
+        @Deprecated
+        public void set(T object) {
+            throw new UnsupportedOperationException("Replacing and element is not supported.");
+        }
+    }
+
+    private final long nativePtr;
+    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
+    private final SharedRealm sharedRealm;
+    private final Context context;
+    private final Table table;
+    private boolean loaded;
+    private boolean isSnapshot = false;
+    private final ObserverPairList<CollectionObserverPair> observerPairs =
+            new ObserverPairList<CollectionObserverPair>();
+
+    // Public for static checking in JNI
+    @SuppressWarnings("WeakerAccess")
+    public static final byte AGGREGATE_FUNCTION_MINIMUM = 1;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte AGGREGATE_FUNCTION_MAXIMUM = 2;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte AGGREGATE_FUNCTION_AVERAGE = 3;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte AGGREGATE_FUNCTION_SUM = 4;
+    public enum Aggregate {
+        MINIMUM(AGGREGATE_FUNCTION_MINIMUM),
+        MAXIMUM(AGGREGATE_FUNCTION_MAXIMUM),
+        AVERAGE(AGGREGATE_FUNCTION_AVERAGE),
+        SUM(AGGREGATE_FUNCTION_SUM);
+
+        private final byte value;
+
+        Aggregate(byte value) {
+            this.value = value;
+        }
+
+        public byte getValue() {
+            return value;
+        }
+    }
+
+    @SuppressWarnings("WeakerAccess")
+    public static final byte MODE_EMPTY = 0;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte MODE_TABLE = 1;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte MODE_QUERY = 2;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte MODE_LINKVIEW = 3;
+    @SuppressWarnings("WeakerAccess")
+    public static final byte MODE_TABLEVIEW = 4;
+    public enum Mode {
+        EMPTY,          // Backed by nothing (for missing tables)
+        TABLE,          // Backed directly by a Table
+        QUERY,          // Backed by a query that has not yet been turned into a TableView
+        LINKVIEW,       // Backed directly by a LinkView
+        TABLEVIEW;      // Backed by a TableView created from a Query
+
+        static Mode getByValue(byte value) {
+            switch (value)  {
+                case MODE_EMPTY:
+                   return EMPTY;
+                case MODE_TABLE:
+                    return TABLE;
+                case MODE_QUERY:
+                    return QUERY;
+                case MODE_LINKVIEW:
+                    return LINKVIEW;
+                case MODE_TABLEVIEW:
+                    return TABLEVIEW;
+                default:
+                    throw new IllegalArgumentException("Invalid value: " + value);
+            }
+        }
+    }
+
+    public Collection(SharedRealm sharedRealm, TableQuery query,
+                      SortDescriptor sortDescriptor, SortDescriptor distinctDescriptor) {
+        query.validateQuery();
+
+        this.nativePtr = nativeCreateResults(sharedRealm.getNativePtr(), query.getNativePtr(),
+                sortDescriptor,
+                distinctDescriptor);
+
+        this.sharedRealm = sharedRealm;
+        this.context = sharedRealm.context;
+        this.table = query.getTable();
+        this.context.addReference(this);
+        this.loaded = false;
+    }
+
+    public Collection(SharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor) {
+        this(sharedRealm, query, sortDescriptor, null);
+    }
+
+    public Collection(SharedRealm sharedRealm, TableQuery query) {
+        this(sharedRealm, query, null, null);
+    }
+
+    public Collection(SharedRealm sharedRealm, LinkView linkView, SortDescriptor sortDescriptor) {
+        this.nativePtr = nativeCreateResultsFromLinkView(sharedRealm.getNativePtr(), linkView.getNativePtr(),
+                sortDescriptor);
+
+        this.sharedRealm = sharedRealm;
+        this.context = sharedRealm.context;
+        this.table = linkView.getTable();
+        this.context.addReference(this);
+        // Collection created from LinkView is loaded by default. So that the listener will be triggered first time
+        // with empty change set.
+        this.loaded = true;
+    }
+
+    private Collection(SharedRealm sharedRealm, Table table, long nativePtr) {
+        this.sharedRealm = sharedRealm;
+        this.context = sharedRealm.context;
+        this.table = table;
+        this.nativePtr = nativePtr;
+        this.context.addReference(this);
+        this.loaded = false;
+    }
+
+    public Collection createSnapshot() {
+        if (isSnapshot) {
+            return this;
+        }
+        Collection collection = new Collection(sharedRealm, table, nativeCreateSnapshot(nativePtr));
+        collection.isSnapshot = true;
+        return collection;
+    }
+
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return nativeFinalizerPtr;
+    }
+
+    public UncheckedRow getUncheckedRow(int index) {
+        return table.getUncheckedRowByPointer(nativeGetRow(nativePtr, index));
+    }
+
+    public UncheckedRow firstUncheckedRow() {
+        long rowPtr = nativeFirstRow(nativePtr);
+        if (rowPtr != 0) {
+            return table.getUncheckedRowByPointer(rowPtr);
+        }
+        return null;
+    }
+
+    public UncheckedRow lastUncheckedRow() {
+        long rowPtr = nativeLastRow(nativePtr);
+        if (rowPtr != 0) {
+            return table.getUncheckedRowByPointer(rowPtr);
+        }
+        return null;
+    }
+
+    public Table getTable() {
+        return table;
+    }
+
+    public TableQuery where() {
+        long nativeQueryPtr = nativeWhere(nativePtr);
+        return new TableQuery(this.context, this.table, nativeQueryPtr);
+    }
+
+    public Number aggregateNumber(Aggregate aggregateMethod, long columnIndex) {
+        return (Number) nativeAggregate(nativePtr, columnIndex, aggregateMethod.getValue());
+    }
+
+    public Date aggregateDate(Aggregate aggregateMethod, long columnIndex) {
+        return (Date) nativeAggregate(nativePtr, columnIndex, aggregateMethod.getValue());
+    }
+
+    public long size() {
+        return nativeSize(nativePtr);
+    }
+
+    public void clear() {
+        nativeClear(nativePtr);
+    }
+
+    public Collection sort(SortDescriptor sortDescriptor) {
+        return new Collection(sharedRealm, table, nativeSort(nativePtr, sortDescriptor));
+    }
+
+    public Collection distinct(SortDescriptor distinctDescriptor) {
+        return new Collection(sharedRealm, table, nativeDistinct(nativePtr, distinctDescriptor));
+    }
+
+    public boolean contains(UncheckedRow row) {
+        return nativeContains(nativePtr, row.getNativePtr());
+    }
+
+    public int indexOf(UncheckedRow row) {
+        long index = nativeIndexOf(nativePtr, row.getNativePtr());
+        return (index > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) index;
+    }
+
+    public int indexOf(long sourceRowIndex) {
+        long index = nativeIndexOfBySourceRowIndex(nativePtr, sourceRowIndex);
+        return (index > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) index;
+    }
+
+    public void delete(long index) {
+        nativeDelete(nativePtr, index);
+    }
+
+    public boolean deleteFirst() {
+        return nativeDeleteFirst(nativePtr);
+    }
+
+    public boolean deleteLast() {
+        return nativeDeleteLast(nativePtr);
+    }
+
+    public <T> void addListener(T observer, OrderedRealmCollectionChangeListener<T> listener) {
+        if (observerPairs.isEmpty()) {
+            nativeStartListening(nativePtr);
+        }
+        CollectionObserverPair<T> collectionObserverPair = new CollectionObserverPair<T>(observer, listener);
+        observerPairs.add(collectionObserverPair);
+    }
+
+    public <T> void addListener(T observer, RealmChangeListener<T> listener) {
+        addListener(observer, new RealmChangeListenerWrapper<T>(listener));
+    }
+
+    public <T> void removeListener(T observer, OrderedRealmCollectionChangeListener<T> listener) {
+        observerPairs.remove(observer, listener);
+        if (observerPairs.isEmpty()) {
+            nativeStopListening(nativePtr);
+        }
+    }
+
+    public <T> void removeListener(T observer, RealmChangeListener<T> listener) {
+        removeListener(observer, new RealmChangeListenerWrapper<T>(listener));
+    }
+
+    public void removeAllListeners() {
+        observerPairs.clear();
+        nativeStopListening(nativePtr);
+    }
+
+    public boolean isValid() {
+        return nativeIsValid(nativePtr);
+    }
+
+    // Called by JNI
+    @SuppressWarnings("unused")
+    private void notifyChangeListeners(long nativeChangeSetPtr) {
+        if (nativeChangeSetPtr == 0 && isLoaded()) {
+            return;
+        }
+        boolean wasLoaded = loaded;
+        loaded = true;
+        // Object Store compute the change set between the SharedGroup versions when the query created and the latest.
+        // So it is possible it deliver a non-empty change set for the first async query returns. In this case, we
+        // return an empty change set to user since it is considered as the first time async query returns.
+        observerPairs.foreach(new Callback(nativeChangeSetPtr == 0 || !wasLoaded ?
+                        null : new CollectionChangeSet(nativeChangeSetPtr)));
+    }
+
+    public Mode getMode() {
+        return Mode.getByValue(nativeGetMode(nativePtr));
+    }
+
+    // The Results of Object Store will be queried asynchronously in nature. But we do have to support "sync" query by
+    // Java like RealmQuery.findAll().
+    // The flag is used for following cases:
+    // 1. For sync query, loaded will be set to true when collection is created. So we will bypass the first trigger of
+    //    listener if it comes with empty change set from Object Store since we assume user already got the query
+    //    result.
+    // 2. For async query, when load() gets called with loaded not set, the listener should be triggered with empty
+    //    change set since it is considered as query first returned.
+    // 3. If the listener triggered with empty change set after load() called for async queries, it is treated as the
+    //    same case as 1).
+    // TODO: Results built from a LinkView has not been considered yet. Maybe it should bet set as loaded when create.
+    public boolean isLoaded() {
+        return loaded;
+    }
+
+    public void load() {
+        if (loaded) {
+            return;
+        }
+        notifyChangeListeners(0);
+    }
+
+    private static native long nativeGetFinalizerPtr();
+    private static native long nativeCreateResults(long sharedRealmNativePtr, long queryNativePtr,
+                                                   SortDescriptor sortDesc, SortDescriptor distinctDesc);
+    private static native long nativeCreateResultsFromLinkView(long sharedRealmNativePtr, long linkViewPtr,
+                                                   SortDescriptor sortDesc);
+    private static native long nativeCreateSnapshot(long nativePtr);
+    private static native long nativeGetRow(long nativePtr, int index);
+    private static native long nativeFirstRow(long nativePtr);
+    private static native long nativeLastRow(long nativePtr);
+    private static native boolean nativeContains(long nativePtr, long nativeRowPtr);
+    private static native void nativeClear(long nativePtr);
+    private static native long nativeSize(long nativePtr);
+    private static native Object nativeAggregate(long nativePtr, long columnIndex, byte aggregateFunc);
+    private static native long nativeSort(long nativePtr, SortDescriptor sortDesc);
+    private static native long nativeDistinct(long nativePtr, SortDescriptor distinctDesc);
+    private static native boolean nativeDeleteFirst(long nativePtr);
+    private static native boolean nativeDeleteLast(long nativePtr);
+    private static native void nativeDelete(long nativePtr, long index);
+    // Non-static, we need this Collection object in JNI.
+    private native void nativeStartListening(long nativePtr);
+    private native void nativeStopListening(long nativePtr);
+    private static native long nativeWhere(long nativePtr);
+    private static native long nativeIndexOf(long nativePtr, long rowNativePtr);
+    private static native long nativeIndexOfBySourceRowIndex(long nativePtr, long sourceRowIndex);
+    private static native boolean nativeIsValid(long nativePtr);
+    private static native byte nativeGetMode(long nativePtr);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java b/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java
new file mode 100644
index 0000000000..96804a1121
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/CollectionChangeSet.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2017 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import io.realm.OrderedCollectionChangeSet;
+
+/**
+ * Implementation of {@link OrderedCollectionChangeSet}. This class holds a pointer to the Object Store's
+ * CollectionChangeSet and read from it only when needed. Creating an Java object from JNI when the collection
+ * notification arrives, is avoided since we also support the collection listeners without a change set parameter,
+ * parsing the change set may not be necessary all the time.
+ */
+public class CollectionChangeSet implements OrderedCollectionChangeSet, NativeObject {
+
+    // Used in JNI.
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_DELETION = 0;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_INSERTION = 1;
+    @SuppressWarnings("WeakerAccess")
+    public static final int TYPE_MODIFICATION = 2;
+    // Max array length is VM dependent. This is a safe value.
+    // See http://stackoverflow.com/questions/3038392/do-java-arrays-have-a-maximum-size
+    @SuppressWarnings({"WeakerAccess", "unused"})
+    public static final int MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;
+
+    private static long finalizerPtr = nativeGetFinalizerPtr();
+    private final long nativePtr;
+
+    public CollectionChangeSet(long nativePtr) {
+        this.nativePtr = nativePtr;
+        Context.dummyContext.addReference(this);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int[] getDeletions() {
+        return nativeGetIndices(nativePtr, TYPE_DELETION);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int[] getInsertions() {
+        return nativeGetIndices(nativePtr, TYPE_INSERTION);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int[] getChanges()  {
+        return nativeGetIndices(nativePtr, TYPE_MODIFICATION);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Range[] getDeletionRanges() {
+        return longArrayToRangeArray(nativeGetRanges(nativePtr, TYPE_DELETION));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Range[] getInsertionRanges() {
+        return longArrayToRangeArray(nativeGetRanges(nativePtr, TYPE_INSERTION));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Range[] getChangeRanges() {
+        return longArrayToRangeArray(nativeGetRanges(nativePtr, TYPE_MODIFICATION));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public long getNativePtr() {
+        return nativePtr;
+    }
+
+    @Override
+    public long getNativeFinalizerPtr() {
+        return finalizerPtr;
+    }
+
+    // Convert long array returned by the nativeGetXxxRanges() to Range array.
+    private Range[] longArrayToRangeArray(int[] longArray) {
+        if (longArray == null) {
+            // Returns a size 0 array so we know JNI gets called.
+            return new Range[0];
+        }
+
+        Range[] ranges = new Range[longArray.length / 2];
+        for (int i = 0; i < ranges.length; i++) {
+            ranges[i] = new Range(longArray[i * 2], longArray[i * 2 + 1]);
+        }
+        return ranges;
+    }
+
+    private native static long nativeGetFinalizerPtr();
+    // Returns the ranges as an long array. eg.: [startIndex1, length1, startIndex2, length2, ...]
+    private native static int[] nativeGetRanges(long nativePtr, int type);
+    // Returns the indices array.
+    private native static int[] nativeGetIndices(long nativePtr, int type);
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Context.java b/realm/realm-library/src/main/java/io/realm/internal/Context.java
index 9dc084e83f..cb9bb6ece6 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Context.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Context.java
@@ -28,6 +28,8 @@
 public class Context {
     private final static ReferenceQueue<NativeObject> referenceQueue = new ReferenceQueue<NativeObject>();
     private final static Thread finalizingThread = new Thread(new FinalizerRunnable(referenceQueue));
+    // Dummy context which will be used by native objects which's destructors are always thread safe.
+    final static Context dummyContext = new Context();
 
     static {
         finalizingThread.setName("RealmFinalizingDaemon");
diff --git a/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java
new file mode 100644
index 0000000000..e910135e5a
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/FieldDescriptor.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal;
+
+import java.util.Arrays;
+
+import io.realm.RealmFieldType;
+
+
+/**
+ * Class describing a single field possible several links away.
+ */
+public class FieldDescriptor {
+
+    private long[] columnIndices;
+    private RealmFieldType fieldType;
+    private String fieldName;
+    private boolean searchIndex;
+
+    public FieldDescriptor(Table table, String fieldDescription, boolean allowLink, boolean allowList) {
+        if (fieldDescription == null || fieldDescription.isEmpty()) {
+            throw new IllegalArgumentException("Non-empty field name must be provided");
+        }
+        if (fieldDescription.startsWith(".") || fieldDescription.endsWith(".")) {
+            throw new IllegalArgumentException("Illegal field name. It cannot start or end with a '.': " + fieldDescription);
+        }
+        if (fieldDescription.contains(".")) {
+            // Resolves field description down to last field name
+            String[] names = fieldDescription.split("\\.");
+            long[] columnIndices = new long[names.length];
+            for (int i = 0; i < names.length - 1; i++) {
+                long index = table.getColumnIndex(names[i]);
+                if (index == Table.NO_MATCH) {
+                    throw new IllegalArgumentException(
+                            String.format("Invalid field name: '%s' does not refer to a class.", names[i]));
+                }
+                RealmFieldType type = table.getColumnType(index);
+                if (!allowLink && type == RealmFieldType.OBJECT) {
+                    throw new IllegalArgumentException(
+                            String.format("'RealmObject' field '%s' is not a supported link field here.", names[i]));
+                } else if (!allowList && type == RealmFieldType.LIST) {
+                    throw new IllegalArgumentException(
+                            String.format("'RealmList' field '%s' is not a supported link field here.", names[i]));
+                } else if (type == RealmFieldType.OBJECT || type == RealmFieldType.LIST) {
+                     table = table.getLinkTarget(index);
+                    columnIndices[i] = index;
+                } else {
+                    throw new IllegalArgumentException(
+                            String.format("Invalid field name: '%s' does not refer to a class.", names[i]));
+                }
+            }
+
+            // Check if last field name is a valid field
+            String columnName = names[names.length - 1];
+            long columnIndex = table.getColumnIndex(columnName);
+            columnIndices[names.length - 1] = columnIndex;
+            if (columnIndex == Table.NO_MATCH) {
+                throw new IllegalArgumentException(
+                        String.format("'%s' is not a field name in class '%s'.", columnName, table.getName()));
+            }
+
+            this.fieldType = table.getColumnType(columnIndex);
+            this.fieldName = columnName;
+            this.columnIndices = columnIndices;
+            this.searchIndex = table.hasSearchIndex(columnIndex);
+        } else {
+            long fieldIndex = table.getColumnIndex(fieldDescription);
+            if (fieldIndex == Table.NO_MATCH) {
+                throw new IllegalArgumentException(String.format("Field '%s' does not exist.", fieldDescription));
+            }
+            this.fieldType = table.getColumnType(fieldIndex);
+            this.fieldName = fieldDescription;
+            this.columnIndices = new long[] {fieldIndex};
+            this.searchIndex = table.hasSearchIndex(fieldIndex);
+        }
+    }
+
+    public long[] getColumnIndices() {
+        return Arrays.copyOf(columnIndices, columnIndices.length);
+    }
+
+    public RealmFieldType getFieldType() {
+        return fieldType;
+    }
+
+    public String getFieldName() {
+        return fieldName;
+    }
+
+    public boolean hasSearchIndex() {
+        return searchIndex;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java b/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java
deleted file mode 100644
index 029c91bc02..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/HandlerControllerConstants.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-/**
- * This class is to share some Android handler related constants between package {@link io.realm} and
- * {@link io.realm.internal.async}.
- */
-public final class HandlerControllerConstants {
-    public static final int REALM_CHANGED = 14930352; // Hopefully it won't clash with other message IDs.
-    public static final int COMPLETED_UPDATE_ASYNC_QUERIES = 24157817;
-    public static final int COMPLETED_ASYNC_REALM_RESULTS = 39088169;
-    public static final int COMPLETED_ASYNC_REALM_OBJECT = 63245986;
-    public static final int REALM_ASYNC_BACKGROUND_EXCEPTION = 102334155;
-    public static final int LOCAL_COMMIT = 165580141;
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
index a368e4193d..8079324ff4 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/LinkView.java
@@ -113,7 +113,7 @@ public void clear() {
 
     public boolean contains(long tableRowIndex) {
         long index = nativeFind(nativePtr, tableRowIndex);
-        return (index != TableOrView.NO_MATCH);
+        return (index != Table.NO_MATCH);
     }
 
     public long size() {
@@ -126,7 +126,7 @@ public boolean isEmpty() {
 
     public TableQuery where() {
         long nativeQueryPtr = nativeWhere(nativePtr);
-        return new TableQuery(this.context, this.parent, nativeQueryPtr);
+        return new TableQuery(this.context, this.getTargetTable(), nativeQueryPtr);
     }
 
     public boolean isAttached() {
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
index 651562b6d3..37ae3b752b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObjectServerFacade.java
@@ -33,7 +33,7 @@
     static {
         //noinspection TryWithIdenticalCatches
         try {
-            Class syncFacadeClass = Class.forName("io.realm.internal.objectserver.SyncObjectServerFacade");
+            Class syncFacadeClass = Class.forName("io.realm.internal.SyncObjectServerFacade");
             syncFacade = (ObjectServerFacade) syncFacadeClass.newInstance();
         } catch (ClassNotFoundException ignored) {
         } catch (InstantiationException e) {
@@ -51,25 +51,13 @@ public void init(Context context) {
     }
 
     /**
-     * Notifies the session for this configuration that a local commit was made.
-     */
-    public void notifyCommit(RealmConfiguration configuration, long lastSnapshotVersion) {
-    }
-
-    /**
-     * The first instance of this Realm was opened.
+     * The last instance of this Realm was closed (across all Threads).
      */
     public void realmClosed(RealmConfiguration configuration) {
     }
 
-    /**
-     * The last instance of this Realm was closed.
-     */
-    public void realmOpened(RealmConfiguration configuration) {
-    }
-
     public String[] getUserAndServerUrl(RealmConfiguration config) {
-        return new String[2];
+        return new String[4];
     }
 
     public static ObjectServerFacade getFacade(boolean needSyncFacade) {
@@ -86,4 +74,8 @@ public static ObjectServerFacade getSyncFacadeIfPossible() {
         }
         return nonSyncFacade;
     }
+
+    // If no session yet exists for this path. Wrap a new Java Session around an existing OS one.
+    public void wrapObjectStoreSessionIfRequired(RealmConfiguration config) {
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
new file mode 100644
index 0000000000..aeb5f8cb0b
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/ObserverPairList.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+
+import java.lang.ref.WeakReference;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+/**
+ * An ObserverPairList holds a list of ObserverPairs. An {@link ObserverPair} is pair containing an observer and a
+ * listener. The observer is the object to react to the changes through the listener. The observer is saved as a weak
+ * reference in the pair to control the life cycle of the listener. When the observer gets GCed, the corresponding pair
+ * will be removed from the list. So DO NOT keep a strong reference to the observer in the subclass of listener since it
+ * will cause leaks!
+ * <p>
+ * This class is not thread safe and it is not supposed to be.
+ *
+ * @param <T> the type of {@link ObserverPair}.
+ */
+class ObserverPairList<T extends ObserverPairList.ObserverPair> {
+
+    /**
+     * @param <T> the type of observer.
+     * @param <S> the type of listener.
+     */
+    abstract static class ObserverPair<T, S> {
+        final WeakReference<T> observerRef;
+        protected final S listener;
+        // Should only be set by the outer class. To marked it as removed in case it is removed in foreach callback.
+        boolean removed = false;
+
+        ObserverPair(T observer, S listener) {
+            this.listener = listener;
+            this.observerRef = new WeakReference<T>(observer);
+        }
+
+        // The two pairs will be treated as the same only when the observers are the same and the listeners are equal.
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+
+            if (obj instanceof ObserverPair) {
+                ObserverPair anotherPair = (ObserverPair) obj;
+                return listener.equals(anotherPair.listener) &&
+                        observerRef.get() == anotherPair.observerRef.get();
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            T observer = observerRef.get();
+
+            int result = 17;
+            result = 31 * result + ((observer != null) ? observer.hashCode() : 0);
+            result = 31 * result + ((listener != null) ? listener.hashCode() : 0);
+            return result;
+        }
+    }
+
+    /**
+     * Callback passed to the {@link #foreach(Callback)} call.
+     *
+     * @param <T> type of ObserverPair.
+     */
+    interface Callback<T extends ObserverPair> {
+        void onCalled(T pair, Object observer);
+    }
+
+    private List<T> pairs = new CopyOnWriteArrayList<T>();
+    // In case the clear() called during the foreach loop.
+    private boolean cleared = false;
+
+    /**
+     * Iterate every valid pair in the list and call the callback on it. The pair with GCed observer will be removed and
+     * callback won't be executed. Before executing the callback, a strong reference to the observer will be kept and
+     * passed to the callback in case the observer gets GCed before callback returns.
+     *
+     * @param callback to be executed on the pair.
+     */
+    void foreach(Callback<T> callback) {
+        for (T pair : pairs) {
+            if (cleared) {
+                break;
+            } else {
+                Object observer = pair.observerRef.get();
+                if (observer == null) {
+                    pairs.remove(pair);
+                } else if (!pair.removed) {
+                    callback.onCalled(pair, observer);
+                }
+            }
+        }
+    }
+
+    public boolean isEmpty() {
+        return pairs.isEmpty();
+    }
+
+    public void clear() {
+        cleared = true;
+        pairs.clear();
+    }
+
+    public void add(T pair) {
+        if (!pairs.contains(pair)) {
+            pairs.add(pair);
+            pair.removed = false;
+        }
+        if (cleared) {
+            cleared = false;
+        }
+    }
+
+    public <S, U> void remove(S observer, U listener) {
+        for (T pair : pairs) {
+            if (observer == pair.observerRef.get() && listener.equals(pair.listener)) {
+                pair.removed = true;
+                pairs.remove(pair);
+                break;
+            }
+        }
+    }
+
+    void removeByObserver(Object observer) {
+        for (T pair : pairs) {
+            Object object = pair.observerRef.get();
+            if (object == null || object == observer) {
+                pair.removed = true;
+                pairs.remove(pair);
+            }
+        }
+    }
+
+    public int size() {
+        return pairs.size();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
new file mode 100644
index 0000000000..8370b03aa2
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/PendingRow.java
@@ -0,0 +1,245 @@
+package io.realm.internal;
+
+import java.lang.ref.WeakReference;
+import java.util.Date;
+
+import io.realm.RealmChangeListener;
+import io.realm.RealmFieldType;
+
+/**
+ * A PendingRow is a row relies on a pending async query.
+ * Before the query returns, calling any accessors will immediately throw. In this case run {@link #executeQuery()} to
+ * get the queried row immediately. If the query results is empty, an {@link InvalidRow} will be returned.
+ * After the query returns, {@link FrontEnd#onQueryFinished(Row)} will be called to give the front end a chance to reset
+ * the row. If the async query returns an empty result, the query will be executed again later until a valid row is
+ * contained by the query results.
+ */
+public class PendingRow implements Row {
+
+    // Implement this interface to reset the PendingRow to a Row backed by real data when query returned.
+    public interface FrontEnd {
+        // When asyncQuery is true, the pending query is executed asynchronously.
+        void onQueryFinished(Row row);
+    }
+
+    private static final String QUERY_NOT_RETURNED_MESSAGE =
+            "The pending query has not been executed.";
+    private static final String PROXY_NOT_SET_MESSAGE = "The 'frontEnd' has not been set.";
+    private static final String QUERY_EXECUTED_MESSAGE =
+            "The query has been executed. This 'PendingRow' is not valid anymore.";
+
+    private Collection pendingCollection;
+    private RealmChangeListener<PendingRow> listener;
+    private WeakReference<FrontEnd> frontEndRef;
+    private boolean returnCheckedRow;
+
+    public PendingRow(SharedRealm sharedRealm, TableQuery query, SortDescriptor sortDescriptor,
+                      final boolean returnCheckedRow) {
+        pendingCollection = new Collection(sharedRealm, query, sortDescriptor, null);
+
+        listener = new RealmChangeListener<PendingRow>() {
+            @Override
+            public void onChange(PendingRow pendingRow) {
+                if (frontEndRef == null) {
+                    throw new IllegalStateException(PROXY_NOT_SET_MESSAGE);
+                }
+                FrontEnd frontEnd = frontEndRef.get();
+                if (frontEnd == null) {
+                    // The front end is GCed.
+                    clearPendingCollection();
+                    return;
+                }
+
+                if (pendingCollection.isValid()) {
+                    // PendingRow will always get the first Row of the query since we only support findFirst.
+                    UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
+                    // If no rows returned by the query, just wait for the query updates until it returns a valid row.
+                    if (uncheckedRow != null) {
+                        Row row = returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
+                        // Ask the front end to reset the row and stop async query.
+                        frontEnd.onQueryFinished(row);
+                        clearPendingCollection();
+                    }
+                } else {
+                    // The Realm is closed. Do nothing then.
+                    clearPendingCollection();
+                }
+            }
+        };
+        pendingCollection.addListener(this, listener);
+        this.returnCheckedRow = returnCheckedRow;
+    }
+
+    // To set the front end of this PendingRow.
+    public void setFrontEnd(FrontEnd frontEnd) {
+        this.frontEndRef = new WeakReference<FrontEnd>(frontEnd);
+    }
+
+    @Override
+    public long getColumnCount() {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public String getColumnName(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public long getColumnIndex(String columnName) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public RealmFieldType getColumnType(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public Table getTable() {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public long getIndex() {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public long getLong(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public boolean getBoolean(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public float getFloat(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public double getDouble(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public Date getDate(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public String getString(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public byte[] getBinaryByteArray(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public long getLink(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public boolean isNullLink(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public LinkView getLinkList(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setLong(long columnIndex, long value) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setBoolean(long columnIndex, boolean value) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setFloat(long columnIndex, float value) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setDouble(long columnIndex, double value) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setDate(long columnIndex, Date date) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setString(long columnIndex, String value) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setBinaryByteArray(long columnIndex, byte[] data) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setLink(long columnIndex, long value) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void nullifyLink(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public boolean isNull(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public void setNull(long columnIndex) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    @Override
+    public boolean isAttached() {
+        return false;
+    }
+
+    @Override
+    public boolean hasColumn(String fieldName) {
+        throw new IllegalStateException(QUERY_NOT_RETURNED_MESSAGE);
+    }
+
+    private void clearPendingCollection() {
+        pendingCollection.removeListener(this, listener);
+        pendingCollection = null;
+        listener = null;
+    }
+
+    public Row executeQuery() {
+        if (pendingCollection == null) {
+            throw new IllegalStateException(QUERY_EXECUTED_MESSAGE);
+        }
+        if (frontEndRef == null) {
+            throw new IllegalStateException(PROXY_NOT_SET_MESSAGE);
+        }
+
+        UncheckedRow uncheckedRow = pendingCollection.firstUncheckedRow();
+        clearPendingCollection();
+
+        if (uncheckedRow == null) {
+            return InvalidRow.INSTANCE;
+        }
+        return returnCheckedRow ? CheckedRow.getFromRow(uncheckedRow) : uncheckedRow;
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
index aaf97b6b5d..74726c5a05 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmNotifier.java
@@ -16,50 +16,142 @@
 
 package io.realm.internal;
 
-import io.realm.internal.async.QueryUpdateTask;
+import java.io.Closeable;
+import java.util.ArrayList;
+import java.util.List;
+
+import io.realm.RealmChangeListener;
 
 /**
  * This interface needs to be implemented by Java and pass to Realm Object Store in order to get notifications when
  * other thread/process changes the Realm file.
  */
 @Keep
-public interface RealmNotifier {
-    /**
-     * This is called from Java when the changes have been made on the same thread.
-     */
-    void notifyCommitByLocalThread();
+public abstract class RealmNotifier implements Closeable {
 
-    /**
-     * This is called in Realm Object Store's JavaBindingContext::changes_available.
-     * This is getting called on the same thread which created this Realm when the same Realm file has been changed by
-     * other thread. The changes on the same thread should not trigger this call.
-     */
+// Calling sequences for a remote commit
+// |-------------------------------+--------------+-----------------------------------|
+// | Thread A                      | Thread B     | Daemon Thread                     |
+// |-------------------------------+--------------+-----------------------------------|
+// |                               | Make changes |                                   |
+// |-------------------------------+--------------+-----------------------------------|
+// |                               |              | epoll callback and notify ALooper |
+// |-------------------------------+--------------+-----------------------------------|
+// | ALooper callback              |              |                                   |
+// | BindingContext::before_notify |              |                                   |
+// | RealmNotifier.beforeNotify    |              |                                   |
+// | BindingContext::did_change    |              |                                   |
+// | RealmNotifier.didChange       |              |                                   |
+// | process_available_async       |              |                                   |
+// | Collection listeners          |              |                                   |
+// |-------------------------------+--------------+-----------------------------------|
+
+    private static class RealmObserverPair<T> extends ObserverPairList.ObserverPair<T, RealmChangeListener<T>> {
+        public RealmObserverPair(T observer, RealmChangeListener<T> listener) {
+            super(observer, listener);
+        }
+
+        private void onChange(T observer) {
+            if (observer != null) {
+                listener.onChange(observer);
+            }
+        }
+    }
+
+    private ObserverPairList<RealmObserverPair> realmObserverPairs = new ObserverPairList<RealmObserverPair>();
+    private final ObserverPairList.Callback<RealmObserverPair> onChangeCallBack =
+            new ObserverPairList.Callback<RealmObserverPair>() {
+                @Override
+                public void onCalled(RealmObserverPair pair, Object observer) {
+                    //noinspection unchecked
+                    if (sharedRealm != null && !sharedRealm.isClosed()) {
+                        pair.onChange(observer);
+                    }
+                }
+            };
+
+    protected RealmNotifier(SharedRealm sharedRealm) {
+        this.sharedRealm = sharedRealm;
+    }
+
+    private SharedRealm sharedRealm;
+    // TODO: The only reason we have this is that async transactions is not supported by OS yet. And OS is using ALopper
+    // which will be using a different message queue from which java is using to deliver remote Realm changes message.
+    // We need a way to deliver the async transaction onSuccess callback to the caller thread after the caller Realm
+    // advanced. This is implemented by posting the callback by RealmNotifier.post() first, and check the realm version
+    // in the posted Runnable. If the Realm version there is still behind the async transaction we committed, the
+    // onSuccess callback will be added to this list and be executed later when we get the change event from OS.
+    // This list is NOT supposed to be thread safe!
+    private List<Runnable> transactionCallbacks = new ArrayList<Runnable>();
+
+
+    // Called from JavaBindingContext::did_change.
+    // This will be called in the caller thread when:
+    // - A committed remote transaction, called from changed event handler.
+    // - A committed remote transaction, called directly from refresh call.
+    // - A committed local transaction, called directly from commitTransaction instead of next event.
+    //   loop.
+    // Package protected to avoid finding class by name in JNI.
     @SuppressWarnings("unused") // called from java_binding_context.cpp
-    void notifyCommitByOtherThread();
+    void didChange() {
+        realmObserverPairs.foreach(onChangeCallBack);
+        for (Runnable runnable : transactionCallbacks) {
+            runnable.run();
+        }
+        transactionCallbacks.clear();
+    }
+
+    // Called from JavaBindingContext::before_notify.
+    // This will be called in the caller thread when:
+    // 1. Get changed notification by this/other Realm instances.
+    // 2. SharedRealm::refresh called.
+    // In both cases, this will be called before the any other callbacks (changed callbacks, async query callbacks.).
+    // Package protected to avoid finding class by name in JNI.
+    @SuppressWarnings("unused")
+    void beforeNotify() {
+        // For the stable iteration.
+        sharedRealm.invalidateIterators();
+    }
 
     /**
-     * Post a runnable to be run in the next event loop on the thread which creates the corresponding Realm.
-     *
-     * @param runnable to be posted.
+     * Called when close SharedRealm to clean up any event left in to queue.
      */
-    void post(Runnable runnable);
+    @Override
+    public void close() {
+        removeAllChangeListeners();
+    }
+
+    public <T> void addChangeListener(T observer, RealmChangeListener<T> realmChangeListener) {
+        RealmObserverPair observerPair = new RealmObserverPair<T>(observer, realmChangeListener);
+        realmObserverPairs.add(observerPair);
+    }
+
+    public <E> void removeChangeListener(E observer, RealmChangeListener<E> realmChangeListener) {
+        realmObserverPairs.remove(observer, realmChangeListener);
+    }
+
+    public <E> void removeChangeListeners(E observer) {
+       realmObserverPairs.removeByObserver(observer);
+    }
+
+    // Since RealmObject is using this notifier as well, use removeChangeListeners to remove all listeners by the given
+    // observer.
+    private void removeAllChangeListeners() {
+        realmObserverPairs.clear();
+    }
+
+    public void addTransactionCallback(Runnable runnable) {
+        transactionCallbacks.add(runnable);
+    }
 
     /**
-     * Is the current notifier valid? eg. Notifier created on non-looper thread cannot be notified.
+     * For current implementation of async transaction only. See comments for {@link #transactionCallbacks}.
      *
-     * @return {@code true} if the thread which owns this notifier can be notified. Otherwise {@code false}
+     * @param runnable to be executed in the following event loop.
      */
-    boolean isValid();
+    public abstract boolean post(Runnable runnable);
 
-    /**
-     * Called when close SharedRealm to clean up any event left in to queue.
-     */
-    void close();
-
-    // FIXME: These are for decoupling handler from async query. Async query needs refactor to either adapt the OS or
-    //        abstract the logic from Android handlers.
-    void completeAsyncResults(QueryUpdateTask.Result result);
-    void completeAsyncObject(QueryUpdateTask.Result result);
-    void throwBackgroundException(Throwable throwable);
-    void completeUpdateAsyncQueries(QueryUpdateTask.Result result);
+    public int getListenersListSize() {
+        return realmObserverPairs.size();
+    }
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java b/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java
index 69a4b2d71e..ee7c43f962 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/RealmObjectProxy.java
@@ -25,6 +25,7 @@
  * Ideally all the static methods was also present here, but that is not supported before Java 8.
  */
  public interface RealmObjectProxy extends RealmModel {
+    void realm$injectObjectContext();
     ProxyState realmGet$proxyState();
     /**
      * Tuple class for saving meta data about a cached RealmObject.
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Row.java b/realm/realm-library/src/main/java/io/realm/internal/Row.java
index 023e923bff..c4db3d31b5 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Row.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Row.java
@@ -22,6 +22,12 @@
 
 /**
  * Interface for Row objects that act as wrappers around the Realm Core Row object.
+ * <p>
+ * When the actual class which implements this interface is {@link CheckedRow}, all methods in this
+ * interface always validate their parameters and throw an appropriate exception if invalid.
+ * For example, methods which accept a column name check the existence of the column and throw
+ * {@link IllegalArgumentException} if not found.
+ *
  */
 public interface Row {
 
@@ -111,154 +117,4 @@
      * @return {@code true} if field name exists, {@code false} otherwise.
      */
     boolean hasColumn(String fieldName);
-
-    Row EMPTY_ROW = new Row() {
-        private final static String UNLOADED_ROW_MESSAGE = "Can't access a row that hasn't been loaded or represents 'null', " +
-                "make sure the instance is loaded and is valid by calling 'RealmObject.isLoaded() && RealmObject.isValid()'.";
-
-        @Override
-        public long getColumnCount() {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public String getColumnName(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public long getColumnIndex(String columnName) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public RealmFieldType getColumnType(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public Table getTable() {
-            return null;
-        }
-
-        @Override
-        public long getIndex() {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public long getLong(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public boolean getBoolean(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public float getFloat(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public double getDouble(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public Date getDate(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public String getString(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public byte[] getBinaryByteArray(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public long getLink(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public boolean isNullLink(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public boolean isNull(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setNull(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public LinkView getLinkList(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setLong(long columnIndex, long value) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setBoolean(long columnIndex, boolean value) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setFloat(long columnIndex, float value) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setDouble(long columnIndex, double value) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setDate(long columnIndex, Date date) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setString(long columnIndex, String value) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setBinaryByteArray(long columnIndex, byte[] data) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void setLink(long columnIndex, long value) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public void nullifyLink(long columnIndex) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-
-        @Override
-        public boolean isAttached() {
-            return false;
-        }
-
-        @Override
-        public boolean hasColumn(String fieldName) {
-            throw new IllegalStateException(UNLOADED_ROW_MESSAGE);
-        }
-    };
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
index 5037f13d12..194d22ba27 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/SharedRealm.java
@@ -18,10 +18,15 @@
 
 import java.io.Closeable;
 import java.io.File;
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import io.realm.RealmConfiguration;
 import io.realm.RealmSchema;
-import io.realm.internal.async.BadVersionException;
+import io.realm.internal.android.AndroidCapabilities;
+import io.realm.internal.android.AndroidRealmNotifier;
 
 public final class SharedRealm implements Closeable, NativeObject {
 
@@ -104,7 +109,10 @@ public byte getNativeValue() {
 
     // JNI will only hold a weak global ref to this.
     public final RealmNotifier realmNotifier;
-    public final ObjectServerFacade objectServerFacade;
+    public final List<WeakReference<Collection>> collections = new CopyOnWriteArrayList<WeakReference<Collection>>();
+    public final Capabilities capabilities;
+    public final List<WeakReference<Collection.Iterator>> iterators =
+            new ArrayList<WeakReference<Collection.Iterator>>();
 
     public static class VersionID implements Comparable<VersionID> {
         public final long version;
@@ -169,55 +177,67 @@ public int hashCode() {
     private long lastSchemaVersion;
     private final SchemaVersionListener schemaChangeListener;
 
-    private SharedRealm(long nativePtr, RealmConfiguration configuration, RealmNotifier notifier,
+    private SharedRealm(long nativeConfigPtr,
+                        RealmConfiguration configuration,
                         SchemaVersionListener schemaVersionListener) {
-        this.nativePtr = nativePtr;
+        Capabilities capabilities = new AndroidCapabilities();
+        RealmNotifier realmNotifier = new AndroidRealmNotifier(this, capabilities);
+
+        this.nativePtr = nativeGetSharedRealm(nativeConfigPtr, realmNotifier);
         this.configuration = configuration;
-        this.realmNotifier = notifier;
+
+        this.capabilities = capabilities;
+        this.realmNotifier = realmNotifier;
         this.schemaChangeListener = schemaVersionListener;
         context = new Context();
         context.addReference(this);
         this.lastSchemaVersion = schemaVersionListener == null ? -1L : getSchemaVersion();
-        objectServerFacade = null;
+        nativeSetAutoRefresh(nativePtr, capabilities.canDeliverNotification());
     }
 
     // This will create a SharedRealm where autoChangeNotifications is false,
     // If autoChangeNotifications is true, an additional SharedGroup might be created in the OS's external commit helper.
     // That is not needed for some cases: eg.: An extra opened SharedGroup will cause a compact failure.
     public static SharedRealm getInstance(RealmConfiguration config) {
-        return getInstance(config, null, null, false);
+        return getInstance(config, null, false);
     }
 
-    public static SharedRealm getInstance(RealmConfiguration config, RealmNotifier realmNotifier,
-                                          SchemaVersionListener schemaVersionListener, boolean autoChangeNotifications) {
-        String[] userAndServer = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(config);
-        String rosServerUrl = userAndServer[0];
-        String rosUserToken = userAndServer[1];
+
+    public static SharedRealm getInstance(RealmConfiguration config, SchemaVersionListener schemaVersionListener,
+                                          boolean autoChangeNotifications) {
+        String[] syncUserConf = ObjectServerFacade.getSyncFacadeIfPossible().getUserAndServerUrl(config);
+        String syncUserIdentifier = syncUserConf[0];
+        String syncRealmUrl = syncUserConf[1];
+        String syncRealmAuthUrl = syncUserConf[2];
+        String syncRefreshToken = syncUserConf[3];
         boolean enable_caching = false; // Handled in Java currently
         boolean disableFormatUpgrade = false; // TODO Double negatives :/
+
         long nativeConfigPtr = nativeCreateConfig(
                 config.getPath(),
                 config.getEncryptionKey(),
-                rosServerUrl != null ? SchemaMode.SCHEMA_MODE_ADDITIVE.getNativeValue() : SchemaMode.SCHEMA_MODE_MANUAL.getNativeValue(),
+                syncRealmUrl != null ? SchemaMode.SCHEMA_MODE_ADDITIVE.getNativeValue() : SchemaMode.SCHEMA_MODE_MANUAL.getNativeValue(),
                 config.getDurability() == Durability.MEM_ONLY,
                 enable_caching,
                 config.getSchemaVersion(),
                 disableFormatUpgrade,
                 autoChangeNotifications,
-                rosServerUrl,
-                rosUserToken);
+                syncRealmUrl,
+                syncRealmAuthUrl,
+                syncUserIdentifier,
+                syncRefreshToken);
+
         try {
-            return new SharedRealm(
-                    nativeGetSharedRealm(nativeConfigPtr, realmNotifier),
-                    config,
-                    realmNotifier,
-                    schemaVersionListener);
+            ObjectServerFacade.getSyncFacadeIfPossible().wrapObjectStoreSessionIfRequired(config);
+
+            return new SharedRealm(nativeConfigPtr, config, schemaVersionListener);
         } finally {
             nativeCloseConfig(nativeConfigPtr);
         }
     }
 
     public void beginTransaction() {
+        detachIterators();
         nativeBeginTransaction(nativePtr);
         invokeSchemaChangeListenerIfSchemaChanged();
     }
@@ -284,15 +304,6 @@ public void refresh() {
         invokeSchemaChangeListenerIfSchemaChanged();
     }
 
-    public void refresh(SharedRealm.VersionID version) throws BadVersionException {
-        // FIXME: This will have a different behaviour compared to refresh to the latest version.
-        // In the JNI this will just advance read the corresponding SharedGroup to the specific version without notifier
-        // or transact log observer involved. Before we use notification & fine grained notification from OS, it is not
-        // a problem.
-        nativeRefresh(nativePtr, version.version, version.index);
-        invokeSchemaChangeListenerIfSchemaChanged();
-    }
-
     public SharedRealm.VersionID getVersionID() {
         long[] versionId = nativeGetVersionID (nativePtr);
         return new SharedRealm.VersionID(versionId[0], versionId[1]);
@@ -333,6 +344,15 @@ public void updateSchema(RealmSchema schema, long version) {
         nativeUpdateSchema(nativePtr, schema.getNativePtr(), version);
     }
 
+    public void setAutoRefresh(boolean enabled) {
+        capabilities.checkCanDeliverNotification(null);
+        nativeSetAutoRefresh(nativePtr, enabled);
+    }
+
+    public boolean isAutoRefresh() {
+        return nativeIsAutoRefresh(nativePtr);
+    }
+
     public boolean requiresMigration(RealmSchema schema) {
         return nativeRequiresMigration(nativePtr, schema.getNativePtr());
     }
@@ -375,11 +395,45 @@ public void invokeSchemaChangeListenerIfSchemaChanged() {
         }
     }
 
+    // addIterator(), detachIterators() and invalidateIterators() are used to make RealmResults stable iterators work.
+    // The iterator will iterate on a snapshot Results if it is accessed inside a transaction.
+    // See https://github.com/realm/realm-java/issues/3883 for more information.
+    // Should only be called by Iterator's constructor.
+    void addIterator(Collection.Iterator iterator) {
+        iterators.add(new WeakReference<Collection.Iterator>(iterator));
+    }
+
+    // The detaching should happen before transaction begins.
+    void detachIterators() {
+        for (WeakReference<Collection.Iterator> iteratorRef : iterators) {
+            Collection.Iterator iterator = iteratorRef.get();
+            if (iterator != null) {
+                iterator.detach();
+            }
+        }
+        iterators.clear();
+    }
+
+    // Invalidates all iterators when a remote change notification is received.
+    void invalidateIterators() {
+        for (WeakReference<Collection.Iterator> iteratorRef : iterators) {
+            Collection.Iterator iterator = iteratorRef.get();
+            if (iterator != null) {
+                iterator.invalidate();
+            }
+        }
+        iterators.clear();
+    }
+
     private static native void nativeInit(String temporaryDirectoryPath);
+    // Keep last session as an 'object' to avoid any reference to sync code
     private static native long nativeCreateConfig(String realmPath, byte[] key, byte schemaMode, boolean inMemory,
                                                   boolean cache, long schemaVersion, boolean disableFormatUpgrade,
                                                   boolean autoChangeNotification,
-                                                  String syncServerURL, String syncUserToken);
+                                                  String syncServerURL,
+                                                  String syncServerAuthURL,
+                                                  String syncUserIdentity,
+                                                  String syncRefreshToken);
     private static native void nativeCloseConfig(long nativeConfigPtr);
     private static native long nativeGetSharedRealm(long nativeConfigPtr, RealmNotifier notifier);
     private static native void nativeCloseSharedRealm(long nativeSharedRealmPtr);
@@ -394,7 +448,6 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
     private static native long nativeReadGroup(long nativeSharedRealmPtr);
     private static native boolean nativeIsEmpty(long nativeSharedRealmPtr);
     private static native void nativeRefresh(long nativeSharedRealmPtr);
-    private static native void nativeRefresh(long nativeSharedRealmPtr, long version, long index);
     private static native long[]  nativeGetVersionID(long nativeSharedRealmPtr);
     private static native long nativeGetTable(long nativeSharedRealmPtr, String tableName);
     private static native String nativeGetTableName(long nativeSharedRealmPtr, int index);
@@ -407,6 +460,8 @@ private static native long nativeCreateConfig(String realmPath, byte[] key, byte
     private static native void nativeStopWaitForChange(long nativeSharedRealmPtr);
     private static native boolean nativeCompact(long nativeSharedRealmPtr);
     private static native void nativeUpdateSchema(long nativePtr, long nativeSchemaPtr, long version);
+    private static native void nativeSetAutoRefresh(long nativePtr, boolean enabled);
+    private static native boolean nativeIsAutoRefresh(long nativePtr);
     private static native boolean nativeRequiresMigration(long nativePtr, long nativeSchemaPtr);
     private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
new file mode 100644
index 0000000000..3d6b6cfc21
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/SortDescriptor.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package io.realm.internal;
+
+import java.util.Arrays;
+import java.util.List;
+
+import io.realm.RealmFieldType;
+import io.realm.Sort;
+
+/**
+ * Java class to present the same name core class in Java. This can be converted to a cpp realm::SortDescriptor object
+ * through realm::_impl::JavaSortDescriptor.
+ * <p>
+ * NOTE: Since the column indices are determined when constructing the object with the given table's status, the indices
+ * could be wrong when schema changes. Always create and consume the instance when needed, DON'T store a SortDescriptor
+ * and use it whenever the ShareGroup can be in different versions.
+ */
+@KeepMember
+public class SortDescriptor {
+
+    private final long[][] columnIndices;
+    private final boolean[] ascendings;
+    private final Table table;
+
+    final static List<RealmFieldType> validFieldTypesForSort = Arrays.asList(
+            RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.FLOAT, RealmFieldType.DOUBLE,
+            RealmFieldType.STRING, RealmFieldType.DATE);
+    final static List<RealmFieldType> validFieldTypesForDistinct = Arrays.asList(
+            RealmFieldType.BOOLEAN, RealmFieldType.INTEGER, RealmFieldType.STRING, RealmFieldType.DATE);
+
+    // Internal use only. For JNI testing.
+    SortDescriptor(Table table, long[] columnIndices) {
+        this(table, new long[][] {columnIndices}, null);
+    }
+
+    private SortDescriptor(Table table, long[][] columnIndices, Sort[] sortOrders) {
+        if (sortOrders != null) {
+            ascendings = new boolean[sortOrders.length];
+            for (int i = 0; i < sortOrders.length; i++) {
+                ascendings[i] = sortOrders[i].getValue();
+            }
+        } else {
+            ascendings = null;
+        }
+
+        this.columnIndices = columnIndices;
+        this.table = table;
+    }
+
+    public static SortDescriptor getInstanceForSort(Table table, String fieldDescription, Sort sortOrder) {
+        return getInstanceForSort(table, new String[] {fieldDescription}, new Sort[] {sortOrder});
+    }
+
+    public static SortDescriptor getInstanceForSort(Table table, String[] fieldDescriptions, Sort[] sortOrders) {
+        if (fieldDescriptions == null || fieldDescriptions.length == 0) {
+            throw new IllegalArgumentException("You must provide at least one field name.");
+        }
+        if (sortOrders == null || sortOrders.length == 0) {
+            throw new IllegalArgumentException("You must provide at least one sort order.");
+        }
+        if (fieldDescriptions.length != sortOrders.length) {
+            throw new IllegalArgumentException("Number of fields and sort orders do not match.");
+        }
+
+        long[][] columnIndices = new long[fieldDescriptions.length][];
+        for (int i = 0; i < fieldDescriptions.length; i++) {
+            FieldDescriptor descriptor = new FieldDescriptor(table, fieldDescriptions[i], true, false);
+            checkFieldTypeForSort(descriptor, fieldDescriptions[i]);
+            columnIndices[i] = descriptor.getColumnIndices();
+        }
+
+        return new SortDescriptor(table, columnIndices, sortOrders);
+    }
+
+    public static SortDescriptor getInstanceForDistinct(Table table, String fieldDescription) {
+        return getInstanceForDistinct(table, new String[] {fieldDescription});
+    }
+
+    public static SortDescriptor getInstanceForDistinct(Table table, String[] fieldDescriptions) {
+        if (fieldDescriptions == null || fieldDescriptions.length == 0) {
+            throw new IllegalArgumentException("You must provide at least one field name.");
+        }
+
+        long[][] columnIndices = new long[fieldDescriptions.length][];
+        for (int i = 0; i < fieldDescriptions.length; i++) {
+            FieldDescriptor descriptor = new FieldDescriptor(table, fieldDescriptions[i], false, false);
+            checkFieldTypeForDistinct(descriptor, fieldDescriptions[i]);
+            columnIndices[i] = descriptor.getColumnIndices();
+        }
+
+        return new SortDescriptor(table, columnIndices, null);
+    }
+
+    private static void checkFieldTypeForSort(FieldDescriptor descriptor, String fieldDescriptions) {
+        if (!validFieldTypesForSort.contains(descriptor.getFieldType())) {
+            throw new IllegalArgumentException(String.format(
+                    "Sort is not supported on '%s' field '%s' in '%s'.", descriptor.toString(), descriptor.getFieldName(),
+                    fieldDescriptions));
+        }
+    }
+
+    private static void checkFieldTypeForDistinct(FieldDescriptor descriptor, String fieldDescriptions) {
+        if (!validFieldTypesForDistinct.contains(descriptor.getFieldType())) {
+            throw new IllegalArgumentException(String.format(
+                    "Distinct is not supported on '%s' field '%s' in '%s'.",
+                    descriptor.getFieldType().toString(), descriptor.getFieldName(), fieldDescriptions));
+        }
+        if (!descriptor.hasSearchIndex()) {
+            throw new IllegalArgumentException(String.format(
+                    "Field '%s' in '%s' must be indexed in order to use it for distinct queries.",
+                    descriptor.getFieldName(), fieldDescriptions));
+        }
+    }
+
+    // Called by JNI.
+    @KeepMember
+    long[][] getColumnIndices() {
+        return columnIndices;
+    }
+
+    // Called by JNI.
+    @KeepMember
+    boolean[] getAscendings() {
+        return ascendings;
+    }
+
+    // Called by JNI.
+    @KeepMember
+    @SuppressWarnings("unused")
+    private long getTablePtr() {
+       return table.getNativePtr();
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/Table.java b/realm/realm-library/src/main/java/io/realm/internal/Table.java
index e518baf8ca..a5b0b5c35c 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/Table.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/Table.java
@@ -28,13 +28,28 @@
  * (define/insert/delete/update) a table has. All the native communications to the Realm C++ library are also handled by
  * this class.
  */
-public class Table implements TableOrView, TableSchema, NativeObject {
+public class Table implements TableSchema, NativeObject {
+
+    enum PivotType {
+        COUNT(0),
+        SUM(1),
+        AVG(2),
+        MIN(3),
+        MAX(4);
+
+        final int value; // Package protected, accessible from Table
+
+        PivotType(int value) {
+            this.value = value;
+        }
+    }
 
     public static final int TABLE_MAX_LENGTH = 56; // Max length of class names without prefix
     public static final String TABLE_PREFIX = Util.getTablePrefix();
     public static final long INFINITE = -1;
     public static final boolean NULLABLE = true;
     public static final boolean NOT_NULLABLE = false;
+    public static final int NO_MATCH = -1;
 
     private static final String PRIMARY_KEY_TABLE_NAME = "pk";
     private static final String PRIMARY_KEY_CLASS_COLUMN_NAME = "pk_table";
@@ -43,9 +58,9 @@
     private static final long PRIMARY_KEY_FIELD_COLUMN_INDEX = 1;
     private static final long NO_PRIMARY_KEY = -2;
 
-    protected long nativePtr;
+    private long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-    private final Context context;
+    final Context context;
     private final SharedRealm sharedRealm;
     private long cachedPrimaryKeyColumnIndex = NO_MATCH;
 
@@ -87,7 +102,6 @@ public long getNativeFinalizerPtr() {
         return nativeFinalizerPtr;
     }
 
-    @Override
     public Table getTable() {
         return this;
     }
@@ -263,7 +277,6 @@ public void convertColumnToNotNullable(long columnIndex) {
      *
      * @return the number of rows.
      */
-    @Override
     public long size() {
         return nativeSize(nativePtr);
     }
@@ -273,7 +286,6 @@ public long size() {
      *
      * @return {@code true} if empty, otherwise {@code false}.
      */
-    @Override
     public boolean isEmpty() {
         return size() == 0;
     }
@@ -281,7 +293,6 @@ public boolean isEmpty() {
     /**
      * Clears the table i.e., deleting all rows in the table.
      */
-    @Override
     public void clear() {
         checkImmutable();
         nativeClear(nativePtr);
@@ -293,7 +304,6 @@ public void clear() {
      *
      * @return the number of columns.
      */
-    @Override
     public long getColumnCount() {
         return nativeGetColumnCount(nativePtr);
     }
@@ -304,7 +314,6 @@ public long getColumnCount() {
      * @param columnIndex the column index.
      * @return the name of the column.
      */
-    @Override
     public String getColumnName(long columnIndex) {
         return nativeGetColumnName(nativePtr, columnIndex);
     }
@@ -315,7 +324,6 @@ public String getColumnName(long columnIndex) {
      * @param columnName column name.
      * @return the index, {@link #NO_MATCH} if not found.
      */
-    @Override
     public long getColumnIndex(String columnName) {
         if (columnName == null) {
             throw new IllegalArgumentException("Column name can not be null.");
@@ -329,7 +337,6 @@ public long getColumnIndex(String columnName) {
      * @param columnIndex index of the column.
      * @return the type of the particular column.
      */
-    @Override
     public RealmFieldType getColumnType(long columnIndex) {
         return RealmFieldType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
     }
@@ -341,19 +348,16 @@ public RealmFieldType getColumnType(long columnIndex) {
      * @param rowIndex the row index (starting with 0)
      *
      */
-    @Override
     public void remove(long rowIndex) {
         checkImmutable();
         nativeRemove(nativePtr, rowIndex);
     }
 
-    @Override
     public void removeFirst() {
         checkImmutable();
         remove(0);
     }
 
-    @Override
     public void removeLast() {
         checkImmutable();
         nativeRemoveLast(nativePtr);
@@ -621,7 +625,7 @@ public boolean hasPrimaryKey() {
     void checkStringValueIsLegal(long columnIndex, long rowToUpdate, String value) {
         if (isPrimaryKey(columnIndex)) {
             long rowIndex = findFirstString(columnIndex, value);
-            if (rowIndex != rowToUpdate && rowIndex != TableOrView.NO_MATCH) {
+            if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
                 throwDuplicatePrimaryKeyException(value);
             }
         }
@@ -630,7 +634,7 @@ void checkStringValueIsLegal(long columnIndex, long rowToUpdate, String value) {
     void checkIntValueIsLegal(long columnIndex, long rowToUpdate, long value) {
         if (isPrimaryKeyColumn(columnIndex)) {
             long rowIndex = findFirstLong(columnIndex, value);
-            if (rowIndex != rowToUpdate && rowIndex != TableOrView.NO_MATCH) {
+            if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
                 throwDuplicatePrimaryKeyException(value);
             }
         }
@@ -644,7 +648,7 @@ void checkDuplicatedNullForPrimaryKeyValue(long columnIndex, long rowToUpdate) {
                 case STRING:
                 case INTEGER:
                     long rowIndex = findFirstNull(columnIndex);
-                    if (rowIndex != rowToUpdate && rowIndex != TableOrView.NO_MATCH) {
+                    if (rowIndex != rowToUpdate && rowIndex != NO_MATCH) {
                         throwDuplicatePrimaryKeyException("null");
                     }
                     break;
@@ -669,27 +673,22 @@ public static void throwDuplicatePrimaryKeyException(Object value) {
     // Getters
     //
 
-    @Override
     public long getLong(long columnIndex, long rowIndex) {
         return nativeGetLong(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
     public boolean getBoolean(long columnIndex, long rowIndex) {
         return nativeGetBoolean(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
     public float getFloat(long columnIndex, long rowIndex) {
         return nativeGetFloat(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
     public double getDouble(long columnIndex, long rowIndex) {
         return nativeGetDouble(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
     public Date getDate(long columnIndex, long rowIndex) {
         return new Date(nativeGetTimestamp(nativePtr, columnIndex, rowIndex));
     }
@@ -701,17 +700,14 @@ public Date getDate(long columnIndex, long rowIndex) {
      * @param rowIndex 0 based index of the row.
      * @return value of the particular cell
      */
-    @Override
     public String getString(long columnIndex, long rowIndex) {
         return nativeGetString(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
     public byte[] getBinaryByteArray(long columnIndex, long rowIndex) {
         return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
     public long getLink(long columnIndex, long rowIndex) {
         return nativeGetLink(nativePtr, columnIndex, rowIndex);
     }
@@ -723,7 +719,6 @@ public Table getLinkTarget(long columnIndex) {
         return table;
     }
 
-    @Override
     public boolean isNull(long columnIndex, long rowIndex) {
         return nativeIsNull(nativePtr, columnIndex, rowIndex);
     }
@@ -767,32 +762,27 @@ public CheckedRow getCheckedRow(long index) {
     // Setters
     //
 
-    @Override
     public void setLong(long columnIndex, long rowIndex, long value, boolean isDefault) {
         checkImmutable();
         checkIntValueIsLegal(columnIndex, rowIndex, value);
         nativeSetLong(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
-    @Override
     public void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault) {
         checkImmutable();
         nativeSetBoolean(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
-    @Override
     public void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault) {
         checkImmutable();
         nativeSetFloat(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
-    @Override
     public void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault) {
         checkImmutable();
         nativeSetDouble(nativePtr, columnIndex, rowIndex, value, isDefault);
     }
 
-    @Override
     public void setDate(long columnIndex, long rowIndex, Date date, boolean isDefault) {
         if (date == null)
             throw new IllegalArgumentException("Null Date is not allowed.");
@@ -807,7 +797,6 @@ public void setDate(long columnIndex, long rowIndex, Date date, boolean isDefaul
      * @param rowIndex 0 based index value of the cell row.
      * @param value a String value to set in the cell.
      */
-    @Override
     public void setString(long columnIndex, long rowIndex, String value, boolean isDefault) {
         checkImmutable();
         if (value == null) {
@@ -819,13 +808,11 @@ public void setString(long columnIndex, long rowIndex, String value, boolean isD
         }
     }
 
-    @Override
     public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault) {
         checkImmutable();
         nativeSetByteArray(nativePtr, columnIndex, rowIndex, data, isDefault);
     }
 
-    @Override
     public void setLink(long columnIndex, long rowIndex, long value, boolean isDefault) {
         checkImmutable();
         nativeSetLink(nativePtr, columnIndex, rowIndex, value, isDefault);
@@ -921,12 +908,10 @@ public boolean hasSearchIndex(long columnIndex) {
         return nativeHasSearchIndex(nativePtr, columnIndex);
     }
 
-    @Override
     public boolean isNullLink(long columnIndex, long rowIndex) {
         return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
     }
 
-    @Override
     public void nullifyLink(long columnIndex, long rowIndex) {
         nativeNullifyLink(nativePtr, columnIndex, rowIndex);
     }
@@ -953,76 +938,62 @@ private void checkHasPrimaryKey() {
     //
 
     // Integers
-    @Override
     public long sumLong(long columnIndex) {
         return nativeSumInt(nativePtr, columnIndex);
     }
 
-    @Override
     public Long maximumLong(long columnIndex) {
         return nativeMaximumInt(nativePtr, columnIndex);
     }
 
-    @Override
     public Long minimumLong(long columnIndex) {
         return nativeMinimumInt(nativePtr, columnIndex);
     }
 
-    @Override
     public double averageLong(long columnIndex) {
         return nativeAverageInt(nativePtr, columnIndex);
     }
 
     // Floats
-    @Override
     public double sumFloat(long columnIndex) {
         return nativeSumFloat(nativePtr, columnIndex);
     }
 
-    @Override
     public Float maximumFloat(long columnIndex) {
         return nativeMaximumFloat(nativePtr, columnIndex);
     }
 
-    @Override
     public Float minimumFloat(long columnIndex) {
         return nativeMinimumFloat(nativePtr, columnIndex);
     }
 
-    @Override
     public double averageFloat(long columnIndex) {
         return nativeAverageFloat(nativePtr, columnIndex);
     }
 
     // Doubles
-    @Override
     public double sumDouble(long columnIndex) {
         return nativeSumDouble(nativePtr, columnIndex);
     }
 
-    @Override
     public Double maximumDouble(long columnIndex) {
         return nativeMaximumDouble(nativePtr, columnIndex);
     }
 
-    @Override
     public Double minimumDouble(long columnIndex) {
         return nativeMinimumDouble(nativePtr, columnIndex);
     }
 
-    @Override
     public double averageDouble(long columnIndex) {
         return nativeAverageDouble(nativePtr, columnIndex);
     }
 
     // Date aggregates
 
-    @Override
     public Date maximumDate(long columnIndex) {
         return new Date(nativeMaximumTimestamp(nativePtr, columnIndex));
     }
 
-    @Override
     public Date minimumDate(long columnIndex) {
         return new Date(nativeMinimumTimestamp(nativePtr, columnIndex));
     }
@@ -1043,7 +1014,6 @@ public long count(long columnIndex, double value) {
         return nativeCountDouble(nativePtr, columnIndex, value);
     }
 
-    @Override
     public long count(long columnIndex, String value) {
         return nativeCountString(nativePtr, columnIndex, value);
     }
@@ -1052,47 +1022,28 @@ public long count(long columnIndex, String value) {
     // Searching methods.
     //
 
-    @Override
     public TableQuery where() {
         long nativeQueryPtr = nativeWhere(nativePtr);
         // Copies context reference from parent.
         return new TableQuery(this.context, this, nativeQueryPtr);
     }
 
-    /**
-     * Returns the same rowIndex that is passed in via the {@code rowIndex}.
-     * This interface method allows for contains() usage in the {@link TableView} class.
-     * See {@link TableView#sourceRowIndex(long)} for more information.
-     *
-     * @param rowIndex the index of the row.
-     * @return the row index.
-     */
-    @Override
-    public long sourceRowIndex(long rowIndex) {
-        return rowIndex;
-    }
-
-    @Override
     public long findFirstLong(long columnIndex, long value) {
         return nativeFindFirstInt(nativePtr, columnIndex, value);
     }
 
-    @Override
     public long findFirstBoolean(long columnIndex, boolean value) {
         return nativeFindFirstBool(nativePtr, columnIndex, value);
     }
 
-    @Override
     public long findFirstFloat(long columnIndex, float value) {
         return nativeFindFirstFloat(nativePtr, columnIndex, value);
     }
 
-    @Override
     public long findFirstDouble(long columnIndex, double value) {
         return nativeFindFirstDouble(nativePtr, columnIndex, value);
     }
 
-    @Override
     public long findFirstDate(long columnIndex, Date date) {
         if (date == null) {
             throw new IllegalArgumentException("null is not supported");
@@ -1100,7 +1051,6 @@ public long findFirstDate(long columnIndex, Date date) {
         return nativeFindFirstTimestamp(nativePtr, columnIndex, date.getTime());
     }
 
-    @Override
     public long findFirstString(long columnIndex, String value) {
         if (value == null) {
             throw new IllegalArgumentException("null is not supported");
@@ -1118,47 +1068,14 @@ public long findFirstNull(long columnIndex) {
         return nativeFindFirstNull(nativePtr, columnIndex);
     }
 
-    @Override
-    public TableView findAllLong(long columnIndex, long value) {
-        long nativeViewPtr = nativeFindAllInt(nativePtr, columnIndex, value);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
-    @Override
-    public TableView findAllBoolean(long columnIndex, boolean value) {
-        long nativeViewPtr = nativeFindAllBool(nativePtr, columnIndex, value);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
-    @Override
-    public TableView findAllFloat(long columnIndex, float value) {
-        long nativeViewPtr = nativeFindAllFloat(nativePtr, columnIndex, value);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
-    @Override
-    public TableView findAllDouble(long columnIndex, double value) {
-        long nativeViewPtr = nativeFindAllDouble(nativePtr, columnIndex, value);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
-    @Override
-    public TableView findAllString(long columnIndex, String value) {
-        long nativeViewPtr = nativeFindAllString(nativePtr, columnIndex, value);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
     // Experimental feature
-    @Override
     public long lowerBoundLong(long columnIndex, long value) {
         return nativeLowerBoundInt(nativePtr, columnIndex, value);
     }
-    @Override
     public long upperBoundLong(long columnIndex, long value) {
         return nativeUpperBoundInt(nativePtr, columnIndex, value);
     }
 
-    @Override
     public Table pivot(long stringCol, long intCol, PivotType pivotType) {
         if (! this.getColumnType(stringCol).equals(RealmFieldType.STRING ))
             throw new UnsupportedOperationException("Group by column must be of type String");
@@ -1171,11 +1088,6 @@ public Table pivot(long stringCol, long intCol, PivotType pivotType) {
 
     //
 
-    public TableView getDistinctView(long columnIndex) {
-        long nativeViewPtr = nativeGetDistinctView(nativePtr, columnIndex);
-        return new TableView(this.context, this, nativeViewPtr);
-    }
-
     /**
      * Returns the table name as it is in the associated group.
      *
@@ -1185,12 +1097,10 @@ public String getName() {
         return nativeGetName(nativePtr);
     }
 
-    @Override
     public String toJson() {
         return nativeToJson(nativePtr);
     }
 
-    @Override
     public String toString() {
         long columnCount = getColumnCount();
         String name = getName();
@@ -1222,11 +1132,6 @@ public String toString() {
         return stringBuilder.toString();
     }
 
-    @Override
-    public long syncIfNeeded() {
-        throw new RuntimeException("Not supported for tables");
-    }
-
     private static void throwImmutable() {
         throw new IllegalStateException("Changing Realm data can only be done from inside a transaction.");
     }
@@ -1348,17 +1253,11 @@ public static String tableNameToClassName(String tableName) {
     private native long nativeFindFirstTimestamp(long nativeTablePtr, long columnIndex, long dateTimeValue);
     public static native long nativeFindFirstString(long nativeTablePtr, long columnIndex, String value);
     public static native long nativeFindFirstNull(long nativeTablePtr, long columnIndex);
-    private native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
-    private native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
-    private native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
-    private native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
     // FIXME: Disabled in cpp code, see comments there
     // private native long nativeFindAllTimestamp(long nativePtr, long columnIndex, long dateTimeValue);
-    private native long nativeFindAllString(long nativePtr, long columnIndex, String value);
     private native long nativeLowerBoundInt(long nativePtr, long columnIndex, long value);
     private native long nativeUpperBoundInt(long nativePtr, long columnIndex, long value);
     private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long resultPtr);
-    private native long nativeGetDistinctView(long nativePtr, long columnIndex);
     private native String nativeGetName(long nativeTablePtr);
     private native String nativeToJson(long nativeTablePtr);
     private native boolean nativeHasSameSchema(long thisTable, long otherTable);
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java b/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
deleted file mode 100644
index b9e6aa7a27..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/TableOrView.java
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.util.Date;
-
-import io.realm.Realm;
-import io.realm.RealmFieldType;
-
-/**
- * Specification of the common operations for the low-level table and view API.
- */
-public interface TableOrView {
-
-    int NO_MATCH = -1;
-
-    void clear();
-
-    /**
-     * Returns the table.
-     *
-     * @return
-     */
-    Table getTable();
-
-    /**
-     * Returns the number of entries of the table/view.
-     *
-     * @return
-     */
-    long size();
-
-    /**
-     * Checks whether the table/view is empty or not.
-     *
-     * @return {@code true} if empty, otherwise {@code false}.
-     */
-    boolean isEmpty();
-
-    /**
-     * Removes a particular row identified by the index from the table/view.
-     * [citation needed] The corresponding row of the table also gets deleted for which the table/view is part of.
-     *
-     * @param index
-     */
-    void remove(long index);
-
-    void removeLast();
-
-    long getColumnCount();
-
-    String getColumnName(long columnIndex);
-
-    long getColumnIndex(String name);
-
-    RealmFieldType getColumnType(long columnIndex);
-
-    /**
-     * Gets the long value of a cell of the table/view identified by the columnIndex and rowIndex.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @return
-     */
-    long getLong(long columnIndex, long rowIndex);
-
-    /**
-     * Gets the boolean value of a cell of the table identified by the columnIndex and rowIndex.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @return
-     */
-    boolean getBoolean(long columnIndex, long rowIndex);
-
-    /**
-     * Gets the float value of a cell of the table identified by the columnIndex and rowIndex.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @return
-     */
-    float getFloat(long columnIndex, long rowIndex);
-
-    /**
-     * Gets the double value of a cell of the table identified by the columnIndex and rowIndex.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @return
-     */
-    double getDouble(long columnIndex, long rowIndex);
-
-    /**
-     * Gets the string value of a cell identified by the columnIndex and rowIndex of the cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @return
-     */
-    String getString(long columnIndex, long rowIndex);
-
-    /**
-     * Returns the Date value (java.util.Date) for a particular cell specified by the columnIndex and rowIndex of the
-     * cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @return
-     */
-    Date getDate(long columnIndex, long rowIndex);
-
-    /**
-     * Returns the binary data for a cell identified by the columnIndex and rowIndex of that cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @return
-     */
-    byte[] getBinaryByteArray(long columnIndex, long rowIndex);
-
-    /**
-     * Gets the link index of a cell of the table/view identified by the columnIndex and rowIndex.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @return
-     */
-    long getLink(long columnIndex, long rowIndex);
-
-    /**
-     * Sets the long value for a particular cell identified by columnIndex and rowIndex of that cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @param value
-     */
-    void setLong(long columnIndex, long rowIndex, long value, boolean isDefault);
-
-    /**
-     * Sets the boolean value of a cell identified by the columnIndex and the rowIndex of that cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @param value
-     */
-    void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault);
-
-    /**
-     * Sets the float value of a cell identified by the columnIndex and the rowIndex of that cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @param value
-     */
-    void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault);
-
-    /**
-     * Sets the double value of a cell identified by the columnIndex and the rowIndex of that cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @param value
-     */
-    void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault);
-
-    /**
-     * Sets the string value of a particular cell of the table/view identified by the columnIndex and the rowIndex of
-     * this table/view
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @param value
-     */
-    void setString(long columnIndex, long rowIndex, String value, boolean isDefault);
-
-    /**
-     * Sets the binary value for a particular cell identified by the rowIndex and columnIndex of the cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @param data
-     * @param isDefault
-     */
-    void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault);
-
-    void setDate(long columnIndex, long rowIndex, Date date, boolean isDefault);
-
-    boolean isNullLink(long columnIndex, long rowIndex);
-
-    void nullifyLink(long columnIndex, long rowIndex);
-
-    /**
-     * Sets the link index for a particular cell identified by columnIndex and rowIndex of that cell.
-     *
-     * @param columnIndex
-     * @param rowIndex
-     * @param value
-     */
-    void setLink(long columnIndex, long rowIndex, long value, boolean isDefault);
-
-    void setNull(long columnIndex, long rowIndex, boolean isDefault);
-
-    boolean isNull(long columnIndex, long rowIndex);
-
-    long sumLong(long columnIndex);
-
-    Long maximumLong(long columnIndex);
-
-    Long minimumLong(long columnIndex);
-
-    double averageLong(long columnIndex);
-
-
-    double sumFloat(long columnIndex);
-
-    Float maximumFloat(long columnIndex);
-
-    Float minimumFloat(long columnIndex);
-
-    double averageFloat(long columnIndex);
-
-
-    double sumDouble(long columnIndex);
-
-    Double maximumDouble(long columnIndex);
-
-    Double minimumDouble(long columnIndex);
-
-    double averageDouble(long columnIndex);
-
-
-    Date maximumDate(long columnIndex);
-
-    Date minimumDate(long columnIndex);
-
-
-    /**
-     * Searches for first occurrence of a value. Beware that the order in the column is undefined.
-     *
-     * @param columnIndex the column to search in.
-     * @param value the value to search for.
-     * @return the row index for the first match found or {@link #NO_MATCH}.
-     */
-    long findFirstLong(long columnIndex, long value);
-
-    /**
-     * Searches for first occurrence of a value. Beware that the order in the column is undefined.
-     *
-     * @param columnIndex the column to search in.
-     * @param value the alue to search for.
-     * @return the row index for the first match found or {@link #NO_MATCH}.
-     */
-    long findFirstBoolean(long columnIndex, boolean value);
-
-    /**
-     * Searches for first occurrence of a value. Beware that the order in the column is undefined.
-     *
-     * @param columnIndex the column to search in.
-     * @param value the value to search for.
-     * @return the row index for the first match found or {@link #NO_MATCH}.
-     */
-    long findFirstFloat(long columnIndex, float value);
-
-    /**
-     * Searches for first occurrence of a value. Beware that the order in the column is undefined.
-     *
-     * @param columnIndex the column to search in.
-     * @param value the value to search for.
-     * @return the row index for the first match found or {@link #NO_MATCH}.
-     */
-    long findFirstDouble(long columnIndex, double value);
-
-    /**
-     * Searches for first occurrence of a value. Beware that the order in the column is undefined.
-     *
-     * @param columnIndex the column to search in.
-     * @param value the value to search for.
-     * @return the row index for the first match found or {@link #NO_MATCH}.
-     */
-    long findFirstDate(long columnIndex, Date value);
-
-    /**
-     * Searches for first occurrence of a value. Beware that the order in the column is undefined.
-     *
-     * @param columnIndex the column to search in.
-     * @param value the value to search for.
-     * @return the row index for the first match found or {@link #NO_MATCH}.
-     */
-    long findFirstString(long columnIndex, String value);
-
-    long lowerBoundLong(long columnIndex, long value);
-    long upperBoundLong(long columnIndex, long value);
-
-
-    TableView findAllLong(long columnIndex, long value);
-
-    TableView findAllBoolean(long columnIndex, boolean value);
-
-    TableView findAllFloat(long columnIndex, float value);
-
-    TableView findAllDouble(long columnIndex, double value);
-
-    TableView findAllString(long columnIndex, String value);
-
-    String toJson();
-
-    String toString();
-
-    TableQuery where();
-
-    /**
-     * Finds a row with in the table or view with the given index.
-     *
-     * @param rowIndex the index of the row.
-     * @return the index if found, or -1 for not found.
-     */
-    long sourceRowIndex(long rowIndex);
-
-    // Experimental:
-
-    long count(long columnIndex, String value);
-
-    /**
-     * Report the current versioning counter for the table. The versioning counter is guaranteed to
-     * change when the contents of the table changes after advance_read() or promote_to_write(), or
-     * immediately after calls to methods which change the table.
-     *
-     * @return version_counter for the table.
-     */
-    long getVersion();
-
-    void removeFirst();
-
-    enum PivotType {
-        COUNT(0),
-        SUM(1),
-        AVG(2),
-        MIN(3),
-        MAX(4);
-
-        final int value; // Package protected, accessible from Table and TableView
-
-        PivotType(int value) {
-            this.value = value;
-        }
-    }
-
-    Table pivot(long stringCol, long intCol, PivotType pivotType);
-
-    /**
-     * Syncs the TableView with the underlying table data. This is effectively the same as rerunning the query, so it
-     * should not be called on TableViews created by an async query.
-     *
-     * This method gets automatically called when calling {@link Realm#refresh()} or when another thread updates
-     * the Realm, but it will _not_ be called if the same thread commits a transaction.
-     *
-     * @return the version number for the updated TableView.
-     */
-    long syncIfNeeded();
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
index 902f4445da..76051a843b 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/TableQuery.java
@@ -28,10 +28,6 @@
     protected long nativePtr;
     private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
     protected final Table table;
-    // Don't convert this into local variable and don't remove this.
-    // Core requests Query to hold the TableView reference which it is built from.
-    @SuppressWarnings({"unused"})
-    private final TableOrView origin; // Table or TableView which created this TableQuery
     private final Context context;
 
     // All actions (find(), findAll(), sum(), etc.) must call validateQuery() before performing
@@ -47,18 +43,6 @@ public TableQuery(Context context, Table table, long nativeQueryPtr) {
         this.context = context;
         this.table = table;
         this.nativePtr = nativeQueryPtr;
-        this.origin = null;
-        context.addReference(this);
-    }
-
-    public TableQuery(Context context, Table table, long nativeQueryPtr, TableOrView origin) {
-        if (DEBUG) {
-            System.err.println("++++++ new TableQuery, ptr= " + nativeQueryPtr);
-        }
-        this.context = context;
-        this.table = table;
-        this.nativePtr = nativeQueryPtr;
-        this.origin = origin;
         context.addReference(this);
     }
 
@@ -72,11 +56,15 @@ public long getNativeFinalizerPtr() {
         return nativeFinalizerPtr;
     }
 
+    public Table getTable() {
+        return table;
+    }
+
     /**
      * Checks in core if query syntax is valid. Throws exception, if not.
      */
-    private void validateQuery() {
-        if (!queryValidated) { // If not yet validated, checks if syntax is valid
+    void validateQuery() {
+        if (! queryValidated) { // If not yet validated, checks if syntax is valid
             String invalidMessage = nativeValidateQuery(nativePtr);
             if (invalidMessage.equals(""))
                 queryValidated = true; // If empty string error message, query is valid
@@ -85,12 +73,6 @@ private void validateQuery() {
         }
     }
 
-    // Query TableView.
-    public TableQuery tableview(TableView tv) {
-        nativeTableview(nativePtr, tv.nativePtr);
-        return this;
-    }
-
     // Grouping
 
     public TableQuery group() {
@@ -436,71 +418,6 @@ public long find() {
         return nativeFind(nativePtr, 0);
     }
 
-    /**
-     * Performs a find query then handover the resulted Row (ready to be imported by another thread/shared_group).
-     *
-     * @param sharedRealm current {@link SharedRealm }from which to operate the query.
-     * @param ptrQuery query to run the the find against.
-     * @return pointer to the handover result (table_view).
-     */
-    public static long findWithHandover(SharedRealm sharedRealm, long ptrQuery) {
-        // Execute the disposal of abandoned realm objects each time a new realm object is created
-        return nativeFindWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0);
-    }
-
-    public TableView findAll(long start, long end, long limit) {
-        validateQuery();
-
-        long nativeViewPtr = nativeFindAll(nativePtr, start, end, limit);
-        return new TableView(this.context, this.table, nativeViewPtr, this);
-    }
-
-    public TableView findAll() {
-        validateQuery();
-
-        long nativeViewPtr = nativeFindAll(nativePtr, 0, Table.INFINITE, Table.INFINITE);
-        return new TableView(this.context, this.table, nativeViewPtr, this);
-    }
-
-    // Handovers find* methods.
-    // this will use a background SharedGroup to import the query (using the handover object)
-    // run the query, and return the table view to the caller SharedGroup using the handover object.
-    public static long findAllWithHandover(SharedRealm sharedRealm, long ptrQuery) throws BadVersionException {
-        return nativeFindAllWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE);
-    }
-
-    public static long findDistinctWithHandover(SharedRealm sharedRealm, long ptrQuery, long columnIndex) throws BadVersionException {
-        return nativeGetDistinctViewWithHandover(sharedRealm.getNativePtr(), ptrQuery, columnIndex);
-    }
-
-    public static long findAllSortedWithHandover(SharedRealm sharedRealm, long ptrQuery, long columnIndex, Sort sortOrder) throws BadVersionException {
-        return nativeFindAllSortedWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndex, sortOrder.getValue());
-    }
-
-    public static long findAllMultiSortedWithHandover(SharedRealm sharedRealm, long ptrQuery, long[] columnIndices, Sort[] sortOrders) throws BadVersionException {
-        boolean[] ascendings = getNativeSortOrderValues(sortOrders);
-        return nativeFindAllMultiSortedWithHandover(sharedRealm.getNativePtr(), ptrQuery, 0, Table.INFINITE, Table.INFINITE, columnIndices, ascendings);
-    }
-
-    public static long[] batchUpdateQueries(SharedRealm sharedRealm, long[] handoverQueries, long[][] parameters,
-                                            long[][] queriesParameters, boolean[][] multiSortOrder)
-            throws BadVersionException {
-        return nativeBatchUpdateQueries(sharedRealm.getNativePtr(), handoverQueries, parameters, queriesParameters,
-                multiSortOrder);
-    }
-    /**
-     * Imports a TableView from a worker thread to the caller thread.
-     *
-     * @param handoverPtr pointer to the handover object
-     * @param sharedRealm the SharedRealm on the caller thread.
-     * @return the TableView on the caller thread.
-     * @throws BadVersionException if the worker thread and caller thread are not at the same version.
-     */
-    public TableView importHandoverTableView(long handoverPtr, SharedRealm sharedRealm) throws BadVersionException {
-        long nativeTvPtr = nativeImportHandoverTableViewIntoSharedGroup(handoverPtr, sharedRealm.getNativePtr());
-        return new TableView(this.context, this.table, nativeTvPtr);
-    }
-
     /**
      * Imports a row from a worker thread to the caller thread.
      *
@@ -724,7 +641,6 @@ private void throwImmutable() {
     }
 
     private native String nativeValidateQuery(long nativeQueryPtr);
-    private native void nativeTableview(long nativeQueryPtr, long nativeTableViewPtr);
     private native void nativeGroup(long nativeQueryPtr);
     private native void nativeEndGroup(long nativeQueryPtr);
     private native void nativeOr(long nativeQueryPtr);
@@ -787,15 +703,7 @@ private void throwImmutable() {
     private native void nativeIsNotNull(long nativePtr, long columnIndices[]);
     private native long nativeCount(long nativeQueryPtr, long start, long end, long limit);
     private native long nativeRemove(long nativeQueryPtr);
-    private native long nativeImportHandoverTableViewIntoSharedGroup(long handoverTableViewPtr, long callerSharedRealmPtr) throws BadVersionException;
     private native long nativeHandoverQuery(long callerSharedRealmPtr, long nativeQueryPtr);
-    private static native long nativeFindAllSortedWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit, long columnIndex, boolean ascending) throws BadVersionException;
-    private static native long nativeFindAllWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit) throws BadVersionException;
-    private  static native long nativeGetDistinctViewWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long columnIndex) throws BadVersionException;
-    private static native long nativeFindWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long fromTableRow);
-    private static native long nativeFindAllMultiSortedWithHandover(long bgSharedRealmPtr, long nativeQueryPtr, long start, long end, long limit, long[] columnIndices, boolean[] ascending) throws BadVersionException;
     private static native long nativeImportHandoverRowIntoSharedGroup(long handoverRowPtr, long callerSharedRealmPtr);
-    public static native void nativeCloseQueryHandover(long nativePtr);
-    private static native long[] nativeBatchUpdateQueries(long bgSharedRealmPtr, long[] handoverQueries, long[][] parameters, long[][] queriesParameters, boolean[][] multiSortOrder) throws BadVersionException;
     private static native long nativeGetFinalizerPtr();
 }
diff --git a/realm/realm-library/src/main/java/io/realm/internal/TableView.java b/realm/realm-library/src/main/java/io/realm/internal/TableView.java
deleted file mode 100644
index 5bf309d3c7..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/TableView.java
+++ /dev/null
@@ -1,813 +0,0 @@
-/*
- * Copyright 2014 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal;
-
-import java.util.Date;
-import java.util.List;
-
-import io.realm.RealmFieldType;
-import io.realm.Sort;
-
-/**
- * This class represents a view of a particular table. We can think of a tableview as a subset of a table. It contains
- * less than or equal to the number of entries of a table. A table view is often a result of a query.
- *
- * The view doesn't copy data from the table, but contains merely a list of row-references into the original table
- * with the real data.
- */
-public class TableView implements TableOrView, NativeObject {
-    // Don't convert this into local variable and don't remove this.
-    // Core requests TableView to hold the Query reference.
-    @SuppressWarnings({"unused"})
-    private final TableQuery query; // the query which created this TableView
-    private long version; // Last seen version number. Call refresh() to update this.
-
-    protected long nativePtr;
-    private static final long nativeFinalizerPtr = nativeGetFinalizerPtr();
-    protected final Table parent;
-    private final Context context;
-
-
-    /**
-     * Creates a TableView. This constructor is used if the TableView is created from a table.
-     *
-     * @param context
-     * @param parent
-     * @param nativePtr
-     */
-    protected TableView(Context context, Table parent, long nativePtr) {
-        this.context = context;
-        this.parent = parent;
-        this.nativePtr = nativePtr;
-        this.query = null;
-        context.addReference(this);
-    }
-
-    /**
-     * Creates a TableView with already created Java TableView Object and a native native TableView object reference.
-     * The method is not supposed to be called by the user of the db. The method is for internal use only.
-     *
-     * @param context
-     * @param parent A table.
-     * @param nativePtr pointer to table view.
-     * @param query a reference to the query which the table view is based.
-     */
-    protected TableView(Context context, Table parent, long nativePtr, TableQuery query) {
-        this.context = context;
-        this.parent = parent;
-        this.nativePtr = nativePtr;
-        this.query = query;
-        context.addReference(this);
-    }
-
-    @Override
-    public long getNativePtr() {
-        return nativePtr;
-    }
-
-    @Override
-    public long getNativeFinalizerPtr() {
-        return nativeFinalizerPtr;
-    }
-
-    @Override
-    public Table getTable() {
-        return parent;
-    }
-
-    /**
-     * Checks whether this table is empty or not.
-     *
-     * @return {@code true} if empty, otherwise {@code false}.
-     */
-    @Override
-    public boolean isEmpty(){
-        return size() == 0;
-    }
-
-    /**
-     * Gets the number of entries/rows of this table.
-     *
-     * @return the number of rows.
-     */
-    @Override
-    public long size() {
-        return nativeSize(nativePtr);
-    }
-
-    /**
-     * Returns the index of the row in the source table.
-     *
-     * @param rowIndex row index in the TableView.
-     * @return the translated row number in the source table.
-     */
-    public long getSourceRowIndex(long rowIndex) {
-        return nativeGetSourceRowIndex(nativePtr, rowIndex);
-    }
-
-    /**
-     * Returns the number of columns in the table.
-     *
-     * @return the number of columns.
-     */
-    @Override
-    public long getColumnCount() {
-        return nativeGetColumnCount(nativePtr);
-    }
-
-    /**
-     * Returns the name of a column identified by columnIndex. Notice that the index is zero based.
-     *
-     * @param columnIndex the column index.
-     * @return the name of the column.
-     */
-    @Override
-    public String getColumnName(long columnIndex) {
-        return nativeGetColumnName(nativePtr, columnIndex);
-    }
-
-    /**
-     * Returns the 0-based index of a column based on the name.
-     *
-     * @param columnName column name.
-     * @return the index, {@code -1} if not found.
-     */
-    @Override
-    public long getColumnIndex(String columnName) {
-        if (columnName == null)
-            throw new IllegalArgumentException("Column name can not be null.");
-        return nativeGetColumnIndex(nativePtr, columnName);
-    }
-
-    /**
-     * Gets the type of a column identified by the columnIndex.
-     *
-     * @param columnIndex index of the column.
-     * @return type of the particular column.
-     */
-    @Override
-    public RealmFieldType getColumnType(long columnIndex) {
-        return RealmFieldType.fromNativeValue(nativeGetColumnType(nativePtr, columnIndex));
-    }
-
-    /**
-     * Gets the value of the particular (integer) cell.
-     *
-     * @param columnIndex 0 based index value of the column.
-     * @param rowIndex 0 based row value of the column.
-     * @return value of the particular cell.
-     */
-    @Override
-    public long getLong(long columnIndex, long rowIndex){
-        return nativeGetLong(nativePtr, columnIndex, rowIndex);
-    }
-
-    /**
-     * Gets the value of the particular (boolean) cell.
-     *
-     * @param columnIndex 0 based index value of the cell column.
-     * @param rowIndex 0 based index of the row.
-     * @return value of the particular cell.
-     */
-    @Override
-    public boolean getBoolean(long columnIndex, long rowIndex){
-        return nativeGetBoolean(nativePtr, columnIndex, rowIndex);
-    }
-
-    /**
-     * Gets the value of the particular (float) cell.
-     *
-     * @param columnIndex 0 based index value of the cell column.
-     * @param rowIndex 0 based index of the row.
-     * @return value of the particular cell.
-     */
-    @Override
-    public float getFloat(long columnIndex, long rowIndex){
-        return nativeGetFloat(nativePtr, columnIndex, rowIndex);
-    }
-
-    /**
-     * Gets the value of the particular (double) cell.
-     *
-     * @param columnIndex 0 based index value of the cell column.
-     * @param rowIndex 0 based index of the row.
-     * @return value of the particular cell.
-     */
-    @Override
-    public double getDouble(long columnIndex, long rowIndex){
-        return nativeGetDouble(nativePtr, columnIndex, rowIndex);
-    }
-
-    /**
-     * Gets the value of the particular (date) cell.
-     *
-     * @param columnIndex 0 based index value of the cell column.
-     * @param rowIndex 0 based index of the row.
-     * @return value of the particular cell.
-     */
-    @Override
-    public Date getDate(long columnIndex, long rowIndex){
-        return new Date(nativeGetTimestamp(nativePtr, columnIndex, rowIndex));
-    }
-
-    /**
-     * Gets the value of a (string )cell.
-     *
-     * @param columnIndex 0 based index value of the column.
-     * @param rowIndex 0 based index of the row.
-     * @return value of the particular cell.
-     */
-    @Override
-    public String getString(long columnIndex, long rowIndex){
-        return nativeGetString(nativePtr, columnIndex, rowIndex);
-    }
-
-    /**
-     * Gets the  value of a (binary) cell.
-     *
-     * @param columnIndex 0 based index value of the cell column.
-     * @param rowIndex 0 based index value of the cell row.
-     * @return value of the particular cell.
-     */
-    /*
-    @Override
-    public ByteBuffer getBinaryByteBuffer(long columnIndex, long rowIndex){
-        return nativeGetBinary(nativePtr, columnIndex, rowIndex);
-    }
-
-    protected native ByteBuffer nativeGetBinary(long nativeViewPtr, long columnIndex, long rowIndex);
-*/
-
-    @Override
-    public byte[] getBinaryByteArray(long columnIndex, long rowIndex){
-        return nativeGetByteArray(nativePtr, columnIndex, rowIndex);
-    }
-
-    public long getLink(long columnIndex, long rowIndex){
-        return nativeGetLink(nativePtr, columnIndex, rowIndex);
-    }
-
-    @Override
-    public boolean isNull(long columnIndex, long rowIndex) {
-        return nativeIsNull(nativePtr, columnIndex, rowIndex);
-    }
-
-    // Methods for setting values.
-
-    /**
-     * Sets the value for a particular (integer) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param value the value.
-     */
-    @Override
-    public void setLong(long columnIndex, long rowIndex, long value, boolean isDefault){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetLong(nativePtr, columnIndex, rowIndex, value);
-    }
-
-    /**
-     * Sets the value for a particular (boolean) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param value the value.
-     */
-    @Override
-    public void setBoolean(long columnIndex, long rowIndex, boolean value, boolean isDefault){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetBoolean(nativePtr, columnIndex, rowIndex, value);
-    }
-
-    /**
-     * Sets the value for a particular (float) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param value the value.
-     */
-    @Override
-    public void setFloat(long columnIndex, long rowIndex, float value, boolean isDefault){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetFloat(nativePtr, columnIndex, rowIndex, value);
-    }
-
-    /**
-     * Sets the value for a particular (double) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param value the value.
-     */
-    @Override
-    public void setDouble(long columnIndex, long rowIndex, double value, boolean isDefault){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetDouble(nativePtr, columnIndex, rowIndex, value);
-    }
-
-    /**
-     * Sets the value for a particular (date) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param value the value.
-     */
-    @Override
-    public void setDate(long columnIndex, long rowIndex, Date value, boolean isDefault){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetTimestampValue(nativePtr, columnIndex, rowIndex, value.getTime());
-    }
-
-    /**
-     * Sets the value for a particular (sting) cell.
-     *
-     * @param columnIndex column index of the.
-     * @param rowIndex row index of the cell.
-     * @param value the value.
-     */
-    @Override
-    public void setString(long columnIndex, long rowIndex, String value, boolean isDefault){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetString(nativePtr, columnIndex, rowIndex, value);
-    }
-
-    /**
-     * Sets the value for a particular (binary) cell.
-     *
-     * @param columnIndex column index of the cell.
-     * @param rowIndex row index of the cell.
-     * @param data the value.
-     */
-    /*
-    @Override
-    public void setBinaryByteBuffer(long columnIndex, long rowIndex, ByteBuffer data){
-        if (immutable) throwImmutable();
-        nativeSetBinary(nativePtr, columnIndex, rowIndex, data);
-    }
-
-    protected native void nativeSetBinary(long nativeViewPtr, long columnIndex, long rowIndex, ByteBuffer data);
-    */
-
-    @Override
-    public void setBinaryByteArray(long columnIndex, long rowIndex, byte[] data, boolean isDefault){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetByteArray(nativePtr, columnIndex, rowIndex, data);
-    }
-
-    @Override
-    public void setLink(long columnIndex, long rowIndex, long value, boolean isDefault){
-        if (parent.isImmutable()) throwImmutable();
-        nativeSetLink(nativePtr, columnIndex, rowIndex, value);
-    }
-
-    @Override
-    public void setNull(long columnIndex, long rowIndex, boolean isDefault) {
-        if (parent.isImmutable()) throwImmutable();
-        getTable().setNull(columnIndex, getSourceRowIndex(rowIndex), isDefault);
-    }
-
-    @Override
-    public boolean isNullLink(long columnIndex, long rowIndex) {
-        return nativeIsNullLink(nativePtr, columnIndex, rowIndex);
-    }
-
-    @Override
-    public void nullifyLink(long columnIndex, long rowIndex) {
-        nativeNullifyLink(nativePtr, columnIndex, rowIndex);
-    }
-
-    // Methods for deleting.
-    @Override
-    public void clear(){
-        if (parent.isImmutable()) throwImmutable();
-        nativeClear(nativePtr);
-    }
-
-    /**
-     * Removes a particular row identified by the index from the tableview.
-     * The corresponding row of the underlying table also get deleted.
-     *
-     * @param rowIndex the row index.
-     */
-    @Override
-    public void remove(long rowIndex){
-        if (parent.isImmutable()) throwImmutable();
-        nativeRemoveRow(nativePtr, rowIndex);
-    }
-
-    @Override
-    public void removeFirst() {
-        if (parent.isImmutable()) throwImmutable();
-        if (!isEmpty()) {
-            nativeRemoveRow(nativePtr, 0);
-        }
-    }
-
-    @Override
-    public void removeLast() {
-        if (parent.isImmutable()) throwImmutable();
-        if (!isEmpty()) {
-            nativeRemoveRow(nativePtr, size() - 1);
-        }
-    }
-
-    // Searches for first match
-    @Override
-    public long findFirstLong(long columnIndex, long value){
-        return nativeFindFirstInt(nativePtr, columnIndex, value);
-    }
-
-    @Override
-    public long findFirstBoolean(long columnIndex, boolean value) {
-        return nativeFindFirstBool(nativePtr, columnIndex, value);
-    }
-
-    @Override
-    public long findFirstFloat(long columnIndex, float value) {
-        return nativeFindFirstFloat(nativePtr, columnIndex, value);
-    }
-
-    @Override
-    public long findFirstDouble(long columnIndex, double value) {
-        return nativeFindFirstDouble(nativePtr, columnIndex, value);
-    }
-
-    @Override
-    public long findFirstDate(long columnIndex, Date date) {
-        // FIXME: waiting for implementation
-        return NO_MATCH;
-        // return nativeFindFirstDate(nativePtr, columnIndex, date.getTime());
-    }
-
-    @Override
-    public long findFirstString(long columnIndex, String value){
-        return nativeFindFirstString(nativePtr, columnIndex, value);
-    }
-
-    // Searches for all matches
-
-    // TODO..
-    @Override
-    public long lowerBoundLong(long columnIndex, long value) {
-        throw new RuntimeException("Not implemented yet");
-    }
-
-    // TODO..
-    @Override
-    public long upperBoundLong(long columnIndex, long value) {
-        throw new RuntimeException("Not implemented yet");
-    }
-
-    @Override
-    public TableView findAllLong(long columnIndex, long value){
-        long nativeViewPtr = nativeFindAllInt(nativePtr, columnIndex, value);
-        return new TableView(this.context, this.parent, nativeViewPtr);
-    }
-
-    @Override
-    public TableView findAllBoolean(long columnIndex, boolean value) {
-        long nativeViewPtr = nativeFindAllBool(nativePtr, columnIndex, value);
-        return new TableView(this.context, this.parent, nativeViewPtr);
-    }
-
-    @Override
-    public TableView findAllFloat(long columnIndex, float value) {
-        long nativeViewPtr = nativeFindAllFloat(nativePtr, columnIndex, value);
-        return new TableView(this.context, this.parent, nativeViewPtr);
-    }
-
-    @Override
-    public TableView findAllDouble(long columnIndex, double value) {
-        long nativeViewPtr = nativeFindAllDouble(nativePtr, columnIndex, value);
-        return new TableView(this.context, this.parent, nativeViewPtr);
-    }
-
-    @Override
-    public TableView findAllString(long columnIndex, String value){
-        long nativeViewPtr = nativeFindAllString(nativePtr, columnIndex, value);
-        return new TableView(this.context, this.parent, nativeViewPtr);
-    }
-
-    //
-    // Integer Aggregates
-    //
-
-    /**
-     * Calculates the sum of the values in a particular column of this tableview.
-     *
-     * Note: the type of the column marked by the columnIndex has to be of type RealmFieldType.INTEGER.
-     *
-     * @param columnIndex column index.
-     * @return the sum of the values in the column.
-     */
-    @Override
-    public long sumLong(long columnIndex){
-        return nativeSumInt(nativePtr, columnIndex);
-    }
-
-    /**
-     * Returns the maximum value of the cells in a column.
-     *
-     * Note: for this method to work the Type of the column identified by the columnIndex has to be
-     * RealmFieldType.INTEGER.
-     *
-     * @param columnIndex column index.
-     * @return the maximum value.
-     */
-    @Override
-    public Long maximumLong(long columnIndex){
-        return nativeMaximumInt(nativePtr, columnIndex);
-    }
-
-    /**
-     * Returns the minimum value of the cells in a column.
-     *
-     * Note: for this method to work the Type of the column identified by the columnIndex has to be
-     * RealmFieldType.INTEGER.
-     *
-     * @param columnIndex column index.
-     * @return the minimum value.
-     */
-    @Override
-    public Long minimumLong(long columnIndex){
-        return nativeMinimumInt(nativePtr, columnIndex);
-    }
-
-    @Override
-    public double averageLong(long columnIndex) {
-        return nativeAverageInt(nativePtr, columnIndex);
-    }
-
-    // Float aggregates
-
-    @Override
-    public double sumFloat(long columnIndex){
-        return nativeSumFloat(nativePtr, columnIndex);
-    }
-
-    @Override
-    public Float maximumFloat(long columnIndex){
-        return nativeMaximumFloat(nativePtr, columnIndex);
-    }
-
-    @Override
-    public Float minimumFloat(long columnIndex){
-        return nativeMinimumFloat(nativePtr, columnIndex);
-    }
-
-    @Override
-    public double averageFloat(long columnIndex) {
-        return nativeAverageFloat(nativePtr, columnIndex);
-    }
-
-    // Double aggregates
-
-    @Override
-    public double sumDouble(long columnIndex){
-        return nativeSumDouble(nativePtr, columnIndex);
-    }
-
-    @Override
-    public Double maximumDouble(long columnIndex){
-        return nativeMaximumDouble(nativePtr, columnIndex);
-    }
-
-
-    @Override
-    public Double minimumDouble(long columnIndex){
-        return nativeMinimumDouble(nativePtr, columnIndex);
-    }
-
-    @Override
-    public double averageDouble(long columnIndex) {
-        return nativeAverageDouble(nativePtr, columnIndex);
-    }
-
-    // Date aggregates
-
-    @Override
-    public Date maximumDate(long columnIndex) {
-        Long result = nativeMaximumTimestamp(nativePtr, columnIndex);
-        if (result == null) {
-            return null;
-        }
-        return new Date(result);
-    }
-
-    @Override
-    public Date minimumDate(long columnIndex) {
-        Long result = nativeMinimumTimestamp(nativePtr, columnIndex);
-        if (result == null) {
-            return null;
-        }
-        return new Date(result);
-    }
-
-    // Sortings
-    public void sort(long columnIndex, Sort sortOrder) {
-        // Don't check for immutable. Sorting does not modify original table
-        nativeSort(nativePtr, columnIndex, sortOrder.getValue());
-    }
-
-    public void sort(long columnIndex) {
-        // Don't check for immutable. Sorting does not modify original table
-        nativeSort(nativePtr, columnIndex, true);
-    }
-
-    public void sort(List<Long> columnIndices, Sort[] sortOrders) {
-        long indices[] = new long[columnIndices.size()];
-        for (int i = 0; i < columnIndices.size(); i++) {
-            indices[i] = columnIndices.get(i);
-        }
-        boolean nativeSortOrder[] = TableQuery.getNativeSortOrderValues(sortOrders);
-        nativeSortMulti(nativePtr, indices, nativeSortOrder);
-    }
-
-    @Override
-    public String toJson() {
-        return nativeToJson(nativePtr);
-    }
-
-    @Override
-    public String toString() {
-        long columnCount = getColumnCount();
-        StringBuilder stringBuilder = new StringBuilder("The TableView contains ");
-        stringBuilder.append(columnCount);
-        stringBuilder.append(" columns: ");
-
-        for (int i = 0; i < columnCount; i++) {
-            if (i != 0) {
-                stringBuilder.append(", ");
-            }
-            stringBuilder.append(getColumnName(i));
-        }
-        stringBuilder.append(".");
-
-        stringBuilder.append(" And ");
-        stringBuilder.append(size());
-        stringBuilder.append(" rows.");
-
-        return stringBuilder.toString();
-    }
-
-    @Override
-    public TableQuery where() {
-        long nativeQueryPtr = nativeWhere(nativePtr);
-        return new TableQuery(this.context, this.parent, nativeQueryPtr, this);
-    }
-
-    /**
-     * Finds a row in the parent table with the given {@code rowIndex}
-     *
-     * @param rowIndex the index of the row.
-     * @return the row index or -1 for not found.
-     */
-    @Override
-    public long sourceRowIndex(long rowIndex) {
-        return nativeFindBySourceNdx(nativePtr, rowIndex);
-    }
-
-
-    private void throwImmutable() {
-        throw new IllegalStateException("Realm data can only be changed inside a write transaction.");
-    }
-
-    @Override
-    public long count(long columnIndex, String value) {
-        // TODO: implement
-        throw new RuntimeException("Not implemented yet.");
-    }
-
-    @Override
-    public long getVersion() {
-        return version;
-    }
-
-    @Override
-    public Table pivot(long stringCol, long intCol, PivotType pivotType){
-        if (! this.getColumnType(stringCol).equals(RealmFieldType.STRING ))
-            throw new UnsupportedOperationException("Group by column must be of type String");
-        if (! this.getColumnType(intCol).equals(RealmFieldType.INTEGER ))
-            throw new UnsupportedOperationException("Aggregation column must be of type Int");
-        Table result = new Table();
-        nativePivot(nativePtr, stringCol, intCol, pivotType.value, result.nativePtr);
-        return result;
-   }
-
-    /**
-     * Removes rows that are duplicated with respect to the column set passed as argument.
-     * If two rows are indentical (for the given set of distinct-columns), then the last row is
-     * removed unless sorted, in which case the first object is returned.
-     *
-     * @param columnIndex the column index.
-     * @throws IllegalArgumentException if the type of the column is unsupported.
-     * @throws UnsupportedOperationException if a column is not indexed.
-     */
-    public void distinct(long columnIndex) {
-        nativeDistinct(nativePtr, columnIndex);
-    }
-
-    /**
-     * If two rows are identical (for the given set of distinct-columns), then the last row is
-     * removed unless sorted, in which case the first object is returned.
-     * Each time distinct() gets called, it will first fetch the full original TableView contents
-     * and then apply distinct() on that, invalidating previous distinct().
-     *
-     * @param columnIndexes the column indexes.
-     * @throws IllegalArgumentException if a column is unsupported type, or is not indexed.
-     */
-    public void distinct(List<Long> columnIndexes) {
-        long[] indexes = new long[columnIndexes.size()];
-        for (int i = 0; i < columnIndexes.size(); i++) {
-            indexes[i] = columnIndexes.get(i);
-        }
-        nativeDistinctMulti(nativePtr, indexes);
-    }
-
-    @Override
-    public long syncIfNeeded() {
-        version = nativeSyncIfNeeded(nativePtr);
-        return version;
-    }
-
-    private native long nativeSize(long nativeViewPtr);
-    private native long nativeGetSourceRowIndex(long nativeViewPtr, long rowIndex);
-    private native long nativeGetColumnCount(long nativeViewPtr);
-    private native String nativeGetColumnName(long nativeViewPtr, long columnIndex);
-    private native long nativeGetColumnIndex(long nativeViewPtr, String columnName);
-    private native int nativeGetColumnType(long nativeViewPtr, long columnIndex);
-    private native long nativeGetLong(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native boolean nativeGetBoolean(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native float nativeGetFloat(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native double nativeGetDouble(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native long nativeGetTimestamp(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native String nativeGetString(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native byte[] nativeGetByteArray(long nativePtr, long columnIndex, long rowIndex);
-    private native long nativeGetLink(long nativeViewPtr, long columnIndex, long rowIndex);
-    private native boolean nativeIsNull(long nativePtr, long columnIndex, long rowIndex);
-    private native void nativeSetLong(long nativeViewPtr, long columnIndex, long rowIndex, long value);
-    private native void nativeSetBoolean(long nativeViewPtr, long columnIndex, long rowIndex, boolean value);
-    private native void nativeSetFloat(long nativeViewPtr, long columnIndex, long rowIndex, float value);
-    private native void nativeSetDouble(long nativeViewPtr, long columnIndex, long rowIndex, double value);
-    private native void nativeSetTimestampValue(long nativePtr, long columnIndex, long rowIndex, long dateTimeValue);
-    private native void nativeSetString(long nativeViewPtr, long columnIndex, long rowIndex, String value);
-    private native void nativeSetByteArray(long nativePtr, long columnIndex, long rowIndex, byte[] data);
-    private native void nativeSetLink(long nativeViewPtr, long columnIndex, long rowIndex, long value);
-    private native boolean nativeIsNullLink(long nativePtr, long columnIndex, long rowIndex);
-    private native void nativeNullifyLink(long nativePtr, long columnIndex, long rowIndex);
-    private native void nativeClear(long nativeViewPtr);
-    private native void nativeRemoveRow(long nativeViewPtr, long rowIndex);
-    private native long nativeFindFirstInt(long nativeTableViewPtr, long columnIndex, long value);
-    private native long nativeFindFirstBool(long nativePtr, long columnIndex, boolean value);
-    private native long nativeFindFirstFloat(long nativePtr, long columnIndex, float value);
-    private native long nativeFindFirstDouble(long nativePtr, long columnIndex, double value);
-    private native long nativeFindFirstDate(long nativeTablePtr, long columnIndex, long dateTimeValue);
-    private native long nativeFindFirstString(long nativePtr, long columnIndex, String value);
-    private native long nativeFindAllInt(long nativePtr, long columnIndex, long value);
-    private native long nativeFindAllBool(long nativePtr, long columnIndex, boolean value);
-    private native long nativeFindAllFloat(long nativePtr, long columnIndex, float value);
-    private native long nativeFindAllDouble(long nativePtr, long columnIndex, double value);
-    private native long nativeFindAllDate(long nativePtr, long columnIndex, long dateTimeValue);
-    private native long nativeFindBySourceNdx(long nativePtr, long rowIndex);
-    private native long nativeSumInt(long nativeViewPtr, long columnIndex);
-    private native long nativeFindAllString(long nativePtr, long columnIndex, String value);
-    private native Long nativeMaximumInt(long nativeViewPtr, long columnIndex);
-    private native Long nativeMinimumInt(long nativeViewPtr, long columnIndex);
-    private native double nativeAverageInt(long nativePtr, long columnIndex);
-    private native double nativeSumFloat(long nativeViewPtr, long columnIndex);
-    private native Float nativeMaximumFloat(long nativeViewPtr, long columnIndex);
-    private native Float nativeMinimumFloat(long nativeViewPtr, long columnIndex);
-    private native double nativeAverageFloat(long nativePtr, long columnIndex);
-    private native double nativeSumDouble(long nativeViewPtr, long columnIndex);
-    private native Double nativeMaximumDouble(long nativeViewPtr, long columnIndex);
-    private native Double nativeMinimumDouble(long nativeViewPtr, long columnIndex);
-    private native double nativeAverageDouble(long nativePtr, long columnIndex);
-    private native Long nativeMaximumTimestamp(long nativePtr, long columnIndex);
-    private native Long nativeMinimumTimestamp(long nativePtr, long columnIndex);
-    private native void nativeSort(long nativeTableViewPtr, long columnIndex, boolean sortOrder);
-    private native void nativeSortMulti(long nativeTableViewPtr, long columnIndices[], boolean ascending[]);
-    private native long createNativeTableView(Table table, long nativeTablePtr);
-    private native String nativeToJson(long nativeViewPtr);
-    private native long nativeWhere(long nativeViewPtr);
-    private native void nativePivot(long nativeTablePtr, long stringCol, long intCol, int pivotType, long result);
-    private native void nativeDistinct(long nativeViewPtr, long columnIndex);
-    private native long nativeSyncIfNeeded(long nativeTablePtr);
-    private native void nativeDistinctMulti(long nativeViewPtr, long[] columnIndexes);
-    private native long nativeSync(long nativeTablePtr);
-    private static native long nativeGetFinalizerPtr();
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
index 7a18693df0..9c99b7a621 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/UncheckedRow.java
@@ -71,7 +71,7 @@ public long getNativeFinalizerPtr() {
      * @return an instance of Row for the table and index specified.
      */
     static UncheckedRow getByRowIndex(Context context, Table table, long index) {
-        long nativeRowPointer = table.nativeGetRowPtr(table.nativePtr, index);
+        long nativeRowPointer = table.nativeGetRowPtr(table.getNativePtr(), index);
         return new UncheckedRow(context, table, nativeRowPointer);
     }
 
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
new file mode 100644
index 0000000000..619ae6204e
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidCapabilities.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2016 Realm Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.realm.internal.android;
+
+import android.os.Looper;
+
+import io.realm.internal.Capabilities;
+
+/**
+ * Realm capabilities for Android.
+ */
+public class AndroidCapabilities implements Capabilities {
+
+    private final boolean hasLooper;
+    private final boolean isIntentServiceThread;
+
+    public AndroidCapabilities() {
+        hasLooper = Looper.myLooper() != null;
+        isIntentServiceThread = isIntentServiceThread();
+    }
+
+    @Override
+    public boolean canDeliverNotification() {
+        return hasLooper && !isIntentServiceThread;
+    }
+
+    @Override
+    public void checkCanDeliverNotification(String exceptionMessage) {
+        if (!hasLooper) {
+            throw new IllegalStateException( exceptionMessage == null ? "" : (exceptionMessage + " ") +
+                    "Realm cannot be automatically updated on a thread without a looper.");
+        }
+        if (isIntentServiceThread) {
+            throw new IllegalStateException( exceptionMessage == null ? "" : (exceptionMessage + " ") +
+                    "Realm cannot be automatically updated on an IntentService thread.");
+        }
+    }
+
+    private static boolean isIntentServiceThread() {
+        // Tries to determine if a thread is an IntentService thread. No public API can detect this,
+        // so use the thread name as a heuristic:
+        // https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/app/IntentService.java#108
+        String threadName = Thread.currentThread().getName();
+        return threadName != null && threadName.startsWith("IntentService[");
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/android/AndroidRealmNotifier.java b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidRealmNotifier.java
new file mode 100644
index 0000000000..4fc88b8cde
--- /dev/null
+++ b/realm/realm-library/src/main/java/io/realm/internal/android/AndroidRealmNotifier.java
@@ -0,0 +1,31 @@
+package io.realm.internal.android;
+
+import android.os.Handler;
+import android.os.Looper;
+
+import io.realm.internal.Capabilities;
+import io.realm.internal.Keep;
+import io.realm.internal.RealmNotifier;
+import io.realm.internal.SharedRealm;
+
+/**
+ * {@link RealmNotifier} implementation for Android.
+ */
+@Keep
+public class AndroidRealmNotifier extends RealmNotifier {
+    private Handler handler;
+
+    public AndroidRealmNotifier(SharedRealm sharedRealm, Capabilities capabilities) {
+        super(sharedRealm);
+        if (capabilities.canDeliverNotification()) {
+            handler = new Handler(Looper.myLooper());
+        } else {
+            handler = null;
+        }
+    }
+
+    @Override
+    public boolean post(Runnable runnable) {
+        return handler != null && handler.post(runnable);
+    }
+}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/ArgumentsHolder.java b/realm/realm-library/src/main/java/io/realm/internal/async/ArgumentsHolder.java
deleted file mode 100644
index 8fed5b45c6..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/async/ArgumentsHolder.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.async;
-
-import io.realm.Sort;
-
-/**
- * Value holder class to encapsulate the arguments of a RealmQuery (in case we want to re-query).
- */
-public class ArgumentsHolder {
-    public final static int TYPE_FIND_ALL = 0;
-    public final static int TYPE_FIND_ALL_SORTED = 1;
-    public final static int TYPE_FIND_ALL_MULTI_SORTED = 2;
-    public final static int TYPE_FIND_FIRST = 3;
-    public final static int TYPE_DISTINCT = 4;
-
-    public final int type;
-    public long columnIndex;
-    public Sort sortOrder;
-    public long[] columnIndices;
-    public Sort[] sortOrders;
-
-    public ArgumentsHolder(int type) {
-        this.type = type;
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java b/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
deleted file mode 100644
index b711d45de9..0000000000
--- a/realm/realm-library/src/main/java/io/realm/internal/async/QueryUpdateTask.java
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Copyright 2015 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.async;
-
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.IdentityHashMap;
-import java.util.List;
-
-import io.realm.RealmConfiguration;
-import io.realm.RealmModel;
-import io.realm.RealmResults;
-import io.realm.internal.RealmNotifier;
-import io.realm.internal.RealmObjectProxy;
-import io.realm.internal.SharedRealm;
-import io.realm.internal.Table;
-import io.realm.internal.TableQuery;
-import io.realm.log.RealmLog;
-
-/**
- * Manages the update of async queries.
- */
-public class QueryUpdateTask implements Runnable {
-
-    public enum NotifyEvent {
-        COMPLETE_ASYNC_RESULTS,
-        COMPLETE_ASYNC_OBJECT,
-        COMPLETE_UPDATE_ASYNC_QUERIES,
-        THROW_BACKGROUND_EXCEPTION,
-    }
-
-    // true if updating RealmResults, false if updating RealmObject, can't mix both
-    // the builder pattern will prevent this.
-    private final static int MODE_UPDATE_REALM_RESULTS = 0;
-    private final static int MODE_UPDATE_REALM_OBJECT = 1;
-    private final int updateMode;
-
-    private RealmConfiguration realmConfiguration;
-    private List<Builder.QueryEntry> realmResultsEntries;
-    private Builder.QueryEntry realmObjectEntry;
-    private WeakReference<RealmNotifier> callerNotifier;
-    private NotifyEvent event;
-
-    private QueryUpdateTask (int mode,
-                             RealmConfiguration realmConfiguration,
-                             List<Builder.QueryEntry> listOfRealmResults,
-                             Builder.QueryEntry realmObject,
-                             WeakReference<RealmNotifier> notifier,
-                             NotifyEvent event) {
-        this.updateMode = mode;
-        this.realmConfiguration = realmConfiguration;
-        this.realmResultsEntries = listOfRealmResults;
-        this.realmObjectEntry = realmObject;
-        this.callerNotifier = notifier;
-        this.event = event;
-    }
-
-    public static Builder.RealmConfigurationStep newBuilder() {
-        return new Builder.Steps();
-    }
-
-    @Override
-    public void run() {
-        SharedRealm sharedRealm = null;
-        try {
-            sharedRealm = SharedRealm.getInstance(realmConfiguration);
-
-            Result result;
-            boolean updateSuccessful;
-            if (updateMode == MODE_UPDATE_REALM_RESULTS) {
-                result = Result.newRealmResultsResponse();
-                AlignedQueriesParameters alignedParameters = prepareQueriesParameters();
-                long[] handoverTableViewPointer = TableQuery.batchUpdateQueries(sharedRealm,
-                        alignedParameters.handoverQueries,
-                        alignedParameters.queriesParameters,
-                        alignedParameters.multiSortColumnIndices,
-                        alignedParameters.multiSortOrder);
-                swapPointers(result, handoverTableViewPointer);
-                updateSuccessful = true;
-                result.versionID = sharedRealm.getVersionID();
-
-            } else {
-                result = Result.newRealmObjectResponse();
-                updateSuccessful = updateRealmObjectQuery(sharedRealm, result);
-                result.versionID = sharedRealm.getVersionID();
-            }
-
-            RealmNotifier notifier = callerNotifier.get();
-            if (updateSuccessful && !isTaskCancelled() && notifier != null) {
-                switch (event) {
-                    case COMPLETE_ASYNC_RESULTS:
-                        notifier.completeAsyncResults(result);
-                        break;
-                    case COMPLETE_ASYNC_OBJECT:
-                        notifier.completeAsyncObject(result);
-                        break;
-                    case COMPLETE_UPDATE_ASYNC_QUERIES:
-                        notifier.completeUpdateAsyncQueries(result);
-                        break;
-                    default:
-                        throw new IllegalStateException(String.format("%s is not handled here.", event));
-                }
-            }
-
-        } catch (BadVersionException e) {
-            // In some rare race conditions, this can happen. In that case, just ignore the error.
-            RealmLog.debug("Query update task could not complete due to a BadVersionException. " +
-                    "Retry is scheduled by a REALM_CHANGED event.");
-
-        } catch (Throwable e) {
-            RealmLog.error(e);
-            RealmNotifier notifier = callerNotifier.get();
-            if (notifier!= null) {
-                notifier.throwBackgroundException(e);
-            }
-
-        } finally {
-            if (sharedRealm != null) {
-                sharedRealm.close();
-            }
-        }
-    }
-
-    private AlignedQueriesParameters prepareQueriesParameters() {
-        long[] handoverQueries = new long[realmResultsEntries.size()];
-        long[][] queriesParameters = new long[realmResultsEntries.size()][6];
-        long[][] multiSortColumnIndices = new long[realmResultsEntries.size()][];
-        boolean[][] multiSortOrder = new boolean[realmResultsEntries.size()][];
-
-        int i = 0;
-        for (Builder.QueryEntry  queryEntry : realmResultsEntries) {
-            switch (queryEntry.queryArguments.type) {
-                case ArgumentsHolder.TYPE_FIND_ALL: {
-                    handoverQueries[i] = queryEntry.handoverQueryPointer;
-                    queriesParameters[i][0] = ArgumentsHolder.TYPE_FIND_ALL;
-                    queriesParameters[i][1] = 0;
-                    queriesParameters[i][2] = Table.INFINITE;
-                    queriesParameters[i][3] = Table.INFINITE;
-                    break;
-                }
-                case ArgumentsHolder.TYPE_DISTINCT: {
-                    handoverQueries[i] = queryEntry.handoverQueryPointer;
-                    queriesParameters[i][0] = ArgumentsHolder.TYPE_DISTINCT;
-                    queriesParameters[i][1] = queryEntry.queryArguments.columnIndex;
-                    break;
-                }
-                case ArgumentsHolder.TYPE_FIND_ALL_SORTED: {
-                    handoverQueries[i] = queryEntry.handoverQueryPointer;
-                    queriesParameters[i][0] = ArgumentsHolder.TYPE_FIND_ALL_SORTED;
-                    queriesParameters[i][1] = 0;
-                    queriesParameters[i][2] = Table.INFINITE;
-                    queriesParameters[i][3] = Table.INFINITE;
-                    queriesParameters[i][4] = queryEntry.queryArguments.columnIndex;
-                    queriesParameters[i][5] = (queryEntry.queryArguments.sortOrder.getValue()) ? 1 : 0;
-                    break;
-                }
-                case ArgumentsHolder.TYPE_FIND_ALL_MULTI_SORTED:
-                    handoverQueries[i] = queryEntry.handoverQueryPointer;
-                    queriesParameters[i][0] = ArgumentsHolder.TYPE_FIND_ALL_MULTI_SORTED;
-                    queriesParameters[i][1] = 0;
-                    queriesParameters[i][2] = Table.INFINITE;
-                    queriesParameters[i][3] = Table.INFINITE;
-                    multiSortColumnIndices[i] = queryEntry.queryArguments.columnIndices;
-                    multiSortOrder[i] = TableQuery.getNativeSortOrderValues(queryEntry.queryArguments.sortOrders);
-                    break;
-                default:
-                    throw new IllegalArgumentException("Query mode " + queryEntry.queryArguments.type + " not supported");
-            }
-            i++;
-        }
-        AlignedQueriesParameters alignedParameters = new AlignedQueriesParameters();
-
-        alignedParameters.handoverQueries = handoverQueries;
-        alignedParameters.multiSortColumnIndices = multiSortColumnIndices;
-        alignedParameters.multiSortOrder = multiSortOrder;
-        alignedParameters.queriesParameters = queriesParameters;
-
-        return alignedParameters;
-    }
-
-    private void swapPointers(Result result, long[] handoverTableViewPointer) {
-        int i = 0;
-        for (Builder.QueryEntry  queryEntry : realmResultsEntries) {
-            result.updatedTableViews.put(queryEntry.element, handoverTableViewPointer[i++]);
-        }
-    }
-
-    private boolean updateRealmObjectQuery(SharedRealm sharedRealm, Result result) {
-        if (!isTaskCancelled()) {
-            switch (realmObjectEntry.queryArguments.type) {
-                case ArgumentsHolder.TYPE_FIND_FIRST: {
-                    long handoverRowPointer = TableQuery.findWithHandover(sharedRealm,
-                                    realmObjectEntry.handoverQueryPointer);
-                    result.updatedRow.put(realmObjectEntry.element, handoverRowPointer);
-                    break;
-                }
-                default:
-                    throw new IllegalArgumentException("Query mode " + realmObjectEntry.queryArguments.type + " not supported");
-            }
-        } else {
-            TableQuery.nativeCloseQueryHandover(realmObjectEntry.handoverQueryPointer);
-            return false;
-        }
-        return true;
-    }
-
-    private boolean isTaskCancelled() {
-        // no point continuing if the caller thread was stopped or this thread was interrupted
-        return Thread.currentThread().isInterrupted();
-    }
-
-    // result of the async query
-    public static class Result {
-        public IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, Long> updatedTableViews;
-        public IdentityHashMap<WeakReference<RealmObjectProxy>, Long> updatedRow;
-        public SharedRealm.VersionID versionID;
-
-        public static Result newRealmResultsResponse() {
-            Result result = new Result();
-            result.updatedTableViews = new IdentityHashMap<WeakReference<RealmResults<? extends RealmModel>>, Long>(1);
-            return result;
-        }
-
-        public static Result newRealmObjectResponse() {
-            Result result = new Result();
-            result.updatedRow = new IdentityHashMap<WeakReference<RealmObjectProxy>, Long>(1);
-            return result;
-        }
-    }
-    private static class AlignedQueriesParameters {
-        long[] handoverQueries;
-        long[][] queriesParameters;
-        long[][] multiSortColumnIndices;
-        boolean[][] multiSortOrder;
-    }
-    /*
-      This uses the step builder pattern to guide the caller throughout the creation of the instance
-      http://rdafbn.blogspot.ie/2012/07/step-builder-pattern_28.html
-      Example of call:
-      QueryUpdateTask task = QueryUpdateTask.newBuilder()
-         .realmConfiguration(null, null)
-         .add(null, 0, null)
-         .add(null, 0, null)
-         .sendToNotifier(null, 0)
-         .build();
-
-     QueryUpdateTask task2 = QueryUpdateTask.newBuilder()
-         .realmConfiguration(null, null)
-         .addObject(null, 0, null)
-         .sendToNotifier(null, 0)
-         .build();
-     */
-    public static class Builder {
-        public interface RealmConfigurationStep {
-            UpdateQueryStep realmConfiguration (RealmConfiguration realmConfiguration);
-        }
-
-        public interface UpdateQueryStep {
-            RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmModel>> weakReference,
-                                          long handoverQueryPointer,
-                                          ArgumentsHolder queryArguments);
-            HandlerStep addObject(WeakReference<? extends RealmModel> weakReference,
-                                  long handoverQueryPointer,
-                                  ArgumentsHolder queryArguments);// can only update 1 element
-        }
-
-        public interface RealmResultsQueryStep {
-            RealmResultsQueryStep add(WeakReference<RealmResults<? extends RealmModel>> weakReference,
-                                          long handoverQueryPointer,
-                                          ArgumentsHolder queryArguments);
-            BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event);
-        }
-
-        public interface HandlerStep {
-            BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event);
-        }
-
-        public interface BuilderStep {
-            QueryUpdateTask build();
-        }
-
-        private static class Steps implements RealmConfigurationStep, UpdateQueryStep, RealmResultsQueryStep, HandlerStep, BuilderStep {
-            private RealmConfiguration realmConfiguration;
-            private List<QueryEntry> realmResultsEntries;
-            private QueryEntry realmObjectEntry;
-            private WeakReference<RealmNotifier> callerNotifier;
-            private NotifyEvent event;
-
-            @Override
-            public UpdateQueryStep realmConfiguration(RealmConfiguration realmConfiguration) {
-                this.realmConfiguration = realmConfiguration;
-                return this;
-            }
-
-            @Override
-            public RealmResultsQueryStep add(WeakReference<RealmResults<?>> weakReference,
-                                             long handoverQueryPointer,
-                                             ArgumentsHolder queryArguments) {
-                if (this.realmResultsEntries == null) {
-                    this.realmResultsEntries = new ArrayList<QueryEntry>(1);
-                }
-                this.realmResultsEntries.add(new QueryEntry(weakReference, handoverQueryPointer, queryArguments));
-                return this;
-            }
-
-            @Override
-            public HandlerStep addObject(WeakReference<? extends RealmModel> weakReference,
-                                         long handoverQueryPointer,
-                                         ArgumentsHolder queryArguments) {
-                realmObjectEntry =
-                        new QueryEntry(weakReference, handoverQueryPointer, queryArguments);
-                return this;
-            }
-
-            @Override
-            public BuilderStep sendToNotifier(RealmNotifier notifier, NotifyEvent event) {
-                this.callerNotifier = new WeakReference<RealmNotifier>(notifier);
-                this.event = event;
-                return this;
-            }
-
-            @Override
-            public QueryUpdateTask build() {
-                return new QueryUpdateTask(
-                        (realmResultsEntries != null) ? MODE_UPDATE_REALM_RESULTS : MODE_UPDATE_REALM_OBJECT,
-                        realmConfiguration,
-                        realmResultsEntries,
-                        realmObjectEntry,
-                        callerNotifier,
-                        event);
-            }
-        }
-
-        private static class QueryEntry {
-            final WeakReference element;
-            long handoverQueryPointer;
-            final ArgumentsHolder queryArguments;
-
-            private QueryEntry(WeakReference element, long handoverQueryPointer, ArgumentsHolder queryArguments) {
-                this.element = element;
-                this.handoverQueryPointer = handoverQueryPointer;
-                this.queryArguments = queryArguments;
-            }
-        }
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java b/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
deleted file mode 100644
index 87a1a98094..0000000000
--- a/realm/realm-library/src/main/java/io/realm/log/AndroidLogger.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.log;
-
-import android.util.Log;
-
-import static android.util.Log.getStackTraceString;
-
-/**
- * Logger implementation outputting to Android LogCat.
- * Androids {@link Log}levels are mapped to Realm {@link LogLevel}s using the following table:
- *
- * <table summary="Comparison of Realm and Android log levels">
- * <tr>
- *     <td>{@link LogLevel#ALL}</td><td>{@link Log#VERBOSE}</td>
- *     <td>{@link LogLevel#TRACE}</td><td>{@link Log#VERBOSE}</td>
- *     <td>{@link LogLevel#DEBUG}</td><td>{@link Log#DEBUG}</td>
- *     <td>{@link LogLevel#INFO}</td><td>{@link Log#INFO}</td>
- *     <td>{@link LogLevel#WARN}</td><td>{@link Log#WARN}</td>
- *     <td>{@link LogLevel#ERROR}</td><td>{@link Log#ERROR}</td>
- *     <td>{@link LogLevel#FATAL}</td><td>{@link Log#ERROR}</td>
- *     <td>{@link LogLevel#OFF}</td><td>Not supported. Remove the logger instead.</td>
- * </tr>
- * </table>
- *
- * @deprecated The new {@link RealmLogger} for Android is implemented in native code. This class will be removed in a
- * future release.
- */
-public class AndroidLogger implements Logger {
-
-    private static final int LOG_ENTRY_MAX_LENGTH = 4000;
-    private final int minimumLogLevel;
-    private volatile String logTag = "REALM";
-
-    /**
-     * Creates an logger that outputs to logcat.
-     *
-     * @param androidLogLevel Android log level
-     */
-    public AndroidLogger(int androidLogLevel) {
-        if (androidLogLevel < Log.VERBOSE || androidLogLevel > Log.ASSERT) {
-            throw new IllegalArgumentException("Unknown android log level: " + androidLogLevel);
-        }
-        minimumLogLevel = androidLogLevel;
-    }
-
-    /**
-     * Sets the logging tag used when outputting to LogCat. The default value is "REALM".
-     *
-     * @param tag Logging tag to use for all subsequent logging calls.
-     */
-    public void setTag(String tag) {
-        logTag = tag;
-    }
-
-    @Override
-    public int getMinimumNativeDebugLevel() {
-        // Maps Android log level to Realms log levels.
-        switch (minimumLogLevel) {
-            case Log.VERBOSE:   return LogLevel.TRACE;
-            case Log.DEBUG:     return LogLevel.DEBUG;
-            case Log.INFO:      return LogLevel.INFO;
-            case Log.WARN:      return LogLevel.WARN;
-            case Log.ERROR:     return LogLevel.ERROR;
-            case Log.ASSERT:    return LogLevel.FATAL;
-            default:
-                throw new IllegalStateException("Unknown log level: " + minimumLogLevel);
-        }
-    }
-
-    // Inspired by https://github.com/JakeWharton/timber/blob/master/timber/src/main/java/timber/log/Timber.java
-    private void log(int androidLogLevel, Throwable t, String message, Object... args) {
-        if (androidLogLevel < minimumLogLevel) {
-            return;
-        }
-        if (message == null) {
-            if (t == null) {
-                return; // Ignores event if message is null and there's no throwable.
-            }
-            message = getStackTraceString(t);
-        } else {
-            if (args != null && args.length > 0) {
-                message = String.format(message, args);
-            }
-            if (t != null) {
-                message += "\n" + getStackTraceString(t);
-            }
-        }
-
-        // Message fits one line. Just prints and exits.
-        if (message.length() < LOG_ENTRY_MAX_LENGTH) {
-            Log.println(androidLogLevel, logTag, message);
-            return;
-        }
-
-        // Message does not fit one line.
-        // Splits by line, then ensures each line can fit into Log's maximum length.
-        for (int i = 0, length = message.length(); i < length; i++) {
-            int newline = message.indexOf('\n', i);
-            newline = newline != -1 ? newline : length;
-            do {
-                int end = Math.min(newline, i + LOG_ENTRY_MAX_LENGTH);
-                String part = message.substring(i, end);
-                Log.println(androidLogLevel, logTag, part);
-                i = end;
-            } while (i < newline);
-        }
-    }
-
-    @Override
-    public void trace(Throwable throwable, String message, Object... args) {
-        log(Log.VERBOSE, throwable, message, args);
-    }
-
-    @Override
-    public void debug(Throwable throwable, String message, Object... args) {
-        log(Log.DEBUG, throwable, message, args);
-    }
-
-    @Override
-    public void info(Throwable throwable, String message, Object... args) {
-        log(Log.INFO, throwable, message, args);
-    }
-
-    @Override
-    public void warn(Throwable throwable, String message, Object... args) {
-        log(Log.WARN, throwable, message, args);
-    }
-
-    @Override
-    public void error(Throwable throwable, String message, Object... args) {
-        log(Log.ERROR, throwable, message, args);
-    }
-
-    @Override
-    public void fatal(Throwable throwable, String message, Object... args) {
-        log(Log.ASSERT, throwable, message, args);
-    }
-}
diff --git a/realm/realm-library/src/main/java/io/realm/log/Logger.java b/realm/realm-library/src/main/java/io/realm/log/Logger.java
deleted file mode 100644
index 6e36fed33f..0000000000
--- a/realm/realm-library/src/main/java/io/realm/log/Logger.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.log;
-
-/**
- * Interface for custom loggers that can be registered at {@link RealmLog#add(Logger)}.
- * The different log levels are described in {@link LogLevel}.
- * @deprecated Use {@link RealmLogger} instead.
- */
-public interface Logger {
-
-    /**
-     * Defines which {@link LogLevel} events this logger cares about from the native components.
-     * <p>
-     * If multiple loggers are registered, the minimum value among all loggers is used.
-     * <p>
-     * Note that sending log events from the native layer is relatively expensive, so only set this value to events
-     * that are truly useful.
-     *
-     * @return the minimum {@link LogLevel} native events this logger cares about.
-     */
-    int getMinimumNativeDebugLevel();
-
-    /**
-     * Handles a {@link LogLevel#TRACE} event.
-     *
-     * @param throwable optional exception to log.
-     * @param message optional additional message.
-     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
-     */
-    void trace(Throwable throwable, String message, Object... args);
-
-    /**
-     * Handles a {@link LogLevel#DEBUG} event.
-     *
-     * @param throwable optional exception to log.
-     * @param message optional additional message.
-     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
-     */
-    void debug(Throwable throwable, String message, Object... args);
-
-    /**
-     * Handles an {@link LogLevel#INFO} event.
-     *
-     * @param throwable optional exception to log.
-     * @param message optional additional message.
-     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
-     */
-    void info(Throwable throwable, String message, Object... args);
-
-    /**
-     * Handles a {@link LogLevel#WARN} event.
-     *
-     * @param throwable optional exception to log.
-     * @param message optional additional message.
-     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
-     */
-    void warn(Throwable throwable, String message, Object... args);
-
-    /**
-     * Handles an {@link LogLevel#ERROR} event.
-     *
-     * @param throwable optional exception to log.
-     * @param message optional additional message.
-     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
-     */
-    void error(Throwable throwable, String message, Object... args);
-
-    /**
-     * Handles a {@link LogLevel#FATAL} event.
-     *
-     * @param throwable optional exception to log.
-     * @param message optional additional message.
-     * @param args optional arguments used to format the message using {@link String#format(String, Object...)}.
-     */
-    void fatal(Throwable throwable, String message, Object... args);
-}
diff --git a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
index 877e8d9e0e..c9218689db 100644
--- a/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
+++ b/realm/realm-library/src/main/java/io/realm/log/RealmLog.java
@@ -18,9 +18,6 @@
 
 import android.util.Log;
 
-import java.util.IdentityHashMap;
-import java.util.Map;
-
 /**
  * Global logger used by all Realm components.
  * Custom loggers can be added by registering classes implementing {@link RealmLogger}.
@@ -30,56 +27,6 @@
     @SuppressWarnings("FieldCanBeLocal")
     private static String REALM_JAVA_TAG = "REALM_JAVA";
 
-    /**
-     * To convert the old {@link Logger} to the new {@link RealmLogger}.
-     */
-    private static class LoggerAdapter implements RealmLogger {
-        private Logger logger;
-        private static final Map<Logger, LoggerAdapter> loggerMap = new IdentityHashMap<Logger, LoggerAdapter>();
-
-        LoggerAdapter(Logger logger) {
-            this.logger = logger;
-            if (loggerMap.containsKey(logger)) {
-                throw new IllegalStateException(String.format("Logger %s exists in the map!", logger.toString()));
-            }
-            loggerMap.put(logger, this);
-        }
-
-        static RealmLogger removeLogger(Logger logger) {
-            return loggerMap.remove(logger);
-        }
-
-        static void clear() {
-            loggerMap.clear();
-        }
-
-        @Override
-        public void log(int level, String tag, Throwable throwable, String message) {
-            switch (level) {
-                case LogLevel.TRACE:
-                    logger.trace(throwable, message);
-                    break;
-                case LogLevel.INFO:
-                    logger.info(throwable, message);
-                    break;
-                case LogLevel.DEBUG:
-                    logger.debug(throwable, message);
-                    break;
-                case LogLevel.WARN:
-                    logger.warn(throwable, message);
-                    break;
-                case LogLevel.ERROR:
-                    logger.error(throwable, message);
-                    break;
-                case LogLevel.FATAL:
-                    logger.fatal(throwable, message);
-                    break;
-                default:
-                    throw new IllegalArgumentException("Level: " + level + " cannot be logged.");
-            }
-        }
-    }
-
     /**
      * Adds a logger implementation that will be notified on log events.
      *
@@ -92,18 +39,6 @@ public static void add(RealmLogger logger) {
         nativeAddLogger(logger);
     }
 
-    /**
-     * Adds a logger implementation that will be notified on log events.
-     *
-     * @param logger the reference to a {@link Logger} implementation.
-     * @deprecated use {@link #add(RealmLogger)} instead.
-     */
-    public static void add(Logger logger) {
-        synchronized (LoggerAdapter.class) {
-            add(new LoggerAdapter(logger));
-        }
-    }
-
     /**
      * Sets the current {@link LogLevel}. Setting this will affect all registered loggers.
      *
@@ -135,34 +70,12 @@ public static boolean remove(RealmLogger logger) {
         return true;
     }
 
-    /**
-     * Removes the given logger if it is currently added.
-     *
-     * @return {@code true} if the logger was removed, {@code false} otherwise.
-     * @deprecated use {@link #remove(RealmLogger)} instead.
-     */
-    public static boolean remove(Logger logger) {
-        synchronized (LoggerAdapter.class) {
-            if (logger == null) {
-                throw new IllegalArgumentException("A non-null logger has to be provided");
-            }
-            RealmLogger adaptor = LoggerAdapter.removeLogger(logger);
-            if (adaptor != null) {
-                nativeRemoveLogger(adaptor);
-            }
-        }
-        return true;
-    }
-
     /**
      * Removes all loggers. The default native logger will be removed as well. Use {@link #registerDefaultLogger()} to
      * add it back.
      */
     public static void clear() {
-        synchronized (LoggerAdapter.class) {
-            nativeClearLoggers();
-            LoggerAdapter.clear();
-        }
+        nativeClearLoggers();
     }
 
     /**
diff --git a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
index 2a0a090e61..b13ccbc127 100644
--- a/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
+++ b/realm/realm-library/src/main/java/io/realm/rx/RealmObservableFactory.java
@@ -45,15 +45,21 @@
  */
 public class RealmObservableFactory implements RxObservableFactory {
 
-    // Maps for storing strong references to RealmResults while they are subscribed to.
+    // Maps for storing strong references to Realm classes while they are subscribed to.
     // This is needed if users create Observables without manually maintaining a reference to them.
-    // In that case RealmObjects/RealmResults might be GC'ed too early.
+    // In that case RealmObjects/RealmResults/RealmLists might be GC'ed too early.
     ThreadLocal<StrongReferenceCounter<RealmResults>> resultsRefs = new ThreadLocal<StrongReferenceCounter<RealmResults>>() {
         @Override
         protected StrongReferenceCounter<RealmResults> initialValue() {
             return new StrongReferenceCounter<RealmResults>();
         }
     };
+    ThreadLocal<StrongReferenceCounter<RealmList>> listRefs = new ThreadLocal<StrongReferenceCounter<RealmList>>() {
+        @Override
+        protected StrongReferenceCounter<RealmList> initialValue() {
+            return new StrongReferenceCounter<RealmList>();
+        }
+    };
     ThreadLocal<StrongReferenceCounter<RealmModel>> objectRefs = new ThreadLocal<StrongReferenceCounter<RealmModel>>() {
         @Override
         protected StrongReferenceCounter<RealmModel> initialValue() {
@@ -127,7 +133,6 @@ public void call() {
     @Override
     public <E extends RealmModel> Observable<RealmResults<E>> from(final Realm realm, final RealmResults<E> results) {
         final RealmConfiguration realmConfig = realm.getConfiguration();
-
         return Observable.create(new Observable.OnSubscribe<RealmResults<E>>() {
             @Override
             public void call(final Subscriber<? super RealmResults<E>> subscriber) {
@@ -198,17 +203,75 @@ public void call() {
     }
 
     @Override
-    public <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, RealmList<E> list) {
-        return getRealmListObservable();
+    public <E extends RealmModel> Observable<RealmList<E>> from(Realm realm, final RealmList<E> list) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new Observable.OnSubscribe<RealmList<E>>() {
+            @Override
+            public void call(final Subscriber<? super RealmList<E>> subscriber) {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final Realm observableRealm = Realm.getInstance(realmConfig);
+                listRefs.get().acquireReference(list);
+
+                final RealmChangeListener<RealmList<E>> listener = new RealmChangeListener<RealmList<E>>() {
+                    @Override
+                    public void onChange(RealmList<E> result) {
+                        if (!subscriber.isUnsubscribed()) {
+                            subscriber.onNext(list);
+                        }
+                    }
+                };
+                list.addChangeListener(listener);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        list.removeChangeListener(listener);
+                        observableRealm.close();
+                        listRefs.get().releaseReference(list);
+                    }
+                }));
+
+                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // value.
+                subscriber.onNext(list);
+            }
+        });
     }
 
     @Override
-    public Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, RealmList<DynamicRealmObject> list) {
-        return getRealmListObservable();
-    }
+    public Observable<RealmList<DynamicRealmObject>> from(DynamicRealm realm, final RealmList<DynamicRealmObject> list) {
+        final RealmConfiguration realmConfig = realm.getConfiguration();
+        return Observable.create(new Observable.OnSubscribe<RealmList<DynamicRealmObject>>() {
+            @Override
+            public void call(final Subscriber<? super RealmList<DynamicRealmObject>> subscriber) {
+                // Gets instance to make sure that the Realm is open for as long as the
+                // Observable is subscribed to it.
+                final DynamicRealm observableRealm = DynamicRealm.getInstance(realmConfig);
+                listRefs.get().acquireReference(list);
+
+                final RealmChangeListener<RealmList<DynamicRealmObject>> listener = new RealmChangeListener<RealmList<DynamicRealmObject>>() {
+                    @Override
+                    public void onChange(RealmList<DynamicRealmObject> result) {
+                        if (!subscriber.isUnsubscribed()) {
+                            subscriber.onNext(list);
+                        }
+                    }
+                };
+                list.addChangeListener(listener);
+                subscriber.add(Subscriptions.create(new Action0() {
+                    @Override
+                    public void call() {
+                        list.removeChangeListener(listener);
+                        observableRealm.close();
+                        listRefs.get().releaseReference(list);
+                    }
+                }));
 
-    private <E extends RealmModel> Observable<RealmList<E>> getRealmListObservable() {
-        throw new RuntimeException("RealmList does not support change listeners yet, so cannot create an Observable");
+                // Immediately calls onNext with the current value, as due to Realm's auto-update, it will be the latest
+                // value.
+                subscriber.onNext(list);
+            }
+        });
     }
 
     @Override
diff --git a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
index 4c443e314f..191bf89c78 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/ErrorCode.java
@@ -104,11 +104,9 @@ public int intValue() {
      * Errors come in 2 categories: FATAL, RECOVERABLE
      * <p>
      * FATAL: The session cannot be recovered and needs to be re-created. A likely cause is that the User does not
-     * have access to this Realm. Check that the {@link SyncConfiguration} is correct. Any fatal error will cause
-     * the session to be become {@link SessionState#STOPPED}.
+     * have access to this Realm. Check that the {@link SyncConfiguration} is correct.
      * <p>
-     * RECOVERABLE: Temporary error. The session becomes {@link SessionState#UNBOUND}, but will automatically try to
-     * recover as soon as possible.
+     * RECOVERABLE: Temporary error. The session will automatically try to recover as soon as possible.
      * <p>
      *
      * @return the severity of the error.
diff --git a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
index 61a3ad24c5..e208131397 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/RealmFileUserStore.java
@@ -95,8 +95,4 @@ private static SyncUser toSyncUserOrNull(String userJson) {
     protected static native void nativeUpdateOrCreateUser(String identity, String jsonToken, String url);
 
     protected static native void nativeLogoutUser(String identity);
-
-    // Should only be called for tests
-    static native void nativeResetForTesting();
-
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SessionState.java b/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
deleted file mode 100644
index d3e167eae7..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/SessionState.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm;
-
-/**
- * Enum describing the various states the Session Finite-State-Machine can be in.
- */
-public enum SessionState {
-    INITIAL,          // Initial starting state
-    UNBOUND,          // Start done, Realm is unbound.
-    BINDING,          // bind() has been called. Can take a while.
-    AUTHENTICATING,   // Trying to authenticate credentials. Can take a while.
-    BOUND,            // Local realm was successfully bound to the remote Realm. Changes are being synchronized.
-    STOPPED           // Terminal state. Session can no longer be used.
-}
-
-
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
index baa076c0f8..9590f702f2 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncConfiguration.java
@@ -34,8 +34,6 @@
 import io.realm.exceptions.RealmException;
 import io.realm.internal.RealmProxyMediator;
 import io.realm.internal.SharedRealm;
-import io.realm.internal.syncpolicy.AutomaticSyncPolicy;
-import io.realm.internal.syncpolicy.SyncPolicy;
 import io.realm.rx.RealmObservableFactory;
 import io.realm.rx.RxObservableFactory;
 
@@ -73,13 +71,12 @@
 
     // The FAT file system has limitations of length. Also, not all characters are permitted.
     // https://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx
-    public static final int MAX_FULL_PATH_LENGTH = 256;
-    public static final int MAX_FILE_NAME_LENGTH = 255;
+    static final int MAX_FULL_PATH_LENGTH = 256;
+    static final int MAX_FILE_NAME_LENGTH = 255;
     private static final char[] INVALID_CHARS = {'<', '>', ':', '"', '/', '\\', '|', '?', '*'};
 
     private final URI serverUrl;
     private final SyncUser user;
-    private final SyncPolicy syncPolicy;
     private final SyncSession.ErrorHandler errorHandler;
     private final boolean deleteRealmOnLogout;
 
@@ -97,7 +94,6 @@ private SyncConfiguration(File directory,
                                 Realm.Transaction initialDataTransaction,
                                 SyncUser user,
                                 URI serverUrl,
-                                SyncPolicy syncPolicy,
                                 SyncSession.ErrorHandler errorHandler,
                                 boolean deleteRealmOnLogout
     ) {
@@ -117,7 +113,6 @@ private SyncConfiguration(File directory,
 
         this.user = user;
         this.serverUrl = serverUrl;
-        this.syncPolicy = syncPolicy;
         this.errorHandler = errorHandler;
         this.deleteRealmOnLogout = deleteRealmOnLogout;
     }
@@ -154,7 +149,6 @@ public boolean equals(Object o) {
         if (deleteRealmOnLogout != that.deleteRealmOnLogout) return false;
         if (!serverUrl.equals(that.serverUrl)) return false;
         if (!user.equals(that.user)) return false;
-        if (!syncPolicy.equals(that.syncPolicy)) return false;
         if (!errorHandler.equals(that.errorHandler)) return false;
         return true;
     }
@@ -165,7 +159,6 @@ public int hashCode() {
         result = 31 * result + serverUrl.hashCode();
         result = 31 * result + user.hashCode();
         result = 31 * result + (deleteRealmOnLogout ? 1 : 0);
-        result = 31 * result + syncPolicy.hashCode();
         result = 31 * result + errorHandler.hashCode();
         return result;
     }
@@ -178,19 +171,12 @@ public String toString() {
         stringBuilder.append("\n");
         stringBuilder.append("user: " + user);
         stringBuilder.append("\n");
-        stringBuilder.append("syncPolicy: " + syncPolicy);
-        stringBuilder.append("\n");
         stringBuilder.append("errorHandler: " + errorHandler);
         stringBuilder.append("\n");
         stringBuilder.append("deleteRealmOnLogout: " + deleteRealmOnLogout);
         return stringBuilder.toString();
     }
 
-    // Keeping this package protected for now. The API might still be subject to change.
-    SyncPolicy getSyncPolicy() {
-        return syncPolicy;
-    }
-
     /**
      * Returns the user.
      *
@@ -246,7 +232,6 @@ boolean isSyncConfiguration() {
         private Realm.Transaction initialDataTransaction;
         private URI serverUrl;
         private SyncUser user = null;
-        private SyncPolicy syncPolicy = new AutomaticSyncPolicy();
         private SyncSession.ErrorHandler errorHandler = SyncManager.defaultSessionErrorHandler;
         private File defaultFolder;
         private String defaultLocalFileName;
@@ -254,7 +239,6 @@ boolean isSyncConfiguration() {
         private boolean deleteRealmOnLogout = false;
         private final Pattern pattern = Pattern.compile("^[A-Za-z0-9_\\-\\.]+$"); // for checking serverUrl
 
-
         /**
          * Creates an instance of the Builder for the SyncConfiguration.
          * <p>
@@ -556,20 +540,6 @@ public Builder inMemory() {
             return this;
         }
 
-        /**
-         * Sets the {@link SyncPolicy} used to control when changes should be synchronized with the remote Realm.
-         * The default policy is {@link AutomaticSyncPolicy}.
-         *
-         * @param syncPolicy policy to use.
-         *
-         * @see SyncSession
-         */
-        Builder syncPolicy(SyncPolicy syncPolicy) {
-            // Package protected until SyncPolicy API is more stable.
-            this.syncPolicy = syncPolicy;
-            return this;
-        }
-
         /**
          * Sets the error handler used by this configuration. This will override any handler set by calling
          * {@link SyncManager#setDefaultSessionErrorHandler(SyncSession.ErrorHandler)}.
@@ -698,7 +668,6 @@ public SyncConfiguration build() {
                     // Sync Configuration specific
                     user,
                     resolvedServerUrl,
-                    syncPolicy,
                     errorHandler,
                     deleteRealmOnLogout
             );
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
index 10a2e1619c..ce463ff77a 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncManager.java
@@ -16,6 +16,8 @@
 
 package io.realm;
 
+import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -25,8 +27,6 @@
 import io.realm.internal.Keep;
 import io.realm.internal.network.AuthenticationServer;
 import io.realm.internal.network.OkHttpAuthenticationServer;
-import io.realm.internal.objectserver.SessionStore;
-import io.realm.internal.objectserver.ObjectServerSession;
 import io.realm.log.RealmLog;
 
 /**
@@ -63,7 +63,7 @@
 
     // Thread pool used when doing network requests against the Realm Authentication Server.
     // FIXME Set proper parameters
-    public static final ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(
+    static final ThreadPoolExecutor NETWORK_POOL_EXECUTOR = new ThreadPoolExecutor(
             10, 10, 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(100));
 
     private static final SyncSession.ErrorHandler SESSION_NO_OP_ERROR_HANDLER = new SyncSession.ErrorHandler() {
@@ -84,7 +84,8 @@ public void onError(SyncSession session, ObjectServerError error) {
             }
         }
     };
-
+    // keeps track of SyncSession, using 'realm_path'. Java interface with the ObjectStore using the 'realm_path'
+    private static Map<String, SyncSession> sessions = new HashMap<String, SyncSession>();
     private static CopyOnWriteArrayList<AuthenticationListener> authListeners = new CopyOnWriteArrayList<AuthenticationListener>();
 
     // The Sync Client is lightweight, but consider creating/removing it when there is no sessions.
@@ -93,27 +94,14 @@ public void onError(SyncSession session, ObjectServerError error) {
     private static volatile UserStore userStore;
 
     static volatile SyncSession.ErrorHandler defaultSessionErrorHandler = SESSION_NO_OP_ERROR_HANDLER;
-    @SuppressWarnings("FieldCanBeLocal")
-    private static Thread clientThread;
 
     // Initialize the SyncManager
     static void init(String appId, UserStore userStore) {
-
         SyncManager.APP_ID = appId;
         SyncManager.userStore = userStore;
 
         // Initialize underlying Sync Network Client
         nativeInitializeSyncClient();
-
-        // Create the client thread in java to avoid problems when exceptions are being thrown. We need to attach
-        // any thread to the JVM anyway in order to send back log events.
-        SyncManager.clientThread = new Thread(new Runnable() {
-            @Override
-            public void run() {
-                nativeRunClient();
-            }
-        }, "RealmSyncClient");
-        SyncManager.clientThread.start();
     }
 
     /**
@@ -178,29 +166,40 @@ public static void setDefaultSessionErrorHandler(SyncSession.ErrorHandler errorH
      * @throws IllegalArgumentException if syncConfiguration is {@code null}.
      */
     public static synchronized SyncSession getSession(SyncConfiguration syncConfiguration) {
+        // This will not create a new native (Object Store) session, this will only associate a Realm's path
+        // with a SyncSession. Object Store's SyncManager is responsible of the life cycle (including creation)
+        // of the native session, the provided Java wrap, helps interact with the native session, when reporting error
+        // or requesting an access_token for example.
+
         if (syncConfiguration == null) {
             throw new IllegalArgumentException("A non-empty 'syncConfiguration' is required.");
         }
 
-        if (SessionStore.hasSession(syncConfiguration)) {
-            return SessionStore.getPublicSession(syncConfiguration);
-        } else {
-            ObjectServerSession internalSession = new ObjectServerSession(
-                    syncConfiguration,
-                    authServer,
-                    syncConfiguration.getUser().getSyncUser(),
-                    syncConfiguration.getSyncPolicy(),
-                    syncConfiguration.getErrorHandler()
-            );
-            SyncSession publicSession = new SyncSession(internalSession);
-            SessionStore.addSession(publicSession, internalSession);
-            syncConfiguration.getUser().getSyncUser().addSession(publicSession);
-            syncConfiguration.getSyncPolicy().onSessionCreated(internalSession);
-            return publicSession;
+        SyncSession session = sessions.get(syncConfiguration.getPath());
+        if (session == null) {
+            session = new SyncSession(syncConfiguration);
+            sessions.put(syncConfiguration.getPath(), session);
+        }
+
+        return session;
+    }
+
+    /**
+     * Remove the wrapped Java session.
+     * @param syncConfiguration configuration object for the synchronized Realm.
+     */
+    @SuppressWarnings("unused")
+    private static synchronized void removeSession(SyncConfiguration syncConfiguration) {
+        if (syncConfiguration == null) {
+            throw new IllegalArgumentException("A non-empty 'syncConfiguration' is required.");
+        }
+        SyncSession syncSession = sessions.remove(syncConfiguration.getPath());
+        if (syncSession != null) {
+            syncSession.close();
         }
     }
 
-    public static AuthenticationServer getAuthServer() {
+    static AuthenticationServer getAuthServer() {
         return authServer;
     }
 
@@ -230,8 +229,62 @@ static void notifyUserLoggedOut(SyncUser user) {
         }
     }
 
+    /**
+     * All errors from native Sync is reported to this method. From the path we can determine which
+     * session to contact. If {@code path == null} all sessions are effected.
+     */
+    @SuppressWarnings("unused")
+    private static synchronized void notifyErrorHandler(int errorCode, String errorMessage, String path) {
+        for (SyncSession syncSession : sessions.values()) {
+            if (path == null || path.equals(syncSession.getConfiguration().getPath())) {
+                try {
+                    syncSession.notifySessionError(errorCode, errorMessage);
+                } catch (Exception exception) {
+                    RealmLog.error(exception);
+                }
+            }
+        }
+    }
+
+    /**
+     * This is called from the Object Store (through JNI) to request an {@code access_token} for
+     * the session specified by sessionPath.
+     *
+     * This will also schedule a timer to proactively refresh the {@code access_token} regularly, before
+     * the {@code access_token} expires.
+     *
+     * @throws IllegalStateException if the wrapped Java session is not found.
+     * @param sessionPath The path to the previously Java wraped session.
+     * @return a valid cached {@code access_token} if available or null.
+     */
+    @SuppressWarnings("unused")
+    private synchronized static String bindSessionWithConfig(String sessionPath) {
+        final SyncSession syncSession = sessions.get(sessionPath);
+        if (syncSession == null) {
+            RealmLog.error("Matching Java SyncSession could not be found for: " + sessionPath);
+        } else {
+            try {
+                return syncSession.accessToken(authServer);
+            } catch (Exception exception) {
+                RealmLog.error(exception);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Resets the SyncManger and clear all existing users.
+     * This will also terminate all sessions.
+     *
+     * Only call this method when testing.
+     */
+    static synchronized void reset() {
+        nativeReset();
+        sessions.clear();
+    }
+
     private static native void nativeInitializeSyncClient();
-    private static native void nativeRunClient();
     // init and load the Metadata Realm containing SyncUsers
     protected static native void nativeConfigureMetaDataSystem(String baseFile);
+    private static native void nativeReset();
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
index ad5ff24e39..1572c34abc 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncSession.java
@@ -17,33 +17,52 @@
 package io.realm;
 
 import java.net.URI;
+import java.util.concurrent.Future;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.realm.internal.Keep;
+import io.realm.internal.KeepMember;
+import io.realm.internal.SyncObjectServerFacade;
+import io.realm.internal.async.RealmAsyncTaskImpl;
+import io.realm.internal.network.AuthenticateResponse;
+import io.realm.internal.network.AuthenticationServer;
+import io.realm.internal.network.ExponentialBackoffTask;
+import io.realm.internal.network.NetworkStateReceiver;
+import io.realm.internal.objectserver.ObjectServerUser;
+import io.realm.internal.objectserver.Token;
 import io.realm.log.RealmLog;
-import io.realm.internal.objectserver.ObjectServerSession;
 
 /**
  * This class represents the connection to the Realm Object Server for one {@link SyncConfiguration}.
  * <p>
- * A Session is created by either calling {@link SyncManager#getSession(SyncConfiguration)} or by opening
- * a Realm instance using that configuration. Once a session has been created, it will continue to exist until the app
- * is closed or the {@link SyncConfiguration} is no longer used.
+ * A Session is created by opening a Realm instance using that configuration. Once a session has been created,
+ * it will continue to exist until the app is closed or all threads using this {@link SyncConfiguration} closes their respective {@link Realm}s.
  * <p>
  * A session is fully controlled by Realm, but can provide additional information in case of errors.
  * It is passed along in all {@link SyncSession.ErrorHandler}s.
  * <p>
  * This object is thread safe.
- *
- * @see SessionState
  */
 @Keep
 public class SyncSession {
+    private final static ScheduledThreadPoolExecutor REFRESH_TOKENS_EXECUTOR = new ScheduledThreadPoolExecutor(1);
+    private final static long REFRESH_MARGIN_DELAY = TimeUnit.SECONDS.toMillis(10);
 
-    private final ObjectServerSession osSession;
+    private final SyncConfiguration configuration;
+    private final ErrorHandler errorHandler;
+    private RealmAsyncTask networkRequest;
+    private NetworkStateReceiver.ConnectionListener networkListener;
+    private RealmAsyncTask refreshTokenTask;
+    private RealmAsyncTask refreshTokenNetworkRequest;
+    private AtomicBoolean onGoingAccessTokenQuery = new AtomicBoolean(false);
+    private volatile boolean isClosed = false;
 
-    SyncSession(ObjectServerSession osSession) {
-        this.osSession = osSession;
-        osSession.setUserSession(this);
+    SyncSession(SyncConfiguration configuration) {
+        this.configuration = configuration;
+        this.errorHandler = configuration.getErrorHandler();
     }
 
     /**
@@ -52,7 +71,7 @@
      * @return SyncConfiguration that defines and controls this session.
      */
     public SyncConfiguration getConfiguration() {
-        return osSession.getConfiguration();
+        return configuration;
     }
 
     /**
@@ -62,7 +81,7 @@ public SyncConfiguration getConfiguration() {
      * @return {@link SyncUser} used to authenticate the session on the Realm Object Server.
      */
     public SyncUser getUser() {
-        return osSession.getConfiguration().getUser();
+        return configuration.getUser();
     }
 
     /**
@@ -71,29 +90,24 @@ public SyncUser getUser() {
      * @return {@link URI} describing the remote Realm.
      */
     public URI getServerUrl() {
-        return osSession.getConfiguration().getServerUrl();
+        return configuration.getServerUrl();
     }
 
-    /**
-     * Returns the state of this session.
-     *
-     * @return the current {@link SessionState} for this session.
-     */
-    public SessionState getState() {
-        return osSession.getState();
-    }
-
-    ObjectServerSession getOsSession() {
-        return osSession;
+    // This callback will happen on the thread running the Sync Client.
+    @KeepMember
+    void notifySessionError(int errorCode, String errorMessage) {
+        ObjectServerError error = new ObjectServerError(ErrorCode.fromInt(errorCode), errorMessage);
+        if (errorHandler != null) {
+            errorHandler.onError(this, error);
+        }
     }
 
-    @Override
-    protected void finalize() throws Throwable {
-        super.finalize();
-        if (osSession.getState() != SessionState.STOPPED) {
-            RealmLog.warn("Session was not closed before being finalized. This is a potential resource leak.");
-            osSession.stop();
+    void close() {
+        isClosed = true;
+        if (networkRequest != null) {
+            networkRequest.cancel();
         }
+        clearScheduledAccessTokenRefresh();
     }
 
     /**
@@ -114,5 +128,185 @@ protected void finalize() throws Throwable {
          */
         void onError(SyncSession session, ObjectServerError error);
     }
+
+    String accessToken(final AuthenticationServer authServer) {
+        // check first if there's a valid access_token we can return immediately
+        if (getUser().getSyncUser().isAuthenticated(configuration)) {
+            Token accessToken = getUser().getSyncUser().getAccessToken(configuration.getServerUrl());
+            // start refreshing this token if a refresh is not going on
+            if (!onGoingAccessTokenQuery.getAndSet(true)) {
+                scheduleRefreshAccessToken(authServer, accessToken.expiresMs());
+            }
+            return accessToken.value();
+
+        } else {
+            if (!onGoingAccessTokenQuery.getAndSet(true)) {
+                if (NetworkStateReceiver.isOnline(SyncObjectServerFacade.getApplicationContext())) {
+                    authenticateRealm(authServer);
+
+                } else {
+                    // Wait for connection to become available, before trying again.
+                    // The Session might potentially stay in this state for the lifetime of the application.
+                    // This is acceptable.
+                    networkListener = new NetworkStateReceiver.ConnectionListener() {
+                        @Override
+                        public void onChange(boolean connectionAvailable) {
+                            if (connectionAvailable) {
+                                if (!onGoingAccessTokenQuery.getAndSet(true)) {
+                                    authenticateRealm(authServer);
+                                }
+                                NetworkStateReceiver.removeListener(this);
+                            }
+                        }
+                    };
+                    NetworkStateReceiver.addListener(networkListener);
+                }
+            }
+        }
+        return null;
+    }
+
+    // Authenticate by getting access tokens for the specific Realm
+    private void authenticateRealm(final AuthenticationServer authServer) {
+        if (networkRequest != null) {
+            networkRequest.cancel();
+        }
+        clearScheduledAccessTokenRefresh();
+
+        // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
+        Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {
+            @Override
+            protected AuthenticateResponse execute() {
+                if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                    return authServer.loginToRealm(
+                            getUser().getAccessToken(),//refresh token in fact
+                            configuration.getServerUrl(),
+                            getUser().getSyncUser().getAuthenticationUrl()
+                    );
+                }
+                return null;
+            }
+
+            @Override
+            protected void onSuccess(AuthenticateResponse response) {
+                RealmLog.debug("Session[%s]: Access token acquired", configuration.getPath());
+                if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                    ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
+                            response.getAccessToken(),
+                            configuration.getPath(),
+                            configuration.shouldDeleteRealmOnLogout()
+                    );
+                    getUser().getSyncUser().addRealm(configuration.getServerUrl(), desc);
+                    // schedule a token refresh before it expires
+                    if (nativeRefreshAccessToken(configuration.getPath(), getUser().getSyncUser().getAccessToken(configuration.getServerUrl()).value(), configuration.getServerUrl().toString())) {
+                        scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
+
+                    } else {
+                        // token not applied, no refresh will be scheduled
+                        onGoingAccessTokenQuery.set(false);
+                    }
+                }
+            }
+
+            @Override
+            protected void onError(AuthenticateResponse response) {
+                onGoingAccessTokenQuery.set(false);
+                RealmLog.debug("Session[%s]: Failed to get access token (%d)", configuration.getPath(), response.getError().getErrorCode());
+                if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                    errorHandler.onError(SyncSession.this, response.getError());
+                }
+            }
+        });
+        networkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
+    }
+
+    private void scheduleRefreshAccessToken(final AuthenticationServer authServer, long expireDateInMs) {
+            // calculate the delay time before which we should refresh the access_token,
+            // we adjust to 10 second to proactively refresh the access_token before the session
+            // hit the expire date on the token
+            long refreshAfter =  expireDateInMs - System.currentTimeMillis() - REFRESH_MARGIN_DELAY;
+            if (refreshAfter < 0) {
+                // Token already expired
+                RealmLog.debug("Expires time already reached for the access token, refresh as soon as possible");
+                // we avoid refreshing directly to avoid an edge case where the client clock is ahead
+                // of the server, causing all access_token received from the server to be always
+                // expired, we will flood the server with refresh token requests then, so adding
+                // a bit of delay is the best effort in this case.
+                refreshAfter = REFRESH_MARGIN_DELAY;
+            }
+
+            RealmLog.debug("Scheduling an access_token refresh in " + (refreshAfter) + " milliseconds");
+
+            if (refreshTokenTask != null) {
+                refreshTokenTask.cancel();
+            }
+
+            ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
+                @Override
+                public void run() {
+                    if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                        refreshAccessToken(authServer);
+                    }
+                }
+            }, refreshAfter, TimeUnit.MILLISECONDS);
+            refreshTokenTask = new RealmAsyncTaskImpl(task, REFRESH_TOKENS_EXECUTOR);
+    }
+
+    // Authenticate by getting access tokens for the specific Realm
+    private void refreshAccessToken(final AuthenticationServer authServer) {
+        // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
+        clearScheduledAccessTokenRefresh();
+
+        Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {
+            @Override
+            protected AuthenticateResponse execute() {
+                if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                    return authServer.refreshUser(getUser().getSyncUser().getUserToken(), configuration.getServerUrl(), getUser().getSyncUser().getAuthenticationUrl());
+                }
+                return null;
+            }
+
+            @Override
+            protected void onSuccess(AuthenticateResponse response) {
+                synchronized (SyncSession.this) {
+                    if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                        RealmLog.debug("Access Token refreshed successfully, Sync URL: " + configuration.getServerUrl());
+                        if (nativeRefreshAccessToken(configuration.getPath(), response.getAccessToken().value(), configuration.getUser().getAuthenticationUrl().toString())) {
+                            // replaced the user old access_token
+                            ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
+                                    response.getAccessToken(),
+                                    configuration.getPath(),
+                                    configuration.shouldDeleteRealmOnLogout()
+                            );
+                            getUser().getSyncUser().addRealm(configuration.getServerUrl(), desc);
+
+                            // schedule the next refresh
+                            scheduleRefreshAccessToken(authServer, response.getAccessToken().expiresMs());
+                        }
+                    }
+                }
+            }
+
+            @Override
+            protected void onError(AuthenticateResponse response) {
+                if (!isClosed && !Thread.currentThread().isInterrupted()) {
+                    onGoingAccessTokenQuery.set(false);
+                    RealmLog.error("Unrecoverable error, while refreshing the access Token (" + response.getError().toString() + ") reschedule will not happen");
+                }
+            }
+        });
+        refreshTokenNetworkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
+    }
+
+    private void clearScheduledAccessTokenRefresh() {
+        if (refreshTokenTask != null) {
+            refreshTokenTask.cancel();
+        }
+        if (refreshTokenNetworkRequest != null) {
+            refreshTokenNetworkRequest.cancel();
+        }
+    }
+
+    private static native boolean nativeRefreshAccessToken(String path, String accessToken, String authURL);
 }
 
diff --git a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
index eac47154eb..f0406cf086 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/SyncUser.java
@@ -293,13 +293,6 @@ public void logout() {
                 }
             }
 
-            // Stop all active sessions immediately. If we waited until after talking to the server
-            // there is a high chance errors would be reported from the Sync Client first which would
-            // be confusing.
-            for (SyncSession session : sessions) {
-                session.getOsSession().stop();
-            }
-
             SyncManager.getUserStore().remove(syncUser.getIdentity());
 
             // Delete all Realms if needed.
@@ -390,9 +383,9 @@ public String getIdentity() {
      *
      * @return the user's access token. If this user has logged out or the login has expired {@code null} is returned.
      */
-    public String getAccessToken() {
+    public Token getAccessToken() {
         Token userToken = syncUser.getUserToken();
-        return (userToken != null) ? userToken.value() : null;
+        return (userToken != null) ? userToken : null;
     }
 
     /**
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
similarity index 59%
rename from realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java
rename to realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
index 63e18261d4..c976c0bc08 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SyncObjectServerFacade.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/SyncObjectServerFacade.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package io.realm.internal.objectserver;
+package io.realm.internal;
 
 import android.annotation.SuppressLint;
 import android.content.Context;
@@ -25,12 +25,9 @@
 import java.lang.reflect.Method;
 
 import io.realm.RealmConfiguration;
-import io.realm.SyncSession;
 import io.realm.SyncConfiguration;
 import io.realm.SyncManager;
 import io.realm.exceptions.RealmException;
-import io.realm.internal.Keep;
-import io.realm.internal.ObjectServerFacade;
 import io.realm.internal.network.NetworkStateReceiver;
 
 @SuppressWarnings({"unused", "WeakerAccess"}) // Used through reflection. See ObjectServerFacade
@@ -41,6 +38,7 @@
             "'configuration' has to be an instance of 'SyncConfiguration'.";
     @SuppressLint("StaticFieldLeak") //
     private static Context applicationContext;
+    private static volatile Method removeSessionMethod;
 
     @Override
     public void init(Context context) {
@@ -71,51 +69,64 @@ public void init(Context context) {
     }
 
     @Override
-    public void notifyCommit(RealmConfiguration configuration, long lastSnapshotVersion) {
+    public void realmClosed(RealmConfiguration configuration) {
+        // Last Thread using the specified configuration is closed
+        // delete the wrapped Java session
         if (configuration instanceof SyncConfiguration) {
-            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
-            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
-            session.notifyCommit(lastSnapshotVersion);
+            SyncConfiguration syncConfig = (SyncConfiguration) configuration;
+            invokeRemoveSession(syncConfig);
         } else {
             throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
         }
     }
 
     @Override
-    public void realmClosed(RealmConfiguration configuration) {
-        if (configuration instanceof SyncConfiguration) {
-            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
-            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
-            session.getSyncPolicy().onRealmClosed(session);
+    public String[] getUserAndServerUrl(RealmConfiguration config) {
+        if (config instanceof SyncConfiguration) {
+            SyncConfiguration syncConfig = (SyncConfiguration) config;
+            String rosServerUrl = syncConfig.getServerUrl().toString();
+            String rosUserIdentity = syncConfig.getUser().getIdentity();
+            String syncRealmAuthUrl = syncConfig.getUser().getAuthenticationUrl().toString();
+            String rosRefreshToken = syncConfig.getUser().getAccessToken().value();
+            return new String[]{rosUserIdentity, rosServerUrl, syncRealmAuthUrl, rosRefreshToken};
         } else {
-            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
+            return new String[4];
         }
     }
 
-    @Override
-    public void realmOpened(RealmConfiguration configuration) {
-        if (configuration instanceof SyncConfiguration) {
-            SyncSession publicSession = SyncManager.getSession((SyncConfiguration) configuration);
-            ObjectServerSession session = SessionStore.getPrivateSession(publicSession);
-            session.getSyncPolicy().onRealmOpened(session);
-        } else {
-            throw new IllegalArgumentException(WRONG_TYPE_OF_CONFIGURATION);
-        }
+    public static Context getApplicationContext() {
+        return applicationContext;
     }
 
     @Override
-    public String[] getUserAndServerUrl(RealmConfiguration config) {
+    public void wrapObjectStoreSessionIfRequired(RealmConfiguration config) {
         if (config instanceof SyncConfiguration) {
-            SyncConfiguration syncConfig = (SyncConfiguration) config;
-            String rosServerUrl = syncConfig.getServerUrl().toString();
-            String rosUserToken = syncConfig.getUser().getAccessToken();
-            return new String[]{rosServerUrl, rosUserToken};
-        } else {
-            return new String[2];
+            SyncManager.getSession((SyncConfiguration) config);
         }
     }
 
-    static Context getApplicationContext() {
-        return applicationContext;
+    //FIXME remove this reflection call once we redesign the SyncManager to separate interface
+    //      from implementation to avoid issue like exposing internal method like SyncManager#removeSession
+    //      or SyncSession#close. This happens because SyncObjectServerFacade is internal, whereas
+    //      SyncManager#removeSession or SyncSession#close are package private & should not be public.
+    private void invokeRemoveSession(SyncConfiguration syncConfig) {
+        try {
+            if (removeSessionMethod == null) {
+                synchronized (SyncObjectServerFacade.class) {
+                    if (removeSessionMethod == null) {
+                        Method removeSession = SyncManager.class.getDeclaredMethod("removeSession", SyncConfiguration.class);
+                        removeSession.setAccessible(true);
+                        removeSessionMethod = removeSession;
+                    }
+                }
+            }
+            removeSessionMethod.invoke(null, syncConfig);
+        } catch (NoSuchMethodException e) {
+            throw new RealmException("Could not lookup method to remove session: " + syncConfig.toString(), e);
+        } catch (InvocationTargetException e) {
+            throw new RealmException("Could not invoke method to remove session: " + syncConfig.toString(), e);
+        } catch (IllegalAccessException e) {
+            throw new RealmException("Could not remove session: " + syncConfig.toString(), e);
+        }
     }
 }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
index ab53fff060..1e428dd190 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/ExponentialBackoffTask.java
@@ -30,7 +30,7 @@
 
     // Check if the task was successful
     protected boolean isSuccess(T result) {
-        return result.isValid();
+        return result != null && result.isValid();
     }
 
     // Return true if based on the task result that this task will never complete
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
index b4bbb18cde..40148acb8a 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/network/OkHttpAuthenticationServer.java
@@ -106,7 +106,6 @@ private AuthenticateResponse authenticate(URL authenticationUrl, String requestB
                 .addHeader("Accept", "application/json")
                 .post(RequestBody.create(JSON, requestBody))
                 .build();
-        RealmLog.debug("Authenticate: " + requestBody);
         Call call = client.newCall(request);
         Response response = call.execute();
         return AuthenticateResponse.from(response);
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java
deleted file mode 100644
index 9ca21ecf9e..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/AuthenticatingState.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import io.realm.ObjectServerError;
-import io.realm.SyncSession;
-import io.realm.SessionState;
-import io.realm.internal.network.NetworkStateReceiver;
-import io.realm.log.RealmLog;
-
-/**
- * AUTHENTICATING State. This step is needed if the user does not have proper access or credentials to access the
- * Realm when attempting to bind it. Reasons for not having proper access or invalid credentials include:
- *
- * <ol>
- *     <li>
- *          <b>Refresh token has expired:</b>
- *          This effectively means the user has been logged out from the Realm Object Server and credentials have
- *          to be re-verified by the Authentication Server. Since verification involves creating a new User object,
- *          this session will be stopped and an error reported.
- *     </li>
- *     <li>
- *          <b>Access token has expired:</b>
- *          In this case, the token is automatically refreshed and will retry binding the Realm.
- *     </li>
- *     <li>
- *          <b>Access token does not exist:</b>
- *          This state means the user has logged in, but not yet gained a specific access token for the Realm.
- *          The access token will automatically be fetched and binding the Realm is retried.
- *      </li>
- * </ol>
- */
-class AuthenticatingState extends FsmState {
-
-    @Override
-    public void onEnterState() {
-        if (NetworkStateReceiver.isOnline(SyncObjectServerFacade.getApplicationContext())) {
-            authenticate(session);
-        } else {
-            // Wait for connection to become available, before trying again.
-            // The Session might potentially stay in this state for the lifetime of the application.
-            // This is acceptable.
-            session.networkListener = new NetworkStateReceiver.ConnectionListener() {
-                @Override
-                public void onChange(boolean connectionAvailable) {
-                    if (connectionAvailable) {
-                        authenticate(session);
-                        NetworkStateReceiver.removeListener(this);
-                    }
-                }
-            };
-            NetworkStateReceiver.addListener(session.networkListener);
-        }
-    }
-
-    @Override
-    public void onExitState() {
-        // Abort any current network request.
-        if (session.networkRequest != null) {
-            session.networkRequest.cancel();
-            session.networkRequest = null;
-        }
-
-        // Release listener if we were waiting for network to become available.
-        if (session.networkListener != null) {
-            NetworkStateReceiver.removeListener(session.networkListener);
-            session.networkListener = null;
-        }
-    }
-
-    @Override
-    public void onBind() {
-        gotoNextState(SessionState.BINDING); // Equivalent to forcing a retry
-    }
-
-    @Override
-    public void onUnbind() {
-        gotoNextState(SessionState.UNBOUND); // Treat this as user wanting to exit a binding in progress.
-    }
-
-    @Override
-    public void onStop() {
-        gotoNextState(SessionState.STOPPED);
-    }
-
-    private synchronized void authenticate(final ObjectServerSession session) {
-        session.authenticateRealm(new Runnable() {
-            @Override
-            public void run() {
-                RealmLog.debug("Session[%s]: Access token acquired", session.getConfiguration().getPath());
-                gotoNextState(SessionState.BINDING);
-            }
-        }, new SyncSession.ErrorHandler() {
-            @Override
-            public void onError(SyncSession s, ObjectServerError error) {
-                RealmLog.debug("Session[%s]: Failed to get access token (%d)", session.getConfiguration().getPath(), error.getErrorCode());
-                session.onError(error);
-            }
-        });
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java
deleted file mode 100644
index fbd3a14f5b..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BindingState.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import io.realm.ObjectServerError;
-import io.realm.SessionState;
-
-/**
- * BINDING State. After {@code bind()} is called, the state will attempt to bind the local Realm to the remote. This is an
- * asynchronous operation which must be interruptible.
- */
-class BindingState extends FsmState {
-
-    @Override
-    public void onEnterState() {
-        if (session.isAuthenticated(session.configuration)) {
-            // FIXME How to handle errors?
-            session.bindWithTokens();
-            gotoNextState(SessionState.BOUND);
-        } else {
-            // Not access token available. We need to authenticateUser first.
-            gotoNextState(SessionState.AUTHENTICATING);
-        }
-    }
-
-    @Override
-    public void onExitState() {
-        // TODO Abort any async stuff going on, possible in `session.bindWithTokens()`
-    }
-
-    @Override
-    public void onBind() {
-        gotoNextState(SessionState.BINDING); // Will trigger a retry.
-    }
-
-    @Override
-    public void onUnbind() {
-        gotoNextState(SessionState.UNBOUND);
-    }
-
-    @Override
-    public void onError(ObjectServerError error) {
-        // Ignore all errors. This is just a transient state. We are not bound yet, and any error should not
-        // happen until we are BOUND.
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
deleted file mode 100644
index e3e4aa53b7..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/BoundState.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import io.realm.ErrorCode;
-import io.realm.ObjectServerError;
-import io.realm.SessionState;
-
-/**
- * BOUND State. In this state the local Realm is bound to the remote Realm and changes are sent in both
- * directions immediately.
- */
-class BoundState extends FsmState {
-
-    @Override
-    public void onEnterState() {
-        // Do nothing. If everything is setup correctly. We should now be synchronizing any changes
-        // between the local and remote Realm.
-    }
-
-    @Override
-    public void onExitState() {
-        // Do nothing. Entry states will stop the session if needed.
-    }
-
-    @Override
-    public void onUnbind() {
-        gotoNextState(SessionState.UNBOUND);
-    }
-
-    @Override
-    public void onStop() {
-        gotoNextState(SessionState.STOPPED);
-    }
-
-    @Override
-    public void onError(ObjectServerError error) {
-        // If a Realms access token has expired, trigger a rebind. If the user is still valid it will automatically
-        // refresh it.
-        if (error.getErrorCode() == ErrorCode.TOKEN_EXPIRED) {
-            //  the server can send a 202 (expired access token) even if the client
-            //  still consider this token to be valid (based on timestamps for example)
-            //
-            //  this may cause the server to send a fatal error (203 bad refresh) if we try to bind
-            //  the session with this token. To be safe we remove the token that has been considered by the
-            //  the server to be invalid.
-
-            // stop the session to avoid sending a bind to the server which will cause it to return
-            // a fatal 203 (bad refresh)
-            session.stopNativeSession();
-            session.removeAccessToken();
-
-            // Create a new session & bind it
-            session.createNativeSession();
-            gotoNextState(SessionState.BINDING);
-
-        } else {
-            switch (error.getCategory()) {
-                case FATAL: gotoNextState(SessionState.STOPPED); break;
-                case RECOVERABLE: gotoNextState(SessionState.UNBOUND); break;
-            }
-        }
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java
deleted file mode 100644
index ee4089a848..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/FsmState.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import io.realm.SyncSession;
-import io.realm.ObjectServerError;
-import io.realm.SessionState;
-
-/**
- * Abstract class containing shared logic for all {@link SyncSession} states. All states must extend
- * this class as it contains the logic for entering and leaving states.
- */
-abstract class FsmState implements FsmAction {
-
-    volatile ObjectServerSession session; // This is non-null when this state is active.
-    private boolean exiting; // TODO: Remind me again what race condition necessitated this.
-
-    /**
-     * Entry into the state. This method is also responsible for executing any asynchronous work
-     * this state might run.
-     *
-     * This should only be called from {@link SyncSession}.
-     */
-    public void entry(ObjectServerSession session) {
-        this.session = session;
-        this.exiting = false;
-        onEnterState();
-    }
-
-    /**
-     * Called just before leaving the state. Once this method is called no more state changes can be triggered from
-     * this state until {@link #entry(ObjectServerSession)} has been called again.
-     * <p>
-     * This should only be called from {@link SyncSession}.
-     */
-    public void exit() {
-        exiting = true;
-        onExitState();
-    }
-
-    public void gotoNextState(SessionState state) {
-        if (!exiting) {
-            session.nextState(state);
-        }
-    }
-
-    protected abstract void onEnterState();
-    protected abstract void onExitState();
-
-    @Override
-    public void onStart() {
-        // Do nothing
-    }
-
-    @Override
-    public void onBind() {
-        // Do nothing
-    }
-
-    @Override
-    public void onUnbind() {
-        // Do nothing
-    }
-
-    @Override
-    public void onStop() {
-        // Do nothing
-    }
-
-    @Override
-    public void onError(ObjectServerError error) {
-        switch(error.getCategory()) {
-            case FATAL:
-                gotoNextState(SessionState.STOPPED);
-                break;
-            case RECOVERABLE:
-                gotoNextState(SessionState.UNBOUND);
-                break;
-        }
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java
deleted file mode 100644
index ed13957250..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/InitialState.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import io.realm.ObjectServerError;
-import io.realm.SessionState;
-
-/**
- * INITIAL State. Starting point for the Session Finite-State-Machine.
- */
-class InitialState extends FsmState {
-
-    @Override
-    public void onEnterState() {
-        // Do nothing. We start here
-    }
-
-    @Override
-    protected void onExitState() {
-        // Do nothing. Right now the underlying Realm Core session cannot bound/unbind multiple times, so instead
-        // we create a new session object each time the Session becomes unbound.
-    }
-
-    @Override
-    public void onStart() {
-        gotoNextState(SessionState.UNBOUND);
-    }
-
-    @Override
-    public void onError(ObjectServerError error) {
-        // Ignore all errors at this state. None of them would have any impact.
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
deleted file mode 100644
index 615e23b5f5..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerSession.java
+++ /dev/null
@@ -1,475 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import java.net.URI;
-import java.util.HashMap;
-import java.util.concurrent.Future;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-
-import io.realm.ErrorCode;
-import io.realm.ObjectServerError;
-import io.realm.RealmAsyncTask;
-import io.realm.SessionState;
-import io.realm.SyncConfiguration;
-import io.realm.SyncManager;
-import io.realm.SyncSession;
-import io.realm.SyncUser;
-import io.realm.internal.KeepMember;
-import io.realm.internal.async.RealmAsyncTaskImpl;
-import io.realm.internal.network.AuthenticateResponse;
-import io.realm.internal.network.AuthenticationServer;
-import io.realm.internal.network.ExponentialBackoffTask;
-import io.realm.internal.network.NetworkStateReceiver;
-import io.realm.internal.syncpolicy.SyncPolicy;
-import io.realm.log.RealmLog;
-
-/**
- * Internal class describing a Realm Object Server Session.
- * There is currently a split between the public {@link SyncSession} and this class.
- * This class is intended as a wrapper for Object Store's Sync Session, but it is not that yet.
- * <p>
- * A Session is created by either calling {@link SyncManager#getSession(SyncConfiguration)} or by opening
- * a Realm instance. Once a session has been created, it will continue to exist until explicitly closed or the
- * underlying Realm file is deleted.
- * <p>
- * It is typically not necessary to interact directly with a session. The interaction should be done by the {@code SyncPolicy}
- * defined using {@code io.realm.SyncConfiguration.Builder#syncPolicy(SyncPolicy)}.
- * <p>
- * A session has a lifecycle consisting of the following states:
- * <p>
- * <dl>
- * <li>
- *     <b>INITIAL</b> Initial state when creating the Session object. No connections to the object server have been
- *     created yet. At this point it is possible to register any relevant error and event listeners. Calling
- *     {@link #start()} will cause the session to become <b>UNBOUND</b> and notify the {@code SyncPolicy} that the
- *     session is ready by calling {@code SyncPolicy#onSessionCreated(Session)}.
- * </li>
- * <li>
- *     <b>UNBOUND</b> When a session is unbound, no synchronization between the local and remote Realm is taking place.
- *     Call {@link #bind()} to start synchronizing changes.
- * </li>
- * <li>
- *     <b>BINDING</b> A session is in the process of binding a local Realm to a remote one. Calling {@link #unbind()}
- *     at this stage, will cancel the process. If binding fails, the session will revert to being INBOUND and an error
- *     will be reported to the error handler.
- * </li>
- * <li>
- *     <b>AUTHENTICATING</b> During binding, if a users access has expired, the session will be <b>AUTHENTICATING</b>.
- *     During this state, Realm will automatically try to acquire new valid credentials. If it succeed <b>BINDING</b>
- *     will automatically be resumed, if not, the session will become <b>UNBOUND</b> or <b>STOPPED</b> and an
- *     appropriate error reported.
- * </li>
- * <li>
- *     <b>BOUND</b> A bound session has an active connection to the remote Realm and will synchronize any changes
- *     immediately.
- * </li>
- * <li>
- *     <b>STOPPED</b> The session are in an unrecoverable state. Check the error log for additional information, but
- *     the type of errors is usually wrong credentials for the Realm being accessed or a mismatching Object Server.
- *     Most problems can be solved by creating a new {@link SyncConfiguration} with a new {@code serverUrl} and
- *     {@code user}.
- * </li>
- * </dl>
- *
- * This object is thread safe.
- */
-@KeepMember
-public final class ObjectServerSession {
-
-    private final HashMap<SessionState, FsmState> FSM = new HashMap<SessionState, FsmState>();
-
-    // Variables used by the FSM
-    final SyncConfiguration configuration;
-    private final AuthenticationServer authServer;
-    private final SyncSession.ErrorHandler errorHandler;
-    private long nativeSessionPointer;
-    private final ObjectServerUser user;
-    RealmAsyncTask networkRequest;
-    private RealmAsyncTask refreshTokenTask;
-    private RealmAsyncTask refreshTokenNetworkRequest;
-    NetworkStateReceiver.ConnectionListener networkListener;
-    private SyncPolicy syncPolicy;
-
-    // Keeping track of current FSM state
-    private SessionState currentStateDescription;
-    private FsmState currentState;
-    private SyncSession userSession;
-
-    private final static ScheduledThreadPoolExecutor REFRESH_TOKENS_EXECUTOR = new ScheduledThreadPoolExecutor(1);
-    private final static long REFRESH_MARGIN_DELAY = TimeUnit.SECONDS.toMillis(10);
-
-    /**
-     * Creates a new Object Server Session.
-     *
-     * @param syncConfiguration Sync configuration defining this session
-     * @param authServer Authentication server used to refresh credentials if needed
-     * @param policy Sync Policy to use by this Session.
-     */
-    public ObjectServerSession(SyncConfiguration syncConfiguration,
-                               AuthenticationServer authServer,
-                               ObjectServerUser user,
-                               SyncPolicy policy,
-                               SyncSession.ErrorHandler errorHandler) {
-        this.configuration = syncConfiguration;
-        this.user = user;
-        this.authServer = authServer;
-        this.errorHandler = errorHandler;
-        this.syncPolicy = policy;
-        setupStateMachine();
-    }
-
-    private void setupStateMachine() {
-        FSM.put(SessionState.INITIAL, new InitialState());
-        FSM.put(SessionState.UNBOUND, new UnboundState());
-        FSM.put(SessionState.BINDING, new BindingState());
-        FSM.put(SessionState.AUTHENTICATING, new AuthenticatingState());
-        FSM.put(SessionState.BOUND, new BoundState());
-        FSM.put(SessionState.STOPPED, new StoppedState());
-        RealmLog.debug("Session started: " + configuration.getServerUrl());
-        currentState = FSM.get(SessionState.INITIAL);
-        currentState.entry(this);
-    }
-
-    // Goto the next state. The FsmState classes are responsible for calling this method as a reaction to a FsmAction
-    // being called or an internal action triggering a state transition.
-    void nextState(SessionState nextStateDescription) {
-        currentState.exit();
-        FsmState nextState = FSM.get(nextStateDescription);
-        if (nextState == null) {
-            throw new IllegalStateException("No state was configured to handle: " + nextStateDescription);
-        }
-        RealmLog.debug("Session[%s]: %s -> %s", configuration.getServerUrl(), currentStateDescription, nextStateDescription);
-        currentStateDescription = nextStateDescription;
-        currentState = nextState;
-        nextState.entry(this);
-    }
-
-    /**
-     * Starts the session. This will cause the session to come <b>UNBOUND</b>. {@link #bind()} must be called to
-     * actually start synchronizing data.
-     */
-    public synchronized void start() {
-        currentState.onStart();
-    }
-
-    /**
-     * Stops the session. The session can no longer be used.
-     */
-    public synchronized void stop() {
-        // tries to stop any scheduled access_token refresh
-        clearScheduledAccessTokenRefresh();
-        currentState.onStop();
-    }
-
-    /**
-     * Binds the local Realm to the remote Realm. Once bound, changes to either the local or Remote Realm will be
-     * synchronized immediately.
-     * <p>
-     * While this method will return immediately, binding a Realm is not guaranteed to succeed. Possible reasons for
-     * failure could be if the device is offline or credentials have expired. Binding is an asynchronous
-     * operation and all errors will be sent first to {@code SyncPolicy#onError(Session, ObjectServerError)} and if the
-     * SyncPolicy doesn't handle it, to the {@link SyncSession.ErrorHandler} defined by
-     * {@link SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)}.
-     */
-    public synchronized void bind() {
-        currentState.onBind();
-    }
-
-    /**
-     * Stops a local Realm from synchronizing changes with the remote Realm.
-     * <p>
-     * It is possible to call {@link #bind()} again after a Realm has been unbound.
-     */
-    public synchronized void unbind() {
-        currentState.onUnbind();
-    }
-
-    /**
-     * Notify the session that an error has occurred.
-     *
-     * @param error the kind of err
-     */
-    public synchronized void onError(ObjectServerError error) {
-        currentState.onError(error); // FSM needs to respond to the error first, before notifying the User
-        if (errorHandler != null) {
-            errorHandler.onError(getUserSession(), error);
-        }
-    }
-
-    // Called from JniSession in native code.
-    // This callback will happen on the thread running the Sync Client.
-    @SuppressWarnings("unused")
-    @KeepMember
-    private void notifySessionError(int errorCode, String errorMessage) {
-        ObjectServerError error = new ObjectServerError(ErrorCode.fromInt(errorCode), errorMessage);
-        onError(error);
-    }
-
-    /**
-     * Checks if the local Realm is bound to the remote Realm and can synchronize any changes happening on either
-     * sides.
-     *
-     * @return {@code true} if the local Realm is bound to the remote Realm, {@code false} otherwise.
-     */
-    boolean isBound() {
-        return currentStateDescription == SessionState.BOUND;
-    }
-
-    //
-    // Package protected methods used by the FSM states to manipulate session variables.
-    //
-
-    // Create a native session. The session abstraction in Realm Core doesn't support multiple calls to bind()/unbind()
-    // yet, so the Java SyncSession must manually create/and close the native sessions as needed.
-    void createNativeSession() {
-        nativeSessionPointer = nativeCreateSession(configuration.getPath());
-    }
-
-    void stopNativeSession() {
-        if (nativeSessionPointer != 0) {
-            nativeUnbind(nativeSessionPointer);
-            nativeSessionPointer = 0;
-        }
-        clearScheduledAccessTokenRefresh();
-    }
-
-    // It is an error to call this function before calling Client::bind() state
-    private boolean updateSessionAccessToken(String userToken) {
-        if (nativeSessionPointer != 0 && isBound()) {
-            nativeRefresh(nativeSessionPointer, userToken);
-            return true;
-        }
-        return false;
-    }
-
-    private void clearScheduledAccessTokenRefresh() {
-        if (refreshTokenTask != null) {
-            refreshTokenTask.cancel();
-        }
-        if (refreshTokenNetworkRequest != null) {
-            refreshTokenNetworkRequest.cancel();
-        }
-    }
-
-    void removeAccessToken() {
-        user.removeAccessToken(configuration.getServerUrl());
-    }
-
-    // Bind with proper access tokens
-    // Access tokens are presumed to be present and valid at this point
-    void bindWithTokens() {
-        Token accessToken = user.getAccessToken(configuration.getServerUrl());
-        if (accessToken == null) {
-            throw new IllegalStateException("User '" + user.toString() + "' does not have an access token for "
-                    + configuration.getServerUrl());
-        }
-        nativeBind(nativeSessionPointer, configuration.getServerUrl().toString(), accessToken.value());
-    }
-
-    // Authenticate by getting access tokens for the specific Realm
-    void authenticateRealm(final Runnable onSuccess, final SyncSession.ErrorHandler errorHandler) {
-        if (networkRequest != null) {
-            networkRequest.cancel();
-        }
-        // clear any previously scheduled refresh access_token
-        // since we're going to obtain a new refresh_token
-        clearScheduledAccessTokenRefresh();
-
-        // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
-        Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {
-            @Override
-            protected AuthenticateResponse execute() {
-                return authServer.loginToRealm(
-                        user.getUserToken(),
-                        configuration.getServerUrl(),
-                        user.getAuthenticationUrl()
-                );
-            }
-
-            @Override
-            protected void onSuccess(AuthenticateResponse response) {
-                ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
-                        response.getAccessToken(),
-                        configuration.getPath(),
-                        configuration.shouldDeleteRealmOnLogout()
-                );
-                user.addRealm(configuration.getServerUrl(), desc);
-                // schedule a token refresh before it expires
-                scheduleRefreshAccessToken(response.getAccessToken().expiresMs());
-                onSuccess.run();
-            }
-
-            @Override
-            protected void onError(AuthenticateResponse response) {
-                errorHandler.onError(getUserSession(), response.getError());
-            }
-        });
-        networkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
-    }
-
-    private void scheduleRefreshAccessToken(long expireDateInMs) {
-        // calculate the delay time before which we should refresh the access_token,
-        // we adjust to 10 second to proactively refresh the access_token before the session
-        // hit the expire date on the token
-        long refreshAfter =  expireDateInMs - System.currentTimeMillis() - REFRESH_MARGIN_DELAY;
-        if (refreshAfter < 0) {
-            // Token already expired
-            RealmLog.debug("Expires time already reached for the access token, refreshing now");
-            refreshAccessToken();
-
-        } else {
-            RealmLog.debug("Scheduling an access_token refresh in " + (refreshAfter) + " milliseconds");
-            if (refreshTokenTask != null) {
-                refreshTokenTask.cancel();
-            }
-
-            ScheduledFuture<?> task = REFRESH_TOKENS_EXECUTOR.schedule(new Runnable() {
-                @Override
-                public void run() {
-                    refreshAccessToken();
-                }
-            }, refreshAfter, TimeUnit.MILLISECONDS);
-            refreshTokenTask = new RealmAsyncTaskImpl(task, REFRESH_TOKENS_EXECUTOR);
-        }
-    }
-
-    // Authenticate by getting access tokens for the specific Realm
-    private void refreshAccessToken() {
-        // Authenticate in a background thread. This allows incremental backoff and retries in a safe manner.
-        if (refreshTokenNetworkRequest != null) {
-            refreshTokenNetworkRequest.cancel();
-        }
-        Future<?> task = SyncManager.NETWORK_POOL_EXECUTOR.submit(new ExponentialBackoffTask<AuthenticateResponse>() {
-            @Override
-            protected AuthenticateResponse execute() {
-                return authServer.refreshUser(user.getUserToken(), configuration.getServerUrl(), user.getAuthenticationUrl());
-            }
-
-            @Override
-            protected void onSuccess(AuthenticateResponse response) {
-                synchronized (ObjectServerSession.this) {
-                    RealmLog.debug("Access Token refreshed successfully");
-                    if (updateSessionAccessToken(response.getAccessToken().value())) {
-                        RealmLog.debug("Token applied");
-                        // only schedule an update if the token was updated.
-                        // The callback might return will the session state is not BOUND
-                        // in this case we'll wait for the new session state to transition to
-                        // BOUND, which will schedule a refresh in the process
-
-                        // this will also avoid updating a stopped session
-
-                        // replaced the user old access_token
-                        ObjectServerUser.AccessDescription desc = new ObjectServerUser.AccessDescription(
-                                response.getAccessToken(),
-                                configuration.getPath(),
-                                configuration.shouldDeleteRealmOnLogout()
-                        );
-                        user.addRealm(configuration.getServerUrl(), desc);
-                        // schedule the next refresh
-                        scheduleRefreshAccessToken(response.getAccessToken().expiresMs());
-                    }
-                }
-            }
-
-            @Override
-            protected void onError(AuthenticateResponse response) {
-                RealmLog.error("Unrecoverable error, while refreshing the access Token (" + response.getError().toString() + ") reschedule will not happen");
-            }
-        });
-        refreshTokenNetworkRequest = new RealmAsyncTaskImpl(task, SyncManager.NETWORK_POOL_EXECUTOR);
-    }
-
-    /**
-     * Checks if a user has valid credentials for accessing this Realm.
-     *
-     * @param configuration the configuration.
-     * @return {@code true} if credentials are valid, {@code false} otherwise.
-     */
-    boolean isAuthenticated(SyncConfiguration configuration) {
-        return user.isAuthenticated(configuration);
-    }
-
-    /**
-     * Returns the {@link SyncConfiguration} that is responsible for controlling this session.
-     *
-     * @return SyncConfiguration that defines and controls this session.
-     */
-    public SyncConfiguration getConfiguration() {
-        return configuration;
-    }
-
-    /**
-     * Returns the {@link SyncUser} defined by the {@link SyncConfiguration} that is used to connect to the
-     * Realm Object Server.
-     *
-     * @return {@link SyncUser} used to authenticate the session on the Realm Object Server.
-     */
-    public SyncUser getUser() {
-        return configuration.getUser();
-    }
-
-    /**
-     * Returns the {@link URI} describing the remote Realm this session connects to and synchronizes changes with.
-     *
-     * @return {@link URI} describing the remote Realm.
-     */
-    public URI getServerUrl() {
-        return configuration.getServerUrl();
-    }
-
-    /**
-     * Returns the state of this session.
-     *
-     * @return The current {@link SessionState} for this session.
-     */
-    public SessionState getState() {
-        return currentStateDescription;
-    }
-
-    /**
-     * Notify session that a commit on the device has happened.
-     *
-     * @param version the commit number/version.
-     */
-    public void notifyCommit(long version) {
-        if (isBound()) {
-            nativeNotifyCommitHappened(nativeSessionPointer, version);
-        }
-    }
-
-    public SyncPolicy getSyncPolicy() {
-        return syncPolicy;
-    }
-
-    public SyncSession getUserSession() {
-        return userSession;
-    }
-
-    public void setUserSession(SyncSession userSession) {
-        this.userSession = userSession;
-    }
-
-    private native long nativeCreateSession(String localRealmPath);
-    private native void nativeBind(long nativeSessionPointer, String remoteRealmUrl, String userToken);
-    private native void nativeUnbind(long nativeSessionPointer);
-    private native void nativeRefresh(long nativeSessionPointer, String userToken);
-    private native void nativeNotifyCommitHappened(long sessionPointer, long version);
-}
-
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
index a24e2bb6ce..740125a54b 100644
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
+++ b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/ObjectServerUser.java
@@ -65,7 +65,7 @@ private void setRefreshToken(final Token refreshToken) {
      *
      * Authenticating will happen automatically as part of opening a Realm.
      */
-    boolean isAuthenticated(SyncConfiguration configuration) {
+    public boolean isAuthenticated(SyncConfiguration configuration) {
         Token token = getAccessToken(configuration.getServerUrl());
         return token != null && token.expiresMs() > System.currentTimeMillis();
     }
@@ -93,7 +93,7 @@ public String getIdentity() {
         return identity;
     }
 
-    Token getAccessToken(URI serverUrl) {
+    public Token getAccessToken(URI serverUrl) {
         AccessDescription accessDescription = realms.get(serverUrl);
         return (accessDescription != null) ? accessDescription.accessToken : null;
     }
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java
deleted file mode 100644
index a40fe01fd1..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/SessionStore.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-
-import io.realm.SyncSession;
-import io.realm.SyncManager;
-import io.realm.SyncConfiguration;
-
-/**
- * Private class for keeping track of sessions.
- * If {@link SyncSession} and {@link ObjectServerSession} are combined at some point, this class can
- * be folded into {@link SyncManager};
- */
-public class SessionStore {
-
-    // Map of between a local Realm path and any associated sessionInfo
-    private static HashMap<String, SyncSession> sessions = new HashMap<String, SyncSession>();
-    private static HashMap<String, ObjectServerSession> privateSessions = new HashMap<String, ObjectServerSession>();
-
-    static synchronized void removeSession(SyncSession session) {
-        if (session == null) {
-            return;
-        }
-
-        Iterator<Map.Entry<String, SyncSession>> it = sessions.entrySet().iterator();
-        while (it.hasNext()) {
-            Map.Entry<String, SyncSession> entry = it.next();
-            if (entry.getValue().equals(session)) {
-                it.remove();
-                break;
-            }
-        }
-    }
-
-    public static synchronized void addSession(SyncSession publicSession, ObjectServerSession internalSession) {
-        String localPath = publicSession.getConfiguration().getPath();
-        sessions.put(localPath, publicSession);
-        privateSessions.put(localPath, internalSession);
-    }
-
-    public static synchronized boolean hasSession(SyncConfiguration config) {
-        String localPath = config.getPath();
-        return sessions.containsKey(localPath);
-    }
-
-    public static synchronized SyncSession getPublicSession(SyncConfiguration config) {
-        String localPath = config.getPath();
-        return sessions.get(localPath);
-    }
-
-    public static synchronized ObjectServerSession getPrivateSession(SyncSession session) {
-        String localPath = session.getConfiguration().getPath();
-        return privateSessions.get(localPath);
-    }
-
-    public static Collection<ObjectServerSession> getAllSessions() {
-        return privateSessions.values();
-    }
-
-}
-
-
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java
deleted file mode 100644
index f1b58008b0..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/StoppedState.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import io.realm.ObjectServerError;
-import io.realm.SyncSession;
-
-/**
- * STOPPED State. This is the final state for a {@link SyncSession}. After this, all actions will throw an
- * {@link IllegalStateException}.
- */
-class StoppedState extends FsmState {
-
-    @Override
-    public void onEnterState() {
-        session.stopNativeSession();
-        session.getSyncPolicy().onSessionStopped(session);
-    }
-
-    @Override
-    protected void onExitState() {
-        // Cannot exit this state
-    }
-
-    @Override
-    public void onStart() {
-        // To harsh to to throw here as any SyncPolicy might not have been made aware
-        // that the Session is stopped. Just ignore the call instead.
-    }
-
-    @Override
-    public void onBind() {
-        // To harsh to to throw here as any SyncPolicy might not have been made aware
-        // that the Session is stopped. Just ignore the call instead.
-    }
-
-    @Override
-    public void onUnbind() {
-        // To harsh to to throw here as any SyncPolicy might not have been made aware
-        // that the Session is stopped. Just ignore the call instead.
-    }
-
-    @Override
-    public void onStop() {
-        // To harsh to to throw here as any SyncPolicy might not have been made aware
-        // that the Session is stopped. Just ignore the call instead.
-    }
-
-    @Override
-    public void onError(ObjectServerError error) {
-        // Ignore all errors at this state. None of them would have any impact.
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java b/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java
deleted file mode 100644
index 3471357544..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/objectserver/UnboundState.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.objectserver;
-
-import io.realm.ObjectServerError;
-import io.realm.SessionState;
-
-/**
- * UNBOUND State. This is the default state after a session has been started and no attempt at binding the local Realm
- * has been made.
- */
-class UnboundState extends FsmState {
-
-    @Override
-    public void onEnterState() {
-        // We can enter this state from multiple states which might have had an active session.
-        // In those cases cleanup any old native session
-        session.stopNativeSession();
-
-        // Create the native session so it is ready to be bound.
-        session.createNativeSession();
-    }
-
-    @Override
-    protected void onExitState() {
-        // Do nothing.
-    }
-
-    @Override
-    public void onBind() {
-        gotoNextState(SessionState.BINDING);
-    }
-
-    @Override
-    public void onError(ObjectServerError error) {
-        // Ignore all errors at this state. None of them would have any impact.
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java
deleted file mode 100644
index 6f4b784181..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/AutomaticSyncPolicy.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.syncpolicy;
-
-import io.realm.ObjectServerError;
-import io.realm.internal.objectserver.ObjectServerSession;
-
-/**
- * This SyncPolicy will automatically start synchronizing changes to a Realm as soon as it is opened.
- */
-public class AutomaticSyncPolicy implements SyncPolicy {
-
-    private Long lastError = null;
-    private int recurringErrors = 0;
-
-    @Override
-    public void onRealmOpened(ObjectServerSession session) {
-        session.bind(); // Bind Realm first time it is opened.
-    }
-
-    @Override
-    public void onRealmClosed(ObjectServerSession session) {
-        // TODO In order to preserve resources we should ideally close the session as well, but first
-        // we want to make sure that all local changes have been synchronized to the remote Realm.
-    }
-
-    @Override
-    public void onSessionCreated(ObjectServerSession session) {
-        session.start();
-    }
-
-    @Override
-    public void onSessionStopped(ObjectServerSession session) {
-        // Do nothing
-    }
-
-    @Override
-    public boolean onError(ObjectServerSession session, ObjectServerError error) {
-        switch(error.getCategory()) {
-            case FATAL:
-                return false;   // Report all fatal errors to the user
-            case RECOVERABLE:
-                return rebind(session);
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Returns {@code true} if we decide to rebind, {@code false} if the error was determined to no longer be solvable.
-     */
-    private boolean rebind(ObjectServerSession session) {
-        // Track all calls to rebind(). If some error reported as RECOVERABLE keeps happening, we need to abort to
-        // prevent run-away sessions. Right now we treat an error as recurring if it happens within 3 seconds of each
-        // other. After 5 of such errors we terminate the session.
-        //
-        // Standard IO errors are already handled using incremental backoff by e.g the AUTHENTICATING state, so
-        // re-occurring errors at this level are more serious.
-        long now = System.currentTimeMillis();
-        if (lastError - now < 3000) {
-            recurringErrors++;
-        } else {
-            recurringErrors = 1;
-        }
-        lastError = now;
-
-        if (recurringErrors == 5) {
-            session.stop(); // Abort session, some error that should be temporary keeps happening.
-            return false;
-        } else {
-            session.bind();
-            return true;
-        }
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null || getClass() != o.getClass()) return false;
-
-        AutomaticSyncPolicy that = (AutomaticSyncPolicy) o;
-
-        if (recurringErrors != that.recurringErrors) return false;
-        return lastError != null ? lastError.equals(that.lastError) : that.lastError == null;
-    }
-
-    @Override
-    public int hashCode() {
-        int result = lastError != null ? lastError.hashCode() : 0;
-        result = 31 * result + recurringErrors;
-        return result;
-    }
-}
diff --git a/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java b/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java
deleted file mode 100644
index ae14b6af3e..0000000000
--- a/realm/realm-library/src/objectServer/java/io/realm/internal/syncpolicy/SyncPolicy.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright 2016 Realm Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package io.realm.internal.syncpolicy;
-
-import io.realm.ObjectServerError;
-import io.realm.SyncSession;
-import io.realm.SyncConfiguration;
-import io.realm.internal.objectserver.ObjectServerSession;
-
-/**
- * Interface describing a given synchronization policy with the Realm Object Server.
- * <p>
- * The sole purpose of classes implementing this interface is to call {@link ObjectServerSession#bind()} and
- * {@link ObjectServerSession#unbind()} as needed, which will control when changes are synchronized between a local and
- * remote Realm.
- *
- * The SyncPolicy is not responsible for managing the lifecycle of the {@link ObjectServerSession} in general. So any
- * implementation of this class should avoid calling {@link ObjectServerSession#stop()} and
- * {@link ObjectServerSession#start()}.
- *
- * If a session is stopped, {@link ObjectServerSession#unbind()} is automatically called and any further calls to
- * {@link ObjectServerSession#bind()} and {@link ObjectServerSession#unbind()} are ignored.
- * {@link #onSessionStopped(ObjectServerSession)} ()} will then be called so the sync policy have a chance to clean up
- * any resources it might be using.
- */
-// Internal until we are sure this is the API we want
-public interface SyncPolicy {
-
-    /**
-     * Called when the session object is created. At this point it is possible to register any relevant error and event
-     * listeners in either the Android framework or for the session itself.
-     *
-     * {@link ObjectServerSession#start()} will be automatically called after this method.
-     *
-     * @param session the {@link SyncSession} just created. It has not yet been started.
-     */
-    void onSessionCreated(ObjectServerSession session);
-
-    /**
-     * The {@link ObjectServerSession} has been stopped and will ignore any further calls to
-     * {@link ObjectServerSession#bind()} and {@link ObjectServerSession#unbind()}. All external resources should be
-     * cleaned up.
-     *
-     * @param session {@link ObjectServerSession} that has been stopped.
-     */
-    void onSessionStopped(ObjectServerSession session);
-
-    /**
-     * Called the first time a Realm is opened on any thread.
-     *
-     * @param session {@link ObjectServerSession} associated with this Realm.
-     */
-    void onRealmOpened(ObjectServerSession session);
-
-    /**
-     * Called when the last Realm instance across all threads have been closed.
-     *
-     * @param session {@link ObjectServerSession} associated with this Realm.
-     */
-    void onRealmClosed(ObjectServerSession session);
-
-    /**
-     * Called if an error occurred in the underlying session. In many cases this has caused the session to become
-     * unbound.
-     *
-     * @param error {@link ObjectServerError} object describing the error.
-     * @return {@code true} if the error was handled, or {@code false} if it should be propagated further out to the
-     * SyncConfigurations error handler.
-     *
-     * This method is always called from a background thread, never the UI thread.
-     *
-     * @see SyncConfiguration.Builder#errorHandler(SyncSession.ErrorHandler)
-     */
-    boolean onError(ObjectServerSession session, ObjectServerError error);
-}
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
index fb7f68f387..ae1cda7ac7 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/AuthTests.java
@@ -9,18 +9,20 @@
 import io.realm.ErrorCode;
 import io.realm.ObjectServerError;
 import io.realm.Realm;
-import io.realm.SessionState;
 import io.realm.SyncConfiguration;
 import io.realm.SyncCredentials;
 import io.realm.SyncManager;
 import io.realm.SyncSession;
 import io.realm.SyncUser;
+import io.realm.log.LogLevel;
+import io.realm.log.RealmLog;
 import io.realm.objectserver.utils.Constants;
 import io.realm.objectserver.utils.UserFactory;
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 
 import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
 @RunWith(AndroidJUnit4.class)
@@ -61,7 +63,7 @@ public void onError(ObjectServerError error) {
     @RunTestInLooperThread
     public void login_withAccessToken() {
         SyncUser admin = UserFactory.createAdminUser(Constants.AUTH_URL);
-        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken(), "custom-admin-user");
+        SyncCredentials credentials = SyncCredentials.accessToken(admin.getAccessToken().value(), "custom-admin-user");
         SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
             @Override
             public void onSuccess(SyncUser user) {
@@ -82,7 +84,7 @@ public void onError(SyncSession session, ObjectServerError error) {
                 looperThread.postRunnableDelayed(new Runnable() {
                     @Override
                     public void run() {
-                        assertEquals(SessionState.BOUND, SyncManager.getSession(config).getState());
+                        assertTrue(SyncManager.getSession(config).getUser().isValid());
                         looperThread.testComplete();
                     }
                 }, 1000);
@@ -100,6 +102,10 @@ public void onError(ObjectServerError error) {
     @Test
     @RunTestInLooperThread
     public void loginAsync_errorHandlerThrows() {
+        // set log level to info to make sure the IllegalArgumentException
+        // thrown in the test is visible in Logcat
+        final int defaultLevel = RealmLog.getLevel();
+        RealmLog.setLevel(LogLevel.INFO);
         SyncCredentials credentials = SyncCredentials.usernamePassword("IWantToHackYou", "GeneralPassword", false);
         SyncUser.loginAsync(credentials, Constants.AUTH_URL, new SyncUser.Callback() {
             @Override
@@ -114,12 +120,12 @@ public void onError(ObjectServerError error) {
             }
         });
 
-        try {
-            Thread.sleep(2000);
-        } catch (InterruptedException e) {
-            e.printStackTrace();
-            fail();
-        }
-        looperThread.testComplete();
+        looperThread.postRunnableDelayed(new Runnable() {
+            @Override
+            public void run() {
+                RealmLog.setLevel(defaultLevel);
+                looperThread.testComplete();
+            }
+        }, 1000);
     }
 }
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
index b63456b79d..8770019e59 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/utils/HttpUtils.java
@@ -16,17 +16,12 @@
 
 package io.realm.objectserver.utils;
 
-import android.support.test.InstrumentationRegistry;
-
 import java.io.IOException;
 
-import io.realm.Realm;
 import io.realm.log.RealmLog;
 import okhttp3.Headers;
-import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
-import okhttp3.RequestBody;
 import okhttp3.Response;
 
 /**
diff --git a/version.txt b/version.txt
index 855ff9501e..0628777500 100644
--- a/version.txt
+++ b/version.txt
@@ -1 +1 @@
-2.4.0-SNAPSHOT
\ No newline at end of file
+3.1.0-SNAPSHOT
\ No newline at end of file
