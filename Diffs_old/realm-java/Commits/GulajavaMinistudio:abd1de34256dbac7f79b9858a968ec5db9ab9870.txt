diff --git a/CHANGELOG.md b/CHANGELOG.md
index 36bb3c07ee..42bed8de7e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,9 +3,13 @@
 ### Deprecated
 
 * Support for mips devices are deprecated.
+* `RealmQuery.findAllSorted()` and `RealmQuery.findAllSortedAsync()` variants in favor of predicate `RealmQuery.sort().findAll()`.
+* `RealmQuery.distinct()` and `RealmQuery.distinctAsync()` variants in favor of predicate `RealmQuery.distinctValues().findAll()`
 
 ### Enhancements
 
+* New query predicate: `sort()`.
+* New query predicate: `distinctValues()`. Will be renamed to `distinct` in next major version.
 * The Realm annotation processor now has a stable output when there are no changes to model classes, improving support for incremental compilers (#5567).
 
 ### Bug Fixes
@@ -25,6 +29,7 @@
 
 * Added missing `toString()` for the implementation of `OrderedCollectionChangeSet`.
 * Sync queries are evaluated immediately to solve the performance issue when the query results are huge, `RealmResults.size()` takes too long time (#5387).
+* Correctly close the Realm instance if an exception was thrown while opening it. This avoids `IllegalStateException` when deleting the Realm in the catch block (#5570).
 
 ### Internal
 
diff --git a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
index 42ece9c78d..3b1142cfc0 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/BulkInsertTests.java
@@ -258,7 +258,7 @@ public void insert_cyclicType() {
         realm.insert(Arrays.asList(oneCyclicType, anotherCyclicType));
         realm.commitTransaction();
 
-        RealmResults<CyclicType> realmObjects = realm.where(CyclicType.class).findAllSorted(CyclicType.FIELD_NAME);
+        RealmResults<CyclicType> realmObjects = realm.where(CyclicType.class).sort(CyclicType.FIELD_NAME).findAll();
         assertNotNull(realmObjects);
         assertEquals(2, realmObjects.size());
         assertEquals("One", realmObjects.get(0).getName());
@@ -276,7 +276,7 @@ public void insertOrUpdate_cyclicType() {
         realm.insertOrUpdate(Arrays.asList(oneCyclicType, anotherCyclicType));
         realm.commitTransaction();
 
-        RealmResults<CyclicTypePrimaryKey> realmObjects = realm.where(CyclicTypePrimaryKey.class).findAllSorted("name");
+        RealmResults<CyclicTypePrimaryKey> realmObjects = realm.where(CyclicTypePrimaryKey.class).sort("name").findAll();
         assertNotNull(realmObjects);
         assertEquals(2, realmObjects.size());
         assertEquals("One", realmObjects.get(0).getName());
@@ -694,7 +694,7 @@ public void insertOrUpdate_mixingNoPrimaryKeyAndPrimaryKeyModels() {
         realm.insertOrUpdate(objA_no_pk);
         realm.commitTransaction();
 
-        all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAllSorted("columnString");
+        all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).sort("columnString").findAll();
         assertEquals(2, all.size());
         assertEquals("A", all.get(0).getColumnString());
         assertEquals(8, all.get(0).getColumnInt());
@@ -735,7 +735,9 @@ public void insertOrUpdate_mixingPrimaryAndNoPrimaryKeyList() {
         realm.insertOrUpdate(objects);
         realm.commitTransaction();
 
-        RealmResults<NoPrimaryKeyWithPrimaryKeyObjectRelation> all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class).findAllSorted("columnString", Sort.DESCENDING);
+        RealmResults<NoPrimaryKeyWithPrimaryKeyObjectRelation> all = realm.where(NoPrimaryKeyWithPrimaryKeyObjectRelation.class)
+                .sort("columnString", Sort.DESCENDING)
+                .findAll();
         assertEquals(2, all.size());
         assertEquals("B", all.get(0).getColumnString());
         assertEquals("A", all.get(1).getColumnString());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
index c45a8cd2b9..64cb64ede3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/CollectionTests.java
@@ -98,7 +98,7 @@ protected void populateRealm(Realm realm, int objects) {
 
             // Adds all items to the RealmList on the first object.
             AllJavaTypes firstObj = realm.where(AllJavaTypes.class).equalTo(AllJavaTypes.FIELD_ID, 0).findFirst();
-            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_ID, Sort.ASCENDING);
+            RealmResults<AllJavaTypes> listData = realm.where(AllJavaTypes.class).sort(AllJavaTypes.FIELD_ID, Sort.ASCENDING).findAll();
             RealmList<AllJavaTypes> list = firstObj.getFieldList();
             for (int i = 0; i < listData.size(); i++) {
                 list.add(listData.get(i));
@@ -202,7 +202,7 @@ protected void populatePartialNullRowsForNumericTesting(Realm realm) {
                     obj.setFieldString(arg);
                 }
                 realm.commitTransaction();
-                orderedCollection = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_STRING);
+                    orderedCollection = realm.where(AllJavaTypes.class).sort(AllJavaTypes.FIELD_STRING).findAll();
                 break;
 
             case REALMRESULTS_SNAPSHOT_LIST_BASE:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
index 7e8d36dd75..573c1e21d7 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/DynamicRealmTests.java
@@ -394,11 +394,12 @@ public void onChange(RealmResults<DynamicRealmObject> object) {
 
     @Test
     @RunTestInLooperThread
-    public void findAllSortedAsync() {
+    public void sort_async() {
         final DynamicRealm dynamicRealm = initializeDynamicRealm();
         final RealmResults<DynamicRealmObject> allTypes = dynamicRealm.where(AllTypes.CLASS_NAME)
                 .between(AllTypes.FIELD_LONG, 0, 4)
-                .findAllSortedAsync(AllTypes.FIELD_STRING, Sort.DESCENDING);
+                .sort(AllTypes.FIELD_STRING, Sort.DESCENDING)
+                .findAllAsync();
         assertFalse(allTypes.isLoaded());
         assertEquals(0, allTypes.size());
 
@@ -428,7 +429,7 @@ private DynamicRealm initializeDynamicRealm() {
 
     @Test
     @RunTestInLooperThread
-    public void findAllSortedAsync_usingMultipleFields() {
+    public void sort_async_usingMultipleFields() {
         final DynamicRealm dynamicRealm = initializeDynamicRealm();
 
         dynamicRealm.setAutoRefresh(false);
@@ -448,18 +449,20 @@ public void findAllSortedAsync_usingMultipleFields() {
 
         // Sorts first set by using: String[ASC], Long[DESC].
         final RealmResults<DynamicRealmObject> realmResults1 = dynamicRealm.where(AllTypes.CLASS_NAME)
-                .findAllSortedAsync(
+                .sort(
                         new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
                         new Sort[]{Sort.ASCENDING, Sort.DESCENDING}
-                );
+                )
+                .findAllAsync();
 
         // Sorts second set by using: String[DESC], Long[ASC].
         final RealmResults<DynamicRealmObject> realmResults2 = dynamicRealm.where(AllTypes.CLASS_NAME)
                 .between(AllTypes.FIELD_LONG, 0, 5)
-                .findAllSortedAsync(
+                .sort(
                         new String[]{AllTypes.FIELD_STRING, AllTypes.FIELD_LONG},
                         new Sort[]{Sort.DESCENDING, Sort.ASCENDING}
-                );
+                )
+                .findAllAsync();
 
         final Runnable signalCallbackDone = new Runnable() {
             final AtomicInteger callbacksDone = new AtomicInteger(2);
diff --git a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
index 5b8cf56418..bd1ed35c67 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/IOSRealmTests.java
@@ -79,7 +79,7 @@ public void iOSDataTypes() throws IOException {
             configFactory.copyRealmFromAssets(context,
                     "ios/" + iosVersion + "-alltypes.realm", REALM_NAME);
             realm = Realm.getDefaultInstance();
-            RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).findAllSorted("id", Sort.ASCENDING);
+            RealmResults<IOSAllTypes> result = realm.where(IOSAllTypes.class).sort("id", Sort.ASCENDING).findAll();
             // Verifies metadata.
             Table table = realm.getTable(IOSAllTypes.class);
             assertEquals("id", OsObjectStore.getPrimaryKeyForObject(realm.getSharedRealm(), IOSAllTypes.CLASS_NAME));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
index d690a3fb44..d609d7fc8e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/LinkingObjectsManagedTests.java
@@ -678,7 +678,7 @@ public void query_multipleReferencesWithDistinct() {
 
         assertEquals(2, child.getListParents().size());
 
-        RealmResults<AllJavaTypes> distinctParents = child.getListParents().where().distinct("fieldId");
+        RealmResults<AllJavaTypes> distinctParents = child.getListParents().where().distinctValues("fieldId").findAll();
         assertEquals(1, distinctParents.size());
         assertTrue(child.getListParents().contains(parent));
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
index 366d4395f9..5fa3c49f3e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedOrderedRealmCollectionTests.java
@@ -698,7 +698,7 @@ public void deleteFirstFromRealm() {
                     dog.setName("Dog " + i);
                 }
                 realm.commitTransaction();
-                orderedCollection = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
+                orderedCollection = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAll();
                 break;
 
             default:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
index b27d7b3796..7b02a12d96 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/ManagedRealmCollectionTests.java
@@ -138,7 +138,8 @@ public void tearDown() {
             case REALMRESULTS_SNAPSHOT_RESULTS_BASE:
             case REALMRESULTS:
                 orderedCollection = realm.where(AllJavaTypes.class)
-                        .findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                        .sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING)
+                        .findAll();
                 break;
 
             default:
@@ -341,15 +342,15 @@ public void where_findAll_size() {
     }
 
     @Test
-    public void where_findAllSorted() {
-        RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+    public void where_sort() {
+        RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class).sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING).findAll();
         assertEquals(TEST_SIZE, results.size());
         //noinspection ConstantConditions
         assertEquals(0, results.first().getFieldLong());
         //noinspection ConstantConditions
         assertEquals(TEST_SIZE - 1, results.last().getFieldLong());
 
-        RealmResults<AllJavaTypes> reverseList = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.DESCENDING);
+        RealmResults<AllJavaTypes> reverseList = realm.where(AllJavaTypes.class).sort(AllJavaTypes.FIELD_LONG, Sort.DESCENDING).findAll();
         assertEquals(TEST_SIZE, reverseList.size());
         //noinspection ConstantConditions
         assertEquals(0, reverseList.last().getFieldLong());
@@ -357,8 +358,7 @@ public void where_findAllSorted() {
         assertEquals(TEST_SIZE - 1, reverseList.first().getFieldLong());
 
         try {
-            realm.where(AllJavaTypes.class).findAllSorted("invalid",
-                    Sort.DESCENDING);
+            realm.where(AllJavaTypes.class).sort("invalid", Sort.DESCENDING).findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
index 1c3788f092..4b5cf29e3d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedCollectionChangeSetTests.java
@@ -197,7 +197,7 @@ private void moveObjects(Realm realm, int originAge, int newAge) {
     private void registerCheckListener(Realm realm, final ChangesCheck changesCheck) {
         switch (type) {
             case REALM_RESULTS:
-                RealmResults<Dog> results = realm.where(Dog.class).findAllSorted(Dog.FIELD_AGE);
+                RealmResults<Dog> results = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAll();
                 looperThread.keepStrongReference(results);
                 results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
                     @Override
@@ -453,7 +453,7 @@ public void emptyChangeSet_findAllAsync() {
 
         Realm realm = looperThread.getRealm();
         populateData(realm, 10);
-        final RealmResults<Dog> results = realm.where(Dog.class).findAllSortedAsync(Dog.FIELD_AGE);
+        final RealmResults<Dog> results = realm.where(Dog.class).sort(Dog.FIELD_AGE).findAllAsync();
         looperThread.keepStrongReference(results);
         results.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Dog>>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
index b173530c82..a5d15ad8e1 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/OrderedRealmCollectionIteratorTests.java
@@ -99,7 +99,9 @@ public void tearDown() {
 
             case UNMANAGED_REALMLIST:
                 populateRealm(realm, sampleSize);
-                RealmResults<AllJavaTypes> objects = realm.where(AllJavaTypes.class).findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                RealmResults<AllJavaTypes> objects = realm.where(AllJavaTypes.class)
+                        .sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING)
+                        .findAll();
                 RealmList<AllJavaTypes> inMemoryList = new RealmList<AllJavaTypes>();
                 inMemoryList.addAll(objects);
                 return inMemoryList;
@@ -108,7 +110,8 @@ public void tearDown() {
             case REALMRESULTS:
                 populateRealm(realm, sampleSize);
                 orderedCollection = realm.where(AllJavaTypes.class)
-                        .findAllSorted(AllJavaTypes.FIELD_LONG, Sort.ASCENDING);
+                        .sort(AllJavaTypes.FIELD_LONG, Sort.ASCENDING)
+                        .findAll();
                 break;
 
             default:
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
index 770337505e..6d7a320cd2 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmAsyncQueryTests.java
@@ -20,7 +20,6 @@
 import android.support.test.rule.UiThreadTestRule;
 import android.support.test.runner.AndroidJUnit4;
 
-import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -769,13 +768,14 @@ public void onChange(AllTypes element) {
     // similar UC as #testFindAllAsync using 'findAllSorted'
     @Test
     @RunTestInLooperThread
-    public void findAllSortedAsync() throws Throwable {
+    public void sort_async() throws Throwable {
         final Realm realm = looperThread.getRealm();
         populateTestRealm(realm, 10);
 
         final RealmResults<AllTypes> results = realm.where(AllTypes.class)
                 .between("columnLong", 0, 4)
-                .findAllSortedAsync("columnString", Sort.DESCENDING);
+                .sort("columnString", Sort.DESCENDING)
+                .findAllAsync();
 
         assertFalse(results.isLoaded());
         assertEquals(0, results.size());
@@ -879,16 +879,16 @@ public void run() {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync() throws Throwable {
+    public void distinct_async() throws Throwable {
         Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 25;
         final long numberOfObjects = 10; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync("indexBoolean");
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctAsync("indexLong");
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctAsync("indexDate");
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues("indexBoolean").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctValues("indexLong").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctValues("indexDate").findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctValues("indexString").findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -955,7 +955,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
 
     @Test
     @RunTestInLooperThread()
-    public void distinctAsync_rememberQueryParams() {
+    public void distinct_async_rememberQueryParams() {
         final Realm realm = looperThread.getRealm();
         realm.beginTransaction();
         final int TEST_SIZE = 10;
@@ -966,7 +966,8 @@ public void distinctAsync_rememberQueryParams() {
 
         RealmResults<AllJavaTypes> results = realm.where(AllJavaTypes.class)
                 .notEqualTo(AllJavaTypes.FIELD_ID, TEST_SIZE / 2)
-                .distinctAsync(AllJavaTypes.FIELD_ID);
+                .distinctValues(AllJavaTypes.FIELD_ID)
+                .findAllAsync();
 
         results.addChangeListener(new RealmChangeListener<RealmResults<AllJavaTypes>>() {
             @Override
@@ -987,13 +988,17 @@ public void distinctAsync_notIndexedFields() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL)
+                .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG);
+                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_LONG)
+                .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE);
+                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_DATE)
+                .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING)
+                .findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -1067,7 +1072,7 @@ public void distinctAsync_noneExistingField() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinctAsync("doesNotExist");
+            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAllAsync();
             fail();
         } catch (IllegalArgumentException ignored) {
             looperThread.testComplete();
@@ -1094,10 +1099,10 @@ public void batchUpdateDifferentTypeOfQueries() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AllTypes> findAllAsync = realm.where(AllTypes.class).findAllAsync();
-        RealmResults<AllTypes> findAllSorted = realm.where(AllTypes.class).findAllSortedAsync("columnString", Sort.ASCENDING);
-        RealmResults<AllTypes> findAllSortedMulti = realm.where(AllTypes.class).findAllSortedAsync(new String[]{"columnString", "columnLong"},
-                new Sort[]{Sort.ASCENDING, Sort.DESCENDING});
-        RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinctAsync("indexString");
+        RealmResults<AllTypes> findAllSorted = realm.where(AllTypes.class).sort("columnString", Sort.ASCENDING).findAllAsync();
+        RealmResults<AllTypes> findAllSortedMulti = realm.where(AllTypes.class).sort(new String[]{"columnString", "columnLong"},
+                new Sort[]{Sort.ASCENDING, Sort.DESCENDING}).findAllAsync();
+        RealmResults<AnnotationIndexTypes> findDistinct = realm.where(AnnotationIndexTypes.class).distinctValues("indexString").findAllAsync();
 
         looperThread.keepStrongReference(findAllAsync);
         looperThread.keepStrongReference(findAllSorted);
@@ -1264,7 +1269,7 @@ public void badVersion_syncTransaction() throws NoSuchFieldException, IllegalAcc
         Realm realm = looperThread.getRealm();
 
         // 1. Makes sure that async query is not started.
-        final RealmResults<AllTypes> result = realm.where(AllTypes.class).findAllSortedAsync(AllTypes.FIELD_STRING);
+        final RealmResults<AllTypes> result = realm.where(AllTypes.class).sort(AllTypes.FIELD_STRING).findAllAsync();
         looperThread.keepStrongReference(result);
         result.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
index 91e0d6945b..2c56308eca 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmMigrationTests.java
@@ -777,7 +777,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertNotNull(objectSchema);
         assertEquals(PrimaryKeyAsString.FIELD_PRIMARY_KEY, objectSchema.getPrimaryKey());
         RealmResults<PrimaryKeyAsString> results = realm.where(PrimaryKeyAsString.class)
-                .findAllSorted(PrimaryKeyAsString.FIELD_ID);
+                .sort(PrimaryKeyAsString.FIELD_ID)
+                .findAll();
         assertEquals(2, results.size());
         assertEquals("string0", results.get(0).getName());
         assertEquals("string1", results.get(1).getName());
@@ -822,7 +823,8 @@ public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
         assertNotNull(objectSchema);
         assertEquals(PrimaryKeyAsInteger.FIELD_ID, objectSchema.getPrimaryKey());
         RealmResults<PrimaryKeyAsInteger> results = realm.where(PrimaryKeyAsInteger.class)
-                .findAllSorted(PrimaryKeyAsInteger.FIELD_ID);
+                .sort(PrimaryKeyAsInteger.FIELD_ID)
+                .findAll();
         assertEquals(2, results.size());
         assertEquals(0, results.get(0).getId());
         assertEquals(1, results.get(1).getId());
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
index 1bf59fdf2a..cbaae6111e 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmModelTests.java
@@ -125,7 +125,10 @@ public void copyToRealm() {
     public void copyFromRealm() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
-        AllTypesRealmModel realmObject = realm.where(AllTypesRealmModel.class).findAllSorted(AllTypesRealmModel.FIELD_LONG).first();
+        AllTypesRealmModel realmObject = realm.where(AllTypesRealmModel.class)
+                .sort(AllTypesRealmModel.FIELD_LONG)
+                .findAll()
+                .first();
         AllTypesRealmModel unmanagedObject = realm.copyFromRealm(realmObject);
         assertArrayEquals(realmObject.columnBinary, unmanagedObject.columnBinary);
         assertEquals(realmObject.columnString, unmanagedObject.columnString);
@@ -198,7 +201,7 @@ public void async_query() {
         Realm realm = looperThread.getRealm();
         populateTestRealm(realm, TEST_DATA_SIZE);
 
-        final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctAsync(AllTypesRealmModel.FIELD_STRING);
+        final RealmResults<AllTypesRealmModel> allTypesRealmModels = realm.where(AllTypesRealmModel.class).distinctValues(AllTypesRealmModel.FIELD_STRING).findAllAsync();
         looperThread.keepStrongReference(allTypesRealmModels);
         allTypesRealmModels.addChangeListener(new RealmChangeListener<RealmResults<AllTypesRealmModel>>() {
             @Override
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
index 6615bffa9b..039e411a32 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmObjectSchemaTests.java
@@ -919,7 +919,7 @@ private void setRequired_onPrimaryKeyField(boolean isRequired) {
             assertTrue(schema.hasPrimaryKey());
             assertTrue(schema.hasIndex(fieldName));
 
-            RealmResults<DynamicRealmObject> results = ((DynamicRealm)realm).where(className).findAllSorted(fieldName);
+            RealmResults<DynamicRealmObject> results = ((DynamicRealm)realm).where(className).sort(fieldName).findAll();
             assertEquals(2, results.size());
             if (fieldType == PrimaryKeyFieldType.STRING) {
                 assertEquals("1", results.get(0).getString(fieldName));
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
index c97668d62e..50467274cb 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmQueryTests.java
@@ -209,7 +209,6 @@ private void populateNoPrimaryKeyNullTypesRows() {
         IS_VALID,
         DISTINCT,
         DISTINCT_BY_MULTIPLE_FIELDS,
-        DISTINCT_ASYNC,
 
         SUM,
         AVERAGE,
@@ -221,14 +220,9 @@ private void populateNoPrimaryKeyNullTypesRows() {
 
         FIND_ALL,
         FIND_ALL_ASYNC,
-        FIND_ALL_SORTED,
-        FIND_ALL_SORTED_ASYNC,
-        FIND_ALL_SORTED_WITH_ORDER,
-        FIND_ALL_SORTED_ASYNC_WITH_ORDER,
-        FIND_ALL_SORTED_WITH_TWO_ORDERS,
-        FIND_ALL_SORTED_ASYNC_WITH_TWO_ORDERS,
-        FIND_ALL_SORTED_WITH_MANY_ORDERS,
-        FIND_ALL_SORTED_ASYNC_WITH_MANY_ORDERS,
+        SORT,
+        SORT_WITH_ORDER,
+        SORT_WITH_MANY_ORDERS,
 
         FIND_FIRST,
         FIND_FIRST_ASYNC,
@@ -324,9 +318,8 @@ private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfined
             case IS_NOT_EMPTY: query.isNotEmpty( AllJavaTypes.FIELD_STRING); break;
 
             case IS_VALID: query.isValid(); break;
-            case DISTINCT: query.distinct(                    AllJavaTypes.FIELD_STRING); break;
-            case DISTINCT_BY_MULTIPLE_FIELDS: query.distinct( AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID); break;
-            case DISTINCT_ASYNC: query.distinctAsync(         AllJavaTypes.FIELD_STRING); break;
+            case DISTINCT: query.distinctValues(                    AllJavaTypes.FIELD_STRING); break;
+            case DISTINCT_BY_MULTIPLE_FIELDS: query.distinctValues( AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID); break;
 
             case SUM: query.sum(                  AllJavaTypes.FIELD_INT); break;
             case AVERAGE: query.average(          AllJavaTypes.FIELD_INT); break;
@@ -338,15 +331,9 @@ private static void callThreadConfinedMethod(RealmQuery<?> query, ThreadConfined
 
             case FIND_ALL: query.findAll(); break;
             case FIND_ALL_ASYNC: query.findAllAsync(); break;
-            case FIND_ALL_SORTED: query.findAllSorted(                             AllJavaTypes.FIELD_STRING); break;
-            case FIND_ALL_SORTED_ASYNC: query.findAllSortedAsync(                  AllJavaTypes.FIELD_STRING); break;
-            case FIND_ALL_SORTED_WITH_ORDER: query.findAllSorted(                  AllJavaTypes.FIELD_STRING, Sort.DESCENDING); break;
-            case FIND_ALL_SORTED_ASYNC_WITH_ORDER: query.findAllSortedAsync(       AllJavaTypes.FIELD_STRING, Sort.DESCENDING); break;
-            case FIND_ALL_SORTED_WITH_TWO_ORDERS: query.findAllSorted(             AllJavaTypes.FIELD_STRING, Sort.DESCENDING, AllJavaTypes.FIELD_ID, Sort.DESCENDING); break;
-            case FIND_ALL_SORTED_ASYNC_WITH_TWO_ORDERS: query.findAllSortedAsync(  AllJavaTypes.FIELD_STRING, Sort.DESCENDING, AllJavaTypes.FIELD_ID, Sort.DESCENDING); break;
-            case FIND_ALL_SORTED_WITH_MANY_ORDERS: query.findAllSorted(            new String[] {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID}, new Sort[] {Sort.DESCENDING, Sort.DESCENDING}); break;
-            case FIND_ALL_SORTED_ASYNC_WITH_MANY_ORDERS: query.findAllSortedAsync( new String[] {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID}, new Sort[] {Sort.DESCENDING, Sort.DESCENDING}); break;
-
+            case SORT: query.sort(AllJavaTypes.FIELD_STRING); break;
+            case SORT_WITH_ORDER: query.sort(AllJavaTypes.FIELD_STRING, Sort.ASCENDING); break;
+            case SORT_WITH_MANY_ORDERS: query.sort(new String[] {AllJavaTypes.FIELD_STRING, AllJavaTypes.FIELD_ID}, new Sort[] {Sort.DESCENDING, Sort.DESCENDING}); break;
             case FIND_FIRST: query.findFirst(); break;
             case FIND_FIRST_ASYNC: query.findFirstAsync(); break;
 
@@ -1266,36 +1253,42 @@ public void queryLink() {
         // Dog.weight has index 4 which is more than the total number of columns in Owner
         // This tests exposes a subtle error where the Owner table spec is used instead of Dog table spec.
         RealmResults<Dog> dogs = realm.where(Owner.class).findFirst().getDogs().where()
-                .findAllSorted("name", Sort.ASCENDING);
+                .sort("name", Sort.ASCENDING)
+                .findAll();
         Dog dog = dogs.where().equalTo("weight", 1d).findFirst();
         assertEquals(dog1, dog);
     }
 
     @Test
-    public void findAllSorted_multiFailures() {
+    public void sort_multiFailures() {
         // Zero fields specified.
         try {
-            realm.where(AllTypes.class).findAllSorted(new String[]{}, new Sort[]{});
+            realm.where(AllTypes.class).sort(new String[]{}, new Sort[]{}).findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // Number of fields and sorting orders don't match.
         try {
-            realm.where(AllTypes.class).findAllSorted(new String[]{AllTypes.FIELD_STRING},
-                    new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+            realm.where(AllTypes.class)
+                    .sort(new String[]{AllTypes.FIELD_STRING},new Sort[]{Sort.ASCENDING, Sort.ASCENDING})
+                    .findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
 
         // Null is not allowed.
         try {
-            realm.where(AllTypes.class).findAllSorted((String[]) null, null);
+            realm.where(AllTypes.class)
+                    .sort((String[]) null, null)
+                    .findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
         try {
-            realm.where(AllTypes.class).findAllSorted(new String[]{AllTypes.FIELD_STRING}, null);
+            realm.where(AllTypes.class)
+                    .sort(new String[]{AllTypes.FIELD_STRING}, null)
+                    .findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
@@ -1303,15 +1296,24 @@ public void findAllSorted_multiFailures() {
         // Non-existing field name.
         try {
             realm.where(AllTypes.class)
-                    .findAllSorted(new String[]{AllTypes.FIELD_STRING, "do-not-exist"},
-                            new Sort[]{Sort.ASCENDING, Sort.ASCENDING});
+                    .sort(new String[]{AllTypes.FIELD_STRING, "do-not-exist"}, new Sort[]{Sort.ASCENDING, Sort.ASCENDING})
+                    .findAll();
             fail();
         } catch (IllegalArgumentException ignored) {
         }
+
+        // Defining sort multiple times
+        try {
+            realm.where(AllTypes.class)
+                    .sort(AllTypes.FIELD_STRING)
+                    .sort(AllTypes.FIELD_STRING);
+            fail();
+        } catch (IllegalStateException ignored) {
+        }
     }
 
     @Test
-    public void findAllSorted_singleField() {
+    public void sort_singleField() {
         realm.beginTransaction();
         for (int i = 0; i < TEST_DATA_SIZE; i++) {
             AllTypes allTypes = realm.createObject(AllTypes.class);
@@ -1320,7 +1322,8 @@ public void findAllSorted_singleField() {
         realm.commitTransaction();
 
         RealmResults<AllTypes> sortedList = realm.where(AllTypes.class)
-                .findAllSorted(new String[]{AllTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING});
+                .sort(new String[]{AllTypes.FIELD_LONG}, new Sort[]{Sort.DESCENDING})
+                .findAll();
         assertEquals(TEST_DATA_SIZE, sortedList.size());
         assertEquals(TEST_DATA_SIZE - 1, sortedList.first().getColumnLong());
         assertEquals(0, sortedList.last().getColumnLong());
@@ -2883,21 +2886,23 @@ public void execute(Realm realm) {
     }
 
     @Test
-    public void findAllSorted_onSubObjectField() {
+    public void sort_onSubObjectField() {
         populateTestRealm(realm, TEST_DATA_SIZE);
         RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .findAllSorted(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE);
+                .sort(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE)
+                .findAll();
         assertEquals(0, results.get(0).getColumnRealmObject().getAge());
         assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
     }
 
     @Test
     @RunTestInLooperThread
-    public void findAllSortedAsync_onSubObjectField() {
+    public void sort_async_onSubObjectField() {
         Realm realm = looperThread.getRealm();
         populateTestRealm(realm, TEST_DATA_SIZE);
         RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .findAllSortedAsync(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE);
+                .sort(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE)
+                .findAllAsync();
         looperThread.keepStrongReference(results);
         results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
             @Override
@@ -2924,7 +2929,7 @@ public void findAll_indexedCaseInsensitiveFields() {
     }
 
     @Test
-    public void findAllSorted_listOnSubObjectField() {
+    public void sort_listOnSubObjectField() {
         String[] fieldNames = new String[2];
         fieldNames[0] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
         fieldNames[1] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
@@ -2935,37 +2940,12 @@ public void findAllSorted_listOnSubObjectField() {
 
         populateTestRealm(realm, TEST_DATA_SIZE);
         RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .findAllSorted(fieldNames, sorts);
+                .sort(fieldNames, sorts)
+                .findAll();
         assertEquals(0, results.get(0).getColumnRealmObject().getAge());
         assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
     }
 
-    @Test
-    @RunTestInLooperThread
-    public void findAllSortedAsync_listOnSubObjectField() {
-        Realm realm = looperThread.getRealm();
-        String[] fieldNames = new String[2];
-        fieldNames[0] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
-        fieldNames[1] = AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_AGE;
-
-        Sort[] sorts = new Sort[2];
-        sorts[0] = Sort.ASCENDING;
-        sorts[1] = Sort.ASCENDING;
-
-        populateTestRealm(realm, TEST_DATA_SIZE);
-        RealmResults<AllTypes> results = realm.where(AllTypes.class)
-                .findAllSortedAsync(fieldNames, sorts);
-        looperThread.keepStrongReference(results);
-        results.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
-            @Override
-            public void onChange(RealmResults<AllTypes> results) {
-                assertEquals(0, results.get(0).getColumnRealmObject().getAge());
-                assertEquals(TEST_DATA_SIZE - 1, results.get(TEST_DATA_SIZE - 1).getColumnRealmObject().getAge());
-                looperThread.testComplete();
-            }
-        });
-    }
-
     // RealmQuery.distinct(): requires indexing, and type = boolean, integer, date, string.
     private void populateForDistinct(Realm realm, long numberOfBlocks, long numberOfObjects, boolean withNull) {
         realm.beginTransaction();
@@ -3002,10 +2982,10 @@ public void distinct() {
         final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL);
+        RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL).findAll();
         assertEquals(2, distinctBool.size());
         for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
             assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
@@ -3017,11 +2997,18 @@ public void distinct_withNullValues() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         for (String field : new String[]{AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
             assertEquals(field, 1, distinct.size());
         }
     }
 
+    @Test(expected = IllegalStateException.class)
+    public void distinct_failIfAppliedMultipleTimes() {
+        realm.where(AnnotationIndexTypes.class)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE);
+    }
+
     @Test
     public void distinct_notIndexedFields() {
         final long numberOfBlocks = 3;
@@ -3029,11 +3016,12 @@ public void distinct_notIndexedFields() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class)
-                .distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL);
+                .distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_BOOL)
+                .findAll();
         assertEquals(2, distinctBool.size());
         for (String field : new String[]{AnnotationIndexTypes.FIELD_NOT_INDEX_LONG,
                 AnnotationIndexTypes.FIELD_NOT_INDEX_DATE, AnnotationIndexTypes.FIELD_NOT_INDEX_STRING}) {
-            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinct(field);
+            RealmResults<AnnotationIndexTypes> distinct = realm.where(AnnotationIndexTypes.class).distinctValues(field).findAll();
             assertEquals(field, numberOfBlocks, distinct.size());
         }
     }
@@ -3045,7 +3033,8 @@ public void distinct_doesNotExist() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinct("doesNotExist");
+            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAll();
+            fail();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3056,7 +3045,7 @@ public void distinct_invalidTypes() {
 
         for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
             try {
-                realm.where(AllTypes.class).distinct(field);
+                realm.where(AllTypes.class).distinctValues(field).findAll();
                 fail(field);
             } catch (IllegalArgumentException ignored) {
             }
@@ -3071,7 +3060,9 @@ public void distinct_indexedLinkedFields() {
 
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
             try {
-                realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                realm.where(AnnotationIndexTypes.class)
+                        .distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field)
+                        .findAll();
                 fail("Unsupported Index" + field + " linked field");
             } catch (IllegalArgumentException ignored) {
             }
@@ -3086,7 +3077,9 @@ public void distinct_notIndexedLinkedFields() {
 
         for (String field : AnnotationIndexTypes.NOT_INDEX_FIELDS) {
             try {
-                realm.where(AnnotationIndexTypes.class).distinct(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                realm.where(AnnotationIndexTypes.class)
+                        .distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field)
+                        .findAll();
                 fail("Unsupported notIndex" + field + " linked field");
             } catch (IllegalArgumentException ignored) {
             }
@@ -3098,24 +3091,26 @@ public void distinct_invalidTypesLinkedFields() {
         populateForDistinctInvalidTypesLinked(realm);
 
         try {
-            realm.where(AllJavaTypes.class).distinct(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
+            realm.where(AllJavaTypes.class)
+                    .distinctValues(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY)
+                    .findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync() throws Throwable {
+    public void distinct_async() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(4);
         final Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 3;
         final long numberOfObjects = 3; // Must be greater than 1
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
-        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_BOOL);
-        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_LONG);
-        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
-        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+        final RealmResults<AnnotationIndexTypes> distinctBool = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctLong = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_LONG).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE).findAllAsync();
+        final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING).findAllAsync();
 
         assertFalse(distinctBool.isLoaded());
         assertTrue(distinctBool.isValid());
@@ -3181,7 +3176,7 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_withNullValues() throws Throwable {
+    public void distinct_async_withNullValues() throws Throwable {
         final AtomicInteger changeListenerCalled = new AtomicInteger(2);
         final Realm realm = looperThread.getRealm();
         final long numberOfBlocks = 3;
@@ -3189,9 +3184,11 @@ public void distinctAsync_withNullValues() throws Throwable {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         final RealmResults<AnnotationIndexTypes> distinctDate = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_DATE);
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE)
+                .findAllAsync();
         final RealmResults<AnnotationIndexTypes> distinctString = realm.where(AnnotationIndexTypes.class)
-                .distinctAsync(AnnotationIndexTypes.FIELD_INDEX_STRING);
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING)
+                .findAllAsync();
 
         final Runnable endTest = new Runnable() {
             @Override
@@ -3224,13 +3221,13 @@ public void onChange(RealmResults<AnnotationIndexTypes> object) {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_doesNotExist() {
+    public void distinct_async_doesNotExist() {
         final long numberOfBlocks = 3;
         final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         try {
-            realm.where(AnnotationIndexTypes.class).distinctAsync("doesNotExist");
+            realm.where(AnnotationIndexTypes.class).distinctValues("doesNotExist").findAllAsync();
         } catch (IllegalArgumentException ignored) {
         }
         looperThread.testComplete();
@@ -3238,12 +3235,12 @@ public void distinctAsync_doesNotExist() {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_invalidTypes() {
+    public void distinct_async_invalidTypes() {
         populateTestRealm(realm, TEST_DATA_SIZE);
 
         for (String field : new String[]{AllTypes.FIELD_REALMOBJECT, AllTypes.FIELD_REALMLIST, AllTypes.FIELD_DOUBLE, AllTypes.FIELD_FLOAT}) {
             try {
-                realm.where(AllTypes.class).distinctAsync(field);
+                realm.where(AllTypes.class).distinctValues(field).findAllAsync();
             } catch (IllegalArgumentException ignored) {
             }
         }
@@ -3252,14 +3249,14 @@ public void distinctAsync_invalidTypes() {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_indexedLinkedFields() {
+    public void distinct_async_indexedLinkedFields() {
         final long numberOfBlocks = 3;
         final long numberOfObjects = 3;
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         for (String field : AnnotationIndexTypes.INDEX_FIELDS) {
             try {
-                realm.where(AnnotationIndexTypes.class).distinctAsync(AnnotationIndexTypes.FIELD_OBJECT + "." + field);
+                realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_OBJECT + "." + field).findAllAsync();
                 fail("Unsupported " + field + " linked field");
             } catch (IllegalArgumentException ignored) {
             }
@@ -3269,11 +3266,11 @@ public void distinctAsync_indexedLinkedFields() {
 
     @Test
     @RunTestInLooperThread
-    public void distinctAsync_notIndexedLinkedFields() {
+    public void distinct_async_notIndexedLinkedFields() {
         populateForDistinctInvalidTypesLinked(realm);
 
         try {
-            realm.where(AllJavaTypes.class).distinctAsync(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY);
+            realm.where(AllJavaTypes.class).distinctValues(AllJavaTypes.FIELD_OBJECT + "." + AllJavaTypes.FIELD_BINARY).findAllAsync();
         } catch (IllegalArgumentException ignored) {
         }
         looperThread.testComplete();
@@ -3286,7 +3283,7 @@ public void distinctMultiArgs() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, false);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS);
+        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.INDEX_FIELDS).findAll();
         assertEquals(numberOfBlocks, distinctMulti.size());
     }
 
@@ -3296,9 +3293,8 @@ public void distinctMultiArgs_switchedFieldsOrder() {
         TestHelper.populateForDistinctFieldsOrder(realm, numberOfBlocks);
 
         // Regardless of the block size defined above, the output size is expected to be the same, 4 in this case, due to receiving unique combinations of tuples.
-        RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        RealmResults<AnnotationIndexTypes> distinctStringLong = query.distinct(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG);
-        RealmResults<AnnotationIndexTypes> distinctLongString = query.distinct(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        RealmResults<AnnotationIndexTypes> distinctStringLong = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_STRING, AnnotationIndexTypes.FIELD_INDEX_LONG).findAll();
+        RealmResults<AnnotationIndexTypes> distinctLongString = realm.where(AnnotationIndexTypes.class).distinctValues(AnnotationIndexTypes.FIELD_INDEX_LONG, AnnotationIndexTypes.FIELD_INDEX_STRING).findAll();
         assertEquals(4, distinctStringLong.size());
         assertEquals(4, distinctLongString.size());
         assertEquals(distinctStringLong.size(), distinctLongString.size());
@@ -3313,47 +3309,47 @@ public void distinctMultiArgs_emptyField() {
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         // An empty string field in the middle.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, "", AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // An empty string field at the end.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "");
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // A null string field in the middle.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null, AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // A null string field at the end.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, AnnotationIndexTypes.FIELD_INDEX_INT, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // (String) Null makes varargs a null array.
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_BOOL, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // Two (String) null for first and varargs fields.
         try {
-            query.distinct((String) null, (String) null);
+            query.distinctValues((String) null, (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String) null combination.
         try {
-            query.distinct("", (String) null);
+            query.distinctValues("", (String) null).findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // "" & (String) null combination.
         try {
-            query.distinct((String) null, "");
+            query.distinctValues((String) null, "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
         // Two empty fields tests.
         try {
-            query.distinct("", "");
+            query.distinctValues("", "").findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3365,7 +3361,7 @@ public void distinctMultiArgs_withNullValues() {
         populateForDistinct(realm, numberOfBlocks, numberOfObjects, true);
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
-        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinct(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING);
+        RealmResults<AnnotationIndexTypes> distinctMulti = query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_DATE, AnnotationIndexTypes.FIELD_INDEX_STRING).findAll();
         assertEquals(1, distinctMulti.size());
     }
 
@@ -3377,7 +3373,7 @@ public void distinctMultiArgs_notIndexedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS);
+            query.distinctValues(AnnotationIndexTypes.FIELD_NOT_INDEX_STRING, AnnotationIndexTypes.NOT_INDEX_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3390,7 +3386,7 @@ public void distinctMultiArgs_doesNotExistField() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinct(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS);
+            query.distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT, AnnotationIndexTypes.NONEXISTANT_MIX_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3401,7 +3397,7 @@ public void distinctMultiArgs_invalidTypesFields() {
 
         RealmQuery<AllTypes> query = realm.where(AllTypes.class);
         try {
-            query.distinct(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT);
+            query.distinctValues(AllTypes.FIELD_REALMOBJECT, AllTypes.INVALID_TYPES_FIELDS_FOR_DISTINCT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3414,7 +3410,7 @@ public void distinctMultiArgs_indexedLinkedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinct(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS);
+            query.distinctValues(AnnotationIndexTypes.INDEX_LINKED_FIELD_STRING, AnnotationIndexTypes.INDEX_LINKED_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3427,7 +3423,7 @@ public void distinctMultiArgs_notIndexedLinkedFields() {
 
         RealmQuery<AnnotationIndexTypes> query = realm.where(AnnotationIndexTypes.class);
         try {
-            query.distinct(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS);
+            query.distinctValues(AnnotationIndexTypes.NOT_INDEX_LINKED_FILED_STRING, AnnotationIndexTypes.NOT_INDEX_LINKED_FIELDS).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
@@ -3438,7 +3434,7 @@ public void distinctMultiArgs_invalidTypesLinkedFields() {
 
         RealmQuery<AllJavaTypes> query = realm.where(AllJavaTypes.class);
         try {
-            query.distinct(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT);
+            query.distinctValues(AllJavaTypes.INVALID_LINKED_BINARY_FIELD_FOR_DISTINCT, AllJavaTypes.INVALID_LINKED_TYPES_FIELDS_FOR_DISTINCT).findAll();
         } catch (IllegalArgumentException ignored) {
         }
     }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
index 8ab8c830a9..6a7e1cdbf3 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmResultsTests.java
@@ -73,7 +73,9 @@ public void setUp() {
         RealmConfiguration realmConfig = configFactory.createConfiguration();
         realm = Realm.getInstance(realmConfig);
         populateTestRealm();
-        collection = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_LONG, Sort.ASCENDING);
+        collection = realm.where(AllTypes.class)
+                .sort(AllTypes.FIELD_LONG, Sort.ASCENDING)
+                .findAll();
     }
 
     @After
diff --git a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
index 509d05f3eb..f1490c163c 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/RealmTests.java
@@ -110,7 +110,6 @@
 import io.realm.rule.RunInLooperThread;
 import io.realm.rule.RunTestInLooperThread;
 import io.realm.rule.TestRealmConfigurationFactory;
-import io.realm.util.ExceptionHolder;
 import io.realm.util.RealmThread;
 
 import static io.realm.TestHelper.testNoObjectFound;
@@ -3299,7 +3298,7 @@ public void copyFromRealm_invalidDepthThrows() {
     @Test
     public void copyFromRealm() {
         populateTestRealm();
-        AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
+        AllTypes realmObject = realm.where(AllTypes.class).sort("columnLong").findAll().first();
         AllTypes unmanagedObject = realm.copyFromRealm(realmObject);
         assertArrayEquals(realmObject.getColumnBinary(), unmanagedObject.getColumnBinary());
         assertEquals(realmObject.getColumnString(), unmanagedObject.getColumnString());
@@ -3313,7 +3312,7 @@ public void copyFromRealm() {
     @Test
     public void copyFromRealm_newCopyEachTime() {
         populateTestRealm();
-        AllTypes realmObject = realm.where(AllTypes.class).findAllSorted("columnLong").first();
+        AllTypes realmObject = realm.where(AllTypes.class).sort("columnLong").findAll().first();
         AllTypes unmanagedObject1 = realm.copyFromRealm(realmObject);
         AllTypes unmanagedObject2 = realm.copyFromRealm(realmObject);
         assertFalse(unmanagedObject1 == unmanagedObject2);
@@ -4467,4 +4466,28 @@ public void getInstance_wrongSchemaInReadonlyThrows() {
         } catch (RealmMigrationNeededException ignored) {
         }
     }
+
+    // https://github.com/realm/realm-java/issues/5570
+    @Test
+    public void getInstance_migrationExceptionThrows_migrationBlockDefiend_realmInstancesShouldBeClosed() {
+        RealmConfiguration config = configFactory.createConfigurationBuilder()
+                .name("readonly.realm")
+                .schema(StringOnlyReadOnly.class, AllJavaTypes.class)
+                .schemaVersion(2)
+                .assetFile("readonly.realm")
+                .migration(new RealmMigration() {
+                    @Override
+                    public void migrate(DynamicRealm realm, long oldVersion, long newVersion) {
+                    }
+                })
+                .build();
+
+        try {
+            realm = Realm.getInstance(config);
+            fail();
+        } catch (RealmMigrationNeededException ignored) {
+            // No Realm instance should be opened at this time.
+            Realm.deleteRealm(config);
+        }
+    }
 }
diff --git a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
index 06e6792365..91d961276d 100644
--- a/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
+++ b/realm/realm-library/src/androidTest/java/io/realm/SortTest.java
@@ -31,6 +31,7 @@
 
 import io.realm.entities.AllTypes;
 import io.realm.entities.AnnotationIndexTypes;
+import io.realm.entities.Dog;
 import io.realm.entities.StringOnly;
 import io.realm.internal.Table;
 import io.realm.internal.UncheckedRow;
@@ -72,18 +73,22 @@ private void populateRealm(Realm realm) {
         AllTypes object1 = realm.createObject(AllTypes.class);
         object1.setColumnLong(5);
         object1.setColumnString("Adam");
+        object1.setColumnRealmObject(realm.copyToRealm(new Dog("D")));
 
         AllTypes object2 = realm.createObject(AllTypes.class);
         object2.setColumnLong(4);
         object2.setColumnString("Brian");
+        object2.setColumnRealmObject(realm.copyToRealm(new Dog("C")));
 
         AllTypes object3 = realm.createObject(AllTypes.class);
         object3.setColumnLong(4);
         object3.setColumnString("Adam");
+        object3.setColumnRealmObject(realm.copyToRealm(new Dog("B")));
 
         AllTypes object4 = realm.createObject(AllTypes.class);
         object4.setColumnLong(5);
         object4.setColumnString("Adam");
+        object4.setColumnRealmObject(realm.copyToRealm(new Dog("A")));
 
         realm.delete(AnnotationIndexTypes.class);
         AnnotationIndexTypes obj1 = realm.createObject(AnnotationIndexTypes.class);
@@ -112,10 +117,10 @@ private UncheckedRow getRowBySourceIndexFromAllTypesTable(long sourceRowIndex) {
     @Before
     public void setUp() {
         // Creates a Realm with the following objects:
-        // 0: (5, "Adam")
-        // 1: (4, "Brian")
-        // 2: (4, "Adam")
-        // 3: (5, "Adam")
+        // 0: (5, "Adam", Dog("D"))
+        // 1: (4, "Brian", Dog("C"))
+        // 2: (4, "Adam", Dog("B"))
+        // 3: (5, "Adam", Dog("A"))
 
         // Injecting the Instrumentation instance is required
         // for your test to run with AndroidJUnitRunner.
@@ -472,7 +477,7 @@ public void sortingDates() {
 
         populateDates(realm, TEST_SIZE);
 
-        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).sort(AllTypes.FIELD_DATE, Sort.ASCENDING).findAll();
         assertEquals(TEST_SIZE, objectsAscending.size());
         int i = 0;
         for (AllTypes allTypes : objectsAscending) {
@@ -480,7 +485,7 @@ public void sortingDates() {
             i++;
         }
 
-        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).sort(AllTypes.FIELD_DATE, Sort.DESCENDING).findAll();
         assertEquals(TEST_SIZE, objectsDescending.size());
         i = TEST_SIZE - 1;
         for (AllTypes allTypes : objectsDescending) {
@@ -509,7 +514,7 @@ public void run() {
             }
         };
 
-        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.ASCENDING);
+        RealmResults<AllTypes> objectsAscending = realm.where(AllTypes.class).sort(AllTypes.FIELD_DATE, Sort.ASCENDING).findAll();
         assertEquals(TEST_SIZE, objectsAscending.size());
         looperThread.keepStrongReference(objectsAscending);
         objectsAscending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
@@ -525,7 +530,7 @@ public void onChange(RealmResults<AllTypes> element) {
             }
         });
 
-        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).findAllSorted(AllTypes.FIELD_DATE, Sort.DESCENDING);
+        RealmResults<AllTypes> objectsDescending = realm.where(AllTypes.class).sort(AllTypes.FIELD_DATE, Sort.DESCENDING).findAll();
         assertEquals(TEST_SIZE, objectsDescending.size());
         looperThread.keepStrongReference(objectsDescending);
         objectsDescending.addChangeListener(new RealmChangeListener<RealmResults<AllTypes>>() {
@@ -559,18 +564,70 @@ public void sortByLongDistinctByInt() {
         // (2, 1, "B")
         // (1, 1, "A)
         RealmResults<AnnotationIndexTypes> results1 = realm.where(AnnotationIndexTypes.class)
-                .findAllSorted(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING);
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
+                .findAll();
         assertEquals(3, results1.size());
         assertEquals(3, results1.get(0).getIndexLong());
 
         // After distinct:
         // (3, 1, "C")
-        RealmResults<AnnotationIndexTypes> results2 =  results1.where().distinct(AnnotationIndexTypes.FIELD_INDEX_INT);
+        RealmResults<AnnotationIndexTypes> results2 =  results1.where().distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT).findAll();
         assertEquals(1, results2.size());
         assertEquals("C", results2.get(0).getIndexString());
         assertEquals(3, results2.get(0).getIndexLong());
     }
 
+    @Test
+    public void sortAndDistinctMixed() {
+        // Dataset:
+        // (FIELD_INDEX_LONG, FIELD_INDEX_INT, FIELD_INDEX_STRING)
+        // (1, 1, "A")
+        // (2, 1, "B")
+        // (3, 1, "C")
+        // Depending on the sorting, distinct should pick the first element encountered.
+        // The order of sort/distinct in the query should not matter
+
+        // Case 1: Selecting highest numbers
+        RealmResults<AnnotationIndexTypes> results1a = realm.where(AnnotationIndexTypes.class)
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .findAll();
+        assertEquals(1, results1a.size());
+        assertEquals(3, results1a.get(0).getIndexLong());
+
+        RealmResults<AnnotationIndexTypes> results1b = realm.where(AnnotationIndexTypes.class)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.DESCENDING)
+                .findAll();
+        assertEquals(1, results1b.size());
+        assertEquals(3, results1b.get(0).getIndexLong());
+
+        // Case 1: Selecting lowest number numbers
+        RealmResults<AnnotationIndexTypes> results2a = realm.where(AnnotationIndexTypes.class)
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.ASCENDING)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .findAll();
+        assertEquals(1, results2a.size());
+        assertEquals(1, results2a.get(0).getIndexLong());
+
+        RealmResults<AnnotationIndexTypes> results2b = realm.where(AnnotationIndexTypes.class)
+                .distinctValues(AnnotationIndexTypes.FIELD_INDEX_INT)
+                .sort(AnnotationIndexTypes.FIELD_INDEX_LONG, Sort.ASCENDING)
+                .findAll();
+        assertEquals(1, results2b.size());
+        assertEquals(1, results2b.get(0).getIndexLong());
+    }
+
+    @Test
+    public void sortByChildValue() {
+        RealmResults<AllTypes> result = realm.where(AllTypes.class)
+                .sort(AllTypes.FIELD_REALMOBJECT + "." + Dog.FIELD_NAME, Sort.ASCENDING)
+                .findAll();
+
+        assertEquals("A", result.first().getColumnRealmObject().getName());
+        assertEquals("D", result.last().getColumnRealmObject().getName());
+    }
+
     private void createAndTest(String str) {
         realm.beginTransaction();
         realm.delete(StringOnly.class);
@@ -579,7 +636,7 @@ private void createAndTest(String str) {
             stringOnly.setChars(str.substring(i, i + 1));
         }
         realm.commitTransaction();
-        RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).findAllSorted("chars");
+        RealmResults<StringOnly> stringOnlies = realm.where(StringOnly.class).sort("chars").findAll();
         for (int i = 0; i < chars.length(); i++) {
             assertEquals(chars.substring(i, i + 1), stringOnlies.get(i).getChars());
         }
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
index 8a8eb0bcb3..1da13db3ce 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsRealmConfig.cpp
@@ -155,10 +155,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetSchemaConfi
                                               reinterpret_cast<jlong>(new_shared_realm_ptr), config_global.get(), obj,
                                               old_realm->schema_version());
                 });
-                // Close the OsSharedRealm. Otherwise it will only be closed when the Java OsSharedRealm gets GCed. And
-                // that will be too late.
-                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(
-                    env, [&new_shared_realm_ptr]() { (*new_shared_realm_ptr)->close(); });
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, nullptr);
             };
         }
         else {
@@ -230,10 +227,7 @@ JNIEXPORT void JNICALL Java_io_realm_internal_OsRealmConfig_nativeSetInitializat
                                               reinterpret_cast<jlong>(new_shared_realm_ptr), config_global_ref.get(),
                                               obj);
                 });
-                // Close the OsSharedRealm. Otherwise it will only be closed when the Java OsSharedRealm gets GCed. And
-                // that will be too late.
-                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(
-                    env, [&new_shared_realm_ptr]() { (*new_shared_realm_ptr)->close(); });
+                TERMINATE_JNI_IF_JAVA_EXCEPTION_OCCURRED(env, nullptr);
             };
         }
         else {
diff --git a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
index 500ed0a8a5..560eb31f52 100644
--- a/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
+++ b/realm/realm-library/src/main/cpp/io_realm_internal_OsResults.cpp
@@ -52,9 +52,7 @@ JNIEXPORT jlong JNICALL Java_io_realm_internal_OsResults_nativeCreateResults(JNI
         }
 
         auto shared_realm = *(reinterpret_cast<SharedRealm*>(shared_realm_ptr));
-
         DescriptorOrdering descriptor_ordering;
-        REALM_ASSERT_RELEASE(!(j_sort_desc && j_distinct_desc));
         if (j_sort_desc) {
             descriptor_ordering.append_sort(JavaSortDescriptor(env, j_sort_desc).sort_descriptor());
         }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmList.java b/realm/realm-library/src/main/java/io/realm/RealmList.java
index a0838b7abe..af87170e3c 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmList.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmList.java
@@ -506,7 +506,7 @@ private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
     @Override
     public RealmResults<E> sort(String fieldName, Sort sortOrder) {
         if (isManaged()) {
-            return this.where().findAllSorted(fieldName, sortOrder);
+            return this.where().sort(fieldName, sortOrder).findAll();
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
@@ -526,7 +526,7 @@ private E lastImpl(boolean shouldThrow, @Nullable E defaultValue) {
     @Override
     public RealmResults<E> sort(String[] fieldNames, Sort[] sortOrders) {
         if (isManaged()) {
-            return where().findAllSorted(fieldNames, sortOrders);
+            return where().sort(fieldNames, sortOrders).findAll();
         } else {
             throw new UnsupportedOperationException(ONLY_IN_MANAGED_MODE_MESSAGE);
         }
diff --git a/realm/realm-library/src/main/java/io/realm/RealmQuery.java b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
index 656cd32737..1662b3de8f 100644
--- a/realm/realm-library/src/main/java/io/realm/RealmQuery.java
+++ b/realm/realm-library/src/main/java/io/realm/RealmQuery.java
@@ -23,6 +23,7 @@
 
 import javax.annotation.Nullable;
 
+import io.realm.annotations.Beta;
 import io.realm.annotations.Required;
 import io.realm.internal.OsResults;
 import io.realm.internal.OsList;
@@ -33,6 +34,7 @@
 import io.realm.internal.Table;
 import io.realm.internal.TableQuery;
 import io.realm.internal.fields.FieldDescriptor;
+import io.realm.log.RealmLog;
 
 
 /**
@@ -63,6 +65,8 @@
     private String className;
     private final boolean forValues;
     private final OsList osList;
+    private SortDescriptor sortDescriptor;
+    private SortDescriptor distinctDescriptor;
 
     private static final String TYPE_MISMATCH = "Field '%s': type mismatch - %s expected.";
     private static final String EMPTY_VALUES = "Non-empty 'values' must be provided.";
@@ -1595,6 +1599,7 @@ public boolean isValid() {
      * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
      * to linked fields.
      */
+    @Deprecated
     public RealmResults<E> distinct(String fieldName) {
         realm.checkIfValid();
 
@@ -1615,6 +1620,7 @@ public boolean isValid() {
      * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
      * to linked fields.
      */
+    @Deprecated
     public RealmResults<E> distinctAsync(String fieldName) {
         realm.checkIfValid();
 
@@ -1635,6 +1641,7 @@ public boolean isValid() {
      * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
      * is an unsupported type, or points to a linked field.
      */
+    @Deprecated
     public RealmResults<E> distinct(String firstFieldName, String... remainingFieldNames) {
         realm.checkIfValid();
 
@@ -1810,7 +1817,7 @@ public long count() {
     public RealmResults<E> findAll() {
         realm.checkIfValid();
 
-        return createRealmResults(query, null, null, true);
+        return createRealmResults(query, sortDescriptor, distinctDescriptor, true);
     }
 
     /**
@@ -1824,7 +1831,7 @@ public long count() {
         realm.checkIfValid();
 
         realm.sharedRealm.capabilities.checkCanDeliverNotification(ASYNC_QUERY_WRONG_THREAD_MESSAGE);
-        return createRealmResults(query, null, null, false);
+        return createRealmResults(query, sortDescriptor, distinctDescriptor, false);
     }
 
     /**
@@ -1841,9 +1848,9 @@ public long count() {
      * {@link RealmObject} or a child {@link RealmList}.
      */
     @SuppressWarnings("unchecked")
+    @Deprecated
     public RealmResults<E> findAllSorted(String fieldName, Sort sortOrder) {
         realm.checkIfValid();
-
         SortDescriptor sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldName, sortOrder);
         return createRealmResults(query, sortDescriptor, null, true);
     }
@@ -1857,6 +1864,7 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(final String fieldName, final Sort sortOrder) {
         realm.checkIfValid();
 
@@ -1865,6 +1873,125 @@ public long count() {
         return createRealmResults(query, sortDescriptor, null, false);
     }
 
+    /**
+     * Sorts the query result by the specific field name in ascending order.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName the field name to sort by.
+     * @throws IllegalArgumentException if the field name does not exist.
+     * @throws IllegalStateException if a sorting order was already defined.
+     */
+    public RealmQuery<E> sort(String fieldName) {
+        realm.checkIfValid();
+        return sort(fieldName, Sort.ASCENDING);
+    }
+
+    /**
+     * Sorts the query result by the specified field name and order.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName the field name to sort by.
+     * @param sortOrder how to sort the results.
+     * @throws IllegalArgumentException if the field name does not exist.
+     * @throws IllegalStateException if a sorting order was already defined.
+     */
+    public RealmQuery<E> sort(String fieldName, Sort sortOrder) {
+        realm.checkIfValid();
+        return sort(new String[] { fieldName}, new Sort[] { sortOrder});
+    }
+
+    /**
+     * Sorts the query result by the specific field names in the provided orders. {@code fieldName2} is only used
+     * in case of equal values in {@code fieldName1}.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldName1 first field name
+     * @param sortOrder1 sort order for first field
+     * @param fieldName2 second field name
+     * @param sortOrder2 sort order for second field
+     * @throws IllegalArgumentException if the field name does not exist.
+     * @throws IllegalStateException if a sorting order was already defined.
+     */
+    public RealmQuery<E> sort(String fieldName1, Sort sortOrder1, String fieldName2, Sort sortOrder2) {
+        realm.checkIfValid();
+        return sort(new String[] { fieldName1, fieldName2 }, new Sort[] { sortOrder1, sortOrder2 });
+    }
+
+    /**
+     * Sorts the query result by the specific field names in the provided orders. Later fields will only be used
+     * if the previous field values are equal.
+     * <p>
+     * Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A',
+     * 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.
+     *
+     * @param fieldNames an array of field names to sort by.
+     * @param sortOrders how to sort the field names.
+     * @throws IllegalArgumentException if the field name does not exist.
+     * @throws IllegalStateException if a sorting order was already defined.
+     */
+    public RealmQuery<E> sort(String[] fieldNames, Sort[] sortOrders) {
+        realm.checkIfValid();
+        if (sortDescriptor != null) {
+            throw new IllegalStateException("A sorting order was already defined.");
+        }
+        sortDescriptor = SortDescriptor.getInstanceForSort(getSchemaConnector(), query.getTable(), fieldNames, sortOrders);
+        return this;
+    }
+
+    /**
+     * BETA API: Will be renamed to {@code distinct} in next major release.
+     *
+     * Selects a distinct set of objects of a specific class. If the result is sorted, the first object will be
+     * returned in case of multiple occurrences, otherwise it is undefined which object is returned.
+     * <p>
+     * Adding {@link io.realm.annotations.Index} to the corresponding field will make this operation much faster.
+     *
+     * @param fieldName the field name.
+     * @throws IllegalArgumentException if a field is {@code null}, does not exist, is an unsupported type, or points
+     * to linked fields.
+     * @throws IllegalStateException if distinct field names were already defined.
+     */
+    @Beta
+    public RealmQuery<E> distinctValues(String fieldName) {
+        return distinctValues(fieldName, new String[]{});
+    }
+
+    /**
+     * BETA API: Will be renamed to {@code distinct} in next major release.
+     *
+     * Selects a distinct set of objects of a specific class. When multiple distinct fields are
+     * given, all unique combinations of values in the fields will be returned. In case of multiple
+     * matches, it is undefined which object is returned. Unless the result is sorted, then the
+     * first object will be returned.
+     *
+     * @param firstFieldName first field name to use when finding distinct objects.
+     * @param remainingFieldNames remaining field names when determining all unique combinations of field values.
+     * @throws IllegalArgumentException if field names is empty or {@code null}, does not exist,
+     * is an unsupported type, or points to a linked field.
+     * @throws IllegalStateException if distinct field names were already defined.
+     */
+    @Beta
+    public RealmQuery<E> distinctValues(String firstFieldName, String... remainingFieldNames) {
+        realm.checkIfValid();
+        if (distinctDescriptor != null) {
+            throw new IllegalStateException("Distinct fields have already been defined.");
+        }
+        if (remainingFieldNames.length == 0) {
+            distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, firstFieldName);
+        } else {
+            String[] fieldNames = new String[1 + remainingFieldNames.length];
+            fieldNames[0] = firstFieldName;
+            System.arraycopy(remainingFieldNames, 0, fieldNames, 1, remainingFieldNames.length);
+            distinctDescriptor = SortDescriptor.getInstanceForDistinct(getSchemaConnector(), table, fieldNames);
+        }
+        return this;
+    }
 
     /**
      * Finds all objects that fulfill the query conditions and sorted by specific field name in ascending order.
@@ -1878,6 +2005,7 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSorted(String fieldName) {
         return findAllSorted(fieldName, Sort.ASCENDING);
     }
@@ -1891,6 +2019,7 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if the field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(String fieldName) {
         return findAllSortedAsync(fieldName, Sort.ASCENDING);
     }
@@ -1908,6 +2037,7 @@ public long count() {
      * @throws java.lang.IllegalArgumentException if one of the field names does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSorted(String[] fieldNames, Sort[] sortOrders) {
         realm.checkIfValid();
 
@@ -1930,6 +2060,7 @@ private boolean isDynamicQuery() {
      * {@link RealmObject} or a child {@link RealmList}.
      * @see io.realm.RealmResults
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(String[] fieldNames, final Sort[] sortOrders) {
         realm.checkIfValid();
 
@@ -1953,6 +2084,7 @@ private boolean isDynamicQuery() {
      * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSorted(String fieldName1, Sort sortOrder1,
             String fieldName2, Sort sortOrder2) {
         return findAllSorted(new String[] {fieldName1, fieldName2}, new Sort[] {sortOrder1, sortOrder2});
@@ -1967,6 +2099,7 @@ private boolean isDynamicQuery() {
      * @throws java.lang.IllegalArgumentException if a field name does not exist or it belongs to a child
      * {@link RealmObject} or a child {@link RealmList}.
      */
+    @Deprecated
     public RealmResults<E> findAllSortedAsync(String fieldName1, Sort sortOrder1,
             String fieldName2, Sort sortOrder2) {
         return findAllSortedAsync(new String[] {fieldName1, fieldName2}, new Sort[] {sortOrder1, sortOrder2});
diff --git a/realm/realm-library/src/main/java/io/realm/Sort.java b/realm/realm-library/src/main/java/io/realm/Sort.java
index 5d7c3d6f5d..861cccfbd6 100644
--- a/realm/realm-library/src/main/java/io/realm/Sort.java
+++ b/realm/realm-library/src/main/java/io/realm/Sort.java
@@ -19,7 +19,7 @@
 /**
  * This class describes the sorting order used in Realm queries.
  *
- * @see io.realm.RealmQuery#findAllSorted(String, Sort)
+ * @see io.realm.RealmQuery#sort(String, Sort)
  */
 public enum Sort {
     ASCENDING(true),
diff --git a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
index 027e0e71b8..137a2ef199 100644
--- a/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
+++ b/realm/realm-library/src/main/java/io/realm/internal/OsSharedRealm.java
@@ -160,6 +160,14 @@ protected PartialSyncCallback(String className) {
     // JNI will only hold a weak global ref to this.
     public final RealmNotifier realmNotifier;
     public final Capabilities capabilities;
+    // For the Java callbacks during constructing in Object Store, some temporary OsSharedRealm objects need to be
+    // created as the parameter of the callback. The native pointers of those temp OsSharedRealm objects have to be
+    // valid during the whole life cycle of the Java object. The living native pointers still hold a ref-count to the
+    // SharedRealm which means the SharedRealm won't be closed automatically if there is any exception throws during
+    // construction. GC will clear them later, but that would be too late. So we are tracking the temp OsSharedRealm
+    // during the construction stage and manually close them if exception throws.
+    private final static List<OsSharedRealm> sharedRealmsUnderConstruction = new CopyOnWriteArrayList<OsSharedRealm>();
+    private final List<OsSharedRealm> tempSharedRealmsForCallback = new ArrayList<OsSharedRealm>();
 
     private final List<WeakReference<PendingRow>> pendingRows = new CopyOnWriteArrayList<>();
     // Package protected for testing
@@ -169,10 +177,25 @@ private OsSharedRealm(OsRealmConfig osRealmConfig) {
         Capabilities capabilities = new AndroidCapabilities();
         RealmNotifier realmNotifier = new AndroidRealmNotifier(this, capabilities);
 
-        this.nativePtr = nativeGetSharedRealm(osRealmConfig.getNativePtr(), realmNotifier);
+        // SharedRealms under constructions are identified by the Context.
+        this.context = osRealmConfig.getContext();
+        sharedRealmsUnderConstruction.add(this);
+        try {
+            this.nativePtr = nativeGetSharedRealm(osRealmConfig.getNativePtr(), realmNotifier);
+        } catch (Throwable t) {
+            // The SharedRealm instances have to be closed before throw.
+            for (OsSharedRealm sharedRealm: tempSharedRealmsForCallback) {
+                if (!sharedRealm.isClosed()) {
+                    sharedRealm.close();
+                }
+            }
+            throw t;
+        } finally {
+            tempSharedRealmsForCallback.clear();
+            sharedRealmsUnderConstruction.remove(this);
+        }
         this.osRealmConfig = osRealmConfig;
         this.schemaInfo = new OsSchemaInfo(nativeGetSchemaInfo(nativePtr), this);
-        this.context = osRealmConfig.getContext();
         this.context.addReference(this);
 
         this.capabilities = capabilities;
@@ -198,6 +221,18 @@ private OsSharedRealm(long nativeSharedRealmPtr, OsRealmConfig osRealmConfig) {
         // This instance should never need notifications.
         this.realmNotifier = null;
         nativeSetAutoRefresh(nativePtr, false);
+
+        boolean foundParentSharedRealm = false;
+        for (OsSharedRealm sharedRealm : sharedRealmsUnderConstruction) {
+            if (sharedRealm.context == osRealmConfig.getContext())  {
+                foundParentSharedRealm = true;
+                sharedRealm.tempSharedRealmsForCallback.add(this);
+                break;
+            }
+        }
+        if (!foundParentSharedRealm) {
+            throw new IllegalStateException("Cannot find the parent 'OsSharedRealm' which is under construction.");
+        }
     }
 
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
index 494938d9e1..cf3602bfe1 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/SyncSessionTests.java
@@ -279,7 +279,7 @@ public void run() {
                         .build();
                 final Realm adminRealm = Realm.getInstance(adminConfig);
 
-                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+                RealmResults<StringOnly> all = adminRealm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();
                 RealmChangeListener<RealmResults<StringOnly>> realmChangeListener = new RealmChangeListener<RealmResults<StringOnly>>() {
                     @Override
                     public void onChange(RealmResults<StringOnly> stringOnlies) {
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
index ded87c8ca1..9c0418233c 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/EncryptedSynchronizedRealmTests.java
@@ -226,8 +226,8 @@ public void onError(SyncSession session, ObjectServerError error) {
 
         adminRealm = Realm.getInstance(adminConfigWithEncryption);
 
-        RealmResults<StringOnly> allSorted = realm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
-        RealmResults<StringOnly> allSortedAdmin = adminRealm.where(StringOnly.class).findAllSorted(StringOnly.FIELD_CHARS);
+        RealmResults<StringOnly> allSorted = realm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();
+        RealmResults<StringOnly> allSortedAdmin = adminRealm.where(StringOnly.class).sort(StringOnly.FIELD_CHARS).findAll();
         assertEquals("Hi Alice", allSorted.get(0).getChars());
         assertEquals("Hi Bob", allSorted.get(1).getChars());
 
diff --git a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
index 08ba70684e..2b7c9383cb 100644
--- a/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
+++ b/realm/realm-library/src/syncIntegrationTest/java/io/realm/objectserver/ProcessCommitTests.java
@@ -192,7 +192,7 @@ public void expectALot() throws Throwable {
                 .directory(looperThread.getRoot())
                 .build();
         final Realm realm = Realm.getInstance(syncConfig);
-        final RealmResults<TestObject> all = realm.where(TestObject.class).findAllSorted("intProp");
+        final RealmResults<TestObject> all = realm.where(TestObject.class).sort("intProp").findAll();
         looperThread.keepStrongReference(all);
         final AtomicInteger listenerCalledCounter = new AtomicInteger(0);
         all.addChangeListener(new RealmChangeListener<RealmResults<TestObject>>() {
