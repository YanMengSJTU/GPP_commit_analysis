diff --git a/.travis.yml b/.travis.yml
index 765c247..91930ff 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -15,15 +15,25 @@ env:
 android:
   components:
     - tools
-    - build-tools-23.0.3
-    - extra-android-m2repository
+    - platform-tools
+    - build-tools-26.0.2
+    - android-27
+    - android-24
     - android-23
+    - android-22
+    - extra-google-google_play_services
+    - extra-google-m2repository
+    - extra-android-m2repository
+    - sys-img-armeabi-v7a-android-22    
 
 # Emulator Management: Create, Start and Wait
 before_script:
-  - echo no | android create avd --force -n test -t android-19 --abi armeabi-v7a
+  - echo no | android create avd --force -n test -t android-22 --abi armeabi-v7a -c 32M
   - emulator -avd test -no-audio -no-window &
   - android-wait-for-emulator
+  - sleep 180
+  - adb devices
   - adb shell input keyevent 82 &
-
-script: ./gradlew connectedAndroidTest
\ No newline at end of file
+  
+script:
+  - ./gradlew connectedAndroidTest
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000..eac3663
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,73 @@
+Change Log
+==========
+
+Version 1.0.1 *(2017-12-20)*
+----------------------------
+
+ * New: Add support for `Single`, `Completable`, `Flowable`, `Maybe` Observable
+ * New: Add support for OPTIONS request
+ * Bump OkHttp Version to 3.9.1
+ * Bump other dependencies
+ * New: Add support for specifying request method dynamically
+ * New: Add API to check isRequestRunning
+ * Fix: Add more than one values for one key in header and query
+ * Merge pull requests
+
+
+Version 1.0.0 *(2017-03-19)*
+----------------------------
+
+ * Fix: Progress bug for large files download
+ * Merge pull requests
+ * New: Add new API
+ * Bump OkHttp Version to 3.6.0
+ * New: Add config options for BitmapDecode
+ * New: Add Consumer Proguard
+
+
+Version 0.4.0 *(2017-02-01)*
+----------------------------
+
+ * New: RxJava2 Support [link](https://amitshekhariitbhu.github.io/Fast-Android-Networking/rxjava2_support.html)
+ * New: Add Java Object directly in any request [link](https://amitshekhariitbhu.github.io/Fast-Android-Networking/post_request.html)
+ * New: Java Object is supported for query parameter, headers also
+ * Update OkHttp to 3.5.0
+ * Fix: Allow all Map implementations
+ * New: Add better logging of request
+ * New: Get parsed error body [link](https://amitshekhariitbhu.github.io/Fast-Android-Networking/error_code_handling.html)
+ * Merged pull requests
+
+
+Version 0.3.0 *(2016-11-07)*
+----------------------------
+
+ * Fix: Few minor bug fixes
+ * Remove unwanted tags from manifest file
+
+
+Version 0.2.0 *(2016-09-16)*
+----------------------------
+
+* New: Jackson Parser Support 
+* New: Making Synchronous Request - [Check Here](https://amitshekhariitbhu.github.io/Fast-Android-Networking/synchronous_request.html)
+* New: setContentType("application/json; charset=utf-8") in POST and Multipart request.
+* New: Getting OkHttpResponse in Response to access headers - [Check Here](https://amitshekhariitbhu.github.io/Fast-Android-Networking/getting_okhttpresponse.html)
+* Bug fixes : As always we are squashing bugs.
+* New: Few other features which are request by the fans of Fast Android Networking.
+
+
+Version 0.1.0 *(2016-07-31)*
+----------------------------
+
+ * New: RxJava Support For Fast-Android-Networking
+ * New: Now RxJava can be used with Fast-Android-Networking
+ * New: Operators like `flatMap`, `filter`, `map`, `zip`, etc can be used easily with Fast-Android-Networking.
+ * New: Chaining of Requests can be done.
+ * New: Requests can be bind with Activity-Lifecycle.
+ * New: Java Object Parsing Support
+
+
+Version 0.0.1 *(2016-06-03)*
+----------------------------
+
+Initial release.
\ No newline at end of file
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000..3741d94
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,9 @@
+# Contributing
+
+1. Fork it!
+2. Checkout the development branch: `git checkout development`
+3. Create your feature branch: `git checkout -b my-new-feature`
+4. Add your changes to the index: `git add .`
+5. Commit your changes: `git commit -m 'Add some feature'`
+6. Push to the branch: `git push origin my-new-feature`
+7. Submit a pull request against the `development` branch
diff --git a/README.md b/README.md
index 0766322..107fff8 100644
--- a/README.md
+++ b/README.md
@@ -1,11 +1,16 @@
+<img src=https://raw.githubusercontent.com/amitshekhariitbhu/Fast-Android-Networking/master/assets/androidnetworking.png >
+
 # Fast Android Networking Library
 
 [![Build Status](https://travis-ci.org/amitshekhariitbhu/Fast-Android-Networking.svg?branch=master)](https://travis-ci.org/amitshekhariitbhu/Fast-Android-Networking)
+[![Mindorks](https://img.shields.io/badge/mindorks-opensource-blue.svg)](https://mindorks.com/open-source-projects)
+[![Mindorks Community](https://img.shields.io/badge/join-community-blue.svg)](https://mindorks.com/join-community)
 [![Android Arsenal](https://img.shields.io/badge/Android%20Arsenal-Android%20Networking-blue.svg?style=flat)](http://android-arsenal.com/details/1/3695)
+[![API](https://img.shields.io/badge/API-9%2B-brightgreen.svg?style=flat)](https://android-arsenal.com/api?level=9)
+[![Download](https://api.bintray.com/packages/amitshekhariitbhu/maven/android-networking/images/download.svg) ](https://bintray.com/amitshekhariitbhu/maven/android-networking/_latestVersion)
+[![Open Source Love](https://badges.frapsoft.com/os/v1/open-source.svg?v=102)](https://opensource.org/licenses/Apache-2.0)
 [![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](https://github.com/amitshekhariitbhu/Fast-Android-Networking/blob/master/LICENSE)
 
-<img src=https://raw.githubusercontent.com/amitshekhariitbhu/Fast-Android-Networking/master/assets/androidnetworking.png >
-
 ### About Fast Android Networking Library
 
 Fast Android Networking Library is a powerful library for doing any type of networking in Android applications which is made on top of [OkHttp Networking Layer](http://square.github.io/okhttp/).
@@ -22,6 +27,17 @@ Fast Android Networking Library takes care of each and everything. So you don't
   [Okio](https://github.com/square/okio) do some clever things to save CPU and memory.
 * As it uses [OkHttp](http://square.github.io/okhttp/) , most important it supports HTTP/2.  
 
+
+### RxJava2 Support, [check here](https://amitshekhariitbhu.github.io/Fast-Android-Networking/rxjava2_support.html).
+
+### RxJava2 + Fast Android Networking + Dagger2 with MVP Architecture Project, [Check here](https://github.com/MindorksOpenSource/android-mvp-architecture)
+
+### Another awesome library for debugging databases and shared preferences, [Check here](https://github.com/amitshekhariitbhu/Android-Debug-Database)
+
+### RxJava2 + Fast Android Networking + Dagger2 with MVVM Architecture Project, [Check here](https://github.com/MindorksOpenSource/android-mvvm-architecture)
+
+### PRDownloader library for downloading file with pause and resume support, [Check here](https://github.com/MindorksOpenSource/PRDownloader)
+
 ### Find this project useful ? :heart:
 * Support it by clicking the :star: button on the upper right of this page. :v:
 
@@ -39,7 +55,7 @@ Fast Android Networking Library supports Android 2.3 (Gingerbread) and later.
 
 Add this in your build.gradle
 ```groovy
-compile 'com.amitshekhar.android:android-networking:0.3.0'
+compile 'com.amitshekhar.android:android-networking:1.0.1'
 ```
 Do not forget to add internet permission in manifest if already not present
 ```xml
@@ -59,7 +75,7 @@ AndroidNetworking.initialize(getApplicationContext(),okHttpClient);
 ```
 Using the Fast Android Networking with Jackson Parser
 ```groovy
-compile 'com.amitshekhar.android:jackson-android-networking:0.3.0'
+compile 'com.amitshekhar.android:jackson-android-networking:1.0.1'
 ```
 ```java
 // Then set the JacksonParserFactory like below
@@ -105,13 +121,33 @@ AndroidNetworking.post("https://fierce-cove-29863.herokuapp.com/createAnUser")
                     }
                 });
 ```
-You can also post json, file, etc in POST request like this.
+You can also post java object, json, file, etc in POST request like this.
 ```java
+User user = new User();
+user.firstname = "Amit";
+user.lastname = "Shekhar";
+
+AndroidNetworking.post("https://fierce-cove-29863.herokuapp.com/createUser")
+                 .addBodyParameter(user) // posting java object
+                 .setTag("test")
+                 .setPriority(Priority.MEDIUM)
+                 .build()
+                 .getAsJSONArray(new JSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(JSONArray response) {
+                      // do anything with response
+                    }
+                    @Override
+                    public void onError(ANError error) {
+                      // handle error
+                    }
+                });
+
 
 JSONObject jsonObject = new JSONObject();
 try {
-    jsonObject.put("firstname", "Rohit");
-    jsonObject.put("lastname", "Kumar");
+    jsonObject.put("firstname", "Amit");
+    jsonObject.put("lastname", "Shekhar");
 } catch (JSONException e) {
   e.printStackTrace();
 }
@@ -158,7 +194,7 @@ AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllUsers/{page
                 .setTag(this)
                 .setPriority(Priority.LOW)
                 .build()
-                .getAsParsed(new TypeToken<List<User>>() {}, new ParsedRequestListener<List<User>>() {
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
                     @Override
                     public void onResponse(List<User> users) {
                       // do anything with response
@@ -180,7 +216,7 @@ AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAnUserDetail/{
                 .setTag(this)
                 .setPriority(Priority.LOW)
                 .build()
-                .getAsParsed(new TypeToken<User>() {}, new ParsedRequestListener<User>() {
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
                      @Override
                      public void onResponse(User user) {
                         // do anything with response
@@ -193,7 +229,7 @@ AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAnUserDetail/{
                         // handle error
                      }
                  }); 
-/*-- Note : TypeToken and getAsParsed is important here --*/              
+/*-- Note : YourObject.class, getAsObject and getAsObjectList are important here --*/              
 ```
 
 ### Downloading a file from server
@@ -342,19 +378,21 @@ AndroidNetworking.get(imageUrl)
 ### Error Code Handling
 ```java
 public void onError(ANError error) {
-                           if (error.getErrorCode() != 0) {
-                                // received error from server
-                                // error.getErrorCode() - the error code from server
-                                // error.getErrorBody() - the error body from server
-                                // error.getErrorDetail() - just an error detail
-                                Log.d(TAG, "onError errorCode : " + error.getErrorCode());
-                                Log.d(TAG, "onError errorBody : " + error.getErrorBody());
-                                Log.d(TAG, "onError errorDetail : " + error.getErrorDetail());
-                           } else {
-                                // error.getErrorDetail() : connectionError, parseError, requestCancelledError
-                                Log.d(TAG, "onError errorDetail : " + error.getErrorDetail());
-                           }
-                        }
+   if (error.getErrorCode() != 0) {
+        // received error from server
+        // error.getErrorCode() - the error code from server
+        // error.getErrorBody() - the error body from server
+        // error.getErrorDetail() - just an error detail
+        Log.d(TAG, "onError errorCode : " + error.getErrorCode());
+        Log.d(TAG, "onError errorBody : " + error.getErrorBody());
+        Log.d(TAG, "onError errorDetail : " + error.getErrorDetail());
+        // get parsed error object (If ApiError is your class)
+        ApiError apiError = error.getErrorAsObject(ApiError.class);
+   } else {
+        // error.getErrorDetail() : connectionError, parseError, requestCancelledError
+        Log.d(TAG, "onError errorDetail : " + error.getErrorDetail());
+   }
+}
 ```
 ### Remove Bitmap from cache or clear cache
 ```java
@@ -505,7 +543,7 @@ ANRequest request = AndroidNetworking.get("https://fierce-cove-29863.herokuapp.c
                         .addPathParameter("pageNumber", "0")
                         .addQueryParameter("limit", "3")
                         .build();
-ANResponse<List<User>> response = request.executeForParsed(new TypeToken<List<User>>() {});
+ANResponse<List<User>> response = request.executeForObjectList(User.class);
 if (response.isSuccess()) {
    List<User> users = responseTwo.getResult();
 } else {
@@ -526,8 +564,7 @@ if (response.isSuccess()) {
 ### Enabling Logging
 ```java
 AndroidNetworking.enableLogging(); // simply enable logging
-AndroidNetworking.enableLogging("tag"); // enabling logging with some tag
-AndroidNetworking.disableLogging(); // disable logging
+AndroidNetworking.enableLogging(LEVEL.HEADERS); // enabling logging with level
 ```
 ### Enabling GZIP From Client to Server
 ```java
@@ -545,7 +582,7 @@ AndroidNetworking.initialize(getApplicationContext(),okHttpClient);
 * Known Bug : As present if you are using GZIP Interceptor from client to server, Upload progress
   is not working perfectly in Multipart.
   
-  If you are using proguard, then add this rule in proguard-project.txt
+  If you are using Proguard with Gradle build system (which is usually the case), you don't have to do anything. The appropriate Proguard rules will be automatically applied. If you still need the rules applied in `proguard-rules.pro`, it is as follows:
   ```
   -dontwarn okio.**
   ```
@@ -558,7 +595,7 @@ AndroidNetworking.initialize(getApplicationContext(),okHttpClient);
 * Fast Android Networking Library supports uploading any type of file (supports multipart upload)
 * Fast Android Networking Library supports cancelling a request
 * Fast Android Networking Library supports setting priority to any request (LOW, MEDIUM, HIGH, IMMEDIATE)
-* Fast Android Networking Library supports [RxJava](https://github.com/amitshekhariitbhu/Fast-Android-Networking/blob/master/RxAndroidNetworking.md)
+* Fast Android Networking Library supports [RxJava](https://amitshekhariitbhu.github.io/Fast-Android-Networking/rxjava2_support.html)
 
 As it uses [OkHttp](http://square.github.io/okhttp/) as a networking layer, it supports:
 
@@ -568,20 +605,20 @@ As it uses [OkHttp](http://square.github.io/okhttp/) as a networking layer, it s
 * Fast Android Networking Library supports response caching which avoids the network completely for repeat requests
 
 ### Difference over other Networking Library
-* In Fast Android Networking Library, OkHttpClient can be customized for every request easily.
+* In Fast Android Networking Library, OkHttpClient can be customized for every request easily — like timeout customization, etc. for each request.
 * As Fast Android Networking Library uses [OkHttp](http://square.github.io/okhttp/) and [Okio](https://github.com/square/okio), it is faster.
 * Single library for all type of networking.
-* Supports RxJava -> [Check here](https://github.com/amitshekhariitbhu/Fast-Android-Networking/wiki/Using-Fast-Android-Networking-Library-With-RxJava)
+* Supports RxJava, RxJava2 -> [Check here](https://amitshekhariitbhu.github.io/Fast-Android-Networking/rxjava2_support.html)
 * Current bandwidth and connection quality can be obtained to decide logic of code.
 * Executor can be passed to any request to get response in another thread.
 * Complete analytics of any request can be obtained.
 * All types of customization is possible.
-* Immediate Request is really immediate now.
-* Prefetching of any request can be done so that it gives instant data when required from cache.
-* Proper cancellation of request.
-* Do not cancel a request if completed more than a threshold percentage.
-* Simple interface to make any type of request.
-* Proper Response Caching, hence reducing bandwidth usage.  
+* Immediate Request really is immediate now.
+* Prefetching of any request can be done so that it gives instant data when required from the cache.
+* Proper request canceling.
+* Prevents cancellation of a request if it’s completed more than a specific threshold percentage.
+* A simple interface to make any type of request.
+* Proper Response Caching — which leads to reduced bandwidth usage. 
 
 ### TODO
 * Integration with other library
@@ -591,7 +628,9 @@ As it uses [OkHttp](http://square.github.io/okhttp/) as a networking layer, it s
 * [Square](https://square.github.io/) - As both [OkHttp](http://square.github.io/okhttp/) and [Okio](https://github.com/square/okio)
   used by Fast Android Networking is developed by [Square](https://square.github.io/).
 * [Volley](https://android.googlesource.com/platform/frameworks/volley/) - As Fast Android Networking uses ImageLoader that is developed by [Volley](https://android.googlesource.com/platform/frameworks/volley/).  
-* [Prashant Gupta](https://github.com/PrashantGupta17) - For RxJava Support - [RxJava Support](https://github.com/amitshekhariitbhu/Fast-Android-Networking/wiki/Using-Fast-Android-Networking-Library-With-RxJava)
+* [Prashant Gupta](https://github.com/PrashantGupta17) - For RxJava, RxJava2 Support - [RxJava Support](https://github.com/amitshekhariitbhu/Fast-Android-Networking/wiki/Using-Fast-Android-Networking-Library-With-RxJava)
+
+### [Check out Mindorks awesome open source projects here](https://mindorks.com/open-source-projects)
 
 ### Contact - Let's become friend
 - [Twitter](https://twitter.com/amitiitbhu)
@@ -618,5 +657,6 @@ As it uses [OkHttp](http://square.github.io/okhttp/) as a networking layer, it s
 ```
 
 ### Contributing to Fast Android Networking
-Just make pull request. You are in!
+All pull requests are welcome, make sure to follow the [contribution guidelines](CONTRIBUTING.md)
+when you submit pull request.
 
diff --git a/RxAndroidNetworking.md b/RxAndroidNetworking.md
deleted file mode 100644
index dc6ab86..0000000
--- a/RxAndroidNetworking.md
+++ /dev/null
@@ -1,627 +0,0 @@
-# Using Fast Android Networking Library with [RxJava](https://github.com/ReactiveX/RxJava)
-
-Add this in your build.gradle
-```groovy
-    compile 'com.amitshekhar.android:rx-android-networking:0.1.0'
-```
-
-Then initialize it in onCreate() Method of application class :
-```java
-    AndroidNetworking.initialize(getApplicationContext());
-```
-
-### All these below examples are working and available on this repo in rx-sample-app.
-
-### Using Map Operator
-```java
-    /*    
-    * Here we are getting ApiUser Object from api server
-    * then we are converting it into User Object because 
-    * may be our database support User Not ApiUser Object
-    * Here we are using Map Operator to do that
-    */
-    RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAnUser/{userId}")
-                    .addPathParameter("userId", "1")
-                    .build()
-                    .getParseObservable(new TypeToken<ApiUser>() {
-                    })
-                    .subscribeOn(Schedulers.io())
-                    .observeOn(AndroidSchedulers.mainThread())
-                    .map(new Func1<ApiUser, User>() { // takes ApiUser and returns User
-                        @Override
-                        public User call(ApiUser apiUser) {
-                            // here we get ApiUser from server
-                            User user = new User(apiUser);
-                            // then by converting, we are returing user
-                            return user;
-                        }
-                    })
-                    .subscribe(new Observer<User>() {
-                        @Override
-                        public void onCompleted() {
-                            // do anything onComplete
-                        }
-                        @Override
-                        public void onError(Throwable e) {
-                            // handle error
-                        }
-                        @Override
-                        public void onNext(User user) {
-                            // do anything with user
-                        }
-                    });
-```
-
-### Using Zip Operator - Combining two network request
-```java
-
-    /*    
-    * Here we are making two network calls 
-    * One returns the list of cricket fans
-    * Another one returns the list of football fans
-    * Then we are finding the list of users who loves both
-    */
-    
-    /*
-    * This observable return the list of User who loves cricket
-    */
-    private Observable<List<User>> getCricketFansObservable() {
-        return RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllCricketFans")
-                .build()
-                .getParseObservable(new TypeToken<List<User>>() {
-                });
-    }
-
-    /*
-    * This observable return the list of User who loves Football
-    */
-    private Observable<List<User>> getFootballFansObservable() {
-        return RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllFootballFans")
-                .build()
-                .getParseObservable(new TypeToken<List<User>>() {
-                });
-    }
-
-    /*
-    * This do the complete magic, make both network call
-    * and then returns the list of user who loves both
-    * Using zip operator to get both response at a time
-    */
-    private void findUsersWhoLovesBoth() {
-        // here we are using zip operator to combine both request
-        Observable.zip(getCricketFansObservable(), getFootballFansObservable(),
-                new Func2<List<User>, List<User>, List<User>>() {
-                    @Override
-                    public List<User> call(List<User> cricketFans,
-                                           List<User> footballFans) {
-                        List<User> userWhoLovesBoth = 
-                                filterUserWhoLovesBoth(cricketFans, footballFans);
-                        return userWhoLovesBoth;
-                    }
-                }
-        ).subscribeOn(Schedulers.newThread())
-        .observeOn(AndroidSchedulers.mainThread())
-        .subscribe(new Observer<List<User>>() {
-            @Override
-            public void onCompleted() {
-            // do anything onComplete
-            }
-
-            @Override
-            public void onError(Throwable e) {
-            // handle error
-            }
-
-            @Override
-            public void onNext(List<User> users) {
-            // do anything with user who loves both
-            }
-        });
-    }
-
-    private List<User> filterUserWhoLovesBoth(List<User> cricketFans, List<User> footballFans) {
-        List<User> userWhoLovesBoth = new ArrayList<>();
-        // your logic to filter who loves both
-        return userWhoLovesBoth;
-    }
-``` 
-
-### Using FlatMap And Filter Operators
-```java
-
-       /*    
-       * First of all we are getting my friends list from
-       * server, then by using flatMap we are emitting users
-       * one by one and then after applying filter we are
-       * returning only those who are following me one by one.
-       */
-       
-       /*
-       * This observable return the list of User who are my friends
-       */    
-       private Observable<List<User>> getAllMyFriendsObservable() {
-           return RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllFriends/{userId}")
-                   .addPathParameter("userId", "1")
-                   .build()
-                   .getParseObservable(new TypeToken<List<User>>() {
-                   });
-       }
-   
-       /*
-       * This method does all
-       */       
-       public void flatMapAndFilter() {
-           getAllMyFriendsObservable()
-                   .flatMap(new Func1<List<User>, Observable<User>>() { // flatMap - to return users one by one
-                       @Override
-                       public Observable<User> call(List<User> usersList) {
-                           return Observable.from(usersList); // returning(emitting) user one by one from usersList.
-                       }
-                   })
-                   .filter(new Func1<User, Boolean>() { // filter operator
-                       @Override
-                       public Boolean call(User user) {
-                           // filtering user who follows me.
-                           return user.isFollowing;
-                       }
-                   })
-                   .subscribeOn(Schedulers.io())
-                   .observeOn(AndroidSchedulers.mainThread())
-                   .subscribe(new Observer<User>() {
-                       @Override
-                       public void onCompleted() {
-                           // do anything onComplete
-                       }
-   
-                       @Override
-                       public void onError(Throwable e) {
-                           // handle error
-                       }
-   
-                       @Override
-                       public void onNext(User user) {
-                           // only the user who is following me comes here one by one
-                       }
-                   });
-       }
-
-```
-
-### Using Take Operator
-```java
-
-    /* Here first of all, we get the list of users from server.
-    * Then using using take operator, it only emits
-    * required number of users. 
-    */
-
-    /*
-    * This observable return the list of users.
-    */
-    private Observable<List<User>> getUserListObservable() {
-        return RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllUsers/{pageNumber}")
-                .addPathParameter("pageNumber", "0")
-                .addQueryParameter("limit", "10")
-                .build()
-                .getParseObservable(new TypeToken<List<User>>() {});
-    }
-
-    getUserListObservable()
-            .flatMap(new Func1<List<User>, Observable<User>>() { // flatMap - to return users one by one
-                @Override
-                public Observable<User> call(List<User> usersList) {
-                    return Observable.from(usersList); // returning user one by one from usersList.
-                }
-            })
-            .take(4) // it will only emit first 4 users out of all
-            .subscribeOn(Schedulers.newThread())
-            .observeOn(AndroidSchedulers.mainThread())
-            .subscribe(new Observer<User>() {
-                @Override
-                public void onCompleted() {
-                    // do something onCompletion
-                }
-
-                @Override
-                public void onError(Throwable e) {
-                    // handle error
-                }
-
-                @Override
-                public void onNext(User user) {
-                    // only four user comes here one by one
-                }
-            });
-```
-
-### Using flatMap Operator
-```java
-
-    /* Here first of all, we get the list of users from server.
-    * Then for each userId from user, it makes the network call to get the detail 
-    * of that user. 
-    * Finally, we get the userDetail for the corresponding user one by one
-    */
-
-    /*
-    * This observable return the list of users.
-    */
-    private Observable<List<User>> getUserListObservable() {
-        return RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllUsers/{pageNumber}")
-                .addPathParameter("pageNumber", "0")
-                .addQueryParameter("limit", "10")
-                .build()
-                .getParseObservable(new TypeToken<List<User>>() {});
-    }
-    
-    /*
-    * This observable return the userDetail corresponding to the user.
-    */
-    private Observable<UserDetail> getUserDetailObservable(long userId) {
-        return RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAnUserDetail/{userId}")
-                .addPathParameter("userId", String.valueOf(userId))
-                .build()
-                .getParseObservable(new TypeToken<UserDetail>() {});
-    }
-    
-    /*
-    * This method do the magic - first gets the list of users
-    * from server.Then, for each user, it makes the network call to get the detail 
-    * of that user.
-    * Finally, we get the UserDetail for the corresponding user one by one
-    */
-    public void flatMap() {
-            getUserListObservable()
-                    .flatMap(new Func1<List<User>, Observable<User>>() { // flatMap - to return users one by one
-                        @Override
-                        public Observable<User> call(List<User> usersList) {
-                            return Observable.from(usersList); // returning user one by one from usersList.
-                        }
-                    })
-                    .flatMap(new Func1<User, Observable<UserDetail>>() {
-                        @Override
-                        public Observable<UserDetail> call(User user) {
-                            // here we get the user one by one
-                            // and returns corresponding getUserDetailObservable
-                            // for that userId
-                            return getUserDetailObservable(user.id);
-                        }
-                    })
-                    .subscribeOn(Schedulers.newThread())
-                    .observeOn(AndroidSchedulers.mainThread())
-                    .subscribe(new Observer<UserDetail>() {
-                        @Override
-                        public void onCompleted() {
-                            // do something onCompleted
-                        }
-    
-                        @Override
-                        public void onError(Throwable e) {
-                            // handle error
-                        }
-    
-                        @Override
-                        public void onNext(UserDetail userDetail) {
-                            // here we get userDetail one by one for all users
-                            Log.d(TAG, "userDetail id : " + userDetail.id);
-                            Log.d(TAG, "userDetail firstname : " + userDetail.firstname);
-                            Log.d(TAG, "userDetail lastname : " + userDetail.lastname);
-                        }
-                    });
-        }
-
-```
-
-### Using combination of flatMap with zip Operator
-```java
-
-    /* Very Similar to above example, only change is 
-    *  that, here we are using zip after flatMap to 
-    * combine(pair) User and UserDetail
-    */ 
-     
-    /*
-    * This method do the magic - first gets the list of users
-    * from server.Then, for each user, it makes the network call to get the detail 
-    * of that user.
-    * Finally, we get the UserDetail for the corresponding user one by one
-    */
-    private void flatMapWithZip() {
-        getUserListObservable()
-                .flatMap(new Func1<List<User>, Observable<User>>() { // flatMap - to return users one by one
-                    @Override
-                    public Observable<User> call(List<User> usersList) {
-                        return Observable.from(usersList); // returning user one by one from usersList.
-                    }
-                })
-                .flatMap(new Func1<User, Observable<Pair<UserDetail, User>>>() {
-                    @Override
-                    public Observable<Pair<UserDetail, User>> call(User user) {
-                      // here we get the user one by one and then we are zipping
-                      // two observable - one getUserDetailObservable (network call to get userDetail)
-                      // and another Observable.just(user) - just to emit user
-                        return Observable.zip(getUserDetailObservable(user.id), // zip to combine two observable
-                                Observable.just(user),
-                                new Func2<UserDetail, User, Pair<UserDetail, User>>() {
-                                    @Override
-                                    public Pair<UserDetail, User> call(UserDetail userDetail, User user) {
-                                        // runs when network call completes 
-                                        // we get here userDetail for the corresponding user
-                                        return new Pair<>(userDetail, user); // returning the pair(userDetail, user)
-                                    }
-                                });
-                    }
-                })
-                .subscribeOn(Schedulers.newThread())
-                .observeOn(AndroidSchedulers.mainThread())
-                .subscribe(new Observer<Pair<UserDetail, User>>() {
-                    @Override
-                    public void onCompleted() {
-                    // do something onCompleted
-                    }
-                    @Override
-                    public void onError(Throwable e) {
-                    // handle error
-                    }
-                    @Override
-                    public void onNext(Pair<UserDetail, User> pair) {
-                        // here we are getting the userDetail for the corresponding user one by one
-                        UserDetail userDetail = pair.first;
-                        User user = pair.second;
-                        Log.d(TAG, "userId : " + user.id);
-                        Log.d(TAG, "userDetail firstname : " + userDetail.firstname);
-                        Log.d(TAG, "userDetail lastname : " + userDetail.lastname);
-                    }
-                });
-    }
-```
-
-### Binding Networking with Activity Lifecycle
-```java
-public class SubscriptionActivity extends Activity {
-
-    private static final String TAG = SubscriptionActivity.class.getSimpleName();
-    private static final String URL = "http://i.imgur.com/AtbX9iX.png";
-    private String dirPath;
-    private String fileName = "imgurimage.png";
-    Subscription subscription;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        dirPath = Utils.getRootDirPath(getApplicationContext());
-        subscription = getObservable()
-                .subscribeOn(Schedulers.io())
-                .observeOn(AndroidSchedulers.mainThread())
-                .subscribe(getObserver());
-    }
-
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        if (subscription != null) {
-            // unsubscribe it when activity onDestroy is called
-            subscription.unsubscribe();
-        }
-    }
-
-    public Observable<String> getObservable() {
-        return RxAndroidNetworking.download(URL, dirPath, fileName)
-                .build()
-                .getDownloadObservable();
-    }
-
-    private Observer<String> getObserver() {
-        return new Observer<String>() {
-            @Override
-            public void onCompleted() {
-                Log.d(TAG, "onCompleted");
-            }
-
-            @Override
-            public void onError(Throwable e) {
-                Log.d(TAG, "onError " + e.getMessage());
-            }
-
-            @Override
-            public void onNext(String response) {
-                Log.d(TAG, "onResponse response : " + response);
-            }
-        };
-    }
-}
-
-```
-
-### Making a GET Request
-```java
-RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllUsers/{pageNumber}")
-                 .addPathParameter("pageNumber", "0")
-                 .addQueryParameter("limit", "3")
-                 .build()
-                 .getJSONArrayObservable()
-                 .subscribeOn(Schedulers.io())
-                 .observeOn(AndroidSchedulers.mainThread())
-                 .subscribe(new Observer<JSONArray>() {
-                      @Override
-                      public void onCompleted() {
-                      // do anything onComplete
-                      }
-                      @Override
-                      public void onError(Throwable e) {
-                      // handle error
-                      }
-                      @Override
-                      public void onNext(JSONArray response) {
-                      //do anything with response
-                      }
-                  });
-```
-
-### Making a POST Request
-```java
-RxAndroidNetworking.post("https://fierce-cove-29863.herokuapp.com/createAnUser")
-                 .addBodyParameter("firstname", "Amit")
-                 .addBodyParameter("lastname", "Shekhar")
-                 .build()
-                 .getJSONObjectObservable()
-                 .subscribeOn(Schedulers.io())
-                 .observeOn(AndroidSchedulers.mainThread())
-                 .subscribe(new Observer<JSONObject>() {
-                      @Override
-                      public void onCompleted() {
-                      // do anything onComplete
-                      }
-                      @Override
-                      public void onError(Throwable e) {
-                      // handle error
-                      }
-                      @Override
-                      public void onNext(JSONObject response) {
-                      //do anything with response
-                      }
-                  });
-```
-
-### Downloading a file from server
-```java
-RxAndroidNetworking.download("http://i.imgur.com/AtbX9iX.png",dirPath,imgurimage.png)
-                 .build()
-                 .setDownloadProgressListener(new DownloadProgressListener() {
-                    @Override
-                    public void onProgress(long bytesDownloaded, long totalBytes) {
-                    // do anything with progress  
-                    }
-                 })
-                 .getDownloadObservable()
-                 .subscribeOn(Schedulers.io()
-                 .observeOn(AndroidSchedulers.mainThread())
-                 .subscribe(new Observer<String>() {
-                      @Override
-                      public void onCompleted() {
-                      // do anything onComplete
-                      }
-                      @Override
-                      public void onError(Throwable e) {
-                      // handle error
-                      }
-                      @Override
-                      public void onNext(String response) {
-                      //gives response = "success"
-                      }
-                  });
-```
-
-### Uploading a file to server
-```java
-RxAndroidNetworking.upload("https://fierce-cove-29863.herokuapp.com/uploadImage")
-                 .addMultipartFile("image", new File(imageFilePath)) 
-                 .addMultipartParameter("key","value") 
-                 .build()
-                 .setUploadProgressListener(new UploadProgressListener() {
-                    @Override
-                    public void onProgress(long bytesUploaded, long totalBytes) {
-                    // do anything with progress  
-                    }
-                 })
-                 .getJSONObjectObservable()
-                 .subscribeOn(Schedulers.io())
-                 .observeOn(AndroidSchedulers.mainThread())
-                 .subscribe(new Observer<JSONObject>() {
-                      @Override
-                      public void onCompleted() {
-                      // do anything onComplete
-                      }
-                      @Override
-                      public void onError(Throwable e) {
-                      // handle error
-                      }
-                      @Override
-                      public void onNext(JSONObject response) {
-                      //do anything with response
-                      }
-                  });
-```
-
-### Using it with your own JAVA Object - JSON Parser
-```java
-/*--------------Example One -> Getting the userList----------------*/
-RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllUsers/{pageNumber}")
-                .addPathParameter("pageNumber", "0")
-                .addQueryParameter("limit", "3")
-                .build()
-                .getParseObservable(new TypeToken<List<User>>() {})
-                .subscribeOn(Schedulers.io())
-                .observeOn(AndroidSchedulers.mainThread())
-                .subscribe(new Observer<List<User>>() {
-                    @Override
-                    public void onCompleted() {
-                        // do anything onComplete 
-                    }
-                    @Override
-                    public void onError(Throwable e) {
-                        // handle error
-                    }
-                    @Override
-                    public void onNext(List<User> users) {
-                        // do anything with response    
-                        Log.d(TAG, "userList size : " + users.size());
-                        for (User user : users) {
-                            Log.d(TAG, "id : " + user.id);
-                            Log.d(TAG, "firstname : " + user.firstname);
-                            Log.d(TAG, "lastname : " + user.lastname);
-                        }
-                    }
-                });                
-/*--------------Example Two -> Getting an user----------------*/
-RxAndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAnUser/{userId}")
-                .addPathParameter("userId", "1")
-                .build()
-                .getParseObservable(new TypeToken<User>() {})
-                .subscribeOn(Schedulers.io())
-                .observeOn(AndroidSchedulers.mainThread())
-                .subscribe(new Observer<User>() {
-                    @Override
-                    public void onCompleted() {
-                        // do anything onComplete 
-                    }
-                    @Override
-                    public void onError(Throwable e) {
-                        // handle error
-                    }
-                    @Override
-                    public void onNext(User user) {
-                        // do anything with response 
-                        Log.d(TAG, "id : " + user.id);
-                        Log.d(TAG, "firstname : " + user.firstname);
-                        Log.d(TAG, "lastname : " + user.lastname);
-                    }
-                });
-/*-- Note : TypeToken and getParseObservable is important here --*/              
-```
-
-### Error Code Handling
-```java
-public void onError(Throwable e) {
-        if (e instanceof ANError) {
-            ANError anError = (ANError) e;
-            if (anError.getErrorCode() != 0) {
-                // received ANError from server
-                // error.getErrorCode() - the ANError code from server
-                // error.getErrorBody() - the ANError body from server
-                // error.getErrorDetail() - just a ANError detail
-                Log.d(TAG, "onError errorCode : " + anError.getErrorCode());
-                Log.d(TAG, "onError errorBody : " + anError.getErrorBody());
-                Log.d(TAG, "onError errorDetail : " + anError.getErrorDetail());
-            } else {
-                // error.getErrorDetail() : connectionError, parseError, requestCancelledError
-                Log.d(TAG, "onError errorDetail : " + anError.getErrorDetail());
-            }
-        } else {
-            Log.d(TAG, "onError errorMessage : " + e.getMessage());
-        }
-   }
-```
-
-### In RxJava, you can do too many things by applying the operators (flatMap, filter, map, mapMany, zip, etc) available in RxJava.
\ No newline at end of file
diff --git a/android-networking/build.gradle b/android-networking/build.gradle
index c29cfa0..e6a08f9 100644
--- a/android-networking/build.gradle
+++ b/android-networking/build.gradle
@@ -18,14 +18,15 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.3"
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
-        targetSdkVersion 23
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "1.0"
+        consumerProguardFiles 'proguard-rules.pro'
     }
     buildTypes {
         release {
@@ -33,13 +34,17 @@ android {
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
+    lintOptions {
+        abortOnError false
+    }
 }
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
-    testCompile 'junit:junit:4.12'
-    androidTestCompile 'com.squareup.okhttp3:mockwebserver:3.2.0'
-    compile 'com.squareup.okhttp3:okhttp:3.2.0'
-    compile 'com.google.code.gson:gson:2.7'
+    testCompile "junit:junit:$rootProject.ext.jUnitVersion"
+    androidTestCompile "com.squareup.okhttp3:mockwebserver:$rootProject.ext.mockWebServerVersion"
+    compile "com.squareup.okhttp3:okhttp:$rootProject.ext.okHttp3Version"
+    compile "com.google.code.gson:gson:$rootProject.ext.gsonVersion"
+    compile "com.android.support:appcompat-v7:$rootProject.ext.supportAppCompatVersion"
 }
 //apply from: 'upload.gradle'
diff --git a/android-networking/proguard-rules.pro b/android-networking/proguard-rules.pro
index 6b7a2bf..3f19523 100644
--- a/android-networking/proguard-rules.pro
+++ b/android-networking/proguard-rules.pro
@@ -15,3 +15,6 @@
 #-keepclassmembers class fqcn.of.javascript.interface.for.webview {
 #   public *;
 #}
+
+# For OkHttp
+-dontwarn okio.**
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/ApplicationTest.java b/android-networking/src/androidTest/java/com/androidnetworking/ApplicationTest.java
deleted file mode 100644
index 2755982..0000000
--- a/android-networking/src/androidTest/java/com/androidnetworking/ApplicationTest.java
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- *    Copyright (C) 2016 Amit Shekhar
- *    Copyright (C) 2011 Android Open Source Project
- *
- *    Licensed under the Apache License, Version 2.0 (the "License");
- *    you may not use this file except in compliance with the License.
- *    You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- *    Unless required by applicable law or agreed to in writing, software
- *    distributed under the License is distributed on an "AS IS" BASIS,
- *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *    See the License for the specific language governing permissions and
- *    limitations under the License.
- */
-
-package com.androidnetworking;
-
-import android.app.Application;
-import android.test.ApplicationTestCase;
-
-import com.androidnetworking.common.ANConstants;
-import com.androidnetworking.error.ANError;
-import com.androidnetworking.interfaces.StringRequestListener;
-
-import org.junit.Rule;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-
-/**
- * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
- */
-public class ApplicationTest extends ApplicationTestCase<Application> {
-    @Rule
-    public final MockWebServer server = new MockWebServer();
-
-    public ApplicationTest() {
-        super(Application.class);
-    }
-
-    @Override
-    public void setUp() throws Exception {
-        super.setUp();
-        createApplication();
-    }
-
-    public void testGetRequest() throws InterruptedException {
-
-        server.enqueue(new MockResponse().setBody("getResponse"));
-
-        final AtomicReference<String> responseRef = new AtomicReference<>();
-        final CountDownLatch latch = new CountDownLatch(1);
-
-        AndroidNetworking.get(server.url("/").toString())
-                .build()
-                .getAsString(new StringRequestListener() {
-                    @Override
-                    public void onResponse(String response) {
-                        responseRef.set(response);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(ANError anError) {
-                        assertTrue(false);
-                    }
-                });
-
-        assertTrue(latch.await(2, SECONDS));
-
-        assertEquals("getResponse", responseRef.get());
-    }
-
-    public void testGetRequest404() throws InterruptedException {
-
-        server.enqueue(new MockResponse().setResponseCode(404).setBody("getResponse"));
-
-        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
-        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
-        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
-        final CountDownLatch latch = new CountDownLatch(1);
-
-        AndroidNetworking.get(server.url("/").toString())
-                .build()
-                .getAsString(new StringRequestListener() {
-                    @Override
-                    public void onResponse(String response) {
-                        assertTrue(false);
-                    }
-
-                    @Override
-                    public void onError(ANError anError) {
-                        errorBodyRef.set(anError.getErrorBody());
-                        errorDetailRef.set(anError.getErrorDetail());
-                        errorCodeRef.set(anError.getErrorCode());
-                        latch.countDown();
-                    }
-                });
-
-        assertTrue(latch.await(2, SECONDS));
-
-        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
-
-        assertEquals("getResponse", errorBodyRef.get());
-
-        assertEquals(404, errorCodeRef.get().intValue());
-
-    }
-
-    public void testPostRequest() throws InterruptedException {
-
-        server.enqueue(new MockResponse().setBody("postResponse"));
-
-        final AtomicReference<String> responseRef = new AtomicReference<>();
-        final CountDownLatch latch = new CountDownLatch(1);
-
-        AndroidNetworking.post(server.url("/").toString())
-                .addBodyParameter("fistName", "Amit")
-                .addBodyParameter("lastName", "Shekhar")
-                .build()
-                .getAsString(new StringRequestListener() {
-                    @Override
-                    public void onResponse(String response) {
-                        responseRef.set(response);
-                        latch.countDown();
-                    }
-
-                    @Override
-                    public void onError(ANError anError) {
-                        assertTrue(false);
-                    }
-                });
-
-        assertTrue(latch.await(2, SECONDS));
-
-        assertEquals("postResponse", responseRef.get());
-    }
-
-
-    public void testPostRequest404() throws InterruptedException {
-
-        server.enqueue(new MockResponse().setResponseCode(404).setBody("postResponse"));
-
-        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
-        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
-        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
-        final CountDownLatch latch = new CountDownLatch(1);
-
-        AndroidNetworking.post(server.url("/").toString())
-                .addBodyParameter("fistName", "Amit")
-                .addBodyParameter("lastName", "Shekhar")
-                .build()
-                .getAsString(new StringRequestListener() {
-                    @Override
-                    public void onResponse(String response) {
-                        assertTrue(false);
-                    }
-
-                    @Override
-                    public void onError(ANError anError) {
-                        errorBodyRef.set(anError.getErrorBody());
-                        errorDetailRef.set(anError.getErrorDetail());
-                        errorCodeRef.set(anError.getErrorCode());
-                        latch.countDown();
-                    }
-                });
-
-        assertTrue(latch.await(2, SECONDS));
-
-        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
-
-        assertEquals("postResponse", errorBodyRef.get());
-
-        assertEquals(404, errorCodeRef.get().intValue());
-    }
-
-
-}
\ No newline at end of file
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/GetJSONApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/GetJSONApiTest.java
new file mode 100644
index 0000000..57e8e33
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/GetJSONApiTest.java
@@ -0,0 +1,469 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.JSONArrayRequestListener;
+import com.androidnetworking.interfaces.JSONObjectRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseAndJSONArrayRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseAndJSONObjectRequestListener;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 03/04/17.
+ */
+
+public class GetJSONApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public GetJSONApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testJSONObjectGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsJSONObject(new JSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONObjectGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsJSONObject(new JSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONArrayGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsJSONArray(new JSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONArrayGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsJSONArray(new JSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONObjectGetRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<JSONObject> response = request.executeForJSONObject();
+
+        assertEquals("Amit", response.getResult().getString("firstName"));
+
+        assertEquals("Shekhar", response.getResult().getString("lastName"));
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONObjectGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<JSONObject> response = request.executeForJSONObject();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONArrayGetRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<JSONArray> response = request.executeForJSONArray();
+
+        JSONObject jsonObject = response.getResult().getJSONObject(0);
+
+        assertEquals("Amit", jsonObject.getString("firstName"));
+
+        assertEquals("Shekhar", jsonObject.getString("lastName"));
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONArrayGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<JSONObject> response = request.executeForJSONArray();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    public void testResponseBodyAndJSONObjectGet() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndJSONObjectGet404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testResponseBodyAndJSONArrayGet() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONArray(new OkHttpResponseAndJSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndJSONArrayGet404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONArray(new OkHttpResponseAndJSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            headerRef.set(okHttpResponse.request().header("headerKey"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+}
\ No newline at end of file
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/GetObjectApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/GetObjectApiTest.java
new file mode 100644
index 0000000..e06a4ac
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/GetObjectApiTest.java
@@ -0,0 +1,450 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.OkHttpResponseAndParsedRequestListener;
+import com.androidnetworking.interfaces.ParsedRequestListener;
+import com.androidnetworking.model.User;
+
+import org.json.JSONException;
+import org.junit.Rule;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 10/04/17.
+ */
+
+public class GetObjectApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public GetObjectApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testObjectGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        firstNameRef.set(userList.get(0).firstName);
+                        lastNameRef.set(userList.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectGetRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        assertEquals("Amit", response.getResult().firstName);
+
+        assertEquals("Shekhar", response.getResult().lastName);
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListGetRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        User user = response.getResult().get(0);
+
+        assertEquals("Amit", user.firstName);
+
+        assertEquals("Shekhar", user.lastName);
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    public void testResponseBodyAndObjectGet() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectGet404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testResponseBodyAndObjectListGet() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                firstNameRef.set(userList.get(0).firstName);
+                                lastNameRef.set(userList.get(0).lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectListGet404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                headerRef.set(okHttpResponse.request().header("headerKey"));
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+}
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/GetStringApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/GetStringApiTest.java
new file mode 100644
index 0000000..aaef6fe
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/GetStringApiTest.java
@@ -0,0 +1,348 @@
+/*
+ *    Copyright (C) 2016 Amit Shekhar
+ *    Copyright (C) 2011 Android Open Source Project
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.OkHttpResponseAndStringRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseListener;
+import com.androidnetworking.interfaces.StringRequestListener;
+
+import org.junit.Rule;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+public class GetStringApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public GetStringApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testStringGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsString(new StringRequestListener() {
+                    @Override
+                    public void onResponse(String response) {
+                        responseRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testStringGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsString(new StringRequestListener() {
+                    @Override
+                    public void onResponse(String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousStringGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<String> response = request.executeForString();
+
+        assertEquals("data", response.getResult());
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousStringGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<String> response = request.executeForString();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+    }
+
+    public void testResponseBodyGet() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponse(new OkHttpResponseListener() {
+                    @Override
+                    public void onResponse(Response response) {
+                        try {
+                            responseRef.set(response.body().string());
+                            latch.countDown();
+                        } catch (IOException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testResponseBodyGet404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponse(new OkHttpResponseListener() {
+                    @Override
+                    public void onResponse(Response response) {
+                        try {
+                            errorBodyRef.set(response.body().string());
+                            errorCodeRef.set(response.code());
+                            latch.countDown();
+                        } catch (IOException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSyncResponseBodyGet() throws InterruptedException, IOException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<Response> response = request.executeForOkHttpResponse();
+
+        assertEquals("data", response.getResult().body().string());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSyncResponseBodyGet404() throws InterruptedException, IOException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<Response> response = request.executeForOkHttpResponse();
+
+        assertEquals("data", response.getResult().body().string());
+
+        assertEquals(404, response.getResult().code());
+    }
+
+    public void testResponseBodyAndStringGet() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final AtomicReference<String> responseStringRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        responseBodySuccess.set(okHttpResponse.isSuccessful());
+                        responseStringRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("data", responseStringRef.get());
+    }
+
+    public void testResponseBodyAndStringGet404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        responseRef.set(response);
+                        responseBodySuccess.set(okHttpResponse.isSuccessful());
+                        headerRef.set(okHttpResponse.request().header("headerKey"));
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("data", responseRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+}
\ No newline at end of file
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/MultipartJSONApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/MultipartJSONApiTest.java
new file mode 100644
index 0000000..3fdc4cf
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/MultipartJSONApiTest.java
@@ -0,0 +1,487 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.JSONArrayRequestListener;
+import com.androidnetworking.interfaces.JSONObjectRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseAndJSONArrayRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseAndJSONObjectRequestListener;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 09/04/17.
+ */
+
+public class MultipartJSONApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public MultipartJSONApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testJSONObjectMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsJSONObject(new JSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONObjectMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsJSONObject(new JSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONArrayMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsJSONArray(new JSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONArrayMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsJSONArray(new JSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONObjectMultipartRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<JSONObject> response = request.executeForJSONObject();
+
+        assertEquals("Amit", response.getResult().getString("firstName"));
+
+        assertEquals("Shekhar", response.getResult().getString("lastName"));
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONObjectMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<JSONObject> response = request.executeForJSONObject();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONArrayMultipartRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<JSONArray> response = request.executeForJSONArray();
+
+        JSONObject jsonObject = response.getResult().getJSONObject(0);
+
+        assertEquals("Amit", jsonObject.getString("firstName"));
+
+        assertEquals("Shekhar", jsonObject.getString("lastName"));
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONArrayMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<JSONObject> response = request.executeForJSONArray();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    public void testResponseBodyAndJSONObjectMultipart() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndJSONObjectMultipart404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testResponseBodyAndJSONArrayMultipart() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONArray(new OkHttpResponseAndJSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndJSONArrayMultipart404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONArray(new OkHttpResponseAndJSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            headerRef.set(okHttpResponse.request().header("headerKey"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+
+}
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/MultipartObjectApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/MultipartObjectApiTest.java
new file mode 100644
index 0000000..e223381
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/MultipartObjectApiTest.java
@@ -0,0 +1,467 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.OkHttpResponseAndParsedRequestListener;
+import com.androidnetworking.interfaces.ParsedRequestListener;
+import com.androidnetworking.model.User;
+
+import org.json.JSONException;
+import org.junit.Rule;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 12/04/17.
+ */
+
+public class MultipartObjectApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public MultipartObjectApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testObjectMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        firstNameRef.set(userList.get(0).firstName);
+                        lastNameRef.set(userList.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectMultipartRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        assertEquals("Amit", response.getResult().firstName);
+
+        assertEquals("Shekhar", response.getResult().lastName);
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListMultipartRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        User user = response.getResult().get(0);
+
+        assertEquals("Amit", user.firstName);
+
+        assertEquals("Shekhar", user.lastName);
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    public void testResponseBodyAndObjectMultipart() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectMultipart404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testResponseBodyAndObjectListMultipart() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                firstNameRef.set(userList.get(0).firstName);
+                                lastNameRef.set(userList.get(0).lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectListMultipart404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                headerRef.set(okHttpResponse.request().header("headerKey"));
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+}
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/MultipartStringApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/MultipartStringApiTest.java
new file mode 100644
index 0000000..af01aa9
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/MultipartStringApiTest.java
@@ -0,0 +1,371 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.OkHttpResponseAndParsedRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseAndStringRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseListener;
+import com.androidnetworking.interfaces.StringRequestListener;
+import com.androidnetworking.model.User;
+
+import org.junit.Rule;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 27/03/17.
+ */
+
+public class MultipartStringApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public MultipartStringApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testStringMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsString(new StringRequestListener() {
+                    @Override
+                    public void onResponse(String response) {
+                        responseRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testStringMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getAsString(new StringRequestListener() {
+                    @Override
+                    public void onResponse(String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousStringMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<String> response = request.executeForString();
+
+        assertEquals("data", response.getResult());
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<String> response = request.executeForString();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+    }
+
+    public void testResponseBodyMultipart() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponse(new OkHttpResponseListener() {
+                    @Override
+                    public void onResponse(Response response) {
+                        try {
+                            responseRef.set(response.body().string());
+                            latch.countDown();
+                        } catch (IOException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testResponseBodyMultipart404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponse(new OkHttpResponseListener() {
+                    @Override
+                    public void onResponse(Response response) {
+                        try {
+                            errorBodyRef.set(response.body().string());
+                            errorCodeRef.set(response.code());
+                            latch.countDown();
+                        } catch (IOException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSyncResponseBodyMultipart() throws InterruptedException, IOException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<Response> response = request.executeForOkHttpResponse();
+
+        assertEquals("data", response.getResult().body().string());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSyncResponseBodyMultipart404() throws InterruptedException, IOException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build();
+
+        ANResponse<Response> response = request.executeForOkHttpResponse();
+
+        assertEquals("data", response.getResult().body().string());
+
+        assertEquals(404, response.getResult().code());
+    }
+
+    public void testResponseBodyAndStringMultipart() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final AtomicReference<String> responseStringRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        responseBodySuccess.set(okHttpResponse.isSuccessful());
+                        responseStringRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("data", responseStringRef.get());
+    }
+
+    public void testResponseBodyAndStringMultipart404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.upload(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .addMultipartParameter("key", "value")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        responseRef.set(response);
+                        responseBodySuccess.set(okHttpResponse.isSuccessful());
+                        headerRef.set(okHttpResponse.request().header("headerKey"));
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("data", responseRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+}
\ No newline at end of file
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/PostJSONApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/PostJSONApiTest.java
new file mode 100644
index 0000000..2f9a244
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/PostJSONApiTest.java
@@ -0,0 +1,499 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.JSONArrayRequestListener;
+import com.androidnetworking.interfaces.JSONObjectRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseAndJSONArrayRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseAndJSONObjectRequestListener;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 06/04/17.
+ */
+
+public class PostJSONApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public PostJSONApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testJSONObjectPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsJSONObject(new JSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONObjectPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsJSONObject(new JSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONArrayPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsJSONArray(new JSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONArrayPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsJSONArray(new JSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONObjectPostRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<JSONObject> response = request.executeForJSONObject();
+
+        assertEquals("Amit", response.getResult().getString("firstName"));
+
+        assertEquals("Shekhar", response.getResult().getString("lastName"));
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONObjectPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<JSONObject> response = request.executeForJSONObject();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONArrayPostRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<JSONArray> response = request.executeForJSONArray();
+
+        JSONObject jsonObject = response.getResult().getJSONObject(0);
+
+        assertEquals("Amit", jsonObject.getString("firstName"));
+
+        assertEquals("Shekhar", jsonObject.getString("lastName"));
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousJSONArrayPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<JSONObject> response = request.executeForJSONArray();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    public void testResponseBodyAndJSONObjectPost() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndJSONObjectPost404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testResponseBodyAndJSONArrayPost() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONArray(new OkHttpResponseAndJSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndJSONArrayPost404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONArray(new OkHttpResponseAndJSONArrayRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndJSONObject(new OkHttpResponseAndJSONObjectRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            responseBodySuccess.set(okHttpResponse.isSuccessful());
+                            headerRef.set(okHttpResponse.request().header("headerKey"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+}
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/PostObjectApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/PostObjectApiTest.java
new file mode 100644
index 0000000..2865436
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/PostObjectApiTest.java
@@ -0,0 +1,480 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.OkHttpResponseAndParsedRequestListener;
+import com.androidnetworking.interfaces.ParsedRequestListener;
+import com.androidnetworking.model.User;
+
+import org.json.JSONException;
+import org.junit.Rule;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 11/04/17.
+ */
+
+public class PostObjectApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public PostObjectApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testObjectPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        firstNameRef.set(userList.get(0).firstName);
+                        lastNameRef.set(userList.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectPostRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        assertEquals("Amit", response.getResult().firstName);
+
+        assertEquals("Shekhar", response.getResult().lastName);
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListPostRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        User user = response.getResult().get(0);
+
+        assertEquals("Amit", user.firstName);
+
+        assertEquals("Shekhar", user.lastName);
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    public void testResponseBodyAndObjectPost() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectPost404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testResponseBodyAndObjectListPost() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                firstNameRef.set(userList.get(0).firstName);
+                                lastNameRef.set(userList.get(0).lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectListPost404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                headerRef.set(okHttpResponse.request().header("headerKey"));
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+}
diff --git a/android-networking/src/androidTest/java/com/androidnetworking/PostStringApiTest.java b/android-networking/src/androidTest/java/com/androidnetworking/PostStringApiTest.java
new file mode 100644
index 0000000..17b527a
--- /dev/null
+++ b/android-networking/src/androidTest/java/com/androidnetworking/PostStringApiTest.java
@@ -0,0 +1,381 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.OkHttpResponseAndStringRequestListener;
+import com.androidnetworking.interfaces.OkHttpResponseListener;
+import com.androidnetworking.interfaces.StringRequestListener;
+
+import org.junit.Rule;
+
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 25/03/17.
+ */
+
+public class PostStringApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public PostStringApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testStringPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsString(new StringRequestListener() {
+                    @Override
+                    public void onResponse(String response) {
+                        responseRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", responseRef.get());
+    }
+
+
+    public void testStringPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsString(new StringRequestListener() {
+                    @Override
+                    public void onResponse(String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousStringPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<String> response = request.executeForString();
+
+        assertEquals("data", response.getResult());
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousStringPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<String> response = request.executeForString();
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+    }
+
+    public void testResponseBodyPost() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponse(new OkHttpResponseListener() {
+                    @Override
+                    public void onResponse(Response response) {
+                        try {
+                            responseRef.set(response.body().string());
+                            latch.countDown();
+                        } catch (IOException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testResponseBodyPost404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponse(new OkHttpResponseListener() {
+                    @Override
+                    public void onResponse(Response response) {
+                        try {
+                            errorBodyRef.set(response.body().string());
+                            errorCodeRef.set(response.code());
+                            latch.countDown();
+                        } catch (IOException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSyncResponseBodyPost() throws InterruptedException, IOException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<Response> response = request.executeForOkHttpResponse();
+
+        assertEquals("data", response.getResult().body().string());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSyncResponseBodyPost404() throws InterruptedException, IOException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<Response> response = request.executeForOkHttpResponse();
+
+        assertEquals("data", response.getResult().body().string());
+
+        assertEquals(404, response.getResult().code());
+    }
+
+    public void testResponseBodyAndStringPost() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final AtomicReference<String> responseStringRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        responseBodySuccess.set(okHttpResponse.isSuccessful());
+                        responseStringRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("data", responseStringRef.get());
+    }
+
+    public void testResponseBodyAndStringPost404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndString(new OkHttpResponseAndStringRequestListener() {
+                    @Override
+                    public void onResponse(Response okHttpResponse, String response) {
+                        responseRef.set(response);
+                        responseBodySuccess.set(okHttpResponse.isSuccessful());
+                        headerRef.set(okHttpResponse.request().header("headerKey"));
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("data", responseRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+}
diff --git a/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/ApplicationTest.java b/android-networking/src/androidTest/java/com/androidnetworking/model/User.java
similarity index 68%
rename from jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/ApplicationTest.java
rename to android-networking/src/androidTest/java/com/androidnetworking/model/User.java
index a422a0b..4337a8f 100644
--- a/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/ApplicationTest.java
+++ b/android-networking/src/androidTest/java/com/androidnetworking/model/User.java
@@ -17,16 +17,15 @@
  *
  */
 
-package com.jacksonandroidnetworking;
-
-import android.app.Application;
-import android.test.ApplicationTestCase;
+package com.androidnetworking.model;
 
 /**
- * <a href="http://d.android.com/tools/testing/testing_android.html">Testing Fundamentals</a>
+ * Created by amitshekhar on 10/04/17.
  */
-public class ApplicationTest extends ApplicationTestCase<Application> {
-    public ApplicationTest() {
-        super(Application.class);
-    }
-}
\ No newline at end of file
+
+public class User {
+
+    public String firstName;
+    public String lastName;
+
+}
diff --git a/android-networking/src/main/java/com/androidnetworking/AndroidNetworking.java b/android-networking/src/main/java/com/androidnetworking/AndroidNetworking.java
index 02dc002..84c50bf 100644
--- a/android-networking/src/main/java/com/androidnetworking/AndroidNetworking.java
+++ b/android-networking/src/main/java/com/androidnetworking/AndroidNetworking.java
@@ -18,13 +18,14 @@
 package com.androidnetworking;
 
 import android.content.Context;
+import android.graphics.BitmapFactory;
 
 import com.androidnetworking.common.ANConstants;
-import com.androidnetworking.common.ANLog;
 import com.androidnetworking.common.ANRequest;
 import com.androidnetworking.common.ConnectionClassManager;
 import com.androidnetworking.common.ConnectionQuality;
 import com.androidnetworking.core.Core;
+import com.androidnetworking.interceptors.HttpLoggingInterceptor.Level;
 import com.androidnetworking.interfaces.ConnectionQualityChangeListener;
 import com.androidnetworking.interfaces.Parser;
 import com.androidnetworking.internal.ANImageLoader;
@@ -83,6 +84,17 @@ public static void initialize(Context context, OkHttpClient okHttpClient) {
         ANImageLoader.initialize();
     }
 
+    /**
+     * Method to set decodeOptions
+     *
+     * @param decodeOptions The decode config for Bitmaps
+     */
+    public static void setBitmapDecodeOptions(BitmapFactory.Options decodeOptions) {
+        if (decodeOptions != null) {
+            ANImageLoader.getInstance().setBitmapDecodeOptions(decodeOptions);
+        }
+    }
+
     /**
      * Method to set connectionQualityChangeListener
      *
@@ -119,6 +131,16 @@ public static void removeConnectionQualityChangeListener() {
         return new ANRequest.HeadRequestBuilder(url);
     }
 
+    /**
+     * Method to make OPTIONS request
+     *
+     * @param url The url on which request is to be made
+     * @return The OptionsRequestBuilder
+     */
+    public static ANRequest.OptionsRequestBuilder options(String url) {
+        return new ANRequest.OptionsRequestBuilder(url);
+    }
+
     /**
      * Method to make POST request
      *
@@ -181,6 +203,17 @@ public static void removeConnectionQualityChangeListener() {
         return new ANRequest.MultiPartBuilder(url);
     }
 
+    /**
+     * Method to make Dynamic request
+     *
+     * @param url    The url on which request is to be made
+     * @param method The HTTP METHOD for the request
+     * @return The DynamicRequestBuilder
+     */
+    public static ANRequest.DynamicRequestBuilder request(String url, int method) {
+        return new ANRequest.DynamicRequestBuilder(url, method);
+    }
+
     /**
      * Method to cancel requests with the given tag
      *
@@ -217,24 +250,16 @@ public static void forceCancelAll() {
      * Method to enable logging
      */
     public static void enableLogging() {
-        ANLog.enableLogging();
+        enableLogging(Level.BASIC);
     }
 
     /**
      * Method to enable logging with tag
      *
-     * @param tag The tag for logging
+     * @param level The level for logging
      */
-    public static void enableLogging(String tag) {
-        ANLog.enableLogging();
-        ANLog.setTag(tag);
-    }
-
-    /**
-     * Method to disable logging
-     */
-    public static void disableLogging() {
-        ANLog.disableLogging();
+    public static void enableLogging(Level level) {
+        InternalNetworking.enableLogging(level);
     }
 
     /**
@@ -295,6 +320,16 @@ public static void setParserFactory(Parser.Factory parserFactory) {
         ParseUtil.setParserFactory(parserFactory);
     }
 
+    /**
+     * Method to find if the request is running or not
+     *
+     * @param tag The tag with which request running status is to be checked
+     * @return The request is running or not
+     */
+    public static boolean isRequestRunning(Object tag) {
+        return ANRequestQueue.getInstance().isRequestRunning(tag);
+    }
+
     /**
      * Shuts AndroidNetworking down
      */
diff --git a/android-networking/src/main/java/com/androidnetworking/common/ANConstants.java b/android-networking/src/main/java/com/androidnetworking/common/ANConstants.java
index dbf5622..89d36aa 100644
--- a/android-networking/src/main/java/com/androidnetworking/common/ANConstants.java
+++ b/android-networking/src/main/java/com/androidnetworking/common/ANConstants.java
@@ -28,9 +28,9 @@
     public static final String RESPONSE_FROM_SERVER_ERROR = "responseFromServerError";
     public static final String REQUEST_CANCELLED_ERROR = "requestCancelledError";
     public static final String PARSE_ERROR = "parseError";
-    public static final String NETWORK_ON_MAIN_THREAD_ERROR = "networkOnMainThreadError";
     public static final String PREFETCH = "prefetch";
-    public static final String ANDROID_NETWORKING = "AndroidNetworking";
+    public static final String FAST_ANDROID_NETWORKING = "FastAndroidNetworking";
     public static final String USER_AGENT = "User-Agent";
     public static final String SUCCESS = "success";
+    public static final String OPTIONS = "OPTIONS";
 }
diff --git a/android-networking/src/main/java/com/androidnetworking/common/ANLog.java b/android-networking/src/main/java/com/androidnetworking/common/ANLog.java
deleted file mode 100644
index 33f50b9..0000000
--- a/android-networking/src/main/java/com/androidnetworking/common/ANLog.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- *    Copyright (C) 2016 Amit Shekhar
- *    Copyright (C) 2011 Android Open Source Project
- *
- *    Licensed under the Apache License, Version 2.0 (the "License");
- *    you may not use this file except in compliance with the License.
- *    You may obtain a copy of the License at
- *
- *        http://www.apache.org/licenses/LICENSE-2.0
- *
- *    Unless required by applicable law or agreed to in writing, software
- *    distributed under the License is distributed on an "AS IS" BASIS,
- *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *    See the License for the specific language governing permissions and
- *    limitations under the License.
- */
-
-package com.androidnetworking.common;
-
-import android.util.Log;
-
-/**
- * Created by amitshekhar on 01/06/16.
- */
-public class ANLog {
-
-    private static boolean IS_LOGGING_ENABLED = false;
-    private static String TAG = ANConstants.ANDROID_NETWORKING;
-
-    private ANLog() {
-
-    }
-
-    public static void enableLogging() {
-        IS_LOGGING_ENABLED = true;
-    }
-
-    public static void disableLogging() {
-        IS_LOGGING_ENABLED = false;
-    }
-
-    public static void setTag(String tag) {
-        if (tag == null) {
-            return;
-        }
-        TAG = tag;
-    }
-
-    public static void d(String message) {
-        if (IS_LOGGING_ENABLED) {
-            Log.d(TAG, message);
-        }
-    }
-
-    public static void e(String message) {
-        if (IS_LOGGING_ENABLED) {
-            Log.e(TAG, message);
-        }
-    }
-
-    public static void i(String message) {
-        if (IS_LOGGING_ENABLED) {
-            Log.i(TAG, message);
-        }
-    }
-
-    public static void w(String message) {
-        if (IS_LOGGING_ENABLED) {
-            Log.w(TAG, message);
-        }
-    }
-
-    public static void wtf(String message) {
-        if (IS_LOGGING_ENABLED) {
-            Log.wtf(TAG, message);
-        }
-    }
-
-}
diff --git a/android-networking/src/main/java/com/androidnetworking/common/ANRequest.java b/android-networking/src/main/java/com/androidnetworking/common/ANRequest.java
index cea7ee2..ab75617 100644
--- a/android-networking/src/main/java/com/androidnetworking/common/ANRequest.java
+++ b/android-networking/src/main/java/com/androidnetworking/common/ANRequest.java
@@ -18,6 +18,7 @@
 package com.androidnetworking.common;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.widget.ImageView;
 
 import com.androidnetworking.core.Core;
@@ -41,6 +42,7 @@
 import com.androidnetworking.internal.SynchronousCall;
 import com.androidnetworking.utils.ParseUtil;
 import com.androidnetworking.utils.Utils;
+import com.google.gson.internal.$Gson$Types;
 import com.google.gson.reflect.TypeToken;
 
 import org.json.JSONArray;
@@ -48,7 +50,11 @@
 
 import java.io.File;
 import java.lang.reflect.Type;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
@@ -80,17 +86,16 @@
     private int sequenceNumber;
     private Object mTag;
     private ResponseType mResponseType;
-    private HashMap<String, String> mHeadersMap = new HashMap<>();
+    private HashMap<String, List<String>> mHeadersMap = new HashMap<>();
     private HashMap<String, String> mBodyParameterMap = new HashMap<>();
     private HashMap<String, String> mUrlEncodedFormBodyParameterMap = new HashMap<>();
     private HashMap<String, String> mMultiPartParameterMap = new HashMap<>();
-    private HashMap<String, String> mQueryParameterMap = new HashMap<>();
+    private HashMap<String, List<String>> mQueryParameterMap = new HashMap<>();
     private HashMap<String, String> mPathParameterMap = new HashMap<>();
     private HashMap<String, File> mMultiPartFileMap = new HashMap<>();
     private String mDirPath;
     private String mFileName;
-    private JSONObject mJsonObject = null;
-    private JSONArray mJsonArray = null;
+    private String mApplicationJsonString = null;
     private String mStringBody = null;
     private byte[] mByte = null;
     private File mFile = null;
@@ -106,6 +111,7 @@
     private int mProgress;
     private boolean isCancelled;
     private boolean isDelivered;
+    private boolean isRunning;
     private int mPercentageThresholdForCancelling = 0;
     private JSONArrayRequestListener mJSONArrayRequestListener;
     private JSONObjectRequestListener mJSONObjectRequestListener;
@@ -163,8 +169,7 @@ public ANRequest(PostRequestBuilder builder) {
         this.mUrlEncodedFormBodyParameterMap = builder.mUrlEncodedFormBodyParameterMap;
         this.mQueryParameterMap = builder.mQueryParameterMap;
         this.mPathParameterMap = builder.mPathParameterMap;
-        this.mJsonObject = builder.mJsonObject;
-        this.mJsonArray = builder.mJsonArray;
+        this.mApplicationJsonString = builder.mApplicationJsonString;
         this.mStringBody = builder.mStringBody;
         this.mFile = builder.mFile;
         this.mByte = builder.mByte;
@@ -253,6 +258,20 @@ public void getAsParsed(TypeToken typeToken, ParsedRequestListener parsedRequest
         ANRequestQueue.getInstance().addRequest(this);
     }
 
+    public void getAsObject(Class objectClass, ParsedRequestListener parsedRequestListener) {
+        this.mType = objectClass;
+        this.mResponseType = ResponseType.PARSED;
+        this.mParsedRequestListener = parsedRequestListener;
+        ANRequestQueue.getInstance().addRequest(this);
+    }
+
+    public void getAsObjectList(Class objectClass, ParsedRequestListener parsedRequestListener) {
+        this.mType = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, objectClass);
+        this.mResponseType = ResponseType.PARSED;
+        this.mParsedRequestListener = parsedRequestListener;
+        ANRequestQueue.getInstance().addRequest(this);
+    }
+
     public void getAsOkHttpResponseAndJSONObject(OkHttpResponseAndJSONObjectRequestListener requestListener) {
         this.mResponseType = ResponseType.JSON_OBJECT;
         this.mOkHttpResponseAndJSONObjectRequestListener = requestListener;
@@ -285,6 +304,19 @@ public void getAsOkHttpResponseAndParsed(TypeToken typeToken, OkHttpResponseAndP
         ANRequestQueue.getInstance().addRequest(this);
     }
 
+    public void getAsOkHttpResponseAndObject(Class objectClass, OkHttpResponseAndParsedRequestListener parsedRequestListener) {
+        this.mType = objectClass;
+        this.mResponseType = ResponseType.PARSED;
+        this.mOkHttpResponseAndParsedRequestListener = parsedRequestListener;
+        ANRequestQueue.getInstance().addRequest(this);
+    }
+
+    public void getAsOkHttpResponseAndObjectList(Class objectClass, OkHttpResponseAndParsedRequestListener parsedRequestListener) {
+        this.mType = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, objectClass);
+        this.mResponseType = ResponseType.PARSED;
+        this.mOkHttpResponseAndParsedRequestListener = parsedRequestListener;
+        ANRequestQueue.getInstance().addRequest(this);
+    }
 
     public void startDownload(DownloadListener downloadListener) {
         this.mDownloadListener = downloadListener;
@@ -327,6 +359,18 @@ public ANResponse executeForParsed(TypeToken typeToken) {
         return SynchronousCall.execute(this);
     }
 
+    public ANResponse executeForObject(Class objectClass) {
+        this.mType = objectClass;
+        this.mResponseType = ResponseType.PARSED;
+        return SynchronousCall.execute(this);
+    }
+
+    public ANResponse executeForObjectList(Class objectClass) {
+        this.mType = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, objectClass);
+        this.mResponseType = ResponseType.PARSED;
+        return SynchronousCall.execute(this);
+    }
+
     public ANResponse executeForDownload() {
         return SynchronousCall.execute(this);
     }
@@ -364,8 +408,17 @@ public String getUrl() {
             tempUrl = tempUrl.replace("{" + entry.getKey() + "}", String.valueOf(entry.getValue()));
         }
         HttpUrl.Builder urlBuilder = HttpUrl.parse(tempUrl).newBuilder();
-        for (HashMap.Entry<String, String> entry : mQueryParameterMap.entrySet()) {
-            urlBuilder.addQueryParameter(entry.getKey(), entry.getValue());
+        if (mQueryParameterMap != null) {
+            Set<Map.Entry<String, List<String>>> entries = mQueryParameterMap.entrySet();
+            for (Map.Entry<String, List<String>> entry : entries) {
+                String name = entry.getKey();
+                List<String> list = entry.getValue();
+                if (list != null) {
+                    for (String value : list) {
+                        urlBuilder.addQueryParameter(name, value);
+                    }
+                }
+            }
         }
         return urlBuilder.build().toString();
     }
@@ -440,7 +493,6 @@ public void run() {
                             if (mDownloadListener != null) {
                                 mDownloadListener.onDownloadComplete();
                             }
-                            ANLog.d("Delivering success : " + toString());
                             finish();
                         }
                     });
@@ -451,7 +503,6 @@ public void run() {
                             if (mDownloadListener != null) {
                                 mDownloadListener.onDownloadComplete();
                             }
-                            ANLog.d("Delivering success : " + toString());
                             finish();
                         }
                     });
@@ -461,7 +512,6 @@ public void run() {
                 finish();
             }
         } else {
-            ANLog.d("Prefetch done : " + toString());
             finish();
         }
     }
@@ -498,8 +548,8 @@ public void cancel(boolean forceCancel) {
         try {
             if (forceCancel || mPercentageThresholdForCancelling == 0
                     || mProgress < mPercentageThresholdForCancelling) {
-                ANLog.d("cancelling request : " + toString());
                 isCancelled = true;
+                isRunning = false;
                 if (call != null) {
                     call.cancel();
                 }
@@ -509,8 +559,6 @@ public void cancel(boolean forceCancel) {
                 if (!isDelivered) {
                     deliverError(new ANError());
                 }
-            } else {
-                ANLog.d("not cancelling request : " + toString());
             }
         } catch (Exception e) {
             e.printStackTrace();
@@ -521,6 +569,14 @@ public boolean isCanceled() {
         return isCancelled;
     }
 
+    public boolean isRunning() {
+        return isRunning;
+    }
+
+    public void setRunning(boolean running) {
+        isRunning = running;
+    }
+
     public Call getCall() {
         return call;
     }
@@ -539,7 +595,7 @@ public void setFuture(Future future) {
 
     public void destroy() {
         mJSONArrayRequestListener = null;
-        mJSONArrayRequestListener = null;
+        mJSONObjectRequestListener = null;
         mStringRequestListener = null;
         mBitmapRequestListener = null;
         mParsedRequestListener = null;
@@ -595,7 +651,12 @@ public ANResponse parseResponse(Response response) {
                     return ANResponse.failed(Utils.getErrorForParse(new ANError(e)));
                 }
             case PREFETCH:
-                return ANResponse.success(ANConstants.PREFETCH);
+                try {
+                    Okio.buffer(response.body().source()).skip(Long.MAX_VALUE);
+                    return ANResponse.success(ANConstants.PREFETCH);
+                } catch (Exception e) {
+                    return ANResponse.failed(Utils.getErrorForParse(new ANError(e)));
+                }
         }
         return null;
     }
@@ -621,7 +682,6 @@ public synchronized void deliverError(ANError anError) {
                     anError.setErrorCode(0);
                 }
                 deliverErrorResponse(anError);
-                ANLog.d("Delivering anError : " + toString());
             }
             isDelivered = true;
         } catch (Exception e) {
@@ -648,14 +708,12 @@ public void run() {
                         }
                     });
                 }
-                ANLog.d("Delivering success : " + toString());
             } else {
                 ANError anError = new ANError();
                 anError.setCancellationMessageInError();
                 anError.setErrorCode(0);
                 deliverErrorResponse(anError);
                 finish();
-                ANLog.d("Delivering cancelled : " + toString());
             }
         } catch (Exception e) {
             e.printStackTrace();
@@ -698,6 +756,8 @@ private void deliverErrorResponse(ANError anError) {
             mBitmapRequestListener.onError(anError);
         } else if (mParsedRequestListener != null) {
             mParsedRequestListener.onError(anError);
+        } else if (mOkHttpResponseListener != null) {
+            mOkHttpResponseListener.onError(anError);
         } else if (mOkHttpResponseAndJSONObjectRequestListener != null) {
             mOkHttpResponseAndJSONObjectRequestListener.onError(anError);
         } else if (mOkHttpResponseAndJSONArrayRequestListener != null) {
@@ -708,7 +768,7 @@ private void deliverErrorResponse(ANError anError) {
             mOkHttpResponseAndBitmapRequestListener.onError(anError);
         } else if (mOkHttpResponseAndParsedRequestListener != null) {
             mOkHttpResponseAndParsedRequestListener.onError(anError);
-        }else if (mDownloadListener != null) {
+        } else if (mDownloadListener != null) {
             mDownloadListener.onError(anError);
         }
     }
@@ -737,7 +797,6 @@ public void run() {
                         }
                     });
                 }
-                ANLog.d("Delivering success : " + toString());
             } else {
                 ANError anError = new ANError();
                 anError.setCancellationMessageInError();
@@ -746,7 +805,6 @@ public void run() {
                     mOkHttpResponseListener.onError(anError);
                 }
                 finish();
-                ANLog.d("Delivering cancelled : " + toString());
             }
         } catch (Exception e) {
             e.printStackTrace();
@@ -754,16 +812,11 @@ public void run() {
     }
 
     public RequestBody getRequestBody() {
-        if (mJsonObject != null) {
+        if (mApplicationJsonString != null) {
             if (customMediaType != null) {
-                return RequestBody.create(customMediaType, mJsonObject.toString());
+                return RequestBody.create(customMediaType, mApplicationJsonString);
             }
-            return RequestBody.create(JSON_MEDIA_TYPE, mJsonObject.toString());
-        } else if (mJsonArray != null) {
-            if (customMediaType != null) {
-                return RequestBody.create(customMediaType, mJsonArray.toString());
-            }
-            return RequestBody.create(JSON_MEDIA_TYPE, mJsonArray.toString());
+            return RequestBody.create(JSON_MEDIA_TYPE, mApplicationJsonString);
         } else if (mStringBody != null) {
             if (customMediaType != null) {
                 return RequestBody.create(customMediaType, mStringBody);
@@ -796,7 +849,9 @@ public RequestBody getRequestBody() {
     }
 
     public RequestBody getMultiPartRequestBody() {
-        MultipartBody.Builder builder = new MultipartBody.Builder().setType(MultipartBody.FORM);
+        MultipartBody.Builder builder = new MultipartBody
+                .Builder()
+                .setType((customMediaType == null) ? MultipartBody.FORM : customMediaType);
         try {
             for (HashMap.Entry<String, String> entry : mMultiPartParameterMap.entrySet()) {
                 builder.addPart(Headers.of("Content-Disposition",
@@ -810,9 +865,6 @@ public RequestBody getMultiPartRequestBody() {
                 builder.addPart(Headers.of("Content-Disposition",
                         "form-data; name=\"" + entry.getKey() + "\"; filename=\"" + fileName + "\""),
                         fileBody);
-                if (customMediaType != null) {
-                    builder.setType(customMediaType);
-                }
             }
         } catch (Exception e) {
             e.printStackTrace();
@@ -823,8 +875,17 @@ public RequestBody getMultiPartRequestBody() {
     public Headers getHeaders() {
         Headers.Builder builder = new Headers.Builder();
         try {
-            for (HashMap.Entry<String, String> entry : mHeadersMap.entrySet()) {
-                builder.add(entry.getKey(), entry.getValue());
+            if (mHeadersMap != null) {
+                Set<Map.Entry<String, List<String>>> entries = mHeadersMap.entrySet();
+                for (Map.Entry<String, List<String>> entry : entries) {
+                    String name = entry.getKey();
+                    List<String> list = entry.getValue();
+                    if (list != null) {
+                        for (String value : list) {
+                            builder.add(name, value);
+                        }
+                    }
+                }
             }
         } catch (Exception e) {
             e.printStackTrace();
@@ -839,17 +900,25 @@ public HeadRequestBuilder(String url) {
         }
     }
 
+    public static class OptionsRequestBuilder extends GetRequestBuilder {
+
+        public OptionsRequestBuilder(String url) {
+            super(url, Method.OPTIONS);
+        }
+    }
+
     public static class GetRequestBuilder<T extends GetRequestBuilder> implements RequestBuilder {
         private Priority mPriority = Priority.MEDIUM;
         private int mMethod = Method.GET;
         private String mUrl;
         private Object mTag;
         private Bitmap.Config mDecodeConfig;
+        private BitmapFactory.Options mBitmapOptions;
         private int mMaxWidth;
         private int mMaxHeight;
         private ImageView.ScaleType mScaleType;
-        private HashMap<String, String> mHeadersMap = new HashMap<>();
-        private HashMap<String, String> mQueryParameterMap = new HashMap<>();
+        private HashMap<String, List<String>> mHeadersMap = new HashMap<>();
+        private HashMap<String, List<String>> mQueryParameterMap = new HashMap<>();
         private HashMap<String, String> mPathParameterMap = new HashMap<>();
         private CacheControl mCacheControl;
         private Executor mExecutor;
@@ -880,42 +949,94 @@ public T setTag(Object tag) {
 
         @Override
         public T addQueryParameter(String key, String value) {
-            mQueryParameterMap.put(key, value);
+            List<String> list = mQueryParameterMap.get(key);
+            if (list == null) {
+                list = new ArrayList<>();
+                mQueryParameterMap.put(key, list);
+            }
+            if (!list.contains(value)) {
+                list.add(value);
+            }
             return (T) this;
         }
 
         @Override
-        public T addQueryParameter(HashMap<String, String> queryParameterMap) {
+        public T addQueryParameter(Map<String, String> queryParameterMap) {
             if (queryParameterMap != null) {
                 for (HashMap.Entry<String, String> entry : queryParameterMap.entrySet()) {
-                    mQueryParameterMap.put(entry.getKey(), entry.getValue());
+                    addQueryParameter(entry.getKey(), entry.getValue());
                 }
             }
             return (T) this;
         }
 
+        @Override
+        public T addQueryParameter(Object object) {
+            if (object != null) {
+                return addQueryParameter(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T addPathParameter(String key, String value) {
             mPathParameterMap.put(key, value);
             return (T) this;
         }
 
+        @Override
+        public T addPathParameter(Map<String, String> pathParameterMap) {
+            if (pathParameterMap != null) {
+                mPathParameterMap.putAll(pathParameterMap);
+            }
+            return (T) this;
+        }
+
+        @Override
+        public T addPathParameter(Object object) {
+            if (object != null) {
+                mPathParameterMap.putAll(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T addHeaders(String key, String value) {
-            mHeadersMap.put(key, value);
+            List<String> list = mHeadersMap.get(key);
+            if (list == null) {
+                list = new ArrayList<>();
+                mHeadersMap.put(key, list);
+            }
+            if (!list.contains(value)) {
+                list.add(value);
+            }
             return (T) this;
         }
 
         @Override
-        public T addHeaders(HashMap<String, String> headerMap) {
+        public T addHeaders(Map<String, String> headerMap) {
             if (headerMap != null) {
                 for (HashMap.Entry<String, String> entry : headerMap.entrySet()) {
-                    mHeadersMap.put(entry.getKey(), entry.getValue());
+                    addHeaders(entry.getKey(), entry.getValue());
                 }
             }
             return (T) this;
         }
 
+        @Override
+        public T addHeaders(Object object) {
+            if (object != null) {
+                return addHeaders(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T doNotCacheResponse() {
             mCacheControl = new CacheControl.Builder().noStore().build();
@@ -969,6 +1090,11 @@ public T setBitmapConfig(Bitmap.Config bitmapConfig) {
             return (T) this;
         }
 
+        public T setBitmapOptions(BitmapFactory.Options bitmapOptions) {
+            mBitmapOptions = bitmapOptions;
+            return (T) this;
+        }
+
         public T setBitmapMaxHeight(int maxHeight) {
             mMaxHeight = maxHeight;
             return (T) this;
@@ -1010,21 +1136,27 @@ public PatchRequestBuilder(String url) {
         }
     }
 
+    public static class DynamicRequestBuilder extends PostRequestBuilder {
+
+        public DynamicRequestBuilder(String url, int method) {
+            super(url, method);
+        }
+    }
+
     public static class PostRequestBuilder<T extends PostRequestBuilder> implements RequestBuilder {
 
         private Priority mPriority = Priority.MEDIUM;
         private int mMethod = Method.POST;
         private String mUrl;
         private Object mTag;
-        private JSONObject mJsonObject = null;
-        private JSONArray mJsonArray = null;
+        private String mApplicationJsonString = null;
         private String mStringBody = null;
         private byte[] mByte = null;
         private File mFile = null;
-        private HashMap<String, String> mHeadersMap = new HashMap<>();
+        private HashMap<String, List<String>> mHeadersMap = new HashMap<>();
         private HashMap<String, String> mBodyParameterMap = new HashMap<>();
         private HashMap<String, String> mUrlEncodedFormBodyParameterMap = new HashMap<>();
-        private HashMap<String, String> mQueryParameterMap = new HashMap<>();
+        private HashMap<String, List<String>> mQueryParameterMap = new HashMap<>();
         private HashMap<String, String> mPathParameterMap = new HashMap<>();
         private CacheControl mCacheControl;
         private Executor mExecutor;
@@ -1056,42 +1188,94 @@ public T setTag(Object tag) {
 
         @Override
         public T addQueryParameter(String key, String value) {
-            mQueryParameterMap.put(key, value);
+            List<String> list = mQueryParameterMap.get(key);
+            if (list == null) {
+                list = new ArrayList<>();
+                mQueryParameterMap.put(key, list);
+            }
+            if (!list.contains(value)) {
+                list.add(value);
+            }
             return (T) this;
         }
 
         @Override
-        public T addQueryParameter(HashMap<String, String> queryParameterMap) {
+        public T addQueryParameter(Map<String, String> queryParameterMap) {
             if (queryParameterMap != null) {
                 for (HashMap.Entry<String, String> entry : queryParameterMap.entrySet()) {
-                    mQueryParameterMap.put(entry.getKey(), entry.getValue());
+                    addQueryParameter(entry.getKey(), entry.getValue());
                 }
             }
             return (T) this;
         }
 
+        @Override
+        public T addQueryParameter(Object object) {
+            if (object != null) {
+                return addQueryParameter(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T addPathParameter(String key, String value) {
             mPathParameterMap.put(key, value);
             return (T) this;
         }
 
+        @Override
+        public T addPathParameter(Map<String, String> pathParameterMap) {
+            if (pathParameterMap != null) {
+                mPathParameterMap.putAll(pathParameterMap);
+            }
+            return (T) this;
+        }
+
+        @Override
+        public T addPathParameter(Object object) {
+            if (object != null) {
+                mPathParameterMap.putAll(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T addHeaders(String key, String value) {
-            mHeadersMap.put(key, value);
+            List<String> list = mHeadersMap.get(key);
+            if (list == null) {
+                list = new ArrayList<>();
+                mHeadersMap.put(key, list);
+            }
+            if (!list.contains(value)) {
+                list.add(value);
+            }
             return (T) this;
         }
 
         @Override
-        public T addHeaders(HashMap<String, String> headerMap) {
+        public T addHeaders(Map<String, String> headerMap) {
             if (headerMap != null) {
                 for (HashMap.Entry<String, String> entry : headerMap.entrySet()) {
-                    mHeadersMap.put(entry.getKey(), entry.getValue());
+                    addHeaders(entry.getKey(), entry.getValue());
                 }
             }
             return (T) this;
         }
 
+        @Override
+        public T addHeaders(Object object) {
+            if (object != null) {
+                return addHeaders(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T doNotCacheResponse() {
             mCacheControl = new CacheControl.Builder().noStore().build();
@@ -1145,36 +1329,63 @@ public T addBodyParameter(String key, String value) {
             return (T) this;
         }
 
+        public T addBodyParameter(Map<String, String> bodyParameterMap) {
+            if (bodyParameterMap != null) {
+                mBodyParameterMap.putAll(bodyParameterMap);
+            }
+            return (T) this;
+        }
+
+        public T addBodyParameter(Object object) {
+            if (object != null) {
+                mBodyParameterMap.putAll(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         public T addUrlEncodeFormBodyParameter(String key, String value) {
             mUrlEncodedFormBodyParameterMap.put(key, value);
             return (T) this;
         }
 
-        public T addBodyParameter(HashMap<String, String> bodyParameterMap) {
+        public T addUrlEncodeFormBodyParameter(Map<String, String> bodyParameterMap) {
             if (bodyParameterMap != null) {
-                for (HashMap.Entry<String, String> entry : bodyParameterMap.entrySet()) {
-                    mBodyParameterMap.put(entry.getKey(), entry.getValue());
-                }
+                mUrlEncodedFormBodyParameterMap.putAll(bodyParameterMap);
             }
             return (T) this;
         }
 
-        public T addUrlEncodeFormBodyParameter(HashMap<String, String> bodyParameterMap) {
-            if (bodyParameterMap != null) {
-                for (HashMap.Entry<String, String> entry : bodyParameterMap.entrySet()) {
-                    mUrlEncodedFormBodyParameterMap.put(entry.getKey(), entry.getValue());
-                }
+        public T addUrlEncodeFormBodyParameter(Object object) {
+            if (object != null) {
+                mUrlEncodedFormBodyParameterMap.putAll(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
+        public T addApplicationJsonBody(Object object) {
+            if (object != null) {
+                mApplicationJsonString = ParseUtil
+                        .getParserFactory()
+                        .getString(object);
             }
             return (T) this;
         }
 
         public T addJSONObjectBody(JSONObject jsonObject) {
-            mJsonObject = jsonObject;
+            if (jsonObject != null) {
+                mApplicationJsonString = jsonObject.toString();
+            }
             return (T) this;
         }
 
         public T addJSONArrayBody(JSONArray jsonArray) {
-            mJsonArray = jsonArray;
+            if (jsonArray != null) {
+                mApplicationJsonString = jsonArray.toString();
+            }
             return (T) this;
         }
 
@@ -1208,8 +1419,8 @@ public ANRequest build() {
         private Priority mPriority = Priority.MEDIUM;
         private String mUrl;
         private Object mTag;
-        private HashMap<String, String> mHeadersMap = new HashMap<>();
-        private HashMap<String, String> mQueryParameterMap = new HashMap<>();
+        private HashMap<String, List<String>> mHeadersMap = new HashMap<>();
+        private HashMap<String, List<String>> mQueryParameterMap = new HashMap<>();
         private HashMap<String, String> mPathParameterMap = new HashMap<>();
         private String mDirPath;
         private String mFileName;
@@ -1239,42 +1450,94 @@ public T setTag(Object tag) {
 
         @Override
         public T addHeaders(String key, String value) {
-            mHeadersMap.put(key, value);
+            List<String> list = mHeadersMap.get(key);
+            if (list == null) {
+                list = new ArrayList<>();
+                mHeadersMap.put(key, list);
+            }
+            if (!list.contains(value)) {
+                list.add(value);
+            }
             return (T) this;
         }
 
         @Override
-        public T addHeaders(HashMap<String, String> headerMap) {
+        public T addHeaders(Map<String, String> headerMap) {
             if (headerMap != null) {
                 for (HashMap.Entry<String, String> entry : headerMap.entrySet()) {
-                    mHeadersMap.put(entry.getKey(), entry.getValue());
+                    addHeaders(entry.getKey(), entry.getValue());
                 }
             }
             return (T) this;
         }
 
+        @Override
+        public T addHeaders(Object object) {
+            if (object != null) {
+                return addHeaders(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T addQueryParameter(String key, String value) {
-            mQueryParameterMap.put(key, value);
+            List<String> list = mQueryParameterMap.get(key);
+            if (list == null) {
+                list = new ArrayList<>();
+                mQueryParameterMap.put(key, list);
+            }
+            if (!list.contains(value)) {
+                list.add(value);
+            }
             return (T) this;
         }
 
         @Override
-        public T addQueryParameter(HashMap<String, String> queryParameterMap) {
+        public T addQueryParameter(Map<String, String> queryParameterMap) {
             if (queryParameterMap != null) {
                 for (HashMap.Entry<String, String> entry : queryParameterMap.entrySet()) {
-                    mQueryParameterMap.put(entry.getKey(), entry.getValue());
+                    addQueryParameter(entry.getKey(), entry.getValue());
                 }
             }
             return (T) this;
         }
 
+        @Override
+        public T addQueryParameter(Object object) {
+            if (object != null) {
+                return addQueryParameter(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T addPathParameter(String key, String value) {
             mPathParameterMap.put(key, value);
             return (T) this;
         }
 
+        @Override
+        public T addPathParameter(Map<String, String> pathParameterMap) {
+            if (pathParameterMap != null) {
+                mPathParameterMap.putAll(pathParameterMap);
+            }
+            return (T) this;
+        }
+
+        @Override
+        public T addPathParameter(Object object) {
+            if (object != null) {
+                mPathParameterMap.putAll(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T doNotCacheResponse() {
             mCacheControl = new CacheControl.Builder().noStore().build();
@@ -1338,9 +1601,9 @@ public ANRequest build() {
         private Priority mPriority = Priority.MEDIUM;
         private String mUrl;
         private Object mTag;
-        private HashMap<String, String> mHeadersMap = new HashMap<>();
+        private HashMap<String, List<String>> mHeadersMap = new HashMap<>();
         private HashMap<String, String> mMultiPartParameterMap = new HashMap<>();
-        private HashMap<String, String> mQueryParameterMap = new HashMap<>();
+        private HashMap<String, List<String>> mQueryParameterMap = new HashMap<>();
         private HashMap<String, String> mPathParameterMap = new HashMap<>();
         private HashMap<String, File> mMultiPartFileMap = new HashMap<>();
         private CacheControl mCacheControl;
@@ -1368,42 +1631,94 @@ public T setTag(Object tag) {
 
         @Override
         public T addQueryParameter(String key, String value) {
-            mQueryParameterMap.put(key, value);
+            List<String> list = mQueryParameterMap.get(key);
+            if (list == null) {
+                list = new ArrayList<>();
+                mQueryParameterMap.put(key, list);
+            }
+            if (!list.contains(value)) {
+                list.add(value);
+            }
             return (T) this;
         }
 
         @Override
-        public T addQueryParameter(HashMap<String, String> queryParameterMap) {
+        public T addQueryParameter(Map<String, String> queryParameterMap) {
             if (queryParameterMap != null) {
                 for (HashMap.Entry<String, String> entry : queryParameterMap.entrySet()) {
-                    mQueryParameterMap.put(entry.getKey(), entry.getValue());
+                    addQueryParameter(entry.getKey(), entry.getValue());
                 }
             }
             return (T) this;
         }
 
+        @Override
+        public T addQueryParameter(Object object) {
+            if (object != null) {
+                return addQueryParameter(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T addPathParameter(String key, String value) {
             mPathParameterMap.put(key, value);
             return (T) this;
         }
 
+        @Override
+        public T addPathParameter(Map<String, String> pathParameterMap) {
+            if (pathParameterMap != null) {
+                mPathParameterMap.putAll(pathParameterMap);
+            }
+            return (T) this;
+        }
+
+        @Override
+        public T addPathParameter(Object object) {
+            if (object != null) {
+                mPathParameterMap.putAll(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T addHeaders(String key, String value) {
-            mHeadersMap.put(key, value);
+            List<String> list = mHeadersMap.get(key);
+            if (list == null) {
+                list = new ArrayList<>();
+                mHeadersMap.put(key, list);
+            }
+            if (!list.contains(value)) {
+                list.add(value);
+            }
             return (T) this;
         }
 
         @Override
-        public T addHeaders(HashMap<String, String> headerMap) {
+        public T addHeaders(Map<String, String> headerMap) {
             if (headerMap != null) {
                 for (HashMap.Entry<String, String> entry : headerMap.entrySet()) {
-                    mHeadersMap.put(entry.getKey(), entry.getValue());
+                    addHeaders(entry.getKey(), entry.getValue());
                 }
             }
             return (T) this;
         }
 
+        @Override
+        public T addHeaders(Object object) {
+            if (object != null) {
+                return addHeaders(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
+            }
+            return (T) this;
+        }
+
         @Override
         public T doNotCacheResponse() {
             mCacheControl = new CacheControl.Builder().noStore().build();
@@ -1457,11 +1772,18 @@ public T addMultipartParameter(String key, String value) {
             return (T) this;
         }
 
-        public T addMultipartParameter(HashMap<String, String> multiPartParameterMap) {
+        public T addMultipartParameter(Map<String, String> multiPartParameterMap) {
             if (multiPartParameterMap != null) {
-                for (HashMap.Entry<String, String> entry : multiPartParameterMap.entrySet()) {
-                    mMultiPartParameterMap.put(entry.getKey(), entry.getValue());
-                }
+                mMultiPartParameterMap.putAll(multiPartParameterMap);
+            }
+            return (T) this;
+        }
+
+        public T addMultipartParameter(Object object) {
+            if (object != null) {
+                mMultiPartParameterMap.putAll(ParseUtil
+                        .getParserFactory()
+                        .getStringMap(object));
             }
             return (T) this;
         }
@@ -1471,11 +1793,9 @@ public T addMultipartFile(String key, File file) {
             return (T) this;
         }
 
-        public T addMultipartFile(HashMap<String, File> multiPartFileMap) {
+        public T addMultipartFile(Map<String, File> multiPartFileMap) {
             if (multiPartFileMap != null) {
-                for (HashMap.Entry<String, File> entry : multiPartFileMap.entrySet()) {
-                    mMultiPartFileMap.put(entry.getKey(), entry.getValue());
-                }
+                mMultiPartFileMap.putAll(multiPartFileMap);
             }
             return (T) this;
         }
diff --git a/android-networking/src/main/java/com/androidnetworking/common/Method.java b/android-networking/src/main/java/com/androidnetworking/common/Method.java
index 1e05a17..65da1b5 100644
--- a/android-networking/src/main/java/com/androidnetworking/common/Method.java
+++ b/android-networking/src/main/java/com/androidnetworking/common/Method.java
@@ -27,4 +27,5 @@
     int DELETE = 3;
     int HEAD = 4;
     int PATCH = 5;
+    int OPTIONS = 6;
 }
diff --git a/android-networking/src/main/java/com/androidnetworking/common/Priority.java b/android-networking/src/main/java/com/androidnetworking/common/Priority.java
index 45405f1..3b37a5a 100644
--- a/android-networking/src/main/java/com/androidnetworking/common/Priority.java
+++ b/android-networking/src/main/java/com/androidnetworking/common/Priority.java
@@ -49,6 +49,6 @@
     /**
      * Highest priority level. Used for data that are required instantly(mainly for emergency).
      */
-    IMMEDIATE;
+    IMMEDIATE
 
 }
diff --git a/android-networking/src/main/java/com/androidnetworking/common/RequestBuilder.java b/android-networking/src/main/java/com/androidnetworking/common/RequestBuilder.java
index bd59ee7..9e1adf3 100644
--- a/android-networking/src/main/java/com/androidnetworking/common/RequestBuilder.java
+++ b/android-networking/src/main/java/com/androidnetworking/common/RequestBuilder.java
@@ -17,7 +17,7 @@
 
 package com.androidnetworking.common;
 
-import java.util.HashMap;
+import java.util.Map;
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 
@@ -34,14 +34,22 @@
 
     RequestBuilder addHeaders(String key, String value);
 
-    RequestBuilder addHeaders(HashMap<String, String> headerMap);
+    RequestBuilder addHeaders(Map<String, String> headerMap);
+
+    RequestBuilder addHeaders(Object object);
 
     RequestBuilder addQueryParameter(String key, String value);
 
-    RequestBuilder addQueryParameter(HashMap<String, String> queryParameterMap);
+    RequestBuilder addQueryParameter(Map<String, String> queryParameterMap);
+
+    RequestBuilder addQueryParameter(Object object);
 
     RequestBuilder addPathParameter(String key, String value);
 
+    RequestBuilder addPathParameter(Map<String, String> pathParameterMap);
+
+    RequestBuilder addPathParameter(Object object);
+
     RequestBuilder doNotCacheResponse();
 
     RequestBuilder getResponseOnlyIfCached();
diff --git a/android-networking/src/main/java/com/androidnetworking/error/ANError.java b/android-networking/src/main/java/com/androidnetworking/error/ANError.java
index 59f8ad7..399e827 100644
--- a/android-networking/src/main/java/com/androidnetworking/error/ANError.java
+++ b/android-networking/src/main/java/com/androidnetworking/error/ANError.java
@@ -18,12 +18,14 @@
 package com.androidnetworking.error;
 
 import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.utils.ParseUtil;
 
 import okhttp3.Response;
 
 /**
  * Created by amitshekhar on 22/03/16.
  */
+@SuppressWarnings({"unchecked", "unused"})
 public class ANError extends Exception {
 
     private String errorBody;
@@ -100,4 +102,14 @@ public void setErrorBody(String errorBody) {
         this.errorBody = errorBody;
     }
 
+    public <T> T getErrorAsObject(Class<T> objectClass) {
+        try {
+            return (T) (ParseUtil
+                    .getParserFactory()
+                    .getObject(errorBody, objectClass));
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
 }
diff --git a/android-networking/src/main/java/com/androidnetworking/gsonparserfactory/GsonParserFactory.java b/android-networking/src/main/java/com/androidnetworking/gsonparserfactory/GsonParserFactory.java
index f746ab2..1229ccc 100644
--- a/android-networking/src/main/java/com/androidnetworking/gsonparserfactory/GsonParserFactory.java
+++ b/android-networking/src/main/java/com/androidnetworking/gsonparserfactory/GsonParserFactory.java
@@ -25,6 +25,7 @@
 import com.google.gson.reflect.TypeToken;
 
 import java.lang.reflect.Type;
+import java.util.HashMap;
 
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -56,4 +57,35 @@ public GsonParserFactory(Gson gson) {
         return new GsonRequestBodyParser<>(gson, adapter);
     }
 
+    @Override
+    public Object getObject(String string, Type type) {
+        try {
+            return gson.fromJson(string, type);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    @Override
+    public String getString(Object object) {
+        try {
+            return gson.toJson(object);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return "";
+    }
+
+    @Override
+    public HashMap<String, String> getStringMap(Object object) {
+        try {
+            Type type = new TypeToken<HashMap<String, String>>() {
+            }.getType();
+            return gson.fromJson(gson.toJson(object), type);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return new HashMap<>();
+    }
 }
diff --git a/android-networking/src/main/java/com/androidnetworking/interceptors/HttpLoggingInterceptor.java b/android-networking/src/main/java/com/androidnetworking/interceptors/HttpLoggingInterceptor.java
new file mode 100644
index 0000000..44f5265
--- /dev/null
+++ b/android-networking/src/main/java/com/androidnetworking/interceptors/HttpLoggingInterceptor.java
@@ -0,0 +1,302 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.androidnetworking.interceptors;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.util.concurrent.TimeUnit;
+
+import okhttp3.Connection;
+import okhttp3.Headers;
+import okhttp3.Interceptor;
+import okhttp3.MediaType;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.http.HttpHeaders;
+import okhttp3.internal.platform.Platform;
+import okio.Buffer;
+import okio.BufferedSource;
+
+import static okhttp3.internal.platform.Platform.INFO;
+
+/**
+ * Created by amitshekhar on 31/01/17.
+ */
+
+public class HttpLoggingInterceptor implements Interceptor {
+
+    private static final Charset UTF8 = Charset.forName("UTF-8");
+
+    public enum Level {
+        /**
+         * No logs.
+         */
+        NONE,
+        /**
+         * Logs request and response lines.
+         * <p>
+         * <p>Example:
+         * <pre>{@code
+         * --> POST /greeting http/1.1 (3-byte body)
+         *
+         * <-- 200 OK (22ms, 6-byte body)
+         * }</pre>
+         */
+        BASIC,
+        /**
+         * Logs request and response lines and their respective headers.
+         * <p>
+         * <p>Example:
+         * <pre>{@code
+         * --> POST /greeting http/1.1
+         * Host: example.com
+         * Content-Type: plain/text
+         * Content-Length: 3
+         * --> END POST
+         *
+         * <-- 200 OK (22ms)
+         * Content-Type: plain/text
+         * Content-Length: 6
+         * <-- END HTTP
+         * }</pre>
+         */
+        HEADERS,
+        /**
+         * Logs request and response lines and their respective headers and bodies (if present).
+         * <p>
+         * <p>Example:
+         * <pre>{@code
+         * --> POST /greeting http/1.1
+         * Host: example.com
+         * Content-Type: plain/text
+         * Content-Length: 3
+         *
+         * Hi?
+         * --> END POST
+         *
+         * <-- 200 OK (22ms)
+         * Content-Type: plain/text
+         * Content-Length: 6
+         *
+         * Hello!
+         * <-- END HTTP
+         * }</pre>
+         */
+        BODY
+    }
+
+    public interface Logger {
+        void log(String message);
+
+        /**
+         * A {@link Logger} defaults output appropriate for the current platform.
+         */
+        Logger DEFAULT = new Logger() {
+            @Override
+            public void log(String message) {
+                Platform.get().log(INFO, message, null);
+            }
+        };
+    }
+
+    public HttpLoggingInterceptor() {
+        this(Logger.DEFAULT);
+    }
+
+    public HttpLoggingInterceptor(Logger logger) {
+        this.logger = logger;
+    }
+
+    private final Logger logger;
+
+    private volatile Level level = Level.NONE;
+
+    /**
+     * Change the level at which this interceptor logs.
+     */
+    public HttpLoggingInterceptor setLevel(Level level) {
+        if (level == null) throw new NullPointerException("level == null. Use Level.NONE instead.");
+        this.level = level;
+        return this;
+    }
+
+    public Level getLevel() {
+        return level;
+    }
+
+    @Override
+    public Response intercept(Chain chain) throws IOException {
+        Level level = this.level;
+
+        Request request = chain.request();
+        if (level == Level.NONE) {
+            return chain.proceed(request);
+        }
+
+        boolean logBody = level == Level.BODY;
+        boolean logHeaders = logBody || level == Level.HEADERS;
+
+        RequestBody requestBody = request.body();
+        boolean hasRequestBody = requestBody != null;
+
+        Connection connection = chain.connection();
+        Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;
+        String requestStartMessage = "--> " + request.method() + ' ' + request.url() + ' ' + protocol;
+        if (!logHeaders && hasRequestBody) {
+            requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
+        }
+        logger.log(requestStartMessage);
+
+        if (logHeaders) {
+            if (hasRequestBody) {
+                // Request body headers are only present when installed as a network interceptor. Force
+                // them to be included (when available) so there values are known.
+                if (requestBody.contentType() != null) {
+                    logger.log("Content-Type: " + requestBody.contentType());
+                }
+                if (requestBody.contentLength() != -1) {
+                    logger.log("Content-Length: " + requestBody.contentLength());
+                }
+            }
+
+            Headers headers = request.headers();
+            for (int i = 0, count = headers.size(); i < count; i++) {
+                String name = headers.name(i);
+                // Skip headers from the request body as they are explicitly logged above.
+                if (!"Content-Type".equalsIgnoreCase(name) && !"Content-Length".equalsIgnoreCase(name)) {
+                    logger.log(name + ": " + headers.value(i));
+                }
+            }
+
+            if (!logBody || !hasRequestBody) {
+                logger.log("--> END " + request.method());
+            } else if (bodyEncoded(request.headers())) {
+                logger.log("--> END " + request.method() + " (encoded body omitted)");
+            } else {
+                Buffer buffer = new Buffer();
+                requestBody.writeTo(buffer);
+
+                Charset charset = UTF8;
+                MediaType contentType = requestBody.contentType();
+                if (contentType != null) {
+                    charset = contentType.charset(UTF8);
+                }
+
+                logger.log("");
+                if (isPlaintext(buffer)) {
+                    logger.log(buffer.readString(charset));
+                    logger.log("--> END " + request.method()
+                            + " (" + requestBody.contentLength() + "-byte body)");
+                } else {
+                    logger.log("--> END " + request.method() + " (binary "
+                            + requestBody.contentLength() + "-byte body omitted)");
+                }
+            }
+        }
+
+        long startNs = System.nanoTime();
+        Response response;
+        try {
+            response = chain.proceed(request);
+        } catch (Exception e) {
+            logger.log("<-- HTTP FAILED: " + e);
+            throw e;
+        }
+        long tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs);
+
+        ResponseBody responseBody = response.body();
+        long contentLength = responseBody.contentLength();
+        String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
+        logger.log("<-- " + response.code() + ' ' + response.message() + ' '
+                + response.request().url() + " (" + tookMs + "ms" + (!logHeaders ? ", "
+                + bodySize + " body" : "") + ')');
+
+        if (logHeaders) {
+            Headers headers = response.headers();
+            for (int i = 0, count = headers.size(); i < count; i++) {
+                logger.log(headers.name(i) + ": " + headers.value(i));
+            }
+
+            if (!logBody || !HttpHeaders.hasBody(response)) {
+                logger.log("<-- END HTTP");
+            } else if (bodyEncoded(response.headers())) {
+                logger.log("<-- END HTTP (encoded body omitted)");
+            } else {
+                BufferedSource source = responseBody.source();
+                source.request(Long.MAX_VALUE); // Buffer the entire body.
+                Buffer buffer = source.buffer();
+
+                Charset charset = UTF8;
+                MediaType contentType = responseBody.contentType();
+                if (contentType != null) {
+                    charset = contentType.charset(UTF8);
+                }
+
+                if (!isPlaintext(buffer)) {
+                    logger.log("");
+                    logger.log("<-- END HTTP (binary " + buffer.size() + "-byte body omitted)");
+                    return response;
+                }
+
+                if (contentLength != 0) {
+                    logger.log("");
+                    logger.log(buffer.clone().readString(charset));
+                }
+
+                logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
+            }
+        }
+
+        return response;
+    }
+
+    /**
+     * Returns true if the body in question probably contains human readable text. Uses a small sample
+     * of code points to detect unicode control characters commonly used in binary file signatures.
+     */
+    static boolean isPlaintext(Buffer buffer) {
+        try {
+            Buffer prefix = new Buffer();
+            long byteCount = buffer.size() < 64 ? buffer.size() : 64;
+            buffer.copyTo(prefix, 0, byteCount);
+            for (int i = 0; i < 16; i++) {
+                if (prefix.exhausted()) {
+                    break;
+                }
+                int codePoint = prefix.readUtf8CodePoint();
+                if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
+                    return false;
+                }
+            }
+            return true;
+        } catch (EOFException e) {
+            return false; // Truncated UTF-8 sequence.
+        }
+    }
+
+    private boolean bodyEncoded(Headers headers) {
+        String contentEncoding = headers.get("Content-Encoding");
+        return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
+    }
+}
diff --git a/android-networking/src/main/java/com/androidnetworking/interfaces/Parser.java b/android-networking/src/main/java/com/androidnetworking/interfaces/Parser.java
index 700a5ec..19e12dd 100644
--- a/android-networking/src/main/java/com/androidnetworking/interfaces/Parser.java
+++ b/android-networking/src/main/java/com/androidnetworking/interfaces/Parser.java
@@ -21,6 +21,7 @@
 
 import java.io.IOException;
 import java.lang.reflect.Type;
+import java.util.HashMap;
 
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -42,6 +43,18 @@
             return null;
         }
 
+        public Object getObject(String string, Type type) {
+            return null;
+        }
+
+        public String getString(Object object) {
+            return null;
+        }
+
+        public HashMap<String, String> getStringMap(Object object) {
+            return null;
+        }
+
     }
 
 }
\ No newline at end of file
diff --git a/android-networking/src/main/java/com/androidnetworking/internal/ANImageLoader.java b/android-networking/src/main/java/com/androidnetworking/internal/ANImageLoader.java
index 180f9eb..d278d54 100644
--- a/android-networking/src/main/java/com/androidnetworking/internal/ANImageLoader.java
+++ b/android-networking/src/main/java/com/androidnetworking/internal/ANImageLoader.java
@@ -18,6 +18,7 @@
 package com.androidnetworking.internal;
 
 import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
 import android.os.Handler;
 import android.os.Looper;
 import android.widget.ImageView;
@@ -58,6 +59,8 @@
 
     private Runnable mRunnable;
 
+    private BitmapFactory.Options mBitmapOptions = new BitmapFactory.Options();
+
     private static ANImageLoader sInstance;
 
     public static void initialize() {
@@ -186,6 +189,7 @@ protected ANRequest makeImageRequest(String requestUrl, int maxWidth, int maxHei
                 .setBitmapMaxWidth(maxWidth)
                 .setImageScaleType(scaleType)
                 .setBitmapConfig(Bitmap.Config.RGB_565)
+                .setBitmapOptions(mBitmapOptions)
                 .build();
 
         ANRequest.getAsBitmap(new BitmapRequestListener() {
@@ -203,6 +207,9 @@ public void onError(ANError anError) {
         return ANRequest;
     }
 
+    public void setBitmapDecodeOptions(BitmapFactory.Options bitmapOptions) {
+        mBitmapOptions = bitmapOptions;
+    }
 
     public void setBatchedResponseDelay(int newBatchedResponseDelayMs) {
         mBatchResponseDelayMs = newBatchedResponseDelayMs;
diff --git a/android-networking/src/main/java/com/androidnetworking/internal/ANRequestQueue.java b/android-networking/src/main/java/com/androidnetworking/internal/ANRequestQueue.java
index b745b4a..ed7ff76 100644
--- a/android-networking/src/main/java/com/androidnetworking/internal/ANRequestQueue.java
+++ b/android-networking/src/main/java/com/androidnetworking/internal/ANRequestQueue.java
@@ -17,14 +17,14 @@
 
 package com.androidnetworking.internal;
 
-import com.androidnetworking.common.ANLog;
 import com.androidnetworking.common.ANRequest;
 import com.androidnetworking.common.Priority;
 import com.androidnetworking.core.Core;
 
-import java.util.HashSet;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
 
 /**
@@ -32,8 +32,8 @@
  */
 public class ANRequestQueue {
 
-    private final static String TAG = ANRequestQueue.class.getSimpleName();
-    private final Set<ANRequest> mCurrentRequests = new HashSet<>();
+    private final Set<ANRequest> mCurrentRequests =
+            Collections.newSetFromMap(new ConcurrentHashMap<ANRequest, Boolean>());
     private AtomicInteger mSequenceGenerator = new AtomicInteger();
     private static ANRequestQueue sInstance = null;
 
@@ -56,40 +56,35 @@ public static ANRequestQueue getInstance() {
         boolean apply(ANRequest request);
     }
 
-
     private void cancel(RequestFilter filter, boolean forceCancel) {
-        synchronized (mCurrentRequests) {
-            try {
-                for (Iterator<ANRequest> iterator = mCurrentRequests.iterator(); iterator.hasNext(); ) {
-                    ANRequest request = iterator.next();
-                    if (filter.apply(request)) {
-                        request.cancel(forceCancel);
-                        if (request.isCanceled()) {
-                            request.destroy();
-                            iterator.remove();
-                        }
+        try {
+            for (Iterator<ANRequest> iterator = mCurrentRequests.iterator(); iterator.hasNext(); ) {
+                ANRequest request = iterator.next();
+                if (filter.apply(request)) {
+                    request.cancel(forceCancel);
+                    if (request.isCanceled()) {
+                        request.destroy();
+                        iterator.remove();
                     }
                 }
-            } catch (Exception e) {
-                e.printStackTrace();
             }
+        } catch (Exception e) {
+            e.printStackTrace();
         }
     }
 
     public void cancelAll(boolean forceCancel) {
-        synchronized (mCurrentRequests) {
-            try {
-                for (Iterator<ANRequest> iterator = mCurrentRequests.iterator(); iterator.hasNext(); ) {
-                    ANRequest request = iterator.next();
-                    request.cancel(forceCancel);
-                    if (request.isCanceled()) {
-                        request.destroy();
-                        iterator.remove();
-                    }
+        try {
+            for (Iterator<ANRequest> iterator = mCurrentRequests.iterator(); iterator.hasNext(); ) {
+                ANRequest request = iterator.next();
+                request.cancel(forceCancel);
+                if (request.isCanceled()) {
+                    request.destroy();
+                    iterator.remove();
                 }
-            } catch (Exception e) {
-                e.printStackTrace();
             }
+        } catch (Exception e) {
+            e.printStackTrace();
         }
     }
 
@@ -101,12 +96,7 @@ public void cancelRequestWithGivenTag(final Object tag, final boolean forceCance
             cancel(new RequestFilter() {
                 @Override
                 public boolean apply(ANRequest request) {
-                    if (request.getTag() instanceof String && tag instanceof String) {
-                        final String tempRequestTag = (String) request.getTag();
-                        final String tempTag = (String) tag;
-                        return tempRequestTag.equals(tempTag);
-                    }
-                    return request.getTag().equals(tag);
+                    return isRequestWithTheGivenTag(request, tag);
                 }
             }, forceCancel);
         } catch (Exception e) {
@@ -119,12 +109,10 @@ public int getSequenceNumber() {
     }
 
     public ANRequest addRequest(ANRequest request) {
-        synchronized (mCurrentRequests) {
-            try {
-                mCurrentRequests.add(request);
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
+        try {
+            mCurrentRequests.add(request);
+        } catch (Exception e) {
+            e.printStackTrace();
         }
         try {
             request.setSequenceNumber(getSequenceNumber());
@@ -139,7 +127,6 @@ public ANRequest addRequest(ANRequest request) {
                         .forNetworkTasks()
                         .submit(new InternalRunnable(request)));
             }
-            ANLog.d("addRequest: after addition - mCurrentRequests size: " + mCurrentRequests.size());
         } catch (Exception e) {
             e.printStackTrace();
         }
@@ -147,13 +134,36 @@ public ANRequest addRequest(ANRequest request) {
     }
 
     public void finish(ANRequest request) {
-        synchronized (mCurrentRequests) {
-            try {
-                mCurrentRequests.remove(request);
-                ANLog.d("finish: after removal - mCurrentRequests size: " + mCurrentRequests.size());
-            } catch (Exception e) {
-                e.printStackTrace();
+        try {
+            mCurrentRequests.remove(request);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public boolean isRequestRunning(Object tag) {
+        try {
+            for (ANRequest request : mCurrentRequests) {
+                if (isRequestWithTheGivenTag(request, tag) && request.isRunning()) {
+                    return true;
+                }
             }
+        } catch (Exception e) {
+            e.printStackTrace();
         }
+        return false;
     }
+
+    private boolean isRequestWithTheGivenTag(ANRequest request, Object tag) {
+        if (request.getTag() == null) {
+            return false;
+        }
+        if (request.getTag() instanceof String && tag instanceof String) {
+            final String tempRequestTag = (String) request.getTag();
+            final String tempTag = (String) tag;
+            return tempRequestTag.equals(tempTag);
+        }
+        return request.getTag().equals(tag);
+    }
+
 }
diff --git a/android-networking/src/main/java/com/androidnetworking/internal/DownloadProgressHandler.java b/android-networking/src/main/java/com/androidnetworking/internal/DownloadProgressHandler.java
index a846632..3e1e2a9 100644
--- a/android-networking/src/main/java/com/androidnetworking/internal/DownloadProgressHandler.java
+++ b/android-networking/src/main/java/com/androidnetworking/internal/DownloadProgressHandler.java
@@ -25,28 +25,25 @@
 import com.androidnetworking.interfaces.DownloadProgressListener;
 import com.androidnetworking.model.Progress;
 
-import java.lang.ref.WeakReference;
-
 /**
  * Created by amitshekhar on 24/05/16.
  */
 public class DownloadProgressHandler extends Handler {
 
-    private final WeakReference<DownloadProgressListener> mDownloadProgressListenerWeakRef;
+    private final DownloadProgressListener mDownloadProgressListener;
 
     public DownloadProgressHandler(DownloadProgressListener downloadProgressListener) {
         super(Looper.getMainLooper());
-        mDownloadProgressListenerWeakRef = new WeakReference<>(downloadProgressListener);
+        mDownloadProgressListener = downloadProgressListener;
     }
 
     @Override
     public void handleMessage(Message msg) {
-        final DownloadProgressListener downloadProgressListener = mDownloadProgressListenerWeakRef.get();
         switch (msg.what) {
             case ANConstants.UPDATE:
-                if (downloadProgressListener != null) {
+                if (mDownloadProgressListener != null) {
                     final Progress progress = (Progress) msg.obj;
-                    downloadProgressListener.onProgress(progress.currentBytes, progress.totalBytes);
+                    mDownloadProgressListener.onProgress(progress.currentBytes, progress.totalBytes);
                 }
                 break;
             default:
diff --git a/android-networking/src/main/java/com/androidnetworking/internal/InternalNetworking.java b/android-networking/src/main/java/com/androidnetworking/internal/InternalNetworking.java
index cb539dc..43c539b 100644
--- a/android-networking/src/main/java/com/androidnetworking/internal/InternalNetworking.java
+++ b/android-networking/src/main/java/com/androidnetworking/internal/InternalNetworking.java
@@ -28,6 +28,8 @@
 import com.androidnetworking.common.ANRequest;
 import com.androidnetworking.common.ConnectionClassManager;
 import com.androidnetworking.error.ANError;
+import com.androidnetworking.interceptors.HttpLoggingInterceptor;
+import com.androidnetworking.interceptors.HttpLoggingInterceptor.Level;
 import com.androidnetworking.utils.Utils;
 
 import java.io.File;
@@ -44,6 +46,7 @@
 import static com.androidnetworking.common.Method.DELETE;
 import static com.androidnetworking.common.Method.GET;
 import static com.androidnetworking.common.Method.HEAD;
+import static com.androidnetworking.common.Method.OPTIONS;
 import static com.androidnetworking.common.Method.PATCH;
 import static com.androidnetworking.common.Method.POST;
 import static com.androidnetworking.common.Method.PUT;
@@ -89,6 +92,10 @@ public static Response performSimpleRequest(ANRequest request) throws ANError {
                     builder = builder.head();
                     break;
                 }
+                case OPTIONS: {
+                    builder = builder.method(ANConstants.OPTIONS, null);
+                    break;
+                }
                 case PATCH: {
                     requestBody = request.getRequestBody();
                     builder = builder.patch(requestBody);
@@ -303,4 +310,13 @@ public static void setClient(OkHttpClient okHttpClient) {
         sHttpClient = okHttpClient;
     }
 
-}
+    public static void enableLogging(Level level) {
+        HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
+        logging.setLevel(level);
+        sHttpClient = getClient()
+                .newBuilder()
+                .addInterceptor(logging)
+                .build();
+    }
+
+}
\ No newline at end of file
diff --git a/android-networking/src/main/java/com/androidnetworking/internal/InternalRunnable.java b/android-networking/src/main/java/com/androidnetworking/internal/InternalRunnable.java
index 1df4783..6cb3f73 100644
--- a/android-networking/src/main/java/com/androidnetworking/internal/InternalRunnable.java
+++ b/android-networking/src/main/java/com/androidnetworking/internal/InternalRunnable.java
@@ -17,7 +17,6 @@
 
 package com.androidnetworking.internal;
 
-import com.androidnetworking.common.ANLog;
 import com.androidnetworking.common.ANRequest;
 import com.androidnetworking.common.ANResponse;
 import com.androidnetworking.common.Priority;
@@ -50,7 +49,7 @@ public InternalRunnable(ANRequest request) {
 
     @Override
     public void run() {
-        ANLog.d("execution started : " + request.toString());
+        request.setRunning(true);
         switch (request.getRequestType()) {
             case SIMPLE:
                 executeSimpleRequest();
@@ -62,7 +61,7 @@ public void run() {
                 executeUploadRequest();
                 break;
         }
-        ANLog.d("execution done : " + request.toString());
+        request.setRunning(false);
     }
 
     private void executeSimpleRequest() {
diff --git a/android-networking/src/main/java/com/androidnetworking/internal/RequestProgressBody.java b/android-networking/src/main/java/com/androidnetworking/internal/RequestProgressBody.java
index 7e4f61c..76acec4 100644
--- a/android-networking/src/main/java/com/androidnetworking/internal/RequestProgressBody.java
+++ b/android-networking/src/main/java/com/androidnetworking/internal/RequestProgressBody.java
@@ -83,4 +83,4 @@ public void write(Buffer source, long byteCount) throws IOException {
             }
         };
     }
-}
+}
\ No newline at end of file
diff --git a/android-networking/src/main/java/com/androidnetworking/internal/SynchronousCall.java b/android-networking/src/main/java/com/androidnetworking/internal/SynchronousCall.java
index 9dd8101..132197e 100644
--- a/android-networking/src/main/java/com/androidnetworking/internal/SynchronousCall.java
+++ b/android-networking/src/main/java/com/androidnetworking/internal/SynchronousCall.java
@@ -80,7 +80,7 @@ private SynchronousCall() {
         } catch (ANError se) {
             return new ANResponse<>(Utils.getErrorForConnection(new ANError(se)));
         } catch (Exception e) {
-            return new ANResponse<>(Utils.getErrorForNetworkOnMainThreadOrConnection(e));
+            return new ANResponse<>(Utils.getErrorForConnection(new ANError(e)));
         } finally {
             SourceCloseUtil.close(okHttpResponse, request);
         }
@@ -105,7 +105,7 @@ private SynchronousCall() {
         } catch (ANError se) {
             return new ANResponse<>(Utils.getErrorForConnection(new ANError(se)));
         } catch (Exception e) {
-            return new ANResponse<>(Utils.getErrorForNetworkOnMainThreadOrConnection(e));
+            return new ANResponse<>(Utils.getErrorForConnection(new ANError(e)));
         }
     }
 
@@ -135,7 +135,7 @@ private SynchronousCall() {
         } catch (ANError se) {
             return new ANResponse<>(Utils.getErrorForConnection(se));
         } catch (Exception e) {
-            return new ANResponse<>(Utils.getErrorForNetworkOnMainThreadOrConnection(e));
+            return new ANResponse<>(Utils.getErrorForConnection(new ANError(e)));
         } finally {
             SourceCloseUtil.close(okHttpResponse, request);
         }
diff --git a/android-networking/src/main/java/com/androidnetworking/internal/UploadProgressHandler.java b/android-networking/src/main/java/com/androidnetworking/internal/UploadProgressHandler.java
index 88cdcc8..f623a5f 100644
--- a/android-networking/src/main/java/com/androidnetworking/internal/UploadProgressHandler.java
+++ b/android-networking/src/main/java/com/androidnetworking/internal/UploadProgressHandler.java
@@ -25,28 +25,25 @@
 import com.androidnetworking.interfaces.UploadProgressListener;
 import com.androidnetworking.model.Progress;
 
-import java.lang.ref.WeakReference;
-
 /**
  * Created by amitshekhar on 24/05/16.
  */
 public class UploadProgressHandler extends Handler {
 
-    private final WeakReference<UploadProgressListener> mUploadProgressListenerWeakRef;
+    private final UploadProgressListener mUploadProgressListener;
 
     public UploadProgressHandler(UploadProgressListener uploadProgressListener) {
         super(Looper.getMainLooper());
-        mUploadProgressListenerWeakRef = new WeakReference<>(uploadProgressListener);
+        mUploadProgressListener = uploadProgressListener;
     }
 
     @Override
     public void handleMessage(Message msg) {
-        final UploadProgressListener uploadProgressListener = mUploadProgressListenerWeakRef.get();
         switch (msg.what) {
             case ANConstants.UPDATE:
-                if (uploadProgressListener != null) {
+                if (mUploadProgressListener != null) {
                     final Progress progress = (Progress) msg.obj;
-                    uploadProgressListener.onProgress(progress.currentBytes, progress.totalBytes);
+                    mUploadProgressListener.onProgress(progress.currentBytes, progress.totalBytes);
                 }
                 break;
             default:
diff --git a/android-networking/src/main/java/com/androidnetworking/utils/ParseUtil.java b/android-networking/src/main/java/com/androidnetworking/utils/ParseUtil.java
index d0a7054..ec6acf4 100644
--- a/android-networking/src/main/java/com/androidnetworking/utils/ParseUtil.java
+++ b/android-networking/src/main/java/com/androidnetworking/utils/ParseUtil.java
@@ -19,8 +19,8 @@
 
 package com.androidnetworking.utils;
 
-import com.androidnetworking.interfaces.Parser;
 import com.androidnetworking.gsonparserfactory.GsonParserFactory;
+import com.androidnetworking.interfaces.Parser;
 import com.google.gson.Gson;
 
 /**
@@ -28,7 +28,7 @@
  */
 public class ParseUtil {
 
-    private static com.androidnetworking.interfaces.Parser.Factory mParserFactory;
+    private static Parser.Factory mParserFactory;
 
     public static void setParserFactory(Parser.Factory parserFactory) {
         mParserFactory = parserFactory;
diff --git a/android-networking/src/main/java/com/androidnetworking/utils/SourceCloseUtil.java b/android-networking/src/main/java/com/androidnetworking/utils/SourceCloseUtil.java
index b17a90a..eaf268a 100644
--- a/android-networking/src/main/java/com/androidnetworking/utils/SourceCloseUtil.java
+++ b/android-networking/src/main/java/com/androidnetworking/utils/SourceCloseUtil.java
@@ -19,7 +19,6 @@
 
 package com.androidnetworking.utils;
 
-import com.androidnetworking.common.ANLog;
 import com.androidnetworking.common.ANRequest;
 import com.androidnetworking.common.ResponseType;
 
@@ -39,8 +38,8 @@ public static void close(Response response, ANRequest request) {
                 response.body().source() != null) {
             try {
                 response.body().source().close();
-            } catch (Exception e) {
-                ANLog.d("Unable to close source data");
+            } catch (Exception ignore) {
+
             }
         }
     }
diff --git a/android-networking/src/main/java/com/androidnetworking/utils/Utils.java b/android-networking/src/main/java/com/androidnetworking/utils/Utils.java
index 139f510..588cba8 100644
--- a/android-networking/src/main/java/com/androidnetworking/utils/Utils.java
+++ b/android-networking/src/main/java/com/androidnetworking/utils/Utils.java
@@ -20,8 +20,6 @@
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
-import android.os.Build;
-import android.os.NetworkOnMainThreadException;
 import android.widget.ImageView;
 
 import com.androidnetworking.common.ANConstants;
@@ -64,9 +62,16 @@ public static String getMimeType(String path) {
         return contentTypeFor;
     }
 
+    public static ANResponse<Bitmap> decodeBitmap(Response response, int maxWidth,
+                                                  int maxHeight, Bitmap.Config decodeConfig,
+                                                  ImageView.ScaleType scaleType) {
+        return decodeBitmap(response, maxWidth, maxHeight, decodeConfig,
+                new BitmapFactory.Options(), scaleType);
+    }
 
     public static ANResponse<Bitmap> decodeBitmap(Response response, int maxWidth,
                                                   int maxHeight, Bitmap.Config decodeConfig,
+                                                  BitmapFactory.Options decodeOptions,
                                                   ImageView.ScaleType scaleType) {
         byte[] data = new byte[0];
         try {
@@ -74,7 +79,6 @@ public static String getMimeType(String path) {
         } catch (IOException e) {
             e.printStackTrace();
         }
-        BitmapFactory.Options decodeOptions = new BitmapFactory.Options();
         Bitmap bitmap = null;
         if (maxWidth == 0 && maxHeight == 0) {
             decodeOptions.inPreferredConfig = decodeConfig;
@@ -231,15 +235,4 @@ public static ANError getErrorForParse(ANError error) {
         return error;
     }
 
-    public static ANError getErrorForNetworkOnMainThreadOrConnection(Exception e) {
-        ANError error = new ANError(e);
-        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB
-                && e instanceof NetworkOnMainThreadException) {
-            error.setErrorDetail(ANConstants.NETWORK_ON_MAIN_THREAD_ERROR);
-        } else {
-            error.setErrorDetail(ANConstants.CONNECTION_ERROR);
-        }
-        error.setErrorCode(0);
-        return error;
-    }
 }
diff --git a/android-networking/src/main/java/com/androidnetworking/widget/ANImageView.java b/android-networking/src/main/java/com/androidnetworking/widget/ANImageView.java
index bef56a5..3286ddb 100644
--- a/android-networking/src/main/java/com/androidnetworking/widget/ANImageView.java
+++ b/android-networking/src/main/java/com/androidnetworking/widget/ANImageView.java
@@ -18,6 +18,7 @@
 package com.androidnetworking.widget;
 
 import android.content.Context;
+import android.support.v7.widget.AppCompatImageView;
 import android.text.TextUtils;
 import android.util.AttributeSet;
 import android.view.ViewGroup;
@@ -29,7 +30,7 @@
 /**
  * Created by amitshekhar on 23/03/16.
  */
-public class ANImageView extends ImageView {
+public class ANImageView extends AppCompatImageView {
 
     private String mUrl;
 
@@ -67,7 +68,7 @@ public void setErrorImageResId(int errorImage) {
     void loadImageIfNecessary(final boolean isInLayoutPass) {
         int width = getWidth();
         int height = getHeight();
-        ScaleType scaleType = getScaleType();
+        ImageView.ScaleType scaleType = getScaleType();
 
         boolean wrapWidth = false, wrapHeight = false;
         if (getLayoutParams() != null) {
diff --git a/android-networking/upload.gradle b/android-networking/upload.gradle
index 5da7312..9ac0a83 100755
--- a/android-networking/upload.gradle
+++ b/android-networking/upload.gradle
@@ -22,7 +22,7 @@ def siteUrl = 'https://github.com/amitshekhariitbhu/Fast-Android-Networking'
 def gitUrl = 'https://github.com/amitshekhariitbhu/Fast-Android-Networking.git'
 
 group = "com.amitshekhar.android"
-version = '0.3.0'
+version = '1.0.1'
 
 install {
     repositories.mavenInstaller {
diff --git a/app/build.gradle b/app/build.gradle
index 2d3c6ea..e2a4b59 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -18,13 +18,13 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.3"
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
 
     defaultConfig {
         applicationId "com.networking"
-        minSdkVersion 15
-        targetSdkVersion 23
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -38,9 +38,7 @@ android {
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
-    testCompile 'junit:junit:4.12'
-    compile 'com.android.support:appcompat-v7:23.2.1'
+    testCompile "junit:junit:$rootProject.ext.jUnitVersion"
+    compile "com.android.support:appcompat-v7:$rootProject.ext.supportAppCompatVersion"
     compile project(':android-networking')
-    compile 'com.facebook.stetho:stetho:1.3.1'
-    compile 'com.facebook.stetho:stetho-okhttp3:1.3.1'
 }
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 3fac4da..d98f777 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -20,7 +20,7 @@
     package="com.networking">
 
     <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 
     <application
         android:name=".MyApplication"
@@ -40,6 +40,7 @@
         <activity android:name=".ImageGridActivity"></activity>
         <activity android:name=".ApiTestActivity"></activity>
         <activity android:name=".OkHttpResponseTestActivity"></activity>
+        <activity android:name=".WebSocketActivity"></activity>
     </application>
 
 </manifest>
diff --git a/app/src/main/java/com/networking/ApiTestActivity.java b/app/src/main/java/com/networking/ApiTestActivity.java
index 78e85a4..d48f282 100644
--- a/app/src/main/java/com/networking/ApiTestActivity.java
+++ b/app/src/main/java/com/networking/ApiTestActivity.java
@@ -37,7 +37,6 @@
 import com.androidnetworking.interfaces.OkHttpResponseListener;
 import com.androidnetworking.interfaces.ParsedRequestListener;
 import com.androidnetworking.interfaces.UploadProgressListener;
-import com.google.gson.reflect.TypeToken;
 import com.networking.model.User;
 import com.networking.utils.Utils;
 
@@ -120,8 +119,7 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
                         Log.d(TAG, " isFromCache : " + isFromCache);
                     }
                 })
-                .getAsParsed(new TypeToken<List<User>>() {
-                }, new ParsedRequestListener<List<User>>() {
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
                     @Override
                     public void onResponse(List<User> users) {
                         Log.d(TAG, "userList size : " + users.size());
@@ -155,8 +153,7 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
                         Log.d(TAG, " isFromCache : " + isFromCache);
                     }
                 })
-                .getAsParsed(new TypeToken<User>() {
-                }, new ParsedRequestListener<User>() {
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
                     @Override
                     public void onResponse(User user) {
                         Log.d(TAG, "id : " + user.id);
@@ -1015,8 +1012,7 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
                                 Log.d(TAG, " isFromCache : " + isFromCache);
                             }
                         });
-                ANResponse<List<User>> responseTwo = requestTwo.executeForParsed(new TypeToken<List<User>>() {
-                });
+                ANResponse<List<User>> responseTwo = requestTwo.executeForObjectList(User.class);
 
                 if (responseTwo.isSuccess()) {
                     Log.d(TAG, "checkSynchronousCall : response success");
@@ -1111,6 +1107,22 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
         }).start();
     }
 
+    public void checkOptionsRequest(View view) {
+        AndroidNetworking.options("https://api.github.com/square/okhttp/issues")
+                .build()
+                .getAsOkHttpResponse(new OkHttpResponseListener() {
+                    @Override
+                    public void onResponse(Response response) {
+                        Log.d(TAG, "response : " + response.headers().toString());
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        Utils.logError(TAG, anError);
+                    }
+                });
+    }
+
     public void getCurrentConnectionQuality(View view) {
         Log.d(TAG, "getCurrentConnectionQuality : " + AndroidNetworking.getCurrentConnectionQuality() + " currentBandwidth : " + AndroidNetworking.getCurrentBandwidth());
     }
diff --git a/app/src/main/java/com/networking/MainActivity.java b/app/src/main/java/com/networking/MainActivity.java
index a4b30ff..c5a0bc3 100644
--- a/app/src/main/java/com/networking/MainActivity.java
+++ b/app/src/main/java/com/networking/MainActivity.java
@@ -148,7 +148,9 @@ public void makeRequests(View view) {
     }
 
     public void cancelAllRequests(View view) {
+        Log.d(TAG, "isRequestRunning before cancel : " + AndroidNetworking.isRequestRunning(this));
         AndroidNetworking.cancel(this);
+        Log.d(TAG, "isRequestRunning after cancel : " + AndroidNetworking.isRequestRunning(this));
     }
 
     public void loadImageDirect(View view) {
@@ -211,4 +213,7 @@ public void startOkHttpResponseTestActivity(View view) {
         startActivity(new Intent(MainActivity.this, OkHttpResponseTestActivity.class));
     }
 
+    public void startWebSocketActivity(View view) {
+        startActivity(new Intent(MainActivity.this, WebSocketActivity.class));
+    }
 }
diff --git a/app/src/main/java/com/networking/MyApplication.java b/app/src/main/java/com/networking/MyApplication.java
index d04d3f4..d4c34a7 100644
--- a/app/src/main/java/com/networking/MyApplication.java
+++ b/app/src/main/java/com/networking/MyApplication.java
@@ -18,6 +18,7 @@
 package com.networking;
 
 import android.app.Application;
+import android.graphics.BitmapFactory;
 import android.util.Log;
 
 import com.androidnetworking.AndroidNetworking;
@@ -40,14 +41,10 @@ public static MyApplication getInstance() {
     public void onCreate() {
         super.onCreate();
         appInstance = this;
-        //For testing purpose only: network interceptor : enable it only for non-images request checking
-//        Stetho.initializeWithDefaults(getApplicationContext());
-//        OkHttpClient okHttpClient = new OkHttpClient().newBuilder().addNetworkInterceptor(new StethoInterceptor()).addInterceptor(new GzipRequestInterceptor()).build();
-//        OkHttpClient okHttpClient = new OkHttpClient().newBuilder()
-//                .addInterceptor(new GzipRequestInterceptor())
-//                .build();
-//        AndroidNetworking.initialize(getApplicationContext(), okHttpClient);
         AndroidNetworking.initialize(getApplicationContext());
+        BitmapFactory.Options options = new BitmapFactory.Options();
+        options.inPurgeable = true;
+        AndroidNetworking.setBitmapDecodeOptions(options);
         AndroidNetworking.enableLogging();
         AndroidNetworking.setConnectionQualityChangeListener(new ConnectionQualityChangeListener() {
             @Override
diff --git a/app/src/main/java/com/networking/OkHttpResponseTestActivity.java b/app/src/main/java/com/networking/OkHttpResponseTestActivity.java
index f66e5a2..b7b8b31 100644
--- a/app/src/main/java/com/networking/OkHttpResponseTestActivity.java
+++ b/app/src/main/java/com/networking/OkHttpResponseTestActivity.java
@@ -34,13 +34,11 @@
 import com.androidnetworking.interfaces.AnalyticsListener;
 import com.androidnetworking.interfaces.DownloadListener;
 import com.androidnetworking.interfaces.DownloadProgressListener;
-import com.androidnetworking.interfaces.JSONObjectRequestListener;
 import com.androidnetworking.interfaces.OkHttpResponseAndJSONArrayRequestListener;
 import com.androidnetworking.interfaces.OkHttpResponseAndJSONObjectRequestListener;
 import com.androidnetworking.interfaces.OkHttpResponseAndParsedRequestListener;
 import com.androidnetworking.interfaces.OkHttpResponseListener;
 import com.androidnetworking.interfaces.UploadProgressListener;
-import com.google.gson.reflect.TypeToken;
 import com.networking.model.User;
 import com.networking.utils.Utils;
 
@@ -123,8 +121,7 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
                         Log.d(TAG, " isFromCache : " + isFromCache);
                     }
                 })
-                .getAsOkHttpResponseAndParsed(new TypeToken<List<User>>() {
-                }, new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                .getAsOkHttpResponseAndObjectList(User.class, new OkHttpResponseAndParsedRequestListener<List<User>>() {
                     @Override
                     public void onResponse(Response okHttpResponse, List<User> users) {
                         Log.d(TAG, "userList size : " + users.size());
@@ -163,8 +160,7 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
                         Log.d(TAG, " isFromCache : " + isFromCache);
                     }
                 })
-                .getAsOkHttpResponseAndParsed(new TypeToken<User>() {
-                }, new OkHttpResponseAndParsedRequestListener<User>() {
+                .getAsOkHttpResponseAndObject(User.class, new OkHttpResponseAndParsedRequestListener<User>() {
                     @Override
                     public void onResponse(Response okHttpResponse, User user) {
                         Log.d(TAG, "id : " + user.id);
@@ -964,8 +960,7 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
                                 Log.d(TAG, " isFromCache : " + isFromCache);
                             }
                         });
-                ANResponse<List<User>> responseTwo = requestTwo.executeForParsed(new TypeToken<List<User>>() {
-                });
+                ANResponse<List<User>> responseTwo = requestTwo.executeForObjectList(User.class);
 
                 if (responseTwo.isSuccess()) {
                     Log.d(TAG, "checkSynchronousCall : response success");
diff --git a/app/src/main/java/com/networking/WebSocketActivity.java b/app/src/main/java/com/networking/WebSocketActivity.java
new file mode 100644
index 0000000..768ac41
--- /dev/null
+++ b/app/src/main/java/com/networking/WebSocketActivity.java
@@ -0,0 +1,131 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.networking;
+
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.widget.TextView;
+
+import java.util.concurrent.TimeUnit;
+
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.WebSocket;
+import okhttp3.WebSocketListener;
+import okio.ByteString;
+
+/**
+ * Created by amitshekhar on 09/12/16.
+ */
+
+public class WebSocketActivity extends AppCompatActivity {
+
+    private static final String TAG = WebSocketActivity.class.getSimpleName();
+    private TextView textView;
+    private WebSocket webSocket;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_web_socket);
+        textView = (TextView) findViewById(R.id.textView);
+    }
+
+    @Override
+    protected void onStart() {
+        super.onStart();
+        connectWebSocket();
+    }
+
+    @Override
+    protected void onStop() {
+        super.onStop();
+        disconnectWebSocket();
+    }
+
+    private void connectWebSocket() {
+        OkHttpClient client = new OkHttpClient.Builder()
+                .readTimeout(0, TimeUnit.MILLISECONDS)
+                .build();
+
+        Request request = new Request.Builder()
+                .url("ws://echo.websocket.org")
+                .build();
+        webSocket = client.newWebSocket(request, getWebSocketListener());
+    }
+
+    private void disconnectWebSocket() {
+        if (webSocket != null) {
+            webSocket.cancel();
+        }
+    }
+
+    private WebSocketListener getWebSocketListener() {
+        return new WebSocketListener() {
+            @Override
+            public void onOpen(WebSocket webSocket, Response response) {
+                webSocket.send("Hello...");
+                webSocket.send("...World!");
+                webSocket.send(ByteString.decodeHex("deadbeef"));
+                webSocket.close(1000, "Goodbye, World!");
+            }
+
+            @Override
+            public void onMessage(WebSocket webSocket, final String text) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        textView.append("\n");
+                        textView.append("MESSAGE: " + text);
+                    }
+                });
+            }
+
+            @Override
+            public void onMessage(WebSocket webSocket,final ByteString bytes) {
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        textView.append("\n");
+                        textView.append("MESSAGE: " + bytes.hex());
+                    }
+                });
+            }
+
+            @Override
+            public void onClosing(WebSocket webSocket,final int code,final String reason) {
+                webSocket.close(1000, null);
+                runOnUiThread(new Runnable() {
+                    @Override
+                    public void run() {
+                        textView.append("\n");
+                        textView.append("CLOSE: " + code + " " + reason);
+                    }
+                });
+            }
+
+            @Override
+            public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+                t.printStackTrace();
+            }
+        };
+    }
+}
diff --git a/app/src/main/res/layout/activity_api_test.xml b/app/src/main/res/layout/activity_api_test.xml
index f1d0655..dd4f217 100644
--- a/app/src/main/res/layout/activity_api_test.xml
+++ b/app/src/main/res/layout/activity_api_test.xml
@@ -306,6 +306,19 @@
             android:layout_height="wrap_content"
             android:layout_gravity="center" />
 
+        <Button
+            android:id="@+id/checkOptionsRequest"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="checkOptionsRequest"
+            android:text="checkOptionsRequest" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
         <Button
             android:id="@+id/getCurrentConnectionQuality"
             android:layout_width="match_parent"
diff --git a/app/src/main/res/layout/activity_main.xml b/app/src/main/res/layout/activity_main.xml
index b034765..6dd97b4 100644
--- a/app/src/main/res/layout/activity_main.xml
+++ b/app/src/main/res/layout/activity_main.xml
@@ -150,6 +150,19 @@
             android:layout_height="wrap_content"
             android:layout_gravity="center" />
 
+        <Button
+            android:id="@+id/startWebSocketActivityButton"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="startWebSocketActivity"
+            android:text="StartWebSocketActivity" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
 
     </LinearLayout>
 
diff --git a/app/src/main/res/layout/activity_web_socket.xml b/app/src/main/res/layout/activity_web_socket.xml
new file mode 100644
index 0000000..b354147
--- /dev/null
+++ b/app/src/main/res/layout/activity_web_socket.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <TextView
+        android:id="@+id/textView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:textColor="@android:color/black" />
+
+</ScrollView>
+
diff --git a/assets/androidnetworking.png b/assets/androidnetworking.png
index 6b77d9a..58b2206 100644
Binary files a/assets/androidnetworking.png and b/assets/androidnetworking.png differ
diff --git a/build.gradle b/build.gradle
index a1c0b49..07f8574 100644
--- a/build.gradle
+++ b/build.gradle
@@ -20,9 +20,10 @@
 buildscript {
     repositories {
         jcenter()
+        google()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.1.3'
+        classpath 'com.android.tools.build:gradle:2.3.2'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.4'
         classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1'
         // NOTE: Do not place your application dependencies here; they belong
@@ -33,9 +34,30 @@ buildscript {
 allprojects {
     repositories {
         jcenter()
+        google()
     }
 }
 
 task clean(type: Delete) {
     delete rootProject.buildDir
 }
+
+ext {
+    // App tools version
+    compileSdkVersion = 27
+    minSdkVersion = 14
+    targetSdkVersion = 27
+    buildToolsVersion = "26.0.2"
+
+    // App dependencies versions
+    okHttp3Version = "3.9.1"
+    gsonVersion = "2.8.2"
+    jacksonVersion = "2.8.2"
+    rxJavaVersion = "1.3.4"
+    rxJavaAndroidVersion = "1.2.1"
+    rxJava2Version = "2.1.7"
+    rxJava2AndroidVersion = "2.0.1"
+    jUnitVersion = "4.12"
+    mockWebServerVersion = "3.9.1"
+    supportAppCompatVersion = "27.0.2"
+}
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index f806ecb..8e69630 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Wed Sep 14 13:42:33 GMT+05:30 2016
+#Wed Dec 06 17:39:39 MST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
diff --git a/jackson-android-networking/build.gradle b/jackson-android-networking/build.gradle
index 29c010a..7e75d80 100644
--- a/jackson-android-networking/build.gradle
+++ b/jackson-android-networking/build.gradle
@@ -20,12 +20,12 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.3"
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
-        targetSdkVersion 23
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -35,13 +35,25 @@ android {
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
+    packagingOptions {
+        exclude 'META-INF/DEPENDENCIES.txt'
+        exclude 'META-INF/LICENSE.txt'
+        exclude 'META-INF/NOTICE.txt'
+        exclude 'META-INF/NOTICE'
+        exclude 'META-INF/LICENSE'
+        exclude 'META-INF/DEPENDENCIES'
+        exclude 'META-INF/notice.txt'
+        exclude 'META-INF/license.txt'
+        exclude 'META-INF/dependencies.txt'
+        exclude 'META-INF/LGPL2.1'
+    }
 }
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
-    testCompile 'junit:junit:4.12'
-    androidTestCompile 'com.squareup.okhttp3:mockwebserver:3.2.0'
-    compile 'com.fasterxml.jackson.core:jackson-databind:2.8.2'
+    testCompile "junit:junit:$rootProject.ext.jUnitVersion"
+    androidTestCompile "com.squareup.okhttp3:mockwebserver:$rootProject.ext.mockWebServerVersion"
+    compile "com.fasterxml.jackson.core:jackson-databind:$rootProject.ext.jacksonVersion"
     compile project(':android-networking')
 }
 
diff --git a/jackson-android-networking/jackson-upload.gradle b/jackson-android-networking/jackson-upload.gradle
index 3258cf6..cf6bc41 100755
--- a/jackson-android-networking/jackson-upload.gradle
+++ b/jackson-android-networking/jackson-upload.gradle
@@ -24,7 +24,7 @@ def siteUrl = 'https://github.com/amitshekhariitbhu/Fast-Android-Networking'
 def gitUrl = 'https://github.com/amitshekhariitbhu/Fast-Android-Networking.git'
 
 group = "com.amitshekhar.android"
-version = '0.3.0'
+version = '1.0.1'
 
 install {
     repositories.mavenInstaller {
diff --git a/jackson-android-networking/src/androidTest/AndroidManifest.xml b/jackson-android-networking/src/androidTest/AndroidManifest.xml
new file mode 100755
index 0000000..b3889e6
--- /dev/null
+++ b/jackson-android-networking/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,26 @@
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.jacksonandroidnetworking">
+
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
+
+</manifest>
diff --git a/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/JacksonGetObjectApiTest.java b/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/JacksonGetObjectApiTest.java
new file mode 100644
index 0000000..7571b98
--- /dev/null
+++ b/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/JacksonGetObjectApiTest.java
@@ -0,0 +1,453 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.jacksonandroidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.AndroidNetworking;
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.OkHttpResponseAndParsedRequestListener;
+import com.androidnetworking.interfaces.ParsedRequestListener;
+import com.jacksonandroidnetworking.model.User;
+
+import org.json.JSONException;
+import org.junit.Rule;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 05/05/17.
+ */
+
+public class JacksonGetObjectApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public JacksonGetObjectApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+        AndroidNetworking.setParserFactory(new JacksonParserFactory());
+    }
+
+    public void testObjectGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        firstNameRef.set(userList.get(0).firstName);
+                        lastNameRef.set(userList.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectGetRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        assertEquals("Amit", response.getResult().firstName);
+
+        assertEquals("Shekhar", response.getResult().lastName);
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListGetRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        User user = response.getResult().get(0);
+
+        assertEquals("Amit", user.firstName);
+
+        assertEquals("Shekhar", user.lastName);
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.get(server.url("/").toString()).build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    public void testResponseBodyAndObjectGet() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectGet404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testResponseBodyAndObjectListGet() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                firstNameRef.set(userList.get(0).firstName);
+                                lastNameRef.set(userList.get(0).lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectListGet404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.get(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                headerRef.set(okHttpResponse.request().header("headerKey"));
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+
+}
diff --git a/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/JacksonPostObjectApiTest.java b/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/JacksonPostObjectApiTest.java
new file mode 100644
index 0000000..580dda4
--- /dev/null
+++ b/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/JacksonPostObjectApiTest.java
@@ -0,0 +1,484 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.jacksonandroidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.AndroidNetworking;
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.interfaces.OkHttpResponseAndParsedRequestListener;
+import com.androidnetworking.interfaces.ParsedRequestListener;
+import com.jacksonandroidnetworking.model.User;
+
+import org.json.JSONException;
+import org.junit.Rule;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicReference;
+
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 13/05/17.
+ */
+
+public class JacksonPostObjectApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public JacksonPostObjectApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+        AndroidNetworking.setParserFactory(new JacksonParserFactory());
+    }
+
+
+    public void testObjectPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsObject(User.class, new ParsedRequestListener<User>() {
+                    @Override
+                    public void onResponse(User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        firstNameRef.set(userList.get(0).firstName);
+                        lastNameRef.set(userList.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getAsObjectList(User.class, new ParsedRequestListener<List<User>>() {
+                    @Override
+                    public void onResponse(List<User> userList) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(ANError anError) {
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectPostRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        assertEquals("Amit", response.getResult().firstName);
+
+        assertEquals("Shekhar", response.getResult().lastName);
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<User> response = request.executeForObject(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListPostRequest() throws InterruptedException, JSONException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        User user = response.getResult().get(0);
+
+        assertEquals("Amit", user.firstName);
+
+        assertEquals("Shekhar", user.lastName);
+
+    }
+
+    @SuppressWarnings("unchecked")
+    public void testSynchronousObjectListPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        ANRequest request = AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build();
+
+        ANResponse<List<User>> response = request.executeForObjectList(User.class);
+
+        ANError error = response.getError();
+
+        assertEquals("data", error.getErrorBody());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, error.getErrorDetail());
+
+        assertEquals(404, error.getErrorCode());
+
+    }
+
+    public void testResponseBodyAndObjectPost() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectPost404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testResponseBodyAndObjectListPost() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                firstNameRef.set(userList.get(0).firstName);
+                                lastNameRef.set(userList.get(0).lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testResponseBodyAndObjectListPost404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObjectList(User.class,
+                        new OkHttpResponseAndParsedRequestListener<List<User>>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, List<User> userList) {
+                                assertTrue(false);
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                errorBodyRef.set(anError.getErrorBody());
+                                errorDetailRef.set(anError.getErrorDetail());
+                                errorCodeRef.set(anError.getErrorCode());
+                                latch.countDown();
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+    }
+
+    public void testHeaderPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<String> headerRef = new AtomicReference<>();
+        final AtomicReference<Boolean> responseBodySuccess = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        AndroidNetworking.post(server.url("/").toString())
+                .addHeaders("headerKey", "headerValue")
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .setExecutor(Executors.newSingleThreadExecutor())
+                .build()
+                .getAsOkHttpResponseAndObject(User.class,
+                        new OkHttpResponseAndParsedRequestListener<User>() {
+                            @Override
+                            public void onResponse(Response okHttpResponse, User user) {
+                                firstNameRef.set(user.firstName);
+                                lastNameRef.set(user.lastName);
+                                responseBodySuccess.set(okHttpResponse.isSuccessful());
+                                headerRef.set(okHttpResponse.request().header("headerKey"));
+                                latch.countDown();
+                            }
+
+                            @Override
+                            public void onError(ANError anError) {
+                                assertTrue(false);
+                            }
+                        });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(responseBodySuccess.get());
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+        assertEquals("headerValue", headerRef.get());
+    }
+
+
+}
diff --git a/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/model/User.java b/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/model/User.java
new file mode 100644
index 0000000..3b05b0e
--- /dev/null
+++ b/jackson-android-networking/src/androidTest/java/com/jacksonandroidnetworking/model/User.java
@@ -0,0 +1,31 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.jacksonandroidnetworking.model;
+
+/**
+ * Created by amitshekhar on 05/05/17.
+ */
+
+public class User {
+
+    public String firstName;
+    public String lastName;
+
+}
diff --git a/jackson-android-networking/src/main/java/com/jacksonandroidnetworking/JacksonParserFactory.java b/jackson-android-networking/src/main/java/com/jacksonandroidnetworking/JacksonParserFactory.java
index a865025..00dbda5 100644
--- a/jackson-android-networking/src/main/java/com/jacksonandroidnetworking/JacksonParserFactory.java
+++ b/jackson-android-networking/src/main/java/com/jacksonandroidnetworking/JacksonParserFactory.java
@@ -20,12 +20,14 @@
 package com.jacksonandroidnetworking;
 
 import com.androidnetworking.interfaces.Parser;
+import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.JavaType;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.ObjectReader;
 import com.fasterxml.jackson.databind.ObjectWriter;
 
 import java.lang.reflect.Type;
+import java.util.HashMap;
 
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -59,4 +61,40 @@ public JacksonParserFactory(ObjectMapper mapper) {
         return new JacksonRequestBodyParser<>(writer);
     }
 
+    @Override
+    public Object getObject(String string, Type type) {
+        try {
+            JavaType javaType = mapper.getTypeFactory().constructType(type);
+            ObjectReader objectReader = mapper.readerFor(javaType);
+            return objectReader.readValue(string);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    @Override
+    public String getString(Object object) {
+        try {
+            ObjectWriter objectWriter = mapper.writerFor(object.getClass());
+            return objectWriter.writeValueAsString(object);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return "";
+    }
+
+    @Override
+    public HashMap<String, String> getStringMap(Object object) {
+        try {
+            TypeReference<HashMap<String, String>> typeRef
+                    = new TypeReference<HashMap<String, String>>() {
+            };
+            ObjectWriter objectWriter = mapper.writerFor(object.getClass());
+            return mapper.readValue(objectWriter.writeValueAsString(object), typeRef);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return new HashMap<>();
+    }
 }
diff --git a/rx-android-networking/build.gradle b/rx-android-networking/build.gradle
index 1206325..a8581b9 100644
--- a/rx-android-networking/build.gradle
+++ b/rx-android-networking/build.gradle
@@ -18,12 +18,12 @@
 apply plugin: 'com.android.library'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.3"
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
 
     defaultConfig {
-        minSdkVersion 9
-        targetSdkVersion 23
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -37,10 +37,9 @@ android {
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
-    testCompile 'junit:junit:4.12'
-    androidTestCompile 'com.squareup.okhttp3:mockwebserver:3.2.0'
-    compile 'io.reactivex:rxandroid:1.2.1'
-    compile 'io.reactivex:rxjava:1.1.6'
+    testCompile "junit:junit:$rootProject.ext.jUnitVersion"
+    compile "io.reactivex:rxandroid:$rootProject.ext.rxJavaAndroidVersion"
+    compile "io.reactivex:rxjava:$rootProject.ext.rxJavaVersion"
     compile project(':android-networking')
 }
 //apply from: 'rx-upload.gradle'
diff --git a/rx-android-networking/rx-upload.gradle b/rx-android-networking/rx-upload.gradle
index 5498e48..50ba761 100755
--- a/rx-android-networking/rx-upload.gradle
+++ b/rx-android-networking/rx-upload.gradle
@@ -22,7 +22,7 @@ def siteUrl = 'https://github.com/amitshekhariitbhu/Fast-Android-Networking'
 def gitUrl = 'https://github.com/amitshekhariitbhu/Fast-Android-Networking.git'
 
 group = "com.amitshekhar.android"
-version = '0.2.0'
+version = '1.0.1'
 
 install {
     repositories.mavenInstaller {
diff --git a/rx-android-networking/src/main/java/com/rxandroidnetworking/RxANRequest.java b/rx-android-networking/src/main/java/com/rxandroidnetworking/RxANRequest.java
index 41f65cc..3f9084f 100644
--- a/rx-android-networking/src/main/java/com/rxandroidnetworking/RxANRequest.java
+++ b/rx-android-networking/src/main/java/com/rxandroidnetworking/RxANRequest.java
@@ -21,18 +21,24 @@
 
 import com.androidnetworking.common.ANRequest;
 import com.androidnetworking.common.Method;
-import com.androidnetworking.common.ResponseType;
 import com.androidnetworking.common.RequestType;
+import com.androidnetworking.common.ResponseType;
+import com.google.gson.internal.$Gson$Types;
 import com.google.gson.reflect.TypeToken;
 
 import org.json.JSONArray;
 import org.json.JSONObject;
 
+import java.util.List;
+
+import rx.Completable;
 import rx.Observable;
+import rx.Single;
 
 /**
  * Created by amitshekhar on 10/06/16.
  */
+@SuppressWarnings({"unchecked", "unused"})
 public class RxANRequest extends ANRequest<RxANRequest> {
 
     public RxANRequest(GetRequestBuilder builder) {
@@ -62,6 +68,14 @@ public RxANRequest(MultiPartBuilder builder) {
         }
     }
 
+    public Single<JSONObject> getJSONObjectSingle() {
+        return getJSONObjectObservable().toSingle();
+    }
+
+    public Completable getJSONObjectCompletable() {
+        return getJSONObjectObservable().toCompletable();
+    }
+
     public Observable<JSONArray> getJSONArrayObservable() {
         this.setResponseAs(ResponseType.JSON_ARRAY);
         if (this.getRequestType() == RequestType.SIMPLE) {
@@ -73,6 +87,14 @@ public RxANRequest(MultiPartBuilder builder) {
         }
     }
 
+    public Single<JSONArray> getJSONArraySingle() {
+        return getJSONArrayObservable().toSingle();
+    }
+
+    public Completable getJSONArrayCompletable() {
+        return getJSONArrayObservable().toCompletable();
+    }
+
     public Observable<Bitmap> getBitmapObservable() {
         this.setResponseAs(ResponseType.BITMAP);
         if (this.getRequestType() == RequestType.SIMPLE) {
@@ -84,6 +106,14 @@ public RxANRequest(MultiPartBuilder builder) {
         }
     }
 
+    public Single<Bitmap> getBitmapSingle() {
+        return getBitmapObservable().toSingle();
+    }
+
+    public Completable getBitmapCompletable() {
+        return getBitmapObservable().toCompletable();
+    }
+
     public Observable<String> getStringObservable() {
         this.setResponseAs(ResponseType.STRING);
         if (this.getRequestType() == RequestType.SIMPLE) {
@@ -95,10 +125,26 @@ public RxANRequest(MultiPartBuilder builder) {
         }
     }
 
+    public Single<String> getStringSingle() {
+        return getStringObservable().toSingle();
+    }
+
+    public Completable getStringCompletable() {
+        return getStringObservable().toCompletable();
+    }
+
     public Observable<String> getDownloadObservable() {
         return RxInternalNetworking.generateDownloadObservable(this);
     }
 
+    public Single<String> getDownloadSingle() {
+        return getDownloadObservable().toSingle();
+    }
+
+    public Completable getDownloadCompletable() {
+        return getDownloadObservable().toCompletable();
+    }
+
     public <T> Observable<T> getParseObservable(TypeToken<T> typeToken) {
         this.setType(typeToken.getType());
         this.setResponseAs(ResponseType.PARSED);
@@ -111,6 +157,54 @@ public RxANRequest(MultiPartBuilder builder) {
         }
     }
 
+    public <T> Single<T> getParseSingle(TypeToken<T> typeToken) {
+        return getParseObservable(typeToken).toSingle();
+    }
+
+    public <T> Completable getParseCompletable(TypeToken<T> typeToken) {
+        return getParseObservable(typeToken).toCompletable();
+    }
+
+    public <T> Observable<T> getObjectObservable(Class<T> objectClass) {
+        this.setType(objectClass);
+        this.setResponseAs(ResponseType.PARSED);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return RxInternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return RxInternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public <T> Single<T> getObjectSingle(Class<T> objectClass) {
+        return getObjectObservable(objectClass).toSingle();
+    }
+
+    public <T> Completable getObjectCompletable(Class<T> objectClass) {
+        return getObjectObservable(objectClass).toCompletable();
+    }
+
+    public <T> Observable<List<T>> getObjectListObservable(Class<T> objectClass) {
+        this.setType($Gson$Types.newParameterizedTypeWithOwner(null, List.class, objectClass));
+        this.setResponseAs(ResponseType.PARSED);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return RxInternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return RxInternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public <T> Single<List<T>> getObjectListSingle(Class<T> objectClass) {
+        return getObjectListObservable(objectClass).toSingle();
+    }
+
+    public <T> Completable getObjectListCompletable(Class<T> objectClass) {
+        return getObjectListObservable(objectClass).toCompletable();
+    }
+
     public static class GetRequestBuilder extends ANRequest.GetRequestBuilder<GetRequestBuilder> {
 
         public GetRequestBuilder(String url) {
@@ -133,6 +227,13 @@ public HeadRequestBuilder(String url) {
         }
     }
 
+    public static class OptionsRequestBuilder extends GetRequestBuilder {
+
+        public OptionsRequestBuilder(String url) {
+            super(url, Method.OPTIONS);
+        }
+    }
+
     public static class PostRequestBuilder extends ANRequest.PostRequestBuilder<PostRequestBuilder> {
 
         public PostRequestBuilder(String url) {
@@ -169,6 +270,13 @@ public PatchRequestBuilder(String url) {
         }
     }
 
+    public static class DynamicRequestBuilder extends PostRequestBuilder {
+
+        public DynamicRequestBuilder(String url, int method) {
+            super(url, method);
+        }
+    }
+
     public static class DownloadBuilder extends ANRequest.DownloadBuilder<DownloadBuilder> {
 
         public DownloadBuilder(String url, String dirPath, String fileName) {
diff --git a/rx-android-networking/src/main/java/com/rxandroidnetworking/RxAndroidNetworking.java b/rx-android-networking/src/main/java/com/rxandroidnetworking/RxAndroidNetworking.java
index 48f26dc..6286836 100644
--- a/rx-android-networking/src/main/java/com/rxandroidnetworking/RxAndroidNetworking.java
+++ b/rx-android-networking/src/main/java/com/rxandroidnetworking/RxAndroidNetworking.java
@@ -24,7 +24,7 @@
 /**
  * RxAndroidNetworking entry point.
  * You must initialize this class before use. The simplest way is to just do
- * {#code RxAndroidNetworking.initialize(context)}.
+ * {#code AndroidNetworking.initialize(context)}.
  */
 public class RxAndroidNetworking {
 
@@ -54,6 +54,16 @@ private RxAndroidNetworking() {
         return new RxANRequest.HeadRequestBuilder(url);
     }
 
+    /**
+     * Method to make OPTIONS request
+     *
+     * @param url The url on which request is to be made
+     * @return The OptionsRequestBuilder
+     */
+    public static RxANRequest.OptionsRequestBuilder options(String url) {
+        return new RxANRequest.OptionsRequestBuilder(url);
+    }
+
     /**
      * Method to make POST request
      *
@@ -115,4 +125,15 @@ private RxAndroidNetworking() {
     public static RxANRequest.MultiPartBuilder upload(String url) {
         return new RxANRequest.MultiPartBuilder(url);
     }
+
+    /**
+     * Method to make Dynamic request
+     *
+     * @param url    The url on which request is to be made
+     * @param method The HTTP METHOD for the request
+     * @return The DynamicRequestBuilder
+     */
+    public static RxANRequest.DynamicRequestBuilder request(String url, int method) {
+        return new RxANRequest.DynamicRequestBuilder(url, method);
+    }
 }
diff --git a/rx-android-networking/src/main/java/com/rxandroidnetworking/RxInternalNetworking.java b/rx-android-networking/src/main/java/com/rxandroidnetworking/RxInternalNetworking.java
index b8be23a..1de12cc 100644
--- a/rx-android-networking/src/main/java/com/rxandroidnetworking/RxInternalNetworking.java
+++ b/rx-android-networking/src/main/java/com/rxandroidnetworking/RxInternalNetworking.java
@@ -19,7 +19,6 @@
 import android.net.TrafficStats;
 
 import com.androidnetworking.common.ANConstants;
-import com.androidnetworking.common.ANLog;
 import com.androidnetworking.common.ANResponse;
 import com.androidnetworking.common.ConnectionClassManager;
 import com.androidnetworking.common.RequestType;
@@ -49,6 +48,7 @@
 import static com.androidnetworking.common.Method.DELETE;
 import static com.androidnetworking.common.Method.GET;
 import static com.androidnetworking.common.Method.HEAD;
+import static com.androidnetworking.common.Method.OPTIONS;
 import static com.androidnetworking.common.Method.PATCH;
 import static com.androidnetworking.common.Method.POST;
 import static com.androidnetworking.common.Method.PUT;
@@ -88,6 +88,10 @@
                 builder = builder.head();
                 break;
             }
+            case OPTIONS: {
+                builder = builder.method(ANConstants.OPTIONS, null);
+                break;
+            }
             case PATCH: {
                 requestBody = request.getRequestBody();
                 builder = builder.patch(requestBody);
@@ -108,7 +112,6 @@
         } else {
             request.setCall(InternalNetworking.sHttpClient.newCall(okHttpRequest));
         }
-        ANLog.d("call generated successfully for simple observable");
         return Observable.create(new ANOnSubscribe<T>(request));
     }
 
@@ -210,7 +213,6 @@ public void request(long n) {
             if (!compareAndSet(false, true)) return; // Request was already triggered.
             Response okHttpResponse = null;
             try {
-                ANLog.d("initiate simple network call observable");
                 final long startTime = System.currentTimeMillis();
                 final long startBytes = TrafficStats.getTotalRxBytes();
                 okHttpResponse = call.execute();
@@ -238,11 +240,8 @@ public void request(long n) {
                                         request.getRequestBody().contentLength() : -1, 0, true);
                     }
                 }
-                if (okHttpResponse.code() == 304) {
-                    ANLog.d("error code 304 simple observable");
-                } else if (okHttpResponse.code() >= 400) {
+                if (okHttpResponse.code() >= 400) {
                     if (!subscriber.isUnsubscribed()) {
-                        ANLog.d("delivering error to subscriber from simple observable");
                         subscriber.onError(Utils.getErrorForServerResponse(new ANError(okHttpResponse),
                                 request, okHttpResponse.code()));
                     }
@@ -250,30 +249,25 @@ public void request(long n) {
                     ANResponse<T> response = request.parseResponse(okHttpResponse);
                     if (!response.isSuccess()) {
                         if (!subscriber.isUnsubscribed()) {
-                            ANLog.d("delivering error to subscriber from simple observable");
                             subscriber.onError(response.getError());
                         }
                     } else {
                         if (!subscriber.isUnsubscribed()) {
-                            ANLog.d("delivering response to subscriber from simple observable");
                             subscriber.onNext(response.getResult());
                         }
                         if (!subscriber.isUnsubscribed()) {
-                            ANLog.d("delivering completion to subscriber from simple observable");
                             subscriber.onCompleted();
                         }
                     }
                 }
             } catch (IOException ioe) {
                 if (!subscriber.isUnsubscribed()) {
-                    ANLog.d("delivering error to subscriber from simple observable");
                     subscriber.onError(Utils.getErrorForConnection(new ANError(ioe)));
                 }
             } catch (Exception e) {
                 Exceptions.throwIfFatal(e);
                 if (!subscriber.isUnsubscribed()) {
-                    ANLog.d("delivering error to subscriber from simple observable");
-                    subscriber.onError(Utils.getErrorForNetworkOnMainThreadOrConnection(e));
+                    subscriber.onError(Utils.getErrorForConnection(new ANError(e)));
                 }
             } finally {
                 SourceCloseUtil.close(okHttpResponse, request);
@@ -282,7 +276,6 @@ public void request(long n) {
 
         @Override
         public void unsubscribe() {
-            ANLog.d("unsubscribed from simple observable");
             call.cancel();
         }
 
@@ -310,7 +303,6 @@ public void request(long n) {
             if (!compareAndSet(false, true)) return; // Request was already triggered.
             Response okHttpResponse;
             try {
-                ANLog.d("initiate download network call observable");
                 final long startTime = System.currentTimeMillis();
                 final long startBytes = TrafficStats.getTotalRxBytes();
                 okHttpResponse = request.getCall().execute();
@@ -360,7 +352,7 @@ public void request(long n) {
             } catch (Exception e) {
                 Exceptions.throwIfFatal(e);
                 if (!subscriber.isUnsubscribed()) {
-                    subscriber.onError(Utils.getErrorForNetworkOnMainThreadOrConnection(e));
+                    subscriber.onError(Utils.getErrorForConnection(new ANError(e)));
                 }
             }
         }
@@ -455,7 +447,7 @@ public void request(long n) {
             } catch (Exception e) {
                 Exceptions.throwIfFatal(e);
                 if (!subscriber.isUnsubscribed()) {
-                    subscriber.onError(Utils.getErrorForNetworkOnMainThreadOrConnection(e));
+                    subscriber.onError(Utils.getErrorForConnection(new ANError(e)));
                 }
             } finally {
                 SourceCloseUtil.close(okHttpResponse, request);
diff --git a/rx2-android-networking/.gitignore b/rx2-android-networking/.gitignore
new file mode 100644
index 0000000..796b96d
--- /dev/null
+++ b/rx2-android-networking/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/rx2-android-networking/build.gradle b/rx2-android-networking/build.gradle
new file mode 100644
index 0000000..24dd65e
--- /dev/null
+++ b/rx2-android-networking/build.gradle
@@ -0,0 +1,48 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+apply plugin: 'com.android.library'
+
+android {
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
+
+    defaultConfig {
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+        versionCode 1
+        versionName "1.0"
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    testCompile "junit:junit:$rootProject.ext.jUnitVersion"
+    androidTestCompile "com.squareup.okhttp3:mockwebserver:$rootProject.ext.mockWebServerVersion"
+    compile "io.reactivex.rxjava2:rxandroid:$rootProject.ext.rxJava2AndroidVersion"
+    compile "io.reactivex.rxjava2:rxjava:$rootProject.ext.rxJava2Version"
+    compile project(':android-networking')
+}
+//apply from: 'rx2-upload.gradle'
diff --git a/rx2-android-networking/proguard-rules.pro b/rx2-android-networking/proguard-rules.pro
new file mode 100644
index 0000000..6b7a2bf
--- /dev/null
+++ b/rx2-android-networking/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/amitshekhar/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/rx2-android-networking/rx2-upload.gradle b/rx2-android-networking/rx2-upload.gradle
new file mode 100755
index 0000000..50f6b80
--- /dev/null
+++ b/rx2-android-networking/rx2-upload.gradle
@@ -0,0 +1,103 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+apply plugin: 'com.github.dcendents.android-maven'
+apply plugin: "com.jfrog.bintray"
+
+def siteUrl = 'https://github.com/amitshekhariitbhu/Fast-Android-Networking'
+def gitUrl = 'https://github.com/amitshekhariitbhu/Fast-Android-Networking.git'
+
+group = "com.amitshekhar.android"
+version = '1.0.1'
+
+install {
+    repositories.mavenInstaller {
+        pom.project {
+            packaging 'aar'
+
+            name 'Fast Android Networking'
+            description 'Fast Android Networking is a powerful library for doing any type of networking in Android applications'
+
+            url siteUrl
+
+            licenses {
+                license {
+                    name 'The Apache Software License, Version 2.0'
+                    url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                }
+            }
+
+            developers {
+                developer {
+                    id 'amitshekhariitbhu'
+                    name 'Amit Shekhar'
+                    email 'amit.shekhar.iitbhu@gmail.com'
+                }
+            }
+
+            scm {
+                connection gitUrl
+                developerConnection gitUrl
+                url siteUrl
+            }
+        }
+    }
+}
+
+task sourcesJar(type: Jar) {
+    from android.sourceSets.main.java.srcDirs
+    classifier = 'sources'
+}
+
+task javadoc(type: Javadoc) {
+    source = android.sourceSets.main.java.srcDirs
+    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
+    classpath += configurations.compile
+}
+
+task javadocJar(type: Jar, dependsOn: javadoc) {
+    classifier = 'javadoc'
+    from javadoc.destinationDir
+}
+artifacts {
+    archives javadocJar
+    archives sourcesJar
+}
+
+if (project.rootProject.file("local.properties").exists()) {
+    Properties properties = new Properties()
+    properties.load(project.rootProject.file('local.properties').newDataInputStream())
+
+    bintray {
+        user = properties.getProperty("bintray.user")
+        key = properties.getProperty("bintray.apikey")
+
+        configurations = ['archives']
+        dryRun = false
+
+        pkg {
+            repo = "maven"
+            name = "rx2-android-networking"
+            websiteUrl = siteUrl
+            vcsUrl = gitUrl
+            licenses = ["Apache-2.0"]
+            publish = true
+        }
+    }
+}
diff --git a/rx2-android-networking/src/androidTest/AndroidManifest.xml b/rx2-android-networking/src/androidTest/AndroidManifest.xml
new file mode 100755
index 0000000..501fd9a
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/AndroidManifest.xml
@@ -0,0 +1,26 @@
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.rx2androidnetworking">
+
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
+
+</manifest>
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetJSONApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetJSONApiTest.java
new file mode 100644
index 0000000..e9f54be
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetJSONApiTest.java
@@ -0,0 +1,466 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.SingleObserver;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.annotations.NonNull;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 30/04/17.
+ */
+
+public class Rx2GetJSONApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2GetJSONApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testJSONObjectGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getJSONObjectObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONObject>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONObjectSingleGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getJSONObjectSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONObjectGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getJSONObjectObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONObject>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONObjectSingleGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getJSONObjectSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONArrayGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getJSONArrayObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONArray>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONArraySingleGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getJSONArraySingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONArray>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONArrayGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getJSONArrayObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONArray>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONArraySingleGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getJSONArraySingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONArray>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+}
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetObjectApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetObjectApiTest.java
new file mode 100644
index 0000000..72d91e6
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetObjectApiTest.java
@@ -0,0 +1,449 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+import com.rx2androidnetworking.model.User;
+
+import org.junit.Rule;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.SingleObserver;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.annotations.NonNull;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 26/04/17.
+ */
+
+public class Rx2GetObjectApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2GetObjectApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testObjectGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getObjectObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<User>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectSingleGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getObjectSingle(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<User>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getObjectObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<User>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectSingleGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getObjectSingle(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<User>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getObjectListObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<List<User>>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(List<User> userList) {
+                        firstNameRef.set(userList.get(0).firstName);
+                        lastNameRef.set(userList.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListSingleGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getObjectListSingle(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<List<User>>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull List<User> users) {
+                        firstNameRef.set(users.get(0).firstName);
+                        lastNameRef.set(users.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        assertTrue(false);
+                    }
+                });
+
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getObjectListObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<List<User>>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(List<User> userList) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListSingleGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getObjectListSingle(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<List<User>>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull List<User> users) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+}
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetStringApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetStringApiTest.java
new file mode 100644
index 0000000..db26c7c
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2GetStringApiTest.java
@@ -0,0 +1,248 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.SingleObserver;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.annotations.NonNull;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 22/04/17.
+ */
+
+public class Rx2GetStringApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2GetStringApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testStringGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getStringObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(String response) {
+                        responseRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testStringSingleGetRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getStringSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<String>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull String response) {
+                        responseRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testStringGetRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getStringObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testStringGetSingleRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.get(server.url("/").toString())
+                .build()
+                .getStringSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<String>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull String s) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+}
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartJSONApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartJSONApiTest.java
new file mode 100644
index 0000000..0f24b34
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartJSONApiTest.java
@@ -0,0 +1,474 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.SingleObserver;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.annotations.NonNull;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 03/05/17.
+ */
+
+public class Rx2MultipartJSONApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2MultipartJSONApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testJSONObjectMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getJSONObjectObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONObject>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONObjectSingleMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getJSONObjectSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONObjectMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getJSONObjectObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONObject>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONObjectSingleMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getJSONObjectSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject jsonObject) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONArrayMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getJSONArrayObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONArray>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONArraySingleMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getJSONArraySingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONArray>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONArrayMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getJSONArrayObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONArray>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONArraySingleMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getJSONArraySingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONArray>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONArray jsonArray) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+}
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartObjectApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartObjectApiTest.java
new file mode 100644
index 0000000..ae74aa5
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartObjectApiTest.java
@@ -0,0 +1,272 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+import com.rx2androidnetworking.model.User;
+
+import org.junit.Rule;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 29/04/17.
+ */
+
+public class Rx2MultipartObjectApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2MultipartObjectApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testObjectMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getObjectObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<User>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getObjectObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<User>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getObjectListObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<List<User>>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(List<User> userList) {
+                        firstNameRef.set(userList.get(0).firstName);
+                        lastNameRef.set(userList.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListMultipartRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getObjectListObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<List<User>>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(List<User> userList) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+}
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartStringApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartStringApiTest.java
new file mode 100644
index 0000000..dc9fb6e
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2MultipartStringApiTest.java
@@ -0,0 +1,162 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 25/04/17.
+ */
+
+public class Rx2MultipartStringApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2MultipartStringApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testStringMultipartRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getStringObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(String response) {
+                        responseRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testStringPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.upload(server.url("/").toString())
+                .addMultipartParameter("key", "value")
+                .build()
+                .getStringObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+}
\ No newline at end of file
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostJSONApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostJSONApiTest.java
new file mode 100644
index 0000000..b3caebc
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostJSONApiTest.java
@@ -0,0 +1,285 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 02/05/17.
+ */
+
+public class Rx2PostJSONApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2PostJSONApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testJSONObjectPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getJSONObjectObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONObject>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONObject response) {
+                        try {
+                            firstNameRef.set(response.getString("firstName"));
+                            lastNameRef.set(response.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONObjectPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getJSONObjectObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONObject>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONObject response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testJSONArrayPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getJSONArrayObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONArray>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONArray response) {
+                        try {
+                            JSONObject jsonObject = response.getJSONObject(0);
+                            firstNameRef.set(jsonObject.getString("firstName"));
+                            lastNameRef.set(jsonObject.getString("lastName"));
+                            latch.countDown();
+                        } catch (JSONException e) {
+                            assertTrue(false);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testJSONArrayPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getJSONArrayObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<JSONArray>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(JSONArray response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+}
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostObjectApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostObjectApiTest.java
new file mode 100644
index 0000000..544f494
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostObjectApiTest.java
@@ -0,0 +1,276 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+import com.rx2androidnetworking.model.User;
+
+import org.junit.Rule;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 28/04/17.
+ */
+
+public class Rx2PostObjectApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2PostObjectApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testObjectPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getObjectObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<User>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(User user) {
+                        firstNameRef.set(user.firstName);
+                        lastNameRef.set(user.lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getObjectObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<User>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(User user) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+    public void testObjectListPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("[{\"firstName\":\"Amit\", \"lastName\":\"Shekhar\"}]"));
+
+        final AtomicReference<String> firstNameRef = new AtomicReference<>();
+        final AtomicReference<String> lastNameRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getObjectListObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<List<User>>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(List<User> userList) {
+                        firstNameRef.set(userList.get(0).firstName);
+                        lastNameRef.set(userList.get(0).lastName);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("Amit", firstNameRef.get());
+        assertEquals("Shekhar", lastNameRef.get());
+    }
+
+    public void testObjectListPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getObjectListObservable(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<List<User>>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(List<User> userList) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+}
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostStringApiTest.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostStringApiTest.java
new file mode 100644
index 0000000..3ba9f0d
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/Rx2PostStringApiTest.java
@@ -0,0 +1,164 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.app.Application;
+import android.test.ApplicationTestCase;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.error.ANError;
+
+import org.junit.Rule;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
+
+import io.reactivex.Observer;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+/**
+ * Created by amitshekhar on 24/04/17.
+ */
+
+public class Rx2PostStringApiTest extends ApplicationTestCase<Application> {
+
+    @Rule
+    public final MockWebServer server = new MockWebServer();
+
+    public Rx2PostStringApiTest() {
+        super(Application.class);
+    }
+
+    @Override
+    public void setUp() throws Exception {
+        super.setUp();
+        createApplication();
+    }
+
+    public void testStringPostRequest() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setBody("data"));
+
+        final AtomicReference<String> responseRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isCompletedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(2);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getStringObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(String response) {
+                        responseRef.set(response);
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        isCompletedRef.set(true);
+                        latch.countDown();
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+        assertTrue(isCompletedRef.get());
+
+        assertEquals("data", responseRef.get());
+    }
+
+    public void testStringPostRequest404() throws InterruptedException {
+
+        server.enqueue(new MockResponse().setResponseCode(404).setBody("data"));
+
+        final AtomicReference<String> errorDetailRef = new AtomicReference<>();
+        final AtomicReference<String> errorBodyRef = new AtomicReference<>();
+        final AtomicReference<Integer> errorCodeRef = new AtomicReference<>();
+        final AtomicReference<Boolean> isSubscribedRef = new AtomicReference<>();
+        final CountDownLatch latch = new CountDownLatch(1);
+
+        Rx2AndroidNetworking.post(server.url("/").toString())
+                .addBodyParameter("fistName", "Amit")
+                .addBodyParameter("lastName", "Shekhar")
+                .build()
+                .getStringObservable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<String>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+                        isSubscribedRef.set(true);
+                    }
+
+                    @Override
+                    public void onNext(String response) {
+                        assertTrue(false);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        ANError anError = (ANError) e;
+                        errorBodyRef.set(anError.getErrorBody());
+                        errorDetailRef.set(anError.getErrorDetail());
+                        errorCodeRef.set(anError.getErrorCode());
+                        latch.countDown();
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        assertTrue(false);
+                    }
+                });
+
+        assertTrue(latch.await(2, SECONDS));
+
+        assertTrue(isSubscribedRef.get());
+
+        assertEquals(ANConstants.RESPONSE_FROM_SERVER_ERROR, errorDetailRef.get());
+
+        assertEquals("data", errorBodyRef.get());
+
+        assertEquals(404, errorCodeRef.get().intValue());
+
+    }
+
+}
\ No newline at end of file
diff --git a/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/model/User.java b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/model/User.java
new file mode 100644
index 0000000..4c91f7b
--- /dev/null
+++ b/rx2-android-networking/src/androidTest/java/com/rx2androidnetworking/model/User.java
@@ -0,0 +1,31 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking.model;
+
+/**
+ * Created by amitshekhar on 26/04/17.
+ */
+
+public class User {
+
+    public String firstName;
+    public String lastName;
+
+}
diff --git a/rx2-android-networking/src/main/AndroidManifest.xml b/rx2-android-networking/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..40fbb9e
--- /dev/null
+++ b/rx2-android-networking/src/main/AndroidManifest.xml
@@ -0,0 +1,22 @@
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.rx2androidnetworking">
+</manifest>
diff --git a/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2ANRequest.java b/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2ANRequest.java
new file mode 100644
index 0000000..a19c9f1
--- /dev/null
+++ b/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2ANRequest.java
@@ -0,0 +1,370 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.graphics.Bitmap;
+
+import com.androidnetworking.common.ANRequest;
+import com.androidnetworking.common.Method;
+import com.androidnetworking.common.RequestType;
+import com.androidnetworking.common.ResponseType;
+import com.google.gson.internal.$Gson$Types;
+import com.google.gson.reflect.TypeToken;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+
+import java.util.List;
+
+import io.reactivex.BackpressureStrategy;
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Observable;
+import io.reactivex.Single;
+
+/**
+ * Created by Prashant Gupta on 30-01-2017.
+ */
+@SuppressWarnings({"unchecked", "unused"})
+public class Rx2ANRequest extends ANRequest<Rx2ANRequest> {
+
+    public Rx2ANRequest(GetRequestBuilder builder) {
+        super(builder);
+    }
+
+    public Rx2ANRequest(PostRequestBuilder builder) {
+        super(builder);
+    }
+
+    public Rx2ANRequest(DownloadBuilder builder) {
+        super(builder);
+    }
+
+    public Rx2ANRequest(MultiPartBuilder builder) {
+        super(builder);
+    }
+
+    public Observable<JSONObject> getJSONObjectObservable() {
+        this.setResponseAs(ResponseType.JSON_OBJECT);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return Rx2InternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return Rx2InternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public Flowable<JSONObject> getJSONObjectFlowable() {
+        return getJSONObjectObservable().toFlowable(BackpressureStrategy.LATEST);
+    }
+
+    public Single<JSONObject> getJSONObjectSingle() {
+        return getJSONObjectObservable().singleOrError();
+    }
+
+    public Maybe<JSONObject> getJSONObjectMaybe() {
+        return getJSONObjectObservable().singleElement();
+    }
+
+    public Completable getJSONObjectCompletable() {
+        return getJSONObjectObservable().ignoreElements();
+    }
+
+    public Observable<JSONArray> getJSONArrayObservable() {
+        this.setResponseAs(ResponseType.JSON_ARRAY);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return Rx2InternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return Rx2InternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public Flowable<JSONArray> getJSONArrayFlowable() {
+        return getJSONArrayObservable().toFlowable(BackpressureStrategy.LATEST);
+    }
+
+    public Single<JSONArray> getJSONArraySingle() {
+        return getJSONArrayObservable().singleOrError();
+    }
+
+    public Maybe<JSONArray> getJSONArrayMaybe() {
+        return getJSONArrayObservable().singleElement();
+    }
+
+    public Completable getJSONArrayCompletable() {
+        return getJSONArrayObservable().ignoreElements();
+    }
+
+    public Observable<Bitmap> getBitmapObservable() {
+        this.setResponseAs(ResponseType.BITMAP);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return Rx2InternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return Rx2InternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public Flowable<Bitmap> getBitmapFlowable() {
+        return getBitmapObservable().toFlowable(BackpressureStrategy.LATEST);
+    }
+
+    public Single<Bitmap> getBitmapSingle() {
+        return getBitmapObservable().singleOrError();
+    }
+
+    public Maybe<Bitmap> getBitmapMaybe() {
+        return getBitmapObservable().singleElement();
+    }
+
+    public Completable getBitmapCompletable() {
+        return getBitmapObservable().ignoreElements();
+    }
+
+    public Observable<String> getStringObservable() {
+        this.setResponseAs(ResponseType.STRING);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return Rx2InternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return Rx2InternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public Flowable<String> getStringFlowable() {
+        return getStringObservable().toFlowable(BackpressureStrategy.LATEST);
+    }
+
+    public Single<String> getStringSingle() {
+        return getStringObservable().singleOrError();
+    }
+
+    public Maybe<String> getStringMaybe() {
+        return getStringObservable().singleElement();
+    }
+
+    public Completable getStringCompletable() {
+        return getStringObservable().ignoreElements();
+    }
+
+    public Observable<String> getDownloadObservable() {
+        return Rx2InternalNetworking.generateDownloadObservable(this);
+    }
+
+    public Flowable<String> getDownloadFlowable() {
+        return getDownloadObservable().toFlowable(BackpressureStrategy.LATEST);
+    }
+
+    public Single<String> getDownloadSingle() {
+        return getDownloadObservable().singleOrError();
+    }
+
+    public Maybe<String> getDownloadMaybe() {
+        return getDownloadObservable().singleElement();
+    }
+
+    public Completable getDownloadCompletable() {
+        return getDownloadObservable().ignoreElements();
+    }
+
+    public <T> Observable<T> getParseObservable(TypeToken<T> typeToken) {
+        this.setType(typeToken.getType());
+        this.setResponseAs(ResponseType.PARSED);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return Rx2InternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return Rx2InternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public <T> Flowable<T> getParseFlowable(TypeToken<T> typeToken) {
+        return getParseObservable(typeToken).toFlowable(BackpressureStrategy.LATEST);
+    }
+
+    public <T> Single<T> getParseSingle(TypeToken<T> typeToken) {
+        return getParseObservable(typeToken).singleOrError();
+    }
+
+    public <T> Maybe<T> getParseMaybe(TypeToken<T> typeToken) {
+        return getParseObservable(typeToken).singleElement();
+    }
+
+    public <T> Completable getParseCompletable(TypeToken<T> typeToken) {
+        return getParseObservable(typeToken).ignoreElements();
+    }
+
+    public <T> Observable<T> getObjectObservable(Class<T> objectClass) {
+        this.setType(objectClass);
+        this.setResponseAs(ResponseType.PARSED);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return Rx2InternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return Rx2InternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public <T> Flowable<T> getObjectFlowable(Class<T> objectClass) {
+        return getObjectObservable(objectClass).toFlowable(BackpressureStrategy.LATEST);
+    }
+
+    public <T> Single<T> getObjectSingle(Class<T> objectClass) {
+        return getObjectObservable(objectClass).singleOrError();
+    }
+
+    public <T> Maybe<T> getObjectMaybe(Class<T> objectClass) {
+        return getObjectObservable(objectClass).singleElement();
+    }
+
+    public <T> Completable getObjectCompletable(Class<T> objectClass) {
+        return getObjectObservable(objectClass).ignoreElements();
+    }
+
+    public <T> Observable<List<T>> getObjectListObservable(Class<T> objectClass) {
+        this.setType($Gson$Types.newParameterizedTypeWithOwner(null, List.class, objectClass));
+        this.setResponseAs(ResponseType.PARSED);
+        if (this.getRequestType() == RequestType.SIMPLE) {
+            return Rx2InternalNetworking.generateSimpleObservable(this);
+        } else if (this.getRequestType() == RequestType.MULTIPART) {
+            return Rx2InternalNetworking.generateMultipartObservable(this);
+        } else {
+            return null;
+        }
+    }
+
+    public <T> Flowable<List<T>> getObjectListFlowable(Class<T> objectClass) {
+        return getObjectListObservable(objectClass).toFlowable(BackpressureStrategy.LATEST);
+    }
+
+    public <T> Single<List<T>> getObjectListSingle(Class<T> objectClass) {
+        return getObjectListObservable(objectClass).singleOrError();
+    }
+
+    public <T> Maybe<List<T>> getObjectListMaybe(Class<T> objectClass) {
+        return getObjectListObservable(objectClass).singleElement();
+    }
+
+    public <T> Completable getObjectListCompletable(Class<T> objectClass) {
+        return getObjectListObservable(objectClass).ignoreElements();
+    }
+
+    public static class GetRequestBuilder extends ANRequest.GetRequestBuilder<GetRequestBuilder> {
+
+        public GetRequestBuilder(String url) {
+            super(url);
+        }
+
+        private GetRequestBuilder(String url, int method) {
+            super(url, method);
+        }
+
+        public Rx2ANRequest build() {
+            return new Rx2ANRequest(this);
+        }
+    }
+
+    public static class HeadRequestBuilder extends GetRequestBuilder {
+
+        public HeadRequestBuilder(String url) {
+            super(url, Method.HEAD);
+        }
+    }
+
+    public static class OptionsRequestBuilder extends GetRequestBuilder {
+
+        public OptionsRequestBuilder(String url) {
+            super(url, Method.OPTIONS);
+        }
+    }
+
+    public static class PostRequestBuilder extends ANRequest.PostRequestBuilder<PostRequestBuilder> {
+
+        public PostRequestBuilder(String url) {
+            super(url);
+        }
+
+        private PostRequestBuilder(String url, int method) {
+            super(url, method);
+        }
+
+        public Rx2ANRequest build() {
+            return new Rx2ANRequest(this);
+        }
+    }
+
+    public static class PutRequestBuilder extends PostRequestBuilder {
+
+        public PutRequestBuilder(String url) {
+            super(url, Method.PUT);
+        }
+    }
+
+    public static class DeleteRequestBuilder extends PostRequestBuilder {
+
+        public DeleteRequestBuilder(String url) {
+            super(url, Method.DELETE);
+        }
+    }
+
+    public static class PatchRequestBuilder extends PostRequestBuilder {
+
+        public PatchRequestBuilder(String url) {
+            super(url, Method.PATCH);
+        }
+    }
+
+    public static class DynamicRequestBuilder extends PostRequestBuilder {
+
+        public DynamicRequestBuilder(String url, int method) {
+            super(url, method);
+        }
+    }
+
+    public static class DownloadBuilder extends ANRequest.DownloadBuilder<DownloadBuilder> {
+
+        public DownloadBuilder(String url, String dirPath, String fileName) {
+            super(url, dirPath, fileName);
+        }
+
+        public Rx2ANRequest build() {
+            return new Rx2ANRequest(this);
+        }
+    }
+
+    public static class MultiPartBuilder extends ANRequest.MultiPartBuilder<MultiPartBuilder> {
+
+        public MultiPartBuilder(String url) {
+            super(url);
+        }
+
+        public Rx2ANRequest build() {
+            return new Rx2ANRequest(this);
+        }
+    }
+}
diff --git a/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2AndroidNetworking.java b/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2AndroidNetworking.java
new file mode 100644
index 0000000..14a7792
--- /dev/null
+++ b/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2AndroidNetworking.java
@@ -0,0 +1,141 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+/**
+ * Created by amitshekhar on 30/01/17.
+ */
+
+/**
+ * Rx2AndroidNetworking entry point.
+ * You must initialize this class before use. The simplest way is to just do
+ * {#code AndroidNetworking.initialize(context)}.
+ */
+public class Rx2AndroidNetworking {
+
+    /**
+     * private constructor to prevent instantiation of this class
+     */
+    private Rx2AndroidNetworking() {
+    }
+
+    /**
+     * Method to make GET request
+     *
+     * @param url The url on which request is to be made
+     * @return The GetRequestBuilder
+     */
+    public static Rx2ANRequest.GetRequestBuilder get(String url) {
+        return new Rx2ANRequest.GetRequestBuilder(url);
+    }
+
+    /**
+     * Method to make HEAD request
+     *
+     * @param url The url on which request is to be made
+     * @return The HeadRequestBuilder
+     */
+    public static Rx2ANRequest.HeadRequestBuilder head(String url) {
+        return new Rx2ANRequest.HeadRequestBuilder(url);
+    }
+
+    /**
+     * Method to make OPTIONS request
+     *
+     * @param url The url on which request is to be made
+     * @return The OptionsRequestBuilder
+     */
+    public static Rx2ANRequest.OptionsRequestBuilder options(String url) {
+        return new Rx2ANRequest.OptionsRequestBuilder(url);
+    }
+
+    /**
+     * Method to make POST request
+     *
+     * @param url The url on which request is to be made
+     * @return The PostRequestBuilder
+     */
+    public static Rx2ANRequest.PostRequestBuilder post(String url) {
+        return new Rx2ANRequest.PostRequestBuilder(url);
+    }
+
+    /**
+     * Method to make PUT request
+     *
+     * @param url The url on which request is to be made
+     * @return The PutRequestBuilder
+     */
+    public static Rx2ANRequest.PutRequestBuilder put(String url) {
+        return new Rx2ANRequest.PutRequestBuilder(url);
+    }
+
+    /**
+     * Method to make DELETE request
+     *
+     * @param url The url on which request is to be made
+     * @return The DeleteRequestBuilder
+     */
+    public static Rx2ANRequest.DeleteRequestBuilder delete(String url) {
+        return new Rx2ANRequest.DeleteRequestBuilder(url);
+    }
+
+    /**
+     * Method to make PATCH request
+     *
+     * @param url The url on which request is to be made
+     * @return The PatchRequestBuilder
+     */
+    public static Rx2ANRequest.PatchRequestBuilder patch(String url) {
+        return new Rx2ANRequest.PatchRequestBuilder(url);
+    }
+
+    /**
+     * Method to make download request
+     *
+     * @param url      The url on which request is to be made
+     * @param dirPath  The directory path on which file is to be saved
+     * @param fileName The file name with which file is to be saved
+     * @return The DownloadBuilder
+     */
+    public static Rx2ANRequest.DownloadBuilder download(String url, String dirPath, String fileName) {
+        return new Rx2ANRequest.DownloadBuilder(url, dirPath, fileName);
+    }
+
+    /**
+     * Method to make upload request
+     *
+     * @param url The url on which request is to be made
+     * @return The MultiPartBuilder
+     */
+    public static Rx2ANRequest.MultiPartBuilder upload(String url) {
+        return new Rx2ANRequest.MultiPartBuilder(url);
+    }
+
+    /**
+     * Method to make Dynamic request
+     *
+     * @param url    The url on which request is to be made
+     * @param method The HTTP METHOD for the request
+     * @return The DynamicRequestBuilder
+     */
+    public static Rx2ANRequest.DynamicRequestBuilder request(String url, int method) {
+        return new Rx2ANRequest.DynamicRequestBuilder(url, method);
+    }
+}
diff --git a/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2InternalNetworking.java b/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2InternalNetworking.java
new file mode 100644
index 0000000..e33afd3
--- /dev/null
+++ b/rx2-android-networking/src/main/java/com/rx2androidnetworking/Rx2InternalNetworking.java
@@ -0,0 +1,446 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import android.net.TrafficStats;
+
+import com.androidnetworking.common.ANConstants;
+import com.androidnetworking.common.ANResponse;
+import com.androidnetworking.common.ConnectionClassManager;
+import com.androidnetworking.error.ANError;
+import com.androidnetworking.internal.InternalNetworking;
+import com.androidnetworking.internal.RequestProgressBody;
+import com.androidnetworking.internal.ResponseProgressBody;
+import com.androidnetworking.utils.SourceCloseUtil;
+import com.androidnetworking.utils.Utils;
+
+import java.io.File;
+import java.io.IOException;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import okhttp3.Call;
+import okhttp3.Interceptor;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+
+import static com.androidnetworking.common.Method.DELETE;
+import static com.androidnetworking.common.Method.GET;
+import static com.androidnetworking.common.Method.HEAD;
+import static com.androidnetworking.common.Method.OPTIONS;
+import static com.androidnetworking.common.Method.PATCH;
+import static com.androidnetworking.common.Method.POST;
+import static com.androidnetworking.common.Method.PUT;
+
+/**
+ * Created by Prashant Gupta on 30-01-2017.
+ */
+@SuppressWarnings("unchecked")
+public class Rx2InternalNetworking {
+
+    public static <T> Observable<T> generateSimpleObservable(Rx2ANRequest request) {
+        Request okHttpRequest;
+        Request.Builder builder = new Request.Builder().url(request.getUrl());
+        InternalNetworking.addHeadersToRequestBuilder(builder, request);
+        RequestBody requestBody;
+        switch (request.getMethod()) {
+            case GET: {
+                builder = builder.get();
+                break;
+            }
+            case POST: {
+                requestBody = request.getRequestBody();
+                builder = builder.post(requestBody);
+                break;
+            }
+            case PUT: {
+                requestBody = request.getRequestBody();
+                builder = builder.put(requestBody);
+                break;
+            }
+            case DELETE: {
+                requestBody = request.getRequestBody();
+                builder = builder.delete(requestBody);
+                break;
+            }
+            case HEAD: {
+                builder = builder.head();
+                break;
+            }
+            case OPTIONS: {
+                builder = builder.method(ANConstants.OPTIONS, null);
+                break;
+            }
+            case PATCH: {
+                requestBody = request.getRequestBody();
+                builder = builder.patch(requestBody);
+                break;
+            }
+        }
+        if (request.getCacheControl() != null) {
+            builder.cacheControl(request.getCacheControl());
+        }
+        okHttpRequest = builder.build();
+        if (request.getOkHttpClient() != null) {
+            request.setCall(request
+                    .getOkHttpClient()
+                    .newBuilder()
+                    .cache(InternalNetworking.sHttpClient.cache())
+                    .build()
+                    .newCall(okHttpRequest));
+        } else {
+            request.setCall(InternalNetworking.sHttpClient.newCall(okHttpRequest));
+        }
+        return new SimpleANObservable<>(request);
+    }
+
+    public static <T> Observable<T> generateDownloadObservable(final Rx2ANRequest request) {
+        Request okHttpRequest;
+        Request.Builder builder = new Request.Builder().url(request.getUrl());
+        InternalNetworking.addHeadersToRequestBuilder(builder, request);
+        builder = builder.get();
+        if (request.getCacheControl() != null) {
+            builder.cacheControl(request.getCacheControl());
+        }
+        okHttpRequest = builder.build();
+
+        OkHttpClient okHttpClient;
+
+        if (request.getOkHttpClient() != null) {
+            okHttpClient = request
+                    .getOkHttpClient()
+                    .newBuilder()
+                    .cache(InternalNetworking.sHttpClient.cache())
+                    .addNetworkInterceptor(new Interceptor() {
+                        @Override
+                        public Response intercept(Chain chain) throws IOException {
+                            Response originalResponse = chain.proceed(chain.request());
+                            return originalResponse.newBuilder()
+                                    .body(new ResponseProgressBody(originalResponse.body(),
+                                            request.getDownloadProgressListener()))
+                                    .build();
+                        }
+                    }).build();
+        } else {
+            okHttpClient = InternalNetworking.sHttpClient.newBuilder()
+                    .addNetworkInterceptor(new Interceptor() {
+                        @Override
+                        public Response intercept(Chain chain) throws IOException {
+                            Response originalResponse = chain.proceed(chain.request());
+                            return originalResponse.newBuilder()
+                                    .body(new ResponseProgressBody(originalResponse.body(),
+                                            request.getDownloadProgressListener()))
+                                    .build();
+                        }
+                    }).build();
+        }
+        request.setCall(okHttpClient.newCall(okHttpRequest));
+        return new DownloadANObservable<>(request);
+    }
+
+    public static <T> Observable<T> generateMultipartObservable(final Rx2ANRequest request) {
+        return new MultipartANObservable<>(request);
+    }
+
+    static final class SimpleANObservable<T> extends Observable<T> {
+
+        private Rx2ANRequest request;
+        private final Call originalCall;
+
+        SimpleANObservable(Rx2ANRequest request) {
+            this.request = request;
+            this.originalCall = request.getCall();
+        }
+
+        @Override
+        protected void subscribeActual(Observer<? super T> observer) {
+            Call call = originalCall.clone();
+            observer.onSubscribe(new ANDisposable(call));
+            boolean doNotSwallowError = false;
+            Response okHttpResponse = null;
+            try {
+                final long startTime = System.currentTimeMillis();
+                final long startBytes = TrafficStats.getTotalRxBytes();
+                okHttpResponse = call.execute();
+                final long timeTaken = System.currentTimeMillis() - startTime;
+                if (okHttpResponse.cacheResponse() == null) {
+                    final long finalBytes = TrafficStats.getTotalRxBytes();
+                    final long diffBytes;
+                    if (startBytes == TrafficStats.UNSUPPORTED || finalBytes == TrafficStats.UNSUPPORTED) {
+                        diffBytes = okHttpResponse.body().contentLength();
+                    } else {
+                        diffBytes = finalBytes - startBytes;
+                    }
+                    ConnectionClassManager.getInstance().updateBandwidth(diffBytes, timeTaken);
+                    Utils.sendAnalytics(request.getAnalyticsListener(), timeTaken,
+                            (request.getRequestBody() != null &&
+                                    request.getRequestBody().contentLength() != 0) ?
+                                    request.getRequestBody().contentLength() : -1,
+                            okHttpResponse.body().contentLength(), false);
+                } else if (request.getAnalyticsListener() != null) {
+                    if (okHttpResponse.networkResponse() == null) {
+                        Utils.sendAnalytics(request.getAnalyticsListener(), timeTaken, 0, 0, true);
+                    } else {
+                        Utils.sendAnalytics(request.getAnalyticsListener(), timeTaken,
+                                (request.getRequestBody() != null && request.getRequestBody().contentLength() != 0) ?
+                                        request.getRequestBody().contentLength() : -1, 0, true);
+                    }
+                }
+                if (okHttpResponse.code() >= 400) {
+                    if (!call.isCanceled()) {
+                        observer.onError(Utils.getErrorForServerResponse(new ANError(okHttpResponse),
+                                request, okHttpResponse.code()));
+                    }
+                } else {
+                    ANResponse<T> response = request.parseResponse(okHttpResponse);
+                    if (!response.isSuccess()) {
+                        if (!call.isCanceled()) {
+                            observer.onError(response.getError());
+                        }
+                    } else {
+                        if (!call.isCanceled()) {
+                            observer.onNext(response.getResult());
+                        }
+                        if (!call.isCanceled()) {
+                            doNotSwallowError = true;
+                            observer.onComplete();
+                        }
+                    }
+                }
+            } catch (IOException ioe) {
+                if (!call.isCanceled()) {
+                    observer.onError(Utils.getErrorForConnection(new ANError(ioe)));
+                }
+            } catch (Exception e) {
+                Exceptions.throwIfFatal(e);
+                if (doNotSwallowError) {
+                    RxJavaPlugins.onError(e);
+                } else if (!call.isCanceled()) {
+                    try {
+                        observer.onError(Utils.getErrorForConnection(new ANError(e)));
+                    } catch (Exception e1) {
+                        Exceptions.throwIfFatal(e1);
+                        RxJavaPlugins.onError(new CompositeException(e, e1));
+                    }
+                }
+            } finally {
+                SourceCloseUtil.close(okHttpResponse, request);
+            }
+        }
+    }
+
+    static final class DownloadANObservable<T> extends Observable<T> {
+
+        private final Rx2ANRequest request;
+        private final Call originalCall;
+
+        DownloadANObservable(Rx2ANRequest request) {
+            this.request = request;
+            this.originalCall = request.getCall();
+        }
+
+        @Override
+        protected void subscribeActual(Observer<? super T> observer) {
+            Call call = originalCall.clone();
+            observer.onSubscribe(new ANDisposable(call));
+            boolean doNotSwallowError = false;
+            Response okHttpResponse;
+            try {
+                final long startTime = System.currentTimeMillis();
+                final long startBytes = TrafficStats.getTotalRxBytes();
+                okHttpResponse = request.getCall().execute();
+                Utils.saveFile(okHttpResponse, request.getDirPath(), request.getFileName());
+                final long timeTaken = System.currentTimeMillis() - startTime;
+                if (okHttpResponse.cacheResponse() == null) {
+                    final long finalBytes = TrafficStats.getTotalRxBytes();
+                    final long diffBytes;
+                    if (startBytes == TrafficStats.UNSUPPORTED ||
+                            finalBytes == TrafficStats.UNSUPPORTED) {
+                        diffBytes = okHttpResponse.body().contentLength();
+                    } else {
+                        diffBytes = finalBytes - startBytes;
+                    }
+                    ConnectionClassManager.getInstance().updateBandwidth(diffBytes, timeTaken);
+                    Utils.sendAnalytics(request.getAnalyticsListener(),
+                            timeTaken, -1, okHttpResponse.body().contentLength(), false);
+                } else if (request.getAnalyticsListener() != null) {
+                    Utils.sendAnalytics(request.getAnalyticsListener(), timeTaken, -1, 0, true);
+                }
+                if (okHttpResponse.code() >= 400) {
+                    if (!call.isCanceled()) {
+                        observer.onError(Utils.getErrorForServerResponse(new ANError(okHttpResponse),
+                                request, okHttpResponse.code()));
+                    }
+                } else {
+                    if (!call.isCanceled()) {
+                        ANResponse<T> response = (ANResponse<T>) ANResponse.success(ANConstants.SUCCESS);
+                        observer.onNext(response.getResult());
+                    }
+                    if (!call.isCanceled()) {
+                        doNotSwallowError = true;
+                        observer.onComplete();
+                    }
+                }
+            } catch (IOException ioe) {
+                try {
+                    File destinationFile = new File(request.getDirPath() + File.separator + request.getFileName());
+                    if (destinationFile.exists()) {
+                        destinationFile.delete();
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+                if (!call.isCanceled()) {
+                    observer.onError(Utils.getErrorForConnection(new ANError(ioe)));
+                }
+            } catch (Exception e) {
+                Exceptions.throwIfFatal(e);
+                if (doNotSwallowError) {
+                    RxJavaPlugins.onError(e);
+                } else if (!call.isCanceled()) {
+                    try {
+                        observer.onError(Utils.getErrorForConnection(new ANError(e)));
+                    } catch (Exception e1) {
+                        Exceptions.throwIfFatal(e1);
+                        RxJavaPlugins.onError(new CompositeException(e, e1));
+                    }
+                }
+            }
+        }
+    }
+
+    static final class MultipartANObservable<T> extends Observable<T> {
+
+        private final Rx2ANRequest request;
+
+        MultipartANObservable(Rx2ANRequest request) {
+            this.request = request;
+        }
+
+        @Override
+        protected void subscribeActual(Observer<? super T> observer) {
+            boolean doNotSwallowError = false;
+            Response okHttpResponse = null;
+            Request okHttpRequest;
+            try {
+                Request.Builder builder = new Request.Builder().url(request.getUrl());
+                InternalNetworking.addHeadersToRequestBuilder(builder, request);
+                final RequestBody requestBody = request.getMultiPartRequestBody();
+                final long requestBodyLength = requestBody.contentLength();
+                builder = builder.post(new RequestProgressBody(requestBody, request.getUploadProgressListener()));
+                if (request.getCacheControl() != null) {
+                    builder.cacheControl(request.getCacheControl());
+                }
+                okHttpRequest = builder.build();
+                if (request.getOkHttpClient() != null) {
+                    request.setCall(request
+                            .getOkHttpClient()
+                            .newBuilder()
+                            .cache(InternalNetworking.sHttpClient.cache())
+                            .build()
+                            .newCall(okHttpRequest));
+                } else {
+                    request.setCall(InternalNetworking.sHttpClient.newCall(okHttpRequest));
+                }
+                observer.onSubscribe(new ANDisposable(request.getCall()));
+                final long startTime = System.currentTimeMillis();
+                okHttpResponse = request.getCall().execute();
+                final long timeTaken = System.currentTimeMillis() - startTime;
+                if (request.getAnalyticsListener() != null) {
+                    if (okHttpResponse.cacheResponse() == null) {
+                        Utils.sendAnalytics(request.getAnalyticsListener(), timeTaken,
+                                requestBodyLength, okHttpResponse.body().contentLength(), false);
+                    } else {
+                        if (okHttpResponse.networkResponse() == null) {
+                            Utils.sendAnalytics(request.getAnalyticsListener(), timeTaken, 0, 0, true);
+                        } else {
+                            Utils.sendAnalytics(request.getAnalyticsListener(), timeTaken,
+                                    requestBodyLength != 0 ? requestBodyLength : -1, 0, true);
+                        }
+                    }
+                }
+                if (okHttpResponse.code() >= 400) {
+                    if (!request.getCall().isCanceled()) {
+                        observer.onError(Utils.getErrorForServerResponse(new ANError(okHttpResponse),
+                                request, okHttpResponse.code()));
+                    }
+                } else {
+                    ANResponse<T> response = request.parseResponse(okHttpResponse);
+                    if (!response.isSuccess()) {
+                        if (!request.getCall().isCanceled()) {
+                            observer.onError(response.getError());
+                        }
+                    } else {
+                        if (!request.getCall().isCanceled()) {
+                            observer.onNext(response.getResult());
+                        }
+                        if (!request.getCall().isCanceled()) {
+                            doNotSwallowError = true;
+                            observer.onComplete();
+                        }
+                    }
+                }
+            } catch (IOException ioe) {
+                if (!request.getCall().isCanceled()) {
+                    observer.onError(Utils.getErrorForConnection(new ANError(ioe)));
+                }
+            } catch (Exception e) {
+                Exceptions.throwIfFatal(e);
+                if (doNotSwallowError) {
+                    RxJavaPlugins.onError(e);
+                } else if (!request.getCall().isCanceled()) {
+                    try {
+                        observer.onError(Utils.getErrorForConnection(new ANError(e)));
+                    } catch (Exception e1) {
+                        Exceptions.throwIfFatal(e1);
+                        RxJavaPlugins.onError(new CompositeException(e, e1));
+                    }
+                }
+            } finally {
+                SourceCloseUtil.close(okHttpResponse, request);
+            }
+        }
+    }
+
+    private static final class ANDisposable implements Disposable {
+
+        private final Call call;
+
+        private ANDisposable(Call call) {
+            this.call = call;
+        }
+
+        @Override
+        public void dispose() {
+            this.call.cancel();
+        }
+
+        @Override
+        public boolean isDisposed() {
+            return this.call.isCanceled();
+        }
+    }
+}
diff --git a/rx2-android-networking/src/main/res/values/strings.xml b/rx2-android-networking/src/main/res/values/strings.xml
new file mode 100644
index 0000000..c5e2584
--- /dev/null
+++ b/rx2-android-networking/src/main/res/values/strings.xml
@@ -0,0 +1,22 @@
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<resources>
+    <string name="app_name">Rx2AndroidNetworking</string>
+</resources>
diff --git a/rx2-android-networking/src/test/java/com/rx2androidnetworking/ExampleUnitTest.java b/rx2-android-networking/src/test/java/com/rx2androidnetworking/ExampleUnitTest.java
new file mode 100644
index 0000000..a650ac4
--- /dev/null
+++ b/rx2-android-networking/src/test/java/com/rx2androidnetworking/ExampleUnitTest.java
@@ -0,0 +1,36 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2androidnetworking;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
diff --git a/rx2sampleapp/.gitignore b/rx2sampleapp/.gitignore
new file mode 100644
index 0000000..796b96d
--- /dev/null
+++ b/rx2sampleapp/.gitignore
@@ -0,0 +1 @@
+/build
diff --git a/rx2sampleapp/build.gradle b/rx2sampleapp/build.gradle
new file mode 100644
index 0000000..1c38a20
--- /dev/null
+++ b/rx2sampleapp/build.gradle
@@ -0,0 +1,52 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
+
+    defaultConfig {
+        applicationId "com.rx2sampleapp"
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
+        versionCode 1
+        versionName "1.0"
+
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+
+    }
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
+        }
+    }
+}
+
+dependencies {
+    compile fileTree(dir: 'libs', include: ['*.jar'])
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+    })
+    compile "com.android.support:appcompat-v7:$rootProject.ext.supportAppCompatVersion"
+    testCompile "junit:junit:$rootProject.ext.jUnitVersion"
+    compile project(':rx2-android-networking')
+}
diff --git a/rx2sampleapp/proguard-rules.pro b/rx2sampleapp/proguard-rules.pro
new file mode 100644
index 0000000..6b7a2bf
--- /dev/null
+++ b/rx2sampleapp/proguard-rules.pro
@@ -0,0 +1,17 @@
+# Add project specific ProGuard rules here.
+# By default, the flags in this file are appended to flags specified
+# in /Users/amitshekhar/Library/Android/sdk/tools/proguard/proguard-android.txt
+# You can edit the include path and order by changing the proguardFiles
+# directive in build.gradle.
+#
+# For more details, see
+#   http://developer.android.com/guide/developing/tools/proguard.html
+
+# Add any project specific keep options here:
+
+# If your project uses WebView with JS, uncomment the following
+# and specify the fully qualified class name to the JavaScript interface
+# class:
+#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
+#   public *;
+#}
diff --git a/rx2sampleapp/src/androidTest/java/com/rx2sampleapp/ExampleInstrumentedTest.java b/rx2sampleapp/src/androidTest/java/com/rx2sampleapp/ExampleInstrumentedTest.java
new file mode 100644
index 0000000..78d7f40
--- /dev/null
+++ b/rx2sampleapp/src/androidTest/java/com/rx2sampleapp/ExampleInstrumentedTest.java
@@ -0,0 +1,45 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2sampleapp;
+
+import android.content.Context;
+import android.support.test.InstrumentationRegistry;
+import android.support.test.runner.AndroidJUnit4;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import static org.junit.Assert.*;
+
+/**
+ * Instrumentation test, which will execute on an Android device.
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+@RunWith(AndroidJUnit4.class)
+public class ExampleInstrumentedTest {
+    @Test
+    public void useAppContext() throws Exception {
+        // Context of the app under test.
+        Context appContext = InstrumentationRegistry.getTargetContext();
+
+        assertEquals("com.rx2sampleapp", appContext.getPackageName());
+    }
+}
diff --git a/rx2sampleapp/src/main/AndroidManifest.xml b/rx2sampleapp/src/main/AndroidManifest.xml
new file mode 100644
index 0000000..fb83a8c
--- /dev/null
+++ b/rx2sampleapp/src/main/AndroidManifest.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.rx2sampleapp">
+
+    <uses-permission android:name="android.permission.INTERNET" />
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+
+    <application
+        android:name=".Rx2MyApplication"
+        android:allowBackup="true"
+        android:icon="@mipmap/ic_launcher"
+        android:label="@string/app_name"
+        android:supportsRtl="true"
+        android:theme="@style/AppTheme">
+        <activity android:name=".Rx2OperatorExampleActivity">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+        <activity android:name=".Rx2ApiTestActivity"></activity>
+        <activity android:name=".SubscriptionActivity"></activity>
+    </application>
+
+</manifest>
\ No newline at end of file
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/ApiEndPoint.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/ApiEndPoint.java
new file mode 100644
index 0000000..61656ed
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/ApiEndPoint.java
@@ -0,0 +1,32 @@
+/*
+ *    Copyright (C) 2016 Amit Shekhar
+ *    Copyright (C) 2011 Android Open Source Project
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+package com.rx2sampleapp;
+
+/**
+ * Created by amitshekhar on 29/03/16.
+ */
+public class ApiEndPoint {
+
+    public static final String BASE_URL = "https://fierce-cove-29863.herokuapp.com";
+    public static final String GET_JSON_ARRAY = "/getAllUsers/{pageNumber}";
+    public static final String GET_JSON_OBJECT = "/getAnUserDetail/{userId}";
+    public static final String CHECK_FOR_HEADER = "/checkForHeader";
+    public static final String POST_CREATE_AN_USER = "/createAnUser";
+    public static final String UPLOAD_IMAGE = "/uploadImage";
+
+}
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2ApiTestActivity.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2ApiTestActivity.java
new file mode 100644
index 0000000..d6f85ae
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2ApiTestActivity.java
@@ -0,0 +1,486 @@
+/*
+ *    Copyright (C) 2016 Amit Shekhar
+ *    Copyright (C) 2011 Android Open Source Project
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+package com.rx2sampleapp;
+
+import android.graphics.Bitmap;
+import android.os.Bundle;
+import android.os.Environment;
+import android.os.Looper;
+import android.support.annotation.Nullable;
+import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
+import android.view.View;
+import android.widget.ImageView;
+
+import com.androidnetworking.AndroidNetworking;
+import com.androidnetworking.interfaces.AnalyticsListener;
+import com.androidnetworking.interfaces.DownloadProgressListener;
+import com.androidnetworking.interfaces.UploadProgressListener;
+import com.rx2androidnetworking.Rx2ANRequest;
+import com.rx2androidnetworking.Rx2AndroidNetworking;
+import com.rx2sampleapp.model.User;
+import com.rx2sampleapp.utils.Utils;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.util.List;
+
+import io.reactivex.CompletableObserver;
+import io.reactivex.Single;
+import io.reactivex.SingleObserver;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.annotations.NonNull;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.schedulers.Schedulers;
+
+/**
+ * Created by Prashant Gupta on 25-07-2016.
+ */
+public class Rx2ApiTestActivity extends AppCompatActivity {
+
+    private static final String TAG = Rx2ApiTestActivity.class.getSimpleName();
+
+    @Override
+    protected void onCreate(@Nullable Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_rx_api_test);
+    }
+
+    public void getAllUsers(View view) {
+        Rx2AndroidNetworking.get(ApiEndPoint.BASE_URL + ApiEndPoint.GET_JSON_ARRAY)
+                .addPathParameter("pageNumber", "0")
+                .addQueryParameter("limit", "3")
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .getObjectListSingle(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<List<User>>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull List<User> users) {
+                        Log.d(TAG, "onResponse isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                        Log.d(TAG, "userList size : " + users.size());
+                        for (User user : users) {
+                            Log.d(TAG, "id : " + user.id);
+                            Log.d(TAG, "firstname : " + user.firstname);
+                            Log.d(TAG, "lastname : " + user.lastname);
+                        }
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+    public void getAnUser(View view) {
+        Rx2AndroidNetworking.get(ApiEndPoint.BASE_URL + ApiEndPoint.GET_JSON_OBJECT)
+                .addPathParameter("userId", "1")
+                .setUserAgent("getAnUser")
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .getObjectSingle(User.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<User>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull User user) {
+                        Log.d(TAG, "onResponse isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                        Log.d(TAG, "id : " + user.id);
+                        Log.d(TAG, "firstname : " + user.firstname);
+                        Log.d(TAG, "lastname : " + user.lastname);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+    public void checkForHeaderGet(View view) {
+
+        Rx2ANRequest.GetRequestBuilder getRequestBuilder = new Rx2ANRequest.GetRequestBuilder(ApiEndPoint.BASE_URL + ApiEndPoint.CHECK_FOR_HEADER);
+
+        getRequestBuilder.addHeaders("token", "1234")
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .getJSONObjectSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject jsonObject) {
+                        Log.d(TAG, "onResponse object : " + jsonObject.toString());
+                        Log.d(TAG, "onResponse isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+    public void checkForHeaderPost(View view) {
+
+        Rx2ANRequest.PostRequestBuilder postRequestBuilder = Rx2AndroidNetworking.post(ApiEndPoint.BASE_URL + ApiEndPoint.CHECK_FOR_HEADER);
+
+        postRequestBuilder.addHeaders("token", "1234");
+
+        Rx2ANRequest rxAnRequest = postRequestBuilder.setTag(this)
+                .build();
+
+        rxAnRequest.setAnalyticsListener(new AnalyticsListener() {
+            @Override
+            public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                Log.d(TAG, " bytesSent : " + bytesSent);
+                Log.d(TAG, " bytesReceived : " + bytesReceived);
+                Log.d(TAG, " isFromCache : " + isFromCache);
+            }
+        });
+
+        rxAnRequest.getJSONObjectSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject jsonObject) {
+                        Log.d(TAG, "onResponse object : " + jsonObject.toString());
+                        Log.d(TAG, "onResponse isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+    public void createAnUser(View view) {
+        Rx2AndroidNetworking.post(ApiEndPoint.BASE_URL + ApiEndPoint.POST_CREATE_AN_USER)
+                .addBodyParameter("firstname", "Amit")
+                .addBodyParameter("lastname", "Shekhar")
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .getJSONObjectSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject jsonObject) {
+                        Log.d(TAG, "onResponse object : " + jsonObject.toString());
+                        Log.d(TAG, "onResponse isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+    public void createAnUserJSONObject(View view) {
+        JSONObject jsonObject = new JSONObject();
+        try {
+            jsonObject.put("firstname", "Rohit");
+            jsonObject.put("lastname", "Kumar");
+        } catch (JSONException e) {
+            e.printStackTrace();
+        }
+        Rx2AndroidNetworking.post(ApiEndPoint.BASE_URL + ApiEndPoint.POST_CREATE_AN_USER)
+                .addJSONObjectBody(jsonObject)
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .getJSONObjectSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject jsonObject) {
+                        Log.d(TAG, "onResponse object : " + jsonObject.toString());
+                        Log.d(TAG, "onResponse isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+    public void downloadFile(final View view) {
+        String url = "http://www.colorado.edu/conflict/peace/download/peace_problem.ZIP";
+        Rx2AndroidNetworking.download(url, Utils.getRootDirPath(getApplicationContext()), "file1.zip")
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .setDownloadProgressListener(new DownloadProgressListener() {
+                    @Override
+                    public void onProgress(long bytesDownloaded, long totalBytes) {
+                        Log.d(TAG, "bytesDownloaded : " + bytesDownloaded + " totalBytes : " + totalBytes);
+                        Log.d(TAG, "setDownloadProgressListener isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                    }
+                })
+                .getDownloadCompletable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new CompletableObserver() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        Log.d(TAG, "File download Completed");
+                        Log.d(TAG, "onDownloadComplete isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+    public void downloadImage(final View view) {
+        String url = "http://i.imgur.com/AtbX9iX.png";
+        Rx2AndroidNetworking.download(url, Utils.getRootDirPath(getApplicationContext()), "image1.png")
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .getDownloadCompletable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new CompletableObserver() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        Log.d(TAG, "File download Completed");
+                        Log.d(TAG, "onDownloadComplete isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+    public void uploadImage(final View view) {
+        Single<JSONObject> single = Rx2AndroidNetworking.upload(ApiEndPoint.BASE_URL + ApiEndPoint.UPLOAD_IMAGE)
+                .addMultipartFile("image", new File(Environment.getExternalStorageDirectory().getAbsolutePath(), "test.png"))
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .setUploadProgressListener(new UploadProgressListener() {
+                    @Override
+                    public void onProgress(long bytesUploaded, long totalBytes) {
+                        Log.d(TAG, "bytesUploaded : " + bytesUploaded + " totalBytes : " + totalBytes);
+                        Log.d(TAG, "setUploadProgressListener isMainThread : " + String.valueOf(Looper.myLooper() == Looper.getMainLooper()));
+                    }
+                })
+                .getJSONObjectSingle();
+
+        single.subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject jsonObject) {
+                        Log.d(TAG + "_1", "Image upload Completed");
+                        Log.d(TAG + "_1", "onResponse object : " + jsonObject.toString());
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+
+        single.subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<JSONObject>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull JSONObject jsonObject) {
+                        Log.d(TAG + "_2", "Image upload Completed");
+                        Log.d(TAG + "_2", "onResponse object : " + jsonObject.toString());
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+
+    }
+
+    public void getCurrentConnectionQuality(View view) {
+        Log.d(TAG, "getCurrentConnectionQuality : " + AndroidNetworking.getCurrentConnectionQuality() + " currentBandwidth : " + AndroidNetworking.getCurrentBandwidth());
+    }
+
+    public void loadImage(View view) {
+        final String URL_IMAGE = "http://i.imgur.com/2M7Hasn.png";
+        Rx2AndroidNetworking.get(URL_IMAGE)
+                .setImageScaleType(null)
+                .setBitmapMaxHeight(0)
+                .setBitmapMaxWidth(0)
+                .setBitmapConfig(Bitmap.Config.ARGB_8888)
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .getBitmapSingle()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<Bitmap>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull Bitmap bitmap) {
+                        Log.d(TAG, "onResponse Bitmap");
+                        ImageView imageView = findViewById(R.id.imageView);
+                        imageView.setImageBitmap(bitmap);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+
+    }
+
+}
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2MyApplication.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2MyApplication.java
new file mode 100644
index 0000000..e5569bc
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2MyApplication.java
@@ -0,0 +1,49 @@
+/*
+ *    Copyright (C) 2016 Amit Shekhar
+ *    Copyright (C) 2011 Android Open Source Project
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+package com.rx2sampleapp;
+
+import android.app.Application;
+import android.util.Log;
+
+import com.androidnetworking.AndroidNetworking;
+import com.androidnetworking.common.ConnectionQuality;
+import com.androidnetworking.interfaces.ConnectionQualityChangeListener;
+
+public class Rx2MyApplication extends Application {
+
+    private static final String TAG = Rx2MyApplication.class.getSimpleName();
+    private static Rx2MyApplication appInstance = null;
+
+    public static Rx2MyApplication getInstance() {
+        return appInstance;
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        appInstance = this;
+        AndroidNetworking.initialize(getApplicationContext());
+        AndroidNetworking.enableLogging();
+        AndroidNetworking.setConnectionQualityChangeListener(new ConnectionQualityChangeListener() {
+            @Override
+            public void onChange(ConnectionQuality currentConnectionQuality, int currentBandwidth) {
+                Log.d(TAG, "onChange: currentConnectionQuality : " + currentConnectionQuality + " currentBandwidth : " + currentBandwidth);
+            }
+        });
+    }
+
+}
\ No newline at end of file
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2OperatorExampleActivity.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2OperatorExampleActivity.java
new file mode 100644
index 0000000..8dd2101
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/Rx2OperatorExampleActivity.java
@@ -0,0 +1,507 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2sampleapp;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
+import android.util.Pair;
+import android.view.View;
+
+import com.androidnetworking.interfaces.AnalyticsListener;
+import com.rx2androidnetworking.Rx2AndroidNetworking;
+import com.rx2sampleapp.model.ApiUser;
+import com.rx2sampleapp.model.User;
+import com.rx2sampleapp.model.UserDetail;
+import com.rx2sampleapp.utils.Utils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import io.reactivex.Observable;
+import io.reactivex.ObservableSource;
+import io.reactivex.Observer;
+import io.reactivex.Single;
+import io.reactivex.SingleObserver;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.annotations.NonNull;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.functions.BiFunction;
+import io.reactivex.functions.Function;
+import io.reactivex.functions.Predicate;
+import io.reactivex.schedulers.Schedulers;
+
+
+/**
+ * Created by amitshekhar on 30/01/17.
+ */
+public class Rx2OperatorExampleActivity extends AppCompatActivity {
+
+    private static final String TAG = Rx2OperatorExampleActivity.class.getSimpleName();
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_rx_operator_example);
+        testApi();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+    }
+
+    /************************************
+     * Just an test api start
+     ************************************/
+
+    private void testApi() {
+
+        Single<List<User>> single = Rx2AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllUsers/{pageNumber}")
+                .addPathParameter("pageNumber", "0")
+                .addQueryParameter("limit", "3")
+                .build()
+                .setAnalyticsListener(new AnalyticsListener() {
+                    @Override
+                    public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceived, boolean isFromCache) {
+                        Log.d(TAG, " timeTakenInMillis : " + timeTakenInMillis);
+                        Log.d(TAG, " bytesSent : " + bytesSent);
+                        Log.d(TAG, " bytesReceived : " + bytesReceived);
+                        Log.d(TAG, " isFromCache : " + isFromCache);
+                    }
+                })
+                .getObjectListSingle(User.class);
+
+        // first observer
+        single.subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<List<User>>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        Log.d(TAG + "_1", "onSubscribe");
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull List<User> users) {
+                        Log.d(TAG + "_1", "userList size : " + users.size());
+                        for (User user : users) {
+                            Log.d(TAG, "id : " + user.id);
+                            Log.d(TAG, "firstname : " + user.firstname);
+                            Log.d(TAG, "lastname : " + user.lastname);
+                        }
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG + "_1", throwable);
+                    }
+                });
+
+        // second observer
+        single.subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new SingleObserver<List<User>>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+                        Log.d(TAG + "_2", "onSubscribe");
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull List<User> users) {
+                        Log.d(TAG + "_2", "userList size : " + users.size());
+                        for (User user : users) {
+                            Log.d(TAG, "id : " + user.id);
+                            Log.d(TAG, "firstname : " + user.firstname);
+                            Log.d(TAG, "lastname : " + user.lastname);
+                        }
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG + "_2", throwable);
+                    }
+                });
+    }
+
+    /************************************
+     * map operator start
+     ************************************/
+
+    public void map(View view) {
+        Rx2AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAnUser/{userId}")
+                .addPathParameter("userId", "1")
+                .build()
+                .getObjectSingle(ApiUser.class)
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .map(new Function<ApiUser, User>() {
+                    @Override
+                    public User apply(ApiUser apiUser) throws Exception {
+                        // here we get ApiUser from server
+                        User user = new User(apiUser);
+                        // then by converting, we are returning user
+                        return user;
+                    }
+                })
+                .subscribe(new SingleObserver<User>() {
+                    @Override
+                    public void onSubscribe(@NonNull Disposable disposable) {
+
+                    }
+
+                    @Override
+                    public void onSuccess(@NonNull User user) {
+                        Log.d(TAG, "user id : " + user.id);
+                        Log.d(TAG, "user firstname : " + user.firstname);
+                        Log.d(TAG, "user lastname : " + user.lastname);
+                    }
+
+                    @Override
+                    public void onError(@NonNull Throwable throwable) {
+                        Utils.logError(TAG, throwable);
+                    }
+                });
+    }
+
+
+    /************************************
+     * zip operator start
+     *********************************/
+
+    /*
+    * This observable return the list of User who loves cricket
+    */
+    private Observable<List<User>> getCricketFansObservable() {
+        return Rx2AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllCricketFans")
+                .build()
+                .getObjectListObservable(User.class);
+    }
+
+    /*
+    * This observable return the list of User who loves Football
+    */
+    private Observable<List<User>> getFootballFansObservable() {
+        return Rx2AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllFootballFans")
+                .build()
+                .getObjectListObservable(User.class);
+    }
+
+    /*
+    * This do the complete magic, make both network call
+    * and then returns the list of user who loves both
+    * Using zip operator to get both response at a time
+    */
+    private void findUsersWhoLovesBoth() {
+        // here we are using zip operator to combine both request
+        Observable.zip(getCricketFansObservable(), getFootballFansObservable(),
+                new BiFunction<List<User>, List<User>, List<User>>() {
+                    @Override
+                    public List<User> apply(List<User> cricketFans, List<User> footballFans) throws Exception {
+                        List<User> userWhoLovesBoth =
+                                filterUserWhoLovesBoth(cricketFans, footballFans);
+                        return userWhoLovesBoth;
+                    }
+                })
+                .subscribeOn(Schedulers.newThread())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<List<User>>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+
+                    }
+
+                    @Override
+                    public void onNext(List<User> users) {
+                        // do anything with user who loves both
+                        Log.d(TAG, "userList size : " + users.size());
+                        for (User user : users) {
+                            Log.d(TAG, "id : " + user.id);
+                            Log.d(TAG, "firstname : " + user.firstname);
+                            Log.d(TAG, "lastname : " + user.lastname);
+                        }
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        Utils.logError(TAG, e);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        Log.d(TAG, "onComplete");
+                    }
+                });
+    }
+
+    private List<User> filterUserWhoLovesBoth(List<User> cricketFans, List<User> footballFans) {
+        List<User> userWhoLovesBoth = new ArrayList<>();
+        for (User cricketFan : cricketFans) {
+            for (User footballFan : footballFans) {
+                if (cricketFan.id == footballFan.id) {
+                    userWhoLovesBoth.add(cricketFan);
+                }
+            }
+        }
+        return userWhoLovesBoth;
+    }
+
+
+    public void zip(View view) {
+        findUsersWhoLovesBoth();
+    }
+
+    /************************************
+     * flatMap and filter operator start
+     ************************************/
+
+    private Observable<List<User>> getAllMyFriendsObservable() {
+        return Rx2AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllFriends/{userId}")
+                .addPathParameter("userId", "1")
+                .build()
+                .getObjectListObservable(User.class);
+    }
+
+    public void flatMapAndFilter(View view) {
+        getAllMyFriendsObservable()
+                .flatMap(new Function<List<User>, ObservableSource<User>>() { // flatMap - to return users one by one
+                    @Override
+                    public ObservableSource<User> apply(List<User> usersList) throws Exception {
+                        return Observable.fromIterable(usersList); // returning user one by one from usersList.
+                    }
+                })
+                .filter(new Predicate<User>() {
+                    @Override
+                    public boolean test(User user) throws Exception {
+                        // filtering user who follows me.
+                        return user.isFollowing;
+                    }
+                })
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<User>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+
+                    }
+
+                    @Override
+                    public void onNext(User user) {
+                        // only the user who is following me comes here one by one
+                        Log.d(TAG, "user id : " + user.id);
+                        Log.d(TAG, "user firstname : " + user.firstname);
+                        Log.d(TAG, "user lastname : " + user.lastname);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        Utils.logError(TAG, e);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        Log.d(TAG, "onComplete");
+                    }
+                });
+    }
+
+    /************************************
+     * take operator start
+     ************************************/
+
+    public void take(View view) {
+        getUserListObservable()
+                .flatMap(new Function<List<User>, ObservableSource<User>>() { // flatMap - to return users one by one
+                    @Override
+                    public ObservableSource<User> apply(List<User> usersList) throws Exception {
+                        return Observable.fromIterable(usersList); // returning user one by one from usersList.
+                    }
+                })
+                .take(4) // it will only emit first 4 users out of all
+                .subscribeOn(Schedulers.newThread())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<User>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+
+                    }
+
+                    @Override
+                    public void onNext(User user) {
+                        // // only four user comes here one by one
+                        Log.d(TAG, "user id : " + user.id);
+                        Log.d(TAG, "user firstname : " + user.firstname);
+                        Log.d(TAG, "user lastname : " + user.lastname);
+                        Log.d(TAG, "isFollowing : " + user.isFollowing);
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        Utils.logError(TAG, e);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        Log.d(TAG, "onComplete");
+                    }
+                });
+    }
+
+
+    /************************************
+     * flatMap operator start
+     ************************************/
+
+
+    public void flatMap(View view) {
+        getUserListObservable()
+                .flatMap(new Function<List<User>, ObservableSource<User>>() { // flatMap - to return users one by one
+                    @Override
+                    public ObservableSource<User> apply(List<User> usersList) throws Exception {
+                        return Observable.fromIterable(usersList); // returning user one by one from usersList.
+                    }
+                })
+                .flatMap(new Function<User, ObservableSource<UserDetail>>() {
+                    @Override
+                    public ObservableSource<UserDetail> apply(User user) throws Exception {
+                        // here we get the user one by one
+                        // and returns corresponding getUserDetailObservable
+                        // for that userId
+                        return getUserDetailObservable(user.id);
+                    }
+                })
+                .subscribeOn(Schedulers.newThread())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<UserDetail>() {
+                    @Override
+                    public void onSubscribe(Disposable d) {
+
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        Utils.logError(TAG, e);
+                    }
+
+                    @Override
+                    public void onNext(UserDetail userDetail) {
+                        // do anything with userDetail
+                        Log.d(TAG, "userDetail id : " + userDetail.id);
+                        Log.d(TAG, "userDetail firstname : " + userDetail.firstname);
+                        Log.d(TAG, "userDetail lastname : " + userDetail.lastname);
+                    }
+
+                    @Override
+                    public void onComplete() {
+                        Log.d(TAG, "onComplete");
+                    }
+                });
+    }
+
+    /************************************
+     * flatMapWithZip operator start
+     ************************************/
+
+    private Observable<List<User>> getUserListObservable() {
+        return Rx2AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAllUsers/{pageNumber}")
+                .addPathParameter("pageNumber", "0")
+                .addQueryParameter("limit", "10")
+                .build()
+                .getObjectListObservable(User.class);
+    }
+
+    private Observable<UserDetail> getUserDetailObservable(long id) {
+        return Rx2AndroidNetworking.get("https://fierce-cove-29863.herokuapp.com/getAnUserDetail/{userId}")
+                .addPathParameter("userId", String.valueOf(id))
+                .build()
+                .getObjectObservable(UserDetail.class);
+    }
+
+    public void flatMapWithZip(View view) {
+        getUserListObservable()
+                .flatMap(new Function<List<User>, ObservableSource<User>>() { // flatMap - to return users one by one
+                    @Override
+                    public ObservableSource<User> apply(List<User> usersList) throws Exception {
+                        return Observable.fromIterable(usersList); // returning user one by one from usersList.
+                    }
+                })
+                .flatMap(new Function<User, ObservableSource<Pair<UserDetail, User>>>() {
+                    @Override
+                    public ObservableSource<Pair<UserDetail, User>> apply(User user) throws Exception {
+                        // here we get the user one by one and then we are zipping
+                        // two observable - one getUserDetailObservable (network call to get userDetail)
+                        // and another Observable.just(user) - just to emit user
+                        return Observable.zip(getUserDetailObservable(user.id),
+                                Observable.just(user),
+                                new BiFunction<UserDetail, User, Pair<UserDetail, User>>() {
+                                    @Override
+                                    public Pair<UserDetail, User> apply(UserDetail userDetail, User user) throws Exception {
+                                        // runs when network call completes
+                                        // we get here userDetail for the corresponding user
+                                        return new Pair<>(userDetail, user); // returning the pair(userDetail, user)
+                                    }
+                                });
+                    }
+                })
+                .subscribeOn(Schedulers.newThread())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribe(new Observer<Pair<UserDetail, User>>() {
+                    @Override
+                    public void onComplete() {
+                        // do something onCompleted
+                        Log.d(TAG, "onComplete");
+                    }
+
+                    @Override
+                    public void onError(Throwable e) {
+                        // handle error
+                        Utils.logError(TAG, e);
+                    }
+
+                    @Override
+                    public void onSubscribe(Disposable d) {
+
+                    }
+
+                    @Override
+                    public void onNext(Pair<UserDetail, User> pair) {
+                        // here we are getting the userDetail for the corresponding user one by one
+                        UserDetail userDetail = pair.first;
+                        User user = pair.second;
+                        Log.d(TAG, "userId : " + user.id);
+                        Log.d(TAG, "userDetail firstname : " + userDetail.firstname);
+                        Log.d(TAG, "userDetail lastname : " + userDetail.lastname);
+                    }
+                });
+    }
+
+    /************************************
+     * others start here
+     ************************************/
+
+    public void startRxApiTestActivity(View view) {
+        startActivity(new Intent(Rx2OperatorExampleActivity.this, Rx2ApiTestActivity.class));
+    }
+
+    public void startSubscriptionActivity(View view) {
+        startActivity(new Intent(Rx2OperatorExampleActivity.this, SubscriptionActivity.class));
+    }
+
+}
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/SubscriptionActivity.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/SubscriptionActivity.java
new file mode 100644
index 0000000..c109a17
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/SubscriptionActivity.java
@@ -0,0 +1,90 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2sampleapp;
+
+import android.os.Bundle;
+import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
+import android.view.View;
+
+import com.rx2androidnetworking.Rx2AndroidNetworking;
+import com.rx2sampleapp.utils.Utils;
+
+import io.reactivex.Completable;
+import io.reactivex.android.schedulers.AndroidSchedulers;
+import io.reactivex.annotations.NonNull;
+import io.reactivex.disposables.CompositeDisposable;
+import io.reactivex.observers.DisposableCompletableObserver;
+import io.reactivex.schedulers.Schedulers;
+
+
+/**
+ * Created by amitshekhar on 31/07/16.
+ */
+public class SubscriptionActivity extends AppCompatActivity {
+
+    private static final String TAG = SubscriptionActivity.class.getSimpleName();
+    private static final String URL = "http://i.imgur.com/AtbX9iX.png";
+    private String dirPath;
+    private String fileName = "imgurimage.png";
+    private final CompositeDisposable disposables = new CompositeDisposable();
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.activity_subscription);
+        dirPath = Utils.getRootDirPath(getApplicationContext());
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        disposables.clear();
+    }
+
+    public Completable getCompletable() {
+        return Rx2AndroidNetworking.download(URL, dirPath, fileName)
+                .build()
+                .getDownloadCompletable();
+    }
+
+    private DisposableCompletableObserver getDisposableObserver() {
+
+        return new DisposableCompletableObserver() {
+            @Override
+            public void onComplete() {
+                Log.d(TAG, "onCompleted");
+            }
+
+            @Override
+            public void onError(@NonNull Throwable throwable) {
+                Log.d(TAG, "onError " + throwable.getMessage());
+            }
+        };
+
+    }
+
+    public void downloadFile(View view) {
+        disposables.add(getCompletable()
+                .subscribeOn(Schedulers.io())
+                .observeOn(AndroidSchedulers.mainThread())
+                .subscribeWith(getDisposableObserver()));
+    }
+}
\ No newline at end of file
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/model/ApiUser.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/model/ApiUser.java
new file mode 100644
index 0000000..b8e94f8
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/model/ApiUser.java
@@ -0,0 +1,29 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2sampleapp.model;
+
+/**
+ * Created by amitshekhar on 02/08/16.
+ */
+public class ApiUser {
+    public long id;
+    public String firstname;
+    public String lastname;
+}
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/model/User.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/model/User.java
new file mode 100644
index 0000000..8f601d7
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/model/User.java
@@ -0,0 +1,36 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2sampleapp.model;
+
+/**
+ * Created by amitshekhar on 31/07/16.
+ */
+public class User {
+    public long id;
+    public String firstname;
+    public String lastname;
+    public boolean isFollowing;
+
+    public User(ApiUser apiUser) {
+        this.id = apiUser.id;
+        this.firstname = apiUser.firstname;
+        this.lastname = apiUser.lastname;
+    }
+}
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/model/UserDetail.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/model/UserDetail.java
new file mode 100644
index 0000000..0b6fbdf
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/model/UserDetail.java
@@ -0,0 +1,31 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2sampleapp.model;
+
+/**
+ * Created by amitshekhar on 02/08/16.
+ */
+public class UserDetail {
+
+    public long id;
+    public String firstname;
+    public String lastname;
+
+}
diff --git a/rx2sampleapp/src/main/java/com/rx2sampleapp/utils/Utils.java b/rx2sampleapp/src/main/java/com/rx2sampleapp/utils/Utils.java
new file mode 100644
index 0000000..a984730
--- /dev/null
+++ b/rx2sampleapp/src/main/java/com/rx2sampleapp/utils/Utils.java
@@ -0,0 +1,62 @@
+/*
+ *    Copyright (C) 2016 Amit Shekhar
+ *    Copyright (C) 2011 Android Open Source Project
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+package com.rx2sampleapp.utils;
+
+import android.content.Context;
+import android.os.Environment;
+import android.support.v4.content.ContextCompat;
+import android.util.Log;
+
+import com.androidnetworking.error.ANError;
+
+import java.io.File;
+
+/**
+ * Created by Prashant Gupta on 29-07-2016.
+ */
+public class Utils {
+
+    public static String getRootDirPath(Context context) {
+        if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
+            File file = ContextCompat.getExternalFilesDirs(context.getApplicationContext(), null)[0];
+            return file.getAbsolutePath();
+        } else {
+            return context.getApplicationContext().getFilesDir().getAbsolutePath();
+        }
+    }
+
+    public static void logError(String TAG, Throwable e) {
+        if (e instanceof ANError) {
+            ANError anError = (ANError) e;
+            if (anError.getErrorCode() != 0) {
+                // received ANError from server
+                // error.getErrorCode() - the ANError code from server
+                // error.getErrorBody() - the ANError body from server
+                // error.getErrorDetail() - just a ANError detail
+                Log.d(TAG, "onError errorCode : " + anError.getErrorCode());
+                Log.d(TAG, "onError errorBody : " + anError.getErrorBody());
+                Log.d(TAG, "onError errorDetail : " + anError.getErrorDetail());
+            } else {
+                // error.getErrorDetail() : connectionError, parseError, requestCancelledError
+                Log.d(TAG, "onError errorDetail : " + anError.getErrorDetail());
+            }
+        } else {
+            Log.d(TAG, "onError errorMessage : " + e.getMessage());
+        }
+    }
+
+}
diff --git a/rx2sampleapp/src/main/res/layout/activity_rx_api_test.xml b/rx2sampleapp/src/main/res/layout/activity_rx_api_test.xml
new file mode 100644
index 0000000..90b35c0
--- /dev/null
+++ b/rx2sampleapp/src/main/res/layout/activity_rx_api_test.xml
@@ -0,0 +1,177 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~    Copyright (C) 2016 Amit Shekhar
+  ~    Copyright (C) 2011 Android Open Source Project
+  ~
+  ~    Licensed under the Apache License, Version 2.0 (the "License");
+  ~    you may not use this file except in compliance with the License.
+  ~    You may obtain a copy of the License at
+  ~
+  ~        http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~    Unless required by applicable law or agreed to in writing, software
+  ~    distributed under the License is distributed on an "AS IS" BASIS,
+  ~    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~    See the License for the specific language governing permissions and
+  ~    limitations under the License.
+  -->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical"
+        android:paddingBottom="@dimen/activity_vertical_margin"
+        android:paddingLeft="@dimen/activity_horizontal_margin"
+        android:paddingRight="@dimen/activity_horizontal_margin"
+        android:paddingTop="@dimen/activity_vertical_margin">
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/getAllUsers"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="getAllUsers"
+            android:text="/getAllUsers/{pageNumber}" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/getAnUser"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="getAnUser"
+            android:text="/getAnUser/{userId}" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/checkForHeaderGet"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="checkForHeaderGet"
+            android:text="GET : checkForHeader" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/checkForHeaderPost"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="checkForHeaderPost"
+            android:text="POST : checkForHeader" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/createAnUser"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="createAnUser"
+            android:text="/createAnUser" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/createAnUserJSONObject"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="createAnUserJSONObject"
+            android:text="/createAnUserJSONObject" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/downloadFile"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="downloadFile"
+            android:text="downloadFile" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/downloadImage"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="downloadImage"
+            android:text="downloadImage" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/uploadImage"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="uploadImage"
+            android:text="uploadImage" />
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/getCurrentConnectionQuality"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="getCurrentConnectionQuality"
+            android:text="getCurrentConnectionQuality" />
+
+        <Button
+            android:id="@+id/loadImage"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="loadImage"
+            android:text="loadImage" />
+
+        <ImageView
+            android:id="@+id/imageView"
+            android:layout_width="200dp"
+            android:layout_height="200dp"
+            android:layout_gravity="center" />
+
+    </LinearLayout>
+
+</ScrollView>
\ No newline at end of file
diff --git a/rx2sampleapp/src/main/res/layout/activity_rx_operator_example.xml b/rx2sampleapp/src/main/res/layout/activity_rx_operator_example.xml
new file mode 100644
index 0000000..1fce022
--- /dev/null
+++ b/rx2sampleapp/src/main/res/layout/activity_rx_operator_example.xml
@@ -0,0 +1,100 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical"
+        android:paddingBottom="@dimen/activity_vertical_margin"
+        android:paddingLeft="@dimen/activity_horizontal_margin"
+        android:paddingRight="@dimen/activity_horizontal_margin"
+        android:paddingTop="@dimen/activity_vertical_margin">
+
+        <Button
+            android:id="@+id/map"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="map"
+            android:text="map" />
+
+        <Button
+            android:id="@+id/zip"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="zip"
+            android:text="zip" />
+
+        <Button
+            android:id="@+id/flatMapAndFilter"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="flatMapAndFilter"
+            android:text="flatMapAndFilter" />
+
+        <Button
+            android:id="@+id/take"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="take"
+            android:text="take" />
+
+        <Button
+            android:id="@+id/flatMap"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="flatMap"
+            android:text="flatMap" />
+
+        <Button
+            android:id="@+id/flatMapWithZip"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="flatMapWithZip"
+            android:text="flatMapWithZip" />
+
+        <Button
+            android:id="@+id/startRxApiTestActivity"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="startRxApiTestActivity"
+            android:text="startRxApiTestActivity" />
+
+        <Button
+            android:id="@+id/startSubscriptionActivity"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="startSubscriptionActivity"
+            android:text="startSubscriptionActivity" />
+
+
+    </LinearLayout>
+
+</ScrollView>
\ No newline at end of file
diff --git a/rx2sampleapp/src/main/res/layout/activity_subscription.xml b/rx2sampleapp/src/main/res/layout/activity_subscription.xml
new file mode 100644
index 0000000..72baf50
--- /dev/null
+++ b/rx2sampleapp/src/main/res/layout/activity_subscription.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?><!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical"
+        android:paddingBottom="@dimen/activity_vertical_margin"
+        android:paddingLeft="@dimen/activity_horizontal_margin"
+        android:paddingRight="@dimen/activity_horizontal_margin"
+        android:paddingTop="@dimen/activity_vertical_margin">
+
+        <ProgressBar
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center" />
+
+        <Button
+            android:id="@+id/downloadFile"
+            android:layout_width="match_parent"
+            android:layout_height="48dp"
+            android:layout_margin="8dp"
+            android:onClick="downloadFile"
+            android:text="downloadFile" />
+
+
+    </LinearLayout>
+
+</ScrollView>
\ No newline at end of file
diff --git a/rx2sampleapp/src/main/res/mipmap-hdpi/ic_launcher.png b/rx2sampleapp/src/main/res/mipmap-hdpi/ic_launcher.png
new file mode 100644
index 0000000..cde69bc
Binary files /dev/null and b/rx2sampleapp/src/main/res/mipmap-hdpi/ic_launcher.png differ
diff --git a/rx2sampleapp/src/main/res/mipmap-mdpi/ic_launcher.png b/rx2sampleapp/src/main/res/mipmap-mdpi/ic_launcher.png
new file mode 100644
index 0000000..c133a0c
Binary files /dev/null and b/rx2sampleapp/src/main/res/mipmap-mdpi/ic_launcher.png differ
diff --git a/rx2sampleapp/src/main/res/mipmap-xhdpi/ic_launcher.png b/rx2sampleapp/src/main/res/mipmap-xhdpi/ic_launcher.png
new file mode 100644
index 0000000..bfa42f0
Binary files /dev/null and b/rx2sampleapp/src/main/res/mipmap-xhdpi/ic_launcher.png differ
diff --git a/rx2sampleapp/src/main/res/mipmap-xxhdpi/ic_launcher.png b/rx2sampleapp/src/main/res/mipmap-xxhdpi/ic_launcher.png
new file mode 100644
index 0000000..324e72c
Binary files /dev/null and b/rx2sampleapp/src/main/res/mipmap-xxhdpi/ic_launcher.png differ
diff --git a/rx2sampleapp/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/rx2sampleapp/src/main/res/mipmap-xxxhdpi/ic_launcher.png
new file mode 100644
index 0000000..aee44e1
Binary files /dev/null and b/rx2sampleapp/src/main/res/mipmap-xxxhdpi/ic_launcher.png differ
diff --git a/rx2sampleapp/src/main/res/values-w820dp/dimens.xml b/rx2sampleapp/src/main/res/values-w820dp/dimens.xml
new file mode 100644
index 0000000..c92595c
--- /dev/null
+++ b/rx2sampleapp/src/main/res/values-w820dp/dimens.xml
@@ -0,0 +1,25 @@
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<resources>
+    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
+         (such as screen margins) for screens with more than 820dp of available width. This
+         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
+    <dimen name="activity_horizontal_margin">64dp</dimen>
+</resources>
diff --git a/rx2sampleapp/src/main/res/values/colors.xml b/rx2sampleapp/src/main/res/values/colors.xml
new file mode 100644
index 0000000..cda449d
--- /dev/null
+++ b/rx2sampleapp/src/main/res/values/colors.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<resources>
+    <color name="colorPrimary">#3F51B5</color>
+    <color name="colorPrimaryDark">#303F9F</color>
+    <color name="colorAccent">#FF4081</color>
+</resources>
diff --git a/rx2sampleapp/src/main/res/values/dimens.xml b/rx2sampleapp/src/main/res/values/dimens.xml
new file mode 100644
index 0000000..2553694
--- /dev/null
+++ b/rx2sampleapp/src/main/res/values/dimens.xml
@@ -0,0 +1,24 @@
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<resources>
+    <!-- Default screen margins, per the Android Design guidelines. -->
+    <dimen name="activity_horizontal_margin">16dp</dimen>
+    <dimen name="activity_vertical_margin">16dp</dimen>
+</resources>
diff --git a/rx2sampleapp/src/main/res/values/strings.xml b/rx2sampleapp/src/main/res/values/strings.xml
new file mode 100644
index 0000000..e0caa16
--- /dev/null
+++ b/rx2sampleapp/src/main/res/values/strings.xml
@@ -0,0 +1,22 @@
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<resources>
+    <string name="app_name">Rx2SampleApp</string>
+</resources>
diff --git a/rx2sampleapp/src/main/res/values/styles.xml b/rx2sampleapp/src/main/res/values/styles.xml
new file mode 100644
index 0000000..2e82b5e
--- /dev/null
+++ b/rx2sampleapp/src/main/res/values/styles.xml
@@ -0,0 +1,30 @@
+<!--
+  ~ /*
+  ~  *    Copyright (C) 2016 Amit Shekhar
+  ~  *    Copyright (C) 2011 Android Open Source Project
+  ~  *
+  ~  *    Licensed under the Apache License, Version 2.0 (the "License");
+  ~  *    you may not use this file except in compliance with the License.
+  ~  *    You may obtain a copy of the License at
+  ~  *
+  ~  *        http://www.apache.org/licenses/LICENSE-2.0
+  ~  *
+  ~  *    Unless required by applicable law or agreed to in writing, software
+  ~  *    distributed under the License is distributed on an "AS IS" BASIS,
+  ~  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  *    See the License for the specific language governing permissions and
+  ~  *    limitations under the License.
+  ~  */
+  -->
+
+<resources>
+
+    <!-- Base application theme. -->
+    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
+        <!-- Customize your theme here. -->
+        <item name="colorPrimary">@color/colorPrimary</item>
+        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
+        <item name="colorAccent">@color/colorAccent</item>
+    </style>
+
+</resources>
diff --git a/rx2sampleapp/src/test/java/com/rx2sampleapp/ExampleUnitTest.java b/rx2sampleapp/src/test/java/com/rx2sampleapp/ExampleUnitTest.java
new file mode 100644
index 0000000..52cbac2
--- /dev/null
+++ b/rx2sampleapp/src/test/java/com/rx2sampleapp/ExampleUnitTest.java
@@ -0,0 +1,36 @@
+/*
+ *
+ *  *    Copyright (C) 2016 Amit Shekhar
+ *  *    Copyright (C) 2011 Android Open Source Project
+ *  *
+ *  *    Licensed under the Apache License, Version 2.0 (the "License");
+ *  *    you may not use this file except in compliance with the License.
+ *  *    You may obtain a copy of the License at
+ *  *
+ *  *        http://www.apache.org/licenses/LICENSE-2.0
+ *  *
+ *  *    Unless required by applicable law or agreed to in writing, software
+ *  *    distributed under the License is distributed on an "AS IS" BASIS,
+ *  *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  *    See the License for the specific language governing permissions and
+ *  *    limitations under the License.
+ *
+ */
+
+package com.rx2sampleapp;
+
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+/**
+ * Example local unit test, which will execute on the development machine (host).
+ *
+ * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
+ */
+public class ExampleUnitTest {
+    @Test
+    public void addition_isCorrect() throws Exception {
+        assertEquals(4, 2 + 2);
+    }
+}
\ No newline at end of file
diff --git a/rxsampleapp/build.gradle b/rxsampleapp/build.gradle
index b6856c7..9a99639 100644
--- a/rxsampleapp/build.gradle
+++ b/rxsampleapp/build.gradle
@@ -18,13 +18,13 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 23
-    buildToolsVersion "23.0.3"
+    compileSdkVersion rootProject.ext.compileSdkVersion
+    buildToolsVersion rootProject.ext.buildToolsVersion
 
     defaultConfig {
         applicationId "com.rxsampleapp"
-        minSdkVersion 14
-        targetSdkVersion 23
+        minSdkVersion rootProject.ext.minSdkVersion
+        targetSdkVersion rootProject.ext.targetSdkVersion
         versionCode 1
         versionName "1.0"
     }
@@ -38,9 +38,7 @@ android {
 
 dependencies {
     compile fileTree(dir: 'libs', include: ['*.jar'])
-    testCompile 'junit:junit:4.12'
-    compile 'com.android.support:appcompat-v7:23.4.0'
+    testCompile "junit:junit:$rootProject.ext.jUnitVersion"
+    compile "com.android.support:appcompat-v7:$rootProject.ext.supportAppCompatVersion"
     compile project(':rx-android-networking')
-    compile 'com.facebook.stetho:stetho:1.3.1'
-    compile 'com.facebook.stetho:stetho-okhttp3:1.3.1'
 }
diff --git a/rxsampleapp/src/main/AndroidManifest.xml b/rxsampleapp/src/main/AndroidManifest.xml
index b6ce004..0d85f83 100644
--- a/rxsampleapp/src/main/AndroidManifest.xml
+++ b/rxsampleapp/src/main/AndroidManifest.xml
@@ -19,7 +19,7 @@
     package="com.rxsampleapp">
 
     <uses-permission android:name="android.permission.INTERNET" />
-    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"></uses-permission>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
 
     <application
         android:name=".RxMyApplication"
@@ -35,7 +35,6 @@
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
-        RxApiTestActivity
         <activity android:name=".RxApiTestActivity"></activity>
         <activity android:name=".SubscriptionActivity"></activity>
     </application>
diff --git a/rxsampleapp/src/main/java/com/rxsampleapp/RxApiTestActivity.java b/rxsampleapp/src/main/java/com/rxsampleapp/RxApiTestActivity.java
index 527f0b1..b34746d 100644
--- a/rxsampleapp/src/main/java/com/rxsampleapp/RxApiTestActivity.java
+++ b/rxsampleapp/src/main/java/com/rxsampleapp/RxApiTestActivity.java
@@ -16,7 +16,6 @@
  */
 package com.rxsampleapp;
 
-import android.content.Intent;
 import android.graphics.Bitmap;
 import android.os.Bundle;
 import android.os.Environment;
@@ -32,7 +31,6 @@
 import com.androidnetworking.interfaces.AnalyticsListener;
 import com.androidnetworking.interfaces.DownloadProgressListener;
 import com.androidnetworking.interfaces.UploadProgressListener;
-import com.google.gson.reflect.TypeToken;
 import com.rxandroidnetworking.RxANRequest;
 import com.rxandroidnetworking.RxAndroidNetworking;
 import com.rxsampleapp.model.User;
@@ -76,8 +74,7 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
                         Log.d(TAG, " isFromCache : " + isFromCache);
                     }
                 })
-                .getParseObservable(new TypeToken<List<User>>() {
-                })
+                .getObjectListObservable(User.class)
                 .subscribeOn(Schedulers.io())
                 .observeOn(AndroidSchedulers.mainThread())
                 .subscribe(new Observer<List<User>>() {
@@ -118,8 +115,7 @@ public void onReceived(long timeTakenInMillis, long bytesSent, long bytesReceive
                         Log.d(TAG, " isFromCache : " + isFromCache);
                     }
                 })
-                .getParseObservable(new TypeToken<User>() {
-                })
+                .getObjectObservable(User.class)
                 .subscribeOn(Schedulers.io())
                 .observeOn(AndroidSchedulers.mainThread())
                 .subscribe(new Observer<User>() {
diff --git a/rxsampleapp/src/main/java/com/rxsampleapp/RxMyApplication.java b/rxsampleapp/src/main/java/com/rxsampleapp/RxMyApplication.java
index 1bc8dbc..1a0d20c 100644
--- a/rxsampleapp/src/main/java/com/rxsampleapp/RxMyApplication.java
+++ b/rxsampleapp/src/main/java/com/rxsampleapp/RxMyApplication.java
@@ -36,13 +36,6 @@ public static RxMyApplication getInstance() {
     public void onCreate() {
         super.onCreate();
         appInstance = this;
-        //For testing purpose only: network interceptor : enable it only for non-images request checking
-//        Stetho.initializeWithDefaults(getApplicationContext());
-//        OkHttpClient okHttpClient = new OkHttpClient().newBuilder().addNetworkInterceptor(new StethoInterceptor()).addInterceptor(new GzipRequestInterceptor()).build();
-//        OkHttpClient okHttpClient = new OkHttpClient().newBuilder()
-//                .addInterceptor(new GzipRequestInterceptor())
-//                .build();
-//        AndroidNetworking.initialize(getApplicationContext(), okHttpClient);
         AndroidNetworking.initialize(getApplicationContext());
         AndroidNetworking.enableLogging();
         AndroidNetworking.setConnectionQualityChangeListener(new ConnectionQualityChangeListener() {
diff --git a/rxsampleapp/src/main/java/com/rxsampleapp/RxOperatorExampleActivity.java b/rxsampleapp/src/main/java/com/rxsampleapp/RxOperatorExampleActivity.java
index 1c41217..99c620c 100644
--- a/rxsampleapp/src/main/java/com/rxsampleapp/RxOperatorExampleActivity.java
+++ b/rxsampleapp/src/main/java/com/rxsampleapp/RxOperatorExampleActivity.java
@@ -125,7 +125,7 @@ public void map(View view) {
                     public User call(ApiUser apiUser) {
                         // here we get ApiUser from server
                         User user = new User(apiUser);
-                        // then by converting, we are returing user
+                        // then by converting, we are returning user
                         return user;
                     }
                 })
diff --git a/settings.gradle b/settings.gradle
index 5cdaaf9..0ab0659 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -15,4 +15,4 @@
  *    limitations under the License.
  */
 
-include ':app', ':android-networking', ':rx-android-networking', ':rxsampleapp', ':jackson-android-networking'
+include ':app', ':android-networking', ':rx-android-networking', ':rxsampleapp', ':jackson-android-networking', ':rx2-android-networking', ':rx2sampleapp'
