diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index a8d9c049..a880c423 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -120,11 +120,13 @@
     private final ArrayList<Region> rangedRegions = new ArrayList<Region>();
     private final List<BeaconParser> beaconParsers = new CopyOnWriteArrayList<>();
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+    private boolean mRegionStatePersistenceEnabled = true;
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
     private boolean mMainProcess = false;
     private Boolean mScannerInSameProcess = null;
 
+
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
 
@@ -228,6 +230,7 @@ public void setBackgroundBetweenScanPeriod(long p) {
      */
     public static void setRegionExitPeriod(long regionExitPeriod){
         sExitRegionPeriod = regionExitPeriod;
+
     }
     
     /**
@@ -610,11 +613,15 @@ public void setRegionStatePeristenceEnabled(boolean enabled) {
      * @param enabled true to enable the region state persistence, false to disable it.
      */
     public void setRegionStatePersistenceEnabled(boolean enabled) {
-        if (enabled) {
-            MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
-        } else {
-            MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+        mRegionStatePersistenceEnabled = enabled;
+        if (isScannerInSameProcess()) {
+            if (enabled) {
+                MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
+            } else {
+                MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+            }
         }
+        this.applySettings();
     }
 
     /**
@@ -622,7 +629,7 @@ public void setRegionStatePersistenceEnabled(boolean enabled) {
      * @return
      */
     public boolean isRegionStatePersistenceEnabled() {
-        return MonitoringStatus.getInstanceForApplication(mContext).isStatePreservationOn();
+        return mRegionStatePersistenceEnabled;
     }
 
     /**
@@ -767,6 +774,9 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
         Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
         msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
+        if (!isScannerInSameProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
+        }
         this.requestStateForRegion(region);
     }
 
@@ -793,6 +803,9 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
         Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
         msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
+        if (!isScannerInSameProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
+        }
     }
 
 
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index f7264f84..279ca886 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -52,31 +52,12 @@ public MonitoringStatus(Context context) {
     }
 
     public synchronized void addRegion(Region region, Callback callback) {
-        if (getRegionsStateMap().containsKey(region)) {
-            // if the region definition hasn't changed, becasue if it has, we need to clear state
-            // otherwise a region with the same uniqueId can never be changed
-            for (Region existingRegion : getRegionsStateMap().keySet()) {
-                if (existingRegion.equals(region)) {
-                    if (existingRegion.hasSameIdentifiers(region)) {
-                        return;
-                    }
-                    else {
-                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
-                        LogManager.d(TAG, "Old definition: "+existingRegion);
-                        LogManager.d(TAG, "New definition: "+region);
-                        LogManager.d(TAG, "clearing state");
-                        getRegionsStateMap().remove(region);
-                        break;
-                    }
-                }
-            }
-        }
-        getRegionsStateMap().put(region, new RegionMonitoringState(callback));
+        addLocalRegion(region, callback);
         saveMonitoringStatusIfOn();
     }
 
     public synchronized void removeRegion(Region region) {
-        getRegionsStateMap().remove(region);
+        removeLocalRegion(region);
         saveMonitoringStatusIfOn();
     }
 
@@ -294,4 +275,34 @@ public void updateLocalState(Region region, Integer state) {
         }
     }
 
+    public void removeLocalRegion(Region region) {
+        getRegionsStateMap().remove(region);
+    }
+    public void addLocalRegion(Region region){
+        Callback dummyCallback = new Callback(null);
+        addLocalRegion(region, dummyCallback);
+    }
+
+    private void addLocalRegion(Region region, Callback callback){
+        if (getRegionsStateMap().containsKey(region)) {
+            // if the region definition hasn't changed, becasue if it has, we need to clear state
+            // otherwise a region with the same uniqueId can never be changed
+            for (Region existingRegion : getRegionsStateMap().keySet()) {
+                if (existingRegion.equals(region)) {
+                    if (existingRegion.hasSameIdentifiers(region)) {
+                        return;
+                    }
+                    else {
+                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
+                        LogManager.d(TAG, "Old definition: "+existingRegion);
+                        LogManager.d(TAG, "New definition: "+region);
+                        LogManager.d(TAG, "clearing state");
+                        getRegionsStateMap().remove(region);
+                        break;
+                    }
+                }
+            }
+        }
+        getRegionsStateMap().put(region, new RegionMonitoringState(callback));
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/SettingsData.java b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
index a5cd5e48..dcb34ca5 100644
--- a/src/main/java/org/altbeacon/beacon/service/SettingsData.java
+++ b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
@@ -79,7 +79,15 @@ public void apply(BeaconService scanService) {
         else {
             LogManager.d(TAG, "Beacon parsers unchanged.");
         }
-        beaconManager.setRegionStatePersistenceEnabled(mRegionStatePersistenceEnabled);
+        MonitoringStatus monitoringStatus = MonitoringStatus.getInstanceForApplication(scanService);
+        if (monitoringStatus.isStatePreservationOn() &&
+                !mRegionStatePersistenceEnabled) {
+            monitoringStatus.stopStatusPreservation();
+        }
+        else if (!monitoringStatus.isStatePreservationOn() &&
+                mRegionStatePersistenceEnabled) {
+            monitoringStatus.startStatusPreservation();
+        }
         beaconManager.setAndroidLScanningDisabled(mAndroidLScanningDisabled);
         BeaconManager.setRegionExitPeriod(mRegionExitPeriod);
         RangeState.setUseTrackingCache(mUseTrackingCache);
