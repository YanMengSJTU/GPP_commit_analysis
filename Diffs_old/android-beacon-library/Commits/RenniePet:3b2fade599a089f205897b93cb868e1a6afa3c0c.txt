diff --git a/src/main/java/org/altbeacon/beacon/AltBeacon.java b/src/main/java/org/altbeacon/beacon/AltBeacon.java
index 5a43621c..891829e8 100644
--- a/src/main/java/org/altbeacon/beacon/AltBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/AltBeacon.java
@@ -35,8 +35,8 @@
  * access to the #mfgReserved field.</p>
  *
  * <p>An <code>AltBeacon</code> is identified by a unique three part identifier.  The first
- * identifier Id1 is normally used across an organization, the second identifer Id2 is used to
- * group beacons and the third identifer Id3 is used to uniquely identify a specific beacon (in
+ * identifier Id1 is normally used across an organization, the second identifier Id2 is used to
+ * group beacons and the third identifier Id3 is used to uniquely identify a specific beacon (in
  * combination with the other two identifiers.)
  *
  * @author  David G. Young
diff --git a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
index 95e58f03..2e9fcdd2 100644
--- a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
@@ -46,11 +46,11 @@ public AltBeaconParser() {
     }
     /**
      * Construct an AltBeacon from a Bluetooth LE packet collected by Android's Bluetooth APIs,
-     * including the raw bluetooth device info
+     * including the raw Bluetooth device info
      *
      * @param scanData The actual packet bytes
      * @param rssi The measured signal strength of the packet
-     * @param device The bluetooth device that was detected
+     * @param device The Bluetooth device that was detected
      * @return An instance of an <code>Beacon</code>
      */
     @TargetApi(5)
@@ -59,6 +59,4 @@ public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
         return fromScanData(scanData, rssi, device, new AltBeacon());
     }
 
-
-
 }
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index f4484a23..7944ae9f 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -101,7 +101,7 @@
     protected int mTxPower;
 
     /**
-     * The bluetooth mac address
+     * The Bluetooth mac address
      */
     protected String mBluetoothAddress;
 
@@ -140,7 +140,7 @@
     protected int mServiceUuid;
 
     /**
-     * The bluetooth device name.  This is a field transmitted by the remote beacon device separate
+     * The Bluetooth device name.  This is a field transmitted by the remote beacon device separate
      * from the advertisement data
      */
     protected String mBluetoothName;
@@ -358,7 +358,7 @@ public void setExtraDataFields(List<Long> fields) {
 
 
     /**
-     * Provides a calcualted estimate of the distance to the beacon based on a running average of
+     * Provides a calculated estimate of the distance to the beacon based on a running average of
      * the RSSI and the transmitted power calibration value included in the beacon advertisement.
      * This value is specific to the type of Android device receiving the transmission.
      *
diff --git a/src/main/java/org/altbeacon/beacon/BeaconConsumer.java b/src/main/java/org/altbeacon/beacon/BeaconConsumer.java
index e4403451..2746a5bc 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconConsumer.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconConsumer.java
@@ -80,10 +80,10 @@
  *
  */
 public interface BeaconConsumer {
+
     /**
      * Called when the beacon service is running and ready to accept your commands through the BeaconManager
      */
-
     public void onBeaconServiceConnect();
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 9b818f52..69e789ee 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -55,7 +55,7 @@
 import java.util.concurrent.ConcurrentMap;
 
 /**
- * An class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
+ * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
  * when the <code>BeaconService</code> is ready to use.  Until this callback is made, ranging and monitoring
  * of beacons is not possible.
@@ -141,19 +141,19 @@ public static void setDebug(boolean debug) {
     }
 
     /**
-     * The default duration in milliseconds of the bluetooth scan cycle
+     * The default duration in milliseconds of the Bluetooth scan cycle
      */
     public static final long DEFAULT_FOREGROUND_SCAN_PERIOD = 1100;
     /**
-     * The default duration in milliseconds spent not scanning between each bluetooth scan cycle
+     * The default duration in milliseconds spent not scanning between each Bluetooth scan cycle
      */
     public static final long DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD = 0;
     /**
-     * The default duration in milliseconds of the bluetooth scan cycle when no ranging/monitoring clients are in the foreground
+     * The default duration in milliseconds of the Bluetooth scan cycle when no ranging/monitoring clients are in the foreground
      */
     public static final long DEFAULT_BACKGROUND_SCAN_PERIOD = 10000;
     /**
-     * The default duration in milliseconds spent not scanning between each bluetooth scan cycle when no ranging/monitoring clients are in the foreground
+     * The default duration in milliseconds spent not scanning between each Bluetooth scan cycle when no ranging/monitoring clients are in the foreground
      */
     public static final long DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD = 5 * 60 * 1000;
 
@@ -164,7 +164,7 @@ public static void setDebug(boolean debug) {
 
     /**
      * Sets the duration in milliseconds of each Bluetooth LE scan cycle to look for beacons.
-     * This function is used to setup the period before calling {@link #bind}  or when switching
+     * This function is used to setup the period before calling {@link #bind} or when switching
      * between background/foreground. To have it effect on an already running scan (when the next
      * cycle starts), call {@link #updateScanPeriods}
      *
@@ -176,7 +176,7 @@ public void setForegroundScanPeriod(long p) {
 
     /**
      * Sets the duration in milliseconds between each Bluetooth LE scan cycle to look for beacons.
-     * This function is used to setup the period before calling {@link #bind}  or when switching
+     * This function is used to setup the period before calling {@link #bind} or when switching
      * between background/foreground. To have it effect on an already running scan (when the next
      * cycle starts), call {@link #updateScanPeriods}
      *
@@ -188,7 +188,7 @@ public void setForegroundBetweenScanPeriod(long p) {
 
     /**
      * Sets the duration in milliseconds of each Bluetooth LE scan cycle to look for beacons.
-     * This function is used to setup the period before calling {@link #bind}  or when switching
+     * This function is used to setup the period before calling {@link #bind} or when switching
      * between background/foreground. To have it effect on an already running scan (when the next
      * cycle starts), call {@link #updateScanPeriods}
      *
@@ -264,14 +264,14 @@ public boolean checkAvailability() throws BleNotAvailableException {
 
     /**
      * Binds an Android <code>Activity</code> or <code>Service</code> to the <code>BeaconService</code>.  The
-     * <code>Activity</code> or <code>Service</code> must implement the <code>beaconConsuemr</code> interface so
+     * <code>Activity</code> or <code>Service</code> must implement the <code>beaconConsumer</code> interface so
      * that it can get a callback when the service is ready to use.
      *
      * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
      */
     public void bind(BeaconConsumer consumer) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
         synchronized (consumers) {
@@ -296,7 +296,7 @@ public void bind(BeaconConsumer consumer) {
      */
     public void unbind(BeaconConsumer consumer) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
         synchronized (consumers) {
@@ -365,7 +365,7 @@ public boolean isAnyConsumerBound() {
      */
     public void setBackgroundMode(boolean backgroundMode) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
         }
         mBackgroundModeUninitialized = false;
         if (backgroundMode != mBackgroundMode) {
@@ -433,7 +433,7 @@ public void setMonitorNotifier(MonitorNotifier notifier) {
     @TargetApi(18)
     public void startRangingBeaconsInRegion(Region region) throws RemoteException {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
         if (serviceMessenger == null) {
@@ -461,7 +461,7 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
     @TargetApi(18)
     public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
         if (serviceMessenger == null) {
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index 3bbbac77..415e23c3 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -239,7 +239,7 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
         if (!mExtraFrame) {
             // extra frames do not have to have identifiers or power fields, but other types do
             if (mIdentifierStartOffsets.size() == 0 || mIdentifierEndOffsets.size() == 0) {
-                throw new BeaconLayoutException("You must supply at least one identifier offset withh a prefix of 'i'");
+                throw new BeaconLayoutException("You must supply at least one identifier offset with a prefix of 'i'");
             }
             if (mPowerStartOffset == null || mPowerEndOffset == null) {
                 throw new BeaconLayoutException("You must supply a power byte offset with a prefix of 'p'");
@@ -252,10 +252,10 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
     }
 
     /**
-     * Returns a list of bluetooth manufactuer codes which will be used for hardware-assisted
+     * Returns a list of Bluetooth manufacturer codes which will be used for hardware-assisted
      * accelerated looking for this beacon type
      *
-     * The possible codes are defined onthis list:
+     * The possible codes are defined on this list:
      * https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers
      *
      * @return manufacturers
@@ -265,10 +265,10 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
     }
 
     /**
-     * Sets a list of bluetooth manufactuer codes which will be used for hardware-assisted
+     * Sets a list of Bluetooth manufacturer codes which will be used for hardware-assisted
      * accelerated looking for this beacon type
      *
-     * The possible codes are defined onthis list:
+     * The possible codes are defined on this list:
      * https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers
      *
      */
@@ -328,11 +328,11 @@ public int getServiceUuidEndOffset() {
 
     /**
      * Construct a Beacon from a Bluetooth LE packet collected by Android's Bluetooth APIs,
-     * including the raw bluetooth device info
+     * including the raw Bluetooth device info
      *
      * @param scanData The actual packet bytes
      * @param rssi The measured signal strength of the packet
-     * @param device The bluetooth device that was detected
+     * @param device The Bluetooth device that was detected
      * @return An instance of a <code>Beacon</code>
      */
     @TargetApi(5)
diff --git a/src/main/java/org/altbeacon/beacon/BleNotAvailableException.java b/src/main/java/org/altbeacon/beacon/BleNotAvailableException.java
index 670123f1..4cf316e1 100644
--- a/src/main/java/org/altbeacon/beacon/BleNotAvailableException.java
+++ b/src/main/java/org/altbeacon/beacon/BleNotAvailableException.java
@@ -24,7 +24,7 @@
 package org.altbeacon.beacon;
 
 /**
- * Indicates that low energy bluetooth is not available on this device
+ * Indicates that Bluetooth Low Energy is not available on this device
  * @see BeaconManager#checkAvailability
  * @author David G. Young
  *
diff --git a/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java b/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
index 032fd97f..d934a428 100644
--- a/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
+++ b/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
@@ -69,7 +69,7 @@ public void setManufacturer(String mManufacturer) {
 
     /**
      * Calculates a qualitative match score between two different Android device models for the
-     * purposes of how likely they are to have similar bluetooth signal level responses
+     * purposes of how likely they are to have similar Bluetooth signal level responses
      * @param otherModel
      * @return match quality, higher numbers are a better match
      */
diff --git a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
index 655d620a..3f53af52 100644
--- a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
+++ b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
@@ -25,7 +25,7 @@
 
 /**
  * Obtains a <code>DistanceCalculator</code> appropriate for a specific Android model.  Each model
- * may have a different bluetooth chipset, radio and antenna and sees a different signal level
+ * may have a different Bluetooth chipset, radio and antenna and sees a different signal level
  * at the same distance, therefore requiring a different equation coefficients for each model.
  *
  * This class uses a configuration table to look for a matching Android device model for which
diff --git a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
index 5db9a87c..697c9dc5 100644
--- a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
+++ b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
@@ -30,7 +30,7 @@
      */
     public BackgroundPowerSaver(Context context, boolean countActiveActivityStrategy) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "BackgroundPowerSaver requires SDK 18 or higher.");
+            LogManager.w(TAG, "BackgroundPowerSaver requires API 18 or higher.");
             return;
         }
         if (context instanceof Application ) {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 7ff4d6a0..bd1fb918 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -159,7 +159,7 @@ public void stop() {
     protected void scanLeDevice(final Boolean enable) {
         mScanCyclerStarted = true;
         if (getBluetoothAdapter() == null) {
-            LogManager.e(TAG, "No bluetooth adapter.  beaconService cannot scan.");
+            LogManager.e(TAG, "No Bluetooth adapter.  beaconService cannot scan.");
         }
         if (enable) {
             if (deferScanIfNeeded()) {
@@ -197,7 +197,7 @@ protected void scanLeDevice(final Boolean enable) {
                         }
                     }
                 } catch (Exception e) {
-                    LogManager.e(e, TAG, "Exception starting bluetooth scan.  Perhaps bluetooth is disabled or unavailable?");
+                    LogManager.e(e, TAG, "Exception starting Bluetooth scan.  Perhaps Bluetooth is disabled or unavailable?");
                 }
             } else {
                 LogManager.d(TAG, "We are already scanning");
@@ -268,7 +268,6 @@ private void finishScanCycle() {
         }
     }
 
-
     protected BluetoothAdapter getBluetoothAdapter() {
         if (mBluetoothAdapter == null) {
             // Initializes Bluetooth adapter.
@@ -296,26 +295,37 @@ protected void setWakeUpAlarm() {
         if (milliseconds < mScanPeriod) {
             milliseconds = mScanPeriod;
         }
+
         AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
-        Intent intent = new Intent();
-        intent.setClassName(mContext, StartupBroadcastReceiver.class.getName());
-        intent.putExtra("wakeup", true);
-        cancelWakeUpAlarm();
-        mWakeUpOperation = PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);
-        alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, System.currentTimeMillis() + milliseconds, mWakeUpOperation);
-        LogManager.d(TAG, "Set a wakeup alarm to go off in %s ms: %s", milliseconds, mWakeUpOperation);
+        alarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + milliseconds, getWakeUpOperation());
+        LogManager.d(TAG, "Set a wakeup alarm to go off in %s ms: %s", milliseconds, getWakeUpOperation());
+    }
+
+    protected PendingIntent getWakeUpOperation() {
+        if (mWakeUpOperation == null) {
+            Intent wakeupIntent = new Intent();
+            //intent.setFlags(Intent.FLAG_UPDATE_CURRENT);
+            wakeupIntent.setClassName(mContext, StartupBroadcastReceiver.class.getName());
+            wakeupIntent.putExtra("wakeup", true);
+            mWakeUpOperation = PendingIntent.getBroadcast(mContext, 0, wakeupIntent, PendingIntent.FLAG_UPDATE_CURRENT);
+        }
+        return mWakeUpOperation;
     }
 
     protected void cancelWakeUpAlarm() {
         LogManager.d(TAG, "cancel wakeup alarm: %s", mWakeUpOperation);
-        if (mWakeUpOperation != null) {
-            AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
-            alarmManager.cancel(mWakeUpOperation);
-        }
+        // We actually don't cancel the wakup alarm... we just reschedule for a long time in the
+        // future.  This is to get around a limit on 500 alarms you can start per app on Samsung
+        // devices.
+        long milliseconds = Long.MAX_VALUE; // 2.9 million years from now
+        AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
+        alarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + milliseconds, getWakeUpOperation());
+        LogManager.d(TAG, "Set a wakeup alarm to go off in %s ms: %s", milliseconds, getWakeUpOperation());
+
     }
 
     private long getNextScanStartTime() {
-        // Because many apps may use this library on the same device, we want to try to synchonize
+        // Because many apps may use this library on the same device, we want to try to synchronize
         // scanning as much as possible in order to save battery.  Therefore, we will set the scan
         // intervals to be on a predictable interval using a modulus of the system time.  This may
         // cause scans to start a little earlier than otherwise, but it should be acceptable.
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
index bacfc829..062d2269 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
@@ -36,11 +36,11 @@ protected void stopScan() {
     protected boolean deferScanIfNeeded() {
         long millisecondsUntilStart = mNextScanCycleStartTime - (new Date().getTime());
         if (millisecondsUntilStart > 0) {
-            LogManager.d(TAG, "Waiting to start next bluetooth scan for another %s milliseconds",
+            LogManager.d(TAG, "Waiting to start next Bluetooth scan for another %s milliseconds",
                     millisecondsUntilStart);
-            // Don't actually wait until the next scan time -- only wait up to 1 second.  this
+            // Don't actually wait until the next scan time -- only wait up to 1 second.  This
             // allows us to start scanning sooner if a consumer enters the foreground and expects
-            // results more quickly
+            // results more quickly.
             if (mBackgroundFlag) {
                 setWakeUpAlarm();
             }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index ee1f9d5b..e47f6b57 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -1,6 +1,7 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.annotation.TargetApi;
+import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.le.BluetoothLeScanner;
 import android.bluetooth.le.ScanCallback;
 import android.bluetooth.le.ScanFilter;
@@ -51,7 +52,7 @@ protected void stopScan() {
          Otherwise:
            - create hardware masks for any beacon regardless of identifiers
            - look for these hardware masks, and if you get one, report the detection
-      when calculating the time to the next scan cycle, male it be on the seconds modulus of the between scan period plus the scan period
+      when calculating the time to the next scan cycle, make it be on the seconds modulus of the between scan period plus the scan period
       This is an improvement over the current state, but the disadvantages are:
          - If a somebody else's beacon is present and yours is not yet visible when the app is in
            the background, you won't get the accelerated discovery.  You only get the accelerated
@@ -141,11 +142,11 @@ protected boolean deferScanIfNeeded() {
                     }
                 }
             }
-            LogManager.d(TAG, "Waiting to start full bluetooth scan for another %s milliseconds",
+            LogManager.d(TAG, "Waiting to start full Bluetooth scan for another %s milliseconds",
                     millisecondsUntilStart);
-            // Don't actually wait until the next scan time -- only wait up to 1 second.  this
+            // Don't actually wait until the next scan time -- only wait up to 1 second.  This
             // allows us to start scanning sooner if a consumer enters the foreground and expects
-            // results more quickly
+            // results more quickly.
             if (mScanDeferredBefore == false && mBackgroundFlag) {
                 setWakeUpAlarm();
             }
@@ -216,7 +217,10 @@ protected void finishScan() {
     private BluetoothLeScanner getScanner() {
         if (mScanner == null) {
             LogManager.d(TAG, "Making new Android L scanner");
-            mScanner = getBluetoothAdapter().getBluetoothLeScanner();
+            BluetoothAdapter bluetoothAdapter = getBluetoothAdapter();
+            if (bluetoothAdapter != null) {
+                mScanner = getBluetoothAdapter().getBluetoothLeScanner();
+            }
             if (mScanner == null) {
                 LogManager.w(TAG, "Failed to make new Android L scanner");
             }
diff --git a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
index 2d00b0c3..93eefda9 100644
--- a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
+++ b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
@@ -17,7 +17,7 @@
     public void onReceive(Context context, Intent intent) {
         LogManager.d(TAG, "onReceive called in startup broadcast receiver");
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not starting up beacon service because we do not have SDK version 18 (Android 4.3).  We have: %s", android.os.Build.VERSION.SDK_INT);
+            LogManager.w(TAG, "Not starting up beacon service because we do not have API version 18 (Android 4.3).  We have: %s", android.os.Build.VERSION.SDK_INT);
             return;
         }
         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context.getApplicationContext());
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
index dafa5aae..018cda70 100644
--- a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
@@ -44,7 +44,7 @@
     private static final String TAG = "BluetoothCrashResolver";
     private static final boolean PREEMPTIVE_ACTION_ENABLED = true;
     /**
-     * This is not the same file that bluedroid uses.  This is just to maintain state of this module
+     * This is not the same file that Bluedroid uses.  This is just to maintain state of this module
      */
     private static final String DISTINCT_BLUETOOTH_ADDRESSES_FILE = "BluetoothCrashResolverState.txt";
     private boolean recoveryInProgress = false;
@@ -72,7 +72,7 @@
      //  84.7% (3060) < 500 ms
      // So we will assume any power off sequence of < 600ms to be a crash
      //
-     // While it is possible to manually turn bluetooth off then back on in
+     // While it is possible to manually turn Bluetooth off then back on in
      // about 600ms, but it is pretty hard to do.
      //
      */
@@ -158,7 +158,7 @@ public void disableDebug() { }
     /**
      * Call this method from your BluetoothAdapter.LeScanCallback method.
      * Doing so is optional, but if you do, this class will be able to count the number of
-     * disctinct bluetooth devices scanned, and prevent crashes before they happen.
+     * distinct Bluetooth devices scanned, and prevent crashes before they happen.
      *
      * This works very well if the app containing this class is the only one running bluetooth
      * LE scans on the device, or it is constantly doing scans (e.g. is in the foreground for
@@ -185,11 +185,11 @@ public void notifyScannedDevice(BluetoothDevice device, BluetoothAdapter.LeScanC
 
         newSize = distinctBluetoothAddresses.size();
         if (oldSize != newSize && newSize % 100 == 0) {
-            LogManager.d(TAG, "Distinct bluetooth devices seen: %s", distinctBluetoothAddresses.size());
+            LogManager.d(TAG, "Distinct Bluetooth devices seen: %s", distinctBluetoothAddresses.size());
         }
         if (distinctBluetoothAddresses.size()  > getCrashRiskDeviceCount()) {
             if (PREEMPTIVE_ACTION_ENABLED && !recoveryInProgress) {
-                LogManager.w(TAG, "Large number of bluetooth devices detected: %s Proactively "
+                LogManager.w(TAG, "Large number of Bluetooth devices detected: %s Proactively "
                         + "attempting to clear out address list to prevent a crash",
                         distinctBluetoothAddresses.size());
                 LogManager.w(TAG, "Stopping LE Scan");
@@ -202,12 +202,12 @@ public void notifyScannedDevice(BluetoothDevice device, BluetoothAdapter.LeScanC
 
     public void crashDetected() {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.d(TAG, "Ignoring crashes before SDK 18, because BLE is unsupported.");
+            LogManager.d(TAG, "Ignoring crashes before API 18, because BLE is unsupported.");
             return;
         }
         LogManager.w(TAG, "BluetoothService crash detected");
         if (distinctBluetoothAddresses.size() > 0) {
-            LogManager.d(TAG, "Distinct bluetooth devices seen at crash: %s",
+            LogManager.d(TAG, "Distinct Bluetooth devices seen at crash: %s",
                     distinctBluetoothAddresses.size());
         }
         long nowTimestamp = new Date().getTime();
@@ -215,7 +215,7 @@ public void crashDetected() {
         detectedCrashCount++;
 
         if (recoveryInProgress) {
-            LogManager.d(TAG, "Ignoring bluetooth crash because recovery is already in progress.");
+            LogManager.d(TAG, "Ignoring Bluetooth crash because recovery is already in progress.");
         }
         else {
             startRecovery();
@@ -256,9 +256,9 @@ public void forceFlush() {
 
     private int getCrashRiskDeviceCount() {
         // 1990 distinct devices tracked by Bluedroid will cause a crash.  But we don't know how many
-        // devices bluedroid is tracking, we only know how many we have seen, which will be smaller
-        // than the number tracked by bluedroid because the number we track does not include its
-        // initial state.  We therefore assume that there are some devices being tracked by bluedroid
+        // devices Bluedroid is tracking, we only know how many we have seen, which will be smaller
+        // than the number tracked by Bluedroid because the number we track does not include its
+        // initial state.  We therefore assume that there are some devices being tracked by Bluedroid
         // after a recovery operation or on startup
         return BLUEDROID_MAX_BLUETOOTH_MAC_COUNT-BLUEDROID_POST_DISCOVERY_ESTIMATED_BLUETOOTH_MAC_COUNT;
     }
@@ -274,7 +274,7 @@ private void processStateChange() {
 
     @TargetApi(17)
     private void startRecovery() {
-        // The discovery operation will start by clearing out the bluetooth mac list to only the 256
+        // The discovery operation will start by clearing out the Bluetooth mac list to only the 256
         // most recently seen BLE mac addresses.
         recoveryAttemptCount++;
         BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
@@ -285,7 +285,7 @@ private void startRecovery() {
             discoveryStartConfirmed = false;
             LogManager.d(TAG, "about to command discovery");
             if (!adapter.startDiscovery()) {
-                LogManager.w(TAG, "Can't start discovery.  Is bluetooth turned on?");
+                LogManager.w(TAG, "Can't start discovery.  Is Bluetooth turned on?");
             }
             LogManager.d(TAG, "startDiscovery commanded.  isDiscovering()=%s", adapter.isDiscovering());
             // We don't actually need to do a discovery -- we just need to kick one off so the
@@ -394,7 +394,7 @@ private void saveState() {
                 } catch (IOException e1) { }
             }
         }
-        LogManager.d(TAG, "Wrote %s bluetooth addresses", distinctBluetoothAddresses.size());
+        LogManager.d(TAG, "Wrote %s Bluetooth addresses", distinctBluetoothAddresses.size());
 
     }
 
@@ -443,7 +443,7 @@ private void loadState() {
                 } catch (IOException e1) { }
             }
         }
-        LogManager.d(TAG, "Read %s bluetooth addresses", distinctBluetoothAddresses.size());
+        LogManager.d(TAG, "Read %s Bluetooth addresses", distinctBluetoothAddresses.size());
     }
 
     private void cancelDiscovery() {
