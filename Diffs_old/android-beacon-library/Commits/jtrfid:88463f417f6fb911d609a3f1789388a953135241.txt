diff --git a/README.md b/README.md
index 6f288a95..6c5fe13f 100644
--- a/README.md
+++ b/README.md
@@ -92,19 +92,19 @@ The following instructions are for project administrators.
 
 2. Configure your  ~/.gradle/gradle.properties with:
 
-    signing.keyId=<my key id>
-    signing.password=<my passphrase>
-    signing.secretKeyRingFile=~/.gnupg/secring.gpg
-    signingPassword=<my passphrase>
-
-    bintrayUserName=<bintray username>
-    bintrayKey=<bintray api key>
+        signing.keyId=<my key id>
+        signing.password=<my passphrase>
+        signing.secretKeyRingFile=~/.gnupg/secring.gpg
+        signingPassword=<my passphrase>
+        
+        bintrayUserName=<bintray username>
+        bintrayKey=<bintray api key>
 
 3. Run the build and upload
 
-   git tag <version>
-   git push --tags 
-   ./gradlew release -Prelease
-   ./gradlew bintrayUpload -Prelease
+        git tag <version>
+        git push --tags 
+        ./gradlew release -Prelease
+        ./gradlew bintrayUpload -Prelease
 
 4. Log in to JCenter, hit the button to publish the release, then select the Maven tab and enter your credentials to Sync to Maven
diff --git a/build.gradle b/build.gradle
index 5d137ee9..13645e73 100644
--- a/build.gradle
+++ b/build.gradle
@@ -28,7 +28,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.2.3'
+        classpath 'com.android.tools.build:gradle:1.3.0'
         classpath 'com.jakewharton.sdkmanager:gradle-plugin:0.12.0'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3'
@@ -50,12 +50,12 @@ allprojects {
 }
 
 android {
-    compileSdkVersion 21
-    buildToolsVersion "21.1.2"
+    compileSdkVersion 23
+    buildToolsVersion "23"
 
     defaultConfig {
         minSdkVersion 7
-        targetSdkVersion 21
+        targetSdkVersion 23
         versionCode 1
         versionName version
         testInstrumentationRunner "com.google.android.apps.common.testing.testrunner.GoogleInstrumentationTestRunner"
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index bd9c66be..2c31d988 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -5,6 +5,7 @@
     <uses-permission android:name="android.permission.BLUETOOTH"/>
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+    <uses-permission-sdk-23 android:name="android.permission.ACCESS_COARSE_LOCATION"/>
 
     <application>
         <receiver android:name="org.altbeacon.beacon.startup.StartupBroadcastReceiver">
diff --git a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
index 1d6b4917..a700d07e 100644
--- a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
@@ -51,7 +51,7 @@ public AltBeaconParser() {
         // manufacturer code not in this list is used for AltBeacons, phones using Andoroid 5.x+
         // detection APIs will not be able to detect the beacon in the background.
         mHardwareAssistManufacturers = new int[]{0x0118};
-        this.setBeaconLayout("m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25");
+        this.setBeaconLayout(BeaconParser.ALTBEACON_LAYOUT);
     }
     /**
      * Construct an AltBeacon from a Bluetooth LE packet collected by Android's Bluetooth APIs,
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index 6b94a2fc..8a277734 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -572,7 +572,7 @@ protected static Double calculateDistance(int txPower, double bestRssiAvailable)
      * </pre>
      */
     public static class Builder {
-        protected Beacon mBeacon;
+        protected final Beacon mBeacon;
         private Identifier mId1, mId2, mId3;
 
         /**
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index fa057341..33dcaf86 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -38,6 +38,7 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
 import org.altbeacon.beacon.service.BeaconService;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.service.RangeState;
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
@@ -53,6 +54,7 @@
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
@@ -113,7 +115,8 @@
     protected MonitorNotifier monitorNotifier = null;
     private final ArrayList<Region> monitoredRegions = new ArrayList<Region>();
     private final ArrayList<Region> rangedRegions = new ArrayList<Region>();
-    private final ArrayList<BeaconParser> beaconParsers = new ArrayList<BeaconParser>();
+    private final List<BeaconParser> beaconParsers = new CopyOnWriteArrayList<>();
+    private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
 
@@ -156,6 +159,12 @@ public static void setDebug(boolean debug) {
      * The default duration in milliseconds spent not scanning between each Bluetooth scan cycle when no ranging/monitoring clients are in the foreground
      */
     public static final long DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD = 5 * 60 * 1000;
+    /**
+     * The default duration in milliseconds of region exit time
+     */
+    public static final long DEFAULT_EXIT_PERIOD = 10000L;
+
+    private static long sExitRegionPeriod = DEFAULT_EXIT_PERIOD;
 
     private long foregroundScanPeriod = DEFAULT_FOREGROUND_SCAN_PERIOD;
     private long foregroundBetweenScanPeriod = DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD;
@@ -207,6 +216,24 @@ public void setBackgroundBetweenScanPeriod(long p) {
         backgroundBetweenScanPeriod = p;
     }
 
+    /**
+     * Set region exit period in milliseconds
+     *
+     * @param regionExitPeriod
+     */
+    public static void setRegionExitPeriod(long regionExitPeriod){
+        sExitRegionPeriod = regionExitPeriod;
+    }
+    
+    /**
+     * Get region exit milliseconds
+     *
+     * @return exit region period in milliseconds
+     */
+    public static long getRegionExitPeriod(){
+        return sExitRegionPeriod;
+    }
+
     /**
      * An accessor for the singleton instance of this class.  A context must be provided, but if you need to use it from a non-Activity
      * or non-Service class, you can attach it to another singleton or a subclass of the Android Application class.
@@ -228,15 +255,11 @@ protected BeaconManager(Context context) {
    }
 
    /**
-     * Gets a list of the active beaconParsers.  This list may only be modified before any consumers
-     * are bound to the beacon service
+     * Gets a list of the active beaconParsers.
      *
      * @return list of active BeaconParsers
      */
     public List<BeaconParser> getBeaconParsers() {
-        if (isAnyConsumerBound()) {
-            return Collections.unmodifiableList(beaconParsers);
-        }
         return beaconParsers;
     }
 
@@ -725,6 +748,14 @@ protected RangeNotifier getDataRequestNotifier() {
         return this.dataRequestNotifier;
     }
 
+    public NonBeaconLeScanCallback getNonBeaconLeScanCallback() {
+        return mNonBeaconLeScanCallback;
+    }
+
+    public void setNonBeaconLeScanCallback(NonBeaconLeScanCallback callback) {
+        mNonBeaconLeScanCallback = callback;
+    }
+
     private class ConsumerInfo {
         public boolean isConnected = false;
     }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index 90c60644..827d315c 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -38,6 +38,10 @@
  */
 public class BeaconParser {
     private static final String TAG = "BeaconParser";
+    public static final String ALTBEACON_LAYOUT = "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25";
+    public static final String EDDYSTONE_TLM_LAYOUT = "x,s:0-1=feaa,m:2-2=20,d:3-3,d:4-5,d:6-7,d:8-11,d:12-15";
+    public static final String EDDYSTONE_UID_LAYOUT = "s:0-1=feaa,m:2-2=00,p:3-3:-41,i:4-13,i:14-19";
+    public static final String EDDYSTONE_URL_LAYOUT = "s:0-1=feaa,m:2-2=10,p:3-3:-41,i:4-20v";
     private static final Pattern I_PATTERN = Pattern.compile("i\\:(\\d+)\\-(\\d+)([blv]*)?");
     private static final Pattern M_PATTERN = Pattern.compile("m\\:(\\d+)-(\\d+)\\=([0-9A-Fa-f]+)");
     private static final Pattern S_PATTERN = Pattern.compile("s\\:(\\d+)-(\\d+)\\=([0-9A-Fa-f]+)");
@@ -45,17 +49,17 @@
     private static final Pattern P_PATTERN = Pattern.compile("p\\:(\\d+)\\-(\\d+)\\:?([\\-\\d]+)?");
     private static final Pattern X_PATTERN = Pattern.compile("x");
     private static final char[] HEX_ARRAY = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
-    private static String LITTLE_ENDIAN_SUFFIX = "l";
-    private static String VARIABLE_LENGTH_SUFFIX = "v";
+    private static final String LITTLE_ENDIAN_SUFFIX = "l";
+    private static final String VARIABLE_LENGTH_SUFFIX = "v";
 
     private Long mMatchingBeaconTypeCode;
-    protected List<Integer> mIdentifierStartOffsets;
-    protected List<Integer> mIdentifierEndOffsets;
-    protected List<Boolean> mIdentifierLittleEndianFlags;
-    protected List<Integer> mDataStartOffsets;
-    protected List<Integer> mDataEndOffsets;
-    protected List<Boolean> mDataLittleEndianFlags;
-    protected List<Boolean> mIdentifierVariableLengthFlags;
+    protected final List<Integer> mIdentifierStartOffsets;
+    protected final List<Integer> mIdentifierEndOffsets;
+    protected final List<Boolean> mIdentifierLittleEndianFlags;
+    protected final List<Integer> mDataStartOffsets;
+    protected final List<Integer> mDataEndOffsets;
+    protected final List<Boolean> mDataLittleEndianFlags;
+    protected final List<Boolean> mIdentifierVariableLengthFlags;
     protected Integer mMatchingBeaconTypeCodeStartOffset;
     protected Integer mMatchingBeaconTypeCodeEndOffset;
     protected Integer mServiceUuidStartOffset;
@@ -430,9 +434,12 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
                     }
                 } else {
                     if (LogManager.isVerboseLoggingEnabled()) {
-                        LogManager.d(TAG, "This is not a matching Beacon advertisement. Was expecting %s.  "
-                                        + "The bytes I see are: %s", byteArrayToString(serviceUuidBytes),
+                        LogManager.d(TAG, "This is not a matching Beacon advertisement. Was expecting %s at offset %d and %s at offset %d.  "
+                                        + "The bytes I see are: %s",
+                                byteArrayToString(serviceUuidBytes),
+                                startByte + mServiceUuidStartOffset,
                                 byteArrayToString(typeCodeBytes),
+                                startByte + mMatchingBeaconTypeCodeStartOffset,
                                 bytesToHex(bytesToProcess));
                     }
                 }
diff --git a/src/main/java/org/altbeacon/beacon/Region.java b/src/main/java/org/altbeacon/beacon/Region.java
index fbc74ccf..45c966e6 100644
--- a/src/main/java/org/altbeacon/beacon/Region.java
+++ b/src/main/java/org/altbeacon/beacon/Region.java
@@ -28,6 +28,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.regex.Pattern;
 
 /**
  * This class represents a criteria of fields used to match beacons.
@@ -48,6 +49,7 @@
  */
 public class Region implements Parcelable {
     private static final String TAG = "Region";
+    private static final Pattern MAC_PATTERN = Pattern.compile("^[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}$");
 
     /**
      * Required to make class Parcelable
@@ -63,6 +65,7 @@ public Region createFromParcel(Parcel in) {
         }
     };
     protected final List<Identifier> mIdentifiers;
+    protected final String mBluetoothAddress;
     protected final String mUniqueId;
 
     /**
@@ -78,6 +81,7 @@ public Region(String uniqueId, Identifier id1, Identifier id2, Identifier id3) {
         this.mIdentifiers.add(id2);
         this.mIdentifiers.add(id3);
         this.mUniqueId = uniqueId;
+        this.mBluetoothAddress = null;
         if (uniqueId == null) {
             throw new NullPointerException("uniqueId may not be null");
         }
@@ -89,8 +93,35 @@ public Region(String uniqueId, Identifier id1, Identifier id2, Identifier id3) {
      * @param identifiers - list of identifiers for this region
      */
     public Region(String uniqueId, List<Identifier> identifiers) {
+       this(uniqueId, identifiers, null);
+    }
+
+    /**
+     * Constructs a new Region object to be used for Ranging or Monitoring
+     * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
+     * @param identifiers - list of identifiers for this region
+     * @param bluetoothAddress - mac address
+     */
+    public Region(String uniqueId, List<Identifier> identifiers, String bluetoothAddress) {
+        validateMac(bluetoothAddress);
         this.mIdentifiers = new ArrayList<Identifier>(identifiers);
         this.mUniqueId = uniqueId;
+        this.mBluetoothAddress = bluetoothAddress;
+        if (uniqueId == null) {
+            throw new NullPointerException("uniqueId may not be null");
+        }
+    }
+
+    /**
+     * Constructs a new Region object to be used for Ranging or Monitoring
+     * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
+     * @param bluetoothAddress - mac address used to match beacons
+     */
+    public Region(String uniqueId, String bluetoothAddress) {
+        validateMac(bluetoothAddress);
+        this.mBluetoothAddress = bluetoothAddress;
+        this.mUniqueId = uniqueId;
+        this.mIdentifiers = new ArrayList<Identifier>();
         if (uniqueId == null) {
             throw new NullPointerException("uniqueId may not be null");
         }
@@ -139,6 +170,11 @@ public String getUniqueId() {
         return mUniqueId;
     }
 
+    /**
+     * Returns the mac address used to filter for beacons
+     */
+    public String getBluetoothAddress() { return mBluetoothAddress; }
+
     /**
      * Checks to see if an Beacon object is included in the matching criteria of this Region
      * @param beacon the beacon to check to see if it is in the Region
@@ -147,11 +183,19 @@ public String getUniqueId() {
     public boolean matchesBeacon(Beacon beacon) {
         // All identifiers must match, or the corresponding region identifier must be null.
         for (int i = mIdentifiers.size(); --i >= 0; ) {
-            final Identifier ident = mIdentifiers.get(i);
-            if (ident != null && !ident.equals(beacon.mIdentifiers.get(i))) {
+            final Identifier identifier = mIdentifiers.get(i);
+            Identifier beaconIdentifier = null;
+            if (i < beacon.mIdentifiers.size()) {
+                beaconIdentifier = beacon.getIdentifier(i);
+            }
+            if ((beaconIdentifier == null && identifier != null) ||
+                    (beaconIdentifier != null  && identifier != null && !identifier.equals(beaconIdentifier))) {
                 return false;
             }
         }
+        if (mBluetoothAddress != null && !mBluetoothAddress.equalsIgnoreCase(beacon.mBluetoothAddress)) {
+            return false;
+        }
         return true;
     }
 
@@ -190,6 +234,7 @@ public int describeContents() {
 
     public void writeToParcel(Parcel out, int flags) {
         out.writeString(mUniqueId);
+        out.writeString(mBluetoothAddress);
         out.writeInt(mIdentifiers.size());
 
         for (Identifier identifier: mIdentifiers) {
@@ -205,6 +250,7 @@ public void writeToParcel(Parcel out, int flags) {
 
     protected Region(Parcel in) {
         mUniqueId = in.readString();
+        mBluetoothAddress = in.readString();
         int size = in.readInt();
         mIdentifiers = new ArrayList<Identifier>(size);
         for (int i = 0; i < size; i++) {
@@ -218,6 +264,14 @@ protected Region(Parcel in) {
         }
     }
 
+    private void validateMac(String mac) throws IllegalArgumentException {
+        if (mac != null) {
+            if(!MAC_PATTERN.matcher(mac).matches()) {
+                throw new IllegalArgumentException("Invalid mac address: '"+mac+"' Must be 6 hex bytes separated by colons.");
+            }
+        }
+    }
+
     /**
      * Returns a clone of this instance.
      * @deprecated instances of this class are immutable and therefore don't have to be cloned when
@@ -227,6 +281,6 @@ protected Region(Parcel in) {
     @Override
     @Deprecated
     public Region clone() {
-        return new Region(mUniqueId, mIdentifiers);
+        return new Region(mUniqueId, mIdentifiers, mBluetoothAddress);
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
index bd3069c7..42f7db77 100644
--- a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
+++ b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
@@ -54,7 +54,7 @@
     private AndroidModel mRequestedModel;
     private String mRemoteUpdateUrlString = null;
     private Context mContext;
-    private ReentrantLock mLock = new ReentrantLock();
+    private final ReentrantLock mLock = new ReentrantLock();
 
     /**
      * Obtains the best possible <code>DistanceCalculator</code> for the Android device calling
diff --git a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
index 0227144d..2394888a 100644
--- a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
+++ b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
@@ -40,7 +40,7 @@ public BackgroundPowerSaver(Context context, boolean countActiveActivityStrategy
         else {
             LogManager.e(TAG, "Context is not an application instance, so we cannot use the BackgroundPowerSaver");
         }
-        beaconManager = beaconManager.getInstanceForApplication(context);
+        beaconManager = BeaconManager.getInstanceForApplication(context);
     }
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index ff6a3249..aaed5ae5 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -47,13 +47,13 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -69,17 +69,18 @@
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
 
-    private Map<Region, RangeState> rangedRegionState = new HashMap<Region, RangeState>();
-    private Map<Region, MonitorState> monitoredRegionState = new HashMap<Region, MonitorState>();
+    private final Map<Region, RangeState> rangedRegionState = new HashMap<Region, RangeState>();
+    private final Map<Region, MonitorState> monitoredRegionState = new HashMap<Region, MonitorState>();
     int trackedBeaconsPacketCount;
-    private Handler handler = new Handler();
+    private final Handler handler = new Handler();
     private int bindCount = 0;
     private BluetoothCrashResolver bluetoothCrashResolver;
     private DistanceCalculator defaultDistanceCalculator = null;
+    private BeaconManager beaconManager;
     private List<BeaconParser> beaconParsers;
     private CycledLeScanner mCycledScanner;
     private boolean mBackgroundFlag = false;
-    private GattBeaconTracker mGattBeaconTracker = new GattBeaconTracker();
+    private final GattBeaconTracker mGattBeaconTracker = new GattBeaconTracker();
     private ExecutorService mExecutor;
 
     /*
@@ -203,12 +204,13 @@ public void onCreate() {
 
         // Create a private executor so we don't compete with threads used by AsyncTask
         // This uses fewer threads than the default executor so it won't hog CPU
-        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()+1);
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
 
         mCycledScanner = CycledLeScanner.createScanner(this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
-                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag,  mCycledLeScanCallback,  bluetoothCrashResolver);
+                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag, mCycledLeScanCallback, bluetoothCrashResolver);
 
-        beaconParsers = BeaconManager.getInstanceForApplication(getApplicationContext()).getBeaconParsers();
+        beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        beaconParsers = beaconManager.getBeaconParsers();
         defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
 
@@ -296,12 +298,15 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
         mCycledScanner.setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
     }
 
-    protected CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
         @TargetApi(Build.VERSION_CODES.HONEYCOMB)
         @Override
         public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+
+            NonBeaconLeScanCallback nonBeaconLeScanCallback = beaconManager.getNonBeaconLeScanCallback();
+
             try {
-                new ScanProcessor().executeOnExecutor(mExecutor,
+                new ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
                         new ScanData(device, rssi, scanRecord));
             }
             catch (RejectedExecutionException e) {
@@ -435,7 +440,13 @@ public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
     }
 
     private class ScanProcessor extends AsyncTask<ScanData, Void, Void> {
-        DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
+            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
+        }
 
         @Override
         protected Void doInBackground(ScanData... params) {
@@ -453,6 +464,10 @@ protected Void doInBackground(ScanData... params) {
             if (beacon != null) {
                 mDetectionTracker.recordDetection();
                 processBeaconFromScan(beacon);
+            } else {
+                if (mNonBeaconLeScanCallback != null) {
+                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+                }
             }
             return null;
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitorState.java b/src/main/java/org/altbeacon/beacon/service/MonitorState.java
index 9fc3cb14..11b70a36 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitorState.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitorState.java
@@ -23,14 +23,14 @@
  */
 package org.altbeacon.beacon.service;
 
+import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
 public class MonitorState {
     private static final String TAG = "MonitorState";
-    public static long INSIDE_EXPIRATION_MILLIS = 10000l;
     private boolean inside = false;
     private long lastSeenTime = 0l;
-    private Callback callback;
+    private final Callback callback;
 
     public MonitorState(Callback c) {
         callback = c;
@@ -51,12 +51,12 @@ public boolean markInside() {
     }
     public boolean isNewlyOutside() {
         if (inside) {
-            if (lastSeenTime > 0 && System.currentTimeMillis() - lastSeenTime > INSIDE_EXPIRATION_MILLIS) {
+            if (lastSeenTime > 0 && System.currentTimeMillis() - lastSeenTime > BeaconManager.getRegionExitPeriod()) {
                 inside = false;
                 LogManager.d(TAG, "We are newly outside the region because the lastSeenTime of %s "
                                 + "was %s seconds ago, and that is over the expiration duration "
                                 + "of %s", lastSeenTime, System.currentTimeMillis() - lastSeenTime,
-                        INSIDE_EXPIRATION_MILLIS);
+                        BeaconManager.getRegionExitPeriod());
                 lastSeenTime = 0l;
                 return true;
             }
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
index 12c64a67..e9523536 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
@@ -31,8 +31,8 @@
 public class MonitoringData implements Parcelable {
     @SuppressWarnings("unused")
     private static final String TAG = "MonitoringData";
-    private boolean inside;
-    private Region region;
+    private final boolean inside;
+    private final Region region;
 
     public MonitoringData (boolean inside, Region region) {
         this.inside = inside;
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index 288ae3f8..a8c1e8d4 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -33,7 +33,7 @@
 
 public class RangeState {
     private static final String TAG = "RangeState";
-    private Callback mCallback;
+    private final Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
     private static boolean UseTrackingCache = false;
 
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index 13fefbf5..34722c4a 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -9,10 +9,10 @@
 public class RangedBeacon {
 
     private static final String TAG = "RangedBeacon";
-    public static long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
+    public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
     public static long maxTrackingAge = DEFAULT_MAX_TRACKING_AGE; /* 5 Seconds */
     //kept here for backward compatibility
-    public static long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
+    public static final long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
     private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
     private boolean mTracked = true;
     protected long lastTrackedTimeMillis = 0;
@@ -24,11 +24,11 @@ public RangedBeacon(Beacon beacon) {
         try {
             Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
             filter = (RssiFilter)cons.newInstance();
-            if ((filter != null) && (filter instanceof RunningAverageRssiFilter))
-                ((RunningAverageRssiFilter)filter).setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
         } catch (Exception e) {
             LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
         }
+
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
         updateBeacon(beacon);
     }
 
diff --git a/src/main/java/org/altbeacon/beacon/service/RangingData.java b/src/main/java/org/altbeacon/beacon/service/RangingData.java
index bfaad9a2..f8750b28 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -36,8 +36,8 @@
 
 public class RangingData implements Parcelable {
     private static final String TAG = "RangingData";
-    private Collection<Beacon> beacons;
-    private Region region;
+    private final Collection<Beacon> beacons;
+    private final Region region;
 
     public RangingData (Collection<Beacon> beacons, Region region) {
         synchronized (beacons) {
diff --git a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
index ccffdd3e..ada81b83 100644
--- a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
@@ -15,7 +15,7 @@
 public class RunningAverageRssiFilter implements RssiFilter {
 
     private static final String TAG = "RunningAverageRssiFilter";
-    public static long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
+    public static final long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
     private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
     private ArrayList<Measurement> mMeasurements = new ArrayList<Measurement>();
 
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index bd1fb918..e228de87 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -9,7 +9,6 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.Handler;
-import android.util.Log;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
@@ -209,7 +208,7 @@ protected void scanLeDevice(final Boolean enable) {
         } else {
             LogManager.d(TAG, "disabling scan");
             mScanning = false;
-
+            mScanCyclerStarted = false;
             stopScan();
             mLastScanCycleEndTime = new Date().getTime();
         }
@@ -319,7 +318,7 @@ protected void cancelWakeUpAlarm() {
         // devices.
         long milliseconds = Long.MAX_VALUE; // 2.9 million years from now
         AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
-        alarmManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + milliseconds, getWakeUpOperation());
+        alarmManager.set(AlarmManager.RTC_WAKEUP, milliseconds, getWakeUpOperation());
         LogManager.d(TAG, "Set a wakeup alarm to go off in %s ms: %s", milliseconds, getWakeUpOperation());
 
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index 50c8bf1d..f0eb9443 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -8,6 +8,7 @@
 import android.bluetooth.le.ScanResult;
 import android.bluetooth.le.ScanSettings;
 import android.content.Context;
+import android.os.ParcelUuid;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
@@ -26,7 +27,8 @@
     private long mBackgroundLScanStartTime = 0l;
     private long mBackgroundLScanFirstDetectionTime = 0l;
     private boolean mScanDeferredBefore = false;
-    private BeaconManager mBeaconManager;
+    private boolean mMainScanCycleActive = false;
+    private final BeaconManager mBeaconManager;
 
     public CycledLeScannerForLollipop(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
         super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
@@ -84,8 +86,10 @@ then no beacons will be detected until the next scan cycle starts (5 minutes max
            operating system versions.
      */
     protected boolean deferScanIfNeeded() {
+        // This method is called to see if it is time to start a scan
         long millisecondsUntilStart = mNextScanCycleStartTime - System.currentTimeMillis();
         if (millisecondsUntilStart > 0) {
+            mMainScanCycleActive = false;
             if (true) {
                 long secsSinceLastDetection = System.currentTimeMillis() -
                         DetectionTracker.getInstance().getLastDetectionTime();
@@ -100,9 +104,10 @@ protected boolean deferScanIfNeeded() {
 
                         // On Android L, between scan cycles do a scan with a filter looking for any beacon
                         // if we see one of those beacons, we need to deliver the results
-                        ScanSettings settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
                         startScan();
                     } else {
+                        // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
+                        // This API is now available in Android M
                         LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
                                 + "ago, so we will not keep scanning in background.",
                                 secsSinceLastDetection);
@@ -154,6 +159,7 @@ public void run() {
                 mBackgroundLScanStartTime = 0;
             }
             mScanDeferredBefore = false;
+            mMainScanCycleActive = true;
         }
         return false;
     }
@@ -163,16 +169,14 @@ protected void startScan() {
         List<ScanFilter> filters = new ArrayList<ScanFilter>();
         ScanSettings settings;
 
-        if (mBackgroundFlag) {
-            LogManager.d(TAG, "starting scan in SCAN_MODE_LOW_POWER");
+        if (mBackgroundFlag && !mMainScanCycleActive) {
+            LogManager.d(TAG, "starting filtered scan in SCAN_MODE_LOW_POWER");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
             filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
                     mBeaconManager.getBeaconParsers());
-
         } else {
-            LogManager.d(TAG, "starting scan in SCAN_MODE_LOW_LATENCY");
+            LogManager.d(TAG, "starting non-filtered scan in SCAN_MODE_LOW_LATENCY");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)).build();
-
         }
 
         try {
@@ -194,6 +198,7 @@ protected void startScan() {
 
     @Override
     protected void finishScan() {
+        LogManager.d(TAG, "Stopping scan");
         stopScan();
         mScanningPaused = true;
     }
@@ -218,7 +223,15 @@ private ScanCallback getNewLeScanCallback() {
 
                 @Override
                 public void onScanResult(int callbackType, ScanResult scanResult) {
-                    LogManager.d(TAG, "got record");
+                    if (LogManager.isVerboseLoggingEnabled()) {
+                        LogManager.d(TAG, "got record");
+                        List<ParcelUuid> uuids = scanResult.getScanRecord().getServiceUuids();
+                        if (uuids != null) {
+                            for (ParcelUuid uuid : uuids) {
+                                LogManager.d(TAG, "with service uuid: "+uuid);
+                            }
+                        }
+                    }
                     mCycledLeScanCallback.onLeScan(scanResult.getDevice(),
                             scanResult.getRssi(), scanResult.getScanRecord().getBytes());
                     if (mBackgroundLScanStartTime > 0) {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java b/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
new file mode 100644
index 00000000..f85139cb
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
@@ -0,0 +1,37 @@
+package org.altbeacon.beacon.service.scanner;
+
+import android.bluetooth.BluetoothDevice;
+
+/**
+ * Allows an implementation to see non-Beacon BLE devices as they are scanned.
+ * <p/>
+ * To use:
+ * <pre><code>
+ * public class BeaconReferenceApplication extends Application implements ..., NonBeaconLeScanCallback {
+ *     public void onCreate() {
+ *         super.onCreate();
+ *         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(this);
+ *         ...
+ *         beaconManager.setNonBeaconLeScanCallback(this);
+ *         ...
+ *     }
+ *
+ *     {@literal @}Override
+ *     public void onNonBeaconLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+ *          ...
+ *     }
+ *  }
+ * </code></pre>
+ */
+public interface NonBeaconLeScanCallback {
+    /**
+     * NOTE: This method is NOT called on the main UI thread.
+     *
+     * @param device Identifies the remote device
+     * @param rssi The RSSI value for the remote device as reported by the
+     *             Bluetooth hardware. 0 if no RSSI value is available.
+     * @param scanRecord The content of the advertisement record offered by
+     *                   the remote device.
+     */
+    void onNonBeaconLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java b/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
index c7700da1..dc4ee965 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
@@ -1,9 +1,14 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.annotation.TargetApi;
+import android.bluetooth.BluetoothDevice;
 import android.bluetooth.le.ScanFilter;
+import android.bluetooth.le.ScanRecord;
+import android.bluetooth.le.ScanResult;
+import android.os.ParcelUuid;
 
 import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.logging.LogManager;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -13,7 +18,9 @@
  */
 @TargetApi(21)
 public class ScanFilterUtils {
+    public static final String TAG = "ScanFilterUtils";
     class ScanFilterData {
+        public Long serviceUuid = null;
         public int manufacturer;
         public byte[] filter;
         public byte[] mask;
@@ -22,6 +29,7 @@
     public List<ScanFilterData> createScanFilterDataForBeaconParser(BeaconParser beaconParser) {
         ArrayList<ScanFilterData> scanFilters = new ArrayList<ScanFilterData>();
         for (int manufacturer : beaconParser.getHardwareAssistManufacturers()) {
+            Long serviceUuid = beaconParser.getServiceUuid();
             long typeCode = beaconParser.getMatchingBeaconTypeCode();
             int startOffset = beaconParser.getMatchingBeaconTypeCodeStartOffset();
             int endOffset = beaconParser.getMatchingBeaconTypeCodeEndOffset();
@@ -46,6 +54,7 @@
             sfd.manufacturer = manufacturer;
             sfd.filter = filter;
             sfd.mask = mask;
+            sfd.serviceUuid = serviceUuid;
             scanFilters.add(sfd);
 
         }
@@ -60,11 +69,30 @@
             List<ScanFilterData> sfds = createScanFilterDataForBeaconParser(beaconParser);
             for (ScanFilterData sfd: sfds) {
                 ScanFilter.Builder builder = new ScanFilter.Builder();
-                builder.setManufacturerData((int) sfd.manufacturer, sfd.filter, sfd.mask);
+                if (sfd.serviceUuid != null) {
+                    // Use a 16 bit service UUID in a 128 bit form
+                    String serviceUuidString = String.format("0000%04X-0000-1000-8000-00805f9b34fb", sfd.serviceUuid);
+                    String serviceUuidMaskString = "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF";
+                    ParcelUuid parcelUuid = ParcelUuid.fromString(serviceUuidString);
+                    ParcelUuid parcelUuidMask = ParcelUuid.fromString(serviceUuidMaskString);
+                    if (LogManager.isVerboseLoggingEnabled()) {
+                        LogManager.d(TAG, "making scan filter for service: "+serviceUuidString+" "+parcelUuid);
+                        LogManager.d(TAG, "making scan filter with service mask: "+serviceUuidMaskString+" "+parcelUuidMask);
+                    }
+                    builder.setServiceUuid(parcelUuid, parcelUuidMask);
+                }
+                else {
+                    builder.setServiceUuid(null);
+                    builder.setManufacturerData((int) sfd.manufacturer, sfd.filter, sfd.mask);
+                }
                 ScanFilter scanFilter = builder.build();
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Set up a scan filter: "+scanFilter);
+                }
                 scanFilters.add(scanFilter);
             }
         }
         return scanFilters;
     }
+
 }
diff --git a/src/test/java/org/altbeacon/beacon/BeaconParserTest.java b/src/test/java/org/altbeacon/beacon/BeaconParserTest.java
index d9d378d6..9b9a41ce 100644
--- a/src/test/java/org/altbeacon/beacon/BeaconParserTest.java
+++ b/src/test/java/org/altbeacon/beacon/BeaconParserTest.java
@@ -159,7 +159,7 @@ public void testLittleEndianIdentifierParsing() {
         assertEquals("id2 should be little endian", "0x0c0b0a090807", beacon.getIdentifier(1).toString());
         assertEquals("id3 should be big endian", "0x0d0e0f1011121314", beacon.getIdentifier(2).toString());
         assertEquals("txPower should be parsed", -59, beacon.getTxPower());
-        assertEquals("manufacturer should be parsed", 0x118 ,beacon.getManufacturer());
+        assertEquals("manufacturer should be parsed", 0x118, beacon.getManufacturer());
     }
 
     @TargetApi(Build.VERSION_CODES.GINGERBREAD)
@@ -185,7 +185,7 @@ public void testRecognizeBeaconCapturedManufacturer() {
         BeaconParser parser = new BeaconParser();
         parser.setBeaconLayout("m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25");
         Beacon beacon = parser.fromScanData(bytes, -55, null);
-        assertEquals("manufacturer should be parsed", "bbaa" ,String.format("%04x", beacon.getManufacturer()));
+        assertEquals("manufacturer should be parsed", "bbaa", String.format("%04x", beacon.getManufacturer()));
     }
 
 
@@ -200,6 +200,16 @@ public void testParseGattIdentifierThatRunsOverPduLength() {
         assertNull("beacon should not be parsed", beacon);
     }
 
+    @Test
+    public void testLongUrlBeaconIdentifier() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        byte[] bytes = hexStringToByteArray("0201060303aafe0d16aafe10e70102030405060708090a0b0c0d0e0f0102030405060708090a0b0c0d0e0f00000000000000000000000000000000000000");
+        BeaconParser parser = new BeaconParser();
+        parser.setBeaconLayout("s:0-1=feaa,m:2-2=10,p:3-3:-41,i:4-20v");
+        Beacon beacon = parser.fromScanData(bytes, -55, null);
+        assertEquals("URL Identifier should be truncated at 8 bytes", 8, beacon.getId1().toByteArray().length);
+    }
+
     @Test
     public void testParseManufacturerIdentifierThatRunsOverPduLength() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
diff --git a/src/test/java/org/altbeacon/beacon/GattBeaconTest.java b/src/test/java/org/altbeacon/beacon/GattBeaconTest.java
index 009b769d..273355fd 100644
--- a/src/test/java/org/altbeacon/beacon/GattBeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/GattBeaconTest.java
@@ -72,7 +72,7 @@ public void testDetectsGattBeacon2WithShortIdentifier() {
                 (byte)0x00,
                 gattBeacon.getId1().toByteArray()[0]);
         assertEquals("GattBeacon identifier should have proper second to last byte",
-                (byte)0x73,
+                (byte) 0x73,
                 gattBeacon.getId1().toByteArray()[14]);
         assertEquals("GattBeacon identifier should have proper last byte",
                 (byte)0x07,
@@ -80,6 +80,19 @@ public void testDetectsGattBeacon2WithShortIdentifier() {
 
     }
 
+
+    @Test
+    public void testDetectsEddystoneUID() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        LogManager.setLogger(Loggers.verboseLogger());
+        LogManager.setVerboseLoggingEnabled(true);
+        byte[] bytes = hexStringToByteArray("0201060303aafe1516aafe00e700010203040506070809010203040506000000000000000000000000000000000000000000000000000000000000000000");
+        BeaconParser parser = new BeaconParser().setBeaconLayout(BeaconParser.EDDYSTONE_UID_LAYOUT);
+        Beacon eddystoneUidBeacon = parser.fromScanData(bytes, -55, null);
+        assertNotNull("Eddystone-UID should be not null if parsed successfully", eddystoneUidBeacon);
+    }
+
+
     @Test
     public void testDetectsGattBeaconWithCnn() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
diff --git a/src/test/java/org/altbeacon/beacon/RegionTest.java b/src/test/java/org/altbeacon/beacon/RegionTest.java
index 606119cc..e6dca7ae 100644
--- a/src/test/java/org/altbeacon/beacon/RegionTest.java
+++ b/src/test/java/org/altbeacon/beacon/RegionTest.java
@@ -6,6 +6,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertFalse;
 
 import org.robolectric.RobolectricTestRunner;
 
@@ -71,6 +72,51 @@ public void testBeaconMatchesRegionWithShorterIdentifierList() {
         assertTrue("Beacon should match region with first identifier equal and shorter Identifier list", region.matchesBeacon(beacon));
     }
 
+    @Test
+    public void testBeaconDoesntMatchRegionWithLongerIdentifierList() {
+        Beacon beacon = new Beacon.Builder().setId1("1").setId2("2").setRssi(4)
+                .setBeaconTypeCode(5).setTxPower(6).setBluetoothAddress("1:2:3:4:5:6").build();
+        Region region = new Region("myRegion", Identifier.parse("1"), Identifier.parse("2"), Identifier.parse("3"));
+        assertFalse("Beacon should not match region with more identifers than the beacon", region.matchesBeacon(beacon));
+    }
+
+    @Test
+    public void testBeaconDoesMatchRegionWithLongerIdentifierListWithSomeNull() {
+        Beacon beacon = new Beacon.Builder().setId1("1").setId2("2").setRssi(4)
+                .setBeaconTypeCode(5).setTxPower(6).setBluetoothAddress("1:2:3:4:5:6").build();
+        Region region = new Region("myRegion", null, null, null);
+        assertTrue("Beacon should match region with more identifers than the beacon, if the region identifiers are null", region.matchesBeacon(beacon));
+    }
+
+    @Test
+    public void testBeaconMatchesRegionWithSameBluetoothMac() {
+        Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
+                .setBeaconTypeCode(5).setTxPower(6).setBluetoothAddress("01:02:03:04:05:06").build();
+        Region region = new Region("myRegion", "01:02:03:04:05:06");
+        assertTrue("Beacon should match region with mac the same", region.matchesBeacon(beacon));
+    }
+
+    @Test
+    public void testBeaconDoesNotMatchRegionWithDiffrentBluetoothMac() {
+        Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
+                .setBeaconTypeCode(5).setTxPower(6).setBluetoothAddress("01:02:03:04:05:06").build();
+        Region region = new Region("myRegion", "01:02:03:04:05:99");
+        assertFalse("Beacon should match region with mac the same", region.matchesBeacon(beacon));
+    }
+
+    @Test
+    public void testBeaconMatchesRegionWithSameBluetoothMacAndIdentifiers() {
+        Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
+                .setBeaconTypeCode(5).setTxPower(6).setBluetoothAddress("01:02:03:04:05:06").build();
+        ArrayList identifiers = new ArrayList<Identifier>();
+        identifiers.add(Identifier.parse("1"));
+        identifiers.add(Identifier.parse("2"));
+        identifiers.add(Identifier.parse("3"));
+        Region region = new Region("myRegion", identifiers , "01:02:03:04:05:06");
+        assertTrue("Beacon should match region with mac the same", region.matchesBeacon(beacon));
+    }
+
+
     @Test
     public void testCanSerializeParcelable() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -87,6 +133,34 @@ public void testCanSerializeParcelable() {
         assertNull("id3 is null after deserialization", region2.getIdentifier(2));
     }
 
+    @Test
+    public void testCanSerializeParcelableWithMac() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        Parcel parcel = Parcel.obtain();
+        Region region = new Region("myRegion", "1B:2a:03:4C:6E:9F");
+        region.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+        Region region2 = new Region(parcel);
+        assertEquals("Right number of identifiers after deserialization", 0, region2.mIdentifiers.size());
+        assertEquals("ac is same after deserialization", region.getBluetoothAddress(), region2.getBluetoothAddress());
+    }
+
+    @Test
+    public void rejectsInvalidMac() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        Parcel parcel = Parcel.obtain();
+        try {
+            Region region = new Region("myRegion", "this string is not a valid mac address!");
+            assertTrue("IllegalArgumentException should have been thrown", false);
+        }
+        catch (IllegalArgumentException e) {
+            assertEquals("Error message should be as expected",
+                    "Invalid mac address: 'this string is not a valid mac address!' Must be 6 hex bytes separated by colons.",
+                    e.getMessage());
+        }
+    }
+
+
     @Test
     public void testToString() {
         Region region = new Region("myRegion", Identifier.parse("1"), Identifier.parse("2"), null);
diff --git a/src/test/java/org/altbeacon/beacon/service/scanner/ScanFilterUtilsTest.java b/src/test/java/org/altbeacon/beacon/service/scanner/ScanFilterUtilsTest.java
index dc174786..deaa6b04 100644
--- a/src/test/java/org/altbeacon/beacon/service/scanner/ScanFilterUtilsTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/scanner/ScanFilterUtilsTest.java
@@ -1,6 +1,7 @@
 package org.altbeacon.beacon.service.scanner;
 
 
+import android.bluetooth.le.ScanFilter;
 import android.content.Context;
 
 import org.altbeacon.beacon.AltBeaconParser;
@@ -15,12 +16,15 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
+import org.mockito.Mockito;
 
 @Config(sdk = 18)
 
@@ -61,9 +65,22 @@ public void testGenericScanFilter() throws Exception {
         ScanFilterUtils.ScanFilterData sfd = scanFilterDatas.get(0);
         assertEquals("manufacturer should be right", 0x004c, sfd.manufacturer);
         assertEquals("mask length should be right", 2, sfd.mask.length);
-        assertArrayEquals("mask should be right", new byte[] {(byte)0xff, (byte)0xff}, sfd.mask);
-        assertArrayEquals("filter should be right", new byte[] {(byte)0x11, (byte)0x11}, sfd.filter);
+        assertArrayEquals("mask should be right", new byte[]{(byte) 0xff, (byte) 0xff}, sfd.mask);
+        assertArrayEquals("filter should be right", new byte[] {(byte)0x11, (byte) 0x11}, sfd.filter);
+        assertNull("serviceUuid should be null", sfd.serviceUuid);
+    }
+    @Test
+    public void testEddystoneScanFilterData() throws Exception {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        BeaconParser parser = new BeaconParser();
+        parser.setBeaconLayout(BeaconParser.EDDYSTONE_UID_LAYOUT);
+        BeaconManager.setsManifestCheckingDisabled(true); // no manifest available in robolectric
+        List<ScanFilterUtils.ScanFilterData> scanFilterDatas = new ScanFilterUtils().createScanFilterDataForBeaconParser(parser);
+        assertEquals("scanFilters should be of correct size", 1, scanFilterDatas.size());
+        ScanFilterUtils.ScanFilterData sfd = scanFilterDatas.get(0);
+        assertEquals("serviceUuid should be right", new Long(0xfeaa), sfd.serviceUuid);
     }
+
     @Test
     public void testZeroOffsetScanFilter() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
