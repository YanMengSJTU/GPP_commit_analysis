diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index 3c567b01..6768754c 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -98,6 +98,7 @@
      * fluctuates quite a bit with RSSI, so despite the name, it is not super accurate.
      */
     protected Double mDistance;
+
     /**
      * The measured signal strength of the Bluetooth packet that led do this Beacon detection.
      */
@@ -119,6 +120,11 @@
      */
     private Double mRunningAverageRssi = null;
 
+    /**
+     * If multiple RSSI samples were available, this is the running average
+     */
+    private Double mRunningMaxRssi = null;
+
     /**
      * Used to attach data to individual Beacons, either locally or in the cloud
      */
@@ -240,6 +246,7 @@ protected Beacon(Beacon otherBeacon) {
         mExtraDataFields = new ArrayList<>(otherBeacon.mExtraDataFields);
         this.mDistance = otherBeacon.mDistance;
         this.mRunningAverageRssi = otherBeacon.mRunningAverageRssi;
+        this.mRunningMaxRssi = otherBeacon.mRunningMaxRssi;
         this.mRssi = otherBeacon.mRssi;
         this.mTxPower = otherBeacon.mTxPower;
         this.mBluetoothAddress = otherBeacon.mBluetoothAddress;
@@ -261,11 +268,20 @@ protected Beacon() {
      * Sets the running average rssi for use in distance calculations
      * @param rssi the running average rssi
      */
-    public void setRunningAverageRssi(double rssi) {
+    public void setRunningAverageRssi(Double rssi) {
         mRunningAverageRssi = rssi;
         mDistance = null; // force calculation of accuracy and proximity next time they are requested
     }
 
+    /**
+     * Sets the running max rssi for use in distance calculations
+     * @param rssi the running max rssi
+     */
+    public void setRunningMaxRssi(Double rssi) {
+        mRunningMaxRssi = rssi;
+        mDistance = null; // force calculation of accuracy and proximity next time they are requested
+    }
+
     /**
      * Sets the most recently measured rssi for use in distance calculations if a running average is
      * not available
@@ -382,12 +398,17 @@ public void setExtraDataFields(List<Long> fields) {
      */
     public double getDistance() {
         if (mDistance == null) {
-            mDistance = calculateDistance(mTxPower, getBestRssiAvailable());
+            mDistance = calculateDistance(mTxPower, getBestAverageRssiAvailable());
+            if (mRunningMaxRssi != null) {
+                // we set the current rssi to be the short term max minus a longer term mean
+                // we are looking for short term changes
+                mDistance = calculateDistance(mTxPower, mRunningMaxRssi) - mDistance;
+            }
         }
         return mDistance;
     }
 
-    public double getBestRssiAvailable() {
+    public double getBestAverageRssiAvailable() {
         double bestRssiAvailable = mRssi;
         if (mRunningAverageRssi != null) {
             bestRssiAvailable = mRunningAverageRssi;
@@ -552,9 +573,11 @@ public JSONObject toJSON() {
 
         map.put("distance", getDistance());
         map.put("rssi", getRssi());
-        map.put("best_rssi", getBestRssiAvailable());
-        LogManager.w(TAG,
-                "beacon saved with rssi : %d and best rssi: %f", getRssi(), getBestRssiAvailable());
+        map.put("best_rssi", getBestAverageRssiAvailable());
+        if (mRunningMaxRssi != null)
+            map.put("max_rssi", mRunningMaxRssi);
+        LogManager.d(TAG,
+                "beacon saved with rssi : %d and best rssi: %f", getRssi(), getBestAverageRssiAvailable());
         map.put("tx_power", mTxPower);
         map.put("bluetooth_address", mBluetoothAddress);
         map.put("bluetooth_type_code", mBeaconTypeCode);
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 6585fdbe..19c79a5d 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -41,6 +41,7 @@
 import org.altbeacon.beacon.service.RangeState;
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
+import org.altbeacon.beacon.service.RunningMaxRssiFilter;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.simulator.BeaconSimulator;
 
@@ -725,10 +726,42 @@ public static void setUseTrackingCache(boolean useTrackingCache) {
      * measurements
      * @param maxTrackingAge in milliseconds
      */
-    public void setMaxTrackingAge(int maxTrackingAge) {
+    public void setMaxTrackingAge(long maxTrackingAge) {
         RangedBeacon.setMaxTrackinAge(maxTrackingAge);
     }
 
+    /**
+     * Set the period for new max measurement
+     * @param sampleExpirationMilliseconds in milliseconds
+     */
+    public void setRunningMaxSampleExpirationMilliseconds(int sampleExpirationMilliseconds) {
+        RunningMaxRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
+    }
+
+    /**
+     * Set the averaging period for new measurement
+     * @param sampleExpirationMilliseconds in milliseconds
+     */
+    public void setRunningAverageSampleExpirationMilliseconds(int sampleExpirationMilliseconds) {
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
+    }
+
+    /**
+     * Set the expected sampling rate
+     * @param sampleRateMilliseconds in milliseconds
+     */
+    public void setSamplingRateMilliseconds(int sampleRateMilliseconds) {
+        RunningAverageRssiFilter.setSampleRateMilliseconds(sampleRateMilliseconds);
+    }
+
+    /**
+     * Set the sample quantile used in the running mean calculation
+     * @param sampleQuantile in milliseconds
+     */
+    public void setSampleQuantile(double sampleQuantile) {
+        RunningAverageRssiFilter.setSampleQuantile(sampleQuantile);
+    }
+
     public static void setBeaconSimulator(BeaconSimulator beaconSimulator) {
         BeaconManager.beaconSimulator = beaconSimulator;
     }
diff --git a/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java b/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
index 8cd4e417..a1627d18 100644
--- a/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
+++ b/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
@@ -50,7 +50,6 @@ public double calculateDistance(int txPower, double rssi) {
 
         LogManager.d(TAG, "calculating distance based on mRssi of %s and txPower of %s", rssi, txPower);
 
-
         double ratio = rssi*1.0/txPower;
         double distance;
         if (ratio < 1.0) {
diff --git a/src/main/java/org/altbeacon/beacon/logging/JSONDataLogger.java b/src/main/java/org/altbeacon/beacon/logging/JSONDataLogger.java
index 009bd6f8..52ec0693 100644
--- a/src/main/java/org/altbeacon/beacon/logging/JSONDataLogger.java
+++ b/src/main/java/org/altbeacon/beacon/logging/JSONDataLogger.java
@@ -47,9 +47,14 @@ public static void setRange(int range) {
         getInstance().mRange = range;
     }
 
+    public static int getRange() {
+        return getInstance().mRange;
+    }
+
     public static JSONDataLogger getInstance() {
         if(mInstance == null) {
             mInstance = new JSONDataLogger();
+            mInstance.setRange(0);
         }
         return mInstance;
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index a8c1e8d4..6fd86a8f 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -82,7 +82,7 @@ public void addBeacon(Beacon beacon) {
                     newRangedBeacons.put(beacon, rangedBeacon);
                 }
                 else {
-                    LogManager.d(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
+                    LogManager.i(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
                 }
             }
             mRangedBeacons = newRangedBeacons;
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index 34722c4a..11e7e9fa 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -11,13 +11,11 @@
     private static final String TAG = "RangedBeacon";
     public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
     public static long maxTrackingAge = DEFAULT_MAX_TRACKING_AGE; /* 5 Seconds */
-    //kept here for backward compatibility
-    public static final long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
-    private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
     private boolean mTracked = true;
     protected long lastTrackedTimeMillis = 0;
     Beacon mBeacon;
     protected RssiFilter filter = null;
+    protected RssiFilter maxFilter = new RunningMaxRssiFilter();
 
     public RangedBeacon(Beacon beacon) {
         //set RSSI filter
@@ -28,7 +26,6 @@ public RangedBeacon(Beacon beacon) {
             LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
         }
 
-        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
         updateBeacon(beacon);
     }
 
@@ -51,14 +48,28 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
+
+        // calculate average
         if (!filter.noMeasurementsAvailable()) {
             double runningAverage = filter.calculateRssi();
             mBeacon.setRunningAverageRssi(runningAverage);
-            LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
+            LogManager.i(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
         else {
+            mBeacon.setRunningAverageRssi(null);
             LogManager.d(TAG, "No measurements available to calculate running average");
         }
+
+        // calculate max
+        if (!maxFilter.noMeasurementsAvailable()) {
+            double runningMax = maxFilter.calculateRssi();
+            mBeacon.setRunningMaxRssi(runningMax);
+            LogManager.i(TAG, "calculated new runningMaxRssi: %s", runningMax);
+        }
+        else {
+            mBeacon.setRunningMaxRssi(null);
+            LogManager.d(TAG, "No measurements available to calculate running max");
+        }
     }
 
     public void addMeasurement(Integer rssi) {
@@ -68,15 +79,11 @@ public void addMeasurement(Integer rssi) {
             mTracked = true;
             lastTrackedTimeMillis = System.currentTimeMillis();
             filter.addMeasurement(rssi);
+            maxFilter.addMeasurement(rssi);
         }
     }
 
-    //kept here for backward compatibility
-    public static void setSampleExpirationMilliseconds(long milliseconds) {
-        sampleExpirationMilliseconds = milliseconds;
-    }
-
-    public static void setMaxTrackinAge(int maxTrackinAge) {
+    public static void setMaxTrackinAge(long maxTrackinAge) {
         RangedBeacon.maxTrackingAge = maxTrackinAge;
     }
 
diff --git a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
index ada81b83..b495119e 100644
--- a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
@@ -15,8 +15,14 @@
 public class RunningAverageRssiFilter implements RssiFilter {
 
     private static final String TAG = "RunningAverageRssiFilter";
+    public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
+    public static long maxTrackingAge = DEFAULT_MAX_TRACKING_AGE; /* 5 Seconds */
     public static final long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
     private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
+    public static final double DEFAULT_SAMPLE_QUANTILE = 0.5;
+    private static double sampleQuantile = DEFAULT_SAMPLE_QUANTILE;
+    public static final long DEFAULT_SAMPLE_RATE = 500; /* 0.5 seconds */
+    private static long sampleRateMilliseconds = DEFAULT_SAMPLE_RATE;
     private ArrayList<Measurement> mMeasurements = new ArrayList<Measurement>();
 
     @Override
@@ -25,6 +31,7 @@ public void addMeasurement(Integer rssi) {
         measurement.rssi = rssi;
         measurement.timestamp = new Date().getTime();
         mMeasurements.add(measurement);
+        LogManager.i(TAG, "added measurement");
     }
 
     @Override
@@ -35,22 +42,29 @@ public boolean noMeasurementsAvailable() {
     @Override
     public double calculateRssi() {
         refreshMeasurements();
-        int size = mMeasurements.size();
-        int startIndex = 0;
-        int endIndex = size -1;
-        if (size > 2) {
-            startIndex = size/10+1;
-            endIndex = size-size/10-2;
+
+        // fill missing samples
+        ArrayList<Measurement> calcMeasurements = new ArrayList<>(mMeasurements);
+        while (calcMeasurements.size() < sampleExpirationMilliseconds/sampleRateMilliseconds) {
+            Measurement m = new Measurement();
+            m.rssi = -110;
+            m.timestamp = System.currentTimeMillis();
+            calcMeasurements.add(m);
         }
+        Collections.sort(mMeasurements);
+
+        int endIndex = (int) (sampleQuantile * sampleExpirationMilliseconds/sampleRateMilliseconds);
+        assert (endIndex > 0);
+        assert (endIndex <= sampleExpirationMilliseconds/sampleRateMilliseconds);
 
         double sum = 0;
-        for (int i = startIndex; i <= endIndex; i++) {
-            sum += mMeasurements.get(i).rssi;
+        for (int i = 0; i < endIndex; i++) {
+            sum += calcMeasurements.get(i).rssi;
         }
-        double runningAverage = sum/(endIndex-startIndex+1);
+        double runningAverage = sum/(endIndex-1);
 
-        LogManager.d(TAG, "Running average mRssi based on %s measurements: %s",
-                size, runningAverage);
+        LogManager.i(TAG, "Running average mRssi based on %s measurements with %s dummy measurements: %s, max : %s",
+                calcMeasurements.size(), calcMeasurements.size()-mMeasurements.size(), runningAverage, calcMeasurements.get(0).rssi);
         return runningAverage;
     }
 
@@ -81,4 +95,12 @@ public static void setSampleExpirationMilliseconds(long newSampleExpirationMilli
         sampleExpirationMilliseconds = newSampleExpirationMilliseconds;
     }
 
+    public static void setSampleRateMilliseconds(long newSampleRateMilliseconds) {
+        sampleRateMilliseconds = newSampleRateMilliseconds;
+    }
+
+    public static void setSampleQuantile(double newSampleQuantile) {
+        sampleQuantile = newSampleQuantile;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RunningMaxRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RunningMaxRssiFilter.java
new file mode 100644
index 00000000..57caff95
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/RunningMaxRssiFilter.java
@@ -0,0 +1,72 @@
+package org.altbeacon.beacon.service;
+
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.Iterator;
+
+/**
+ * Calculate a RSSI value on base of an arbitrary list of measured RSSI values
+ * The list is clipped by a certain length at start and end and the average
+ * is calculate by simple arithmetic average
+ */
+public class RunningMaxRssiFilter implements RssiFilter {
+
+    private static final String TAG = "RunningAverageRssiFilter";
+    public static final long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 7500; /* 7.5 seconds */
+    private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
+    private ArrayList<Measurement> mMeasurements = new ArrayList<Measurement>();
+
+    @Override
+    public void addMeasurement(Integer rssi) {
+        Measurement measurement = new Measurement();
+        measurement.rssi = rssi;
+        measurement.timestamp = new Date().getTime();
+        mMeasurements.add(measurement);
+        LogManager.i(TAG, "added measurement");
+    }
+
+    @Override
+    public boolean noMeasurementsAvailable() {
+        refreshMeasurements();
+        return mMeasurements.size() == 0;
+    }
+
+    @Override
+    public double calculateRssi() {
+        refreshMeasurements();
+        if (mMeasurements.size() == 0) return -1;
+        LogManager.d(TAG, "Running max mRssi: %s", mMeasurements.get(0));
+        return (double) mMeasurements.get(0).rssi;
+    }
+
+    private synchronized void refreshMeasurements() {
+        Date now = new Date();
+        ArrayList<Measurement> newMeasurements = new ArrayList<Measurement>();
+        Iterator<Measurement> iterator = mMeasurements.iterator();
+        while (iterator.hasNext()) {
+            Measurement measurement = iterator.next();
+            if (now.getTime() - measurement.timestamp < sampleExpirationMilliseconds ) {
+                newMeasurements.add(measurement);
+            }
+        }
+        mMeasurements = newMeasurements;
+        Collections.sort(mMeasurements);
+    }
+
+    private class Measurement implements Comparable<Measurement> {
+        Integer rssi;
+        long timestamp;
+        @Override
+        public int compareTo(Measurement arg0) {
+            return rssi.compareTo(arg0.rssi);
+        }
+    }
+
+    public static void setSampleExpirationMilliseconds(long newSampleExpirationMilliseconds) {
+        sampleExpirationMilliseconds = newSampleExpirationMilliseconds;
+    }
+
+}
