diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index 2000a4d8..a27fcf75 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -28,6 +28,8 @@
             android:exported="false"
             />
 
+        <service android:name=".service.ScanJob"
+                android:permission="android.permission.BIND_JOB_SERVICE" />
     </application>
 
 </manifest>
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 22fff999..be26ac11 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -61,6 +61,9 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CopyOnWriteArraySet;
 
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanState;
+
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
@@ -125,7 +128,7 @@
     private boolean mBackgroundModeUninitialized = true;
     private boolean mMainProcess = false;
     private Boolean mScannerInSameProcess = null;
-
+    private boolean mScheduledScanJobsEnabled = false;
 
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
@@ -288,6 +291,26 @@ protected BeaconManager(Context context) {
         this.beaconParsers.add(new AltBeaconParser());
     }
 
+
+    public void setEnableScheduledScanJobs(boolean enabled) {
+        this.mScheduledScanJobsEnabled = enabled;
+    }
+    public boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+    public long getBackgroundScanPeriod() {
+        return backgroundScanPeriod;
+    }
+    public long getBackgroundBetweenScanPeriod() {
+        return backgroundBetweenScanPeriod;
+    }
+    public long getForegroundScanPeriod() {
+        return foregroundScanPeriod;
+    }
+    public long getForegroundBetweenScanPeriod() {
+        return foregroundBetweenScanPeriod;
+    }
+
     /***
      * Determines if this BeaconManager instance is associated with the main application process that
      * hosts the user interface.  This is normally true unless the scanning service or another servide
@@ -368,6 +391,11 @@ public void bind(BeaconConsumer consumer) {
             LogManager.w(TAG, "This device does not support bluetooth LE.  Will not start beacon scanning.");
             return;
         }
+        if (mScheduledScanJobsEnabled) {
+            LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
+            consumer.onBeaconServiceConnect();
+            return;
+        }
         synchronized (consumers) {
             ConsumerInfo newConsumerInfo = new ConsumerInfo();
             ConsumerInfo alreadyBoundConsumerInfo = consumers.putIfAbsent(consumer, newConsumerInfo);
@@ -715,15 +743,20 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
-        Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             rangedRegions.add(region);
         }
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
+        }
     }
 
     /**
@@ -745,12 +778,6 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             Region regionToRemove = null;
             for (Region rangedRegion : rangedRegions) {
@@ -760,6 +787,17 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             }
             rangedRegions.remove(regionToRemove);
         }
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
+        }
     }
 
     /**
@@ -821,13 +859,18 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
+            Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
         }
-        LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
-        Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         if (isScannerInDifferentProcess()) {
             MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
         }
@@ -854,12 +897,17 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         if (isScannerInDifferentProcess()) {
             MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
         }
@@ -881,14 +929,19 @@ public void updateScanPeriods() throws RemoteException {
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
-        Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
         LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
         LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
-        msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
+            msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
+        }
     }
 
     private String callbackPackageName() {
diff --git a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
index a93e8fb2..303efdd4 100644
--- a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
@@ -2,6 +2,7 @@
 
 import org.altbeacon.beacon.Beacon;
 
+import java.io.Serializable;
 import java.util.HashMap;
 
 /**
@@ -9,7 +10,7 @@
  * merges them together depending on configured beacon parsers
  * Created by dyoung on 5/5/15.
  */
-public class ExtraDataBeaconTracker {
+public class ExtraDataBeaconTracker implements Serializable {
     private static final String TAG = "BeaconTracker";
     // This is a lookup table to find tracked beacons by the calculated beacon key
     private HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<String,HashMap<Integer,Beacon>>();
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index 0c1ad59e..8a940ba1 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -26,12 +26,13 @@
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
-public class RangeState {
+public class RangeState implements Serializable {
     private static final String TAG = "RangeState";
     private final Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index a5b321cb..e19e92cf 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -6,9 +6,10 @@
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
-public class RangedBeacon {
+public class RangedBeacon implements Serializable {
 
     private static final String TAG = "RangedBeacon";
     public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
@@ -19,18 +20,9 @@
     private boolean mTracked = true;
     protected long lastTrackedTimeMillis = 0;
     Beacon mBeacon;
-    protected RssiFilter filter = null;
+    protected transient RssiFilter mFilter = null;
 
     public RangedBeacon(Beacon beacon) {
-        //set RSSI filter
-        try {
-            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
-            filter = (RssiFilter)cons.newInstance();
-        } catch (Exception e) {
-            LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
-        }
-
-        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
         updateBeacon(beacon);
     }
 
@@ -53,10 +45,11 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-        if (!filter.noMeasurementsAvailable()) {
-            double runningAverage = filter.calculateRssi();
-            mBeacon.setRunningAverageRssi(runningAverage);
-            LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
+         if (!getFilter().noMeasurementsAvailable()) {
+             double runningAverage = getFilter().calculateRssi();
+             mBeacon.setRunningAverageRssi(runningAverage);
+             LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
         else {
             LogManager.d(TAG, "No measurements available to calculate running average");
@@ -69,7 +62,7 @@ public void addMeasurement(Integer rssi) {
         if (rssi != 127) {
             mTracked = true;
             lastTrackedTimeMillis = SystemClock.elapsedRealtime();
-            filter.addMeasurement(rssi);
+            getFilter().addMeasurement(rssi);
         }
     }
 
@@ -83,7 +76,7 @@ public static void setMaxTrackinAge(int maxTrackinAge) {
     }
 
     public boolean noMeasurementsAvailable() {
-        return filter.noMeasurementsAvailable();
+        return getFilter().noMeasurementsAvailable();
     }
 
     public long getTrackingAge() {
@@ -94,4 +87,17 @@ public boolean isExpired() {
         return getTrackingAge() > maxTrackingAge;
     }
 
+    private RssiFilter getFilter() {
+        if (mFilter == null) {
+            //set RSSI filter
+            try {
+            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
+                mFilter = (RssiFilter)cons.newInstance();
+            } catch (Exception e) {
+                LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
+            }
+        }
+        return mFilter;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
new file mode 100644
index 00000000..9aa95ea1
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -0,0 +1,469 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.job.JobInfo;
+import android.app.job.JobParameters;
+import android.app.job.JobScheduler;
+import android.app.job.JobService;
+import android.bluetooth.BluetoothDevice;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.os.Handler;
+import android.os.PersistableBundle;
+import android.os.SystemClock;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.BuildConfig;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+import org.altbeacon.beacon.utils.ProcessUtils;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * Created by dyoung on 3/24/17.
+ */
+
+/**
+ * Only one instance of this will be active, even with multiple jobIds.  If one job
+ * is already running when another is scheduled to start, onStartJob gets called again on the same
+ * instance.
+ *
+ * If the OS decides to create a new instance, it will call onStopJob() on the old instance
+ */
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+public class ScanJob extends JobService {
+    private static final String TAG = ScanJob.class.getSimpleName();
+    private ScanState mScanState;
+    private Handler mStopHandler = new Handler();
+
+    // Fields to be refactord to a shared class with BeaconService
+    private ExecutorService mExecutor;
+    private BeaconManager mBeaconManager;
+    private CycledLeScanner mCycledScanner;
+    private MonitoringStatus mMonitoringStatus;
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
+    private List<Beacon> mSimulatedScanData = null;  // not supported for scan jobs
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private boolean mInitialized = false;
+
+    @Override
+    public boolean onStartJob(final JobParameters jobParameters) {
+        JobScheduler jobScheduler = (JobScheduler) this.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        if (jobParameters.getJobId() == sPeriodicScanJobId) {
+            LogManager.i(TAG, "Running periodic scan job: instance is "+this);
+        }
+        else {
+            LogManager.i(TAG, "Running immediate scan job: instance is "+this);
+        }
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
+        boolean startedScan = false;
+        if (mInitialized) {
+            LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
+            startedScan = restartScanning();
+        }
+        else {
+            startedScan = startScanning();
+        }
+        mStopHandler.removeCallbacksAndMessages(null);
+
+        if (startedScan) {
+            LogManager.i(TAG, "Scan job running for "+mScanState.getScanJobRuntimeMillis()+" millis");
+            mStopHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    LogManager.i(TAG, "Scan job runtime expired");
+                    stopScanning();
+                    mScanState.save();
+                    ScanJob.this.jobFinished(jobParameters , false);
+                }
+            }, mScanState.getScanJobRuntimeMillis());
+        }
+        else {
+            LogManager.i(TAG, "No monitored or ranged regions. Scan job complete.");
+            ScanJob.this.jobFinished(jobParameters , false);
+        }
+        return true;
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters params) {
+        if (params.getJobId() == sPeriodicScanJobId) {
+            LogManager.i(TAG, "onStopJob called for periodic scan");
+        }
+        else {
+            LogManager.i(TAG, "onStopJob called for immediate scan");
+        }
+        // Cancel the stop timer.  The OS is stopping prematurely
+        mStopHandler.removeCallbacksAndMessages(null);
+        stopScanning();
+        return false;
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean restartScanning() {
+        mScanState = ScanState.restore(ScanJob.this);
+        mScanState.setLastScanStartTimeMillis(System.currentTimeMillis());
+        mMonitoringStatus = mScanState.getMonitoringStatus();
+        mRangedRegionState = mScanState.getRangedRegionState();
+        mBeaconParsers = mScanState.getBeaconParsers();
+        mExtraDataBeaconTracker = mScanState.getExtraBeaconDataTracker();
+        if (mCycledScanner == null) {
+            mCycledScanner = CycledLeScanner.createScanner(ScanJob.this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
+                    BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mScanState.getBackgroundMode(), mCycledLeScanCallback, null);
+        }
+        mCycledScanner.setScanPeriods(mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod(),
+                                      mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod(),
+                                      mScanState.getBackgroundMode());
+        if (mRangedRegionState.size() > 0 || mMonitoringStatus.regions().size() > 0) {
+            mCycledScanner.start();
+            return true;
+        }
+        else {
+            mCycledScanner.stop();
+            return false;
+        }
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean startScanning() {
+        // Create a private executor so we don't compete with threads used by AsyncTask
+        // This uses fewer threads than the default executor so it won't hog CPU
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
+        mBeaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        mBeaconManager.setScannerInSameProcess(true);
+        if (mBeaconManager.isMainProcess()) {
+            LogManager.i(TAG, "scanJob version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+        }
+        else {
+            LogManager.i(TAG, "beaconScanJob library version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(ScanJob.this);
+            LogManager.i(TAG, "beaconScanJob PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
+        }
+        ModelSpecificDistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(ScanJob.this, BeaconManager.getDistanceModelUpdateUrl());
+        Beacon.setDistanceCalculator(defaultDistanceCalculator);
+        return restartScanning();
+    }
+
+    private void stopScanning() {
+        mCycledScanner.stop();
+        mCycledScanner.destroy();
+        mInitialized = false;
+        LogManager.d(TAG, "Scanning stopped");
+    }
+
+
+    //TODO: Move this and the static methods below to its own utility class
+
+    /*
+        Periodic scan jobs are used in general, but they cannot be started immediately.  So we have
+        a second immediate scan job to kick off when scanning gets started or settings changed.
+        Once the periodic one gets run, the immediate is cancelled.
+     */
+    private static int sImmediateScanJobId = 1; // TODO: make this configurable
+    private static int sPeriodicScanJobId = 2; // TODO: make this configurable
+
+    public static void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
+        scanState.applyChanges(beaconManager);
+        LogManager.d(TAG, "Applying scan job settings with background mode "+scanState.getBackgroundMode());
+        schedule(context, scanState);
+    }
+
+    public static void applySettingsToScheduledJob(Context context, BeaconManager beaconManager) {
+        LogManager.d(TAG, "Applying settings to ScanJob");
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        ScanState scanState = ScanState.restore(context);
+        applySettingsToScheduledJob(context, beaconManager, scanState);
+    }
+    /**
+     *
+     * @param context
+     */
+    public static void schedule(Context context, ScanState scanState) {
+        long betweenScanPeriod = scanState.getScanJobIntervalMillis() - scanState.getScanJobRuntimeMillis();
+
+        long millisToNextJobStart = scanState.getScanJobIntervalMillis();
+        if (betweenScanPeriod > 0) {
+            // If we pause between scans, then we need to start scanning on a normalized time
+            millisToNextJobStart = (SystemClock.elapsedRealtime() % scanState.getScanJobIntervalMillis());
+        }
+        else {
+            millisToNextJobStart = 0;
+        }
+
+        if (millisToNextJobStart < 50) {
+            // always wait a little bit to start scanning in case settings keep changing.
+            // by user restarting settings and scanning.  50ms should be fine
+            millisToNextJobStart = 50;
+        }
+
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+
+        if (scanState.getBackgroundMode()) {
+            LogManager.d(TAG, "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
+            jobScheduler.cancel(sImmediateScanJobId);
+        }
+        else {
+            // If we are in the foreground, and we want to start a scan soon, we will schedule an
+            // immediat job
+            if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
+                // If the next time we want to scan is less than 50ms from the periodic scan cycle, then]
+                // we schedule it for that specific time.
+                LogManager.d(TAG, "Scheduling immediate ScanJob to run in "+millisToNextJobStart+" millis");
+                JobInfo immediateJob = new JobInfo.Builder(sImmediateScanJobId, new ComponentName(context, ScanJob.class))
+                        .setPersisted(true) // This makes it restart after reboot
+                        .setExtras(new PersistableBundle())
+                        .setMinimumLatency(millisToNextJobStart)
+                        .setOverrideDeadline(millisToNextJobStart).build();
+                int error = jobScheduler.schedule(immediateJob);
+                if (error < 0) {
+                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+                }
+            }
+        }
+
+        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(sPeriodicScanJobId, new ComponentName(context, ScanJob.class))
+                .setPersisted(true) // This makes it restart after reboot
+                .setExtras(new PersistableBundle());
+
+        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            // ON Android N+ we specify a tolerance of 0ms (capped at 5% by the OS) to ensure
+            // our scans happen within 5% of the schduled time.
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0l).build();
+        }
+        else {
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis()).build();
+        }
+
+        LogManager.d(TAG, "Scheduling ScanJob to run every "+scanState.getScanJobIntervalMillis()+" millis");
+        int error = jobScheduler.schedule(periodicJobBuilder.build());
+        if (error < 0) {
+            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+        }
+    }
+
+  // ***********************
+  // Code below here copied from BeaconService -- refactor to a common class
+
+
+    protected void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
+        //flatMap all beacon parsers
+        boolean matchBeaconsByServiceUUID = true;
+        if (mBeaconManager.getBeaconParsers() != null) {
+            newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
+            for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
+                if (beaconParser.getExtraDataParsers().size() > 0) {
+                    matchBeaconsByServiceUUID = false;
+                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
+                }
+            }
+        }
+        mBeaconParsers = newBeaconParsers;
+        //initialize the extra data beacon tracker
+        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+    }
+    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+        @Override
+        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+
+            NonBeaconLeScanCallback nonBeaconLeScanCallback = mBeaconManager.getNonBeaconLeScanCallback();
+
+            try {
+                new ScanJob.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
+                        new ScanJob.ScanData(device, rssi, scanRecord));
+            } catch (RejectedExecutionException e) {
+                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+            }
+        }
+
+        @Override
+        public void onCycleEnd() {
+            mDistinctPacketDetector.clearDetections();
+            mMonitoringStatus.updateNewlyOutside();
+            processRangeData();
+            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
+            if (mSimulatedScanData != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
+
+                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : mSimulatedScanData) {
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
+                }
+            }
+            if (BeaconManager.getBeaconSimulator() != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                            processBeaconFromScan(beacon);
+                        }
+                    } else {
+                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                    }
+                } else {
+                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+                }
+            }
+        }
+    };
+
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                rangeState.getCallback().call(ScanJob.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+    private void processBeaconFromScan(Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions = null;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+
+
+    private class ScanData {
+        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        int rssi;
+        BluetoothDevice device;
+        byte[] scanRecord;
+    }
+
+    private class ScanProcessor extends AsyncTask<ScanJob.ScanData, Void, Void> {
+        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
+            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
+        }
+
+        @Override
+        protected Void doInBackground(ScanJob.ScanData... params) {
+            ScanJob.ScanData scanData = params[0];
+            Beacon beacon = null;
+
+            for (BeaconParser parser : ScanJob.this.mBeaconParsers) {
+                beacon = parser.fromScanData(scanData.scanRecord,
+                        scanData.rssi, scanData.device);
+
+                if (beacon != null) {
+                    break;
+                }
+            }
+            if (beacon != null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                }
+                mDetectionTracker.recordDetection();
+                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
+                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
+                            scanData.scanRecord)) {
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
+                    }
+                }
+                processBeaconFromScan(beacon);
+            } else {
+                if (mNonBeaconLeScanCallback != null) {
+                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+                }
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+        }
+
+        @Override
+        protected void onPreExecute() {
+        }
+
+        @Override
+        protected void onProgressUpdate(Void... values) {
+        }
+    }
+
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<Region>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanState.java b/src/main/java/org/altbeacon/beacon/service/ScanState.java
new file mode 100644
index 00000000..25f8264a
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanState.java
@@ -0,0 +1,279 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+import android.util.Log;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InvalidClassException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static android.content.Context.MODE_PRIVATE;
+
+/**
+ * Stores the full state of scanning for the libary, including all settings so it can be ressurrected easily
+ * for running from a scheduled job
+ *
+ * Created by dyoung on 3/26/17.
+ */
+
+public class ScanState implements Serializable {
+    private static final String TAG = ScanState.class.getSimpleName();
+    private static final String STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state";
+    public static int MIN_SCAN_JOB_INTERVAL_MILLIS = 300000; //  5 minutes
+
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private transient MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+    private long mForegroundBetweenScanPeriod;
+    private long mBackgroundBetweenScanPeriod;
+    private long mForegroundScanPeriod;
+    private long mBackgroundScanPeriod;
+    private boolean mBackgroundMode;
+    private long mLastScanStartTimeMillis = 0l;
+    private transient Context mContext;
+
+    public Boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+
+    public void setBackgroundMode(Boolean backgroundMode) {
+        mBackgroundMode = backgroundMode;
+    }
+
+    public Long getBackgroundBetweenScanPeriod() {
+        return mBackgroundBetweenScanPeriod;
+    }
+
+    public void setBackgroundBetweenScanPeriod(Long backgroundBetweenScanPeriod) {
+        mBackgroundBetweenScanPeriod = backgroundBetweenScanPeriod;
+    }
+
+    public Long getBackgroundScanPeriod() {
+        return mBackgroundScanPeriod;
+    }
+
+    public void setBackgroundScanPeriod(Long backgroundScanPeriod) {
+        mBackgroundScanPeriod = backgroundScanPeriod;
+    }
+
+    public Long getForegroundBetweenScanPeriod() {
+        return mForegroundBetweenScanPeriod;
+    }
+
+    public void setForegroundBetweenScanPeriod(Long foregroundBetweenScanPeriod) {
+        mForegroundBetweenScanPeriod = foregroundBetweenScanPeriod;
+    }
+
+    public Long getForegroundScanPeriod() {
+        return mForegroundScanPeriod;
+    }
+
+    public void setForegroundScanPeriod(Long foregroundScanPeriod) {
+        mForegroundScanPeriod = foregroundScanPeriod;
+    }
+
+    public ScanState(Context context) {
+        mContext = context;
+    }
+
+    public MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    public void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    public Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    public void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        mRangedRegionState = rangedRegionState;
+    }
+
+    public ExtraDataBeaconTracker getExtraBeaconDataTracker() {
+        return mExtraBeaconDataTracker;
+    }
+
+    public void setExtraBeaconDataTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraBeaconDataTracker = extraDataBeaconTracker;
+    }
+
+    public Set<BeaconParser> getBeaconParsers() {
+        return mBeaconParsers;
+    }
+
+    public void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    public long getLastScanStartTimeMillis() {
+        return mLastScanStartTimeMillis;
+    }
+    public void setLastScanStartTimeMillis(long time) {
+        mLastScanStartTimeMillis = time;
+    }
+
+    public static ScanState restore(Context context) {
+        ScanState scanState = null;
+        synchronized (ScanState.class) {
+            FileInputStream inputStream = null;
+            ObjectInputStream objectInputStream = null;
+            try {
+                inputStream = context.openFileInput(STATUS_PRESERVATION_FILE_NAME);
+                objectInputStream = new ObjectInputStream(inputStream);
+                scanState = (ScanState) objectInputStream.readObject();
+                scanState.mContext = context;
+                ;
+            } catch (IOException | ClassNotFoundException | ClassCastException e) {
+                if (e instanceof InvalidClassException) {
+                    LogManager.d(TAG, "Serialized ScanState has wrong class. Just ignoring saved state...");
+                }
+                else {
+                    LogManager.e(TAG, "Deserialization exception");
+                    Log.e(TAG, "error: ", e);
+                }
+
+            } finally {
+                if (null != inputStream) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectInputStream != null) {
+                    try {
+                        objectInputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            if (scanState == null) {
+                scanState = new ScanState(context);
+
+            }
+            if (scanState.mExtraBeaconDataTracker == null) {
+                scanState.mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+            }
+            scanState.mMonitoringStatus = MonitoringStatus.getInstanceForApplication(context);
+            LogManager.d(TAG, "Scan state restore regions: monitored="+scanState.getMonitoringStatus().regions().size()+" ranged="+scanState.getRangedRegionState().keySet().size());
+            return scanState;
+        }
+    }
+
+    public void save() {
+        synchronized (ScanState.class) {
+            // TODO: need to limit how big this object is somehow.
+            // Impose limits on ranged and monitored regions?
+            FileOutputStream outputStream = null;
+            ObjectOutputStream objectOutputStream = null;
+            try {
+                outputStream = mContext.openFileOutput(STATUS_PRESERVATION_FILE_NAME, MODE_PRIVATE);
+                objectOutputStream = new ObjectOutputStream(outputStream);
+                objectOutputStream.writeObject(this);
+
+            } catch (IOException e) {
+                LogManager.e(TAG, "Error while saving scan status to file: ", e.getMessage());
+                Log.e(TAG, "error: ", e);
+            } finally {
+                if (null != outputStream) {
+                    try {
+                        outputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectOutputStream != null) {
+                    try {
+                        objectOutputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            mMonitoringStatus.saveMonitoringStatusIfOn();
+        }
+    }
+
+    public int getScanJobIntervalMillis() {
+        long cyclePeriodMillis;
+        if (getBackgroundMode()) {
+            cyclePeriodMillis = getBackgroundScanPeriod()+getBackgroundBetweenScanPeriod();
+        }
+        else {
+            cyclePeriodMillis = getForegroundScanPeriod()+getForegroundBetweenScanPeriod();
+        }
+        int scanJobIntervalMillis = MIN_SCAN_JOB_INTERVAL_MILLIS;
+        if (cyclePeriodMillis > MIN_SCAN_JOB_INTERVAL_MILLIS) {
+            scanJobIntervalMillis = (int) cyclePeriodMillis;
+        }
+        return scanJobIntervalMillis;
+    }
+
+    public int getScanJobRuntimeMillis() {
+        long scanPeriodMillis;
+        LogManager.d(TAG, "ScanState says background mode for ScanJob is "+getBackgroundMode());
+        if (getBackgroundMode()) {
+            scanPeriodMillis = getBackgroundScanPeriod();
+        }
+        else {
+            scanPeriodMillis = getForegroundScanPeriod();
+        }
+        if (!getBackgroundMode()) {
+            // if we are in the foreground, we keep the scan job going for the minimum interval
+            if (scanPeriodMillis < MIN_SCAN_JOB_INTERVAL_MILLIS) {
+                return MIN_SCAN_JOB_INTERVAL_MILLIS;
+            }
+        }
+        return (int) scanPeriodMillis;
+    }
+
+
+
+    public void applyChanges(BeaconManager beaconManager) {
+        mBeaconParsers = new HashSet<>(beaconManager.getBeaconParsers());
+        mForegroundScanPeriod = beaconManager.getForegroundScanPeriod();
+        mForegroundBetweenScanPeriod = beaconManager.getForegroundBetweenScanPeriod();
+        mBackgroundScanPeriod = beaconManager.getBackgroundScanPeriod();
+        mBackgroundBetweenScanPeriod = beaconManager.getBackgroundBetweenScanPeriod();
+        mBackgroundMode = beaconManager.getBackgroundMode();
+
+        ArrayList<Region> existingMonitoredRegions = new ArrayList<>(mMonitoringStatus.regions());
+        ArrayList<Region> existingRangedRegions = new ArrayList<>(mRangedRegionState.keySet());
+        ArrayList<Region> newMonitoredRegions = new ArrayList<>(beaconManager.getMonitoredRegions());
+        ArrayList<Region> newRangedRegions = new ArrayList<>(beaconManager.getRangedRegions());
+        LogManager.d(TAG, "ranged regions: old="+existingRangedRegions.size()+" new="+newRangedRegions.size());
+        LogManager.d(TAG, "monitored regions: old="+existingMonitoredRegions.size()+" new="+newMonitoredRegions.size());
+
+        for (Region newRangedRegion: newRangedRegions) {
+            if (!existingRangedRegions.contains(newRangedRegion)) {
+                LogManager.d(TAG, "Starting ranging region: "+newRangedRegion);
+                mRangedRegionState.put(newRangedRegion, new RangeState(new Callback(mContext.getPackageName())));
+            }
+        }
+        for (Region existingRangedRegion: existingRangedRegions) {
+            if (!newRangedRegions.contains(existingRangedRegion)) {
+                LogManager.d(TAG, "Stopping ranging region: "+existingRangedRegion);
+                mRangedRegionState.remove(existingRangedRegion);
+            }
+        }
+        LogManager.d(TAG, "Updated state with "+newRangedRegions.size()+" ranging regions and "+newMonitoredRegions.size()+" monitoring regions.");
+
+        this.save();
+    }
+
+}
\ No newline at end of file
