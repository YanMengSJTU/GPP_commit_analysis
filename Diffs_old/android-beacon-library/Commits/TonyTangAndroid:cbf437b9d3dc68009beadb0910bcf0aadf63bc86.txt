diff --git a/eclipse-support/project.properties b/eclipse-support/project.properties
index 9ca1deb7..c6f7ffdf 100644
--- a/eclipse-support/project.properties
+++ b/eclipse-support/project.properties
@@ -9,7 +9,6 @@
 #
 # To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
 #proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
 # Project target.
 target=android-28
 android.library=true
diff --git a/gradle.properties b/gradle.properties
index 129c5292..f3f75c7a 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,11 +1,11 @@
-project_vendor = altbeacon
-project_vendor_name = altbeacon
-project_description = Allows Android apps to interact with BLE beacons
-project_url = https://github.com/AltBeacon/android-beacon-library
-project_scm = https://github.com/AltBeacon/android-beacon-library
-project_issues_url = https://github.com/AltBeacon/android-beacon-library/issues
-project_connection = scm:git:https://github.com/AltBeacon/android-beacon-library.git
-project_dev_connection = scm:git:git@github.com:AltBeacon/android-beacon-library.git
-project_bintray_repo = android
-project_bintray_org = altbeacon
+project_vendor=altbeacon
+project_vendor_name=altbeacon
+project_description=Allows Android apps to interact with BLE beacons
+project_url=https://github.com/AltBeacon/android-beacon-library
+project_scm=https://github.com/AltBeacon/android-beacon-library
+project_issues_url=https://github.com/AltBeacon/android-beacon-library/issues
+project_connection=scm:git:https://github.com/AltBeacon/android-beacon-library.git
+project_dev_connection=scm:git:git@github.com:AltBeacon/android-beacon-library.git
+project_bintray_repo=android
+project_bintray_org=altbeacon
 android.enableUnitTestBinaryResources=true
\ No newline at end of file
diff --git a/gradle/bintray.gradle b/gradle/bintray.gradle
index 8f653e8c..4b7dc0e2 100644
--- a/gradle/bintray.gradle
+++ b/gradle/bintray.gradle
@@ -16,7 +16,7 @@ bintray {
     pkg {
         repo = attr 'project_bintray_repo'
         name = attr 'name'
-        userOrg =  attr 'project_bintray_org'
+        userOrg = attr 'project_bintray_org'
         desc = attr 'project_description'
         licenses = ['Apache-2.0']
         labels = ['android', 'beacon', 'BLE', 'bluetooth']
diff --git a/gradle/package.gradle b/gradle/package.gradle
index c64d05f6..8e74c804 100644
--- a/gradle/package.gradle
+++ b/gradle/package.gradle
@@ -34,7 +34,7 @@ android.libraryVariants.all { variant ->
         ext.androidJar =
                 "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
         //Refer to https://stackoverflow.com/a/50833438/4068957
-        doFirst { classpath = files(variant.javaCompile.classpath.files, ext.androidJar)}
+        doFirst { classpath = files(variant.javaCompile.classpath.files, ext.androidJar) }
         options.linksOffline "http://d.android.com/reference/", "${android.sdkDirectory}/docs/reference"
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
diff --git a/lib/build.gradle b/lib/build.gradle
index 1d483c1e..defc8f75 100644
--- a/lib/build.gradle
+++ b/lib/build.gradle
@@ -50,7 +50,7 @@ configurations {
 }
 
 dependencies {
-    implementation fileTree ( dir: 'libs', include: ['*.jar'] )
+    implementation fileTree(dir: 'libs', include: ['*.jar'])
     implementation 'com.android.support:support-v4:28.0.0'
     implementation 'com.android.support:support-annotations:28.0.0'
 
@@ -65,7 +65,7 @@ dependencies {
     androidTestImplementation 'com.android.support.test:rules:1.0.2'
     androidTestImplementation 'org.apache.commons:commons-math3:3.6.1'
     androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
-    
+
     doclava 'com.google.doclava:doclava:1.0.6'
 }
 
diff --git a/lib/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java b/lib/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java
index b93ede2e..b01a2276 100644
--- a/lib/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java
+++ b/lib/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java
@@ -82,20 +82,20 @@
  */
 @RunWith(AndroidJUnit4.class)
 public class NotifierSetCopyBenchmarksTest {
-    private static final Set<RangeNotifier> LARGE_SET  = buildSet(20);
+    private static final Set<RangeNotifier> LARGE_SET = buildSet(20);
 
     private static final Set<RangeNotifier> MEDIUM_SET = buildSet(10);
 
     private static final Set<RangeNotifier> SINGLE_SET = buildSet(1);
 
-    private static final Set<RangeNotifier> SMALL_SET  = buildSet(3);
+    private static final Set<RangeNotifier> SMALL_SET = buildSet(3);
 
     private static final String STAT_FORMAT =
             "| %15s | %4d | %4d | %7d | %7d | %7d | %#8.1f | %.5e |";
 
     private static final String STAT_HEADER =
             "|      Type       | Size |   N   |   Min   |   Max   |  Mean   | Std. Dev |  Variance   |\n" +
-            "|-----------------|------|-------|---------|---------|---------|----------|-------------|";
+                    "|-----------------|------|-------|---------|---------|---------|----------|-------------|";
 
     private static final String TAG = "BenchmarkTests";
 
diff --git a/lib/src/main/AndroidManifest.xml b/lib/src/main/AndroidManifest.xml
index 1da97bff..d7828cd5 100644
--- a/lib/src/main/AndroidManifest.xml
+++ b/lib/src/main/AndroidManifest.xml
@@ -1,9 +1,13 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="org.altbeacon.beacon"
+          package="org.altbeacon.beacon"
     >
 
-    <uses-permission android:name="android.permission.BLUETOOTH" android:required="false"/>
-    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:required="false"/>
+    <uses-permission
+        android:name="android.permission.BLUETOOTH"
+        android:required="false"/>
+    <uses-permission
+        android:name="android.permission.BLUETOOTH_ADMIN"
+        android:required="false"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
 
@@ -16,27 +20,37 @@
             </intent-filter>
         </receiver>
 
-        <service android:enabled="true"
+        <service
+            android:name=".service.BeaconService"
+            android:enabled="true"
             android:exported="false"
             android:isolatedProcess="false"
             android:label="beacon"
-            android:name=".service.BeaconService"
             />
 
-        <service android:name=".BeaconIntentProcessor"
+        <service
+            android:name=".BeaconIntentProcessor"
             android:enabled="true"
             android:exported="false"
             />
 
-        <service android:name=".service.ScanJob"
-                android:permission="android.permission.BIND_JOB_SERVICE">
-            <meta-data android:name="immediateScanJobId" android:value="208352939" />
-            <meta-data android:name="periodicScanJobId" android:value="208352940" />
+        <service
+            android:name=".service.ScanJob"
+            android:permission="android.permission.BIND_JOB_SERVICE">
+            <meta-data
+                android:name="immediateScanJobId"
+                android:value="208352939"/>
+            <meta-data
+                android:name="periodicScanJobId"
+                android:value="208352940"/>
         </service>
-  
-        <service android:name="org.altbeacon.bluetooth.BluetoothTestJob"
-            android:permission="android.permission.BIND_JOB_SERVICE" >
-            <meta-data android:name="jobId" android:value="1799803768"/>
+
+        <service
+            android:name="org.altbeacon.bluetooth.BluetoothTestJob"
+            android:permission="android.permission.BIND_JOB_SERVICE">
+            <meta-data
+                android:name="jobId"
+                android:value="1799803768"/>
         </service>
 
     </application>
diff --git a/lib/src/main/java/org/altbeacon/beacon/AltBeacon.java b/lib/src/main/java/org/altbeacon/beacon/AltBeacon.java
index ccfd2777..5afeac49 100644
--- a/lib/src/main/java/org/altbeacon/beacon/AltBeacon.java
+++ b/lib/src/main/java/org/altbeacon/beacon/AltBeacon.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -25,7 +25,6 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.util.Log;
 
 import java.util.ArrayList;
 
@@ -39,11 +38,9 @@
  * group beacons and the third identifier Id3 is used to uniquely identify a specific beacon (in
  * combination with the other two identifiers.)
  *
- * @author  David G. Young
+ * @author David G. Young
  */
 public class AltBeacon extends Beacon {
-    private static final String TAG = "AltBeacon";
-
     /**
      * Required for making object Parcelable.  If you override this class, you must provide an
      * equivalent version of this method.
@@ -58,9 +55,11 @@ public AltBeacon createFromParcel(Parcel in) {
             return new AltBeacon[size];
         }
     };
+    private static final String TAG = "AltBeacon";
 
     /**
      * Copy constructor from base class
+     *
      * @param beacon
      */
     protected AltBeacon(Beacon beacon) {
@@ -86,6 +85,7 @@ protected AltBeacon(Parcel in) {
      * manufacturer.  The manufacturer specifications for the beacon should be checked before using
      * this field, and the manufacturer should be checked against the Beacon#mManufacturer
      * field
+     *
      * @return mfgReserved
      */
     public int getMfgReserved() {
@@ -94,6 +94,7 @@ public int getMfgReserved() {
 
     /**
      * Required for making object Parcelable
+     *
      * @return
      */
     @Override
@@ -104,7 +105,7 @@ public int describeContents() {
     /**
      * Required for making object Parcelable
      **/
-     @Override
+    @Override
     public void writeToParcel(Parcel out, int flags) {
         super.writeToParcel(out, flags);
     }
@@ -130,11 +131,12 @@ public void writeToParcel(Parcel out, int flags) {
         public Beacon build() {
             return new AltBeacon(super.build());
         }
+
         public Builder setMfgReserved(int mfgReserved) {
             if (mBeacon.mDataFields.size() != 0) {
                 mBeacon.mDataFields = new ArrayList<Long>();
             }
-            mBeacon.mDataFields.add((long)mfgReserved);
+            mBeacon.mDataFields.add((long) mfgReserved);
             return this;
         }
     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/AltBeaconParser.java b/lib/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
index 7e98d225..3ef67599 100644
--- a/lib/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
+++ b/lib/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -24,7 +24,6 @@
 package org.altbeacon.beacon;
 
 import android.bluetooth.BluetoothDevice;
-import android.util.Log;
 
 /**
  * A specific beacon parser designed to parse only AltBeacons from raw BLE packets detected by
@@ -53,13 +52,14 @@ public AltBeaconParser() {
         this.setBeaconLayout(BeaconParser.ALTBEACON_LAYOUT);
         this.mIdentifier = "altbeacon";
     }
+
     /**
      * Construct an AltBeacon from a Bluetooth LE packet collected by Android's Bluetooth APIs,
      * including the raw Bluetooth device info
      *
      * @param scanData The actual packet bytes
-     * @param rssi The measured signal strength of the packet
-     * @param device The Bluetooth device that was detected
+     * @param rssi     The measured signal strength of the packet
+     * @param device   The Bluetooth device that was detected
      * @return An instance of an <code>Beacon</code>
      */
     @Override
diff --git a/lib/src/main/java/org/altbeacon/beacon/Beacon.java b/lib/src/main/java/org/altbeacon/beacon/Beacon.java
index f46e9edc..3a77479f 100644
--- a/lib/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/lib/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -34,7 +34,6 @@
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
-
 import java.util.List;
 
 /**
@@ -53,32 +52,46 @@
  * tx power.  It then uses the measured RSSI and calibrated tx power to do a rough
  * distance measurement (the mDistance field)
  *
- * @author  David G. Young
+ * @author David G. Young
  * @see     Region#matchesBeacon(Beacon Beacon)
  */
 public class Beacon implements Parcelable, Serializable {
-    private static final String TAG = "Beacon";
+    /**
+     * Required for making object Parcelable.  If you override this class, you must provide an
+     * equivalent version of this method.
+     */
+    @Deprecated
+    public static final Parcelable.Creator<Beacon> CREATOR
+            = new Parcelable.Creator<Beacon>() {
+        public Beacon createFromParcel(Parcel in) {
+            return new Beacon(in);
+        }
 
+        public Beacon[] newArray(int size) {
+            return new Beacon[size];
+        }
+    };
+    private static final String TAG = "Beacon";
     private static final List<Long> UNMODIFIABLE_LIST_OF_LONG =
             Collections.unmodifiableList(new ArrayList<Long>());
     private static final List<Identifier> UNMODIFIABLE_LIST_OF_IDENTIFIER =
             Collections.unmodifiableList(new ArrayList<Identifier>());
-
     /**
      * Determines whether a the bluetoothAddress (mac address) must be the same for two Beacons
      * to be configured equal.
      */
     protected static boolean sHardwareEqualityEnforced = false;
-
     protected static DistanceCalculator sDistanceCalculator = null;
-
+    /**
+     * Used to attach data to individual Beacons, either locally or in the cloud
+     */
+    protected static BeaconDataFactory beaconDataFactory = new NullBeaconDataFactory();
     /**
      * The a list of the multi-part identifiers of the beacon.  Together, these identifiers signify
      * a unique beacon.  The identifiers are ordered by significance for the purpose of grouping
      * beacons
      */
     protected List<Identifier> mIdentifiers;
-
     /**
      * A list of generic non-identifying data fields included in the beacon advertisement.  Data
      * fields are limited to the size of a Java long, or six bytes.
@@ -90,7 +103,6 @@
      * bytes.
      */
     protected List<Long> mExtraDataFields;
-
     /**
      * A double that is an estimate of how far the Beacon is away in meters.   Note that this number
      * fluctuates quite a bit with RSSI, so despite the name, it is not super accurate.
@@ -106,124 +118,64 @@
      * it is transmitted with each packet to aid in the mDistance estimate
      */
     protected int mTxPower;
-
     /**
      * The Bluetooth mac address
      */
     protected String mBluetoothAddress;
-
-    /**
-     * The number of rssi samples available, if known
-     */
-    private int mRssiMeasurementCount = 0;
-
-    /**
-     * The number of packets detected in the last cycle
-     */
-    private int mPacketCount = 0;
-
-    /**
-     * If multiple RSSI samples were available, this is the running average
-     */
-    private Double mRunningAverageRssi = null;
-
-    /**
-     * Used to attach data to individual Beacons, either locally or in the cloud
-     */
-    protected static BeaconDataFactory beaconDataFactory = new NullBeaconDataFactory();
-
     /**
      * The two byte value indicating the type of beacon that this is, which is used for figuring
      * out the byte layout of the beacon advertisement
      */
     protected int mBeaconTypeCode;
-
     /**
      * A two byte code indicating the beacon manufacturer.  A list of registered manufacturer codes
      * may be found here:
      * https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers
-     *
+     * <p>
      * If the beacon is a GATT-based beacon, this field will be set to -1
      */
     protected int mManufacturer;
-
     /**
      * A 32 bit service uuid for the beacon
-     *
+     * <p>
      * This is valid only for GATT-based beacons.   If the beacon is a manufacturer data-based
      * beacon, this field will be -1
      */
 
     protected int mServiceUuid = -1;
-
     /**
      * The Bluetooth device name.  This is a field transmitted by the remote beacon device separate
      * from the advertisement data
      */
     protected String mBluetoothName;
-
     /**
      * The identifier of the beaconParser used to create this beacon.  Useful for figuring out
      * beacon types.
      */
     protected String mParserIdentifier;
-
     /**
      * An indicator marking this beacon as a potential multi frame beacon.
-     *
+     * <p>
      * This will be set to true if the beacon was parsed by a BeaconParser which has extra
      * data parsers defined.
      */
     protected boolean mMultiFrameBeacon = false;
-
     /**
-     * Required for making object Parcelable.  If you override this class, you must provide an
-     * equivalent version of this method.
-     */
-    @Deprecated
-    public static final Parcelable.Creator<Beacon> CREATOR
-            = new Parcelable.Creator<Beacon>() {
-        public Beacon createFromParcel(Parcel in) {
-            return new Beacon(in);
-        }
-
-        public Beacon[] newArray(int size) {
-            return new Beacon[size];
-        }
-    };
-
-    /**
-     * Sets the DistanceCalculator to use with this beacon
-     * @param dc
+     * The number of rssi samples available, if known
      */
-    public static void setDistanceCalculator(DistanceCalculator dc) {
-        sDistanceCalculator = dc;
-    }
-
+    private int mRssiMeasurementCount = 0;
     /**
-     * Gets the DistanceCalculator to use with this beacon
+     * The number of packets detected in the last cycle
      */
-    public static DistanceCalculator getDistanceCalculator() {
-        return sDistanceCalculator;
-    }
-
+    private int mPacketCount = 0;
     /**
-     * Configures whether a the bluetoothAddress (mac address) must be the same for two Beacons
-     * to be configured equal.  This setting applies to all beacon instances in the same process.
-     * Defaults to false for backward compatibility.
-     *
-     * @param e
+     * If multiple RSSI samples were available, this is the running average
      */
-    public static void setHardwareEqualityEnforced(boolean e) {
-        sHardwareEqualityEnforced = e;
-    }
-
-    public static boolean getHardwareEqualityEnforced() {
-        return sHardwareEqualityEnforced;
-    }
+    private Double mRunningAverageRssi = null;
 
     /**
      * Required for making Beacon parcelable
+     *
      * @param in parcel
      */
     @Deprecated
@@ -261,6 +213,7 @@ protected Beacon(Parcel in) {
 
     /**
      * Copy constructor
+     *
      * @param otherBeacon
      */
     protected Beacon(Beacon otherBeacon) {
@@ -292,9 +245,58 @@ protected Beacon() {
         mExtraDataFields = new ArrayList<Long>(1);
     }
 
+    /**
+     * Gets the DistanceCalculator to use with this beacon
+     */
+    public static DistanceCalculator getDistanceCalculator() {
+        return sDistanceCalculator;
+    }
+
+    /**
+     * Sets the DistanceCalculator to use with this beacon
+     *
+     * @param dc
+     */
+    public static void setDistanceCalculator(DistanceCalculator dc) {
+        sDistanceCalculator = dc;
+    }
+
+    public static boolean getHardwareEqualityEnforced() {
+        return sHardwareEqualityEnforced;
+    }
+
+    /**
+     * Configures whether a the bluetoothAddress (mac address) must be the same for two Beacons
+     * to be configured equal.  This setting applies to all beacon instances in the same process.
+     * Defaults to false for backward compatibility.
+     *
+     * @param e
+     */
+    public static void setHardwareEqualityEnforced(boolean e) {
+        sHardwareEqualityEnforced = e;
+    }
+
+    /**
+     * Estimate the distance to the beacon using the DistanceCalculator set on this class.  If no
+     * DistanceCalculator has been set, return -1 as the distance.
+     *
+     * @param txPower
+     * @param bestRssiAvailable
+     * @return
+     * @see org.altbeacon.beacon.distance.DistanceCalculator
+     */
+    protected static Double calculateDistance(int txPower, double bestRssiAvailable) {
+        if (Beacon.getDistanceCalculator() != null) {
+            return Beacon.getDistanceCalculator().calculateDistance(txPower, bestRssiAvailable);
+        } else {
+            LogManager.e(TAG, "Distance calculator not set.  Distance will bet set to -1");
+            return -1.0;
+        }
+    }
 
     /**
      * Sets the measurement count that went into the rssi sample
+     *
      * @param rssiMeasurementCount
      */
     public void setRssiMeasurementCount(int rssiMeasurementCount) {
@@ -310,6 +312,7 @@ public int getPacketCount() {
 
     /**
      * Sets the packet detections in the last ranging cycle
+     *
      * @param packetCount
      */
     public void setPacketCount(int packetCount) {
@@ -324,15 +327,6 @@ public int getMeasurementCount() {
         return mRssiMeasurementCount;
     }
 
-    /**
-     * Sets the running average rssi for use in distance calculations
-     * @param rssi the running average rssi
-     */
-    public void setRunningAverageRssi(double rssi) {
-        mRunningAverageRssi = rssi;
-        mDistance = null; // force calculation of accuracy and proximity next time they are requested
-    }
-
     /**
      * @deprecated To be removed in a future release. Use
      * {@link org.altbeacon.beacon.Beacon#getRunningAverageRssi()}
@@ -345,22 +339,24 @@ public double getRunningAverageRssi(double rssi) {
 
     /**
      * Returns the running average rssi
+     *
      * @return double
      */
     public double getRunningAverageRssi() {
-        if (mRunningAverageRssi != null){
+        if (mRunningAverageRssi != null) {
             return mRunningAverageRssi;
         }
         return mRssi;
     }
 
     /**
-     * Sets the most recently measured rssi for use in distance calculations if a running average is
-     * not available
-     * @param rssi
+     * Sets the running average rssi for use in distance calculations
+     *
+     * @param rssi the running average rssi
      */
-    public void setRssi(int rssi) {
-        mRssi = rssi;
+    public void setRunningAverageRssi(double rssi) {
+        mRunningAverageRssi = rssi;
+        mDistance = null; // force calculation of accuracy and proximity next time they are requested
     }
 
     /**
@@ -380,6 +376,7 @@ public int getServiceUuid() {
     /**
      * Returns the specified identifier - 0 indexed
      * Note:  to read id1, call getIdentifier(0);
+     *
      * @param i - index identfier
      * @return identifier
      */
@@ -390,6 +387,7 @@ public Identifier getIdentifier(int i) {
 
     /**
      * Convenience method to get the first identifier
+     *
      * @return
      */
     public Identifier getId1() {
@@ -398,6 +396,7 @@ public Identifier getId1() {
 
     /**
      * Convenience method to get the second identifier
+     *
      * @return
      */
     public Identifier getId2() {
@@ -406,6 +405,7 @@ public Identifier getId2() {
 
     /**
      * Convenience method to get the third identifier
+     *
      * @return
      */
     public Identifier getId3() {
@@ -414,32 +414,33 @@ public Identifier getId3() {
 
     /**
      * Returns the list of data fields transmitted with the advertisement
+     *
      * @return dataFields
      */
     public List<Long> getDataFields() {
         if (mDataFields.getClass().isInstance(UNMODIFIABLE_LIST_OF_LONG)) {
             return mDataFields;
-        }
-        else {
+        } else {
             return Collections.unmodifiableList(mDataFields);
         }
     }
 
     /**
      * Returns the list of data fields transmitted with the advertisement
+     *
      * @return dataFields
      */
     public List<Long> getExtraDataFields() {
         if (mExtraDataFields.getClass().isInstance(UNMODIFIABLE_LIST_OF_LONG)) {
             return mExtraDataFields;
-        }
-        else {
+        } else {
             return Collections.unmodifiableList(mExtraDataFields);
         }
     }
 
     /**
      * Sets extra data fields
+     *
      * @param fields
      */
     public void setExtraDataFields(List<Long> fields) {
@@ -448,13 +449,13 @@ public void setExtraDataFields(List<Long> fields) {
 
     /**
      * Returns the list of identifiers transmitted with the advertisement
+     *
      * @return identifier
      */
     public List<Identifier> getIdentifiers() {
         if (mIdentifiers.getClass().isInstance(UNMODIFIABLE_LIST_OF_IDENTIFIER)) {
             return mIdentifiers;
-        }
-        else {
+        } else {
             return Collections.unmodifiableList(mIdentifiers);
         }
     }
@@ -465,73 +466,91 @@ public void setExtraDataFields(List<Long> fields) {
      * the RSSI and the transmitted power calibration value included in the beacon advertisement.
      * This value is specific to the type of Android device receiving the transmission.
      *
-     * @see #mDistance
      * @return distance
+     * @see #mDistance
      */
     public double getDistance() {
         if (mDistance == null) {
             double bestRssiAvailable = mRssi;
             if (mRunningAverageRssi != null) {
                 bestRssiAvailable = mRunningAverageRssi;
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "Not using running average RSSI because it is null");
             }
             mDistance = calculateDistance(mTxPower, bestRssiAvailable);
         }
         return mDistance;
     }
+
     /**
-     * @see #mRssi
      * @return mRssi
+     * @see #mRssi
      */
     public int getRssi() {
         return mRssi;
     }
+
+    /**
+     * Sets the most recently measured rssi for use in distance calculations if a running average is
+     * not available
+     *
+     * @param rssi
+     */
+    public void setRssi(int rssi) {
+        mRssi = rssi;
+    }
+
     /**
-     * @see #mTxPower
      * @return txPowwer
+     * @see #mTxPower
      */
     public int getTxPower() {
         return mTxPower;
     }
 
     /**
-     * @see #mBeaconTypeCode
      * @return beaconTypeCode
+     * @see #mBeaconTypeCode
      */
-    public int getBeaconTypeCode() { return mBeaconTypeCode; }
+    public int getBeaconTypeCode() {
+        return mBeaconTypeCode;
+    }
 
     /**
-     * @see #mBluetoothAddress
      * @return mBluetoothAddress
+     * @see #mBluetoothAddress
      */
     public String getBluetoothAddress() {
         return mBluetoothAddress;
     }
 
     /**
-     * @see #mBluetoothName
      * @return mBluetoothName
+     * @see #mBluetoothName
      */
     public String getBluetoothName() {
         return mBluetoothName;
     }
 
     /**
-     * @see #mParserIdentifier
      * @return mParserIdentifier
+     * @see #mParserIdentifier
      */
-    public String getParserIdentifier() { return mParserIdentifier; }
+    public String getParserIdentifier() {
+        return mParserIdentifier;
+    }
 
     /**
-     * @see #mMultiFrameBeacon
      * @return mMultiFrameBeacon
+     * @see #mMultiFrameBeacon
      */
-    public boolean isMultiFrameBeacon() { return mMultiFrameBeacon; }
+    public boolean isMultiFrameBeacon() {
+        return mMultiFrameBeacon;
+    }
 
     /**
      * Calculate a hashCode for this beacon
+     *
      * @return
      */
     @Override
@@ -563,6 +582,7 @@ public boolean equals(Object that) {
     /**
      * Requests server-side data for this beacon.  Requires that a BeaconDataFactory be set up with
      * a backend service.
+     *
      * @param notifier interface providing a callback when data are available
      */
     public void requestData(BeaconDataNotifier notifier) {
@@ -571,6 +591,7 @@ public void requestData(BeaconDataNotifier notifier) {
 
     /**
      * Formats a beacon as a string showing only its unique identifiers
+     *
      * @return
      */
     @Override
@@ -581,7 +602,7 @@ public String toString() {
     private StringBuilder toStringBuilder() {
         final StringBuilder sb = new StringBuilder();
         int i = 1;
-        for (Identifier identifier: mIdentifiers) {
+        for (Identifier identifier : mIdentifiers) {
             if (i > 1) {
                 sb.append(" ");
             }
@@ -592,7 +613,7 @@ private StringBuilder toStringBuilder() {
             i++;
         }
         if (mParserIdentifier != null) {
-            sb.append(" type "+mParserIdentifier);
+            sb.append(" type " + mParserIdentifier);
         }
         return sb;
     }
@@ -612,7 +633,7 @@ public int describeContents() {
     @Deprecated
     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mIdentifiers.size());
-        for (Identifier identifier: mIdentifiers) {
+        for (Identifier identifier : mIdentifiers) {
             out.writeString(identifier == null ? null : identifier.toString());
         }
         out.writeDouble(getDistance());
@@ -622,17 +643,17 @@ public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mBeaconTypeCode);
         out.writeInt(mServiceUuid);
         out.writeInt(mDataFields.size());
-        for (Long dataField: mDataFields) {
+        for (Long dataField : mDataFields) {
             out.writeLong(dataField);
         }
         out.writeInt(mExtraDataFields.size());
-        for (Long dataField: mExtraDataFields) {
+        for (Long dataField : mExtraDataFields) {
             out.writeLong(dataField);
         }
         out.writeInt(mManufacturer);
         out.writeString(mBluetoothName);
         out.writeString(mParserIdentifier);
-        out.writeByte((byte) (mMultiFrameBeacon ? 1: 0));
+        out.writeByte((byte) (mMultiFrameBeacon ? 1 : 0));
         out.writeValue(mRunningAverageRssi);
         out.writeInt(mRssiMeasurementCount);
         out.writeInt(mPacketCount);
@@ -641,31 +662,13 @@ public void writeToParcel(Parcel out, int flags) {
     /**
      * Indicates whether this beacon is an "Extra data beacon," meaning one that has no identifiers
      * but has data fields.
+     *
      * @return
      */
     public boolean isExtraBeaconData() {
         return mIdentifiers.size() == 0 && mDataFields.size() != 0;
     }
 
-    /**
-     * Estimate the distance to the beacon using the DistanceCalculator set on this class.  If no
-     * DistanceCalculator has been set, return -1 as the distance.
-     * @see org.altbeacon.beacon.distance.DistanceCalculator
-     *
-     * @param txPower
-     * @param bestRssiAvailable
-     * @return
-     */
-    protected static Double calculateDistance(int txPower, double bestRssiAvailable) {
-        if (Beacon.getDistanceCalculator() != null) {
-            return Beacon.getDistanceCalculator().calculateDistance(txPower, bestRssiAvailable);
-        }
-        else {
-            LogManager.e(TAG, "Distance calculator not set.  Distance will bet set to -1");
-            return -1.0;
-        }
-    }
-
     /**
      * Builder class for Beacon objects. Provides a convenient way to set the various fields of a
      * Beacon
@@ -693,14 +696,15 @@ public Builder() {
 
         /**
          * Builds an instance of this beacon based on parameters set in the Builder
+         *
          * @return beacon
          */
         public Beacon build() {
-            if (mId1!= null) {
+            if (mId1 != null) {
                 mBeacon.mIdentifiers.add(mId1);
-                if (mId2!= null) {
+                if (mId2 != null) {
                     mBeacon.mIdentifiers.add(mId2);
-                    if (mId3!= null) {
+                    if (mId3 != null) {
                         mBeacon.mIdentifiers.add(mId3);
                     }
                 }
@@ -728,11 +732,11 @@ public Builder copyBeaconFields(Beacon beacon) {
         }
 
         /**
-         * @see Beacon#mIdentifiers
          * @param identifiers identifiers to set
          * @return builder
+         * @see Beacon#mIdentifiers
          */
-        public Builder setIdentifiers(List<Identifier>identifiers) {
+        public Builder setIdentifiers(List<Identifier> identifiers) {
             mId1 = null;
             mId2 = null;
             mId3 = null;
@@ -743,6 +747,7 @@ public Builder setIdentifiers(List<Identifier>identifiers) {
         /**
          * Convenience method allowing the first beacon identifier to be set as a String.  It will
          * be parsed into an Identifier object
+         *
          * @param id1String string to parse into an identifier
          * @return builder
          */
@@ -754,6 +759,7 @@ public Builder setId1(String id1String) {
         /**
          * Convenience method allowing the second beacon identifier to be set as a String.  It will
          * be parsed into an Identifier object
+         *
          * @param id2String string to parse into an identifier
          * @return builder
          */
@@ -765,6 +771,7 @@ public Builder setId2(String id2String) {
         /**
          * Convenience method allowing the third beacon identifier to be set as a String.  It will
          * be parsed into an Identifier object
+         *
          * @param id3String string to parse into an identifier
          * @return builder
          */
@@ -774,9 +781,9 @@ public Builder setId3(String id3String) {
         }
 
         /**
-         * @see Beacon#mRssi
          * @param rssi
          * @return builder
+         * @see Beacon#mRssi
          */
         public Builder setRssi(int rssi) {
             mBeacon.mRssi = rssi;
@@ -784,9 +791,9 @@ public Builder setRssi(int rssi) {
         }
 
         /**
-         * @see Beacon#mRssi
          * @param rssi
          * @return builder
+         * @see Beacon#mRssi
          */
         public Builder setRunningAverageRssi(double rssi) {
             mBeacon.mRunningAverageRssi = rssi;
@@ -794,9 +801,9 @@ public Builder setRunningAverageRssi(double rssi) {
         }
 
         /**
-         * @see Beacon#mTxPower
          * @param txPower
          * @return builder
+         * @see Beacon#mTxPower
          */
         public Builder setTxPower(int txPower) {
             mBeacon.mTxPower = txPower;
@@ -804,9 +811,9 @@ public Builder setTxPower(int txPower) {
         }
 
         /**
-         * @see Beacon#mBeaconTypeCode
          * @param beaconTypeCode
          * @return builder
+         * @see Beacon#mBeaconTypeCode
          */
         public Builder setBeaconTypeCode(int beaconTypeCode) {
             mBeacon.mBeaconTypeCode = beaconTypeCode;
@@ -814,9 +821,9 @@ public Builder setBeaconTypeCode(int beaconTypeCode) {
         }
 
         /**
-         * @see Beacon#mServiceUuid
          * @param serviceUuid
          * @return builder
+         * @see Beacon#mServiceUuid
          */
         public Builder setServiceUuid(int serviceUuid) {
             mBeacon.mServiceUuid = serviceUuid;
@@ -824,9 +831,9 @@ public Builder setServiceUuid(int serviceUuid) {
         }
 
         /**
-         * @see Beacon#mBluetoothAddress
          * @param bluetoothAddress
          * @return builder
+         * @see Beacon#mBluetoothAddress
          */
         public Builder setBluetoothAddress(String bluetoothAddress) {
             mBeacon.mBluetoothAddress = bluetoothAddress;
@@ -834,9 +841,9 @@ public Builder setBluetoothAddress(String bluetoothAddress) {
         }
 
         /**
-         * @see Beacon#mDataFields
          * @param dataFields
          * @return builder
+         * @see Beacon#mDataFields
          */
         public Builder setDataFields(List<Long> dataFields) {
             mBeacon.mDataFields = dataFields;
@@ -844,9 +851,9 @@ public Builder setDataFields(List<Long> dataFields) {
         }
 
         /**
-         * @see Beacon#mDataFields
          * @param extraDataFields
          * @return builder
+         * @see Beacon#mDataFields
          */
         public Builder setExtraDataFields(List<Long> extraDataFields) {
             mBeacon.mExtraDataFields = extraDataFields;
@@ -854,9 +861,9 @@ public Builder setExtraDataFields(List<Long> extraDataFields) {
         }
 
         /**
-         * @see Beacon#mManufacturer
          * @param manufacturer
          * @return builder
+         * @see Beacon#mManufacturer
          */
         public Builder setManufacturer(int manufacturer) {
             mBeacon.mManufacturer = manufacturer;
@@ -864,9 +871,9 @@ public Builder setManufacturer(int manufacturer) {
         }
 
         /**
-         * @see Beacon#mBluetoothName
          * @param name
          * @return builder
+         * @see Beacon#mBluetoothName
          */
         public Builder setBluetoothName(String name) {
             mBeacon.mBluetoothName = name;
@@ -874,9 +881,9 @@ public Builder setBluetoothName(String name) {
         }
 
         /**
-         * @see Beacon#mParserIdentifier
          * @param id
          * @return builder
+         * @see Beacon#mParserIdentifier
          */
         public Builder setParserIdentifier(String id) {
             mBeacon.mParserIdentifier = id;
@@ -885,8 +892,8 @@ public Builder setParserIdentifier(String id) {
 
 
         /**
-         * @see Beacon#mMultiFrameBeacon
          * @return multiFrameBeacon
+         * @see Beacon#mMultiFrameBeacon
          */
         public Builder setMultiFrameBeacon(boolean multiFrameBeacon) {
             mBeacon.mMultiFrameBeacon = multiFrameBeacon;
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconConsumer.java b/lib/src/main/java/org/altbeacon/beacon/BeaconConsumer.java
index 2746a5bc..93b484e6 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconConsumer.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconConsumer.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -33,11 +33,11 @@
  * with <code>BeaconManager</code> and provides a callback when the <code>BeaconService</code>
  * is ready to use.  Until this callback is made, ranging and monitoring of beacons is not
  * possible.
- *
+ * <p>
  * In the example below, an Activity implements the <code>BeaconConsumer</code> interface, binds
  * to the service, then when it gets the callback saying the service is ready, it starts ranging.
  *
- *  <pre><code>
+ * <pre><code>
  *  public class RangingActivity extends Activity implements BeaconConsumer {
  *      protected static final String TAG = "RangingActivity";
  *      private BeaconManager beaconManager = BeaconManager.getInstanceForApplication(this);
@@ -74,10 +74,8 @@
  *  }
  *  </code></pre>
  *
- * @see BeaconManager
- *
  * @author David G. Young
- *
+ * @see BeaconManager
  */
 public interface BeaconConsumer {
 
@@ -89,6 +87,7 @@
     /**
      * Called by the BeaconManager to get the context of your Service or Activity.  This method is implemented by Service or Activity.
      * You generally should not override it.
+     *
      * @return the application context of your service or activity
      */
     public Context getApplicationContext();
@@ -96,6 +95,7 @@
     /**
      * Called by the BeaconManager to unbind your BeaconConsumer to the  BeaconService.  This method is implemented by Service or Activity, and
      * You generally should not override it.
+     *
      * @return the application context of your service or activity
      */
     public void unbindService(ServiceConnection connection);
@@ -103,6 +103,7 @@
     /**
      * Called by the BeaconManager to bind your BeaconConsumer to the  BeaconService.  This method is implemented by Service or Activity, and
      * You generally should not override it.
+     *
      * @return the application context of your service or activity
      */
     public boolean bindService(Intent intent, ServiceConnection connection, int mode);
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconData.java b/lib/src/main/java/org/altbeacon/beacon/BeaconData.java
index 28129cd6..5da0855d 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconData.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconData.java
@@ -6,11 +6,18 @@
  */
 public interface BeaconData {
     public Double getLatitude();
+
     public void setLatitude(Double latitude);
-    public void setLongitude(Double longitude);
+
     public Double getLongitude();
+
+    public void setLongitude(Double longitude);
+
     public String get(String key);
+
     public void set(String key, String value);
+
     public void sync(BeaconDataNotifier notifier);
+
     public boolean isDirty();
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconDataNotifier.java b/lib/src/main/java/org/altbeacon/beacon/BeaconDataNotifier.java
index 78ae14d1..ef4c3bee 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconDataNotifier.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconDataNotifier.java
@@ -10,6 +10,7 @@
      * This method is called after a request to get or sync beacon data
      * If fetching data was successful, the data is returned and the exception is null.
      * If fetching of the data is not successful, an exception is provided.
+     *
      * @param beacon
      * @param data
      * @param exception
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/lib/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index 1f63462e..dd8cc872 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -26,28 +26,20 @@
 import android.app.IntentService;
 import android.content.Intent;
 
-import org.altbeacon.beacon.logging.LogManager;
-import org.altbeacon.beacon.service.MonitoringData;
-import org.altbeacon.beacon.service.MonitoringStatus;
-import org.altbeacon.beacon.service.RangingData;
-
-import java.util.Set;
-
 /**
  * Converts internal intents to notifier callbacks
- *
+ * <p>
  * This is used with the BeaconService and supports scanning in a separate process.
  * It is not used with the ScanJob, as an IntentService will not be able to be started in some cases
  * where the app is in the background on Android O.
  *
+ * @hide
  * @see BeaconLocalBroadcastProcessor for the equivalent use with ScanJob.
- *
+ * <p>
  * This IntentService may be running in a different process from the BeaconService, which justifies
  * its continued existence for multi-process service cases.
- *
+ * <p>
  * Internal library class.  Do not use directly from outside the library
- *
- * @hide
  */
 public class BeaconIntentProcessor extends IntentService {
     private static final String TAG = "BeaconIntentProcessor";
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java b/lib/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
index b2fe9039..819f49a1 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -32,45 +32,48 @@
 
 import org.altbeacon.beacon.logging.LogManager;
 
-import java.util.Set;
-
 /**
  * Converts internal intents to notifier callbacks
- *
+ * <p>
  * This is used with ScanJob and supports delivering intents even under Android O background
  * restrictions preventing starting a new IntentService.
- *
+ * <p>
  * It is not used with the BeaconService, if running in a separate process, as local broadcast
  * intents cannot be deliverd across different processes which the BeaconService supports.
  *
+ * @hide
  * @see BeaconIntentProcessor for the equivalent use with BeaconService in a separate process.
- **
+ * *
  * Internal library class.  Do not use directly from outside the library
- *
- * @hide
  */
 public class BeaconLocalBroadcastProcessor {
-    private static final String TAG = "BeaconLocalBroadcastProcessor";
-
     public static final String RANGE_NOTIFICATION = "org.altbeacon.beacon.range_notification";
     public static final String MONITOR_NOTIFICATION = "org.altbeacon.beacon.monitor_notification";
-
+    private static final String TAG = "BeaconLocalBroadcastProcessor";
+    static int registerCallCount = 0;
+    int registerCallCountForInstnace = 0;
     @NonNull
     private Context mContext;
+    private BroadcastReceiver mLocalBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            new IntentHandler().convertIntentsToCallbacks(context, intent);
+        }
+    };
+
     private BeaconLocalBroadcastProcessor() {
 
     }
+
     public BeaconLocalBroadcastProcessor(Context context) {
         mContext = context;
 
     }
 
-    static int registerCallCount = 0;
-    int registerCallCountForInstnace = 0;
     public void register() {
         registerCallCount += 1;
         registerCallCountForInstnace += 1;
-        LogManager.d(TAG, "Register calls: global="+registerCallCount+" instance="+registerCallCountForInstnace);
+        LogManager.d(TAG, "Register calls: global=" + registerCallCount + " instance=" + registerCallCountForInstnace);
         unregister();
         LocalBroadcastManager.getInstance(mContext).registerReceiver(mLocalBroadcastReceiver,
                 new IntentFilter(RANGE_NOTIFICATION));
@@ -81,12 +84,4 @@ public void register() {
     public void unregister() {
         LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mLocalBroadcastReceiver);
     }
-
-
-    private BroadcastReceiver mLocalBroadcastReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            new IntentHandler().convertIntentsToCallbacks(context, intent);
-        }
-    };
 }
\ No newline at end of file
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconManager.java b/lib/src/main/java/org/altbeacon/beacon/BeaconManager.java
index cf351b24..20827dc9 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -49,9 +49,7 @@
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
-import org.altbeacon.beacon.service.ScanJob;
 import org.altbeacon.beacon.service.ScanJobScheduler;
-import org.altbeacon.beacon.service.ScanState;
 import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
@@ -70,15 +68,12 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CopyOnWriteArraySet;
 
-import org.altbeacon.beacon.service.ScanJob;
-import org.altbeacon.beacon.service.ScanState;
-
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
  * when the <code>BeaconService</code> is ready to use.  Until this callback is made, ranging and monitoring
  * of beacons is not possible.
- *
+ * <p>
  * In the example below, an Activity implements the <code>BeaconConsumer</code> interface, binds
  * to the service, then when it gets the callback saying the service is ready, it starts ranging.
  *
@@ -121,39 +116,62 @@
  * @author Andrew Reitz <andrew@andrewreitz.com>
  */
 public class BeaconManager {
+    /**
+     * The default duration in milliseconds of the Bluetooth scan cycle
+     */
+    public static final long DEFAULT_FOREGROUND_SCAN_PERIOD = 1100;
+    /**
+     * The default duration in milliseconds spent not scanning between each Bluetooth scan cycle
+     */
+    public static final long DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD = 0;
+    /**
+     * The default duration in milliseconds of the Bluetooth scan cycle when no ranging/monitoring clients are in the foreground
+     */
+    public static final long DEFAULT_BACKGROUND_SCAN_PERIOD = 10000;
+    /**
+     * The default duration in milliseconds spent not scanning between each Bluetooth scan cycle when no ranging/monitoring clients are in the foreground
+     */
+    public static final long DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD = 5 * 60 * 1000;
+    /**
+     * The default duration in milliseconds of region exit time
+     */
+    public static final long DEFAULT_EXIT_PERIOD = 10000L;
     @NonNull
     private static final String TAG = "BeaconManager";
-
-    @NonNull
-    private final Context mContext;
-
+    /**
+     * Private lock object for singleton initialization protecting against denial-of-service attack.
+     */
+    private static final Object SINGLETON_LOCK = new Object();
     @Nullable
     protected static volatile BeaconManager sInstance = null;
-
-    @NonNull
-    private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<>();
-
     @Nullable
-    private Messenger serviceMessenger = null;
-
+    protected static BeaconSimulator beaconSimulator;
+    protected static String distanceModelUpdateUrl = "https://s3.amazonaws.com/android-beacon-library/android-distance.json";
+    /**
+     * Default class for rssi filter/calculation implementation
+     */
+    protected static Class rssiFilterImplClass = RunningAverageRssiFilter.class;
+    private static boolean sAndroidLScanningDisabled = false;
+    private static boolean sManifestCheckingDisabled = false;
+    private static long sExitRegionPeriod = DEFAULT_EXIT_PERIOD;
     @NonNull
     protected final Set<RangeNotifier> rangeNotifiers = new CopyOnWriteArraySet<>();
-
-    @Nullable
-    protected RangeNotifier dataRequestNotifier = null;
-
     @NonNull
     protected final Set<MonitorNotifier> monitorNotifiers = new CopyOnWriteArraySet<>();
-
+    @NonNull
+    private final Context mContext;
+    @NonNull
+    private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<>();
     @NonNull
     private final ArrayList<Region> rangedRegions = new ArrayList<>();
-
     @NonNull
     private final List<BeaconParser> beaconParsers = new CopyOnWriteArrayList<>();
-
+    @Nullable
+    protected RangeNotifier dataRequestNotifier = null;
+    @Nullable
+    private Messenger serviceMessenger = null;
     @Nullable
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-
     private boolean mRegionStatePersistenceEnabled = true;
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
@@ -161,28 +179,34 @@
     @Nullable
     private Boolean mScannerInSameProcess = null;
     private boolean mScheduledScanJobsEnabled = false;
-    private static boolean sAndroidLScanningDisabled = false;
-    private static boolean sManifestCheckingDisabled = false;
-
     @Nullable
     private Notification mForegroundServiceNotification = null;
     private int mForegroundServiceNotificationId = -1;
+    private long foregroundScanPeriod = DEFAULT_FOREGROUND_SCAN_PERIOD;
+    private long foregroundBetweenScanPeriod = DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD;
+    private long backgroundScanPeriod = DEFAULT_BACKGROUND_SCAN_PERIOD;
+    private long backgroundBetweenScanPeriod = DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD;
 
-    /**
-     * Private lock object for singleton initialization protecting against denial-of-service attack.
-     */
-    private static final Object SINGLETON_LOCK = new Object();
+    protected BeaconManager(@NonNull Context context) {
+        mContext = context.getApplicationContext();
+        checkIfMainProcess();
+        if (!sManifestCheckingDisabled) {
+            verifyServiceDeclaration();
+        }
+        this.beaconParsers.add(new AltBeaconParser());
+        setScheduledScanJobsEnabledDefault();
+    }
 
     /**
      * Set to true if you want to show library debugging.
      *
      * @param debug True turn on all logs for this library to be printed out to logcat. False turns
      *              off detailed logging..
-     *
-     * This is a convenience method that calls setLogger to a verbose logger and enables verbose
-     * logging. For more fine grained control, use:
-     * {@link org.altbeacon.beacon.logging.LogManager#setLogger(org.altbeacon.beacon.logging.Logger)}
-     * instead.
+     *              <p>
+     *              This is a convenience method that calls setLogger to a verbose logger and enables verbose
+     *              logging. For more fine grained control, use:
+     *              {@link org.altbeacon.beacon.logging.LogManager#setLogger(org.altbeacon.beacon.logging.Logger)}
+     *              instead.
      */
     public static void setDebug(boolean debug) {
         if (debug) {
@@ -195,81 +219,12 @@ public static void setDebug(boolean debug) {
     }
 
     /**
-     * The default duration in milliseconds of the Bluetooth scan cycle
-     */
-    public static final long DEFAULT_FOREGROUND_SCAN_PERIOD = 1100;
-    /**
-     * The default duration in milliseconds spent not scanning between each Bluetooth scan cycle
-     */
-    public static final long DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD = 0;
-    /**
-     * The default duration in milliseconds of the Bluetooth scan cycle when no ranging/monitoring clients are in the foreground
-     */
-    public static final long DEFAULT_BACKGROUND_SCAN_PERIOD = 10000;
-    /**
-     * The default duration in milliseconds spent not scanning between each Bluetooth scan cycle when no ranging/monitoring clients are in the foreground
-     */
-    public static final long DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD = 5 * 60 * 1000;
-    /**
-     * The default duration in milliseconds of region exit time
-     */
-    public static final long DEFAULT_EXIT_PERIOD = 10000L;
-
-    private static long sExitRegionPeriod = DEFAULT_EXIT_PERIOD;
-
-    private long foregroundScanPeriod = DEFAULT_FOREGROUND_SCAN_PERIOD;
-    private long foregroundBetweenScanPeriod = DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD;
-    private long backgroundScanPeriod = DEFAULT_BACKGROUND_SCAN_PERIOD;
-    private long backgroundBetweenScanPeriod = DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD;
-
-    /**
-     * Sets the duration in milliseconds of each Bluetooth LE scan cycle to look for beacons.
-     * This function is used to setup the period before calling {@link #bind} or when switching
-     * between background/foreground. To have it effect on an already running scan (when the next
-     * cycle starts), call {@link #updateScanPeriods}
-     *
-     * @param p
-     */
-    public void setForegroundScanPeriod(long p) {
-        foregroundScanPeriod = p;
-    }
-
-    /**
-     * Sets the duration in milliseconds between each Bluetooth LE scan cycle to look for beacons.
-     * This function is used to setup the period before calling {@link #bind} or when switching
-     * between background/foreground. To have it effect on an already running scan (when the next
-     * cycle starts), call {@link #updateScanPeriods}
-     *
-     * @param p
-     */
-    public void setForegroundBetweenScanPeriod(long p) {
-        foregroundBetweenScanPeriod = p;
-    }
-
-    /**
-     * Sets the duration in milliseconds of each Bluetooth LE scan cycle to look for beacons.
-     * This function is used to setup the period before calling {@link #bind} or when switching
-     * between background/foreground. To have it effect on an already running scan (when the next
-     * cycle starts), call {@link #updateScanPeriods}
-     *
-     * @param p
-     */
-    public void setBackgroundScanPeriod(long p) {
-        backgroundScanPeriod = p;
-    }
-
-    /**
-     * Sets the duration in milliseconds spent not scanning between each Bluetooth LE scan cycle when no ranging/monitoring clients are in the foreground
+     * Get region exit milliseconds
      *
-     * @param p
+     * @return exit region period in milliseconds
      */
-    public void setBackgroundBetweenScanPeriod(long p) {
-        backgroundBetweenScanPeriod = p;
-        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
-                backgroundBetweenScanPeriod < 15*60*1000 /* 15 min */) {
-            LogManager.w(TAG, "Setting a short backgroundBetweenScanPeriod has no effect on "+
-                    "Android 8+, which is limited to scanning every ~15 minutes");
-        }
+    public static long getRegionExitPeriod() {
+        return sExitRegionPeriod;
     }
 
     /**
@@ -277,22 +232,13 @@ public void setBackgroundBetweenScanPeriod(long p) {
      *
      * @param regionExitPeriod
      */
-    public static void setRegionExitPeriod(long regionExitPeriod){
+    public static void setRegionExitPeriod(long regionExitPeriod) {
         sExitRegionPeriod = regionExitPeriod;
         BeaconManager instance = sInstance;
         if (instance != null) {
             instance.applySettings();
         }
     }
-    
-    /**
-     * Get region exit milliseconds
-     *
-     * @return exit region period in milliseconds
-     */
-    public static long getRegionExitPeriod(){
-        return sExitRegionPeriod;
-    }
 
     /**
      * An accessor for the singleton instance of this class.  A context must be provided, but if you need to use it from a non-Activity
@@ -325,84 +271,202 @@ public static BeaconManager getInstanceForApplication(@NonNull Context context)
         return instance;
     }
 
-    protected BeaconManager(@NonNull Context context) {
-        mContext = context.getApplicationContext();
-        checkIfMainProcess();
-        if (!sManifestCheckingDisabled) {
-           verifyServiceDeclaration();
-         }
-        this.beaconParsers.add(new AltBeaconParser());
-        setScheduledScanJobsEnabledDefault();
-    }
-
-    /***
-     * Determines if this BeaconManager instance is associated with the main application process that
-     * hosts the user interface.  This is normally true unless the scanning service or another servide
-     * is running in a separate process.
-     * @return
+    /**
+     * Convenience method for logging debug by the library
+     *
+     * @param tag
+     * @param message
+     * @deprecated This will be removed in a later release. Use
+     * {@link org.altbeacon.beacon.logging.LogManager#d(String, String, Object...)} instead.
      */
-    public boolean isMainProcess() {
-        return mMainProcess;
+    @Deprecated
+    public static void logDebug(String tag, String message) {
+        LogManager.d(tag, message);
     }
 
     /**
-     * 
-     * Determines if this BeaconManager instance is not part of the process hosting the beacon scanning
-     * service.  This is normally false, except when scanning is hosted in a different process.
-     * This will always return false until the scanning service starts up, at which time it will be
-     * known if it is in a different process.
+     * Convenience method for logging debug by the library
      *
-     * @return
+     * @param tag
+     * @param message
+     * @param t
+     * @deprecated This will be removed in a later release. Use
+     * {@link org.altbeacon.beacon.logging.LogManager#d(Throwable, String, String, Object...)}
+     * instead.
      */
-    public boolean isScannerInDifferentProcess() {
-        // may be null if service not started yet, so explicitly check
-        return mScannerInSameProcess != null && !mScannerInSameProcess;
+    @Deprecated
+    public static void logDebug(String tag, String message, Throwable t) {
+        LogManager.d(t, tag, message);
     }
 
-    /**
-     * Reserved for internal use by the library.
-     * @hide
-     */
-    public void setScannerInSameProcess(boolean isScanner) {
-        mScannerInSameProcess = isScanner;
+    public static String getDistanceModelUpdateUrl() {
+        return distanceModelUpdateUrl;
     }
 
-    protected void checkIfMainProcess() {
-        ProcessUtils processUtils = new ProcessUtils(mContext);
-        String processName = processUtils.getProcessName();
-        String packageName = processUtils.getPackageName();
-        int pid = processUtils.getPid();
-        mMainProcess = processUtils.isMainProcess();
-        LogManager.i(TAG, "BeaconManager started up on pid "+pid+" named '"+processName+"' for application package '"+packageName+"'.  isMainProcess="+mMainProcess);
+    public static void setDistanceModelUpdateUrl(@NonNull String url) {
+        warnIfScannerNotInSameProcess();
+        distanceModelUpdateUrl = url;
     }
 
-   /**
-     * Gets a list of the active beaconParsers.
-     *
-     * @return list of active BeaconParsers
-     */
-   @NonNull
-    public List<BeaconParser> getBeaconParsers() {
-        return beaconParsers;
+    public static Class getRssiFilterImplClass() {
+        return rssiFilterImplClass;
+    }
+
+    public static void setRssiFilterImplClass(@NonNull Class c) {
+        warnIfScannerNotInSameProcess();
+        rssiFilterImplClass = c;
     }
 
     /**
-     * Check if Bluetooth LE is supported by this Android device, and if so, make sure it is enabled.
+     * Allow the library to use a tracking cache
      *
-     * @return false if it is supported and not enabled
-     * @throws BleNotAvailableException if Bluetooth LE is not supported.  (Note: The Android emulator will do this)
+     * @param useTrackingCache
      */
-    @TargetApi(18)
-    public boolean checkAvailability() throws BleNotAvailableException {
-        if (!isBleAvailableOrSimulated()) {
-            throw new BleNotAvailableException("Bluetooth LE not supported by this device");
+    public static void setUseTrackingCache(boolean useTrackingCache) {
+        RangeState.setUseTrackingCache(useTrackingCache);
+        if (sInstance != null) {
+            sInstance.applySettings();
         }
-        return ((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled();
     }
 
-    /**
-     * Binds an Android <code>Activity</code> or <code>Service</code> to the <code>BeaconService</code>.  The
-     * <code>Activity</code> or <code>Service</code> must implement the <code>beaconConsumer</code> interface so
+    @Nullable
+    public static BeaconSimulator getBeaconSimulator() {
+        return BeaconManager.beaconSimulator;
+    }
+
+    public static void setBeaconSimulator(BeaconSimulator beaconSimulator) {
+        warnIfScannerNotInSameProcess();
+        BeaconManager.beaconSimulator = beaconSimulator;
+    }
+
+    /**
+     * Determines if Android L Scanning is disabled by user selection
+     *
+     * @return
+     */
+    public static boolean isAndroidLScanningDisabled() {
+        return sAndroidLScanningDisabled;
+    }
+
+    /**
+     * Allows disabling use of Android L BLE Scanning APIs on devices with API 21+
+     * If set to false (default), devices with API 21+ will use the Android L APIs to
+     * scan for beacons
+     *
+     * @param disabled
+     */
+    public static void setAndroidLScanningDisabled(boolean disabled) {
+        sAndroidLScanningDisabled = disabled;
+        BeaconManager instance = sInstance;
+        if (instance != null) {
+            instance.applySettings();
+        }
+    }
+
+    /**
+     * Deprecated misspelled method
+     *
+     * @param disabled
+     * @see #setManifestCheckingDisabled(boolean)
+     */
+    @Deprecated
+    public static void setsManifestCheckingDisabled(boolean disabled) {
+        sManifestCheckingDisabled = disabled;
+    }
+
+    /**
+     * Returns whether manifest checking is disabled
+     */
+    public static boolean getManifestCheckingDisabled() {
+        return sManifestCheckingDisabled;
+    }
+
+    /**
+     * Allows disabling check of manifest for proper configuration of service.  Useful for unit
+     * testing
+     *
+     * @param disabled
+     */
+    public static void setManifestCheckingDisabled(boolean disabled) {
+        sManifestCheckingDisabled = disabled;
+    }
+
+    private static void warnIfScannerNotInSameProcess() {
+        BeaconManager instance = sInstance;
+        if (instance != null && instance.isScannerInDifferentProcess()) {
+            LogManager.w(TAG,
+                    "Unsupported configuration change made for BeaconScanner in separate process");
+        }
+    }
+
+    /***
+     * Determines if this BeaconManager instance is associated with the main application process that
+     * hosts the user interface.  This is normally true unless the scanning service or another servide
+     * is running in a separate process.
+     * @return
+     */
+    public boolean isMainProcess() {
+        return mMainProcess;
+    }
+
+    /**
+     * Determines if this BeaconManager instance is not part of the process hosting the beacon scanning
+     * service.  This is normally false, except when scanning is hosted in a different process.
+     * This will always return false until the scanning service starts up, at which time it will be
+     * known if it is in a different process.
+     *
+     * @return
+     */
+    public boolean isScannerInDifferentProcess() {
+        // may be null if service not started yet, so explicitly check
+        return mScannerInSameProcess != null && !mScannerInSameProcess;
+    }
+
+    /**
+     * Reserved for internal use by the library.
+     *
+     * @hide
+     */
+    public void setScannerInSameProcess(boolean isScanner) {
+        mScannerInSameProcess = isScanner;
+    }
+
+    protected void checkIfMainProcess() {
+        ProcessUtils processUtils = new ProcessUtils(mContext);
+        String processName = processUtils.getProcessName();
+        String packageName = processUtils.getPackageName();
+        int pid = processUtils.getPid();
+        mMainProcess = processUtils.isMainProcess();
+        LogManager.i(TAG, "BeaconManager started up on pid " + pid + " named '" + processName + "' for application package '" + packageName + "'.  isMainProcess=" + mMainProcess);
+    }
+
+    /**
+     * Gets a list of the active beaconParsers.
+     *
+     * @return list of active BeaconParsers
+     */
+    @NonNull
+    public List<BeaconParser> getBeaconParsers() {
+        return beaconParsers;
+    }
+
+    /**
+     * Check if Bluetooth LE is supported by this Android device, and if so, make sure it is enabled.
+     *
+     * @return false if it is supported and not enabled
+     * @throws BleNotAvailableException if Bluetooth LE is not supported.  (Note: The Android emulator will do this)
+     */
+    @TargetApi(18)
+    public boolean checkAvailability() throws BleNotAvailableException {
+        if (!isBleAvailableOrSimulated()) {
+            throw new BleNotAvailableException("Bluetooth LE not supported by this device");
+        }
+        return ((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled();
+    }
+
+    /**
+     * Binds an Android <code>Activity</code> or <code>Service</code> to the <code>BeaconService</code>.  The
+     * <code>Activity</code> or <code>Service</code> must implement the <code>beaconConsumer</code> interface so
      * that it can get a callback when the service is ready to use.
      *
      * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
@@ -417,22 +481,19 @@ public void bind(@NonNull BeaconConsumer consumer) {
             ConsumerInfo alreadyBoundConsumerInfo = consumers.putIfAbsent(consumer, newConsumerInfo);
             if (alreadyBoundConsumerInfo != null) {
                 LogManager.d(TAG, "This consumer is already bound");
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "This consumer is not bound.  Binding now: %s", consumer);
                 if (mScheduledScanJobsEnabled) {
                     LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
                     consumer.onBeaconServiceConnect();
-                }
-                else {
+                } else {
                     LogManager.d(TAG, "Binding to service");
                     Intent intent = new Intent(consumer.getApplicationContext(), BeaconService.class);
                     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
                             this.getForegroundServiceNotification() != null) {
                         LogManager.i(TAG, "Starting foreground beacon scanning service.");
                         mContext.startForegroundService(intent);
-                    }
-                    else {
+                    } else {
                     }
                     consumer.bindService(intent, newConsumerInfo.beaconServiceConnection, Context.BIND_AUTO_CREATE);
                 }
@@ -457,13 +518,12 @@ public void unbind(@NonNull BeaconConsumer consumer) {
                 LogManager.d(TAG, "Unbinding");
                 if (mScheduledScanJobsEnabled) {
                     LogManager.d(TAG, "Not unbinding from scanning service as we are using scan jobs.");
-                }
-                else {
+                } else {
                     consumer.unbindService(consumers.get(consumer).beaconServiceConnection);
                 }
-                LogManager.d(TAG, "Before unbind, consumer count is "+consumers.size());
+                LogManager.d(TAG, "Before unbind, consumer count is " + consumers.size());
                 consumers.remove(consumer);
-                LogManager.d(TAG, "After unbind, consumer count is "+consumers.size());
+                LogManager.d(TAG, "After unbind, consumer count is " + consumers.size());
                 if (consumers.size() == 0) {
                     // If this is the last consumer to disconnect, the service will exit
                     // release the serviceMessenger.
@@ -480,8 +540,7 @@ public void unbind(@NonNull BeaconConsumer consumer) {
                         }
                     }
                 }
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "This consumer is not bound to: %s", consumer);
                 LogManager.d(TAG, "Bound consumers: ");
                 Set<Map.Entry<BeaconConsumer, ConsumerInfo>> consumers = this.consumers.entrySet();
@@ -499,7 +558,7 @@ public void unbind(@NonNull BeaconConsumer consumer) {
      * @return
      */
     public boolean isBound(@NonNull BeaconConsumer consumer) {
-        synchronized(consumers) {
+        synchronized (consumers) {
             // Annotation doesn't guarantee we get a non-null, but raising an NPE here is excessive
             //noinspection ConstantConditions
             return consumer != null && consumers.get(consumer) != null &&
@@ -513,63 +572,28 @@ public boolean isBound(@NonNull BeaconConsumer consumer) {
      * @return
      */
     public boolean isAnyConsumerBound() {
-        synchronized(consumers) {
+        synchronized (consumers) {
             return !consumers.isEmpty() &&
                     (mScheduledScanJobsEnabled || serviceMessenger != null);
         }
     }
 
-    /**
-     * This method notifies the beacon service that the application is either moving to background
-     * mode or foreground mode.  When in background mode, BluetoothLE scans to look for beacons are
-     * executed less frequently in order to save battery life. The specific scan rates for
-     * background and foreground operation are set by the defaults below, but may be customized.
-     * When ranging in the background, the time between updates will be much less frequent than in
-     * the foreground.  Updates will come every time interval equal to the sum total of the
-     * BackgroundScanPeriod and the BackgroundBetweenScanPeriod.
-     *
-     * @param backgroundMode true indicates the app is in the background
-     * @see #DEFAULT_FOREGROUND_SCAN_PERIOD
-     * @see #DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD;
-     * @see #DEFAULT_BACKGROUND_SCAN_PERIOD;
-     * @see #DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD;
-     * @see #setForegroundScanPeriod(long p)
-     * @see #setForegroundBetweenScanPeriod(long p)
-     * @see #setBackgroundScanPeriod(long p)
-     * @see #setBackgroundBetweenScanPeriod(long p)
-     */
-    public void setBackgroundMode(boolean backgroundMode) {
-        if (!isBleAvailableOrSimulated()) {
-            LogManager.w(TAG, "Method invocation will be ignored.");
-            return;
-        }
-        mBackgroundModeUninitialized = false;
-        if (backgroundMode != mBackgroundMode) {
-            mBackgroundMode = backgroundMode;
-            try {
-                this.updateScanPeriods();
-            } catch (RemoteException e) {
-                LogManager.e(TAG, "Cannot contact service to set scan periods");
-            }
-        }
-    }
-
     /**
      * Configures using a `ScanJob` run with the `JobScheduler` to perform scans rather than using a
      * long-running `BeaconService` to do so.
-     *
+     * <p>
      * Calling with true on devices older than Android L (5.0) will not apply the change
      * as the JobScheduler is not available.
-     *
+     * <p>
      * This value defaults to true on Android O+ and false on devices with older OS versions.
      * Accepting the default value of false is recommended on Android N and earlier because
      * otherwise beacon scans may be run only once every 15 minutes in the background, and no low
      * power scans may be performed between scanning cycles.
-     *
+     * <p>
      * Setting this value to false will disable ScanJobs when the app is run on Android 8+, which
      * can prohibit delivery of callbacks when the app is in the background unless the scanning
      * process is running in a foreground service.
-     *
+     * <p>
      * This method may only be called if bind() has not yet been called, otherwise an
      * `IllegalStateException` is thown.
      *
@@ -587,31 +611,121 @@ public void setEnableScheduledScanJobs(boolean enabled) {
             return;
         }
         if (!enabled && android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-            LogManager.w(TAG, "Disabling ScanJobs on Android 8+ may disable delivery of "+
+            LogManager.w(TAG, "Disabling ScanJobs on Android 8+ may disable delivery of " +
                     "beacon callbacks in the background unless a foreground service is active.");
         }
         mScheduledScanJobsEnabled = enabled;
     }
-    
+
     public boolean getScheduledScanJobsEnabled() {
         return mScheduledScanJobsEnabled;
     }
+
     public boolean getBackgroundMode() {
         return mBackgroundMode;
     }
+
+    /**
+     * This method notifies the beacon service that the application is either moving to background
+     * mode or foreground mode.  When in background mode, BluetoothLE scans to look for beacons are
+     * executed less frequently in order to save battery life. The specific scan rates for
+     * background and foreground operation are set by the defaults below, but may be customized.
+     * When ranging in the background, the time between updates will be much less frequent than in
+     * the foreground.  Updates will come every time interval equal to the sum total of the
+     * BackgroundScanPeriod and the BackgroundBetweenScanPeriod.
+     *
+     * @param backgroundMode true indicates the app is in the background
+     * @see #DEFAULT_FOREGROUND_SCAN_PERIOD
+     * @see #DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD;
+     * @see #DEFAULT_BACKGROUND_SCAN_PERIOD;
+     * @see #DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD;
+     * @see #setForegroundScanPeriod(long p)
+     * @see #setForegroundBetweenScanPeriod(long p)
+     * @see #setBackgroundScanPeriod(long p)
+     * @see #setBackgroundBetweenScanPeriod(long p)
+     */
+    public void setBackgroundMode(boolean backgroundMode) {
+        if (!isBleAvailableOrSimulated()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
+        }
+        mBackgroundModeUninitialized = false;
+        if (backgroundMode != mBackgroundMode) {
+            mBackgroundMode = backgroundMode;
+            try {
+                this.updateScanPeriods();
+            } catch (RemoteException e) {
+                LogManager.e(TAG, "Cannot contact service to set scan periods");
+            }
+        }
+    }
+
     public long getBackgroundScanPeriod() {
         return backgroundScanPeriod;
     }
+
+    /**
+     * Sets the duration in milliseconds of each Bluetooth LE scan cycle to look for beacons.
+     * This function is used to setup the period before calling {@link #bind} or when switching
+     * between background/foreground. To have it effect on an already running scan (when the next
+     * cycle starts), call {@link #updateScanPeriods}
+     *
+     * @param p
+     */
+    public void setBackgroundScanPeriod(long p) {
+        backgroundScanPeriod = p;
+    }
+
     public long getBackgroundBetweenScanPeriod() {
         return backgroundBetweenScanPeriod;
     }
+
+    /**
+     * Sets the duration in milliseconds spent not scanning between each Bluetooth LE scan cycle when no ranging/monitoring clients are in the foreground
+     *
+     * @param p
+     */
+    public void setBackgroundBetweenScanPeriod(long p) {
+        backgroundBetweenScanPeriod = p;
+        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
+                backgroundBetweenScanPeriod < 15 * 60 * 1000 /* 15 min */) {
+            LogManager.w(TAG, "Setting a short backgroundBetweenScanPeriod has no effect on " +
+                    "Android 8+, which is limited to scanning every ~15 minutes");
+        }
+    }
+
     public long getForegroundScanPeriod() {
         return foregroundScanPeriod;
     }
+
+    /**
+     * Sets the duration in milliseconds of each Bluetooth LE scan cycle to look for beacons.
+     * This function is used to setup the period before calling {@link #bind} or when switching
+     * between background/foreground. To have it effect on an already running scan (when the next
+     * cycle starts), call {@link #updateScanPeriods}
+     *
+     * @param p
+     */
+    public void setForegroundScanPeriod(long p) {
+        foregroundScanPeriod = p;
+    }
+
     public long getForegroundBetweenScanPeriod() {
         return foregroundBetweenScanPeriod;
     }
 
+    /**
+     * Sets the duration in milliseconds between each Bluetooth LE scan cycle to look for beacons.
+     * This function is used to setup the period before calling {@link #bind} or when switching
+     * between background/foreground. To have it effect on an already running scan (when the next
+     * cycle starts), call {@link #updateScanPeriods}
+     *
+     * @param p
+     */
+    public void setForegroundBetweenScanPeriod(long p) {
+        foregroundBetweenScanPeriod = p;
+    }
+
     /**
      * @return indicator of whether any calls have yet been made to set the
      * background mode
@@ -766,6 +880,15 @@ public void setRegionStatePeristenceEnabled(boolean enabled) {
         setRegionStatePersistenceEnabled(enabled);
     }
 
+    /**
+     * Indicates whether region state preservation is enabled
+     *
+     * @return
+     */
+    public boolean isRegionStatePersistenceEnabled() {
+        return mRegionStatePersistenceEnabled;
+    }
+
     /**
      * Turns off saving the state of monitored regions to persistent storage so it is retained over
      * app restarts.  Defaults to enabled.  When enabled, there will not be an "extra" region entry
@@ -787,18 +910,11 @@ public void setRegionStatePersistenceEnabled(boolean enabled) {
         this.applySettings();
     }
 
-    /**
-     * Indicates whether region state preservation is enabled
-     * @return
-     */
-    public boolean isRegionStatePersistenceEnabled() {
-        return mRegionStatePersistenceEnabled;
-    }
-
     /**
      * Requests the current in/out state on the specified region. If the region is being monitored,
      * this will cause an asynchronous callback on the `MonitorNotifier`'s `didDetermineStateForRegion`
      * method.  If it is not a monitored region, it will be ignored.
+     *
      * @param region
      */
     public void requestStateForRegion(@NonNull Region region) {
@@ -877,6 +993,7 @@ public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteExce
     /**
      * Call this method if you are running the scanner service in a different process in order to
      * synchronize any configuration settings, including BeaconParsers to the scanner
+     *
      * @see #isScannerInDifferentProcess()
      */
     public void applySettings() {
@@ -1001,11 +1118,9 @@ private void applyChangesToServices(int type, Region region) throws RemoteExcept
         Message msg = Message.obtain(null, type, 0, 0);
         if (type == BeaconService.MSG_SET_SCAN_PERIODS) {
             msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        }
-        else if (type == BeaconService.MSG_SYNC_SETTINGS) {
+        } else if (type == BeaconService.MSG_SYNC_SETTINGS) {
             msg.setData(new SettingsData().collect(mContext).toBundle());
-        }
-        else {
+        } else {
             msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(), mBackgroundMode).toBundle());
         }
         serviceMessenger.send(msg);
@@ -1043,162 +1158,85 @@ public MonitorNotifier getMonitoringNotifier() {
      * @return a thread-safe {@linkplain Collections#unmodifiableSet(Set) unmodifiable view}
      * providing "read-only" access to the registered {@link MonitorNotifier} instances
      * @see #addMonitorNotifier(MonitorNotifier)
-     * @see #removeMonitorNotifier(MonitorNotifier)
-     * @see Collections#unmodifiableSet(Set)
-     */
-    @NonNull
-    public Set<MonitorNotifier> getMonitoringNotifiers(){
-        return Collections.unmodifiableSet(monitorNotifiers);
-    }
-
-    /**
-     * @return the first registered rangeNotifier
-     * @deprecated replaced by (@link #getRangeNotifiers)
-     */
-    @Deprecated
-    @Nullable
-    public RangeNotifier getRangingNotifier() {
-        Iterator<RangeNotifier> iterator = rangeNotifiers.iterator();
-        if (iterator.hasNext()) {
-            return iterator.next();
-        }
-        return null;
-    }
-
-    /**
-     * Read-only access to the registered {@link RangeNotifier} instances
-     * <p>
-     * This provides a thread-safe "read-only" view of the {@link Set} of registered range
-     * notifiers. Attempts to modify the returned set, or its iterator, will throw an
-     * {@link UnsupportedOperationException}. Modifications to the underlying set should be made
-     * through {@link #addRangeNotifier(RangeNotifier)} and
-     * {@link #removeRangeNotifier(RangeNotifier)}.
-     *
-     * @return a thread-safe {@linkplain Collections#unmodifiableSet(Set) unmodifiable view}
-     * providing "read-only" access to the registered {@link RangeNotifier} instances
-     * @see #addRangeNotifier(RangeNotifier)
-     * @see #removeRangeNotifier(RangeNotifier)
-     * @see Collections#unmodifiableSet(Set)
-     */
-    @NonNull
-    public Set<RangeNotifier> getRangingNotifiers() {
-        return Collections.unmodifiableSet(rangeNotifiers);
-    }
-
-    /**
-     * @return the list of regions currently being monitored
-     */
-    @NonNull
-    public Collection<Region> getMonitoredRegions() {
-        return MonitoringStatus.getInstanceForApplication(mContext).regions();
-    }
-
-    /**
-     * @return the list of regions currently being ranged
-     */
-    @NonNull
-    public Collection<Region> getRangedRegions() {
-        synchronized(this.rangedRegions) {
-            return new ArrayList<>(this.rangedRegions);
-        }
-    }
-
-    /**
-     * Convenience method for logging debug by the library
-     *
-     * @param tag
-     * @param message
-     * @deprecated This will be removed in a later release. Use
-     * {@link org.altbeacon.beacon.logging.LogManager#d(String, String, Object...)} instead.
-     */
-    @Deprecated
-    public static void logDebug(String tag, String message) {
-        LogManager.d(tag, message);
-    }
-
-    /**
-     * Convenience method for logging debug by the library
-     *
-     * @param tag
-     * @param message
-     * @param t
-     * @deprecated This will be removed in a later release. Use
-     * {@link org.altbeacon.beacon.logging.LogManager#d(Throwable, String, String, Object...)}
-     * instead.
-     */
-    @Deprecated
-    public static void logDebug(String tag, String message, Throwable t) {
-        LogManager.d(t, tag, message);
-    }
-
-    @Nullable
-    protected static BeaconSimulator beaconSimulator;
-
-    protected static String distanceModelUpdateUrl = "https://s3.amazonaws.com/android-beacon-library/android-distance.json";
-
-    public static String getDistanceModelUpdateUrl() {
-        return distanceModelUpdateUrl;
+     * @see #removeMonitorNotifier(MonitorNotifier)
+     * @see Collections#unmodifiableSet(Set)
+     */
+    @NonNull
+    public Set<MonitorNotifier> getMonitoringNotifiers() {
+        return Collections.unmodifiableSet(monitorNotifiers);
     }
 
-    public static void setDistanceModelUpdateUrl(@NonNull String url) {
-        warnIfScannerNotInSameProcess();
-        distanceModelUpdateUrl = url;
+    /**
+     * @return the first registered rangeNotifier
+     * @deprecated replaced by (@link #getRangeNotifiers)
+     */
+    @Deprecated
+    @Nullable
+    public RangeNotifier getRangingNotifier() {
+        Iterator<RangeNotifier> iterator = rangeNotifiers.iterator();
+        if (iterator.hasNext()) {
+            return iterator.next();
+        }
+        return null;
     }
 
     /**
-     * Default class for rssi filter/calculation implementation
+     * Read-only access to the registered {@link RangeNotifier} instances
+     * <p>
+     * This provides a thread-safe "read-only" view of the {@link Set} of registered range
+     * notifiers. Attempts to modify the returned set, or its iterator, will throw an
+     * {@link UnsupportedOperationException}. Modifications to the underlying set should be made
+     * through {@link #addRangeNotifier(RangeNotifier)} and
+     * {@link #removeRangeNotifier(RangeNotifier)}.
+     *
+     * @return a thread-safe {@linkplain Collections#unmodifiableSet(Set) unmodifiable view}
+     * providing "read-only" access to the registered {@link RangeNotifier} instances
+     * @see #addRangeNotifier(RangeNotifier)
+     * @see #removeRangeNotifier(RangeNotifier)
+     * @see Collections#unmodifiableSet(Set)
      */
-    protected static Class rssiFilterImplClass = RunningAverageRssiFilter.class;
-
-    public static void setRssiFilterImplClass(@NonNull Class c) {
-        warnIfScannerNotInSameProcess();
-        rssiFilterImplClass = c;
+    @NonNull
+    public Set<RangeNotifier> getRangingNotifiers() {
+        return Collections.unmodifiableSet(rangeNotifiers);
     }
 
-    public static Class getRssiFilterImplClass() {
-        return rssiFilterImplClass;
+    /**
+     * @return the list of regions currently being monitored
+     */
+    @NonNull
+    public Collection<Region> getMonitoredRegions() {
+        return MonitoringStatus.getInstanceForApplication(mContext).regions();
     }
 
     /**
-     * Allow the library to use a tracking cache
-     * @param useTrackingCache
+     * @return the list of regions currently being ranged
      */
-    public static void setUseTrackingCache(boolean useTrackingCache) {
-        RangeState.setUseTrackingCache(useTrackingCache);
-        if (sInstance != null) {
-            sInstance.applySettings();
+    @NonNull
+    public Collection<Region> getRangedRegions() {
+        synchronized (this.rangedRegions) {
+            return new ArrayList<>(this.rangedRegions);
         }
     }
 
     /**
      * Set the period of time, in which a beacon did not receive new
      * measurements
+     *
      * @param maxTrackingAge in milliseconds
      */
     public void setMaxTrackingAge(int maxTrackingAge) {
         RangedBeacon.setMaxTrackinAge(maxTrackingAge);
     }
 
-    public static void setBeaconSimulator(BeaconSimulator beaconSimulator) {
-        warnIfScannerNotInSameProcess();
-        BeaconManager.beaconSimulator = beaconSimulator;
-    }
-
     @Nullable
-    public static BeaconSimulator getBeaconSimulator() {
-        return BeaconManager.beaconSimulator;
+    protected RangeNotifier getDataRequestNotifier() {
+        return this.dataRequestNotifier;
     }
 
-
     protected void setDataRequestNotifier(@Nullable RangeNotifier notifier) {
         this.dataRequestNotifier = notifier;
     }
 
-    @Nullable
-    protected RangeNotifier getDataRequestNotifier() {
-        return this.dataRequestNotifier;
-    }
-
     @Nullable
     public NonBeaconLeScanCallback getNonBeaconLeScanCallback() {
         return mNonBeaconLeScanCallback;
@@ -1214,6 +1252,7 @@ private boolean isBleAvailableOrSimulated() {
         }
         return isBleAvailable();
     }
+
     private boolean isBleAvailable() {
         boolean available = false;
         if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
@@ -1253,110 +1292,6 @@ private void verifyServiceDeclaration() {
         }
     }
 
-    private class ConsumerInfo {
-        public boolean isConnected = false;
-
-        @NonNull
-        public BeaconServiceConnection beaconServiceConnection;
-
-        public ConsumerInfo() {
-            this.isConnected = false;
-            this.beaconServiceConnection= new BeaconServiceConnection();
-        }
-    }
-
-    private class BeaconServiceConnection implements ServiceConnection {
-        private BeaconServiceConnection() {
-        }
-
-        // Called when the connection with the service is established
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            LogManager.d(TAG, "we have a connection to the service now");
-            if (mScannerInSameProcess == null) {
-                mScannerInSameProcess = false;
-            }
-            serviceMessenger = new Messenger(service);
-            // This will sync settings to the scanning service if it is in a different process
-            applySettings();
-            synchronized(consumers) {
-                Iterator<Map.Entry<BeaconConsumer, ConsumerInfo>> iter = consumers.entrySet().iterator();
-                while (iter.hasNext()) {
-                    Map.Entry<BeaconConsumer, ConsumerInfo> entry = iter.next();
-
-                    if (!entry.getValue().isConnected) {
-                        entry.getKey().onBeaconServiceConnect();
-                        entry.getValue().isConnected = true;
-                    }
-                }
-            }
-        }
-
-        // Called when the connection with the service disconnects
-        public void onServiceDisconnected(ComponentName className) {
-            LogManager.e(TAG, "onServiceDisconnected");
-            serviceMessenger = null;
-        }
-    }
-
-    public class ServiceNotDeclaredException extends RuntimeException {
-        public ServiceNotDeclaredException() {
-            super("The BeaconService is not properly declared in AndroidManifest.xml.  If using Eclipse," +
-                    " please verify that your project.properties has manifestmerger.enabled=true");
-        }
-    }
-
-    /**
-     * Determines if Android L Scanning is disabled by user selection
-     *
-     * @return
-     */
-    public static boolean isAndroidLScanningDisabled() {
-        return sAndroidLScanningDisabled;
-    }
-
-    /**
-     * Allows disabling use of Android L BLE Scanning APIs on devices with API 21+
-     * If set to false (default), devices with API 21+ will use the Android L APIs to
-     * scan for beacons
-     *
-     * @param disabled
-     */
-    public static void setAndroidLScanningDisabled(boolean disabled) {
-        sAndroidLScanningDisabled = disabled;
-        BeaconManager instance = sInstance;
-        if (instance != null) {
-            instance.applySettings();
-        }
-    }
-
-    /**
-     * Deprecated misspelled method
-     * @see #setManifestCheckingDisabled(boolean)
-     * @param disabled
-     */
-    @Deprecated
-    public static void setsManifestCheckingDisabled(boolean disabled) {
-        sManifestCheckingDisabled = disabled;
-    }
-
-    /**
-     * Allows disabling check of manifest for proper configuration of service.  Useful for unit
-     * testing
-     *
-     * @param disabled
-     */
-    public static void setManifestCheckingDisabled(boolean disabled) {
-        sManifestCheckingDisabled = disabled;
-    }
-
-    /**
-     * Returns whether manifest checking is disabled
-     */
-    public static boolean getManifestCheckingDisabled() {
-        return sManifestCheckingDisabled;
-    }
-
-
     /**
      * Configures the library to use a foreground service for bacon scanning.  This allows nearly
      * constant scanning on most Android versions to get around background limits, and displays an
@@ -1365,21 +1300,19 @@ public static boolean getManifestCheckingDisabled() {
      * that this method does not by itself enable constant scanning.  The scan intervals will work
      * as normal and must be configurd to specific values depending on how often you wish to scan.
      *
+     * @param notification - the notification that will be displayed when beacon scanning is active,
+     *                     along with the icon that shows up in the status bar.
+     * @throws IllegalStateException if called after consumers are already bound to the scanning
+     *                               service
      * @see #setForegroundScanPeriod(long)
      * @see #setForegroundBetweenScanPeriod(long)
-     *
+     * <p>
      * This method requires a notification to display a message to the user about why the app is
      * scanning in the background.  The notification must include an icon that will be displayed
      * in the top bar whenever the scanning service is running.
-     *
+     * <p>
      * If the BeaconService is configured to run in a different process, this call will have no
      * effect.
-     *
-     * @param notification - the notification that will be displayed when beacon scanning is active,
-     *                       along with the icon that shows up in the status bar.
-     *
-     * @throws IllegalStateException if called after consumers are already bound to the scanning
-     * service
      */
     public void enableForegroundServiceScanning(Notification notification, int notificationId)
             throws IllegalStateException {
@@ -1397,13 +1330,12 @@ public void enableForegroundServiceScanning(Notification notification, int notif
     /**
      * Disables a foreground scanning service, if previously configured.
      *
+     * @throws IllegalStateException if called after consumers are already bound to the scanning
+     *                               service
      * @see #enableForegroundServiceScanning
-     *
+     * <p>
      * In order to call this method to disable a foreground service, you must  unbind from the
      * BeaconManager.  You can then rebind after this call is made.
-     *
-     * @throws IllegalStateException if called after consumers are already bound to the scanning
-     * service
      */
     public void disableForegroundServiceScanning() throws IllegalStateException {
         if (isAnyConsumerBound()) {
@@ -1414,42 +1346,84 @@ public void disableForegroundServiceScanning() throws IllegalStateException {
     }
 
     /**
-     * @see #enableForegroundServiceScanning
      * @return The notification shown for the beacon scanning service, if so configured
+     * @see #enableForegroundServiceScanning
      */
     public Notification getForegroundServiceNotification() {
         return mForegroundServiceNotification;
     }
 
-
     /**
-     * @see #enableForegroundServiceScanning
      * @return The notification shown for the beacon scanning service, if so configured
+     * @see #enableForegroundServiceScanning
      */
     public int getForegroundServiceNotificationId() {
         return mForegroundServiceNotificationId;
     }
 
-
     private boolean determineIfCalledFromSeparateScannerProcess() {
         if (isScannerInDifferentProcess() && !isMainProcess()) {
-            LogManager.w(TAG, "Ranging/Monitoring may not be controlled from a separate "+
-                    "BeaconScanner process.  To remove this warning, please wrap this call in:"+
+            LogManager.w(TAG, "Ranging/Monitoring may not be controlled from a separate " +
+                    "BeaconScanner process.  To remove this warning, please wrap this call in:" +
                     " if (beaconManager.isMainProcess())");
             return true;
         }
         return false;
     }
 
-    private static void warnIfScannerNotInSameProcess() {
-        BeaconManager instance = sInstance;
-        if (instance != null && instance.isScannerInDifferentProcess()) {
-            LogManager.w(TAG,
-                    "Unsupported configuration change made for BeaconScanner in separate process");
+    private void setScheduledScanJobsEnabledDefault() {
+        mScheduledScanJobsEnabled = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O;
+    }
+
+    private class ConsumerInfo {
+        public boolean isConnected = false;
+
+        @NonNull
+        public BeaconServiceConnection beaconServiceConnection;
+
+        public ConsumerInfo() {
+            this.isConnected = false;
+            this.beaconServiceConnection = new BeaconServiceConnection();
         }
     }
 
-    private void setScheduledScanJobsEnabledDefault() {
-        mScheduledScanJobsEnabled = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O;
+    private class BeaconServiceConnection implements ServiceConnection {
+        private BeaconServiceConnection() {
+        }
+
+        // Called when the connection with the service is established
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            LogManager.d(TAG, "we have a connection to the service now");
+            if (mScannerInSameProcess == null) {
+                mScannerInSameProcess = false;
+            }
+            serviceMessenger = new Messenger(service);
+            // This will sync settings to the scanning service if it is in a different process
+            applySettings();
+            synchronized (consumers) {
+                Iterator<Map.Entry<BeaconConsumer, ConsumerInfo>> iter = consumers.entrySet().iterator();
+                while (iter.hasNext()) {
+                    Map.Entry<BeaconConsumer, ConsumerInfo> entry = iter.next();
+
+                    if (!entry.getValue().isConnected) {
+                        entry.getKey().onBeaconServiceConnect();
+                        entry.getValue().isConnected = true;
+                    }
+                }
+            }
+        }
+
+        // Called when the connection with the service disconnects
+        public void onServiceDisconnected(ComponentName className) {
+            LogManager.e(TAG, "onServiceDisconnected");
+            serviceMessenger = null;
+        }
+    }
+
+    public class ServiceNotDeclaredException extends RuntimeException {
+        public ServiceNotDeclaredException() {
+            super("The BeaconService is not properly declared in AndroidManifest.xml.  If using Eclipse," +
+                    " please verify that your project.properties has manifestmerger.enabled=true");
+        }
     }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconParser.java b/lib/src/main/java/org/altbeacon/beacon/BeaconParser.java
index ef55e7a8..ce201b60 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -35,27 +35,23 @@
  * For more information on how to set up parsing of a beacon,
  * {@link #setBeaconLayout(String) see setBeaconLayout(String)}
  * </p>
- *
  */
 public class BeaconParser implements Serializable {
-    private static final String TAG = "BeaconParser";
     public static final String ALTBEACON_LAYOUT = "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25";
     public static final String EDDYSTONE_TLM_LAYOUT = "x,s:0-1=feaa,m:2-2=20,d:3-3,d:4-5,d:6-7,d:8-11,d:12-15";
     public static final String EDDYSTONE_UID_LAYOUT = "s:0-1=feaa,m:2-2=00,p:3-3:-41,i:4-13,i:14-19";
     public static final String EDDYSTONE_URL_LAYOUT = "s:0-1=feaa,m:2-2=10,p:3-3:-41,i:4-21v";
     public static final String URI_BEACON_LAYOUT = "s:0-1=fed8,m:2-2=00,p:3-3:-41,i:4-21v";
+    private static final String TAG = "BeaconParser";
     private static final Pattern I_PATTERN = Pattern.compile("i\\:(\\d+)\\-(\\d+)([blv]*)?");
     private static final Pattern M_PATTERN = Pattern.compile("m\\:(\\d+)-(\\d+)\\=([0-9A-Fa-f]+)");
     private static final Pattern S_PATTERN = Pattern.compile("s\\:(\\d+)-(\\d+)\\=([0-9A-Fa-f]+)");
     private static final Pattern D_PATTERN = Pattern.compile("d\\:(\\d+)\\-(\\d+)([bl]*)?");
     private static final Pattern P_PATTERN = Pattern.compile("p\\:(\\d+)\\-(\\d+)\\:?([\\-\\d]+)?");
     private static final Pattern X_PATTERN = Pattern.compile("x");
-    private static final char[] HEX_ARRAY = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
+    private static final char[] HEX_ARRAY = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
     private static final String LITTLE_ENDIAN_SUFFIX = "l";
     private static final String VARIABLE_LENGTH_SUFFIX = "v";
-
-    protected String mBeaconLayout;
-    private Long mMatchingBeaconTypeCode;
     protected final List<Integer> mIdentifierStartOffsets = new ArrayList<Integer>();
     protected final List<Integer> mIdentifierEndOffsets = new ArrayList<Integer>();
     protected final List<Boolean> mIdentifierLittleEndianFlags = new ArrayList<Boolean>();
@@ -63,22 +59,22 @@
     protected final List<Integer> mDataEndOffsets = new ArrayList<Integer>();
     protected final List<Boolean> mDataLittleEndianFlags = new ArrayList<Boolean>();
     protected final List<Boolean> mIdentifierVariableLengthFlags = new ArrayList<Boolean>();
+    protected String mBeaconLayout;
     protected Integer mMatchingBeaconTypeCodeStartOffset;
     protected Integer mMatchingBeaconTypeCodeEndOffset;
     protected Integer mServiceUuidStartOffset;
     protected Integer mServiceUuidEndOffset;
     protected Long mServiceUuid;
     protected Boolean mExtraFrame;
-
     protected Integer mPowerStartOffset;
     protected Integer mPowerEndOffset;
     protected Integer mDBmCorrection;
     protected Integer mLayoutSize;
     protected Boolean mAllowPduOverflow = true;
     protected String mIdentifier;
-    protected int[] mHardwareAssistManufacturers = new int[] { 0x004c };
-
+    protected int[] mHardwareAssistManufacturers = new int[]{0x004c};
     protected List<BeaconParser> extraParsers = new ArrayList<BeaconParser>();
+    private Long mMatchingBeaconTypeCode;
 
 
     /**
@@ -95,6 +91,33 @@ public BeaconParser(String identifier) {
         mIdentifier = identifier;
     }
 
+    protected static String bytesToHex(byte[] bytes) {
+        char[] hexChars = new char[bytes.length * 2];
+        int v;
+        for (int j = 0; j < bytes.length; j++) {
+            v = bytes[j] & 0xFF;
+            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
+            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
+        }
+        return new String(hexChars);
+    }
+
+    public static byte[] longToByteArray(long longValue, int length) {
+        return longToByteArray(longValue, length, true);
+    }
+
+    public static byte[] longToByteArray(long longValue, int length, boolean bigEndian) {
+        byte[] array = new byte[length];
+        for (int i = 0; i < length; i++) {
+            int adjustedI = bigEndian ? i : length - i - 1;
+            long mask = 0xffl << (length - adjustedI - 1) * 8;
+            long shift = (length - adjustedI - 1) * 8;
+            long value = ((longValue & mask) >> shift);
+            array[i] = (byte) value;
+        }
+        return array;
+    }
+
     /**
      * <p>Defines a beacon field parsing algorithm based on a string designating the zero-indexed
      * offsets to bytes within a BLE advertisement.</p>
@@ -139,14 +162,14 @@ public BeaconParser(String identifier) {
      * <p>Example of a parser string for AltBeacon:</p>
      *
      * </pre>
-     *   "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25"
+     * "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25"
      * </pre>
      *
      * <p>This signifies that the beacon type will be decoded when an advertisement is found with
      * 0xbeac in bytes 2-3, and a three-part identifier will be pulled out of bytes 4-19, bytes
      * 20-21 and bytes 22-23, respectively.  A signed power calibration value will be pulled out of
      * byte 24, and a data field will be pulled out of byte 25.</p>
-     *
+     * <p>
      * Note: bytes 0-1 of the BLE manufacturer advertisements are the two byte manufacturer code.
      * Generally you should not match on these two bytes when using a BeaconParser, because it will
      * limit your parser to matching only a transmitter made by a specific manufacturer.  Software
@@ -158,19 +181,19 @@ public BeaconParser(String identifier) {
      *
      * <p>
      * Extra layouts can also be added by using:
+     *
+     * @param beaconLayout
+     * @return the BeaconParser instance
      * @see #addExtraDataParser(BeaconParser)
      * This is the preferred method and matching BeaconLayouts by serviceUUID will be deprecated in
      * the future.
      * </p>
-     *
-     * @param beaconLayout
-     * @return the BeaconParser instance
      */
     public BeaconParser setBeaconLayout(String beaconLayout) {
         mBeaconLayout = beaconLayout;
-        Log.d(TAG, "Parsing beacon layout: "+beaconLayout);
+        Log.d(TAG, "Parsing beacon layout: " + beaconLayout);
 
-        String[] terms =  beaconLayout.split(",");
+        String[] terms = beaconLayout.split(",");
         mExtraFrame = false; // this is not an extra frame by default
 
         for (String term : terms) {
@@ -216,9 +239,9 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
                     if (matcher.group(3) != null) {
                         dBmCorrection = Integer.parseInt(matcher.group(3));
                     }
-                    mDBmCorrection=dBmCorrection;
-                    mPowerStartOffset=startOffset;
-                    mPowerEndOffset=endOffset;
+                    mDBmCorrection = dBmCorrection;
+                    mPowerStartOffset = startOffset;
+                    mPowerEndOffset = endOffset;
                 } catch (NumberFormatException e) {
                     throw new BeaconLayoutException("Cannot parse integer power byte offset in term: " + term);
                 }
@@ -236,10 +259,9 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
                 }
                 String hexString = matcher.group(3);
                 try {
-                    mMatchingBeaconTypeCode = Long.decode("0x"+hexString);
-                }
-                catch (NumberFormatException e) {
-                    throw new BeaconLayoutException("Cannot parse beacon type code: "+hexString+" in term: " + term);
+                    mMatchingBeaconTypeCode = Long.decode("0x" + hexString);
+                } catch (NumberFormatException e) {
+                    throw new BeaconLayoutException("Cannot parse beacon type code: " + hexString + " in term: " + term);
                 }
             }
             matcher = S_PATTERN.matcher(term);
@@ -255,10 +277,9 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
                 }
                 String hexString = matcher.group(3);
                 try {
-                    mServiceUuid = Long.decode("0x"+hexString);
-                }
-                catch (NumberFormatException e) {
-                    throw new BeaconLayoutException("Cannot parse serviceUuid: "+hexString+" in term: " + term);
+                    mServiceUuid = Long.decode("0x" + hexString);
+                } catch (NumberFormatException e) {
+                    throw new BeaconLayoutException("Cannot parse serviceUuid: " + hexString + " in term: " + term);
                 }
             }
             matcher = X_PATTERN.matcher(term);
@@ -303,9 +324,9 @@ public boolean addExtraDataParser(BeaconParser extraDataParser) {
     /**
      * Gets a list of extra parsers configured for this <code>BeaconParser</code>.
      *
+     * @return
      * @see #addExtraDataParser
      * @see #setBeaconLayout
-     * @return
      */
     public List<BeaconParser> getExtraDataParsers() {
         return new ArrayList<>(extraParsers);
@@ -314,6 +335,7 @@ public boolean addExtraDataParser(BeaconParser extraDataParser) {
     /**
      * Gets an optional identifier field that may be used to identify this parser.  If set, it will
      * be passed along to any beacons decoded with this parser.
+     *
      * @return
      */
     public String getIdentifier() {
@@ -323,7 +345,7 @@ public String getIdentifier() {
     /**
      * Returns a list of Bluetooth manufacturer codes which will be used for hardware-assisted
      * accelerated looking for this beacon type
-     *
+     * <p>
      * The possible codes are defined on this list:
      * https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers
      *
@@ -336,10 +358,9 @@ public String getIdentifier() {
     /**
      * Sets a list of Bluetooth manufacturer codes which will be used for hardware-assisted
      * accelerated looking for this beacon type
-     *
+     * <p>
      * The possible codes are defined on this list:
      * https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers
-     *
      */
     public void setHardwareAssistManufacturerCodes(int[] manufacturers) {
         mHardwareAssistManufacturers = manufacturers;
@@ -349,6 +370,7 @@ public void setHardwareAssistManufacturerCodes(int[] manufacturers) {
      * Setting to true indicates that packets should be rejected if the PDU length is too short for
      * the fields.  Some beacons transmit malformed PDU packets that understate their length, so
      * this defaults to false.
+     *
      * @param enabled
      */
     public void setAllowPduOverflow(Boolean enabled) {
@@ -356,15 +378,21 @@ public void setAllowPduOverflow(Boolean enabled) {
     }
 
     /**
-     * @see #mMatchingBeaconTypeCode
      * @return
+     * @see #mMatchingBeaconTypeCode
      */
     public Long getMatchingBeaconTypeCode() {
         return mMatchingBeaconTypeCode;
     }
 
+    public BeaconParser setMatchingBeaconTypeCode(Long typeCode) {
+        mMatchingBeaconTypeCode = typeCode;
+        return this;
+    }
+
     /**
      * see #mMatchingBeaconTypeCodeStartOffset
+     *
      * @return
      */
     public int getMatchingBeaconTypeCodeStartOffset() {
@@ -373,16 +401,16 @@ public int getMatchingBeaconTypeCodeStartOffset() {
 
     /**
      * see #mMatchingBeaconTypeCodeEndOffset
+     *
      * @return
      */
     public int getMatchingBeaconTypeCodeEndOffset() {
         return mMatchingBeaconTypeCodeEndOffset;
     }
 
-
     /**
-     * @see #mServiceUuid
      * @return
+     * @see #mServiceUuid
      */
     public Long getServiceUuid() {
         return mServiceUuid;
@@ -390,6 +418,7 @@ public Long getServiceUuid() {
 
     /**
      * see #mServiceUuidStartOffset
+     *
      * @return
      */
     public int getMServiceUuidStartOffset() {
@@ -398,20 +427,20 @@ public int getMServiceUuidStartOffset() {
 
     /**
      * see #mServiceUuidEndOffset
+     *
      * @return
      */
     public int getServiceUuidEndOffset() {
         return mServiceUuidEndOffset;
     }
 
-
     /**
      * Construct a Beacon from a Bluetooth LE packet collected by Android's Bluetooth APIs,
      * including the raw Bluetooth device info
      *
      * @param scanData The actual packet bytes
-     * @param rssi The measured signal strength of the packet
-     * @param device The Bluetooth device that was detected
+     * @param rssi     The measured signal strength of the packet
+     * @param device   The Bluetooth device that was detected
      * @return An instance of a <code>Beacon</code>
      */
     public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
@@ -426,7 +455,7 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
         ArrayList<Identifier> identifiers = new ArrayList<Identifier>();
         ArrayList<Long> dataFields = new ArrayList<Long>();
 
-        for (Pdu pdu: advert.getPdus()) {
+        for (Pdu pdu : advert.getPdus()) {
             if (pdu.getType() == Pdu.GATT_SERVICE_UUID_PDU_TYPE ||
                     pdu.getType() == Pdu.MANUFACTURER_DATA_PDU_TYPE) {
                 pduToParse = pdu;
@@ -434,8 +463,7 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
                     LogManager.d(TAG, "Processing pdu type %02X: %s with startIndex: %d, endIndex: %d", pdu.getType(), bytesToHex(bytesToProcess), pdu.getStartIndex(), pdu.getEndIndex());
                 }
                 break;
-            }
-            else {
+            } else {
                 if (LogManager.isVerboseLoggingEnabled()) {
                     LogManager.d(TAG, "Ignoring pdu type %02X", pdu.getType());
                 }
@@ -446,8 +474,7 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
                 LogManager.d(TAG, "No PDUs to process in this packet.");
             }
             parseFailed = true;
-        }
-        else {
+        } else {
             byte[] serviceUuidBytes = null;
             byte[] typeCodeBytes = longToByteArray(getMatchingBeaconTypeCode(), mMatchingBeaconTypeCodeEndOffset - mMatchingBeaconTypeCodeStartOffset + 1);
             if (getServiceUuid() != null) {
@@ -488,7 +515,7 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
                     }
                 }
                 parseFailed = true;
-                beacon =  null;
+                beacon = null;
             } else {
                 if (LogManager.isVerboseLoggingEnabled()) {
                     LogManager.d(TAG, "This is a recognized beacon advertisement -- %s seen",
@@ -498,41 +525,39 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
             }
 
             if (patternFound) {
-                if (bytesToProcess.length <= startByte+mLayoutSize && mAllowPduOverflow) {
+                if (bytesToProcess.length <= startByte + mLayoutSize && mAllowPduOverflow) {
                     // If the layout size is bigger than this PDU, and we allow overflow.  Make sure
                     // the byte buffer is big enough by zero padding the end so we don't try to read
                     // outside the byte array of the advertisement
                     if (LogManager.isVerboseLoggingEnabled()) {
-                        LogManager.d(TAG, "Expanding buffer because it is too short to parse: "+bytesToProcess.length+", needed: "+(startByte+mLayoutSize));
+                        LogManager.d(TAG, "Expanding buffer because it is too short to parse: " + bytesToProcess.length + ", needed: " + (startByte + mLayoutSize));
                     }
-                    bytesToProcess = ensureMaxSize(bytesToProcess, startByte+mLayoutSize);
+                    bytesToProcess = ensureMaxSize(bytesToProcess, startByte + mLayoutSize);
                 }
                 for (int i = 0; i < mIdentifierEndOffsets.size(); i++) {
                     int endIndex = mIdentifierEndOffsets.get(i) + startByte;
 
                     if (endIndex > pduToParse.getEndIndex() && mIdentifierVariableLengthFlags.get(i)) {
                         if (LogManager.isVerboseLoggingEnabled()) {
-                            LogManager.d(TAG, "Need to truncate identifier by "+(endIndex-pduToParse.getEndIndex()));
+                            LogManager.d(TAG, "Need to truncate identifier by " + (endIndex - pduToParse.getEndIndex()));
                         }
                         // If this is a variable length identifier, we truncate it to the size that
                         // is available in the packet
                         int start = mIdentifierStartOffsets.get(i) + startByte;
-                        int end = pduToParse.getEndIndex()+1;
+                        int end = pduToParse.getEndIndex() + 1;
                         if (end <= start) {
                             LogManager.d(TAG, "PDU is too short for identifer.  Packet is malformed");
                             return null;
                         }
                         Identifier identifier = Identifier.fromBytes(bytesToProcess, start, end, mIdentifierLittleEndianFlags.get(i));
                         identifiers.add(identifier);
-                    }
-                    else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
+                    } else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                         parseFailed = true;
                         if (LogManager.isVerboseLoggingEnabled()) {
-                            LogManager.d(TAG, "Cannot parse identifier "+i+" because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex());
+                            LogManager.d(TAG, "Cannot parse identifier " + i + " because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex());
                         }
-                    }
-                    else {
-                        Identifier identifier = Identifier.fromBytes(bytesToProcess, mIdentifierStartOffsets.get(i) + startByte, endIndex+1, mIdentifierLittleEndianFlags.get(i));
+                    } else {
+                        Identifier identifier = Identifier.fromBytes(bytesToProcess, mIdentifierStartOffsets.get(i) + startByte, endIndex + 1, mIdentifierLittleEndianFlags.get(i));
                         identifiers.add(identifier);
                     }
                 }
@@ -540,11 +565,10 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                     int endIndex = mDataEndOffsets.get(i) + startByte;
                     if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                         if (LogManager.isVerboseLoggingEnabled()) {
-                            LogManager.d(TAG, "Cannot parse data field "+i+" because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex()+".  Setting value to 0");
+                            LogManager.d(TAG, "Cannot parse data field " + i + " because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex() + ".  Setting value to 0");
                         }
                         dataFields.add(new Long(0l));
-                    }
-                    else {
+                    } else {
                         String dataString = byteArrayToFormattedString(bytesToProcess, mDataStartOffsets.get(i) + startByte, endIndex, mDataLittleEndianFlags.get(i));
                         dataFields.add(Long.decode(dataString));
                     }
@@ -559,21 +583,18 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                             if (LogManager.isVerboseLoggingEnabled()) {
                                 LogManager.d(TAG, "Cannot parse power field because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex());
                             }
-                        }
-                        else {
+                        } else {
                             String powerString = byteArrayToFormattedString(bytesToProcess, mPowerStartOffset + startByte, mPowerEndOffset + startByte, false);
-                            txPower = Integer.parseInt(powerString)+mDBmCorrection;
+                            txPower = Integer.parseInt(powerString) + mDBmCorrection;
                             // make sure it is a signed integer
                             if (txPower > 127) {
                                 txPower -= 256;
                             }
                             beacon.mTxPower = txPower;
                         }
-                    }
-                    catch (NumberFormatException e1) {
+                    } catch (NumberFormatException e1) {
                         // keep default value
-                    }
-                    catch (NullPointerException e2) {
+                    } catch (NullPointerException e2) {
                         // keep default value
                     }
                 }
@@ -582,15 +603,14 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
 
         if (parseFailed) {
             beacon = null;
-        }
-        else {
+        } else {
             int beaconTypeCode = 0;
-            String beaconTypeString = byteArrayToFormattedString(bytesToProcess, mMatchingBeaconTypeCodeStartOffset+startByte, mMatchingBeaconTypeCodeEndOffset+startByte, false);
+            String beaconTypeString = byteArrayToFormattedString(bytesToProcess, mMatchingBeaconTypeCodeStartOffset + startByte, mMatchingBeaconTypeCodeEndOffset + startByte, false);
             beaconTypeCode = Integer.parseInt(beaconTypeString);
             // TODO: error handling needed on the parse
 
             int manufacturer = 0;
-            String manufacturerString = byteArrayToFormattedString(bytesToProcess, startByte, startByte+1, true);
+            String manufacturerString = byteArrayToFormattedString(bytesToProcess, startByte, startByte + 1, true);
             manufacturer = Integer.parseInt(manufacturerString);
 
             String macAddress = null;
@@ -606,13 +626,12 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
             beacon.mBeaconTypeCode = beaconTypeCode;
             if (mServiceUuid != null) {
                 beacon.mServiceUuid = (int) mServiceUuid.longValue();
-            }
-            else {
+            } else {
                 beacon.mServiceUuid = -1;
             }
 
             beacon.mBluetoothAddress = macAddress;
-            beacon.mBluetoothName= name;
+            beacon.mBluetoothName = name;
             beacon.mManufacturer = manufacturer;
             beacon.mParserIdentifier = mIdentifier;
             beacon.mMultiFrameBeacon = extraParsers.size() > 0 || mExtraFrame;
@@ -622,6 +641,7 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
 
     /**
      * Get BLE advertisement bytes for a Beacon
+     *
      * @param beacon the beacon containing the data to be transmitted
      * @return the byte array of the advertisement
      */
@@ -630,7 +650,7 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
         byte[] advertisingBytes;
 
         if (beacon.getIdentifiers().size() != getIdentifierCount()) {
-            throw new IllegalArgumentException("Beacon has "+beacon.getIdentifiers().size()+" identifiers but format requires "+getIdentifierCount());
+            throw new IllegalArgumentException("Beacon has " + beacon.getIdentifiers().size() + " identifiers but format requires " + getIdentifierCount());
         }
 
         int lastIndex = -1;
@@ -655,7 +675,7 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
         int adjustedIdentifiersLength = 0;
         for (int identifierNum = 0; identifierNum < this.mIdentifierStartOffsets.size(); identifierNum++) {
             if (mIdentifierVariableLengthFlags.get(identifierNum)) {
-                int declaredIdentifierLength = (this.mIdentifierEndOffsets.get(identifierNum) - this.mIdentifierStartOffsets.get(identifierNum)+1);
+                int declaredIdentifierLength = (this.mIdentifierEndOffsets.get(identifierNum) - this.mIdentifierStartOffsets.get(identifierNum) + 1);
                 int actualIdentifierLength = beacon.getIdentifier(identifierNum).getByteCount();
                 adjustedIdentifiersLength += actualIdentifierLength;
                 adjustedIdentifiersLength -= declaredIdentifierLength;
@@ -663,13 +683,13 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
         }
         lastIndex += adjustedIdentifiersLength;
 
-        advertisingBytes = new byte[lastIndex+1-2];
+        advertisingBytes = new byte[lastIndex + 1 - 2];
         long beaconTypeCode = this.getMatchingBeaconTypeCode();
 
         // set type code
         for (int index = this.mMatchingBeaconTypeCodeStartOffset; index <= this.mMatchingBeaconTypeCodeEndOffset; index++) {
-            byte value = (byte) (this.getMatchingBeaconTypeCode() >> (8*(this.mMatchingBeaconTypeCodeEndOffset-index)) & 0xff);
-            advertisingBytes[index-2] = value;
+            byte value = (byte) (this.getMatchingBeaconTypeCode() >> (8 * (this.mMatchingBeaconTypeCodeEndOffset - index)) & 0xff);
+            advertisingBytes[index - 2] = value;
         }
 
         // set identifiers
@@ -683,41 +703,37 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                     // Pad it, but only if this is not a variable length identifier
                     if (mIdentifierLittleEndianFlags.get(identifierNum)) {
                         // this is little endian.  Pad at the end of the array
-                        identifierBytes = Arrays.copyOf(identifierBytes,getIdentifierByteCount(identifierNum));
-                    }
-                    else {
+                        identifierBytes = Arrays.copyOf(identifierBytes, getIdentifierByteCount(identifierNum));
+                    } else {
                         // this is big endian.  Pad at the beginning of the array
                         byte[] newIdentifierBytes = new byte[getIdentifierByteCount(identifierNum)];
-                        System.arraycopy(identifierBytes, 0, newIdentifierBytes, getIdentifierByteCount(identifierNum)-identifierBytes.length, identifierBytes.length);
+                        System.arraycopy(identifierBytes, 0, newIdentifierBytes, getIdentifierByteCount(identifierNum) - identifierBytes.length, identifierBytes.length);
                         identifierBytes = newIdentifierBytes;
                     }
                 }
-                LogManager.d(TAG, "Expanded identifier because it is too short.  It is now: "+byteArrayToString(identifierBytes));
-            }
-            else if (identifierBytes.length > getIdentifierByteCount(identifierNum)) {
+                LogManager.d(TAG, "Expanded identifier because it is too short.  It is now: " + byteArrayToString(identifierBytes));
+            } else if (identifierBytes.length > getIdentifierByteCount(identifierNum)) {
                 if (mIdentifierLittleEndianFlags.get(identifierNum)) {
                     // Truncate it at the beginning for big endian
-                    identifierBytes = Arrays.copyOfRange(identifierBytes, getIdentifierByteCount(identifierNum)-identifierBytes.length, getIdentifierByteCount(identifierNum));
-                }
-                else {
+                    identifierBytes = Arrays.copyOfRange(identifierBytes, getIdentifierByteCount(identifierNum) - identifierBytes.length, getIdentifierByteCount(identifierNum));
+                } else {
                     // Truncate it at the end for little endian
-                    identifierBytes = Arrays.copyOf(identifierBytes,getIdentifierByteCount(identifierNum));
+                    identifierBytes = Arrays.copyOf(identifierBytes, getIdentifierByteCount(identifierNum));
                 }
-                LogManager.d(TAG, "Truncated identifier because it is too long.  It is now: "+byteArrayToString(identifierBytes));
-            }
-            else {
-                LogManager.d(TAG, "Identifier size is just right: "+byteArrayToString(identifierBytes));
+                LogManager.d(TAG, "Truncated identifier because it is too long.  It is now: " + byteArrayToString(identifierBytes));
+            } else {
+                LogManager.d(TAG, "Identifier size is just right: " + byteArrayToString(identifierBytes));
             }
-            for (int index = this.mIdentifierStartOffsets.get(identifierNum); index <= this.mIdentifierStartOffsets.get(identifierNum)+identifierBytes.length-1; index ++) {
-                advertisingBytes[index-2] = (byte) identifierBytes[index-this.mIdentifierStartOffsets.get(identifierNum)];
+            for (int index = this.mIdentifierStartOffsets.get(identifierNum); index <= this.mIdentifierStartOffsets.get(identifierNum) + identifierBytes.length - 1; index++) {
+                advertisingBytes[index - 2] = (byte) identifierBytes[index - this.mIdentifierStartOffsets.get(identifierNum)];
             }
         }
 
         // set power
 
         if (this.mPowerStartOffset != null && this.mPowerEndOffset != null) {
-            for (int index = this.mPowerStartOffset; index <= this.mPowerEndOffset; index ++) {
-                advertisingBytes[index-2] = (byte) (beacon.getTxPower() >> (8*(index - this.mPowerStartOffset)) & 0xff);
+            for (int index = this.mPowerStartOffset; index <= this.mPowerEndOffset; index++) {
+                advertisingBytes[index - 2] = (byte) (beacon.getTxPower() >> (8 * (index - this.mPowerStartOffset)) & 0xff);
             }
         }
 
@@ -725,24 +741,20 @@ else if (identifierBytes.length > getIdentifierByteCount(identifierNum)) {
         for (int dataFieldNum = 0; dataFieldNum < this.mDataStartOffsets.size(); dataFieldNum++) {
             long dataField = beacon.getDataFields().get(dataFieldNum);
             int dataFieldLength = this.mDataEndOffsets.get(dataFieldNum) - this.mDataStartOffsets.get(dataFieldNum);
-            for (int index = 0; index <= dataFieldLength; index ++) {
+            for (int index = 0; index <= dataFieldLength; index++) {
                 int endianCorrectedIndex = index;
                 if (!this.mDataLittleEndianFlags.get(dataFieldNum)) {
-                    endianCorrectedIndex = dataFieldLength-index;
+                    endianCorrectedIndex = dataFieldLength - index;
                 }
-                advertisingBytes[this.mDataStartOffsets.get(dataFieldNum)-2+endianCorrectedIndex] = (byte) (dataField >> (8*index) & 0xff);
+                advertisingBytes[this.mDataStartOffsets.get(dataFieldNum) - 2 + endianCorrectedIndex] = (byte) (dataField >> (8 * index) & 0xff);
             }
         }
         return advertisingBytes;
     }
 
-    public BeaconParser setMatchingBeaconTypeCode(Long typeCode) {
-        mMatchingBeaconTypeCode = typeCode;
-        return this;
-    }
-
     /**
      * Caclculates the byte size of the specified identifier in this format
+     *
      * @param identifierNum
      * @return bytes
      */
@@ -775,40 +787,10 @@ public String getLayout() {
      * @return the correction value in dBm to apply to the calibrated txPower to get a 1m calibrated value.
      * Some formats like Eddystone use a 0m calibrated value, which requires this correction
      */
-    public int getPowerCorrection() { return mDBmCorrection; }
-
-    protected static String bytesToHex(byte[] bytes) {
-        char[] hexChars = new char[bytes.length * 2];
-        int v;
-        for ( int j = 0; j < bytes.length; j++ ) {
-            v = bytes[j] & 0xFF;
-            hexChars[j * 2] = HEX_ARRAY[v >>> 4];
-            hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
-        }
-        return new String(hexChars);
+    public int getPowerCorrection() {
+        return mDBmCorrection;
     }
 
-    public static class BeaconLayoutException extends RuntimeException {
-        public BeaconLayoutException(String s) {
-        super(s);
-        }
-    }
-
-    public static byte[] longToByteArray(long longValue, int length) {
-        return longToByteArray(longValue, length, true);
-    }
-
-    public static byte[] longToByteArray(long longValue, int length, boolean bigEndian) {
-        byte[] array = new byte[length];
-        for (int i = 0; i < length; i++){
-            int adjustedI = bigEndian ? i : length - i -1;
-            long mask = 0xffl << (length-adjustedI-1)*8;
-            long shift = (length-adjustedI-1)*8;
-            long value = ((longValue & mask)  >> shift);
-            array[i] = (byte) value;
-        }
-        return array;
-    }
     private int calculateLayoutSize() {
         int lastEndOffset = 0;
         if (mIdentifierEndOffsets != null) {
@@ -825,13 +807,13 @@ private int calculateLayoutSize() {
                 }
             }
         }
-        if (mPowerEndOffset != null && mPowerEndOffset > lastEndOffset ) {
+        if (mPowerEndOffset != null && mPowerEndOffset > lastEndOffset) {
             lastEndOffset = mPowerEndOffset;
         }
         if (mServiceUuidEndOffset != null && mServiceUuidEndOffset > lastEndOffset) {
             lastEndOffset = mServiceUuidEndOffset;
         }
-        return lastEndOffset+1;
+        return lastEndOffset + 1;
     }
 
     private boolean byteArraysMatch(byte[] source, int offset, byte[] expected) {
@@ -839,7 +821,7 @@ private boolean byteArraysMatch(byte[] source, int offset, byte[] expected) {
         if (source.length - offset < length) {
             return false;
         }
-        for (int i = 0; i <  length; i++) {
+        for (int i = 0; i < length; i++) {
             if (source[offset + i] != expected[i]) {
                 return false;
             }
@@ -857,27 +839,26 @@ private String byteArrayToString(byte[] bytes) {
     }
 
     private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int endIndex, boolean littleEndian) {
-        byte[] bytes = new byte[endIndex-startIndex+1];
+        byte[] bytes = new byte[endIndex - startIndex + 1];
         if (littleEndian) {
-            for (int i = 0; i <= endIndex-startIndex; i++) {
-                bytes[i] = byteBuffer[startIndex+bytes.length-1-i];
+            for (int i = 0; i <= endIndex - startIndex; i++) {
+                bytes[i] = byteBuffer[startIndex + bytes.length - 1 - i];
             }
-        }
-        else {
-            for (int i = 0; i <= endIndex-startIndex; i++) {
-                bytes[i] = byteBuffer[startIndex+i];
+        } else {
+            for (int i = 0; i <= endIndex - startIndex; i++) {
+                bytes[i] = byteBuffer[startIndex + i];
             }
         }
 
 
-        int length = endIndex-startIndex +1;
+        int length = endIndex - startIndex + 1;
         // We treat a 1-4 byte number as decimal string
         if (length < 5) {
             long number = 0l;
-            for (int i = 0; i < bytes.length; i++)  {
-                long byteValue = (long) (bytes[bytes.length - i-1] & 0xff);
-                long positionValue = (long) Math.pow(256.0,i*1.0);
-                long calculatedValue =  (byteValue * positionValue);
+            for (int i = 0; i < bytes.length; i++) {
+                long byteValue = (long) (bytes[bytes.length - i - 1] & 0xff);
+                long positionValue = (long) Math.pow(256.0, i * 1.0);
+                long calculatedValue = (byteValue * positionValue);
                 number += calculatedValue;
             }
             return Long.toString(number);
@@ -889,18 +870,18 @@ private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int
         // And if it is a 12 byte number we add dashes to it to make it look like a standard UUID
         if (bytes.length == 16) {
             StringBuilder sb = new StringBuilder();
-            sb.append(hexString.substring(0,8));
+            sb.append(hexString.substring(0, 8));
             sb.append("-");
-            sb.append(hexString.substring(8,12));
+            sb.append(hexString.substring(8, 12));
             sb.append("-");
-            sb.append(hexString.substring(12,16));
+            sb.append(hexString.substring(12, 16));
             sb.append("-");
-            sb.append(hexString.substring(16,20));
+            sb.append(hexString.substring(16, 20));
             sb.append("-");
-            sb.append(hexString.substring(20,32));
+            sb.append(hexString.substring(20, 32));
             return sb.toString();
         }
-        return "0x"+hexString;
+        return "0x" + hexString;
     }
 
     @TargetApi(Build.VERSION_CODES.GINGERBREAD)
@@ -913,30 +894,30 @@ private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int
 
     @Override
     public int hashCode() {
-        return Arrays.hashCode(new Object[] {
-                mMatchingBeaconTypeCode,
-                mIdentifierStartOffsets,
-                mIdentifierEndOffsets,
-                mIdentifierLittleEndianFlags,
-                mDataStartOffsets,
-                mDataEndOffsets,
-                mDataLittleEndianFlags,
-                mIdentifierVariableLengthFlags,
-                mMatchingBeaconTypeCodeStartOffset,
-                mMatchingBeaconTypeCodeEndOffset,
-                mServiceUuidStartOffset,
-                mServiceUuidEndOffset,
-                mServiceUuid,
-                mExtraFrame,
-                mPowerStartOffset,
-                mPowerEndOffset,
-                mDBmCorrection,
-                mLayoutSize,
-                mAllowPduOverflow,
-                mIdentifier,
-                mHardwareAssistManufacturers,
-                extraParsers
-            }
+        return Arrays.hashCode(new Object[]{
+                        mMatchingBeaconTypeCode,
+                        mIdentifierStartOffsets,
+                        mIdentifierEndOffsets,
+                        mIdentifierLittleEndianFlags,
+                        mDataStartOffsets,
+                        mDataEndOffsets,
+                        mDataLittleEndianFlags,
+                        mIdentifierVariableLengthFlags,
+                        mMatchingBeaconTypeCodeStartOffset,
+                        mMatchingBeaconTypeCodeEndOffset,
+                        mServiceUuidStartOffset,
+                        mServiceUuidEndOffset,
+                        mServiceUuid,
+                        mExtraFrame,
+                        mPowerStartOffset,
+                        mPowerEndOffset,
+                        mDBmCorrection,
+                        mLayoutSize,
+                        mAllowPduOverflow,
+                        mIdentifier,
+                        mHardwareAssistManufacturers,
+                        extraParsers
+                }
         );
     }
 
@@ -950,9 +931,15 @@ public boolean equals(Object o) {
                     return true;
                 }
             }
+        } catch (ClassCastException e) {
         }
-        catch (ClassCastException e ) { }
         return false;
     }
 
+    public static class BeaconLayoutException extends RuntimeException {
+        public BeaconLayoutException(String s) {
+            super(s);
+        }
+    }
+
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java b/lib/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
index 4f8fb4f2..ac5ad1fa 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
@@ -46,8 +46,9 @@
     /**
      * Creates a new beacon transmitter capable of transmitting beacons with the format
      * specified in the BeaconParser and with the data fields specified in the Beacon object
+     *
      * @param context
-     * @param parser specifies the format of the beacon transmission
+     * @param parser  specifies the format of the beacon transmission
      */
     public BeaconTransmitter(Context context, BeaconParser parser) {
         mBeaconParser = parser;
@@ -58,14 +59,102 @@ public BeaconTransmitter(Context context, BeaconParser parser) {
             mBluetoothLeAdvertiser = mBluetoothAdapter.getBluetoothLeAdvertiser();
             LogManager.d(TAG, "new BeaconTransmitter constructed.  mbluetoothLeAdvertiser is %s",
                     mBluetoothLeAdvertiser);
-        }
-        else {
+        } else {
             LogManager.e(TAG, "Failed to get BluetoothManager");
         }
     }
 
+    /**
+     * Checks to see if this device supports beacon advertising
+     *
+     * @return SUPPORTED if yes, otherwise:
+     * NOT_SUPPORTED_MIN_SDK
+     * NOT_SUPPORTED_BLE
+     * NOT_SUPPORTED_MULTIPLE_ADVERTISEMENTS
+     * NOT_SUPPORTED_CANNOT_GET_ADVERTISER
+     */
+    public static int checkTransmissionSupported(Context context) {
+        int returnCode = SUPPORTED;
+
+        if (android.os.Build.VERSION.SDK_INT < 21) {
+            returnCode = NOT_SUPPORTED_MIN_SDK;
+        } else if (!context.getApplicationContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            returnCode = NOT_SUPPORTED_BLE;
+        } else {
+            try {
+                // Check to see if the getBluetoothLeAdvertiser is available.  If not, this will throw an exception indicating we are not running Android L
+                if (((BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().getBluetoothLeAdvertiser() == null) {
+                    if (!((BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isMultipleAdvertisementSupported()) {
+                        returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER_MULTIPLE_ADVERTISEMENTS;
+                    } else {
+                        returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER;
+                    }
+                }
+            } catch (Exception e) {
+                returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER;
+            }
+        }
+
+        return returnCode;
+    }
+
+    /**
+     * Parse UUID from bytes. The {@code uuidBytes} can represent a 16-bit, 32-bit or 128-bit UUID,
+     * but the returned UUID is always in 128-bit format.
+     * Note UUID is little endian in Bluetooth.
+     *
+     * @param uuidBytes Byte representation of uuid.
+     * @return {@link ParcelUuid} parsed from bytes.
+     * @throws IllegalArgumentException If the {@code uuidBytes} cannot be parsed.
+     *                                  <p>
+     *                                  Copied from java/android/bluetooth/BluetoothUuid.java
+     *                                  Copyright (C) 2009 The Android Open Source Project
+     *                                  Licensed under the Apache License, Version 2.0
+     */
+    private static ParcelUuid parseUuidFrom(byte[] uuidBytes) {
+        /** Length of bytes for 16 bit UUID */
+        final int UUID_BYTES_16_BIT = 2;
+        /** Length of bytes for 32 bit UUID */
+        final int UUID_BYTES_32_BIT = 4;
+        /** Length of bytes for 128 bit UUID */
+        final int UUID_BYTES_128_BIT = 16;
+        final ParcelUuid BASE_UUID =
+                ParcelUuid.fromString("00000000-0000-1000-8000-00805F9B34FB");
+        if (uuidBytes == null) {
+            throw new IllegalArgumentException("uuidBytes cannot be null");
+        }
+        int length = uuidBytes.length;
+        if (length != UUID_BYTES_16_BIT && length != UUID_BYTES_32_BIT &&
+                length != UUID_BYTES_128_BIT) {
+            throw new IllegalArgumentException("uuidBytes length invalid - " + length);
+        }
+        // Construct a 128 bit UUID.
+        if (length == UUID_BYTES_128_BIT) {
+            ByteBuffer buf = ByteBuffer.wrap(uuidBytes).order(ByteOrder.LITTLE_ENDIAN);
+            long msb = buf.getLong(8);
+            long lsb = buf.getLong(0);
+            return new ParcelUuid(new UUID(msb, lsb));
+        }
+        // For 16 bit and 32 bit UUID we need to convert them to 128 bit value.
+        // 128_bit_value = uuid * 2^96 + BASE_UUID
+        long shortUuid;
+        if (length == UUID_BYTES_16_BIT) {
+            shortUuid = uuidBytes[0] & 0xFF;
+            shortUuid += (uuidBytes[1] & 0xFF) << 8;
+        } else {
+            shortUuid = uuidBytes[0] & 0xFF;
+            shortUuid += (uuidBytes[1] & 0xFF) << 8;
+            shortUuid += (uuidBytes[2] & 0xFF) << 16;
+            shortUuid += (uuidBytes[3] & 0xFF) << 24;
+        }
+        long msb = BASE_UUID.getUuid().getMostSignificantBits() + (shortUuid << 32);
+        long lsb = BASE_UUID.getUuid().getLeastSignificantBits();
+        return new ParcelUuid(new UUID(msb, lsb));
+    }
+
     /**
      * Tells if transmission has started
+     *
      * @return
      */
     public boolean isStarted() {
@@ -74,6 +163,7 @@ public boolean isStarted() {
 
     /**
      * Sets the beacon whose fields will be transmitted
+     *
      * @param beacon
      */
     public void setBeacon(Beacon beacon) {
@@ -82,6 +172,7 @@ public void setBeacon(Beacon beacon) {
 
     /**
      * Sets the beaconParsser used for formatting the transmission
+     *
      * @param beaconParser
      */
     public void setBeaconParser(BeaconParser beaconParser) {
@@ -89,8 +180,8 @@ public void setBeaconParser(BeaconParser beaconParser) {
     }
 
     /**
-     * @see #setAdvertiseMode(int)
      * @return advertiseMode
+     * @see #setAdvertiseMode(int)
      */
     public int getAdvertiseMode() {
         return mAdvertiseMode;
@@ -100,6 +191,7 @@ public int getAdvertiseMode() {
      * AdvertiseSettings.ADVERTISE_MODE_BALANCED 3 Hz
      * AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY 10 Hz
      * AdvertiseSettings.ADVERTISE_MODE_LOW_POWER 1 Hz
+     *
      * @param mAdvertiseMode
      */
     public void setAdvertiseMode(int mAdvertiseMode) {
@@ -107,8 +199,8 @@ public void setAdvertiseMode(int mAdvertiseMode) {
     }
 
     /**
-     * @see #setAdvertiseTxPowerLevel(int mAdvertiseTxPowerLevel)
      * @return txPowerLevel
+     * @see #setAdvertiseTxPowerLevel(int mAdvertiseTxPowerLevel)
      */
     public int getAdvertiseTxPowerLevel() {
         return mAdvertiseTxPowerLevel;
@@ -119,6 +211,7 @@ public int getAdvertiseTxPowerLevel() {
      * AdvertiseSettings.ADVERTISE_TX_POWER_LOW -75 dBm @ 1 meter with Nexus 5
      * AdvertiseSettings.ADVERTISE_TX_POWER_MEDIUM -66 dBm @ 1 meter with Nexus 5
      * AdvertiseSettings.ADVERTISE_TX_POWER_ULTRA_LOW not detected with Nexus 5
+     *
      * @param mAdvertiseTxPowerLevel
      */
     public void setAdvertiseTxPowerLevel(int mAdvertiseTxPowerLevel) {
@@ -126,23 +219,25 @@ public void setAdvertiseTxPowerLevel(int mAdvertiseTxPowerLevel) {
     }
 
     /**
-     * Whether the advertisement should indicate the device is connectable.
-     * @param connectable
+     * @return connectable
+     * @see #setConnectable(boolean)
      */
-    public void setConnectable(boolean connectable) {
-        this.mConnectable = connectable;
+    public boolean isConnectable() {
+        return mConnectable;
     }
 
     /**
-     * @see #setConnectable(boolean)
-     * @return connectable
+     * Whether the advertisement should indicate the device is connectable.
+     *
+     * @param connectable
      */
-    public boolean isConnectable() {
-        return mConnectable;
+    public void setConnectable(boolean connectable) {
+        this.mConnectable = connectable;
     }
 
     /**
      * Starts advertising with fields from the passed beacon
+     *
      * @param beacon
      */
     public void startAdvertising(Beacon beacon) {
@@ -151,6 +246,7 @@ public void startAdvertising(Beacon beacon) {
 
     /**
      * Starts advertising with fields from the passed beacon
+     *
      * @param beacon
      */
     public void startAdvertising(Beacon beacon, AdvertiseCallback callback) {
@@ -178,20 +274,20 @@ public void startAdvertising() {
 
         byte[] advertisingBytes = mBeaconParser.getBeaconAdvertisementData(mBeacon);
         String byteString = "";
-        for (int i= 0; i < advertisingBytes.length; i++) {
+        for (int i = 0; i < advertisingBytes.length; i++) {
             byteString += String.format("%02X", advertisingBytes[i]);
             byteString += " ";
         }
         LogManager.d(TAG, "Starting advertising with ID1: %s ID2: %s ID3: %s and data: %s of size "
                         + "%s", mBeacon.getId1(),
-                        mBeacon.getIdentifiers().size() > 1 ? mBeacon.getId2() : "",
-                        mBeacon.getIdentifiers().size() > 2 ? mBeacon.getId3() : "", byteString,
+                mBeacon.getIdentifiers().size() > 1 ? mBeacon.getId2() : "",
+                mBeacon.getIdentifiers().size() > 2 ? mBeacon.getId3() : "", byteString,
                 advertisingBytes.length);
 
-        try{
+        try {
             AdvertiseData.Builder dataBuilder = new AdvertiseData.Builder();
             if (serviceUuid > 0) {
-                byte[] serviceUuidBytes = new byte[] {
+                byte[] serviceUuidBytes = new byte[]{
                         (byte) (serviceUuid & 0xff),
                         (byte) ((serviceUuid >> 8) & 0xff)};
                 ParcelUuid parcelUuid = parseUuidFrom(serviceUuidBytes);
@@ -213,7 +309,7 @@ public void startAdvertising() {
             mBluetoothLeAdvertiser.startAdvertising(settingsBuilder.build(), dataBuilder.build(), getAdvertiseCallback());
             LogManager.d(TAG, "Started advertisement with callback: %s", getAdvertiseCallback());
 
-        } catch (Exception e){
+        } catch (Exception e) {
             LogManager.e(e, TAG, "Cannot start advertising due to exception");
         }
     }
@@ -230,55 +326,18 @@ public void stopAdvertising() {
         mAdvertisingClientCallback = null;
         try {
             mBluetoothLeAdvertiser.stopAdvertising(getAdvertiseCallback());
-        }
-        catch (IllegalStateException e) {
+        } catch (IllegalStateException e) {
             LogManager.w(TAG, "Bluetooth is turned off. Transmitter stop call failed.");
         }
         mStarted = false;
     }
 
-    /**
-     * Checks to see if this device supports beacon advertising
-     * @return SUPPORTED if yes, otherwise:
-     *          NOT_SUPPORTED_MIN_SDK
-     *          NOT_SUPPORTED_BLE
-     *          NOT_SUPPORTED_MULTIPLE_ADVERTISEMENTS
-     *          NOT_SUPPORTED_CANNOT_GET_ADVERTISER
-     */
-    public static int checkTransmissionSupported(Context context) {
-        int returnCode = SUPPORTED;
-
-        if (android.os.Build.VERSION.SDK_INT < 21) {
-            returnCode = NOT_SUPPORTED_MIN_SDK;
-        }
-        else if (!context.getApplicationContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
-            returnCode = NOT_SUPPORTED_BLE;
-        }
-        else {
-            try {
-                // Check to see if the getBluetoothLeAdvertiser is available.  If not, this will throw an exception indicating we are not running Android L
-                if (((BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().getBluetoothLeAdvertiser() == null) {
-                    if (!((BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isMultipleAdvertisementSupported()) {
-                        returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER_MULTIPLE_ADVERTISEMENTS;
-                    }
-                    else {
-                        returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER;
-                    }
-                }
-            } catch (Exception e) {
-                returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER;
-            }
-        }
-
-        return returnCode;
-    }
-
     private AdvertiseCallback getAdvertiseCallback() {
         if (mAdvertiseCallback == null) {
             mAdvertiseCallback = new AdvertiseCallback() {
                 @Override
                 public void onStartFailure(int errorCode) {
-                    LogManager.e(TAG,"Advertisement start failed, code: %s", errorCode);
+                    LogManager.e(TAG, "Advertisement start failed, code: %s", errorCode);
                     if (mAdvertisingClientCallback != null) {
                         mAdvertisingClientCallback.onStartFailure(errorCode);
                     }
@@ -287,7 +346,7 @@ public void onStartFailure(int errorCode) {
 
                 @Override
                 public void onStartSuccess(AdvertiseSettings settingsInEffect) {
-                    LogManager.i(TAG,"Advertisement start succeeded.");
+                    LogManager.i(TAG, "Advertisement start succeeded.");
                     mStarted = true;
                     if (mAdvertisingClientCallback != null) {
                         mAdvertisingClientCallback.onStartSuccess(settingsInEffect);
@@ -301,58 +360,4 @@ public void onStartSuccess(AdvertiseSettings settingsInEffect) {
         return mAdvertiseCallback;
     }
 
-    /**
-     * Parse UUID from bytes. The {@code uuidBytes} can represent a 16-bit, 32-bit or 128-bit UUID,
-     * but the returned UUID is always in 128-bit format.
-     * Note UUID is little endian in Bluetooth.
-     *
-     * @param uuidBytes Byte representation of uuid.
-     * @return {@link ParcelUuid} parsed from bytes.
-     * @throws IllegalArgumentException If the {@code uuidBytes} cannot be parsed.
-     *
-     * Copied from java/android/bluetooth/BluetoothUuid.java
-     * Copyright (C) 2009 The Android Open Source Project
-     * Licensed under the Apache License, Version 2.0
-     */
-    private static ParcelUuid parseUuidFrom(byte[] uuidBytes) {
-        /** Length of bytes for 16 bit UUID */
-        final int UUID_BYTES_16_BIT = 2;
-        /** Length of bytes for 32 bit UUID */
-        final int UUID_BYTES_32_BIT = 4;
-        /** Length of bytes for 128 bit UUID */
-        final int UUID_BYTES_128_BIT = 16;
-        final ParcelUuid BASE_UUID =
-                ParcelUuid.fromString("00000000-0000-1000-8000-00805F9B34FB");
-        if (uuidBytes == null) {
-            throw new IllegalArgumentException("uuidBytes cannot be null");
-        }
-        int length = uuidBytes.length;
-        if (length != UUID_BYTES_16_BIT && length != UUID_BYTES_32_BIT &&
-                length != UUID_BYTES_128_BIT) {
-            throw new IllegalArgumentException("uuidBytes length invalid - " + length);
-        }
-        // Construct a 128 bit UUID.
-        if (length == UUID_BYTES_128_BIT) {
-            ByteBuffer buf = ByteBuffer.wrap(uuidBytes).order(ByteOrder.LITTLE_ENDIAN);
-            long msb = buf.getLong(8);
-            long lsb = buf.getLong(0);
-            return new ParcelUuid(new UUID(msb, lsb));
-        }
-        // For 16 bit and 32 bit UUID we need to convert them to 128 bit value.
-        // 128_bit_value = uuid * 2^96 + BASE_UUID
-        long shortUuid;
-        if (length == UUID_BYTES_16_BIT) {
-            shortUuid = uuidBytes[0] & 0xFF;
-            shortUuid += (uuidBytes[1] & 0xFF) << 8;
-        } else {
-            shortUuid = uuidBytes[0] & 0xFF ;
-            shortUuid += (uuidBytes[1] & 0xFF) << 8;
-            shortUuid += (uuidBytes[2] & 0xFF) << 16;
-            shortUuid += (uuidBytes[3] & 0xFF) << 24;
-        }
-        long msb = BASE_UUID.getUuid().getMostSignificantBits() + (shortUuid << 32);
-        long lsb = BASE_UUID.getUuid().getLeastSignificantBits();
-        return new ParcelUuid(new UUID(msb, lsb));
-    }
-
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/BleNotAvailableException.java b/lib/src/main/java/org/altbeacon/beacon/BleNotAvailableException.java
index 4cf316e1..50c1b9af 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BleNotAvailableException.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BleNotAvailableException.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -25,16 +25,16 @@
 
 /**
  * Indicates that Bluetooth Low Energy is not available on this device
- * @see BeaconManager#checkAvailability
- * @author David G. Young
  *
+ * @author David G. Young
+ * @see BeaconManager#checkAvailability
  */
 public class BleNotAvailableException extends RuntimeException {
 
     private static final long serialVersionUID = 2242747823097637729L;
 
     public BleNotAvailableException(String message) {
-            super(message);
-        }
+        super(message);
+    }
 
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/Identifier.java b/lib/src/main/java/org/altbeacon/beacon/Identifier.java
index d96e567a..e27bc2b4 100644
--- a/lib/src/main/java/org/altbeacon/beacon/Identifier.java
+++ b/lib/src/main/java/org/altbeacon/beacon/Identifier.java
@@ -3,8 +3,6 @@
 import android.annotation.TargetApi;
 import android.os.Build;
 
-import org.altbeacon.beacon.logging.LogManager;
-
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.LongBuffer;
@@ -27,41 +25,69 @@
     // BUG: Dashes in UUIDs are not optional!
     private static final Pattern UUID_PATTERN = Pattern.compile("^[0-9A-Fa-f]{8}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{12}$");
     private static final int MAX_INTEGER = 65535;
-
+    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
     private final byte[] mValue;
 
+    /**
+     * Creates a new copy of the specified Identifier.
+     *
+     * @param identifier identifier to copy
+     * @deprecated objects of this class are immutable and therefore don't have to be cloned when
+     * used from multiple threads
+     */
+    @Deprecated
+    public Identifier(Identifier identifier) {
+        if (identifier == null) {
+            throw new NullPointerException("Identifiers cannot be constructed from null pointers but \"identifier\" is null.");
+        }
+        mValue = identifier.mValue;
+    }
+
+    /**
+     * Creates a new instance of Identifier
+     *
+     * @param value value to use. This value isn't copied, so don't change the value after using it to create an instance!
+     */
+    protected Identifier(byte[] value) {
+        if (value == null) {
+            throw new NullPointerException("Identifiers cannot be constructed from null pointers but \"value\" is null.");
+        }
+        this.mValue = value;
+    }
+
     /**
      * Takes the passed string and tries to figure out what format it is in.
      * Then turns the string into plain bytes and constructs an Identifier.
-     *
+     * <p>
      * Known bug: This method happily parses UUIDs without dashes (normally
      * invalid). Although the bug is left unfixed for backward compatibility,
      * please check your UUIDs or even better, use
      * {@link #fromUuid(java.util.UUID)} directly, which is safe.
-     *
+     * <p>
      * Allowed formats:
      * <ul>
-     *   <li>UUID: 2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6 (16 bytes)</li>
-     *   <li>Hexadecimal: 0x000000000003 (variable length)</li>
-     *   <li>Decimal: 1337 (2 bytes)</li>
+     * <li>UUID: 2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6 (16 bytes)</li>
+     * <li>Hexadecimal: 0x000000000003 (variable length)</li>
+     * <li>Decimal: 1337 (2 bytes)</li>
      * </ul>
      *
-     * @param  stringValue string to parse
-     * @return             Identifier representing the specified value
-     * @throws             IllegalArgumentException if the passed string cannot be parsed
-     * @throws             NullPointerException if the passed string is <code>null</code>
-     * @see                <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122 on UUIDs</a>
+     * @param stringValue string to parse
+     * @return Identifier representing the specified value
+     * @throws IllegalArgumentException if the passed string cannot be parsed
+     * @throws NullPointerException     if the passed string is <code>null</code>
+     * @see <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122 on UUIDs</a>
      */
     public static Identifier parse(String stringValue) {
-       return parse(stringValue, -1);
+        return parse(stringValue, -1);
     }
 
     /**
      * Variant of the parse method that allows specifying the byte length of the identifier.
-     * @see #parse(String)
+     *
      * @param stringValue
      * @param desiredByteLength
      * @return
+     * @see #parse(String)
      */
     public static Identifier parse(String stringValue, int desiredByteLength) {
         if (stringValue == null) {
@@ -80,14 +106,12 @@ public static Identifier parse(String stringValue, int desiredByteLength) {
             int value = -1;
             try {
                 value = Integer.valueOf(stringValue);
-            }
-            catch (Throwable t) {
+            } catch (Throwable t) {
                 throw new IllegalArgumentException("Unable to parse Identifier in decimal format.", t);
             }
             if (desiredByteLength <= 0 || desiredByteLength == 2) {
                 return fromInt(value);
-            }
-            else {
+            } else {
                 return fromLong(value, desiredByteLength);
             }
         }
@@ -102,28 +126,29 @@ public static Identifier parse(String stringValue, int desiredByteLength) {
     private static Identifier parseHex(String identifierString, int desiredByteLength) {
         String str = identifierString.length() % 2 == 0 ? "" : "0";
         str += identifierString.toUpperCase();
-        if (desiredByteLength > 0 && desiredByteLength < str.length()/2) {
+        if (desiredByteLength > 0 && desiredByteLength < str.length() / 2) {
             str = str.substring(str.length() - desiredByteLength * 2);
         }
-        if (desiredByteLength > 0 && desiredByteLength > str.length()/2) {
-            int extraCharsToAdd = desiredByteLength*2 - str.length();
+        if (desiredByteLength > 0 && desiredByteLength > str.length() / 2) {
+            int extraCharsToAdd = desiredByteLength * 2 - str.length();
             StringBuilder sb = new StringBuilder();
             while (sb.length() < extraCharsToAdd) {
                 sb.append("0");
             }
-            str = sb.toString()+str;
+            str = sb.toString() + str;
         }
 
         byte[] result = new byte[str.length() / 2];
         for (int i = 0; i < result.length; i++) {
-            result[i] = (byte)(Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16) & 0xFF);
+            result[i] = (byte) (Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16) & 0xFF);
         }
         return new Identifier(result);
     }
 
     /**
      * Creates an Identifer backed by an array of length desiredByteLength
-     * @param longValue a long to put into the identifier
+     *
+     * @param longValue         a long to put into the identifier
      * @param desiredByteLength how many bytes to make the identifier
      * @return
      */
@@ -132,7 +157,7 @@ public static Identifier fromLong(long longValue, int desiredByteLength) {
             throw new IllegalArgumentException("Identifier length must be > 0.");
         }
         byte[] newValue = new byte[desiredByteLength];
-        for (int i = desiredByteLength-1; i >= 0; i--) {
+        for (int i = desiredByteLength - 1; i >= 0; i--) {
             newValue[i] = (byte) (longValue & 0xff);
             longValue = longValue >> 8;
         }
@@ -141,6 +166,7 @@ public static Identifier fromLong(long longValue, int desiredByteLength) {
 
     /**
      * Creates an Identifier backed by a two byte Array (big endian).
+     *
      * @param intValue an integer between 0 and 65535 (inclusive)
      * @return an Identifier with the specified value
      */
@@ -159,14 +185,15 @@ public static Identifier fromInt(int intValue) {
 
     /**
      * Creates an Identifier from the specified byte array.
-     * @param bytes array to copy from
-     * @param start the start index, inclusive
-     * @param end the end index, exclusive
+     *
+     * @param bytes        array to copy from
+     * @param start        the start index, inclusive
+     * @param end          the end index, exclusive
      * @param littleEndian whether the bytes are ordered in little endian
      * @return a new Identifier
-     * @throws java.lang.NullPointerException <code>bytes</code> must not be <code>null</code>
+     * @throws java.lang.NullPointerException           <code>bytes</code> must not be <code>null</code>
      * @throws java.lang.ArrayIndexOutOfBoundsException start or end are outside the bounds of the array
-     * @throws java.lang.IllegalArgumentException start is larger than end
+     * @throws java.lang.IllegalArgumentException       start is larger than end
      */
     @TargetApi(Build.VERSION_CODES.GINGERBREAD)
     public static Identifier fromBytes(byte[] bytes, int start, int end, boolean littleEndian) {
@@ -202,29 +229,13 @@ public static Identifier fromUuid(UUID uuid) {
         return new Identifier(buf.array());
     }
 
-    /**
-     * Creates a new copy of the specified Identifier.
-     * @param identifier identifier to copy
-     * @deprecated objects of this class are immutable and therefore don't have to be cloned when
-     * used from multiple threads
-     */
-    @Deprecated
-    public Identifier(Identifier identifier) {
-        if (identifier == null) {
-            throw new NullPointerException("Identifiers cannot be constructed from null pointers but \"identifier\" is null.");
-        }
-        mValue = identifier.mValue;
-    }
-
-    /**
-     * Creates a new instance of Identifier
-     * @param value value to use. This value isn't copied, so don't change the value after using it to create an instance!
-     */
-    protected Identifier(byte[] value) {
-        if (value == null) {
-            throw new NullPointerException("Identifiers cannot be constructed from null pointers but \"value\" is null.");
+    private static void reverseArray(byte[] bytes) {
+        for (int i = 0; i < bytes.length / 2; i++) {
+            int mirroredIndex = bytes.length - i - 1;
+            byte tmp = bytes[i];
+            bytes[i] = bytes[mirroredIndex];
+            bytes[mirroredIndex] = tmp;
         }
-        this.mValue = value;
     }
 
     /**
@@ -232,6 +243,7 @@ protected Identifier(byte[] value) {
      * <ul><li>When the value is 2 bytes long: decimal, for example 6536
      * <li>When the value is 16 bytes long: uuid, for example 2f234454-cf6d-4a0f-adf2-f4911ba9ffa6
      * <li>Else: hexadecimal prefixed with <code>0x</code>, for example 0x0012ab</ul>
+     *
      * @return string representation of the current value
      */
     public String toString() {
@@ -248,6 +260,7 @@ public String toString() {
 
     /**
      * Represents the value as an <code>int</code>.
+     *
      * @return value represented as int
      * @throws java.lang.UnsupportedOperationException when value length is longer than 2
      */
@@ -266,6 +279,7 @@ public int toInt() {
 
     /**
      * Converts identifier to a byte array
+     *
      * @param bigEndian true if bytes are MSB first
      * @return a new byte array with a copy of the value
      */
@@ -280,17 +294,9 @@ public int toInt() {
         return copy;
     }
 
-    private static void reverseArray(byte[] bytes) {
-        for (int i = 0; i < bytes.length / 2; i++) {
-            int mirroredIndex = bytes.length - i - 1;
-            byte tmp = bytes[i];
-            bytes[i] = bytes[mirroredIndex];
-            bytes[mirroredIndex] = tmp;
-        }
-    }
-
     /**
      * Returns the byte length of this identifier.
+     *
      * @return length of identifier
      */
     public int getByteCount() {
@@ -305,6 +311,7 @@ public int hashCode() {
     /**
      * Returns whether both Identifiers contain equal value. This is the case when the value is the same
      * and has the same length
+     *
      * @param that object to compare to
      * @return whether that equals this
      */
@@ -317,18 +324,17 @@ public boolean equals(Object that) {
         return Arrays.equals(mValue, thatIdentifier.mValue);
     }
 
-    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
-
     /**
      * Represents the value as a hexadecimal String. The String is prefixed with <code>0x</code>. For example 0x0034ab
+     *
      * @return value as hexadecimal String
      */
     public String toHexString() {
         final int l = mValue.length;
-        final char[] out = new char[l*2+2];
+        final char[] out = new char[l * 2 + 2];
         out[0] = '0';
         out[1] = 'x';
-        for( int i=0,j=2; i<l; i++ ){
+        for (int i = 0, j = 2; i < l; i++) {
             out[j++] = HEX_DIGITS[(0xF0 & mValue[i]) >>> 4];
             out[j++] = HEX_DIGITS[0x0F & mValue[i]];
         }
@@ -338,11 +344,12 @@ public String toHexString() {
 
     /**
      * Returns the value of this Identifier in UUID format. For example 2f234454-cf6d-4a0f-adf2-f4911ba9ffa6
-     * @deprecated Replaced by stronger typed variant.
-     *    This mathod returns a string, therefore does not offer type safety on
-     *    the UUID per se. It was replaced by {@link #toUuid()}.
+     *
      * @return value in UUID format
      * @throws UnsupportedOperationException when value length is not 16 bytes
+     * @deprecated Replaced by stronger typed variant.
+     * This mathod returns a string, therefore does not offer type safety on
+     * the UUID per se. It was replaced by {@link #toUuid()}.
      */
     @Deprecated
     public String toUuidString() {
@@ -353,7 +360,7 @@ public String toUuidString() {
      * Gives you the Identifier as a UUID if possible.
      *
      * @throws UnsupportedOperationException if the byte array backing this Identifier is not exactly
-     *         16 bytes long.
+     *                                       16 bytes long.
      */
     public UUID toUuid() {
         if (mValue.length != 16) {
@@ -378,10 +385,10 @@ public UUID toUuid() {
      * When the Identifiers don't have the same length, the Identifier having the shortest
      * array is considered smaller than the other.
      *
-     * @param  that the other identifier
-     * @return      0 if both identifiers are equal.  Otherwise returns -1 or 1 depending
-     *              on which is bigger than the other.
-     * @see         Comparable#compareTo
+     * @param that the other identifier
+     * @return 0 if both identifiers are equal.  Otherwise returns -1 or 1 depending
+     * on which is bigger than the other.
+     * @see Comparable#compareTo
      */
     @Override
     public int compareTo(Identifier that) {
diff --git a/lib/src/main/java/org/altbeacon/beacon/IntentHandler.java b/lib/src/main/java/org/altbeacon/beacon/IntentHandler.java
index 6e6c84a7..2159ee6b 100644
--- a/lib/src/main/java/org/altbeacon/beacon/IntentHandler.java
+++ b/lib/src/main/java/org/altbeacon/beacon/IntentHandler.java
@@ -14,16 +14,16 @@
  * Converts internal Intents for ranging/monitoring to notifier callbacks.
  * These may be local broadcast intents from BeaconLocalBroadcastProcessor or
  * global broadcast intents fro BeaconIntentProcessor
- *
+ * <p>
  * Internal library class.  Do not use directly from outside the library
  *
- * @hide
- * Created by dyoung on 7/20/17.
+ * @hide Created by dyoung on 7/20/17.
  */
 
 /* package private*/
 class IntentHandler {
     private static final String TAG = IntentHandler.class.getSimpleName();
+
     public void convertIntentsToCallbacks(Context context, Intent intent) {
         MonitoringData monitoringData = null;
         RangingData rangingData = null;
@@ -45,11 +45,10 @@ public void convertIntentsToCallbacks(Context context, Intent intent) {
             Set<RangeNotifier> notifiers = BeaconManager.getInstanceForApplication(context).getRangingNotifiers();
             java.util.Collection<Beacon> beacons = rangingData.getBeacons();
             if (notifiers != null) {
-                for(RangeNotifier notifier : notifiers){
+                for (RangeNotifier notifier : notifiers) {
                     notifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
                 }
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "but ranging notifier is null, so we're dropping it.");
             }
             RangeNotifier dataNotifier = BeaconManager.getInstanceForApplication(context).getDataRequestNotifier();
@@ -62,7 +61,7 @@ public void convertIntentsToCallbacks(Context context, Intent intent) {
             LogManager.d(TAG, "got monitoring data");
             Set<MonitorNotifier> notifiers = BeaconManager.getInstanceForApplication(context).getMonitoringNotifiers();
             if (notifiers != null) {
-                for(MonitorNotifier notifier : notifiers) {
+                for (MonitorNotifier notifier : notifiers) {
                     LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
                     Region region = monitoringData.getRegion();
                     Integer state = monitoringData.isInside() ? MonitorNotifier.INSIDE :
diff --git a/lib/src/main/java/org/altbeacon/beacon/MonitorNotifier.java b/lib/src/main/java/org/altbeacon/beacon/MonitorNotifier.java
index 0a908b41..07a0a56a 100644
--- a/lib/src/main/java/org/altbeacon/beacon/MonitorNotifier.java
+++ b/lib/src/main/java/org/altbeacon/beacon/MonitorNotifier.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -26,11 +26,10 @@
 /**
  * This interface is implemented by classes that receive beacon monitoring notifications
  *
+ * @author David G. Young
  * @see BeaconManager#setMonitorNotifier(MonitorNotifier notifier)
  * @see BeaconManager#startMonitoringBeaconsInRegion(Region region)
  * @see Region
- *
- * @author David G. Young
  */
 public interface MonitorNotifier {
     /**
@@ -44,12 +43,14 @@
 
     /**
      * Called when at least one beacon in a <code>Region</code> is visible.
+     *
      * @param region a Region that defines the criteria of beacons to look for
      */
     public void didEnterRegion(Region region);
 
     /**
      * Called when no beacons in a <code>Region</code> are visible.
+     *
      * @param region a Region that defines the criteria of beacons to look for
      */
     public void didExitRegion(Region region);
@@ -57,7 +58,8 @@
     /**
      * Called with a state value of MonitorNotifier.INSIDE when at least one beacon in a <code>Region</code> is visible.
      * Called with a state value of MonitorNotifier.OUTSIDE when no beacons in a <code>Region</code> are visible.
-     * @param state either MonitorNotifier.INSIDE or MonitorNotifier.OUTSIDE
+     *
+     * @param state  either MonitorNotifier.INSIDE or MonitorNotifier.OUTSIDE
      * @param region a Region that defines the criteria of beacons to look for
      */
     public void didDetermineStateForRegion(int state, Region region);
diff --git a/lib/src/main/java/org/altbeacon/beacon/RangeNotifier.java b/lib/src/main/java/org/altbeacon/beacon/RangeNotifier.java
index 528da0cc..9fbb5e59 100644
--- a/lib/src/main/java/org/altbeacon/beacon/RangeNotifier.java
+++ b/lib/src/main/java/org/altbeacon/beacon/RangeNotifier.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -24,22 +24,22 @@
 package org.altbeacon.beacon;
 
 import java.util.Collection;
+
 /**
  * This interface is implemented by classes that receive beacon ranging notifications
  *
+ * @author David G. Young
  * @see BeaconManager#setRangeNotifier(RangeNotifier notifier)
  * @see BeaconManager#startRangingBeaconsInRegion(Region region)
  * @see Region
  * @see Beacon
- *
- * @author David G. Young
- *
  */
 public interface RangeNotifier {
     /**
      * Called once per second to give an estimate of the mDistance to visible beacons
+     *
      * @param beacons a collection of <code>Beacon<code> objects that have been seen in the past second
-     * @param region the <code>Region</code> object that defines the criteria for the ranged beacons
+     * @param region  the <code>Region</code> object that defines the criteria for the ranged beacons
      */
     public void didRangeBeaconsInRegion(Collection<Beacon> beacons, Region region);
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/Region.java b/lib/src/main/java/org/altbeacon/beacon/Region.java
index 24b0ad62..da4a5c71 100644
--- a/lib/src/main/java/org/altbeacon/beacon/Region.java
+++ b/lib/src/main/java/org/altbeacon/beacon/Region.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -33,24 +33,21 @@
 
 /**
  * This class represents a criteria of fields used to match beacons.
- *
+ * <p>
  * The uniqueId field is used to distinguish this Region in the system.  When you set up
  * monitoring or ranging based on a Region and later want to stop monitoring or ranging,
  * you must do so by passing a Region object that has the same uniqueId field value.  If it
  * doesn't match, you can't cancel the operation.  There is no other purpose to this field.
- *
+ * <p>
  * The region can be constructed from a multi-part identifier.  The first identifier is the most
  * significant, the second the second most significant, etc.
- *
+ * <p>
  * When constructing a range, any or all of these identifiers may be set to null,
  * which indicates that they are a wildcard and will match any value.
  *
  * @author dyoung
- *
  */
 public class Region implements Parcelable, Serializable {
-    private static final String TAG = "Region";
-    private static final Pattern MAC_PATTERN = Pattern.compile("^[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}$");
     /**
      * Required to make class Parcelable
      */
@@ -64,16 +61,19 @@ public Region createFromParcel(Parcel in) {
             return new Region[size];
         }
     };
+    private static final String TAG = "Region";
+    private static final Pattern MAC_PATTERN = Pattern.compile("^[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}$");
     protected final List<Identifier> mIdentifiers;
     protected final String mBluetoothAddress;
     protected final String mUniqueId;
 
     /**
      * Constructs a new Region object to be used for Ranging or Monitoring
+     *
      * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
-     * @param id1 - most significant identifier (can be null)
-     * @param id2 - second most significant identifier (can be null)
-     * @param id3 - third most significant identifier (can be null)
+     * @param id1      - most significant identifier (can be null)
+     * @param id2      - second most significant identifier (can be null)
+     * @param id3      - third most significant identifier (can be null)
      */
     public Region(String uniqueId, Identifier id1, Identifier id2, Identifier id3) {
         this.mIdentifiers = new ArrayList<Identifier>(3);
@@ -89,17 +89,19 @@ public Region(String uniqueId, Identifier id1, Identifier id2, Identifier id3) {
 
     /**
      * Constructs a new Region object to be used for Ranging or Monitoring
-     * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
+     *
+     * @param uniqueId    - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
      * @param identifiers - list of identifiers for this region
      */
     public Region(String uniqueId, List<Identifier> identifiers) {
-       this(uniqueId, identifiers, null);
+        this(uniqueId, identifiers, null);
     }
 
     /**
      * Constructs a new Region object to be used for Ranging or Monitoring
-     * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
-     * @param identifiers - list of identifiers for this region
+     *
+     * @param uniqueId         - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
+     * @param identifiers      - list of identifiers for this region
      * @param bluetoothAddress - mac address
      */
     public Region(String uniqueId, List<Identifier> identifiers, String bluetoothAddress) {
@@ -114,7 +116,8 @@ public Region(String uniqueId, List<Identifier> identifiers, String bluetoothAdd
 
     /**
      * Constructs a new Region object to be used for Ranging or Monitoring
-     * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
+     *
+     * @param uniqueId         - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
      * @param bluetoothAddress - mac address used to match beacons
      */
     public Region(String uniqueId, String bluetoothAddress) {
@@ -127,8 +130,25 @@ public Region(String uniqueId, String bluetoothAddress) {
         }
     }
 
+    protected Region(Parcel in) {
+        mUniqueId = in.readString();
+        mBluetoothAddress = in.readString();
+        int size = in.readInt();
+        mIdentifiers = new ArrayList<Identifier>(size);
+        for (int i = 0; i < size; i++) {
+            String identifierString = in.readString();
+            if (identifierString == null) {
+                mIdentifiers.add(null);
+            } else {
+                Identifier identifier = Identifier.parse(identifierString);
+                mIdentifiers.add(identifier);
+            }
+        }
+    }
+
     /**
      * Convenience method to get the first identifier
+     *
      * @return
      */
     public Identifier getId1() {
@@ -137,6 +157,7 @@ public Identifier getId1() {
 
     /**
      * Convenience method to get the second identifier
+     *
      * @return
      */
     public Identifier getId2() {
@@ -145,6 +166,7 @@ public Identifier getId2() {
 
     /**
      * Convenience method to get the third identifier
+     *
      * @return
      */
     public Identifier getId3() {
@@ -154,6 +176,7 @@ public Identifier getId3() {
     /**
      * Returns the 0-indexed identifier
      * Note:  IMPORTANT:  to get id1, you would call getIdentifier(0);
+     *
      * @param i
      * @return
      */
@@ -164,6 +187,7 @@ public Identifier getIdentifier(int i) {
     /**
      * Returns the identifier used to start or stop ranging/monitoring this region when calling
      * the <code>BeaconManager</code> methods.
+     *
      * @return
      */
     public String getUniqueId() {
@@ -173,10 +197,13 @@ public String getUniqueId() {
     /**
      * Returns the mac address used to filter for beacons
      */
-    public String getBluetoothAddress() { return mBluetoothAddress; }
+    public String getBluetoothAddress() {
+        return mBluetoothAddress;
+    }
 
     /**
      * Checks to see if an Beacon object is included in the matching criteria of this Region
+     *
      * @param beacon the beacon to check to see if it is in the Region
      * @return true if is covered
      */
@@ -189,7 +216,7 @@ public boolean matchesBeacon(Beacon beacon) {
                 beaconIdentifier = beacon.getIdentifier(i);
             }
             if ((beaconIdentifier == null && identifier != null) ||
-                    (beaconIdentifier != null  && identifier != null && !identifier.equals(beaconIdentifier))) {
+                    (beaconIdentifier != null && identifier != null && !identifier.equals(beaconIdentifier))) {
                 return false;
             }
         }
@@ -207,40 +234,35 @@ public int hashCode() {
     @Override
     public boolean equals(Object other) {
         if (other instanceof Region) {
-            return ((Region)other).mUniqueId.equals(this.mUniqueId);
+            return ((Region) other).mUniqueId.equals(this.mUniqueId);
         }
         return false;
     }
 
     public boolean hasSameIdentifiers(Region region) {
         if (region.mIdentifiers.size() == this.mIdentifiers.size()) {
-            for (int i = 0 ; i < region.mIdentifiers.size(); i++) {
+            for (int i = 0; i < region.mIdentifiers.size(); i++) {
 
                 if (region.getIdentifier(i) == null && this.getIdentifier(i) != null) {
                     return false;
-                }
-                else if (region.getIdentifier(i) != null && this.getIdentifier(i) == null) {
+                } else if (region.getIdentifier(i) != null && this.getIdentifier(i) == null) {
                     return false;
-                }
-                else if (!(region.getIdentifier(i) == null && this.getIdentifier(i) == null)) {
+                } else if (!(region.getIdentifier(i) == null && this.getIdentifier(i) == null)) {
                     if (!region.getIdentifier(i).equals(this.getIdentifier(i))) {
                         return false;
                     }
                 }
             }
-        }
-        else {
+        } else {
             return false;
         }
         return true;
     }
 
-
-
     public String toString() {
         StringBuilder sb = new StringBuilder();
         int i = 1;
-        for (Identifier identifier: mIdentifiers) {
+        for (Identifier identifier : mIdentifiers) {
             if (i > 1) {
                 sb.append(" ");
             }
@@ -262,46 +284,29 @@ public void writeToParcel(Parcel out, int flags) {
         out.writeString(mBluetoothAddress);
         out.writeInt(mIdentifiers.size());
 
-        for (Identifier identifier: mIdentifiers) {
+        for (Identifier identifier : mIdentifiers) {
             if (identifier != null) {
                 out.writeString(identifier.toString());
-            }
-            else {
-                out.writeString(null);
-            }
-        }
-    }
-
-
-    protected Region(Parcel in) {
-        mUniqueId = in.readString();
-        mBluetoothAddress = in.readString();
-        int size = in.readInt();
-        mIdentifiers = new ArrayList<Identifier>(size);
-        for (int i = 0; i < size; i++) {
-            String identifierString = in.readString();
-            if (identifierString == null) {
-                mIdentifiers.add(null);
             } else {
-                Identifier identifier = Identifier.parse(identifierString);
-                mIdentifiers.add(identifier);
+                out.writeString(null);
             }
         }
     }
 
     private void validateMac(String mac) throws IllegalArgumentException {
         if (mac != null) {
-            if(!MAC_PATTERN.matcher(mac).matches()) {
-                throw new IllegalArgumentException("Invalid mac address: '"+mac+"' Must be 6 hex bytes separated by colons.");
+            if (!MAC_PATTERN.matcher(mac).matches()) {
+                throw new IllegalArgumentException("Invalid mac address: '" + mac + "' Must be 6 hex bytes separated by colons.");
             }
         }
     }
 
     /**
      * Returns a clone of this instance.
+     *
+     * @return a new instance of this class with the same uniqueId and identifiers
      * @deprecated instances of this class are immutable and therefore don't have to be cloned when
      * used in concurrent code.
-     * @return a new instance of this class with the same uniqueId and identifiers
      */
     @Override
     @Deprecated
diff --git a/lib/src/main/java/org/altbeacon/beacon/client/BeaconDataFactory.java b/lib/src/main/java/org/altbeacon/beacon/client/BeaconDataFactory.java
index 7e2031e8..af434cef 100644
--- a/lib/src/main/java/org/altbeacon/beacon/client/BeaconDataFactory.java
+++ b/lib/src/main/java/org/altbeacon/beacon/client/BeaconDataFactory.java
@@ -8,12 +8,12 @@
  * In the public data store, you can read any value but only write to the values to the beacons you created
  *
  * @author dyoung
- *
  */
 public interface BeaconDataFactory {
     /**
      * Asynchronous call
      * When data is available, it is passed back to the beaconDataNotifier interface
+     *
      * @param beacon
      */
     public void requestBeaconData(Beacon beacon, BeaconDataNotifier notifier);
diff --git a/lib/src/main/java/org/altbeacon/beacon/client/DataProviderException.java b/lib/src/main/java/org/altbeacon/beacon/client/DataProviderException.java
index 1a6e5494..a60f4ad9 100644
--- a/lib/src/main/java/org/altbeacon/beacon/client/DataProviderException.java
+++ b/lib/src/main/java/org/altbeacon/beacon/client/DataProviderException.java
@@ -6,12 +6,15 @@
      *
      */
     private static final long serialVersionUID = -2574842662565384114L;
+
     public DataProviderException() {
         super();
     }
+
     public DataProviderException(String msg) {
         super(msg);
     }
+
     public DataProviderException(String msg, Throwable t) {
         super(msg, t);
     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java b/lib/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
index d934a428..6a8db1ae 100644
--- a/lib/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
+++ b/lib/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
@@ -1,12 +1,12 @@
 package org.altbeacon.beacon.distance;
 
 import android.os.Build;
-import org.altbeacon.beacon.BeaconManager;
+
 import org.altbeacon.beacon.logging.LogManager;
 
 /**
  * Represents a specific Android device model based on the available device build information
- *
+ * <p>
  * Created by dyoung on 8/28/14.
  */
 public class AndroidModel {
@@ -26,12 +26,13 @@ public AndroidModel(String version, String buildNumber,
         mManufacturer = manufacturer;
 
     }
+
     public static AndroidModel forThisDevice() {
         return new AndroidModel(
-            Build.VERSION.RELEASE,
-            Build.ID,
-            Build.MODEL,
-            Build.MANUFACTURER);
+                Build.VERSION.RELEASE,
+                Build.ID,
+                Build.MODEL,
+                Build.MANUFACTURER);
     }
 
     public String getVersion() {
@@ -46,23 +47,22 @@ public String getBuildNumber() {
         return mBuildNumber;
     }
 
+    public void setBuildNumber(String mBuildNumber) {
+        this.mBuildNumber = mBuildNumber;
+    }
+
     public String getModel() {
         return mModel;
     }
 
+    public void setModel(String mModel) {
+        this.mModel = mModel;
+    }
 
     public String getManufacturer() {
         return mManufacturer;
     }
 
-    public void setBuildNumber(String mBuildNumber) {
-        this.mBuildNumber = mBuildNumber;
-    }
-
-    public void setModel(String mModel) {
-        this.mModel = mModel;
-    }
-
     public void setManufacturer(String mManufacturer) {
         this.mManufacturer = mManufacturer;
     }
@@ -70,6 +70,7 @@ public void setManufacturer(String mManufacturer) {
     /**
      * Calculates a qualitative match score between two different Android device models for the
      * purposes of how likely they are to have similar Bluetooth signal level responses
+     *
      * @param otherModel
      * @return match quality, higher numbers are a better match
      */
@@ -78,7 +79,7 @@ public int matchScore(AndroidModel otherModel) {
         if (this.mManufacturer.equalsIgnoreCase(otherModel.mManufacturer)) {
             score = 1;
         }
-        if (score ==1 && this.mModel.equals(otherModel.mModel)) {
+        if (score == 1 && this.mModel.equals(otherModel.mModel)) {
             score = 2;
         }
         if (score == 2 && this.mBuildNumber.equals(otherModel.mBuildNumber)) {
@@ -93,6 +94,6 @@ public int matchScore(AndroidModel otherModel) {
 
     @Override
     public String toString() {
-        return ""+mManufacturer+";"+mModel+";"+mBuildNumber+";"+mVersion;
+        return "" + mManufacturer + ";" + mModel + ";" + mBuildNumber + ";" + mVersion;
     }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java b/lib/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
index 8cd4e417..a755e312 100644
--- a/lib/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
+++ b/lib/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
@@ -1,17 +1,16 @@
 package org.altbeacon.beacon.distance;
 
-import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
 /**
  * This class estimates the distance between the mobile device and a BLE beacon based on the measured
  * RSSI and a txPower calibration value that represents the expected RSSI for an iPhone 5 receiving
  * the signal when it is 1 meter away.
- *
+ * <p>
  * This class uses a best-fit curve equation with configurable coefficients.  The coefficients must
  * be supplied by the caller and are specific to the Android device being used.  See the
  * <code>ModelSpecificDistanceCalculator</code> for more information on the coefficients.
- *
+ * <p>
  * Created by dyoung on 8/28/14.
  */
 public class CurveFittedDistanceCalculator implements DistanceCalculator {
@@ -51,13 +50,12 @@ public double calculateDistance(int txPower, double rssi) {
         LogManager.d(TAG, "calculating distance based on mRssi of %s and txPower of %s", rssi, txPower);
 
 
-        double ratio = rssi*1.0/txPower;
+        double ratio = rssi * 1.0 / txPower;
         double distance;
         if (ratio < 1.0) {
-            distance =  Math.pow(ratio,10);
-        }
-        else {
-            distance =  (mCoefficient1)*Math.pow(ratio,mCoefficient2) + mCoefficient3;
+            distance = Math.pow(ratio, 10);
+        } else {
+            distance = (mCoefficient1) * Math.pow(ratio, mCoefficient2) + mCoefficient3;
         }
         LogManager.d(TAG, "avg mRssi: %s distance: %s", rssi, distance);
         return distance;
diff --git a/lib/src/main/java/org/altbeacon/beacon/distance/DistanceCalculator.java b/lib/src/main/java/org/altbeacon/beacon/distance/DistanceCalculator.java
index 76c5f882..d9efa1e7 100644
--- a/lib/src/main/java/org/altbeacon/beacon/distance/DistanceCalculator.java
+++ b/lib/src/main/java/org/altbeacon/beacon/distance/DistanceCalculator.java
@@ -4,7 +4,7 @@
  * Interface for a class that can estimate the distance between a mobile
  * device and a beacon based on the measured RSSI and a reference txPower
  * calibration value.
- *
+ * <p>
  * Created by dyoung on 8/28/14.
  */
 public interface DistanceCalculator {
diff --git a/lib/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java b/lib/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
index ad4bfe73..3135c307 100644
--- a/lib/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
+++ b/lib/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
@@ -27,34 +27,34 @@
  * Obtains a <code>DistanceCalculator</code> appropriate for a specific Android model.  Each model
  * may have a different Bluetooth chipset, radio and antenna and sees a different signal level
  * at the same distance, therefore requiring a different equation coefficients for each model.
- *
+ * <p>
  * This class uses a configuration table to look for a matching Android device model for which
  * coefficients are known.  If an exact match cannot be found, this class will attempt to find the
  * closest match possible based on the assumption that an unknown model made by Samsung, for example
  * might have a different signal response as a known device model also made by Samsung.
- *
+ * <p>
  * If no match can be found at all, the device model marked as the default will be used for the
  * calculation.
- *
+ * <p>
  * The configuration table is stored in model-distance-calculations.json
- *
+ * <p>
  * For information on how to get new Android device models added to this table, please
  * see <a href='http://altbeacon.github.io/android-beacon-library/distance-calculations.html'
  * Optimizing Distance Calculations</a>
- *
+ * <p>
  * Created by dyoung on 8/28/14.
  */
 public class ModelSpecificDistanceCalculator implements DistanceCalculator {
-    Map<AndroidModel,DistanceCalculator> mModelMap;
     private static final String CONFIG_FILE = "model-distance-calculations.json";
     private static final String TAG = "ModelSpecificDistanceCalculator";
+    private final ReentrantLock mLock = new ReentrantLock();
+    Map<AndroidModel, DistanceCalculator> mModelMap;
     private AndroidModel mDefaultModel;
     private DistanceCalculator mDistanceCalculator;
     private AndroidModel mModel;
     private AndroidModel mRequestedModel;
     private String mRemoteUpdateUrlString = null;
     private Context mContext;
-    private final ReentrantLock mLock = new ReentrantLock();
 
     /**
      * Obtains the best possible <code>DistanceCalculator</code> for the Android device calling
@@ -168,21 +168,24 @@ private boolean loadModelMapFromFile() {
             while ((line = reader.readLine()) != null) {
                 sb.append(line).append("\n");
             }
-        }
-        catch (FileNotFoundException fnfe){
+        } catch (FileNotFoundException fnfe) {
             //This occurs on the first time the app is run, no error message necessary.
             return false;
-        }
-        catch (IOException e) {
+        } catch (IOException e) {
             LogManager.e(e, TAG, "Cannot open distance model file %s", file);
             return false;
-        }
-        finally {
+        } finally {
             if (reader != null) {
-                try { reader.close(); } catch (Exception e2) {}
+                try {
+                    reader.close();
+                } catch (Exception e2) {
+                }
             }
             if (inputStream != null) {
-                try { inputStream.close(); } catch (Exception e2) {}
+                try {
+                    inputStream.close();
+                } catch (Exception e2) {
+                }
             }
         }
         try {
@@ -210,12 +213,11 @@ private boolean saveJson(String jsonString) {
         } catch (Exception e) {
             LogManager.w(e, TAG, "Cannot write updated distance model to local storage");
             return false;
-        }
-        finally {
+        } finally {
             try {
                 if (outputStream != null) outputStream.close();
+            } catch (Exception e) {
             }
-            catch (Exception e) {}
         }
         LogManager.i(TAG, "Successfully saved new distance model file");
         return true;
@@ -231,32 +233,30 @@ private void requestModelMapFromWeb() {
 
         new ModelSpecificDistanceUpdater(mContext, mRemoteUpdateUrlString,
                 new ModelSpecificDistanceUpdater.CompletionHandler() {
-            @Override
-            public void onComplete(String body, Exception ex, int code) {
-                if (ex != null) {
-                    LogManager.w(TAG, "Cannot updated distance models from online database at %s",
-                            ex, mRemoteUpdateUrlString);
-                }
-                else if (code != 200) {
-                    LogManager.w(TAG, "Cannot updated distance models from online database at %s "
-                            + "due to HTTP status code %s", mRemoteUpdateUrlString, code);
-                }
-                else {
-                    LogManager.d(TAG,
-                            "Successfully downloaded distance models from online database");
-                    try {
-                        buildModelMapWithLock(body);
-                        if (saveJson(body)) {
-                            loadModelMapFromFile();
-                            mDistanceCalculator = findCalculatorForModelWithLock(mRequestedModel);
-                            LogManager.i(TAG, "Successfully updated distance model with latest from online database");
+                    @Override
+                    public void onComplete(String body, Exception ex, int code) {
+                        if (ex != null) {
+                            LogManager.w(TAG, "Cannot updated distance models from online database at %s",
+                                    ex, mRemoteUpdateUrlString);
+                        } else if (code != 200) {
+                            LogManager.w(TAG, "Cannot updated distance models from online database at %s "
+                                    + "due to HTTP status code %s", mRemoteUpdateUrlString, code);
+                        } else {
+                            LogManager.d(TAG,
+                                    "Successfully downloaded distance models from online database");
+                            try {
+                                buildModelMapWithLock(body);
+                                if (saveJson(body)) {
+                                    loadModelMapFromFile();
+                                    mDistanceCalculator = findCalculatorForModelWithLock(mRequestedModel);
+                                    LogManager.i(TAG, "Successfully updated distance model with latest from online database");
+                                }
+                            } catch (JSONException e) {
+                                LogManager.w(e, TAG, "Cannot parse json from downloaded distance model");
+                            }
                         }
-                    } catch (JSONException e) {
-                        LogManager.w(e, TAG, "Cannot parse json from downloaded distance model");
                     }
-                }
-            }
-        }).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
+                }).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
     }
 
     void buildModelMapWithLock(String jsonString) throws JSONException {
@@ -287,7 +287,7 @@ private void buildModelMap(String jsonString) throws JSONException {
             String manufacturer = modelObject.getString("manufacturer");
 
             CurveFittedDistanceCalculator distanceCalculator =
-                    new CurveFittedDistanceCalculator(coefficient1,coefficient2,coefficient3);
+                    new CurveFittedDistanceCalculator(coefficient1, coefficient2, coefficient3);
 
             AndroidModel androidModel = new AndroidModel(version, buildNumber, model, manufacturer);
             map.put(androidModel, distanceCalculator);
@@ -301,8 +301,7 @@ private void buildModelMap(String jsonString) throws JSONException {
     private void loadDefaultModelMap() {
         try {
             buildModelMap(stringFromFilePath(CONFIG_FILE));
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             mModelMap = new HashMap<AndroidModel, DistanceCalculator>();
             LogManager.e(e, TAG, "Cannot build model distance calculations");
         }
@@ -323,12 +322,12 @@ private String stringFromFilePath(String path) throws IOException {
             }
             bufferedReader = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
             String line = bufferedReader.readLine();
-            while(line != null){
-                inputStringBuilder.append(line);inputStringBuilder.append('\n');
+            while (line != null) {
+                inputStringBuilder.append(line);
+                inputStringBuilder.append('\n');
                 line = bufferedReader.readLine();
             }
-        }
-        finally {
+        } finally {
             if (bufferedReader != null) {
                 bufferedReader.close();
             }
diff --git a/lib/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java b/lib/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
index bebb7c91..587e0af1 100644
--- a/lib/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
+++ b/lib/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
@@ -1,14 +1,10 @@
 package org.altbeacon.beacon.distance;
 
 import android.content.Context;
-import android.content.pm.PackageInfo;
 import android.os.AsyncTask;
-import android.os.Build;
 import android.provider.Settings;
-import android.util.Log;
 
 import org.altbeacon.beacon.BuildConfig;
-import org.json.JSONObject;
 
 /**
  * Created by dyoung on 9/12/14.
@@ -23,6 +19,12 @@
     private DistanceConfigFetcher mDistanceConfigFetcher;
     private CompletionHandler mCompletionHandler;
 
+    public ModelSpecificDistanceUpdater(Context context, String urlString, CompletionHandler completionHandler) {
+        mContext = context;
+        mDistanceConfigFetcher = new DistanceConfigFetcher(urlString, getUserAgentString());
+        mCompletionHandler = completionHandler;
+    }
+
     @Override
     protected Void doInBackground(Void... params) {
         mDistanceConfigFetcher.request();
@@ -35,24 +37,22 @@ protected Void doInBackground(Void... params) {
     protected void onPostExecute() {
     }
 
-    public ModelSpecificDistanceUpdater(Context context, String urlString, CompletionHandler completionHandler) {
-        mContext = context;
-        mDistanceConfigFetcher = new DistanceConfigFetcher(urlString, getUserAgentString());
-        mCompletionHandler = completionHandler;
-    }
-
     private String getUserAgentString() {
-        return "Android Beacon Library;"+getVersion()+";"+getPackage()+";"+getInstallId()+";"+getModel();
+        return "Android Beacon Library;" + getVersion() + ";" + getPackage() + ";" + getInstallId() + ";" + getModel();
     }
+
     private String getPackage() {
         return mContext.getPackageName();
     }
+
     private String getModel() {
         return AndroidModel.forThisDevice().toString();
     }
+
     private String getInstallId() {
         return Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.ANDROID_ID);
     }
+
     private String getVersion() {
         return BuildConfig.VERSION_NAME;
     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java b/lib/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
index 2b9baec5..1dd85337 100644
--- a/lib/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
+++ b/lib/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
@@ -21,21 +21,25 @@
 /**
  * Android logger that only logs out warning and above to the {@link android.util.Log}.
  *
- * @since 2.2
  * @author Andrew Reitz
+ * @since 2.2
  */
 final class InfoAndroidLogger extends AbstractAndroidLogger {
     @Override
-    public void v(String tag, String message, Object... args) { }
+    public void v(String tag, String message, Object... args) {
+    }
 
     @Override
-    public void v(Throwable t, String tag, String message, Object... args) { }
+    public void v(Throwable t, String tag, String message, Object... args) {
+    }
 
     @Override
-    public void d(String tag, String message, Object... args) { }
+    public void d(String tag, String message, Object... args) {
+    }
 
     @Override
-    public void d(Throwable t, String tag, String message, Object... args) { }
+    public void d(Throwable t, String tag, String message, Object... args) {
+    }
 
     @Override
     public void i(String tag, String message, Object... args) {
diff --git a/lib/src/main/java/org/altbeacon/beacon/logging/LogManager.java b/lib/src/main/java/org/altbeacon/beacon/logging/LogManager.java
index 8420d7a6..50da64c9 100644
--- a/lib/src/main/java/org/altbeacon/beacon/logging/LogManager.java
+++ b/lib/src/main/java/org/altbeacon/beacon/logging/LogManager.java
@@ -27,6 +27,20 @@
     private static Logger sLogger = Loggers.infoLogger();
     private static boolean sVerboseLoggingEnabled = false;
 
+    private LogManager() {
+        // no instances
+    }
+
+    /**
+     * Gets the currently set logger
+     *
+     * @return logger
+     * @see org.altbeacon.beacon.logging.Logger
+     */
+    public static Logger getLogger() {
+        return sLogger;
+    }
+
     /**
      * Set the logger that the Altbeacon library will use to send it's log messages to.
      *
@@ -43,19 +57,10 @@ public static void setLogger(Logger logger) {
         sLogger = logger;
     }
 
-    /**
-     * Gets the currently set logger
-     *
-     * @see org.altbeacon.beacon.logging.Logger
-     * @return logger
-     */
-    public static Logger getLogger() {
-        return sLogger;
-    }
-
     /**
      * Indicates whether verbose logging is enabled.   If not, expensive calculations to create
      * log strings should be avoided.
+     *
      * @return
      */
     public static boolean isVerboseLoggingEnabled() {
@@ -206,8 +211,4 @@ public static void e(String tag, String message, Object... args) {
     public static void e(Throwable t, String tag, String message, Object... args) {
         sLogger.e(t, tag, message, args);
     }
-
-    private LogManager() {
-        // no instances
-    }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/logging/Loggers.java b/lib/src/main/java/org/altbeacon/beacon/logging/Loggers.java
index c243f62c..024bd498 100644
--- a/lib/src/main/java/org/altbeacon/beacon/logging/Loggers.java
+++ b/lib/src/main/java/org/altbeacon/beacon/logging/Loggers.java
@@ -24,18 +24,30 @@
  * @since 2.2
  */
 public final class Loggers {
-    /** Empty Logger Singleton. */
+    /**
+     * Empty Logger Singleton.
+     */
     private static final Logger EMPTY_LOGGER = new EmptyLogger();
 
-    /** Debug Logger Singleton. */
+    /**
+     * Debug Logger Singleton.
+     */
     private static final Logger VERBOSE_ANDROID_LOGGER = new VerboseAndroidLogger();
 
-    /** Info Logger Singleton. */
+    /**
+     * Info Logger Singleton.
+     */
     private static final Logger INFO_ANDROID_LOGGER = new InfoAndroidLogger();
 
-    /** Warning Logger Singleton. */
+    /**
+     * Warning Logger Singleton.
+     */
     private static final Logger WARNING_ANDROID_LOGGER = new WarningAndroidLogger();
 
+    private Loggers() {
+        // No instances
+    }
+
     /**
      * @return Get a logger that does nothing.
      */
@@ -66,8 +78,4 @@ public static Logger infoLogger() {
     public static Logger warningLogger() {
         return WARNING_ANDROID_LOGGER;
     }
-
-    private Loggers() {
-        // No instances
-    }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/logging/WarningAndroidLogger.java b/lib/src/main/java/org/altbeacon/beacon/logging/WarningAndroidLogger.java
index 130931f3..6299e0c4 100644
--- a/lib/src/main/java/org/altbeacon/beacon/logging/WarningAndroidLogger.java
+++ b/lib/src/main/java/org/altbeacon/beacon/logging/WarningAndroidLogger.java
@@ -21,27 +21,33 @@
 /**
  * Android logger that only logs out warning and above to the {@link android.util.Log}.
  *
- * @since 2.2
  * @author Andrew Reitz
+ * @since 2.2
  */
 final class WarningAndroidLogger extends AbstractAndroidLogger {
     @Override
-    public void v(String tag, String message, Object... args) { }
+    public void v(String tag, String message, Object... args) {
+    }
 
     @Override
-    public void v(Throwable t, String tag, String message, Object... args) { }
+    public void v(Throwable t, String tag, String message, Object... args) {
+    }
 
     @Override
-    public void d(String tag, String message, Object... args) { }
+    public void d(String tag, String message, Object... args) {
+    }
 
     @Override
-    public void d(Throwable t, String tag, String message, Object... args) { }
+    public void d(Throwable t, String tag, String message, Object... args) {
+    }
 
     @Override
-    public void i(String tag, String message, Object... args) { }
+    public void i(String tag, String message, Object... args) {
+    }
 
     @Override
-    public void i(Throwable t, String tag, String message, Object... args) { }
+    public void i(Throwable t, String tag, String message, Object... args) {
+    }
 
     @Override
     public void w(String tag, String message, Object... args) {
diff --git a/lib/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java b/lib/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
index 1349ad49..1cd93bbc 100644
--- a/lib/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
+++ b/lib/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
@@ -45,7 +45,7 @@ public BackgroundPowerSaver(Context context) {
             LogManager.w(TAG, "BackgroundPowerSaver requires API 18 or higher.");
         }
         beaconManager = BeaconManager.getInstanceForApplication(context);
-        ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
+        ((Application) context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
     }
 
     @Override
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java b/lib/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
index 78c8eea6..cd060b06 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
@@ -8,18 +8,17 @@
  * where c is a coefficient, that denotes the smoothness - the lower the value, the smoother the average
  * Note: a smoother average needs longer to "settle down"
  * Note: For signals, that change rather frequently (say, 1Hz or faster) and tend to vary more a recommended
- *       value would be 0,1 (that means the actual value is changed by 10% of the difference between the
- *       actual measurement and the actual average)
- *       For signals at lower rates (10Hz) a value of 0.25 to 0.5 would be appropriate
+ * value would be 0,1 (that means the actual value is changed by 10% of the difference between the
+ * actual measurement and the actual average)
+ * For signals at lower rates (10Hz) a value of 0.25 to 0.5 would be appropriate
  */
 public class ArmaRssiFilter implements RssiFilter {
 
-    private static double DEFAULT_ARMA_SPEED = 0.1;     //How likely is it that the RSSI value changes?
-                                                        //Note: the more unlikely, the higher can that value be
-                                                        //      also, the lower the (expected) sending frequency,
-                                                        //      the higher should that value be
-
     private static final String TAG = "ArmaRssiFilter";
+    //Note: the more unlikely, the higher can that value be
+    //      also, the lower the (expected) sending frequency,
+    //      the higher should that value be
+    private static double DEFAULT_ARMA_SPEED = 0.1;     //How likely is it that the RSSI value changes?
     //initially set to min value
     private int armaMeasurement;
     private double armaSpeed = 0.1;
@@ -29,19 +28,26 @@ public ArmaRssiFilter() {
         this.armaSpeed = DEFAULT_ARMA_SPEED;
     }
 
+    public static void setDEFAULT_ARMA_SPEED(double default_arma_speed) {
+        DEFAULT_ARMA_SPEED = default_arma_speed;
+    }
+
     public void addMeasurement(Integer rssi) {
         LogManager.d(TAG, "adding rssi: %s", rssi);
         //use first measurement as initialization
         if (!isInitialized) {
             armaMeasurement = rssi;
             isInitialized = true;
-        };
+        }
+        ;
         armaMeasurement = Double.valueOf(armaMeasurement - armaSpeed * (armaMeasurement - rssi)).intValue();
         LogManager.d(TAG, "armaMeasurement: %s", armaMeasurement);
     }
 
     @Override
-    public int getMeasurementCount() { return 0; }
+    public int getMeasurementCount() {
+        return 0;
+    }
 
     public boolean noMeasurementsAvailable() {
         return false;
@@ -52,8 +58,4 @@ public double calculateRssi() {
 
     }
 
-    public static void setDEFAULT_ARMA_SPEED(double default_arma_speed) {
-        DEFAULT_ARMA_SPEED = default_arma_speed;
-    }
-
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/lib/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 73545ded..a869f913 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -62,7 +62,6 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 
 import static android.app.PendingIntent.FLAG_ONE_SHOT;
 import static android.app.PendingIntent.getBroadcast;
@@ -73,10 +72,13 @@
 
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
-    private final Handler handler = new Handler();
-    private BluetoothCrashResolver bluetoothCrashResolver;
-    private ScanHelper mScanHelper;
-    private BeaconLocalBroadcastProcessor mBeaconNotificationProcessor;
+    /**
+     * Command to the service to display a message
+     */
+    public static final int MSG_START_RANGING = 2;
+    public static final int MSG_STOP_RANGING = 3;
+    public static final int MSG_START_MONITORING = 4;
+    public static final int MSG_STOP_MONITORING = 5;
 
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
@@ -99,100 +101,16 @@
      * scanning.
      *
      */
-
-    /**
-     * Class used for the client Binder.  Because we know this service always
-     * runs in the same process as its clients, we don't need to deal with IPC.
-     */
-    public class BeaconBinder extends Binder {
-        public BeaconService getService() {
-            LogManager.i(TAG, "getService of BeaconBinder called");
-            // Return this instance of LocalService so clients can call public methods
-            return BeaconService.this;
-        }
-    }
-
-    /**
-     * Command to the service to display a message
-     */
-    public static final int MSG_START_RANGING = 2;
-    public static final int MSG_STOP_RANGING = 3;
-    public static final int MSG_START_MONITORING = 4;
-    public static final int MSG_STOP_MONITORING = 5;
     public static final int MSG_SET_SCAN_PERIODS = 6;
     public static final int MSG_SYNC_SETTINGS = 7;
-
-    static class IncomingHandler extends Handler {
-        private final WeakReference<BeaconService> mService;
-
-        IncomingHandler(BeaconService service) {
-            /*
-             * Explicitly state this uses the main thread. Without this we defer to where the
-             * service instance is initialized/created; which is usually the main thread anyways.
-             * But by being explicit we document our code design expectations for where things run.
-             */
-            super(Looper.getMainLooper());
-            mService = new WeakReference<BeaconService>(service);
-        }
-
-        @MainThread
-        @Override
-        public void handleMessage(Message msg) {
-            BeaconService service = mService.get();
-            if (service != null) {
-                StartRMData startRMData = StartRMData.fromBundle(msg.getData());
-                if (startRMData != null) {
-                    switch (msg.what) {
-                        case MSG_START_RANGING:
-                            LogManager.i(TAG, "start ranging received");
-                            service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                            break;
-                        case MSG_STOP_RANGING:
-                            LogManager.i(TAG, "stop ranging received");
-                            service.stopRangingBeaconsInRegion(startRMData.getRegionData());
-                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                            break;
-                        case MSG_START_MONITORING:
-                            LogManager.i(TAG, "start monitoring received");
-                            service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                            break;
-                        case MSG_STOP_MONITORING:
-                            LogManager.i(TAG, "stop monitoring received");
-                            service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
-                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                            break;
-                        case MSG_SET_SCAN_PERIODS:
-                            LogManager.i(TAG, "set scan intervals received");
-                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                            break;
-                        default:
-                            super.handleMessage(msg);
-                    }
-                }
-                else if (msg.what == MSG_SYNC_SETTINGS) {
-                    LogManager.i(TAG, "Received settings update from other process");
-                    SettingsData settingsData = SettingsData.fromBundle(msg.getData());
-                    if (settingsData != null) {
-                        settingsData.apply(service);
-                    }
-                    else {
-                        LogManager.w(TAG, "Settings data missing");
-                    }
-                }
-                else {
-                    LogManager.i(TAG, "Received unknown message from other process : "+msg.what);
-                }
-
-            }
-        }
-    }
-
     /**
      * Target we publish for clients to send messages to IncomingHandler.
      */
     final Messenger mMessenger = new Messenger(new IncomingHandler(this));
+    private final Handler handler = new Handler();
+    private BluetoothCrashResolver bluetoothCrashResolver;
+    private ScanHelper mScanHelper;
+    private BeaconLocalBroadcastProcessor mBeaconNotificationProcessor;
 
     @MainThread
     @Override
@@ -217,11 +135,10 @@ public void onCreate() {
             LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
             // if we are on the main process, we use local broadcast notifications to deliver results.
             ensureNotificationProcessorSetup();
-        }
-        else {
+        } else {
             LogManager.i(TAG, "beaconService version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
             ProcessUtils processUtils = new ProcessUtils(this);
-            LogManager.i(TAG, "beaconService PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
+            LogManager.i(TAG, "beaconService PID is " + processUtils.getPid() + " with process name " + processUtils.getProcessName());
         }
 
         String longScanForcingEnabled = getManifestMetadataValue("longScanForcingEnabled");
@@ -234,7 +151,7 @@ public void onCreate() {
 
         mScanHelper.reloadParsers();
 
-        DistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
+        DistanceCalculator defaultDistanceCalculator = new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
 
         // Look for simulated scan data
@@ -250,7 +167,6 @@ public void onCreate() {
         this.startForegroundIfConfigured();
     }
 
-
     private void ensureNotificationProcessorSetup() {
         if (mBeaconNotificationProcessor == null) {
             mBeaconNotificationProcessor = new BeaconLocalBroadcastProcessor(this);
@@ -258,7 +174,6 @@ private void ensureNotificationProcessorSetup() {
         }
     }
 
-
     /*
      * This starts the scanning service as a foreground service if it is so configured in the
      * manifest
@@ -283,8 +198,7 @@ private String getManifestMetadataValue(String key) {
             if (info != null && info.metaData != null) {
                 return info.metaData.get(key).toString();
             }
-        }
-        catch (PackageManager.NameNotFoundException e) {
+        } catch (PackageManager.NameNotFoundException e) {
         }
         return null;
     }
@@ -433,4 +347,80 @@ public void reloadParsers() {
     protected CycledLeScanCallback getCycledLeScanCallback() {
         return mScanHelper.getCycledLeScanCallback();
     }
+
+    static class IncomingHandler extends Handler {
+        private final WeakReference<BeaconService> mService;
+
+        IncomingHandler(BeaconService service) {
+            /*
+             * Explicitly state this uses the main thread. Without this we defer to where the
+             * service instance is initialized/created; which is usually the main thread anyways.
+             * But by being explicit we document our code design expectations for where things run.
+             */
+            super(Looper.getMainLooper());
+            mService = new WeakReference<BeaconService>(service);
+        }
+
+        @MainThread
+        @Override
+        public void handleMessage(Message msg) {
+            BeaconService service = mService.get();
+            if (service != null) {
+                StartRMData startRMData = StartRMData.fromBundle(msg.getData());
+                if (startRMData != null) {
+                    switch (msg.what) {
+                        case MSG_START_RANGING:
+                            LogManager.i(TAG, "start ranging received");
+                            service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_STOP_RANGING:
+                            LogManager.i(TAG, "stop ranging received");
+                            service.stopRangingBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_START_MONITORING:
+                            LogManager.i(TAG, "start monitoring received");
+                            service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_STOP_MONITORING:
+                            LogManager.i(TAG, "stop monitoring received");
+                            service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_SET_SCAN_PERIODS:
+                            LogManager.i(TAG, "set scan intervals received");
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        default:
+                            super.handleMessage(msg);
+                    }
+                } else if (msg.what == MSG_SYNC_SETTINGS) {
+                    LogManager.i(TAG, "Received settings update from other process");
+                    SettingsData settingsData = SettingsData.fromBundle(msg.getData());
+                    if (settingsData != null) {
+                        settingsData.apply(service);
+                    } else {
+                        LogManager.w(TAG, "Settings data missing");
+                    }
+                } else {
+                    LogManager.i(TAG, "Received unknown message from other process : " + msg.what);
+                }
+
+            }
+        }
+    }
+
+    /**
+     * Class used for the client Binder.  Because we know this service always
+     * runs in the same process as its clients, we don't need to deal with IPC.
+     */
+    public class BeaconBinder extends Binder {
+        public BeaconService getService() {
+            LogManager.i(TAG, "getService of BeaconBinder called");
+            // Return this instance of LocalService so clients can call public methods
+            return BeaconService.this;
+        }
+    }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/Callback.java b/lib/src/main/java/org/altbeacon/beacon/service/Callback.java
index 512f031d..9ce0048f 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -55,24 +55,22 @@ public boolean call(Context context, String dataName, Bundle data) {
         boolean useLocalBroadcast = BeaconManager.getInstanceForApplication(context).isMainProcess();
         boolean success = false;
 
-        if(useLocalBroadcast) {
+        if (useLocalBroadcast) {
             String action = null;
             if (dataName == "rangingData") {
                 action = BeaconLocalBroadcastProcessor.RANGE_NOTIFICATION;
-            }
-            else {
+            } else {
                 action = BeaconLocalBroadcastProcessor.MONITOR_NOTIFICATION;
             }
             Intent intent = new Intent(action);
             intent.putExtra(dataName, data);
-            LogManager.d(TAG, "attempting callback via local broadcast intent: %s",action);
+            LogManager.d(TAG, "attempting callback via local broadcast intent: %s", action);
             success = LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
-        }
-        else {
+        } else {
             Intent intent = new Intent();
             intent.setComponent(new ComponentName(context.getPackageName(), "org.altbeacon.beacon.BeaconIntentProcessor"));
             intent.putExtra(dataName, data);
-            LogManager.d(TAG, "attempting callback via global broadcast intent: %s",intent.getComponent());
+            LogManager.d(TAG, "attempting callback via global broadcast intent: %s", intent.getComponent());
             try {
                 context.startService(intent);
                 success = true;
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java b/lib/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
index 3797d241..d4b9e4b6 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
@@ -9,15 +9,19 @@
     private static final DetectionTracker INSTANCE = new DetectionTracker();
 
     private long mLastDetectionTime = 0l;
+
     private DetectionTracker() {
 
     }
+
     public static DetectionTracker getInstance() {
         return INSTANCE;
     }
+
     public long getLastDetectionTime() {
         return mLastDetectionTime;
     }
+
     public void recordDetection() {
         mLastDetectionTime = SystemClock.elapsedRealtime();
     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java b/lib/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
index ae1bbbb1..74a2ed1c 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
@@ -20,7 +20,7 @@
      * This is a lookup table to find tracked beacons by the calculated beacon key
      */
     @NonNull
-    private final HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<>();
+    private final HashMap<String, HashMap<Integer, Beacon>> mBeaconsByKey = new HashMap<>();
 
     private final boolean matchBeaconsByServiceUUID;
 
@@ -41,8 +41,7 @@ public synchronized Beacon track(@NonNull Beacon beacon) {
         Beacon trackedBeacon = null;
         if (beacon.isMultiFrameBeacon() || beacon.getServiceUuid() != -1) {
             trackedBeacon = trackGattBeacon(beacon);
-        }
-        else {
+        } else {
             trackedBeacon = beacon;
         }
         return trackedBeacon;
@@ -59,11 +58,10 @@ private Beacon trackGattBeacon(@NonNull Beacon beacon) {
         }
 
         String key = getBeaconKey(beacon);
-        HashMap<Integer,Beacon> matchingTrackedBeacons = mBeaconsByKey.get(key);
+        HashMap<Integer, Beacon> matchingTrackedBeacons = mBeaconsByKey.get(key);
         if (null == matchingTrackedBeacons) {
             matchingTrackedBeacons = new HashMap<>();
-        }
-        else {
+        } else {
             Beacon trackedBeacon = matchingTrackedBeacons.values().iterator().next();
             beacon.setExtraDataFields(trackedBeacon.getExtraDataFields());
         }
@@ -74,7 +72,7 @@ private Beacon trackGattBeacon(@NonNull Beacon beacon) {
     }
 
     private void updateTrackedBeacons(@NonNull Beacon beacon) {
-        HashMap<Integer,Beacon> matchingTrackedBeacons = mBeaconsByKey.get(getBeaconKey(beacon));
+        HashMap<Integer, Beacon> matchingTrackedBeacons = mBeaconsByKey.get(getBeaconKey(beacon));
         if (null != matchingTrackedBeacons) {
             for (Beacon matchingTrackedBeacon : matchingTrackedBeacons.values()) {
                 matchingTrackedBeacon.setRssi(beacon.getRssi());
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/MonitoringData.java b/lib/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
index 74356914..48f08b25 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -23,25 +23,37 @@
  */
 package org.altbeacon.beacon.service;
 
-import org.altbeacon.beacon.Region;
-
 import android.os.Bundle;
 
+import org.altbeacon.beacon.Region;
+
 public class MonitoringData {
     @SuppressWarnings("unused")
     private static final String TAG = "MonitoringData";
-    private final boolean mInside;
-    private final Region mRegion;
     private static final String REGION_KEY = "region";
     private static final String INSIDE_KEY = "inside";
+    private final boolean mInside;
+    private final Region mRegion;
 
-    public MonitoringData (boolean inside, Region region) {
+    public MonitoringData(boolean inside, Region region) {
         this.mInside = inside;
         this.mRegion = region;
     }
+
+    public static MonitoringData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
+        }
+        Boolean inside = bundle.getBoolean(INSIDE_KEY);
+        return new MonitoringData(inside, region);
+    }
+
     public boolean isInside() {
         return mInside;
     }
+
     public Region getRegion() {
         return mRegion;
     }
@@ -53,14 +65,5 @@ public Bundle toBundle() {
 
         return bundle;
     }
-    public static MonitoringData fromBundle(Bundle bundle) {
-        bundle.setClassLoader(Region.class.getClassLoader());
-        Region region = null;
-        if (bundle.get(REGION_KEY) != null) {
-            region = (Region) bundle.getSerializable(REGION_KEY);
-        }
-        Boolean inside = bundle.getBoolean(INSIDE_KEY);
-        return new MonitoringData(inside, region);
-    }
 
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/lib/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index ea8573e7..bc48c69b 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -25,22 +25,23 @@
 import static android.content.Context.MODE_PRIVATE;
 
 public class MonitoringStatus {
-    private static volatile MonitoringStatus sInstance;
+    public static final String STATUS_PRESERVATION_FILE_NAME =
+            "org.altbeacon.beacon.service.monitoring_status_state";
     private static final int MAX_REGIONS_FOR_STATUS_PRESERVATION = 50;
     private static final int MAX_STATUS_PRESERVATION_FILE_AGE_TO_RESTORE_SECS = 60 * 15;
     private static final String TAG = MonitoringStatus.class.getSimpleName();
-    public static final String STATUS_PRESERVATION_FILE_NAME =
-            "org.altbeacon.beacon.service.monitoring_status_state";
-    private Map<Region, RegionMonitoringState> mRegionsStatesMap;
-
-    private Context mContext;
-
-    private boolean mStatePreservationIsOn = true;
-
     /**
      * Private lock object for singleton initialization protecting against denial-of-service attack.
      */
     private static final Object SINGLETON_LOCK = new Object();
+    private static volatile MonitoringStatus sInstance;
+    private Map<Region, RegionMonitoringState> mRegionsStatesMap;
+    private Context mContext;
+    private boolean mStatePreservationIsOn = true;
+
+    public MonitoringStatus(Context context) {
+        this.mContext = context;
+    }
 
     public static MonitoringStatus getInstanceForApplication(Context context) {
         /*
@@ -68,10 +69,6 @@ public static MonitoringStatus getInstanceForApplication(Context context) {
         return instance;
     }
 
-    public MonitoringStatus(Context context) {
-        this.mContext = context;
-    }
-
     public synchronized void addRegion(Region region, Callback callback) {
         addLocalRegion(region, callback);
         saveMonitoringStatusIfOn();
@@ -108,8 +105,7 @@ public synchronized void updateNewlyOutside() {
         }
         if (needsMonitoringStateSaving) {
             saveMonitoringStatusIfOn();
-        }
-        else {
+        } else {
             updateMonitoringStatusTime(System.currentTimeMillis());
         }
     }
@@ -117,7 +113,7 @@ public synchronized void updateNewlyOutside() {
     public synchronized void updateNewlyInsideInRegionsContaining(Beacon beacon) {
         List<Region> matchingRegions = regionsMatchingTo(beacon);
         boolean needsMonitoringStateSaving = false;
-        for(Region region : matchingRegions) {
+        for (Region region : matchingRegions) {
             RegionMonitoringState state = getRegionsStateMap().get(region);
             if (state != null && state.markInside()) {
                 needsMonitoringStateSaving = true;
@@ -127,8 +123,7 @@ public synchronized void updateNewlyInsideInRegionsContaining(Beacon beacon) {
         }
         if (needsMonitoringStateSaving) {
             saveMonitoringStatusIfOn();
-        }
-        else {
+        } else {
             updateMonitoringStatusTime(System.currentTimeMillis());
         }
     }
@@ -145,11 +140,9 @@ private void restoreOrInitializeMonitoringStatus() {
         mRegionsStatesMap = new ConcurrentHashMap<Region, RegionMonitoringState>();
         if (!mStatePreservationIsOn) {
             LogManager.d(TAG, "Not restoring monitoring state because persistence is disabled");
-        }
-        else if (millisSinceLastMonitor > MAX_STATUS_PRESERVATION_FILE_AGE_TO_RESTORE_SECS * 1000) {
-            LogManager.d(TAG, "Not restoring monitoring state because it was recorded too many milliseconds ago: "+millisSinceLastMonitor);
-        }
-        else {
+        } else if (millisSinceLastMonitor > MAX_STATUS_PRESERVATION_FILE_AGE_TO_RESTORE_SECS * 1000) {
+            LogManager.d(TAG, "Not restoring monitoring state because it was recorded too many milliseconds ago: " + millisSinceLastMonitor);
+        } else {
             restoreMonitoringStatus();
             LogManager.d(TAG, "Done restoring monitoring status");
         }
@@ -168,22 +161,21 @@ else if (millisSinceLastMonitor > MAX_STATUS_PRESERVATION_FILE_AGE_TO_RESTORE_SE
     }
 
     protected void saveMonitoringStatusIfOn() {
-        if(!mStatePreservationIsOn) return;
+        if (!mStatePreservationIsOn) return;
         LogManager.d(TAG, "saveMonitoringStatusIfOn()");
         if (getRegionsStateMap().size() > MAX_REGIONS_FOR_STATUS_PRESERVATION) {
             LogManager.w(TAG, "Too many regions being monitored.  Will not persist region state");
             mContext.deleteFile(STATUS_PRESERVATION_FILE_NAME);
-        }
-        else {
+        } else {
             FileOutputStream outputStream = null;
             ObjectOutputStream objectOutputStream = null;
             try {
                 outputStream = mContext.openFileOutput(STATUS_PRESERVATION_FILE_NAME, MODE_PRIVATE);
                 objectOutputStream = new ObjectOutputStream(outputStream);
-                Map<Region,RegionMonitoringState> map = getRegionsStateMap();
+                Map<Region, RegionMonitoringState> map = getRegionsStateMap();
                 // Must convert ConcurrentHashMap to HashMap becasue attempting to serialize
                 // ConcurrentHashMap throws a java.io.NotSerializableException
-                HashMap<Region,RegionMonitoringState> serializableMap = new HashMap<Region,RegionMonitoringState>();
+                HashMap<Region, RegionMonitoringState> serializableMap = new HashMap<Region, RegionMonitoringState>();
                 for (Region region : map.keySet()) {
                     serializableMap.put(region, map.get(region));
                 }
@@ -225,18 +217,16 @@ protected void restoreMonitoringStatus() {
             inputStream = mContext.openFileInput(STATUS_PRESERVATION_FILE_NAME);
             objectInputStream = new ObjectInputStream(inputStream);
             Map<Region, RegionMonitoringState> obj = (Map<Region, RegionMonitoringState>) objectInputStream.readObject();
-            LogManager.d(TAG, "Restored region monitoring state for "+obj.size()+" regions.");
+            LogManager.d(TAG, "Restored region monitoring state for " + obj.size() + " regions.");
             for (Region region : obj.keySet()) {
-                LogManager.d(TAG, "Region  "+region+" uniqueId: "+region.getUniqueId()+" state: "+obj.get(region));
+                LogManager.d(TAG, "Region  " + region + " uniqueId: " + region.getUniqueId() + " state: " + obj.get(region));
             }
 
             // RegionMonitoringState objects only get serialized to the status preservation file when they are first inside,
             // therefore, their {@link RegionMonitoringState#lastSeenTime will be when they were first "inside".
             // Mark all beacons that were inside again so they don't trigger as a new exit - enter.
-            for (RegionMonitoringState regionMonitoringState : obj.values())
-            {
-                if (regionMonitoringState.getInside())
-                {
+            for (RegionMonitoringState regionMonitoringState : obj.values()) {
+                if (regionMonitoringState.getInside()) {
                     regionMonitoringState.markInside();
                 }
             }
@@ -245,7 +235,7 @@ protected void restoreMonitoringStatus() {
 
         } catch (IOException | ClassNotFoundException | ClassCastException e) {
             if (e instanceof InvalidClassException) {
-                LogManager.d(TAG, "Serialized Monitoring State has wrong class. Just ignoring saved state..." );
+                LogManager.d(TAG, "Serialized Monitoring State has wrong class. Just ignoring saved state...");
             } else LogManager.e(TAG, "Deserialization exception, message: %s", e.getMessage());
         } finally {
             if (null != inputStream) {
@@ -309,12 +299,13 @@ public void updateLocalState(Region region, Integer state) {
     public void removeLocalRegion(Region region) {
         getRegionsStateMap().remove(region);
     }
-    public RegionMonitoringState addLocalRegion(Region region){
+
+    public RegionMonitoringState addLocalRegion(Region region) {
         Callback dummyCallback = new Callback(null);
         return addLocalRegion(region, dummyCallback);
     }
 
-    private RegionMonitoringState addLocalRegion(Region region, Callback callback){
+    private RegionMonitoringState addLocalRegion(Region region, Callback callback) {
         if (getRegionsStateMap().containsKey(region)) {
             // if the region definition hasn't changed, becasue if it has, we need to clear state
             // otherwise a region with the same uniqueId can never be changed
@@ -322,11 +313,10 @@ private RegionMonitoringState addLocalRegion(Region region, Callback callback){
                 if (existingRegion.equals(region)) {
                     if (existingRegion.hasSameIdentifiers(region)) {
                         return getRegionsStateMap().get(existingRegion);
-                    }
-                    else {
-                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
-                        LogManager.d(TAG, "Old definition: "+existingRegion);
-                        LogManager.d(TAG, "New definition: "+region);
+                    } else {
+                        LogManager.d(TAG, "Replacing region with unique identifier " + region.getUniqueId());
+                        LogManager.d(TAG, "Old definition: " + existingRegion);
+                        LogManager.d(TAG, "New definition: " + region);
                         LogManager.d(TAG, "clearing state");
                         getRegionsStateMap().remove(region);
                         break;
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/RangeState.java b/lib/src/main/java/org/altbeacon/beacon/service/RangeState.java
index ed5aa765..ed26c022 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -34,14 +34,22 @@
 
 public class RangeState implements Serializable {
     private static final String TAG = "RangeState";
-    private Callback mCallback;
-    private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
     private static boolean sUseTrackingCache = false;
+    private Callback mCallback;
+    private Map<Beacon, RangedBeacon> mRangedBeacons = new HashMap<Beacon, RangedBeacon>();
 
     public RangeState(Callback c) {
         mCallback = c;
     }
 
+    public static boolean getUseTrackingCache() {
+        return sUseTrackingCache;
+    }
+
+    public static void setUseTrackingCache(boolean useTrackingCache) {
+        RangeState.sUseTrackingCache = useTrackingCache;
+    }
+
     public Callback getCallback() {
         return mCallback;
     }
@@ -53,8 +61,7 @@ public void addBeacon(Beacon beacon) {
                 LogManager.d(TAG, "adding %s to existing range for: %s", beacon, rangedBeacon);
             }
             rangedBeacon.updateBeacon(beacon);
-        }
-        else {
+        } else {
             if (LogManager.isVerboseLoggingEnabled()) {
                 LogManager.d(TAG, "adding %s to new rangedBeacon", beacon);
             }
@@ -65,7 +72,7 @@ public void addBeacon(Beacon beacon) {
     // returns a list of beacons that are tracked, and then removes any from the list that should not
     // be there for the next cycle
     public synchronized Collection<Beacon> finalizeBeacons() {
-        Map<Beacon,RangedBeacon> newRangedBeacons = new HashMap<Beacon,RangedBeacon>();
+        Map<Beacon, RangedBeacon> newRangedBeacons = new HashMap<Beacon, RangedBeacon>();
         ArrayList<Beacon> finalizedBeacons = new ArrayList<Beacon>();
 
         synchronized (mRangedBeacons) {
@@ -86,8 +93,7 @@ public void addBeacon(Beacon beacon) {
                         if (!sUseTrackingCache || rangedBeacon.isExpired())
                             rangedBeacon.setTracked(false);
                         newRangedBeacons.put(beacon, rangedBeacon);
-                    }
-                    else {
+                    } else {
                         LogManager.d(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
                     }
                 }
@@ -98,12 +104,4 @@ public void addBeacon(Beacon beacon) {
         return finalizedBeacons;
     }
 
-    public static void setUseTrackingCache(boolean useTrackingCache) {
-        RangeState.sUseTrackingCache = useTrackingCache;
-    }
-
-    public static boolean getUseTrackingCache() {
-        return sUseTrackingCache;
-    }
-
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/lib/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index d02bef83..55573544 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -11,22 +11,32 @@
 
 public class RangedBeacon implements Serializable {
 
-    private static final String TAG = "RangedBeacon";
     public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
-    public static long maxTrackingAge = DEFAULT_MAX_TRACKING_AGE; /* 5 Seconds */
     //kept here for backward compatibility
     public static final long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
+    private static final String TAG = "RangedBeacon";
+    public static long maxTrackingAge = DEFAULT_MAX_TRACKING_AGE; /* 5 Seconds */
     private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
-    private boolean mTracked = true;
     protected long lastTrackedTimeMillis = 0;
-    Beacon mBeacon;
     protected transient RssiFilter mFilter = null;
+    Beacon mBeacon;
+    private boolean mTracked = true;
     private int packetCount = 0;
 
     public RangedBeacon(Beacon beacon) {
         updateBeacon(beacon);
     }
 
+    //kept here for backward compatibility
+    public static void setSampleExpirationMilliseconds(long milliseconds) {
+        sampleExpirationMilliseconds = milliseconds;
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
+    }
+
+    public static void setMaxTrackinAge(int maxTrackinAge) {
+        RangedBeacon.maxTrackingAge = maxTrackinAge;
+    }
+
     public void updateBeacon(Beacon beacon) {
         packetCount += 1;
         mBeacon = beacon;
@@ -47,13 +57,12 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-         if (!getFilter().noMeasurementsAvailable()) {
-             double runningAverage = getFilter().calculateRssi();
-             mBeacon.setRunningAverageRssi(runningAverage);
-             mBeacon.setRssiMeasurementCount(getFilter().getMeasurementCount());
-             LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
-        }
-        else {
+        if (!getFilter().noMeasurementsAvailable()) {
+            double runningAverage = getFilter().calculateRssi();
+            mBeacon.setRunningAverageRssi(runningAverage);
+            mBeacon.setRssiMeasurementCount(getFilter().getMeasurementCount());
+            LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
+        } else {
             LogManager.d(TAG, "No measurements available to calculate running average");
         }
         mBeacon.setPacketCount(packetCount);
@@ -70,16 +79,6 @@ public void addMeasurement(Integer rssi) {
         }
     }
 
-    //kept here for backward compatibility
-    public static void setSampleExpirationMilliseconds(long milliseconds) {
-        sampleExpirationMilliseconds = milliseconds;
-        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
-    }
-
-    public static void setMaxTrackinAge(int maxTrackinAge) {
-        RangedBeacon.maxTrackingAge = maxTrackinAge;
-    }
-
     public boolean noMeasurementsAvailable() {
         return getFilter().noMeasurementsAvailable();
     }
@@ -96,8 +95,8 @@ private RssiFilter getFilter() {
         if (mFilter == null) {
             //set RSSI filter
             try {
-            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
-                mFilter = (RssiFilter)cons.newInstance();
+                Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
+                mFilter = (RssiFilter) cons.newInstance();
             } catch (Exception e) {
                 LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
             }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/RangingData.java b/lib/src/main/java/org/altbeacon/beacon/service/RangingData.java
index d7bb44ff..dc73239a 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -23,36 +23,52 @@
  */
 package org.altbeacon.beacon.service;
 
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collection;
+import android.os.Bundle;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.Region;
 
-import android.os.Bundle;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collection;
 
 /**
  * Internal class used to transfer ranging data between the BeaconService and the client
+ *
  * @hide
  */
 public class RangingData {
     private static final String TAG = "RangingData";
-    private final Collection<Beacon> mBeacons;
-    private final Region mRegion;
     private static final String REGION_KEY = "region";
     private static final String BEACONS_KEY = "beacons";
+    private final Collection<Beacon> mBeacons;
+    private final Region mRegion;
 
-    public RangingData (Collection<Beacon> beacons, Region region) {
+    public RangingData(Collection<Beacon> beacons, Region region) {
         synchronized (beacons) {
-            this.mBeacons =  beacons;
+            this.mBeacons = beacons;
         }
         this.mRegion = region;
     }
 
+    public static RangingData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        Collection<Beacon> beacons = null;
+        if (bundle.get(BEACONS_KEY) != null) {
+            beacons = (Collection<Beacon>) bundle.getSerializable(BEACONS_KEY);
+        }
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
+        }
+
+        return new RangingData(beacons, region);
+    }
+
     public Collection<Beacon> getBeacons() {
         return mBeacons;
     }
+
     public Region getRegion() {
         return mRegion;
     }
@@ -68,18 +84,5 @@ public Bundle toBundle() {
 
         return bundle;
     }
-    public static RangingData fromBundle(Bundle bundle) {
-        bundle.setClassLoader(Region.class.getClassLoader());
-        Region region = null;
-        Collection<Beacon> beacons = null;
-        if (bundle.get(BEACONS_KEY) != null) {
-            beacons = (Collection<Beacon>) bundle.getSerializable(BEACONS_KEY);
-        }
-        if (bundle.get(REGION_KEY) != null) {
-            region = (Region) bundle.getSerializable(REGION_KEY);
-        }
-
-        return new RangingData(beacons, region);
-    }
 
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java b/lib/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
index d7b36fb3..3a5dd209 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -32,9 +32,9 @@
 
 public class RegionMonitoringState implements Serializable {
     private static final String TAG = RegionMonitoringState.class.getSimpleName();
+    private final Callback callback;
     private boolean inside = false;
     private long lastSeenTime = 0l;
-    private final Callback callback;
 
     public RegionMonitoringState(Callback c) {
         callback = c;
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/RssiFilter.java b/lib/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
index d092c6ac..08139596 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
@@ -7,8 +7,11 @@
 public interface RssiFilter {
 
     public void addMeasurement(Integer rssi);
+
     public boolean noMeasurementsAvailable();
+
     public double calculateRssi();
+
     public int getMeasurementCount();
 
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java b/lib/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
index 7672f3b1..37c73092 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
@@ -17,11 +17,20 @@
  */
 public class RunningAverageRssiFilter implements RssiFilter {
 
-    private static final String TAG = "RunningAverageRssiFilter";
     public static final long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
+    private static final String TAG = "RunningAverageRssiFilter";
     private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
     private ArrayList<Measurement> mMeasurements = new ArrayList<Measurement>();
 
+    @RestrictTo(Scope.TESTS)
+    static long getSampleExpirationMilliseconds() {
+        return sampleExpirationMilliseconds;
+    }
+
+    public static void setSampleExpirationMilliseconds(long newSampleExpirationMilliseconds) {
+        sampleExpirationMilliseconds = newSampleExpirationMilliseconds;
+    }
+
     @Override
     public void addMeasurement(Integer rssi) {
         Measurement measurement = new Measurement();
@@ -35,26 +44,27 @@ public boolean noMeasurementsAvailable() {
         return mMeasurements.size() == 0;
     }
 
-
     @Override
-    public int getMeasurementCount() { return mMeasurements.size(); }
+    public int getMeasurementCount() {
+        return mMeasurements.size();
+    }
 
     @Override
     public double calculateRssi() {
         refreshMeasurements();
         int size = mMeasurements.size();
         int startIndex = 0;
-        int endIndex = size -1;
+        int endIndex = size - 1;
         if (size > 2) {
-            startIndex = size/10+1;
-            endIndex = size-size/10-2;
+            startIndex = size / 10 + 1;
+            endIndex = size - size / 10 - 2;
         }
 
         double sum = 0;
         for (int i = startIndex; i <= endIndex; i++) {
             sum += mMeasurements.get(i).rssi;
         }
-        double runningAverage = sum/(endIndex-startIndex+1);
+        double runningAverage = sum / (endIndex - startIndex + 1);
 
         LogManager.d(TAG, "Running average mRssi based on %s measurements: %s",
                 size, runningAverage);
@@ -66,7 +76,7 @@ private synchronized void refreshMeasurements() {
         Iterator<Measurement> iterator = mMeasurements.iterator();
         while (iterator.hasNext()) {
             Measurement measurement = iterator.next();
-            if (SystemClock.elapsedRealtime() - measurement.timestamp < sampleExpirationMilliseconds ) {
+            if (SystemClock.elapsedRealtime() - measurement.timestamp < sampleExpirationMilliseconds) {
                 newMeasurements.add(measurement);
             }
         }
@@ -77,18 +87,10 @@ private synchronized void refreshMeasurements() {
     private class Measurement implements Comparable<Measurement> {
         Integer rssi;
         long timestamp;
+
         @Override
         public int compareTo(Measurement arg0) {
             return rssi.compareTo(arg0.rssi);
         }
     }
-
-    public static void setSampleExpirationMilliseconds(long newSampleExpirationMilliseconds) {
-        sampleExpirationMilliseconds = newSampleExpirationMilliseconds;
-    }
-
-    @RestrictTo(Scope.TESTS)
-    static long getSampleExpirationMilliseconds() {
-        return sampleExpirationMilliseconds;
-    }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/lib/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
index 34d7f6d9..1a9e9625 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -18,9 +18,9 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.annotation.RequiresApi;
-import android.support.annotation.WorkerThread;
 import android.support.annotation.RestrictTo;
 import android.support.annotation.RestrictTo.Scope;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -50,9 +50,9 @@
 
 /**
  * Created by dyoung on 6/16/17.
- *
+ * <p>
  * This is an internal utility class and should not be called directly by library users.
- *
+ * <p>
  * This encapsulates shared data and methods used by both ScanJob and BeaconService
  * that deal with the specifics of beacon scanning.
  *
@@ -61,21 +61,62 @@
 
 class ScanHelper {
     private static final String TAG = ScanHelper.class.getSimpleName();
+    private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
     @Nullable
     private ExecutorService mExecutor;
     private BeaconManager mBeaconManager;
     @Nullable
     private CycledLeScanner mCycledScanner;
     private MonitoringStatus mMonitoringStatus;
-    private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
     private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
 
     @NonNull
     private ExtraDataBeaconTracker mExtraDataBeaconTracker = new ExtraDataBeaconTracker();
 
-    private Set<BeaconParser> mBeaconParsers  = new HashSet<>();
+    private Set<BeaconParser> mBeaconParsers = new HashSet<>();
     private List<Beacon> mSimulatedScanData = null;
     private Context mContext;
+    private final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+        @Override
+        @MainThread
+        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            processScanResult(device, rssi, scanRecord);
+        }
+
+        @Override
+        @MainThread
+        @SuppressLint("WrongThread")
+        public void onCycleEnd() {
+            if (BeaconManager.getBeaconSimulator() != null) {
+                LogManager.d(TAG, "Beacon simulator enabled");
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                    if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                        LogManager.d(TAG, "Beacon simulator returns " + BeaconManager.getBeaconSimulator().getBeacons().size() + " beacons.");
+                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                            // This is an expensive call and we do not want to block the main thread.
+                            // But here we are in debug/test mode so we allow it on the main thread.
+                            //noinspection WrongThread
+                            processBeaconFromScan(beacon);
+                        }
+                    } else {
+                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                    }
+                } else {
+                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+                }
+            } else {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon simulator not enabled");
+                }
+            }
+            mDistinctPacketDetector.clearDetections();
+            mMonitoringStatus.updateNewlyOutside();
+            processRangeData();
+        }
+    };
 
     ScanHelper(Context context) {
         mContext = context;
@@ -96,8 +137,7 @@ void terminateThreads() {
                 if (!mExecutor.awaitTermination(10, TimeUnit.MILLISECONDS)) {
                     LogManager.e(TAG, "Can't stop beacon parsing thread.");
                 }
-            }
-            catch (InterruptedException e) {
+            } catch (InterruptedException e) {
                 LogManager.e(TAG, "Interrupted waiting to stop beacon parsing thread.");
             }
             mExecutor = null;
@@ -110,7 +150,8 @@ protected void finalize() throws Throwable {
         terminateThreads();
     }
 
-    @Nullable CycledLeScanner getCycledScanner() {
+    @Nullable
+    CycledLeScanner getCycledScanner() {
         return mCycledScanner;
     }
 
@@ -145,7 +186,6 @@ void setSimulatedScanData(List<Beacon> simulatedScanData) {
         mSimulatedScanData = simulatedScanData;
     }
 
-
     void createCycledLeScanner(boolean backgroundMode, BluetoothCrashResolver crashResolver) {
         mCycledScanner = CycledLeScanner.createScanner(mContext, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
                 BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, backgroundMode,
@@ -208,8 +248,7 @@ void startAndroidOBackgroundScan(Set<BeaconParser> beaconParsers) {
                     LogManager.e(TAG, "Failed to start background scan on Android O: scanner is null");
                 }
             }
-        }
-        catch (SecurityException e) {
+        } catch (SecurityException e) {
             LogManager.e(TAG, "SecurityException making Android O background scanner");
         }
     }
@@ -225,10 +264,10 @@ void stopAndroidOBackgroundScan() {
             } else if (!bluetoothAdapter.isEnabled()) {
                 LogManager.w(TAG, "BluetoothAdapter is not enabled");
             } else {
-               BluetoothLeScanner scanner =  bluetoothAdapter.getBluetoothLeScanner();
-               if (scanner != null) {
-                   scanner.stopScan(getScanCallbackIntent());
-               }
+                BluetoothLeScanner scanner = bluetoothAdapter.getBluetoothLeScanner();
+                if (scanner != null) {
+                    scanner.stopScan(getScanCallbackIntent());
+                }
             }
         } catch (SecurityException e) {
             LogManager.e(TAG, "SecurityException stopping Android O background scanner");
@@ -242,52 +281,9 @@ void stopAndroidOBackgroundScan() {
     PendingIntent getScanCallbackIntent() {
         Intent intent = new Intent(mContext, StartupBroadcastReceiver.class);
         intent.putExtra("o-scan", true);
-        return PendingIntent.getBroadcast(mContext,0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+        return PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
     }
 
-    private final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
-        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-        @Override
-        @MainThread
-        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
-            processScanResult(device, rssi, scanRecord);
-        }
-
-        @Override
-        @MainThread
-        @SuppressLint("WrongThread")
-        public void onCycleEnd() {
-            if (BeaconManager.getBeaconSimulator() != null) {
-                LogManager.d(TAG, "Beacon simulator enabled");
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
-                    if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                        LogManager.d(TAG, "Beacon simulator returns "+BeaconManager.getBeaconSimulator().getBeacons().size()+" beacons.");
-                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
-                            // This is an expensive call and we do not want to block the main thread.
-                            // But here we are in debug/test mode so we allow it on the main thread.
-                            //noinspection WrongThread
-                            processBeaconFromScan(beacon);
-                        }
-                    } else {
-                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
-                    }
-                } else {
-                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
-                }
-            }
-            else {
-                if (LogManager.isVerboseLoggingEnabled()) {
-                    LogManager.d(TAG, "Beacon simulator not enabled");
-                }
-            }
-            mDistinctPacketDetector.clearDetections();
-            mMonitoringStatus.updateNewlyOutside();
-            processRangeData();
-        }
-    };
-
     @RestrictTo(Scope.TESTS)
     CycledLeScanCallback getCycledLeScanCallback() {
         return mCycledLeScanCallback;
@@ -350,23 +346,33 @@ private void processBeaconFromScan(@NonNull Beacon beacon) {
         }
     }
 
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+
     /**
      * <strong>This class is not thread safe.</strong>
      */
     private class ScanData {
-        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
-            this.device = device;
-            this.rssi = rssi;
-            this.scanRecord = scanRecord;
-        }
-
         final int rssi;
-
         @NonNull
         BluetoothDevice device;
-
         @NonNull
         byte[] scanRecord;
+
+        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
     }
 
     private class ScanProcessor extends AsyncTask<ScanHelper.ScanData, Void, Void> {
@@ -394,7 +400,7 @@ protected Void doInBackground(ScanHelper.ScanData... params) {
             }
             if (beacon != null) {
                 if (LogManager.isVerboseLoggingEnabled()) {
-                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                    LogManager.d(TAG, "Beacon packet detected for: " + beacon + " with rssi " + beacon.getRssi());
                 }
                 mDetectionTracker.recordDetection();
                 if (mCycledScanner != null && !mCycledScanner.getDistinctPacketsDetectedPerScan()) {
@@ -426,16 +432,4 @@ protected void onProgressUpdate(Void... values) {
         }
     }
 
-    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<>();
-        for (Region region : regions) {
-            if (region.matchesBeacon(beacon)) {
-                matched.add(region);
-            } else {
-                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
-            }
-        }
-        return matched;
-    }
-
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/lib/src/main/java/org/altbeacon/beacon/service/ScanJob.java
index b7380965..448cc8df 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/ScanJob.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -26,14 +26,15 @@
 
 /**
  * Used to perform scans periodically using the JobScheduler
- *
+ * <p>
  * Only one instance of this will be active, even with multiple jobIds.  If one job
  * is already running when another is scheduled to start, onStartJob gets called again on the same
  * instance.
- *
+ * <p>
  * If the OS decides to create a new instance, it will call onStopJob() on the old instance
- *
+ * <p>
  * Created by dyoung on 3/24/17.
+ *
  * @hide
  */
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
@@ -52,6 +53,96 @@
     private ScanHelper mScanHelper;
     private boolean mInitialized = false;
 
+    /**
+     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
+     * will default to the value in the AndroidManifest.xml
+     * <p>
+     * WARNING:  If using this library in a multi-process application, this method may not work.
+     * This is considered a private API and may be removed at any time.
+     * <p>
+     * the preferred way of setting this is in the AndroidManifest.xml as so:
+     * <code>
+     * <service android:name="org.altbeacon.beacon.service.ScanJob">
+     * </service>
+     * </code>
+     *
+     * @param id identifier to give the job
+     */
+    @SuppressWarnings("unused")
+    public static void setOverrideImmediateScanJobId(int id) {
+        sOverrideImmediateScanJobId = id;
+    }
+
+    /**
+     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
+     * will default to the value in the AndroidManifest.xml
+     * <p>
+     * WARNING:  If using this library in a multi-process application, this method may not work.
+     * This is considered a private API and may be removed at any time.
+     * <p>
+     * the preferred way of setting this is in the AndroidManifest.xml as so:
+     * <code>
+     * <service android:name="org.altbeacon.beacon.service.ScanJob">
+     * <meta-data android:name="immmediateScanJobId" android:value="1001" tools:replace="android:value"/>
+     * <meta-data android:name="periodicScanJobId" android:value="1002" tools:replace="android:value"/>
+     * </service>
+     * </code>
+     *
+     * @param id identifier to give the job
+     */
+    @SuppressWarnings("unused")
+    public static void setOverridePeriodicScanJobId(int id) {
+        sOverridePeriodicScanJobId = id;
+    }
+
+    /**
+     * Returns the job id to be used to schedule this job.  This may be set in the
+     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     *
+     * @param context the application context
+     * @return the job id
+     */
+    public static int getImmediateScanJobId(Context context) {
+        if (sOverrideImmediateScanJobId >= 0) {
+            LogManager.i(TAG, "Using ImmediateScanJobId from static override: " +
+                    sOverrideImmediateScanJobId);
+            return sOverrideImmediateScanJobId;
+        }
+        return getJobIdFromManifest(context, "immediateScanJobId");
+    }
+
+    /**
+     * Returns the job id to be used to schedule this job.  This may be set in the
+     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     *
+     * @param context the application context
+     * @return the job id
+     */
+    public static int getPeriodicScanJobId(Context context) {
+        if (sOverrideImmediateScanJobId >= 0) {
+            LogManager.i(TAG, "Using PeriodicScanJobId from static override: " +
+                    sOverridePeriodicScanJobId);
+            return sOverridePeriodicScanJobId;
+        }
+        return getJobIdFromManifest(context, "periodicScanJobId");
+    }
+
+    private static int getJobIdFromManifest(Context context, String name) {
+        PackageItemInfo info = null;
+        try {
+            info = context.getPackageManager().getServiceInfo(new ComponentName(context,
+                    ScanJob.class), PackageManager.GET_META_DATA);
+        } catch (PackageManager.NameNotFoundException e) { /* do nothing here */ }
+        if (info != null && info.metaData != null && info.metaData.get(name) != null) {
+            int jobId = info.metaData.getInt(name);
+            LogManager.i(TAG, "Using " + name + " from manifest: " + jobId);
+            return jobId;
+        } else {
+            throw new RuntimeException("Cannot get job id from manifest.  " +
+                    "Make sure that the " + name + " is configured in the manifest for the ScanJob.");
+        }
+    }
+
     @Override
     public boolean onStartJob(final JobParameters jobParameters) {
         if (!initialzeScanHelper()) {
@@ -59,10 +150,9 @@ public boolean onStartJob(final JobParameters jobParameters) {
             return false;
         }
         if (jobParameters.getJobId() == getImmediateScanJobId(this)) {
-            LogManager.i(TAG, "Running immediate scan job: instance is "+this);
-        }
-        else {
-            LogManager.i(TAG, "Running periodic scan job: instance is "+this);
+            LogManager.i(TAG, "Running immediate scan job: instance is " + this);
+        } else {
+            LogManager.i(TAG, "Running periodic scan job: instance is " + this);
         }
 
         List<ScanResult> queuedScanResults = ScanJobScheduler.getInstance().dumpBackgroundScanResultQueue();
@@ -79,21 +169,20 @@ public boolean onStartJob(final JobParameters jobParameters) {
         if (mInitialized) {
             LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
             startedScan = restartScanning();
-        }
-        else {
+        } else {
             startedScan = startScanning();
         }
         mStopHandler.removeCallbacksAndMessages(null);
 
         if (startedScan) {
-            LogManager.i(TAG, "Scan job running for "+mScanState.getScanJobRuntimeMillis()+" millis");
+            LogManager.i(TAG, "Scan job running for " + mScanState.getScanJobRuntimeMillis() + " millis");
             mStopHandler.postDelayed(new Runnable() {
                 @Override
                 public void run() {
                     LogManager.i(TAG, "Scan job runtime expired: " + ScanJob.this);
                     stopScanning();
                     mScanState.save();
-                    ScanJob.this.jobFinished(jobParameters , false);
+                    ScanJob.this.jobFinished(jobParameters, false);
 
                     // need to execute this after the current block or Android stops this job prematurely
                     mStopHandler.post(new Runnable() {
@@ -105,16 +194,15 @@ public void run() {
 
                 }
             }, mScanState.getScanJobRuntimeMillis());
-        }
-        else {
+        } else {
             LogManager.i(TAG, "Scanning not started so Scan job is complete.");
-            ScanJob.this.jobFinished(jobParameters , false);
+            ScanJob.this.jobFinished(jobParameters, false);
         }
         return true;
     }
 
-    private void scheduleNextScan(){
-        if(!mScanState.getBackgroundMode()){
+    private void scheduleNextScan() {
+        if (!mScanState.getBackgroundMode()) {
             // immediately reschedule scan if running in foreground
             LogManager.d(TAG, "In foreground mode, schedule next scan");
             ScanJobScheduler.getInstance().forceScheduleNextScan(ScanJob.this);
@@ -137,12 +225,10 @@ private void startPassiveScanIfNeeded() {
         if (insideAnyRegion) {
             // TODO: Set up a scan filter for not detecting a beacon pattern
             LogManager.i(TAG, "We are inside a beacon region.  We will not scan between cycles.");
-        }
-        else {
+        } else {
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                 mScanHelper.startAndroidOBackgroundScan(mScanState.getBeaconParsers());
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "This is not Android O.  No scanning between cycles when using ScanJob");
             }
         }
@@ -152,8 +238,7 @@ private void startPassiveScanIfNeeded() {
     public boolean onStopJob(JobParameters params) {
         if (params.getJobId() == getPeriodicScanJobId(this)) {
             LogManager.i(TAG, "onStopJob called for periodic scan " + this);
-        }
-        else {
+        } else {
             LogManager.i(TAG, "onStopJob called for immediate scan " + this);
         }
         // Cancel the stop timer.  The OS is stopping prematurely
@@ -189,8 +274,7 @@ private boolean initialzeScanHelper() {
         if (mScanHelper.getCycledScanner() == null) {
             try {
                 mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
-            }
-            catch (OutOfMemoryError e) {
+            } catch (OutOfMemoryError e) {
                 LogManager.w(TAG, "Failed to create CycledLeScanner thread.");
                 return false;
             }
@@ -224,8 +308,7 @@ private boolean restartScanning() {
                 mScanHelper.getCycledScanner().start();
             }
             return true;
-        }
-        else {
+        } else {
             if (mScanHelper.getCycledScanner() != null) {
                 mScanHelper.getCycledScanner().stop();
             }
@@ -239,103 +322,13 @@ private boolean startScanning() {
         beaconManager.setScannerInSameProcess(true);
         if (beaconManager.isMainProcess()) {
             LogManager.i(TAG, "scanJob version %s is starting up on the main process", BuildConfig.VERSION_NAME);
-        }
-        else {
+        } else {
             LogManager.i(TAG, "beaconScanJob library version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
             ProcessUtils processUtils = new ProcessUtils(ScanJob.this);
-            LogManager.i(TAG, "beaconScanJob PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
+            LogManager.i(TAG, "beaconScanJob PID is " + processUtils.getPid() + " with process name " + processUtils.getProcessName());
         }
-        ModelSpecificDistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(ScanJob.this, BeaconManager.getDistanceModelUpdateUrl());
+        ModelSpecificDistanceCalculator defaultDistanceCalculator = new ModelSpecificDistanceCalculator(ScanJob.this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
         return restartScanning();
     }
-
-    /**
-     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
-     * will default to the value in the AndroidManifest.xml
-     *
-     * WARNING:  If using this library in a multi-process application, this method may not work.
-     * This is considered a private API and may be removed at any time.
-     *
-     * the preferred way of setting this is in the AndroidManifest.xml as so:
-     * <code>
-     * <service android:name="org.altbeacon.beacon.service.ScanJob">
-     * </service>
-     * </code>
-     *
-     * @param id identifier to give the job
-     */
-    @SuppressWarnings("unused")
-    public static void setOverrideImmediateScanJobId(int id) {
-        sOverrideImmediateScanJobId = id;
-    }
-
-    /**
-     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
-     * will default to the value in the AndroidManifest.xml
-     *
-     * WARNING:  If using this library in a multi-process application, this method may not work.
-     * This is considered a private API and may be removed at any time.
-     *
-     * the preferred way of setting this is in the AndroidManifest.xml as so:
-     * <code>
-     * <service android:name="org.altbeacon.beacon.service.ScanJob">
-     *   <meta-data android:name="immmediateScanJobId" android:value="1001" tools:replace="android:value"/>
-     *   <meta-data android:name="periodicScanJobId" android:value="1002" tools:replace="android:value"/>
-     * </service>
-     * </code>
-     *
-     * @param id identifier to give the job
-     */
-    @SuppressWarnings("unused")
-    public static void setOverridePeriodicScanJobId(int id) {
-        sOverridePeriodicScanJobId = id;
-    }
-
-    /**
-     * Returns the job id to be used to schedule this job.  This may be set in the
-     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
-     * @param context the application context
-     * @return the job id
-     */
-    public static int getImmediateScanJobId(Context context) {
-        if (sOverrideImmediateScanJobId >= 0) {
-            LogManager.i(TAG, "Using ImmediateScanJobId from static override: "+
-                    sOverrideImmediateScanJobId);
-            return sOverrideImmediateScanJobId;
-        }
-        return getJobIdFromManifest(context, "immediateScanJobId");
-    }
-
-    /**
-     * Returns the job id to be used to schedule this job.  This may be set in the
-     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
-     * @param context the application context
-     * @return the job id
-     */
-    public static int getPeriodicScanJobId(Context context) {
-        if (sOverrideImmediateScanJobId >= 0) {
-            LogManager.i(TAG, "Using PeriodicScanJobId from static override: "+
-                    sOverridePeriodicScanJobId);
-            return sOverridePeriodicScanJobId;
-        }
-        return getJobIdFromManifest(context, "periodicScanJobId");
-    }
-
-    private static int getJobIdFromManifest(Context context, String name) {
-        PackageItemInfo info = null;
-        try {
-            info = context.getPackageManager().getServiceInfo(new ComponentName(context,
-                    ScanJob.class), PackageManager.GET_META_DATA);
-        } catch (PackageManager.NameNotFoundException e) { /* do nothing here */ }
-        if (info != null && info.metaData != null && info.metaData.get(name) != null) {
-            int jobId = info.metaData.getInt(name);
-            LogManager.i(TAG, "Using "+name+" from manifest: "+jobId);
-            return jobId;
-        }
-        else {
-            throw new RuntimeException("Cannot get job id from manifest.  " +
-                    "Make sure that the "+name+" is configured in the manifest for the ScanJob.");
-        }
-    }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/lib/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
index 422f3d0c..2756cac5 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -21,15 +21,16 @@
 
 /**
  * Schedules two types of ScanJobs:
- *  1. Periodic, which are set to go every scanPeriod+betweenScanPeriod
- *  2. Immediate, which go right now.
- *
- *  Immediate ScanJobs are used when the app is in the foreground and wants to get immediate results
- *  or when beacons have been detected with background scan filters and delivered via Intents and
- *  a scan needs to run in a timely manner to collect data about those beacons known to be newly
- *  in the vicinity despite the app being in the background.
- *
+ * 1. Periodic, which are set to go every scanPeriod+betweenScanPeriod
+ * 2. Immediate, which go right now.
+ * <p>
+ * Immediate ScanJobs are used when the app is in the foreground and wants to get immediate results
+ * or when beacons have been detected with background scan filters and delivered via Intents and
+ * a scan needs to run in a timely manner to collect data about those beacons known to be newly
+ * in the vicinity despite the app being in the background.
+ * <p>
  * Created by dyoung on 6/7/17.
+ *
  * @hide
  */
 @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
@@ -46,6 +47,9 @@
     @Nullable
     private BeaconLocalBroadcastProcessor mBeaconNotificationProcessor;
 
+    private ScanJobScheduler() {
+    }
+
     @NonNull
     public static ScanJobScheduler getInstance() {
         ScanJobScheduler instance = sInstance;
@@ -60,9 +64,6 @@ public static ScanJobScheduler getInstance() {
         return instance;
     }
 
-    private ScanJobScheduler() {
-    }
-
     private void ensureNotificationProcessorSetup(Context context) {
         if (mBeaconNotificationProcessor == null) {
             mBeaconNotificationProcessor = new BeaconLocalBroadcastProcessor(context);
@@ -81,7 +82,7 @@ private void ensureNotificationProcessorSetup(Context context) {
 
     private void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
         scanState.applyChanges(beaconManager);
-        LogManager.d(TAG, "Applying scan job settings with background mode "+scanState.getBackgroundMode());
+        LogManager.d(TAG, "Applying scan job settings with background mode " + scanState.getBackgroundMode());
         schedule(context, scanState, false);
     }
 
@@ -111,10 +112,9 @@ public void scheduleAfterBackgroundWakeup(Context context, List<ScanResult> scan
         synchronized (this) {
             // We typically get a bunch of calls in a row here, separated by a few millis.  Only do this once.
             if (System.currentTimeMillis() - mScanJobScheduleTime > MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING) {
-                LogManager.d(TAG, "scheduling an immediate scan job because last did "+(System.currentTimeMillis() - mScanJobScheduleTime)+"seconds ago.");
+                LogManager.d(TAG, "scheduling an immediate scan job because last did " + (System.currentTimeMillis() - mScanJobScheduleTime) + "seconds ago.");
                 mScanJobScheduleTime = System.currentTimeMillis();
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "Not scheduling an immediate scan job because we just did recently.");
                 return;
             }
@@ -137,13 +137,11 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
         if (backgroundWakeup) {
             LogManager.d(TAG, "We just woke up in the background based on a new scan result.  Start scan job immediately.");
             millisToNextJobStart = 0;
-        }
-        else {
+        } else {
             if (betweenScanPeriod > 0) {
                 // If we pause between scans, then we need to start scanning on a normalized time
                 millisToNextJobStart = (SystemClock.elapsedRealtime() % scanState.getScanJobIntervalMillis());
-            }
-            else {
+            } else {
                 millisToNextJobStart = 0;
             }
 
@@ -162,7 +160,7 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
             if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
                 // If the next time we want to scan is less than 50ms from the periodic scan cycle, then]
                 // we schedule it for that specific time.
-                LogManager.d(TAG, "Scheduling immediate ScanJob to run in "+millisToNextJobStart+" millis");
+                LogManager.d(TAG, "Scheduling immediate ScanJob to run in " + millisToNextJobStart + " millis");
                 JobInfo immediateJob = new JobInfo.Builder(ScanJob.getImmediateScanJobId(context), new ComponentName(context, ScanJob.class))
                         .setPersisted(true) // This makes it restart after reboot
                         .setExtras(new PersistableBundle())
@@ -170,13 +168,12 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
                         .setOverrideDeadline(millisToNextJobStart).build();
                 int error = jobScheduler.schedule(immediateJob);
                 if (error < 0) {
-                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: " + error);
                 }
             } else {
                 LogManager.d(TAG, "Not scheduling immediate scan, assuming periodic is about to run");
             }
-        }
-        else {
+        } else {
             LogManager.d(TAG, "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
             jobScheduler.cancel(ScanJob.getImmediateScanJobId(context));
         }
@@ -189,8 +186,7 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
             // ON Android N+ we specify a tolerance of 0ms (capped at 5% by the OS) to ensure
             // our scans happen within 5% of the schduled time.
             periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0L).build();
-        }
-        else {
+        } else {
             periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis()).build();
         }
         // On Android O I see this:
@@ -245,10 +241,10 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
          */
 
         final JobInfo jobInfo = periodicJobBuilder.build();
-        LogManager.d(TAG, "Scheduling ScanJob " + jobInfo + " to run every "+scanState.getScanJobIntervalMillis()+" millis");
+        LogManager.d(TAG, "Scheduling ScanJob " + jobInfo + " to run every " + scanState.getScanJobIntervalMillis() + " millis");
         int error = jobScheduler.schedule(jobInfo);
         if (error < 0) {
-            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: " + error);
         }
     }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/ScanState.java b/lib/src/main/java/org/altbeacon/beacon/service/ScanState.java
index 3e3fbddd..d1380d6f 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/ScanState.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/ScanState.java
@@ -10,10 +10,10 @@
 
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InvalidClassException;
-import java.io.FileNotFoundException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
@@ -28,8 +28,9 @@
 /**
  * Stores the full state of scanning for the libary, including all settings so it can be ressurrected easily
  * for running from a scheduled job
- *
+ * <p>
  * Created by dyoung on 3/26/17.
+ *
  * @hide
  */
 
@@ -41,7 +42,7 @@
 
     private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
     private transient MonitoringStatus mMonitoringStatus;
-    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private Set<BeaconParser> mBeaconParsers = new HashSet<BeaconParser>();
     private ExtraDataBeaconTracker mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
     private long mForegroundBetweenScanPeriod;
     private long mBackgroundBetweenScanPeriod;
@@ -51,6 +52,57 @@
     private long mLastScanStartTimeMillis = 0l;
     private transient Context mContext;
 
+    public ScanState(Context context) {
+        mContext = context;
+    }
+
+    public static ScanState restore(Context context) {
+        ScanState scanState = null;
+        synchronized (ScanState.class) {
+            FileInputStream inputStream = null;
+            ObjectInputStream objectInputStream = null;
+            try {
+                inputStream = context.openFileInput(STATUS_PRESERVATION_FILE_NAME);
+                objectInputStream = new ObjectInputStream(inputStream);
+                scanState = (ScanState) objectInputStream.readObject();
+                scanState.mContext = context;
+            } catch (FileNotFoundException fnfe) {
+                LogManager.w(TAG, "Serialized ScanState does not exist.  This may be normal on first run.");
+            } catch (IOException | ClassNotFoundException | ClassCastException e) {
+                if (e instanceof InvalidClassException) {
+                    LogManager.d(TAG, "Serialized ScanState has wrong class. Just ignoring saved state...");
+                } else {
+                    LogManager.e(TAG, "Deserialization exception");
+                    Log.e(TAG, "error: ", e);
+                }
+
+            } finally {
+                if (null != inputStream) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectInputStream != null) {
+                    try {
+                        objectInputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            if (scanState == null) {
+                scanState = new ScanState(context);
+
+            }
+            if (scanState.mExtraBeaconDataTracker == null) {
+                scanState.mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+            }
+            scanState.mMonitoringStatus = MonitoringStatus.getInstanceForApplication(context);
+            LogManager.d(TAG, "Scan state restore regions: monitored=" + scanState.getMonitoringStatus().regions().size() + " ranged=" + scanState.getRangedRegionState().keySet().size());
+            return scanState;
+        }
+    }
+
     public Boolean getBackgroundMode() {
         return mBackgroundMode;
     }
@@ -91,10 +143,6 @@ public void setForegroundScanPeriod(Long foregroundScanPeriod) {
         mForegroundScanPeriod = foregroundScanPeriod;
     }
 
-    public ScanState(Context context) {
-        mContext = context;
-    }
-
     public MonitoringStatus getMonitoringStatus() {
         return mMonitoringStatus;
     }
@@ -130,59 +178,11 @@ public void setBeaconParsers(Set<BeaconParser> beaconParsers) {
     public long getLastScanStartTimeMillis() {
         return mLastScanStartTimeMillis;
     }
+
     public void setLastScanStartTimeMillis(long time) {
         mLastScanStartTimeMillis = time;
     }
 
-    public static ScanState restore(Context context) {
-        ScanState scanState = null;
-        synchronized (ScanState.class) {
-            FileInputStream inputStream = null;
-            ObjectInputStream objectInputStream = null;
-            try {
-                inputStream = context.openFileInput(STATUS_PRESERVATION_FILE_NAME);
-                objectInputStream = new ObjectInputStream(inputStream);
-                scanState = (ScanState) objectInputStream.readObject();
-                scanState.mContext = context;
-            } catch (FileNotFoundException fnfe) {
-                LogManager.w(TAG, "Serialized ScanState does not exist.  This may be normal on first run.");
-            }
-            catch (IOException | ClassNotFoundException | ClassCastException e) {
-                if (e instanceof InvalidClassException) {
-                    LogManager.d(TAG, "Serialized ScanState has wrong class. Just ignoring saved state...");
-                }
-                else {
-                    LogManager.e(TAG, "Deserialization exception");
-                    Log.e(TAG, "error: ", e);
-                }
-
-            } finally {
-                if (null != inputStream) {
-                    try {
-                        inputStream.close();
-                    } catch (IOException ignored) {
-                    }
-                }
-                if (objectInputStream != null) {
-                    try {
-                        objectInputStream.close();
-                    } catch (IOException ignored) {
-                    }
-                }
-            }
-            if (scanState == null) {
-                scanState = new ScanState(context);
-
-            }
-            if (scanState.mExtraBeaconDataTracker == null) {
-                scanState.mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
-            }
-            scanState.mMonitoringStatus = MonitoringStatus.getInstanceForApplication(context);
-            LogManager.d(TAG, "Scan state restore regions: monitored="+scanState.getMonitoringStatus().regions().size()+" ranged="+scanState.getRangedRegionState().keySet().size());
-            return scanState;
-        }
-    }
-
     public void save() {
         synchronized (ScanState.class) {
             // TODO: need to limit how big this object is somehow.
@@ -195,8 +195,8 @@ public void save() {
                 objectOutputStream.writeObject(this);
                 File file = new File(mContext.getFilesDir(), STATUS_PRESERVATION_FILE_NAME);
                 File tempFile = new File(mContext.getFilesDir(), TEMP_STATUS_PRESERVATION_FILE_NAME);
-                LogManager.d(TAG, "Temp file is "+tempFile.getAbsolutePath());
-                LogManager.d(TAG, "Perm file is "+file.getAbsolutePath());
+                LogManager.d(TAG, "Temp file is " + tempFile.getAbsolutePath());
+                LogManager.d(TAG, "Perm file is " + file.getAbsolutePath());
 
                 if (!file.delete()) {
                     LogManager.e(TAG, "Error while saving scan status to file: Cannot delete existing file.");
@@ -227,10 +227,9 @@ public void save() {
     public int getScanJobIntervalMillis() {
         long cyclePeriodMillis;
         if (getBackgroundMode()) {
-            cyclePeriodMillis = getBackgroundScanPeriod()+getBackgroundBetweenScanPeriod();
-        }
-        else {
-            cyclePeriodMillis = getForegroundScanPeriod()+getForegroundBetweenScanPeriod();
+            cyclePeriodMillis = getBackgroundScanPeriod() + getBackgroundBetweenScanPeriod();
+        } else {
+            cyclePeriodMillis = getForegroundScanPeriod() + getForegroundBetweenScanPeriod();
         }
         int scanJobIntervalMillis = MIN_SCAN_JOB_INTERVAL_MILLIS;
         if (cyclePeriodMillis > MIN_SCAN_JOB_INTERVAL_MILLIS) {
@@ -241,11 +240,10 @@ public int getScanJobIntervalMillis() {
 
     public int getScanJobRuntimeMillis() {
         long scanPeriodMillis;
-        LogManager.d(TAG, "ScanState says background mode for ScanJob is "+getBackgroundMode());
+        LogManager.d(TAG, "ScanState says background mode for ScanJob is " + getBackgroundMode());
         if (getBackgroundMode()) {
             scanPeriodMillis = getBackgroundScanPeriod();
-        }
-        else {
+        } else {
             scanPeriodMillis = getForegroundScanPeriod();
         }
         if (!getBackgroundMode()) {
@@ -258,7 +256,6 @@ public int getScanJobRuntimeMillis() {
     }
 
 
-
     public void applyChanges(BeaconManager beaconManager) {
         mBeaconParsers = new HashSet<>(beaconManager.getBeaconParsers());
         mForegroundScanPeriod = beaconManager.getForegroundScanPeriod();
@@ -271,22 +268,22 @@ public void applyChanges(BeaconManager beaconManager) {
         ArrayList<Region> existingRangedRegions = new ArrayList<>(mRangedRegionState.keySet());
         ArrayList<Region> newMonitoredRegions = new ArrayList<>(beaconManager.getMonitoredRegions());
         ArrayList<Region> newRangedRegions = new ArrayList<>(beaconManager.getRangedRegions());
-        LogManager.d(TAG, "ranged regions: old="+existingRangedRegions.size()+" new="+newRangedRegions.size());
-        LogManager.d(TAG, "monitored regions: old="+existingMonitoredRegions.size()+" new="+newMonitoredRegions.size());
+        LogManager.d(TAG, "ranged regions: old=" + existingRangedRegions.size() + " new=" + newRangedRegions.size());
+        LogManager.d(TAG, "monitored regions: old=" + existingMonitoredRegions.size() + " new=" + newMonitoredRegions.size());
 
-        for (Region newRangedRegion: newRangedRegions) {
+        for (Region newRangedRegion : newRangedRegions) {
             if (!existingRangedRegions.contains(newRangedRegion)) {
-                LogManager.d(TAG, "Starting ranging region: "+newRangedRegion);
+                LogManager.d(TAG, "Starting ranging region: " + newRangedRegion);
                 mRangedRegionState.put(newRangedRegion, new RangeState(new Callback(mContext.getPackageName())));
             }
         }
-        for (Region existingRangedRegion: existingRangedRegions) {
+        for (Region existingRangedRegion : existingRangedRegions) {
             if (!newRangedRegions.contains(existingRangedRegion)) {
-                LogManager.d(TAG, "Stopping ranging region: "+existingRangedRegion);
+                LogManager.d(TAG, "Stopping ranging region: " + existingRangedRegion);
                 mRangedRegionState.remove(existingRangedRegion);
             }
         }
-        LogManager.d(TAG, "Updated state with "+newRangedRegions.size()+" ranging regions and "+newMonitoredRegions.size()+" monitoring regions.");
+        LogManager.d(TAG, "Updated state with " + newRangedRegions.size() + " ranging regions and " + newMonitoredRegions.size() + " monitoring regions.");
 
         this.save();
     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/SettingsData.java b/lib/src/main/java/org/altbeacon/beacon/service/SettingsData.java
index d1202336..32411443 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/SettingsData.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/SettingsData.java
@@ -16,7 +16,7 @@
 
 /**
  * Created by dyoung on 3/10/17.
- *
+ * <p>
  * Internal class used to transfer settings between the BeaconService and the client
  *
  * @hide
@@ -38,11 +38,6 @@
     //        BeaconManager.setBeaconSimulator(...)
     //        beaconManager.setNonBeaconLeScanCallback(...)
 
-    public Bundle toBundle() {
-        Bundle bundle = new Bundle();
-        bundle.putSerializable(SETTINGS_DATA_KEY, this);
-        return bundle;
-    }
     public static SettingsData fromBundle(@NonNull Bundle bundle) {
         bundle.setClassLoader(Region.class.getClassLoader());
         SettingsData settingsData = null;
@@ -52,6 +47,12 @@ public static SettingsData fromBundle(@NonNull Bundle bundle) {
         return settingsData;
     }
 
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(SETTINGS_DATA_KEY, this);
+        return bundle;
+    }
+
     public void apply(@NonNull BeaconService scanService) {
         LogManager.d(TAG, "Applying settings changes to scanner in other process");
         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(scanService);
@@ -60,13 +61,12 @@ public void apply(@NonNull BeaconService scanService) {
         if (beaconParsers.size() == mBeaconParsers.size()) {
             for (int i = 0; i < beaconParsers.size(); i++) {
                 if (!beaconParsers.get(i).equals(mBeaconParsers.get(i))) {
-                    LogManager.d(TAG, "Beacon parsers have changed to: "+mBeaconParsers.get(i).getLayout());
+                    LogManager.d(TAG, "Beacon parsers have changed to: " + mBeaconParsers.get(i).getLayout());
                     beaconParsersChanged = true;
                     break;
                 }
             }
-        }
-        else {
+        } else {
             beaconParsersChanged = true;
             LogManager.d(TAG, "Beacon parsers have been added or removed.");
         }
@@ -75,16 +75,14 @@ public void apply(@NonNull BeaconService scanService) {
             beaconManager.getBeaconParsers().clear();
             beaconManager.getBeaconParsers().addAll(mBeaconParsers);
             scanService.reloadParsers();
-        }
-        else {
+        } else {
             LogManager.d(TAG, "Beacon parsers unchanged.");
         }
         MonitoringStatus monitoringStatus = MonitoringStatus.getInstanceForApplication(scanService);
         if (monitoringStatus.isStatePreservationOn() &&
                 !mRegionStatePersistenceEnabled) {
             monitoringStatus.stopStatusPreservation();
-        }
-        else if (!monitoringStatus.isStatePreservationOn() &&
+        } else if (!monitoringStatus.isStatePreservationOn() &&
                 mRegionStatePersistenceEnabled) {
             monitoringStatus.startStatusPreservation();
         }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/StartRMData.java b/lib/src/main/java/org/altbeacon/beacon/service/StartRMData.java
index 1fa8a6d6..6778a8ce 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/StartRMData.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/StartRMData.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -33,18 +33,26 @@
 import java.io.Serializable;
 
 /**
- *
  * Internal class used to transfer ranging and monitoring data between the BeaconService and client
  *
  * @hide
  */
 public class StartRMData implements Serializable, Parcelable {
+    public static final Parcelable.Creator<StartRMData> CREATOR
+            = new Parcelable.Creator<StartRMData>() {
+        public StartRMData createFromParcel(Parcel in) {
+            return new StartRMData(in);
+        }
+
+        public StartRMData[] newArray(int size) {
+            return new StartRMData[size];
+        }
+    };
     private static final String SCAN_PERIOD_KEY = "scanPeriod";
     private static final String BETWEEN_SCAN_PERIOD_KEY = "betweenScanPeriod";
     private static final String BACKGROUND_FLAG_KEY = "backgroundFlag";
     private static final String CALLBACK_PACKAGE_NAME_KEY = "callbackPackageName";
     private static final String REGION_KEY = "region";
-
     private Region mRegion;
     private long mScanPeriod;
     private long mBetweenScanPeriod;
@@ -58,12 +66,14 @@ public StartRMData(@NonNull Region region, @NonNull String callbackPackageName)
         this.mRegion = region;
         this.mCallbackPackageName = callbackPackageName;
     }
+
     public StartRMData(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
         this.mScanPeriod = scanPeriod;
         this.mBetweenScanPeriod = betweenScanPeriod;
         this.mBackgroundFlag = backgroundFlag;
     }
 
+
     public StartRMData(@NonNull Region region, @NonNull String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
         this.mScanPeriod = scanPeriod;
         this.mBetweenScanPeriod = betweenScanPeriod;
@@ -72,39 +82,6 @@ public StartRMData(@NonNull Region region, @NonNull String callbackPackageName,
         this.mBackgroundFlag = backgroundFlag;
     }
 
-
-    public long getScanPeriod() { return mScanPeriod; }
-    public long getBetweenScanPeriod() { return mBetweenScanPeriod; }
-    public Region getRegionData() {
-        return mRegion;
-    }
-    public String getCallbackPackageName() {
-        return mCallbackPackageName;
-    }
-    public boolean getBackgroundFlag() { return mBackgroundFlag; }
-    public int describeContents() {
-        return 0;
-    }
-
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeParcelable(mRegion, flags);
-        out.writeString(mCallbackPackageName);
-        out.writeLong(mScanPeriod);
-        out.writeLong(mBetweenScanPeriod);
-        out.writeByte((byte) (mBackgroundFlag ? 1 : 0));
-    }
-
-    public static final Parcelable.Creator<StartRMData> CREATOR
-            = new Parcelable.Creator<StartRMData>() {
-        public StartRMData createFromParcel(Parcel in) {
-            return new StartRMData(in);
-        }
-
-        public StartRMData[] newArray(int size) {
-            return new StartRMData[size];
-        }
-    };
-
     private StartRMData(Parcel in) {
         mRegion = in.readParcelable(StartRMData.class.getClassLoader());
         mCallbackPackageName = in.readString();
@@ -113,24 +90,12 @@ private StartRMData(Parcel in) {
         mBackgroundFlag = in.readByte() != 0;
     }
 
-    public Bundle toBundle() {
-        Bundle bundle = new Bundle();
-        bundle.putLong(SCAN_PERIOD_KEY, this.mScanPeriod);
-        bundle.putLong(BETWEEN_SCAN_PERIOD_KEY, this.mBetweenScanPeriod);
-        bundle.putBoolean(BACKGROUND_FLAG_KEY, this.mBackgroundFlag);
-        bundle.putString(CALLBACK_PACKAGE_NAME_KEY, this.mCallbackPackageName);
-        if (mRegion != null) {
-            bundle.putSerializable(REGION_KEY, mRegion);
-        }
-        return bundle;
-    }
-
     public static StartRMData fromBundle(@NonNull Bundle bundle) {
         bundle.setClassLoader(Region.class.getClassLoader());
         boolean valid = false;
         StartRMData data = new StartRMData();
         if (bundle.containsKey(REGION_KEY)) {
-            data.mRegion = (Region)bundle.getSerializable(REGION_KEY);
+            data.mRegion = (Region) bundle.getSerializable(REGION_KEY);
             valid = true;
         }
         if (bundle.containsKey(SCAN_PERIOD_KEY)) {
@@ -148,10 +113,53 @@ public static StartRMData fromBundle(@NonNull Bundle bundle) {
         }
         if (valid) {
             return data;
-        }
-        else {
+        } else {
             return null;
         }
     }
 
+    public long getScanPeriod() {
+        return mScanPeriod;
+    }
+
+    public long getBetweenScanPeriod() {
+        return mBetweenScanPeriod;
+    }
+
+    public Region getRegionData() {
+        return mRegion;
+    }
+
+    public String getCallbackPackageName() {
+        return mCallbackPackageName;
+    }
+
+    public boolean getBackgroundFlag() {
+        return mBackgroundFlag;
+    }
+
+    public int describeContents() {
+        return 0;
+    }
+
+    public void writeToParcel(Parcel out, int flags) {
+        out.writeParcelable(mRegion, flags);
+        out.writeString(mCallbackPackageName);
+        out.writeLong(mScanPeriod);
+        out.writeLong(mBetweenScanPeriod);
+        out.writeByte((byte) (mBackgroundFlag ? 1 : 0));
+    }
+
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putLong(SCAN_PERIOD_KEY, this.mScanPeriod);
+        bundle.putLong(BETWEEN_SCAN_PERIOD_KEY, this.mBetweenScanPeriod);
+        bundle.putBoolean(BACKGROUND_FLAG_KEY, this.mBackgroundFlag);
+        bundle.putString(CALLBACK_PACKAGE_NAME_KEY, this.mCallbackPackageName);
+        if (mRegion != null) {
+            bundle.putSerializable(REGION_KEY, mRegion);
+        }
+        return bundle;
+    }
+
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/Stats.java b/lib/src/main/java/org/altbeacon/beacon/service/Stats.java
index aaac630b..8094f333 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/Stats.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/Stats.java
@@ -27,33 +27,40 @@
     private boolean mEnabled;
     private Sample mSample;
 
-    public static Stats getInstance() {
-        return INSTANCE;
-    }
-
     private Stats() {
         mSampleIntervalMillis = 0l;
         clearSamples();
     }
+
+    public static Stats getInstance() {
+        return INSTANCE;
+    }
+
     public ArrayList<Sample> getSamples() {
         rollSampleIfNeeded();
         return mSamples;
     }
-    public void setEnabled(boolean enabled) {
-        mEnabled = enabled;
-    }
+
     public boolean isEnabled() {
         return mEnabled;
     }
+
+    public void setEnabled(boolean enabled) {
+        mEnabled = enabled;
+    }
+
     public void setLoggingEnabled(boolean enabled) {
         mEnableLogging = enabled;
     }
+
     public void setHistoricalLoggingEnabled(boolean enabled) {
         mEnableHistoricalLogging = enabled;
     }
+
     public void setSampleIntervalMillis(long interval) {
         mSampleIntervalMillis = interval;
     }
+
     public void log(Beacon beacon) {
         rollSampleIfNeeded();
         mSample.detectionCount++;
@@ -69,6 +76,7 @@ public void log(Beacon beacon) {
         }
         mSample.lastDetectionTime = new Date();
     }
+
     public void clearSample() {
         mSample = null;
     }
@@ -76,7 +84,7 @@ public void clearSample() {
     public void newSampleInterval() {
         Date boundaryTime = new Date();
         if (mSample != null) {
-            boundaryTime = new Date(mSample.sampleStartTime.getTime()+mSampleIntervalMillis);
+            boundaryTime = new Date(mSample.sampleStartTime.getTime() + mSampleIntervalMillis);
             mSample.sampleStopTime = boundaryTime;
             if (!mEnableHistoricalLogging && mEnableLogging) {
                 logSample(mSample, true);
@@ -124,6 +132,7 @@ private void logSamples() {
             firstPass = false;
         }
     }
+
     private void rollSampleIfNeeded() {
         if (mSample == null || (mSampleIntervalMillis > 0 && (new Date().getTime() - mSample.sampleStartTime.getTime()) >=
                 mSampleIntervalMillis)) {
@@ -133,7 +142,7 @@ private void rollSampleIfNeeded() {
 
 
     public static class Sample {
-        public long detectionCount  = 0l;
+        public long detectionCount = 0l;
         public long maxMillisBetweenDetections;
         public Date firstDetectionTime;
         public Date lastDetectionTime;
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
index f8066130..3a82346c 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
@@ -8,11 +8,12 @@
  * <p>
  * Since Android bluetooth scan callbacks occur on the main thread it is expected that these
  * callbacks will also occur on the main thread.
- *
+ * <p>
  * Created by dyoung on 10/6/14.
  */
 @MainThread
 public interface CycledLeScanCallback {
     void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);
+
     void onCycleEnd();
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 0089b18e..e2255669 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -30,43 +30,19 @@
 public abstract class CycledLeScanner {
     public static final long ANDROID_N_MAX_SCAN_DURATION_MILLIS = 30 * 60 * 1000l; // 30 minutes
     private static final String TAG = "CycledLeScanner";
-    private BluetoothAdapter mBluetoothAdapter;
-
-    private long mLastScanCycleStartTime = 0l;
-    private long mLastScanCycleEndTime = 0l;
-    protected long mNextScanCycleStartTime = 0l;
-    private long mScanCycleStopTime = 0l;
-    // This is the last time this class actually commanded the OS
-    // to start scanning.
-    private long mCurrentScanStartTime = 0l;
-    // True if the app has explicitly requested long running scans that
-    // may go beyond what is normally allowed on Android N.
-    private boolean mLongScanForcingEnabled = false;
-    private boolean mScanning;
-    protected boolean mScanningPaused;
-    private boolean mScanCyclerStarted = false;
-    private boolean mScanningEnabled = false;
+    private static final long ANDROID_N_MIN_SCAN_CYCLE_MILLIS = 6000l;
     protected final Context mContext;
-    private long mScanPeriod;
-    // indicates that we decided not to turn scanning off at the end of a scan cycle (e.g. to
-    // avoid doing too many scans in a limited time on Android 7.0 or because we are capable of
-    // multiple detections.  If true, it indicates scanning needs to be stopped when we finish.
-    private boolean mScanningLeftOn = false;
-
-    protected long mBetweenScanPeriod;
-
     /**
      * Main thread handle for scheduling scan cycle tasks.
      * <p>
      * Use this to schedule deferred tasks such as the following:
      * <ul>
-     *     <li>{@link #scheduleScanCycleStop()}</li>
-     *     <li>{@link #scanLeDevice(Boolean) scanLeDevice(true)} from {@link #deferScanIfNeeded()}</li>
+     * <li>{@link #scheduleScanCycleStop()}</li>
+     * <li>{@link #scanLeDevice(Boolean) scanLeDevice(true)} from {@link #deferScanIfNeeded()}</li>
      * </ul>
      */
     @NonNull
     protected final Handler mHandler = new Handler(Looper.getMainLooper());
-
     /**
      * Handler to background thread for interacting with the low-level Android BLE scanner.
      * <p>
@@ -74,19 +50,36 @@
      */
     @NonNull
     protected final Handler mScanHandler;
-
+    protected final BluetoothCrashResolver mBluetoothCrashResolver;
+    protected final CycledLeScanCallback mCycledLeScanCallback;
     /**
      * Worker thread hosting the internal scanner message queue.
      */
     @NonNull
     private final HandlerThread mScanThread;
-
-    protected final BluetoothCrashResolver mBluetoothCrashResolver;
-    protected final CycledLeScanCallback mCycledLeScanCallback;
-
+    protected long mNextScanCycleStartTime = 0l;
+    protected boolean mScanningPaused;
+    protected long mBetweenScanPeriod;
     protected boolean mBackgroundFlag = false;
     protected boolean mRestartNeeded = false;
-
+    private BluetoothAdapter mBluetoothAdapter;
+    private long mLastScanCycleStartTime = 0l;
+    private long mLastScanCycleEndTime = 0l;
+    private long mScanCycleStopTime = 0l;
+    // This is the last time this class actually commanded the OS
+    // to start scanning.
+    private long mCurrentScanStartTime = 0l;
+    // True if the app has explicitly requested long running scans that
+    // may go beyond what is normally allowed on Android N.
+    private boolean mLongScanForcingEnabled = false;
+    private boolean mScanning;
+    private boolean mScanCyclerStarted = false;
+    private boolean mScanningEnabled = false;
+    private long mScanPeriod;
+    // indicates that we decided not to turn scanning off at the end of a scan cycle (e.g. to
+    // avoid doing too many scans in a limited time on Android 7.0 or because we are capable of
+    // multiple detections.  If true, it indicates scanning needs to be stopped when we finish.
+    private boolean mScanningLeftOn = false;
     /**
      * Flag indicating device hardware supports detecting multiple identical packets per scan.
      * <p>
@@ -103,7 +96,7 @@
      * also true for background scan threads which may be running concurrently.
      */
     private volatile boolean mDistinctPacketsDetectedPerScan = false;
-    private static final long ANDROID_N_MIN_SCAN_CYCLE_MILLIS = 6000l;
+    private PendingIntent mWakeUpOperation = null;
 
     protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
         mScanPeriod = scanPeriod;
@@ -130,8 +123,7 @@ public static CycledLeScanner createScanner(Context context, long scanPeriod, lo
             LogManager.i(TAG, "This is pre Android 5.0.  We are using old scanning APIs");
             useAndroidLScanner = false;
 
-        }
-        else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+        } else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
             if (BeaconManager.isAndroidLScanningDisabled()) {
                 LogManager.i(TAG, "This is Android 5.0, but L scanning is disabled. We are using old scanning APIs");
                 useAndroidLScanner = false;
@@ -139,16 +131,14 @@ else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
                 LogManager.i(TAG, "This is Android 5.0.  We are using new scanning APIs");
                 useAndroidLScanner = true;
             }
-        }
-        else {
+        } else {
             LogManager.i(TAG, "Using Android O scanner");
             useAndroidOScanner = true;
         }
 
         if (useAndroidOScanner) {
             return new CycledLeScannerForAndroidO(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
-        }
-        else if (useAndroidLScanner) {
+        } else if (useAndroidLScanner) {
             return new CycledLeScannerForLollipop(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         } else {
             return new CycledLeScannerForJellyBeanMr2(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
@@ -158,6 +148,7 @@ else if (useAndroidLScanner) {
     /**
      * Enables the scanner to go to extra lengths to keep scans going for longer than would
      * otherwise be allowed.  Useful only for Android N and higher.
+     *
      * @param enabled
      */
     public void setLongScanForcingEnabled(boolean enabled) {
@@ -168,6 +159,7 @@ public void setLongScanForcingEnabled(boolean enabled) {
      * Tells the cycler the scan rate and whether it is in operating in background mode.
      * Background mode flag  is used only with the Android 5.0 scanning implementations to switch
      * between LOW_POWER_MODE vs. LOW_LATENCY_MODE
+     *
      * @param backgroundFlag
      */
     @MainThread
@@ -330,9 +322,9 @@ protected void scanLeDevice(final Boolean enable) {
                         LogManager.e(e, TAG, "Exception starting Bluetooth scan.  Perhaps Bluetooth is disabled or unavailable?");
                     }
                 } else {
-                    LogManager.d(TAG, "We are already scanning and have been for "+(
+                    LogManager.d(TAG, "We are already scanning and have been for " + (
                             SystemClock.elapsedRealtime() - mCurrentScanStartTime
-                            )+" millis");
+                    ) + " millis");
                 }
                 mScanCycleStopTime = (SystemClock.elapsedRealtime() + mScanPeriod);
                 scheduleScanCycleStop();
@@ -351,8 +343,7 @@ protected void scanLeDevice(final Boolean enable) {
                 mHandler.removeCallbacksAndMessages(null);
                 finishScanCycle();
             }
-        }
-        catch (SecurityException e) {
+        } catch (SecurityException e) {
             LogManager.w(TAG, "SecurityException working accessing bluetooth.");
         }
     }
@@ -403,18 +394,17 @@ private void finishScanCycle() {
                                 mustStopScanToPreventAndroidNScanTimeout()) {
                             long now = SystemClock.elapsedRealtime();
                             if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
-                                    mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
-                                    now-mLastScanCycleStartTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
+                                    mBetweenScanPeriod + mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
+                                    now - mLastScanCycleStartTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
                                 // As of Android N, only 5 scans may be started in a 30 second period (6
                                 // seconds per cycle)  otherwise they are blocked.  So we check here to see
                                 // if the scan period is 6 seconds or less, and if we last stopped scanning
                                 // fewer than 6 seconds ag and if so, we simply do not stop scanning
                                 LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
-                                        " keep scanning for a minimum of 6 seconds at a time. "+
-                                        "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanCycleStartTime))+" millisconds.");
+                                        " keep scanning for a minimum of 6 seconds at a time. " +
+                                        "We will stop in " + (ANDROID_N_MIN_SCAN_CYCLE_MILLIS - (now - mLastScanCycleStartTime)) + " millisconds.");
                                 mScanningLeftOn = true;
-                            }
-                            else {
+                            } else {
                                 try {
                                     LogManager.d(TAG, "stopping bluetooth le scan");
                                     finishScan();
@@ -423,8 +413,7 @@ private void finishScanCycle() {
                                     LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
                                 }
                             }
-                        }
-                        else {
+                        } else {
                             LogManager.d(TAG, "Not stopping scanning.  Device capable of multiple indistinct detections per scan.");
                             mScanningLeftOn = true;
                         }
@@ -445,8 +434,7 @@ private void finishScanCycle() {
                 mScanCyclerStarted = false;
                 cancelWakeUpAlarm();
             }
-        }
-        catch (SecurityException e) {
+        } catch (SecurityException e) {
             LogManager.w(TAG, "SecurityException working accessing bluetooth.");
         }
     }
@@ -462,17 +450,13 @@ protected BluetoothAdapter getBluetoothAdapter() {
                     LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
                 }
             }
-        }
-        catch (SecurityException e) {
+        } catch (SecurityException e) {
             // Thrown by Samsung Knox devices if bluetooth access denied for an app
             LogManager.e(TAG, "Cannot consruct bluetooth adapter.  Security Exception");
         }
         return mBluetoothAdapter;
     }
 
-
-    private PendingIntent mWakeUpOperation = null;
-
     // In case we go into deep sleep, we will set up a wakeup alarm when in the background to kickoff
     // off the scan cycle again
     protected void setWakeUpAlarm() {
@@ -524,11 +508,11 @@ private long getNextScanStartTime() {
             return SystemClock.elapsedRealtime();
         }
         long fullScanCycle = mScanPeriod + mBetweenScanPeriod;
-        long normalizedBetweenScanPeriod = mBetweenScanPeriod-(SystemClock.elapsedRealtime() % fullScanCycle);
+        long normalizedBetweenScanPeriod = mBetweenScanPeriod - (SystemClock.elapsedRealtime() % fullScanCycle);
         LogManager.d(TAG, "Normalizing between scan period from %s to %s", mBetweenScanPeriod,
                 normalizedBetweenScanPeriod);
 
-        return SystemClock.elapsedRealtime()+normalizedBetweenScanPeriod;
+        return SystemClock.elapsedRealtime() + normalizedBetweenScanPeriod;
     }
 
     private boolean checkLocationPermission() {
@@ -544,13 +528,14 @@ private boolean checkPermission(final String permission) {
      * stopped by the OS and converted to an "opportunistic" scan, meaning that they will only yield
      * detections if another app is scanning.  This is inteneded to save battery.  This can be
      * prevented by stopping scanning and restarting.  This method returns true if:
-     *   * this is Android N or later
-     *   * we are close to the 30 minute boundary since the last scan started
-     *   * The app developer has explicitly enabled long-running scans
+     * * this is Android N or later
+     * * we are close to the 30 minute boundary since the last scan started
+     * * The app developer has explicitly enabled long-running scans
+     *
      * @return true if we must stop scanning to prevent
      */
     private boolean mustStopScanToPreventAndroidNScanTimeout() {
-        long timeOfNextScanCycleEnd = SystemClock.elapsedRealtime() +  mBetweenScanPeriod +
+        long timeOfNextScanCycleEnd = SystemClock.elapsedRealtime() + mBetweenScanPeriod +
                 mScanPeriod;
         boolean timeoutAtRisk = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
                 mCurrentScanStartTime > 0 &&
@@ -558,11 +543,10 @@ private boolean mustStopScanToPreventAndroidNScanTimeout() {
 
         if (timeoutAtRisk) {
             LogManager.d(TAG, "The next scan cycle would go over the Android N max duration.");
-            if  (mLongScanForcingEnabled) {
+            if (mLongScanForcingEnabled) {
                 LogManager.d(TAG, "Stopping scan to prevent Android N scan timeout.");
                 return true;
-            }
-            else {
+            } else {
                 LogManager.w(TAG, "Allowing a long running scan to be stopped by the OS.  To " +
                         "prevent this, set longScanForcingEnabled in the AndroidBeaconLibrary.");
             }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
index fe095400..0b33d9fb 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
@@ -2,7 +2,9 @@
 
 import android.annotation.TargetApi;
 import android.content.Context;
+
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
+
 import java.util.Set;
 
 /**
@@ -14,7 +16,7 @@
  *
  * @see org.altbeacon.beacon.service.ScanJob
  * @see org.altbeacon.beacon.service.ScanHelper#startAndroidOBackgroundScan(Set)
- *
+ * <p>
  * Created by dyoung on 5/28/17.
  */
 
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index acac9d9e..95134d10 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -21,7 +21,6 @@
 import org.altbeacon.beacon.service.DetectionTracker;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
-import java.security.Security;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -29,12 +28,12 @@
 public class CycledLeScannerForLollipop extends CycledLeScanner {
     private static final String TAG = "CycledLeScannerForLollipop";
     private static final long BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS = 10000l;
+    private final BeaconManager mBeaconManager;
     private BluetoothLeScanner mScanner;
     private ScanCallback leScanCallback;
     private long mBackgroundLScanStartTime = 0l;
     private long mBackgroundLScanFirstDetectionTime = 0;
     private boolean mMainScanCycleActive = false;
-    private final BeaconManager mBeaconManager;
 
     public CycledLeScannerForLollipop(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
         super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
@@ -102,8 +101,7 @@ protected boolean deferScanIfNeeded() {
                     // error on Android N.
                     if (mBetweenScanPeriod > 6000l) {
                         startScan();
-                    }
-                    else {
+                    } else {
                         LogManager.d(TAG, "Suppressing scan between cycles because the between scan cycle is too short.");
                     }
 
@@ -112,7 +110,7 @@ protected boolean deferScanIfNeeded() {
                     // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
                     // This API is now available in Android M
                     LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
-                            + "ago, so we will not keep scanning in background.",
+                                    + "ago, so we will not keep scanning in background.",
                             secsSinceLastDetection);
                 }
             }
@@ -130,8 +128,7 @@ protected boolean deferScanIfNeeded() {
                         LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
                         stopScan();
                         mBackgroundLScanStartTime = 0l;
-                    }
-                    else {
+                    } else {
                         // report the results up the chain
                         LogManager.d(TAG, "Delivering Android L background scanning results");
                         mCycledLeScanCallback.onCycleEnd();
@@ -175,7 +172,7 @@ protected void startScan() {
             LogManager.d(TAG, "starting filtered scan in SCAN_MODE_LOW_POWER");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
             filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
-                          mBeaconManager.getBeaconParsers());
+                    mBeaconManager.getBeaconParsers());
         } else {
             LogManager.d(TAG, "starting a scan in SCAN_MODE_LOW_LATENCY");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)).build();
@@ -195,14 +192,12 @@ protected void startScan() {
                     LogManager.d(TAG, "Using a non-empty scan filter since this is Samsung 8.1+");
                     filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
                             mBeaconManager.getBeaconParsers());
-                }
-                else {
+                } else {
                     LogManager.d(TAG, "Using an empty scan filter since this is 8.1+ on Non-Samsung");
                     // The wildcard filter matches everything.
                     filters = new ScanFilterUtils().createWildcardScanFilters();
                 }
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "Using no scan filter since this is pre-8.1");
             }
         }
@@ -247,7 +242,7 @@ public void run() {
     }
 
     private void postStopLeScan() {
-        if (!isBluetoothOn()){
+        if (!isBluetoothOn()) {
             LogManager.d(TAG, "Not stopping scan because bluetooth is off");
             return;
         }
@@ -285,8 +280,7 @@ private boolean isBluetoothOn() {
                 return (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON);
             }
             LogManager.w(TAG, "Cannot get bluetooth adapter");
-        }
-        catch (SecurityException e) {
+        } catch (SecurityException e) {
             LogManager.w(TAG, "SecurityException checking if bluetooth is on");
         }
         return false;
@@ -304,8 +298,7 @@ private BluetoothLeScanner getScanner() {
                     LogManager.w(TAG, "Failed to make new Android L scanner");
                 }
             }
-        }
-        catch (SecurityException e) {
+        } catch (SecurityException e) {
             LogManager.w(TAG, "SecurityException making new Android L scanner");
         }
         return mScanner;
@@ -322,7 +315,7 @@ public void onScanResult(int callbackType, ScanResult scanResult) {
                         List<ParcelUuid> uuids = scanResult.getScanRecord().getServiceUuids();
                         if (uuids != null) {
                             for (ParcelUuid uuid : uuids) {
-                                LogManager.d(TAG, "with service uuid: "+uuid);
+                                LogManager.d(TAG, "with service uuid: " + uuid);
                             }
                         }
                     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
index daff6763..13436d59 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
@@ -30,15 +30,14 @@ public void clearDetections() {
 
     public boolean isPacketDistinct(@NonNull String originMacAddress, @NonNull byte[] scanRecord) {
         byte[] macBytes = originMacAddress.getBytes();
-        ByteBuffer buffer = ByteBuffer.allocate(macBytes.length+scanRecord.length);
+        ByteBuffer buffer = ByteBuffer.allocate(macBytes.length + scanRecord.length);
         buffer.put(macBytes);
         buffer.put(scanRecord);
         buffer.rewind(); // rewind puts position back to beginning so .equals and .hashCode work
 
         if (mDistinctPacketsDetected.size() == MAX_PACKETS_TO_TRACK) {
             return mDistinctPacketsDetected.contains(buffer);
-        }
-        else {
+        } else {
             return mDistinctPacketsDetected.add(buffer);
         }
     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
index 15aeda1e..d2ecbdb2 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
@@ -29,9 +29,9 @@
     /**
      * NOTE: This method is NOT called on the main UI thread.
      *
-     * @param device Identifies the remote device
-     * @param rssi The RSSI value for the remote device as reported by the
-     *             Bluetooth hardware. 0 if no RSSI value is available.
+     * @param device     Identifies the remote device
+     * @param rssi       The RSSI value for the remote device as reported by the
+     *                   Bluetooth hardware. 0 if no RSSI value is available.
      * @param scanRecord The content of the advertisement record offered by
      *                   the remote device.
      */
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
index dab1925f..522f9379 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
@@ -1,10 +1,7 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.annotation.TargetApi;
-import android.bluetooth.BluetoothDevice;
 import android.bluetooth.le.ScanFilter;
-import android.bluetooth.le.ScanRecord;
-import android.bluetooth.le.ScanResult;
 import android.os.ParcelUuid;
 
 import org.altbeacon.beacon.BeaconParser;
@@ -19,12 +16,6 @@
 @TargetApi(21)
 public class ScanFilterUtils {
     public static final String TAG = "ScanFilterUtils";
-    class ScanFilterData {
-        public Long serviceUuid = null;
-        public int manufacturer;
-        public byte[] filter;
-        public byte[] mask;
-    }
 
     public List<ScanFilter> createWildcardScanFilters() {
         List<ScanFilter> scanFilters = new ArrayList<ScanFilter>();
@@ -46,14 +37,14 @@
             // from the start of the two byte code
             byte[] filter = new byte[endOffset + 1 - 2];
             byte[] mask = new byte[endOffset + 1 - 2];
-            byte[] typeCodeBytes = BeaconParser.longToByteArray(typeCode, endOffset-startOffset+1);
+            byte[] typeCodeBytes = BeaconParser.longToByteArray(typeCode, endOffset - startOffset + 1);
             for (int layoutIndex = 2; layoutIndex <= endOffset; layoutIndex++) {
-                int filterIndex = layoutIndex-2;
+                int filterIndex = layoutIndex - 2;
                 if (layoutIndex < startOffset) {
                     filter[filterIndex] = 0;
                     mask[filterIndex] = 0;
                 } else {
-                    filter[filterIndex] = typeCodeBytes[layoutIndex-startOffset];
+                    filter[filterIndex] = typeCodeBytes[layoutIndex - startOffset];
                     mask[filterIndex] = (byte) 0xff;
                 }
             }
@@ -72,9 +63,9 @@
         List<ScanFilter> scanFilters = new ArrayList<ScanFilter>();
         // for each beacon parser, make a filter expression that includes all its desired
         // hardware manufacturers
-        for (BeaconParser beaconParser: beaconParsers) {
+        for (BeaconParser beaconParser : beaconParsers) {
             List<ScanFilterData> sfds = createScanFilterDataForBeaconParser(beaconParser);
-            for (ScanFilterData sfd: sfds) {
+            for (ScanFilterData sfd : sfds) {
                 ScanFilter.Builder builder = new ScanFilter.Builder();
                 if (sfd.serviceUuid != null) {
                     // Use a 16 bit service UUID in a 128 bit form
@@ -83,18 +74,17 @@
                     ParcelUuid parcelUuid = ParcelUuid.fromString(serviceUuidString);
                     ParcelUuid parcelUuidMask = ParcelUuid.fromString(serviceUuidMaskString);
                     if (LogManager.isVerboseLoggingEnabled()) {
-                        LogManager.d(TAG, "making scan filter for service: "+serviceUuidString+" "+parcelUuid);
-                        LogManager.d(TAG, "making scan filter with service mask: "+serviceUuidMaskString+" "+parcelUuidMask);
+                        LogManager.d(TAG, "making scan filter for service: " + serviceUuidString + " " + parcelUuid);
+                        LogManager.d(TAG, "making scan filter with service mask: " + serviceUuidMaskString + " " + parcelUuidMask);
                     }
                     builder.setServiceUuid(parcelUuid, parcelUuidMask);
-                }
-                else {
+                } else {
                     builder.setServiceUuid(null);
                     builder.setManufacturerData((int) sfd.manufacturer, sfd.filter, sfd.mask);
                 }
                 ScanFilter scanFilter = builder.build();
                 if (LogManager.isVerboseLoggingEnabled()) {
-                    LogManager.d(TAG, "Set up a scan filter: "+scanFilter);
+                    LogManager.d(TAG, "Set up a scan filter: " + scanFilter);
                 }
                 scanFilters.add(scanFilter);
             }
@@ -102,4 +92,11 @@
         return scanFilters;
     }
 
+    class ScanFilterData {
+        public Long serviceUuid = null;
+        public int manufacturer;
+        public byte[] filter;
+        public byte[] mask;
+    }
+
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/simulator/StaticBeaconSimulator.java b/lib/src/main/java/org/altbeacon/beacon/simulator/StaticBeaconSimulator.java
index 0c6f735e..61ba2aa7 100644
--- a/lib/src/main/java/org/altbeacon/beacon/simulator/StaticBeaconSimulator.java
+++ b/lib/src/main/java/org/altbeacon/beacon/simulator/StaticBeaconSimulator.java
@@ -15,6 +15,7 @@
     public List<Beacon> getBeacons() {
         return beacons;
     }
+
     public void setBeacons(List<Beacon> beacons) {
         this.beacons = beacons;
     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/startup/RegionBootstrap.java b/lib/src/main/java/org/altbeacon/beacon/startup/RegionBootstrap.java
index 6dc42d51..980d38d7 100644
--- a/lib/src/main/java/org/altbeacon/beacon/startup/RegionBootstrap.java
+++ b/lib/src/main/java/org/altbeacon/beacon/startup/RegionBootstrap.java
@@ -19,10 +19,10 @@
  * to start on Android device startup.  If a matching beacon is detected, the BootstrapNotifier
  * didEnterRegion method will be called, allowing the application to launch an Activity, send a
  * local notification, or perform any other action desired.
- *
+ * <p>
  * Using this class as described above will also cause beacon scanning to start back up after power
  * is connected or disconnected from a device if the user has force terminated the app.
- *
+ * <p>
  * IMPORTANT NOTE:  The RegionBootstrap class registers an internal MonitorNotifier with the
  * BeaconManager.  If you use the RegionBootstrap, your application must not manually register
  * a second MonitorNotifier, otherwise it will unregister the one configured by the RegionBootstrap,
@@ -61,6 +61,7 @@ public RegionBootstrap(BootstrapNotifier application, Region region) {
 
     /**
      * Constructor to bootstrap your Application on an entry/exit from multiple regions
+     *
      * @param application
      * @param regions
      */
@@ -110,7 +111,7 @@ public void addRegion(Region region) {
                 } catch (RemoteException e) {
                     LogManager.e(e, TAG, "Can't add bootstrap region");
                 }
-            }else{
+            } else {
                 LogManager.w(TAG, "Adding a region: service not yet Connected");
             }
             regions.add(region);
@@ -130,7 +131,7 @@ public void removeRegion(Region region) {
                 } catch (RemoteException e) {
                     LogManager.e(e, TAG, "Can't stop bootstrap region");
                 }
-            }else{
+            } else {
                 LogManager.w(TAG, "Removing a region: service not yet Connected");
             }
             regions.remove(region);
diff --git a/lib/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java b/lib/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
index 0a041fe0..8de11ce3 100644
--- a/lib/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
+++ b/lib/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
@@ -1,25 +1,18 @@
 package org.altbeacon.beacon.startup;
 
 import android.bluetooth.le.BluetoothLeScanner;
-import android.bluetooth.le.ScanCallback;
 import android.bluetooth.le.ScanResult;
-import android.bluetooth.le.ScanSettings;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Bundle;
-import android.os.Parcel;
-import android.os.Parcelable;
 
-import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.BeaconManager;
-import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.ScanJobScheduler;
 
 import java.util.ArrayList;
 
-public class StartupBroadcastReceiver extends BroadcastReceiver
-{
+public class StartupBroadcastReceiver extends BroadcastReceiver {
     private static final String TAG = "StartupBroadcastReceiver";
 
     @Override
@@ -33,25 +26,22 @@ public void onReceive(Context context, Intent intent) {
         if (beaconManager.isAnyConsumerBound() || beaconManager.getScheduledScanJobsEnabled()) {
             int bleCallbackType = intent.getIntExtra(BluetoothLeScanner.EXTRA_CALLBACK_TYPE, -1); // e.g. ScanSettings.CALLBACK_TYPE_FIRST_MATCH
             if (bleCallbackType != -1) {
-                LogManager.d(TAG, "Passive background scan callback type: "+bleCallbackType);
+                LogManager.d(TAG, "Passive background scan callback type: " + bleCallbackType);
                 LogManager.d(TAG, "got Android O background scan via intent");
                 int errorCode = intent.getIntExtra(BluetoothLeScanner.EXTRA_ERROR_CODE, -1); // e.g.  ScanCallback.SCAN_FAILED_INTERNAL_ERROR
                 if (errorCode != -1) {
-                    LogManager.w(TAG, "Passive background scan failed.  Code; "+errorCode);
+                    LogManager.w(TAG, "Passive background scan failed.  Code; " + errorCode);
                 }
                 ArrayList<ScanResult> scanResults = intent.getParcelableArrayListExtra(BluetoothLeScanner.EXTRA_LIST_SCAN_RESULT);
                 ScanJobScheduler.getInstance().scheduleAfterBackgroundWakeup(context, scanResults);
-            }
-            else if (intent.getBooleanExtra("wakeup", false)) {
+            } else if (intent.getBooleanExtra("wakeup", false)) {
                 LogManager.d(TAG, "got wake up intent");
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "Already started.  Ignoring intent: %s of type: %s", intent,
                         intent.getStringExtra("wakeup"));
             }
-        }
-        else {
+        } else {
             LogManager.d(TAG, "No consumers are bound.  Ignoring broadcast receiver.");
         }
-     }
+    }
 }
diff --git a/lib/src/main/java/org/altbeacon/beacon/utils/EddystoneTelemetryAccessor.java b/lib/src/main/java/org/altbeacon/beacon/utils/EddystoneTelemetryAccessor.java
index e9b1f259..f3c634d3 100644
--- a/lib/src/main/java/org/altbeacon/beacon/utils/EddystoneTelemetryAccessor.java
+++ b/lib/src/main/java/org/altbeacon/beacon/utils/EddystoneTelemetryAccessor.java
@@ -14,9 +14,11 @@
  */
 public class EddystoneTelemetryAccessor {
     private static final String TAG = "EddystoneTLMAccessor";
+
     /**
      * Extracts the raw Eddystone telemetry bytes from the extra data fields of an associated beacon.
      * This is useful for passing the telemetry to Google's backend services.
+     *
      * @param beacon
      * @return the bytes of the telemetry frame
      */
@@ -30,8 +32,7 @@
             byte[] telemetryBytes = telemetryParser.getBeaconAdvertisementData(telemetryBeacon);
             Log.d(TAG, "Rehydrated telemetry bytes are :" + byteArrayToString(telemetryBytes));
             return telemetryBytes;
-        }
-        else {
+        } else {
             return null;
         }
     }
@@ -40,6 +41,7 @@
      * Extracts the raw Eddystone telemetry bytes from the extra data fields of an associated beacon
      * and base64 encodes them.  This is useful for passing the telemetry to Google's backend
      * services.
+     *
      * @param beacon
      * @return base64 encoded telemetry bytes
      */
@@ -50,10 +52,9 @@ public String getBase64EncodedTelemetry(Beacon beacon) {
             String base64EncodedTelemetry = Base64.encodeToString(bytes, Base64.DEFAULT);
             // 12-21 00:17:18.844 20180-20180/? D/EddystoneTLMAccessor: Rehydrated telemetry bytes are :20 00 00 00 88 29 18 4d 00 00 18 4d 00 00
             // 12-21 00:17:18.844 20180-20180/? D/EddystoneTLMAccessor: Base64 telemetry bytes are :IAAAAIgpGE0AABhNAAA=
-            Log.d(TAG, "Base64 telemetry bytes are :"+base64EncodedTelemetry);
+            Log.d(TAG, "Base64 telemetry bytes are :" + base64EncodedTelemetry);
             return base64EncodedTelemetry;
-        }
-        else {
+        } else {
             return null;
         }
     }
diff --git a/lib/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java b/lib/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
index 7cf0959c..bdf094f7 100644
--- a/lib/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
+++ b/lib/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
@@ -8,8 +8,9 @@
 
 /**
  * Created by dyoung on 3/10/17.
- *
+ * <p>
  * Internal class used to determine current process state in multi-process setups
+ *
  * @hide
  */
 
@@ -26,7 +27,7 @@ public String getProcessName() {
         if (processes != null) {
             for (ActivityManager.RunningAppProcessInfo processInfo : processes) {
                 if (processInfo.pid == getPid()) {
-                    return  processInfo.processName;
+                    return processInfo.processName;
                 }
             }
         }
diff --git a/lib/src/main/java/org/altbeacon/beacon/utils/UrlBeaconUrlCompressor.java b/lib/src/main/java/org/altbeacon/beacon/utils/UrlBeaconUrlCompressor.java
index db074293..271766b0 100644
--- a/lib/src/main/java/org/altbeacon/beacon/utils/UrlBeaconUrlCompressor.java
+++ b/lib/src/main/java/org/altbeacon/beacon/utils/UrlBeaconUrlCompressor.java
@@ -11,95 +11,85 @@
 /**
  * Provides encoding / decoding functions for the URL beacon https://github.com/google/uribeacon
  */
-public class UrlBeaconUrlCompressor  {
+public class UrlBeaconUrlCompressor {
 
     private static final String EDDYSTONE_URL_REGEX = "^((?i)http|https):\\/\\/((?i)www\\.)?((?:[0-9a-zA-Z_-]+\\.?)+)(/?)([./0-9a-zA-Z_-]*)"; // Break into components
     private static final int EDDYSTONE_URL_PROTOCOL_GROUP = 1;
-    private static final int EDDYSTONE_URL_WWW_GROUP      = 2;
-    private static final int EDDYSTONE_URL_FQDN_GROUP     = 3;
-    private static final int EDDYSTONE_URL_SLASH_GROUP      = 4;
-    private static final int EDDYSTONE_URL_PATH_GROUP     = 5;
+    private static final int EDDYSTONE_URL_WWW_GROUP = 2;
+    private static final int EDDYSTONE_URL_FQDN_GROUP = 3;
+    private static final int EDDYSTONE_URL_SLASH_GROUP = 4;
+    private static final int EDDYSTONE_URL_PATH_GROUP = 5;
 
-    private static final String URL_PROTOCOL_HTTP_WWW_DOT  = "http://www.";
+    private static final String URL_PROTOCOL_HTTP_WWW_DOT = "http://www.";
     private static final String URL_PROTOCOL_HTTPS_WWW_DOT = "https://www.";
-    private static final String URL_PROTOCOL_HTTP  = "http";
-    private static final String URL_PROTOCOL_HTTP_COLON_SLASH_SLASH  = "http://";
+    private static final String URL_PROTOCOL_HTTP = "http";
+    private static final String URL_PROTOCOL_HTTP_COLON_SLASH_SLASH = "http://";
     private static final String URL_PROTOCOL_HTTPS_COLON_SLASH_SLASH = "https://";
     private static final String URL_HOST_WWW = "www.";
-    private static final String URL_TLD_DOT_COM =  ".com";
-    private static final String URL_TLD_DOT_ORG =  ".org";
-    private static final String URL_TLD_DOT_EDU =  ".edu";
-    private static final String URL_TLD_DOT_NET =  ".net";
+    private static final String URL_TLD_DOT_COM = ".com";
+    private static final String URL_TLD_DOT_ORG = ".org";
+    private static final String URL_TLD_DOT_EDU = ".edu";
+    private static final String URL_TLD_DOT_NET = ".net";
     private static final String URL_TLD_DOT_INFO = ".info";
-    private static final String URL_TLD_DOT_BIZ =  ".biz";
-    private static final String URL_TLD_DOT_GOV =  ".gov";
-    private static final String URL_TLD_DOT_COM_SLASH =  ".com/";
-    private static final String URL_TLD_DOT_ORG_SLASH =  ".org/";
-    private static final String URL_TLD_DOT_EDU_SLASH =  ".edu/";
-    private static final String URL_TLD_DOT_NET_SLASH =  ".net/";
+    private static final String URL_TLD_DOT_BIZ = ".biz";
+    private static final String URL_TLD_DOT_GOV = ".gov";
+    private static final String URL_TLD_DOT_COM_SLASH = ".com/";
+    private static final String URL_TLD_DOT_ORG_SLASH = ".org/";
+    private static final String URL_TLD_DOT_EDU_SLASH = ".edu/";
+    private static final String URL_TLD_DOT_NET_SLASH = ".net/";
     private static final String URL_TLD_DOT_INFO_SLASH = ".info/";
-    private static final String URL_TLD_DOT_BIZ_SLASH =  ".biz/";
-    private static final String URL_TLD_DOT_GOV_SLASH =  ".gov/";
+    private static final String URL_TLD_DOT_BIZ_SLASH = ".biz/";
+    private static final String URL_TLD_DOT_GOV_SLASH = ".gov/";
 
-    private static final byte EDDYSTONE_URL_PROTOCOL_HTTP_WWW  = 0x00;
+    private static final byte EDDYSTONE_URL_PROTOCOL_HTTP_WWW = 0x00;
     private static final byte EDDYSTONE_URL_PROTOCOL_HTTPS_WWW = 0x01;
-    private static final byte EDDYSTONE_URL_PROTOCOL_HTTP      = 0x02;
-    private static final byte EDDYSTONE_URL_PROTOCOL_HTTPS     = 0x03;
+    private static final byte EDDYSTONE_URL_PROTOCOL_HTTP = 0x02;
+    private static final byte EDDYSTONE_URL_PROTOCOL_HTTPS = 0x03;
 
-    private static final byte EDDYSTONE_URL_COM_SLASH  = 0x00;
-    private static final byte EDDYSTONE_URL_ORG_SLASH  = 0x01;
-    private static final byte EDDYSTONE_URL_EDU_SLASH  = 0x02;
-    private static final byte EDDYSTONE_URL_NET_SLASH  = 0x03;
+    private static final byte EDDYSTONE_URL_COM_SLASH = 0x00;
+    private static final byte EDDYSTONE_URL_ORG_SLASH = 0x01;
+    private static final byte EDDYSTONE_URL_EDU_SLASH = 0x02;
+    private static final byte EDDYSTONE_URL_NET_SLASH = 0x03;
     private static final byte EDDYSTONE_URL_INFO_SLASH = 0x04;
-    private static final byte EDDYSTONE_URL_BIZ_SLASH  = 0x05;
-    private static final byte EDDYSTONE_URL_GOV_SLASH  = 0x06;
-    private static final byte EDDYSTONE_URL_COM        = 0x07;
-    private static final byte EDDYSTONE_URL_ORG        = 0x08;
-    private static final byte EDDYSTONE_URL_EDU        = 0x09;
-    private static final byte EDDYSTONE_URL_NET        = 0x0a;
-    private static final byte EDDYSTONE_URL_INFO       = 0x0b;
-    private static final byte EDDYSTONE_URL_BIZ        = 0x0c;
-    private static final byte EDDYSTONE_URL_GOV        = 0x0d;
+    private static final byte EDDYSTONE_URL_BIZ_SLASH = 0x05;
+    private static final byte EDDYSTONE_URL_GOV_SLASH = 0x06;
+    private static final byte EDDYSTONE_URL_COM = 0x07;
+    private static final byte EDDYSTONE_URL_ORG = 0x08;
+    private static final byte EDDYSTONE_URL_EDU = 0x09;
+    private static final byte EDDYSTONE_URL_NET = 0x0a;
+    private static final byte EDDYSTONE_URL_INFO = 0x0b;
+    private static final byte EDDYSTONE_URL_BIZ = 0x0c;
+    private static final byte EDDYSTONE_URL_GOV = 0x0d;
 
-    private static final byte TLD_NOT_ENCODABLE        = (byte) 0xff;
+    private static final byte TLD_NOT_ENCODABLE = (byte) 0xff;
 
     // Maps from the top level domains (with or without trailing slash)
     // to the associated encoded byte.
-
-    private static class TLDMapEntry {
-        public final String tld;
-        public final byte encodedByte;
-
-        public TLDMapEntry(String topLevelDomain, byte encodedTLDByte) {
-            tld = topLevelDomain;
-            encodedByte = encodedTLDByte;
-        }
-    }
-
     private static List<TLDMapEntry> tldMap;
+
     static {
         tldMap = new ArrayList<>();
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_COM_SLASH , EDDYSTONE_URL_COM_SLASH ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_ORG_SLASH , EDDYSTONE_URL_ORG_SLASH ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_EDU_SLASH , EDDYSTONE_URL_EDU_SLASH ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_NET_SLASH , EDDYSTONE_URL_NET_SLASH ));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_COM_SLASH, EDDYSTONE_URL_COM_SLASH));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_ORG_SLASH, EDDYSTONE_URL_ORG_SLASH));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_EDU_SLASH, EDDYSTONE_URL_EDU_SLASH));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_NET_SLASH, EDDYSTONE_URL_NET_SLASH));
         tldMap.add(new TLDMapEntry(URL_TLD_DOT_INFO_SLASH, EDDYSTONE_URL_INFO_SLASH));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_BIZ_SLASH , EDDYSTONE_URL_BIZ_SLASH ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_GOV_SLASH , EDDYSTONE_URL_GOV_SLASH ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_COM       , EDDYSTONE_URL_COM       ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_ORG       , EDDYSTONE_URL_ORG       ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_EDU       , EDDYSTONE_URL_EDU       ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_NET       , EDDYSTONE_URL_NET       ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_INFO      , EDDYSTONE_URL_INFO      ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_BIZ       , EDDYSTONE_URL_BIZ       ));
-        tldMap.add(new TLDMapEntry(URL_TLD_DOT_GOV       , EDDYSTONE_URL_GOV       ));
-    };
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_BIZ_SLASH, EDDYSTONE_URL_BIZ_SLASH));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_GOV_SLASH, EDDYSTONE_URL_GOV_SLASH));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_COM, EDDYSTONE_URL_COM));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_ORG, EDDYSTONE_URL_ORG));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_EDU, EDDYSTONE_URL_EDU));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_NET, EDDYSTONE_URL_NET));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_INFO, EDDYSTONE_URL_INFO));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_BIZ, EDDYSTONE_URL_BIZ));
+        tldMap.add(new TLDMapEntry(URL_TLD_DOT_GOV, EDDYSTONE_URL_GOV));
+    }
 
     private static byte encodedByteForTopLevelDomain(String tld) {
         byte encodedByte = TLD_NOT_ENCODABLE;
         boolean tldFound = false;
         Iterator<TLDMapEntry> iterator = tldMap.iterator();
-        while (! tldFound && iterator.hasNext()) {
+        while (!tldFound && iterator.hasNext()) {
             TLDMapEntry entry = iterator.next();
             tldFound = entry.tld.equalsIgnoreCase(tld);
             if (tldFound) {
@@ -109,11 +99,13 @@ private static byte encodedByteForTopLevelDomain(String tld) {
         return encodedByte;
     }
 
+    ;
+
     private static String topLevelDomainForByte(Byte encodedByte) {
         String tld = null;
         boolean tldFound = false;
         Iterator<TLDMapEntry> iterator = tldMap.iterator();
-        while (! tldFound && iterator.hasNext()) {
+        while (!tldFound && iterator.hasNext()) {
             TLDMapEntry entry = iterator.next();
             tldFound = entry.encodedByte == encodedByte;
             if (tldFound) {
@@ -125,17 +117,17 @@ private static String topLevelDomainForByte(Byte encodedByte) {
 
     /**
      * Converts the given URL string into a byte array "compressed" version of the URL.
-     *
+     * <p>
      * The regex needs to determine what the URL starts with and what the hostname ends
      * with.  The URL must start with one of the following:
-     *
+     * <p>
      * http://www.
      * https://www.
      * http://
      * https://
-     *
+     * <p>
      * The hostname may end with one of the following TLDs:
-     *
+     * <p>
      * .com
      * .org
      * .edu
@@ -143,18 +135,18 @@ private static String topLevelDomainForByte(Byte encodedByte) {
      * .info
      * .biz
      * .gov
-     *
+     * <p>
      * If the path component of the URL is non-empty, then the "slash" version of
      * the matching TLD can be used.  Otherwise, the "non-slash" version of the TLD is used.
      * If the hostname doesn't end with a TLD, that's fine; it just isn't compressed
      * into a single byte.
-     *
+     * <p>
      * Therefore, the following regex should tell me what I need to know about the URL:
-     *
+     * <p>
      * ^(http|https):\/\/(www.)?((?:[0-9a-z_-]+\.??)+)(\.[0-9a-z_-]+\/?)(.*)$
-     *
+     * <p>
      * Groups:
-     *
+     * <p>
      * 1: http or https
      * 2: www. or empty
      * 3: hostname including optional leading www. but excluding trailing dot up to but not including TLD
@@ -184,8 +176,7 @@ private static String topLevelDomainForByte(Byte encodedByte) {
                 String protocol = rawProtocol.toLowerCase();
                 if (protocol.equalsIgnoreCase(URL_PROTOCOL_HTTP)) {
                     byteBuffer[byteBufferIndex] = (haswww ? EDDYSTONE_URL_PROTOCOL_HTTP_WWW : EDDYSTONE_URL_PROTOCOL_HTTP);
-                }
-                else {
+                } else {
                     byteBuffer[byteBufferIndex] = (haswww ? EDDYSTONE_URL_PROTOCOL_HTTPS_WWW : EDDYSTONE_URL_PROTOCOL_HTTPS);
                 }
                 byteBufferIndex++;
@@ -235,7 +226,7 @@ private static String topLevelDomainForByte(Byte encodedByte) {
                 }
 
                 // Optional slash.
-                if (! consumedSlash) {
+                if (!consumedSlash) {
                     String slash = urlMatcher.group(EDDYSTONE_URL_SLASH_GROUP);
                     if (slash != null) {
                         int slashLength = slash.length();
@@ -247,7 +238,7 @@ private static String topLevelDomainForByte(Byte encodedByte) {
                 // Path.
                 String path = urlMatcher.group(EDDYSTONE_URL_PATH_GROUP);
                 if (path != null) {
-                    int pathLength =  path.length();
+                    int pathLength = path.length();
                     System.arraycopy(path.getBytes(), 0, byteBuffer, byteBufferIndex, pathLength);
                     byteBufferIndex += pathLength;
                 }
@@ -255,12 +246,10 @@ private static String topLevelDomainForByte(Byte encodedByte) {
                 // Copy the result.
                 compressedBytes = new byte[byteBufferIndex];
                 System.arraycopy(byteBuffer, 0, compressedBytes, 0, compressedBytes.length);
-            }
-            else {
+            } else {
                 throw new MalformedURLException();
             }
-        }
-        else {
+        } else {
             throw new MalformedURLException();
         }
         return compressedBytes;
@@ -287,19 +276,28 @@ public static String uncompress(byte[] compressedURL) {
         byte lastByte = -1;
         for (int i = 1; i < compressedURL.length; i++) {
             byte b = compressedURL[i];
-            if (lastByte == 0 && b == 0 ) {
+            if (lastByte == 0 && b == 0) {
                 break;
             }
             lastByte = b;
             String tld = topLevelDomainForByte(b);
             if (tld != null) {
                 url.append(tld);
-            }
-            else {
+            } else {
                 url.append((char) b);
             }
         }
 
         return url.toString();
     }
+
+    private static class TLDMapEntry {
+        public final String tld;
+        public final byte encodedByte;
+
+        public TLDMapEntry(String topLevelDomain, byte encodedTLDByte) {
+            tld = topLevelDomain;
+            encodedByte = encodedTLDByte;
+        }
+    }
 }
\ No newline at end of file
diff --git a/lib/src/main/java/org/altbeacon/bluetooth/BleAdvertisement.java b/lib/src/main/java/org/altbeacon/bluetooth/BleAdvertisement.java
index 25902dcd..592123af 100644
--- a/lib/src/main/java/org/altbeacon/bluetooth/BleAdvertisement.java
+++ b/lib/src/main/java/org/altbeacon/bluetooth/BleAdvertisement.java
@@ -1,24 +1,24 @@
 package org.altbeacon.bluetooth;
 
-import android.util.Log;
-
 import java.util.ArrayList;
 import java.util.List;
 
 /**
  * Parses a byte array representing a BLE advertisement into
  * a number of "Payload Data Units" (PDUs).
- *
+ * <p>
  * Created by dyoung on 4/14/15.
  */
 public class BleAdvertisement {
     private static final String TAG = "BleAdvertisement";
     private List<Pdu> mPdus;
     private byte[] mBytes;
+
     public BleAdvertisement(byte[] bytes) {
         mBytes = bytes;
         mPdus = parsePdus();
     }
+
     private List<Pdu> parsePdus() {
         ArrayList<Pdu> pdus = new ArrayList<Pdu>();
         Pdu pdu = null;
@@ -26,7 +26,7 @@ public BleAdvertisement(byte[] bytes) {
         do {
             pdu = Pdu.parse(mBytes, index);
             if (pdu != null) {
-                index = index + pdu.getDeclaredLength()+1;
+                index = index + pdu.getDeclaredLength() + 1;
                 pdus.add(pdu);
             }
         }
@@ -37,6 +37,7 @@ public BleAdvertisement(byte[] bytes) {
 
     /**
      * The list of PDUs inside the advertisement
+     *
      * @return
      */
     public List<Pdu> getPdus() {
diff --git a/lib/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java b/lib/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
index 195a770a..04c1b7db 100644
--- a/lib/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
+++ b/lib/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
@@ -21,22 +21,21 @@
 import java.util.Set;
 
 /**
- *
  * This class provides relief for Android Bug 67272.  This bug in the Bluedroid stack causes crashes
  * in Android's BluetoothService when scanning for BLE devices encounters a large number of unique
  * devices.  It is rare for most users but can be problematic for those with apps scanning for
  * Bluetooth LE devices in the background (e.g. beacon-enabled apps), especially when these users
  * are around Bluetooth LE devices that randomize their mac address like Gimbal beacons.
- *
+ * <p>
  * This class can both recover from crashes and prevent crashes from happening in the first place.
- *
+ * <p>
  * More details on the bug can be found at the following URLs:
- *
+ * <p>
  * https://code.google.com/p/android/issues/detail?id=67272
  * https://github.com/RadiusNetworks/android-ibeacon-service/issues/16
- *
+ * <p>
  * Version 1.0
- *
+ * <p>
  * Created by dyoung on 3/24/14.
  */
 public class BluetoothCrashResolver {
@@ -46,34 +45,20 @@
      * This is not the same file that Bluedroid uses.  This is just to maintain state of this module.
      */
     private static final String DISTINCT_BLUETOOTH_ADDRESSES_FILE = "BluetoothCrashResolverState.txt";
-    private boolean recoveryInProgress = false;
-    private boolean discoveryStartConfirmed = false;
-
-    private long lastBluetoothOffTime = 0l;
-    private long lastBluetoothTurningOnTime = 0l;
-    private long lastBluetoothCrashDetectionTime = 0l;
-    private int detectedCrashCount = 0;
-    private int recoveryAttemptCount = 0;
-    private boolean lastRecoverySucceeded = false;
-    private long lastStateSaveTime = 0l;
     private static final long MIN_TIME_BETWEEN_STATE_SAVES_MILLIS = 60000l;
-
-    private Context context = null;
-    private UpdateNotifier updateNotifier;
-    private final Set<String> distinctBluetoothAddresses = new HashSet<String>();
     /**
-     // It is very likely a crash if Bluetooth turns off and comes
-     // back on in an extremely short interval.  Testing on a Nexus 4 shows
-     // that when the BluetoothService crashes, the time between the STATE_OFF
-     // and the STATE_TURNING_ON ranges from 0ms-684ms
-     // Out of 3614 samples:
-     //  99.4% (3593) < 600 ms
-     //  84.7% (3060) < 500 ms
-     // So we will assume any power off sequence of < 600ms to be a crash
-     //
-     // While it is possible to manually turn Bluetooth off then back on in
-     // about 600ms, but it is pretty hard to do.
-     //
+     * // It is very likely a crash if Bluetooth turns off and comes
+     * // back on in an extremely short interval.  Testing on a Nexus 4 shows
+     * // that when the BluetoothService crashes, the time between the STATE_OFF
+     * // and the STATE_TURNING_ON ranges from 0ms-684ms
+     * // Out of 3614 samples:
+     * //  99.4% (3593) < 600 ms
+     * //  84.7% (3060) < 500 ms
+     * // So we will assume any power off sequence of < 600ms to be a crash
+     * //
+     * // While it is possible to manually turn Bluetooth off then back on in
+     * // about 600ms, but it is pretty hard to do.
+     * //
      */
     private static final long SUSPICIOUSLY_SHORT_BLUETOOTH_OFF_INTERVAL_MILLIS = 600l;
     /**
@@ -92,6 +77,68 @@
      * sure.
      */
     private static final int TIME_TO_LET_DISCOVERY_RUN_MILLIS = 5000;  /* if 0, it means forever */
+    private final Set<String> distinctBluetoothAddresses = new HashSet<String>();
+    private boolean recoveryInProgress = false;
+    private boolean discoveryStartConfirmed = false;
+    private long lastBluetoothOffTime = 0l;
+    private long lastBluetoothTurningOnTime = 0l;
+    private long lastBluetoothCrashDetectionTime = 0l;
+    private int detectedCrashCount = 0;
+    private int recoveryAttemptCount = 0;
+    private boolean lastRecoverySucceeded = false;
+    private long lastStateSaveTime = 0l;
+    private Context context = null;
+    private UpdateNotifier updateNotifier;
+    private final BroadcastReceiver receiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+
+            if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {
+                if (recoveryInProgress) {
+                    LogManager.d(TAG, "Bluetooth discovery finished");
+                    finishRecovery();
+                } else {
+                    LogManager.d(TAG, "Bluetooth discovery finished (external)");
+                }
+            }
+            if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {
+                if (recoveryInProgress) {
+                    discoveryStartConfirmed = true;
+                    LogManager.d(TAG, "Bluetooth discovery started");
+                } else {
+                    LogManager.d(TAG, "Bluetooth discovery started (external)");
+                }
+            }
+
+            if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
+                final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                        BluetoothAdapter.ERROR);
+                switch (state) {
+                    case BluetoothAdapter.ERROR:
+                        LogManager.d(TAG, "Bluetooth state is ERROR");
+                        break;
+                    case BluetoothAdapter.STATE_OFF:
+                        LogManager.d(TAG, "Bluetooth state is OFF");
+                        lastBluetoothOffTime = SystemClock.elapsedRealtime();
+                        break;
+                    case BluetoothAdapter.STATE_TURNING_OFF:
+                        break;
+                    case BluetoothAdapter.STATE_ON:
+                        LogManager.d(TAG, "Bluetooth state is ON");
+                        LogManager.d(TAG, "Bluetooth was turned off for %s milliseconds", lastBluetoothTurningOnTime - lastBluetoothOffTime);
+                        if (lastBluetoothTurningOnTime - lastBluetoothOffTime < SUSPICIOUSLY_SHORT_BLUETOOTH_OFF_INTERVAL_MILLIS) {
+                            crashDetected();
+                        }
+                        break;
+                    case BluetoothAdapter.STATE_TURNING_ON:
+                        lastBluetoothTurningOnTime = SystemClock.elapsedRealtime();
+                        LogManager.d(TAG, "Bluetooth state is TURNING_ON");
+                        break;
+                }
+            }
+        }
+    };
 
     /**
      * Constructor should be called only once per long-running process that does Bluetooth LE
@@ -132,11 +179,12 @@ public void stop() {
 
     /**
      * Enable debug logging.  By default no debug lines are logged.
+     *
+     * @see org.altbeacon.beacon.logging.LogManager
+     * @see org.altbeacon.beacon.logging.Loggers
      * @deprecated Since the default logger used by the android-beacon-library only logs warnings and
      * above, this method is no logger used. To log debug messages use the
      * {@link org.altbeacon.beacon.logging.Loggers#verboseLogger()}
-     * @see org.altbeacon.beacon.logging.LogManager
-     * @see org.altbeacon.beacon.logging.Loggers
      */
     @Deprecated
     public void enableDebug() {
@@ -145,28 +193,30 @@ public void enableDebug() {
 
     /**
      * Disable debug logging.
+     *
+     * @see org.altbeacon.beacon.logging.LogManager
+     * @see org.altbeacon.beacon.logging.Loggers
      * @deprecated Since the default logger used by the android-beacon-library only logs warnings and
      * above, this method is no logger used. To log debug messages use the
      * {@link org.altbeacon.beacon.logging.Loggers#verboseLogger()}
-     * @see org.altbeacon.beacon.logging.LogManager
-     * @see org.altbeacon.beacon.logging.Loggers
      */
     @Deprecated
-    public void disableDebug() { }
+    public void disableDebug() {
+    }
 
     /**
      * Call this method from your BluetoothAdapter.LeScanCallback method.
      * Doing so is optional, but if you do, this class will be able to count the number of
      * distinct Bluetooth devices scanned, and prevent crashes before they happen.
-     *
+     * <p>
      * This works very well if the app containing this class is the only one running bluetooth
      * LE scans on the device, or it is constantly doing scans (e.g. is in the foreground for
      * extended periods of time.)
-     *
+     * <p>
      * This will not work well if the application using this class is only scanning periodically
      * (e.g. when in the background to save battery) and another application is also scanning on
      * the same device, because this class will only get the counts from this application.
-     *
+     * <p>
      * Future augmentation of this class may improve this by somehow centralizing the list of
      * unique scanned devices.
      *
@@ -178,7 +228,7 @@ public void notifyScannedDevice(BluetoothDevice device, BluetoothAdapter.LeScanC
 
         oldSize = distinctBluetoothAddresses.size();
 
-        synchronized(distinctBluetoothAddresses) {
+        synchronized (distinctBluetoothAddresses) {
             distinctBluetoothAddresses.add(device.getAddress());
         }
 
@@ -186,10 +236,10 @@ public void notifyScannedDevice(BluetoothDevice device, BluetoothAdapter.LeScanC
         if (oldSize != newSize && newSize % 100 == 0) {
             LogManager.d(TAG, "Distinct Bluetooth devices seen: %s", distinctBluetoothAddresses.size());
         }
-        if (distinctBluetoothAddresses.size()  > getCrashRiskDeviceCount()) {
+        if (distinctBluetoothAddresses.size() > getCrashRiskDeviceCount()) {
             if (PREEMPTIVE_ACTION_ENABLED && !recoveryInProgress) {
                 LogManager.w(TAG, "Large number of Bluetooth devices detected: %s Proactively "
-                        + "attempting to clear out address list to prevent a crash",
+                                + "attempting to clear out address list to prevent a crash",
                         distinctBluetoothAddresses.size());
                 LogManager.w(TAG, "Stopping LE Scan");
                 BluetoothAdapter.getDefaultAdapter().stopLeScan(scanner);
@@ -215,8 +265,7 @@ public void crashDetected() {
 
         if (recoveryInProgress) {
             LogManager.d(TAG, "Ignoring Bluetooth crash because recovery is already in progress.");
-        }
-        else {
+        } else {
             startRecovery();
         }
         processStateChange();
@@ -226,19 +275,21 @@ public void crashDetected() {
     public long getLastBluetoothCrashDetectionTime() {
         return lastBluetoothCrashDetectionTime;
     }
+
     public int getDetectedCrashCount() {
         return detectedCrashCount;
     }
+
     public int getRecoveryAttemptCount() {
         return recoveryAttemptCount;
     }
+
     public boolean isLastRecoverySucceeded() {
         return lastRecoverySucceeded;
     }
-    public boolean isRecoveryInProgress() { return recoveryInProgress; }
 
-    public interface UpdateNotifier {
-        public void dataUpdated();
+    public boolean isRecoveryInProgress() {
+        return recoveryInProgress;
     }
 
     public void setUpdateNotifier(UpdateNotifier updateNotifier) {
@@ -246,7 +297,7 @@ public void setUpdateNotifier(UpdateNotifier updateNotifier) {
     }
 
     /**
-     Used to force a recovery operation
+     * Used to force a recovery operation
      */
     public void forceFlush() {
         startRecovery();
@@ -259,7 +310,7 @@ private int getCrashRiskDeviceCount() {
         // than the number tracked by Bluedroid because the number we track does not include its
         // initial state.  We therefore assume that there are some devices being tracked by Bluedroid
         // after a recovery operation or on startup
-        return BLUEDROID_MAX_BLUETOOTH_MAC_COUNT-BLUEDROID_POST_DISCOVERY_ESTIMATED_BLUETOOTH_MAC_COUNT;
+        return BLUEDROID_MAX_BLUETOOTH_MAC_COUNT - BLUEDROID_POST_DISCOVERY_ESTIMATED_BLUETOOTH_MAC_COUNT;
     }
 
     private void processStateChange() {
@@ -290,81 +341,26 @@ private void startRecovery() {
             // We don't actually need to do a discovery -- we just need to kick one off so the
             // mac list will be pared back to 256.  Because discovery is an expensive operation in
             // terms of battery, we will cancel it.
-            if (TIME_TO_LET_DISCOVERY_RUN_MILLIS > 0 ) {
+            if (TIME_TO_LET_DISCOVERY_RUN_MILLIS > 0) {
                 LogManager.d(TAG, "We will be cancelling this discovery in %s milliseconds.", TIME_TO_LET_DISCOVERY_RUN_MILLIS);
                 cancelDiscovery();
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "We will let this discovery run its course.");
             }
-        }
-        else {
+        } else {
             LogManager.w(TAG, "Already discovering.  Recovery attempt abandoned.");
         }
 
     }
+
     private void finishRecovery() {
         LogManager.w(TAG, "Recovery attempt finished");
-        synchronized(distinctBluetoothAddresses) {
+        synchronized (distinctBluetoothAddresses) {
             distinctBluetoothAddresses.clear();
         }
         recoveryInProgress = false;
     }
 
-    private final BroadcastReceiver receiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            String action = intent.getAction();
-
-            if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {
-                if (recoveryInProgress) {
-                    LogManager.d(TAG, "Bluetooth discovery finished");
-                    finishRecovery();
-                }
-                else {
-                    LogManager.d(TAG, "Bluetooth discovery finished (external)");
-                }
-            }
-            if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {
-                if (recoveryInProgress) {
-                    discoveryStartConfirmed = true;
-                    LogManager.d(TAG, "Bluetooth discovery started");
-                }
-                else {
-                    LogManager.d(TAG, "Bluetooth discovery started (external)");
-                }
-            }
-
-            if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) {
-                final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
-                        BluetoothAdapter.ERROR);
-                switch (state) {
-                    case BluetoothAdapter.ERROR:
-                        LogManager.d(TAG, "Bluetooth state is ERROR");
-                        break;
-                    case BluetoothAdapter.STATE_OFF:
-                        LogManager.d(TAG, "Bluetooth state is OFF");
-                        lastBluetoothOffTime = SystemClock.elapsedRealtime();
-                        break;
-                    case BluetoothAdapter.STATE_TURNING_OFF:
-                        break;
-                    case BluetoothAdapter.STATE_ON:
-                        LogManager.d(TAG, "Bluetooth state is ON");
-                        LogManager.d(TAG, "Bluetooth was turned off for %s milliseconds", lastBluetoothTurningOnTime - lastBluetoothOffTime);
-                        if (lastBluetoothTurningOnTime - lastBluetoothOffTime < SUSPICIOUSLY_SHORT_BLUETOOTH_OFF_INTERVAL_MILLIS) {
-                            crashDetected();
-                        }
-                        break;
-                    case BluetoothAdapter.STATE_TURNING_ON:
-                        lastBluetoothTurningOnTime = SystemClock.elapsedRealtime();
-                        LogManager.d(TAG, "Bluetooth state is TURNING_ON");
-                        break;
-                }
-            }
-        }
-    };
-
-
     private void saveState() {
         FileOutputStream outputStream;
         OutputStreamWriter writer = null;
@@ -373,9 +369,9 @@ private void saveState() {
         try {
             outputStream = context.openFileOutput(DISTINCT_BLUETOOTH_ADDRESSES_FILE, Context.MODE_PRIVATE);
             writer = new OutputStreamWriter(outputStream);
-            writer.write(lastBluetoothCrashDetectionTime+"\n");
-            writer.write(detectedCrashCount+"\n");
-            writer.write(recoveryAttemptCount+"\n");
+            writer.write(lastBluetoothCrashDetectionTime + "\n");
+            writer.write(detectedCrashCount + "\n");
+            writer.write(recoveryAttemptCount + "\n");
             writer.write(lastRecoverySucceeded ? "1\n" : "0\n");
             synchronized (distinctBluetoothAddresses) {
                 for (String mac : distinctBluetoothAddresses) {
@@ -385,12 +381,12 @@ private void saveState() {
             }
         } catch (IOException e) {
             LogManager.w(TAG, "Can't write macs to %s", DISTINCT_BLUETOOTH_ADDRESSES_FILE);
-        }
-        finally {
+        } finally {
             if (writer != null) {
                 try {
                     writer.close();
-                } catch (IOException e1) { }
+                } catch (IOException e1) {
+                }
             }
         }
         LogManager.d(TAG, "Wrote %s Bluetooth addresses", distinctBluetoothAddresses.size());
@@ -434,12 +430,12 @@ private void loadState() {
             LogManager.w(TAG, "Can't read macs from %s", DISTINCT_BLUETOOTH_ADDRESSES_FILE);
         } catch (NumberFormatException e) {
             LogManager.w(TAG, "Can't parse file %s", DISTINCT_BLUETOOTH_ADDRESSES_FILE);
-        }
-        finally {
+        } finally {
             if (reader != null) {
                 try {
                     reader.close();
-                } catch (IOException e1) { }
+                } catch (IOException e1) {
+                }
             }
         }
         LogManager.d(TAG, "Read %s Bluetooth addresses", distinctBluetoothAddresses.size());
@@ -456,13 +452,16 @@ private void cancelDiscovery() {
             if (adapter.isDiscovering()) {
                 LogManager.d(TAG, "Cancelling discovery");
                 adapter.cancelDiscovery();
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "Discovery not running.  Won't cancel it");
             }
         } catch (InterruptedException e) {
             LogManager.d(TAG, "DiscoveryCanceller sleep interrupted.");
         }
     }
+
+    public interface UpdateNotifier {
+        public void dataUpdated();
+    }
 }
 
diff --git a/lib/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java b/lib/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
index e3d5f157..78f06ba5 100644
--- a/lib/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
+++ b/lib/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
@@ -9,11 +9,11 @@
 import android.bluetooth.le.AdvertiseCallback;
 import android.bluetooth.le.AdvertiseData;
 import android.bluetooth.le.AdvertiseSettings;
+import android.bluetooth.le.AdvertiseSettings.Builder;
 import android.bluetooth.le.BluetoothLeAdvertiser;
 import android.bluetooth.le.BluetoothLeScanner;
 import android.bluetooth.le.ScanCallback;
 import android.bluetooth.le.ScanResult;
-import android.bluetooth.le.AdvertiseSettings.Builder;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
@@ -27,38 +27,37 @@
 import android.support.annotation.RequiresApi;
 import android.support.v4.app.NotificationCompat;
 import android.support.v4.content.LocalBroadcastManager;
-import java.util.List;
 
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.util.List;
+
 /**
- *
  * Utility class for checking the health of the bluetooth stack on the device by running two kinds
  * of tests: scanning and transmitting.  The class looks for specific failure codes from these
  * tests to determine if the bluetooth stack is in a bad state and if so, optionally cycle power to
  * bluetooth to try and fix the problem.  This is known to work well on some Android devices.
- *
+ * <p>
  * The tests may be called directly, or set up to run automatically approximately every 15 minutes.
  * To set up in an automated way:
  *
  * <code>
- *   BluetoothMedic medic = BluetoothMedic.getInstance();
- *   medic.enablePowerCycleOnFailures(context);
- *   medic.enablePeriodicTests(context, BluetoothMedic.SCAN_TEST | BluetoothMedic.TRANSMIT_TEST);
+ * BluetoothMedic medic = BluetoothMedic.getInstance();
+ * medic.enablePowerCycleOnFailures(context);
+ * medic.enablePeriodicTests(context, BluetoothMedic.SCAN_TEST | BluetoothMedic.TRANSMIT_TEST);
  * </code>
- *
+ * <p>
  * To set up in a manual way:
  *
  * <code>
- *   BluetoothMedic medic = BluetoothMedic.getInstance();
- *   medic.enablePowerCycleOnFailures(context);
- *   if (!medic.runScanTest(context)) {
- *     // Bluetooth stack is in a bad state
- *   }
- *   if (!medic.runTransmitterTest(context)) {
- *     // Bluetooth stack is in a bad state
- *   }
- *
+ * BluetoothMedic medic = BluetoothMedic.getInstance();
+ * medic.enablePowerCycleOnFailures(context);
+ * if (!medic.runScanTest(context)) {
+ * // Bluetooth stack is in a bad state
+ * }
+ * if (!medic.runTransmitterTest(context)) {
+ * // Bluetooth stack is in a bad state
+ * }
  */
 
 @SuppressWarnings("javadoc")
@@ -80,6 +79,9 @@
     @SuppressWarnings("WeakerAccess")
     public static final int SCAN_TEST = 1;
     private static final String TAG = BluetoothMedic.class.getSimpleName();
+    private static final long MIN_MILLIS_BETWEEN_BLUETOOTH_POWER_CYCLES = 60000L;
+    @Nullable
+    private static BluetoothMedic sInstance;
     @Nullable
     private BluetoothAdapter mAdapter;
     @Nullable
@@ -94,9 +96,6 @@
     private boolean mNotificationsEnabled = false;
     private int mNotificationIcon = 0;
     private long mLastBluetoothPowerCycleTime = 0L;
-    private static final long MIN_MILLIS_BETWEEN_BLUETOOTH_POWER_CYCLES = 60000L;
-    @Nullable
-    private static BluetoothMedic sInstance;
     @RequiresApi(21)
     private BroadcastReceiver mBluetoothEventReceiver = new BroadcastReceiver() {
         public void onReceive(Context context, Intent intent) {
@@ -104,24 +103,24 @@ public void onReceive(Context context, Intent intent) {
             int errorCode;
             String action = intent.getAction();
             if (action != null) {
-                if(action.equalsIgnoreCase("onScanFailed")) {
+                if (action.equalsIgnoreCase("onScanFailed")) {
                     errorCode = intent.getIntExtra("errorCode", -1);
-                    if(errorCode == 2) {
+                    if (errorCode == 2) {
                         BluetoothMedic.this.sendNotification(context, "scan failed",
                                 "Power cycling bluetooth");
                         LogManager.d(BluetoothMedic.TAG,
                                 "Detected a SCAN_FAILED_APPLICATION_REGISTRATION_FAILED.  We need to cycle bluetooth to recover");
-                        if(!BluetoothMedic.this.cycleBluetoothIfNotTooSoon()) {
+                        if (!BluetoothMedic.this.cycleBluetoothIfNotTooSoon()) {
                             BluetoothMedic.this.sendNotification(context, "scan failed", "" +
                                     "Cannot power cycle bluetooth again");
                         }
                     }
-                } else if(action.equalsIgnoreCase("onStartFailed")) {
+                } else if (action.equalsIgnoreCase("onStartFailed")) {
                     errorCode = intent.getIntExtra("errorCode", -1);
-                    if(errorCode == 4) {
+                    if (errorCode == 4) {
                         BluetoothMedic.this.sendNotification(context, "advertising failed",
                                 "Expected failure.  Power cycling.");
-                        if(!BluetoothMedic.this.cycleBluetoothIfNotTooSoon()) {
+                        if (!BluetoothMedic.this.cycleBluetoothIfNotTooSoon()) {
                             BluetoothMedic.this.sendNotification(context, "advertising failed",
                                     "Cannot power cycle bluetooth again");
                         }
@@ -134,25 +133,26 @@ public void onReceive(Context context, Intent intent) {
     };
 
 
+    private BluetoothMedic() {
+    }
+
     /**
      * Get a singleton instance of the BluetoothMedic
+     *
      * @return
      */
     public static BluetoothMedic getInstance() {
-        if(sInstance == null) {
+        if (sInstance == null) {
             sInstance = new BluetoothMedic();
         }
         return sInstance;
     }
 
-    private BluetoothMedic() {
-    }
-
     @RequiresApi(21)
     private void initializeWithContext(Context context) {
         if (this.mAdapter == null || this.mLocalBroadcastManager == null) {
-            BluetoothManager manager = (BluetoothManager)context.getSystemService(Context.BLUETOOTH_SERVICE);
-            if(manager == null) {
+            BluetoothManager manager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);
+            if (manager == null) {
                 throw new NullPointerException("Cannot get BluetoothManager");
             } else {
                 this.mAdapter = manager.getAdapter();
@@ -202,14 +202,14 @@ public void enablePeriodicTests(Context context, int testType) {
     /**
      * Starts up a brief blueooth scan with the intent of seeing if it results in an error condition
      * indicating the bluetooth stack may be in a bad state.
-     *
+     * <p>
      * If the failure error code matches a pattern known to be associated with a bad bluetooth stack
      * state, then the bluetooth stack is turned off and then back on after a short delay in order
      * to try to recover.
      *
      * @return false if the test indicates a failure indicating a bad state of the bluetooth stack
      */
-    @SuppressWarnings({"unused","WeakerAccess"})
+    @SuppressWarnings({"unused", "WeakerAccess"})
     @RequiresApi(21)
     public boolean runScanTest(final Context context) {
         initializeWithContext(context);
@@ -225,8 +225,7 @@ public void onScanResult(int callbackType, ScanResult result) {
                     LogManager.i(BluetoothMedic.TAG, "Scan test succeeded");
                     try {
                         scanner.stopScan(this);
-                    }
-                    catch (IllegalStateException e) { /* do nothing */ } // caught if bluetooth is off here
+                    } catch (IllegalStateException e) { /* do nothing */ } // caught if bluetooth is off here
                 }
 
                 public void onBatchScanResults(List<ScanResult> results) {
@@ -244,7 +243,7 @@ public void onScanFailed(int errorCode) {
                     }
                     LogManager.d(BluetoothMedic.TAG, "broadcast: " + intent +
                             " should be received by " + BluetoothMedic.this.mBluetoothEventReceiver);
-                    if(errorCode == 2) {
+                    if (errorCode == 2) {
                         LogManager.w(BluetoothMedic.TAG,
                                 "Scan test failed in a way we consider a failure");
                         BluetoothMedic.this.sendNotification(context,
@@ -258,7 +257,7 @@ public void onScanFailed(int errorCode) {
 
                 }
             };
-            if(scanner != null) {
+            if (scanner != null) {
                 try {
                     scanner.startScan(callback);
                     while (this.mScanTestResult == null) {
@@ -277,8 +276,7 @@ public void onScanFailed(int errorCode) {
                 } catch (IllegalStateException e) {
                     LogManager.d(TAG, "Bluetooth is off.  Cannot run scan test.");
                 }
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "Cannot get scanner");
             }
         }
@@ -290,14 +288,14 @@ public void onScanFailed(int errorCode) {
     /**
      * Starts up a beacon transmitter with the intent of seeing if it results in an error condition
      * indicating the bluetooth stack may be in a bad state.
-     *
+     * <p>
      * If the failure error code matches a pattern known to be associated with a bad bluetooth stack
      * state, then the bluetooth stack is turned off and then back on after a short delay in order
      * to try to recover.
      *
      * @return false if the test indicates a failure indicating a bad state of the bluetooth stack
      */
-    @SuppressWarnings({"unused","WeakerAccess"})
+    @SuppressWarnings({"unused", "WeakerAccess"})
     @RequiresApi(21)
     public boolean runTransmitterTest(final Context context) {
         initializeWithContext(context);
@@ -305,7 +303,7 @@ public boolean runTransmitterTest(final Context context) {
         long testStartTime = System.currentTimeMillis();
         if (mAdapter != null) {
             final BluetoothLeAdvertiser advertiser = getAdvertiserSafely(mAdapter);
-            if(advertiser != null) {
+            if (advertiser != null) {
                 AdvertiseSettings settings = (new Builder()).setAdvertiseMode(0).build();
                 AdvertiseData data = (new android.bluetooth.le.AdvertiseData.Builder())
                         .addManufacturerData(0, new byte[]{0}).build();
@@ -327,7 +325,7 @@ public void onStartFailure(int errorCode) {
                         if (BluetoothMedic.this.mLocalBroadcastManager != null) {
                             BluetoothMedic.this.mLocalBroadcastManager.sendBroadcast(intent);
                         }
-                        if(errorCode == 4) {
+                        if (errorCode == 4) {
                             BluetoothMedic.this.mTransmitterTestResult = false;
                             LogManager.w(BluetoothMedic.TAG,
                                     "Transmitter test failed in a way we consider a test failure");
@@ -344,14 +342,14 @@ public void onStartFailure(int errorCode) {
             } else {
                 LogManager.d(TAG, "Cannot get advertiser");
             }
-            while(this.mTransmitterTestResult == null) {
+            while (this.mTransmitterTestResult == null) {
                 LogManager.d(TAG, "Waiting for transmitter test to complete...");
 
                 try {
                     Thread.sleep(1000L);
                 } catch (InterruptedException e) { /* do nothing */ }
 
-                if(System.currentTimeMillis() - testStartTime > 5000L) {
+                if (System.currentTimeMillis() - testStartTime > 5000L) {
                     LogManager.d(TAG, "Timeout running transmitter test");
                     break;
                 }
@@ -363,11 +361,10 @@ public void onStartFailure(int errorCode) {
     }
 
     /**
-     *
      * Configure whether to send user-visible notification warnings when bluetooth power is cycled.
      *
      * @param enabled if true, a user-visible notification is sent to tell the user when
-     * @param icon the icon drawable to use in notifications (e.g. R.drawable.notification_icon)
+     * @param icon    the icon drawable to use in notifications (e.g. R.drawable.notification_icon)
      */
     @SuppressWarnings("unused")
     @RequiresApi(21)
@@ -379,7 +376,7 @@ public void setNotificationsEnabled(boolean enabled, int icon) {
     @RequiresApi(21)
     private boolean cycleBluetoothIfNotTooSoon() {
         long millisSinceLastCycle = System.currentTimeMillis() - this.mLastBluetoothPowerCycleTime;
-        if(millisSinceLastCycle < MIN_MILLIS_BETWEEN_BLUETOOTH_POWER_CYCLES) {
+        if (millisSinceLastCycle < MIN_MILLIS_BETWEEN_BLUETOOTH_POWER_CYCLES) {
             LogManager.d(TAG, "Not cycling bluetooth because we just did so " +
                     millisSinceLastCycle + " milliseconds ago.");
             return false;
@@ -405,8 +402,7 @@ public void run() {
                     }
                 }
             }, 1000L);
-        }
-        else {
+        } else {
             LogManager.w(TAG, "Cannot cycle bluetooth.  Manager is null.");
         }
     }
@@ -414,7 +410,7 @@ public void run() {
     @RequiresApi(21)
     private void sendNotification(Context context, String message, String detail) {
         initializeWithContext(context);
-        if(this.mNotificationsEnabled) {
+        if (this.mNotificationsEnabled) {
             NotificationCompat.Builder builder =
                     (new NotificationCompat.Builder(context, "err"))
                             .setContentTitle("BluetoothMedic: " + message)
@@ -429,7 +425,7 @@ private void sendNotification(Context context, String message, String detail) {
             );
             builder.setContentIntent(resultPendingIntent);
             NotificationManager notificationManager =
-                    (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
+                    (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
             if (notificationManager != null) {
                 notificationManager.notify(1, builder.build());
             }
@@ -462,8 +458,7 @@ private BluetoothLeAdvertiser getAdvertiserSafely(BluetoothAdapter adapter) {
             // This can sometimes throw a NullPointerException as reported here:
             // https://github.com/AltBeacon/android-beacon-library/issues/672
             return adapter.getBluetoothLeAdvertiser();
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             LogManager.w(TAG, "Cannot get bluetoothLeAdvertiser", e);
         }
         return null;
diff --git a/lib/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java b/lib/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java
index 8d70bd98..2123a17f 100644
--- a/lib/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java
+++ b/lib/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java
@@ -10,34 +10,36 @@
 import android.os.HandlerThread;
 import android.support.annotation.Nullable;
 import android.support.annotation.RequiresApi;
+
 import org.altbeacon.beacon.logging.LogManager;
-import org.altbeacon.beacon.service.BeaconService;
 
 /**
- * @hide
- * Internal library class.  Do not use directly.
+ * @hide Internal library class.  Do not use directly.
  */
 @SuppressWarnings("javadoc")
 @RequiresApi(21)
 public class BluetoothTestJob extends JobService {
     private static final String TAG = BluetoothTestJob.class.getSimpleName();
+    private static int sOverrideJobId = -1;
     @Nullable
     private Handler mHandler = null;
     @Nullable
     private HandlerThread mHandlerThread = null;
-    private static int sOverrideJobId = -1;
+
+    public BluetoothTestJob() {
+    }
 
     /**
      * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
      * will default to he value in the AndroidManifest.xml
-     *
+     * <p>
      * WARNING:  If using this library in a multi-process application, this method may not work.
      * This is considered a private API and may be removed at any time.
-     *
+     * <p>
      * the preferred way of setting this is in the AndroidManifest.xml as so:
      * <code>
      * <service android:name="org.altbeacon.bluetooth.BluetoothTestJob">
-     *   <meta-data android:name="jobId" android:value="1001" tools:replace="android:value"/>
+     * <meta-data android:name="jobId" android:value="1001" tools:replace="android:value"/>
      * </service>
      * </code>
      *
@@ -50,12 +52,13 @@ public static void setOverrideJobId(int id) {
     /**
      * Returns the job id to be used to schedule this job.  This may be set in the
      * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     *
      * @param context
      * @return
      */
     public static int getJobId(Context context) {
         if (sOverrideJobId >= 0) {
-            LogManager.i(TAG, "Using BluetoothTestJob JobId from static override: "+
+            LogManager.i(TAG, "Using BluetoothTestJob JobId from static override: " +
                     sOverrideJobId);
             return sOverrideJobId;
         }
@@ -66,25 +69,21 @@ public static int getJobId(Context context) {
         } catch (PackageManager.NameNotFoundException e) { /* do nothing here */ }
         if (info != null && info.metaData != null && info.metaData.get("jobId") != null) {
             int jobId = info.metaData.getInt("jobId");
-            LogManager.i(TAG, "Using BluetoothTestJob JobId from manifest: "+jobId);
+            LogManager.i(TAG, "Using BluetoothTestJob JobId from manifest: " + jobId);
             return jobId;
-        }
-        else {
+        } else {
             throw new RuntimeException("Cannot get job id from manifest.  " +
                     "Make sure that the BluetoothTestJob is configured in the manifest.");
         }
     }
 
-    public BluetoothTestJob() {
-    }
-
     public boolean onStartJob(final JobParameters params) {
-        if(this.mHandlerThread == null) {
+        if (this.mHandlerThread == null) {
             this.mHandlerThread = new HandlerThread("BluetoothTestThread");
             this.mHandlerThread.start();
         }
 
-        if(this.mHandler == null) {
+        if (this.mHandler == null) {
             this.mHandler = new Handler(this.mHandlerThread.getLooper());
         }
 
@@ -93,12 +92,12 @@ public void run() {
                 boolean found = false;
                 LogManager.i(BluetoothTestJob.TAG, "Bluetooth Test Job running");
                 int testType = params.getExtras().getInt("test_type");
-                if(testType == BluetoothMedic.NO_TEST) {
+                if (testType == BluetoothMedic.NO_TEST) {
                     found = true;
                     LogManager.d(BluetoothTestJob.TAG, "No test specified.  Done with job.");
                 }
 
-                if((testType & BluetoothMedic.SCAN_TEST) == BluetoothMedic.SCAN_TEST) {
+                if ((testType & BluetoothMedic.SCAN_TEST) == BluetoothMedic.SCAN_TEST) {
                     LogManager.d(BluetoothTestJob.TAG, "Scan test specified.");
                     found = true;
                     if (!BluetoothMedic.getInstance().runScanTest(BluetoothTestJob.this)) {
@@ -106,8 +105,8 @@ public void run() {
                     }
                 }
 
-                if((testType & BluetoothMedic.TRANSMIT_TEST) == BluetoothMedic.TRANSMIT_TEST) {
-                    if(found) {
+                if ((testType & BluetoothMedic.TRANSMIT_TEST) == BluetoothMedic.TRANSMIT_TEST) {
+                    if (found) {
                         try {
                             Thread.sleep(10000L);
                         } catch (InterruptedException e) {
@@ -122,7 +121,7 @@ public void run() {
                     }
                 }
 
-                if(!found) {
+                if (!found) {
                     LogManager.w(BluetoothTestJob.TAG, "Unknown test type:" + testType + "  Exiting.");
                 }
 
diff --git a/lib/src/main/java/org/altbeacon/bluetooth/Pdu.java b/lib/src/main/java/org/altbeacon/bluetooth/Pdu.java
index 0938c986..160fdd9b 100644
--- a/lib/src/main/java/org/altbeacon/bluetooth/Pdu.java
+++ b/lib/src/main/java/org/altbeacon/bluetooth/Pdu.java
@@ -8,10 +8,9 @@
  * Created by dyoung on 4/14/15.
  */
 public class Pdu {
-    private static final String  TAG = "Pdu";
     public static final byte MANUFACTURER_DATA_PDU_TYPE = (byte) 0xff;
     public static final byte GATT_SERVICE_UUID_PDU_TYPE = (byte) 0x16;
-
+    private static final String TAG = "Pdu";
     private byte mType;
     private int mDeclaredLength;
     private int mStartIndex;
@@ -20,6 +19,7 @@
 
     /**
      * Parse a PDU from a byte array looking offset by startIndex
+     *
      * @param bytes
      * @param startIndex
      * @return
@@ -28,7 +28,7 @@
     @TargetApi(Build.VERSION_CODES.GINGERBREAD)
     public static Pdu parse(byte[] bytes, int startIndex) {
         Pdu pdu = null;
-        if (bytes.length-startIndex >= 2) {
+        if (bytes.length - startIndex >= 2) {
             byte length = bytes[startIndex];
             if (length > 0) {
                 byte type = bytes[startIndex + 1];
@@ -54,6 +54,7 @@ public static Pdu parse(byte[] bytes, int startIndex) {
 
     /**
      * PDU type field
+     *
      * @return
      */
     public byte getType() {
@@ -62,6 +63,7 @@ public byte getType() {
 
     /**
      * PDU length from header
+     *
      * @return
      */
     public int getDeclaredLength() {
@@ -70,6 +72,7 @@ public int getDeclaredLength() {
 
     /**
      * Actual PDU length (may be less than declared length if fewer bytes are actually available.)
+     *
      * @return
      */
     public int getActualLength() {
@@ -80,6 +83,7 @@ public int getActualLength() {
      * Start index within byte buffer of PDU
      * This is the start of the payload data that starts after the length and the type, so the PDU
      * actually starts two bytes earlier
+     *
      * @return
      */
     public int getStartIndex() {
@@ -88,6 +92,7 @@ public int getStartIndex() {
 
     /**
      * End index within byte buffer of PDU
+     *
      * @return
      */
     public int getEndIndex() {
diff --git a/lib/src/main/resources/model-distance-calculations.json b/lib/src/main/resources/model-distance-calculations.json
index 2bda2d1f..f1eeef41 100644
--- a/lib/src/main/resources/model-distance-calculations.json
+++ b/lib/src/main/resources/model-distance-calculations.json
@@ -1,43 +1,42 @@
 {
-  "models":
-  [
+  "models": [
     {
       "coefficient1": 0.42093,
       "coefficient2": 6.9476,
       "coefficient3": 0.54992,
-      "version":"4.4.2",
-      "build_number":"KOT49H",
-      "model":"Nexus 4",
-      "manufacturer":"LGE"
+      "version": "4.4.2",
+      "build_number": "KOT49H",
+      "model": "Nexus 4",
+      "manufacturer": "LGE"
     },
     {
       "coefficient1": 0.42093,
       "coefficient2": 6.9476,
       "coefficient3": 0.54992,
-      "version":"4.4.2",
-      "build_number":"LPV79",
-      "model":"Nexus 5",
-      "manufacturer":"LGE",
+      "version": "4.4.2",
+      "build_number": "LPV79",
+      "model": "Nexus 5",
+      "manufacturer": "LGE",
       "default": true
     },
     {
       "coefficient1": 0.9401940951,
       "coefficient2": 6.170094565,
       "coefficient3": 0.0,
-      "version":"5.0.2",
-      "build_number":"LXG22.67-7.1",
-      "model":"Moto X Pro",
-      "manufacturer":"XT1115",
+      "version": "5.0.2",
+      "build_number": "LXG22.67-7.1",
+      "model": "Moto X Pro",
+      "manufacturer": "XT1115",
       "default": false
     },
     {
       "coefficient1": 0.1862616782,
       "coefficient2": 8.235367435,
       "coefficient3": -0.45324519,
-      "version":"6.0",
-      "build_number":"MPE24.49-18",
-      "model":"XT1092",
-      "manufacturer":"Motorola",
+      "version": "6.0",
+      "build_number": "MPE24.49-18",
+      "model": "XT1092",
+      "manufacturer": "Motorola",
       "default": false
     }
   ]
diff --git a/lib/src/test/AndroidManifest.xml b/lib/src/test/AndroidManifest.xml
index bd9c66be..49bfd6df 100644
--- a/lib/src/test/AndroidManifest.xml
+++ b/lib/src/test/AndroidManifest.xml
@@ -1,5 +1,5 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="org.altbeacon.beacon"
+          package="org.altbeacon.beacon"
     >
 
     <uses-permission android:name="android.permission.BLUETOOTH"/>
@@ -15,14 +15,16 @@
             </intent-filter>
         </receiver>
 
-        <service android:enabled="true"
+        <service
+            android:name=".service.BeaconService"
+            android:enabled="true"
             android:exported="false"
             android:isolatedProcess="false"
             android:label="beacon"
-            android:name=".service.BeaconService"
             />
 
-        <service android:name=".BeaconIntentProcessor"
+        <service
+            android:name=".BeaconIntentProcessor"
             android:enabled="true"
             android:exported="false"
             />
diff --git a/lib/src/test/java/org/altbeacon/beacon/AltBeaconParserTest.java b/lib/src/test/java/org/altbeacon/beacon/AltBeaconParserTest.java
index 0eba592e..3f3f7e01 100644
--- a/lib/src/test/java/org/altbeacon/beacon/AltBeaconParserTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/AltBeaconParserTest.java
@@ -1,17 +1,15 @@
 package org.altbeacon.beacon;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-
 import org.altbeacon.beacon.logging.LogManager;
-import org.altbeacon.beacon.logging.Loggers;
-import org.robolectric.RobolectricTestRunner;
-
-import org.junit.runner.RunWith;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+
 @Config(sdk = 28)
 @RunWith(RobolectricTestRunner.class)
 /*
@@ -30,17 +28,18 @@
         byte[] data = new byte[len / 2];
         for (int i = 0; i < len; i += 2) {
             data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                    + Character.digit(s.charAt(i+1), 16));
+                    + Character.digit(s.charAt(i + 1), 16));
         }
         return data;
     }
+
     @Test
     public void testRecognizeBeacon() {
         BeaconManager.setDebug(true);
         byte[] bytes = hexStringToByteArray("02011a1bff1801beac2f234454cf6d4a0fadf2f4911ba9ffa600010002c50900");
         AltBeaconParser parser = new AltBeaconParser();
         Beacon beacon = parser.fromScanData(bytes, -55, null);
-        assertEquals ("Beacon should have one data field", 1, beacon.getDataFields().size());
+        assertEquals("Beacon should have one data field", 1, beacon.getDataFields().size());
         assertEquals("manData should be parsed", 9, ((AltBeacon) beacon).getMfgReserved());
     }
 
@@ -52,6 +51,7 @@ public void testDetectsDaveMHardwareBeacon() {
         Beacon beacon = parser.fromScanData(bytes, -55, null);
         assertNotNull("Beacon should be not null if parsed successfully", beacon);
     }
+
     @Test
     public void testDetectsAlternateBeconType() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -61,6 +61,7 @@ public void testDetectsAlternateBeconType() {
         Beacon beacon = parser.fromScanData(bytes, -55, null);
         assertNotNull("Beacon should be not null if parsed successfully", beacon);
     }
+
     @Test
     public void testParseWrongFormatReturnsNothing() {
         BeaconManager.setDebug(true);
@@ -85,7 +86,7 @@ public void testParsesBeaconMissingDataField() {
         assertEquals("id2 should be parsed", "1", beacon.getIdentifier(1).toString());
         assertEquals("id3 should be parsed", "2", beacon.getIdentifier(2).toString());
         assertEquals("txPower should be parsed", -59, beacon.getTxPower());
-        assertEquals("manufacturer should be parsed", 0x118 ,beacon.getManufacturer());
+        assertEquals("manufacturer should be parsed", 0x118, beacon.getManufacturer());
         assertEquals("missing data field zero should be zero", new Long(0l), beacon.getDataFields().get(0));
     }
 }
\ No newline at end of file
diff --git a/lib/src/test/java/org/altbeacon/beacon/AltBeaconTest.java b/lib/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
index c25c7d77..13f93147 100644
--- a/lib/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
@@ -33,51 +33,51 @@
 public class AltBeaconTest {
     private Parcel aParcel = null;
 
-    @After
-    public void after() {
-        // Clean up any obtained parcel
-        if (null != aParcel) {
-            aParcel.recycle();
-        }
-    }
-
     public static byte[] hexStringToByteArray(String s) {
         int len = s.length();
         byte[] data = new byte[len / 2];
         for (int i = 0; i < len; i += 2) {
             data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                    + Character.digit(s.charAt(i+1), 16));
+                    + Character.digit(s.charAt(i + 1), 16));
         }
         return data;
     }
 
+    @After
+    public void after() {
+        // Clean up any obtained parcel
+        if (null != aParcel) {
+            aParcel.recycle();
+        }
+    }
+
     @Test
     public void testRecognizeBeacon() {
         byte[] bytes = hexStringToByteArray("02011a1bff1801beac2f234454cf6d4a0fadf2f4911ba9ffa600010002c509");
         AltBeaconParser parser = new AltBeaconParser();
         Beacon beacon = parser.fromScanData(bytes, -55, null);
-        assertEquals("manData should be parsed", 9, ((AltBeacon) beacon).getMfgReserved() );
+        assertEquals("manData should be parsed", 9, ((AltBeacon) beacon).getMfgReserved());
     }
 
     @Test
     public void testCanSerializeParcelable() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
         final Beacon original = new AltBeacon.Builder().setMfgReserved(2)
-                                                       .setBluetoothAddress("aa:bb:cc:dd:ee:ff")
-                                                       .setBluetoothName("Any Bluetooth")
-                                                       .setBeaconTypeCode(1)
-                                                       .setExtraDataFields(Arrays.asList(4L, 5L))
-                                                       .setId1("6")
-                                                       .setId2("7")
-                                                       .setId3("8")
-                                                       .setManufacturer(10)
-                                                       .setMultiFrameBeacon(true)
-                                                       .setParserIdentifier("Any Parser ID")
-                                                       .setRssi(-11)
-                                                       .setRunningAverageRssi(-12.3)
-                                                       .setServiceUuid(13)
-                                                       .setTxPower(14)
-                                                       .build();
+                .setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                .setBluetoothName("Any Bluetooth")
+                .setBeaconTypeCode(1)
+                .setExtraDataFields(Arrays.asList(4L, 5L))
+                .setId1("6")
+                .setId2("7")
+                .setId3("8")
+                .setManufacturer(10)
+                .setMultiFrameBeacon(true)
+                .setParserIdentifier("Any Parser ID")
+                .setRssi(-11)
+                .setRunningAverageRssi(-12.3)
+                .setServiceUuid(13)
+                .setTxPower(14)
+                .build();
         original.setPacketCount(15);
         original.setRssiMeasurementCount(16);
 
@@ -114,21 +114,21 @@ public void testCanSerializeParcelable() {
     @Test
     public void copyingBeaconTransfersAllFields() {
         final Beacon original = new AltBeacon.Builder().setMfgReserved(2)
-                                                       .setBluetoothAddress("aa:bb:cc:dd:ee:ff")
-                                                       .setBluetoothName("Any Bluetooth")
-                                                       .setBeaconTypeCode(1)
-                                                       .setExtraDataFields(Arrays.asList(4L, 5L))
-                                                       .setId1("6")
-                                                       .setId2("7")
-                                                       .setId3("8")
-                                                       .setManufacturer(10)
-                                                       .setMultiFrameBeacon(true)
-                                                       .setParserIdentifier("Any Parser ID")
-                                                       .setRssi(-11)
-                                                       .setRunningAverageRssi(-12.3)
-                                                       .setServiceUuid(13)
-                                                       .setTxPower(14)
-                                                       .build();
+                .setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                .setBluetoothName("Any Bluetooth")
+                .setBeaconTypeCode(1)
+                .setExtraDataFields(Arrays.asList(4L, 5L))
+                .setId1("6")
+                .setId2("7")
+                .setId3("8")
+                .setManufacturer(10)
+                .setMultiFrameBeacon(true)
+                .setParserIdentifier("Any Parser ID")
+                .setRssi(-11)
+                .setRunningAverageRssi(-12.3)
+                .setServiceUuid(13)
+                .setTxPower(14)
+                .build();
         original.setPacketCount(15);
         original.setRssiMeasurementCount(16);
         final AltBeacon copied = new AltBeacon(original);
diff --git a/lib/src/test/java/org/altbeacon/beacon/BeaconParserTest.java b/lib/src/test/java/org/altbeacon/beacon/BeaconParserTest.java
index 9128fe37..4b3ffbbf 100644
--- a/lib/src/test/java/org/altbeacon/beacon/BeaconParserTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/BeaconParserTest.java
@@ -34,10 +34,11 @@
         byte[] data = new byte[len / 2];
         for (int i = 0; i < len; i += 2) {
             data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                    + Character.digit(s.charAt(i+1), 16));
+                    + Character.digit(s.charAt(i + 1), 16));
         }
         return data;
     }
+
     public static String byteArrayToHexString(byte[] bytes) {
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < bytes.length; i++) {
@@ -53,7 +54,7 @@ public void testSetBeaconLayout() {
         parser.setBeaconLayout("m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25");
 
         assertEquals("parser should get beacon type code start offset", new Integer(2), parser.mMatchingBeaconTypeCodeStartOffset);
-        assertEquals("parser should get beacon type code end offset",  new Integer(3), parser.mMatchingBeaconTypeCodeEndOffset);
+        assertEquals("parser should get beacon type code end offset", new Integer(3), parser.mMatchingBeaconTypeCodeEndOffset);
         assertEquals("parser should get beacon type code", new Long(0xbeac), parser.getMatchingBeaconTypeCode());
         assertEquals("parser should get identifier start offset", new Integer(4), parser.mIdentifierStartOffsets.get(0));
         assertEquals("parser should get identifier end offset", new Integer(19), parser.mIdentifierEndOffsets.get(0));
@@ -88,7 +89,7 @@ public void testRecognizeBeacon() {
         assertEquals("id2 should be parsed", "1", beacon.getIdentifier(1).toString());
         assertEquals("id3 should be parsed", "2", beacon.getIdentifier(2).toString());
         assertEquals("txPower should be parsed", -59, beacon.getTxPower());
-        assertEquals("manufacturer should be parsed", 0x118 ,beacon.getManufacturer());
+        assertEquals("manufacturer should be parsed", 0x118, beacon.getManufacturer());
     }
 
     @Test
@@ -115,7 +116,7 @@ public void testParsesBeaconMissingDataField() {
         assertEquals("id2 should be parsed", "1", beacon.getIdentifier(1).toString());
         assertEquals("id3 should be parsed", "2", beacon.getIdentifier(2).toString());
         assertEquals("txPower should be parsed", -59, beacon.getTxPower());
-        assertEquals("manufacturer should be parsed", 0x118 ,beacon.getManufacturer());
+        assertEquals("manufacturer should be parsed", 0x118, beacon.getManufacturer());
         assertEquals("missing data field zero should be zero", new Long(0l), beacon.getDataFields().get(0));
 
     }
@@ -134,7 +135,7 @@ public void testRecognizeBeaconWithFormatSpecifyingManufacturer() {
         assertEquals("id2 should be parsed", "1", beacon.getIdentifier(1).toString());
         assertEquals("id3 should be parsed", "2", beacon.getIdentifier(2).toString());
         assertEquals("txPower should be parsed", -59, beacon.getTxPower());
-        assertEquals("manufacturer should be parsed", 0x118 ,beacon.getManufacturer());
+        assertEquals("manufacturer should be parsed", 0x118, beacon.getManufacturer());
     }
 
     @Test
@@ -264,8 +265,8 @@ public void testCanParseLocationBeacon() {
         Beacon beacon = new Beacon.Builder()
                 .setManufacturer(0x0118) // Radius Networks
                 .setId1("1") // device sequence number
-                .setId2(String.format("0x%08X", (long)((latitude+90)*10000.0)))
-                .setId3(String.format("0x%08X", (long)((longitude+180)*10000.0)))
+                .setId2(String.format("0x%08X", (long) ((latitude + 90) * 10000.0)))
+                .setId3(String.format("0x%08X", (long) ((longitude + 180) * 10000.0)))
                 .setTxPower(-59) // The measured transmitter power at one meter in dBm
                 .build();
         // TODO: make this pass if data fields are little endian or > 4 bytes (or even > 2 bytes)
@@ -273,7 +274,7 @@ public void testCanParseLocationBeacon() {
                 setBeaconLayout("m:2-3=10ca,i:4-9,i:10-13,i:14-17,p:18-18");
         byte[] bytes = p.getBeaconAdvertisementData(beacon);
         byte[] headerBytes = hexStringToByteArray("02011a1bff1801");
-        byte[] advBytes = new byte[bytes.length+headerBytes.length];
+        byte[] advBytes = new byte[bytes.length + headerBytes.length];
         System.arraycopy(headerBytes, 0, advBytes, 0, headerBytes.length);
         System.arraycopy(bytes, 0, advBytes, headerBytes.length, bytes.length);
 
@@ -282,13 +283,14 @@ public void testCanParseLocationBeacon() {
         double parsedLatitude = Long.parseLong(parsedBeacon.getId2().toString().substring(2), 16) / 10000.0 - 90.0;
         double parsedLongitude = Long.parseLong(parsedBeacon.getId3().toString().substring(2), 16) / 10000.0 - 180.0;
 
-        long encodedLatitude = (long)((latitude+90)*10000.0);
+        long encodedLatitude = (long) ((latitude + 90) * 10000.0);
         assertEquals("encoded latitude hex should match", String.format("0x%08x", encodedLatitude), parsedBeacon.getId2().toString());
         assertEquals("device sequence num should be same", "0x000000000001", parsedBeacon.getId1().toString());
         assertEquals("latitude should be about right", latitude, parsedLatitude, 0.0001);
         assertEquals("longitude should be about right", longitude, parsedLongitude, 0.0001);
 
     }
+
     @Test
     public void testCanGetAdvertisementDataForUrlBeacon() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -303,6 +305,7 @@ public void testCanGetAdvertisementDataForUrlBeacon() {
         byte[] bytes = p.getBeaconAdvertisementData(beacon);
         assertEquals("First byte of url should be in position 3", 0x02, bytes[2]);
     }
+
     @Test
     public void doesNotCashWithOverflowingByteCodeComparisonOnPdu() {
         // Test for https://github.com/AltBeacon/android-beacon-library/issues/323
@@ -320,7 +323,7 @@ public void doesNotCashWithOverflowingByteCodeComparisonOnPdu() {
     }
 
     @Test
-    public void testCanParseLongDataTypeOfDifferentSize(){
+    public void testCanParseLongDataTypeOfDifferentSize() {
         // Create a beacon parser
         BeaconParser parser = new BeaconParser();
         parser.setBeaconLayout("m:2-3=0118,i:4-7,p:8-8,d:9-16,d:18-21,d:22-25");
diff --git a/lib/src/test/java/org/altbeacon/beacon/BeaconTest.java b/lib/src/test/java/org/altbeacon/beacon/BeaconTest.java
index 7a59b603..89b7117e 100644
--- a/lib/src/test/java/org/altbeacon/beacon/BeaconTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/BeaconTest.java
@@ -8,6 +8,15 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.Arrays;
+import java.util.List;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.allOf;
@@ -16,17 +25,6 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import org.robolectric.annotation.Config;
-
-import java.util.Arrays;
-import java.util.List;
-
-import java.io.ObjectOutputStream;
-import java.io.ObjectInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-
 @Config(sdk = 28)
 
 @RunWith(RobolectricTestRunner.class)
@@ -160,7 +158,7 @@ public void testCalculateAccuracyWithRssiGreaterThanPower() {
     public void testCalculateAccuracyWithRssiLessThanPower() {
         Beacon.setDistanceCalculator(new ModelSpecificDistanceCalculator(null, null));
         double accuracy = Beacon.calculateDistance(-55, -60);
-        assertTrue("Distance should be over one meter if mRssi is less negative than power. Accuracy was "+accuracy,  accuracy > 1.0);
+        assertTrue("Distance should be over one meter if mRssi is less negative than power. Accuracy was " + accuracy, accuracy > 1.0);
     }
 
     @Test
@@ -227,21 +225,21 @@ public void testHashCodeWithNullIdentifier() {
     @Test
     public void parcelingBeaconContainsAllFields() {
         final Beacon original = new Beacon.Builder().setBluetoothAddress("aa:bb:cc:dd:ee:ff")
-                                                    .setBluetoothName("Any Bluetooth")
-                                                    .setBeaconTypeCode(1)
-                                                    .setDataFields(Arrays.asList(2L, 3L))
-                                                    .setExtraDataFields(Arrays.asList(4L, 5L))
-                                                    .setId1("6")
-                                                    .setId2("7")
-                                                    .setId3("8")
-                                                    .setManufacturer(10)
-                                                    .setMultiFrameBeacon(true)
-                                                    .setParserIdentifier("Any Parser ID")
-                                                    .setRssi(-11)
-                                                    .setRunningAverageRssi(-12.3)
-                                                    .setServiceUuid(13)
-                                                    .setTxPower(14)
-                                                    .build();
+                .setBluetoothName("Any Bluetooth")
+                .setBeaconTypeCode(1)
+                .setDataFields(Arrays.asList(2L, 3L))
+                .setExtraDataFields(Arrays.asList(4L, 5L))
+                .setId1("6")
+                .setId2("7")
+                .setId3("8")
+                .setManufacturer(10)
+                .setMultiFrameBeacon(true)
+                .setParserIdentifier("Any Parser ID")
+                .setRssi(-11)
+                .setRunningAverageRssi(-12.3)
+                .setServiceUuid(13)
+                .setTxPower(14)
+                .build();
         original.setPacketCount(15);
         original.setRssiMeasurementCount(16);
 
@@ -276,21 +274,21 @@ public void parcelingBeaconContainsAllFields() {
     @Test
     public void copyingBeaconContainsAllFields() {
         final Beacon original = new Beacon.Builder().setBluetoothAddress("aa:bb:cc:dd:ee:ff")
-                                                    .setBluetoothName("Any Bluetooth")
-                                                    .setBeaconTypeCode(1)
-                                                    .setDataFields(Arrays.asList(2L, 3L))
-                                                    .setExtraDataFields(Arrays.asList(4L, 5L))
-                                                    .setId1("6")
-                                                    .setId2("7")
-                                                    .setId3("8")
-                                                    .setManufacturer(10)
-                                                    .setMultiFrameBeacon(true)
-                                                    .setParserIdentifier("Any Parser ID")
-                                                    .setRssi(-11)
-                                                    .setRunningAverageRssi(-12.3)
-                                                    .setServiceUuid(13)
-                                                    .setTxPower(14)
-                                                    .build();
+                .setBluetoothName("Any Bluetooth")
+                .setBeaconTypeCode(1)
+                .setDataFields(Arrays.asList(2L, 3L))
+                .setExtraDataFields(Arrays.asList(4L, 5L))
+                .setId1("6")
+                .setId2("7")
+                .setId3("8")
+                .setManufacturer(10)
+                .setMultiFrameBeacon(true)
+                .setParserIdentifier("Any Parser ID")
+                .setRssi(-11)
+                .setRunningAverageRssi(-12.3)
+                .setServiceUuid(13)
+                .setTxPower(14)
+                .build();
         original.setPacketCount(15);
         original.setRssiMeasurementCount(16);
 
@@ -328,6 +326,7 @@ public void copyingBeaconContainsAllFields() {
             return bos.toByteArray();
         }
     }
+
     private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
         try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
              ObjectInputStream in = new ObjectInputStream(bis)) {
diff --git a/lib/src/test/java/org/altbeacon/beacon/BeaconTransmitterTest.java b/lib/src/test/java/org/altbeacon/beacon/BeaconTransmitterTest.java
index 07bc92d9..1ac03e4f 100644
--- a/lib/src/test/java/org/altbeacon/beacon/BeaconTransmitterTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/BeaconTransmitterTest.java
@@ -6,8 +6,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 import java.util.Arrays;
 
@@ -72,7 +72,7 @@ public void testBeaconAdvertisingBytesForEddystone() {
             byteString += String.format("%02X", data[i]);
             byteString += " ";
         }
-        Log.d(TAG, "Advertising bytes are "+byteString );
+        Log.d(TAG, "Advertising bytes are " + byteString);
         assertEquals("Data should be 24 bytes long", 18, data.length);
         assertEquals("Advertisement bytes should be as expected", "00 C5 2F 23 44 54 F4 91 1B A9 FF A6 00 00 00 00 00 01 ", byteString);
     }
diff --git a/lib/src/test/java/org/altbeacon/beacon/GattBeaconTest.java b/lib/src/test/java/org/altbeacon/beacon/GattBeaconTest.java
index c37f76a1..5c3be9c1 100644
--- a/lib/src/test/java/org/altbeacon/beacon/GattBeaconTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/GattBeaconTest.java
@@ -8,8 +8,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 import java.util.Arrays;
 
@@ -25,12 +25,22 @@
  */
 @RunWith(RobolectricTestRunner.class)
 public class GattBeaconTest {
+    public static byte[] hexStringToByteArray(String s) {
+        int len = s.length();
+        byte[] data = new byte[len / 2];
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
+                    + Character.digit(s.charAt(i + 1), 16));
+        }
+        return data;
+    }
+
     @Test
     public void testDetectsGattBeacon() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
         LogManager.setLogger(Loggers.verboseLogger());
         LogManager.setVerboseLoggingEnabled(true);
-        System.err.println("verbose logging:"+LogManager.isVerboseLoggingEnabled());
+        System.err.println("verbose logging:" + LogManager.isVerboseLoggingEnabled());
         byte[] bytes = hexStringToByteArray("020106030334121516341200e72f234454f4911ba9ffa6000000000001000000000000000000000000000000000000000000000000000000000000000000");
         BeaconParser parser = new BeaconParser().setBeaconLayout("s:0-1=1234,m:2-2=00,p:3-3:-41,i:4-13,i:14-19");
         assertNotNull("Service uuid parsed should not be null", parser.getServiceUuid());
@@ -68,21 +78,20 @@ public void testDetectsGattBeacon2WithShortIdentifier() {
         Beacon gattBeacon = parser.fromScanData(bytes, -55, null);
         assertNotNull("GattBeacon should be not null if parsed successfully", gattBeacon);
         assertEquals("GattBeacon identifier length should be adjusted smaller if packet is short",
-                     16,
-                     gattBeacon.getId1().toByteArray().length);
+                16,
+                gattBeacon.getId1().toByteArray().length);
         assertEquals("GattBeacon identifier should have proper first byte",
-                (byte)0x00,
+                (byte) 0x00,
                 gattBeacon.getId1().toByteArray()[0]);
         assertEquals("GattBeacon identifier should have proper second to last byte",
                 (byte) 0x73,
                 gattBeacon.getId1().toByteArray()[14]);
         assertEquals("GattBeacon identifier should have proper last byte",
-                (byte)0x07,
+                (byte) 0x07,
                 gattBeacon.getId1().toByteArray()[15]);
 
     }
 
-
     @Test
     public void testDetectsEddystoneUID() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -94,7 +103,6 @@ public void testDetectsEddystoneUID() {
         assertNotNull("Eddystone-UID should be not null if parsed successfully", eddystoneUidBeacon);
     }
 
-
     @Test
     public void testDetectsGattBeaconWithCnn() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -157,7 +165,6 @@ public void testDetectsUriBeacon() {
         assertEquals("URL should be decompressed successfully", "https://goo.gl/hqBXE1", urlString);
     }
 
-
     @Test
     public void doesNotCrashOnMalformedEddystoneBeacon() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -171,17 +178,4 @@ public void doesNotCrashOnMalformedEddystoneBeacon() {
         assertNull("GattBeacon should be null when not parsed successfully", gattBeacon);
     }
 
-
-
-
-    public static byte[] hexStringToByteArray(String s) {
-        int len = s.length();
-        byte[] data = new byte[len / 2];
-        for (int i = 0; i < len; i += 2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                    + Character.digit(s.charAt(i+1), 16));
-        }
-        return data;
-    }
-
 }
diff --git a/lib/src/test/java/org/altbeacon/beacon/IdentifierTest.java b/lib/src/test/java/org/altbeacon/beacon/IdentifierTest.java
index 1bf3f7da..0b0af03f 100644
--- a/lib/src/test/java/org/altbeacon/beacon/IdentifierTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/IdentifierTest.java
@@ -1,21 +1,17 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
-import static android.test.MoreAsserts.assertNotEqual;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertTrue;
-
-import org.robolectric.RobolectricTestRunner;
-
-import org.junit.runner.RunWith;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
 import java.util.Arrays;
 import java.util.UUID;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+
 @Config(sdk = 28)
 @RunWith(RobolectricTestRunner.class)
 
@@ -87,6 +83,7 @@ public void testToByteArrayConvertsHex() {
         assertEquals("first byte of hex is converted properly", 0x01, bytes[0] & 0xFF);
         assertEquals("last byte of hex is converted properly", 0x06, bytes[5] & 0xFF);
     }
+
     @Test
     public void testToByteArrayConvertsDecimal() {
         Identifier identifier1 = Identifier.parse("65534");
@@ -110,7 +107,7 @@ public void testToByteArrayConvertsInt() {
 
     @Test
     public void testToByteArrayFromByteArray() {
-        byte[] value = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25};
+        byte[] value = new byte[]{(byte) 0xFF, (byte) 0xAB, 0x12, 0x25};
         Identifier identifier1 = Identifier.fromBytes(value, 0, value.length, false);
         byte[] bytes = identifier1.toByteArrayOfSpecifiedEndianness(true);
 
@@ -122,9 +119,9 @@ public void testToByteArrayFromByteArray() {
 
     @Test
     public void testComparableDifferentLength() {
-        byte[] value1 = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25};
+        byte[] value1 = new byte[]{(byte) 0xFF, (byte) 0xAB, 0x12, 0x25};
         Identifier identifier1 = Identifier.fromBytes(value1, 0, value1.length, false);
-        byte[] value2 = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x11, 0x11};
+        byte[] value2 = new byte[]{(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x11, 0x11};
         Identifier identifier2 = Identifier.fromBytes(value2, 0, value2.length, false);
 
         assertEquals("identifier1 is smaller than identifier2", identifier1.compareTo(identifier2), -1);
@@ -133,9 +130,9 @@ public void testComparableDifferentLength() {
 
     @Test
     public void testComparableSameLength() {
-        byte[] value1 = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x22, 0x25};
+        byte[] value1 = new byte[]{(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x22, 0x25};
         Identifier identifier1 = Identifier.fromBytes(value1, 0, value1.length, false);
-        byte[] value2 = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x11, 0x11};
+        byte[] value2 = new byte[]{(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x11, 0x11};
         Identifier identifier2 = Identifier.fromBytes(value2, 0, value2.length, false);
 
         assertEquals("identifier1 is equal to identifier2", identifier1.compareTo(identifier1), 0);
@@ -190,34 +187,40 @@ public void testParseBigHexWithNoPrefix() {
         Identifier id = Identifier.parse("123456789abcdef");
         assertEquals("Should parse and get prefixed hex value for big numbers", "0x0123456789abcdef", id.toString());
     }
+
     @Test
     public void testParseZeroPrefixedDecimalNumberAsHex() {
         Identifier id = Identifier.parse("0010");
         assertEquals("Should be treated as hex in parse, but converted back to decimal because it is small", "16", id.toString());
     }
+
     @Test
     public void testParseNonZeroPrefixedDecimalNumberAsDecimal() {
         Identifier id = Identifier.parse("10");
         assertEquals("Should be treated as decimal", "10", id.toString());
     }
+
     @Test
     public void testParseDecimalNumberWithSpecifiedLength() {
         Identifier id = Identifier.parse("10", 8);
         assertEquals("Should be treated as hex because it is long", "0x000000000000000a", id.toString());
         assertEquals("Byte count should be as specified", 8, id.getByteCount());
     }
+
     @Test
     public void testParseDecimalNumberWithSpecifiedShortLength() {
         Identifier id = Identifier.parse("10", 2);
         assertEquals("Should be treated as decimal because it is short", "10", id.toString());
         assertEquals("Byte count should be as specified", 2, id.getByteCount());
     }
+
     @Test
     public void testParseHexNumberWithSpecifiedLength() {
         Identifier id = Identifier.parse("2fffffffffffffffffff", 10);
         assertEquals("Should be treated as hex because it is long", "0x2fffffffffffffffffff", id.toString());
         assertEquals("Byte count should be as specified", 10, id.getByteCount());
     }
+
     @Test
     public void testParseZeroAsInteger() {
         Identifier id = Identifier.parse("0");
diff --git a/lib/src/test/java/org/altbeacon/beacon/RegionTest.java b/lib/src/test/java/org/altbeacon/beacon/RegionTest.java
index e2edd854..f6f1c287 100644
--- a/lib/src/test/java/org/altbeacon/beacon/RegionTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/RegionTest.java
@@ -1,25 +1,22 @@
 package org.altbeacon.beacon;
 
-import static android.test.MoreAsserts.assertNotEqual;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.assertFalse;
-
-import org.robolectric.RobolectricTestRunner;
-
-import org.junit.runner.RunWith;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 
-import java.io.ObjectOutputStream;
-import java.io.ObjectInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 @Config(sdk = 28)
 
@@ -80,9 +77,9 @@ public void testBeaconMatchesRegionWithShorterIdentifierList() {
     public void testBeaconMatchesRegionWithSingleNullIdentifierList() {
         Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
                 .setBeaconTypeCode(5).setTxPower(6).setBluetoothAddress("1:2:3:4:5:6").build();
-        ArrayList<Identifier> identifiers=new ArrayList<>();
+        ArrayList<Identifier> identifiers = new ArrayList<>();
         identifiers.add(null);
-        Region region=new Region("all-beacons-region",identifiers);
+        Region region = new Region("all-beacons-region", identifiers);
         assertTrue("Beacon should match region with first identifier null and shorter Identifier list", region.matchesBeacon(beacon));
     }
 
@@ -126,7 +123,7 @@ public void testBeaconMatchesRegionWithSameBluetoothMacAndIdentifiers() {
         identifiers.add(Identifier.parse("1"));
         identifiers.add(Identifier.parse("2"));
         identifiers.add(Identifier.parse("3"));
-        Region region = new Region("myRegion", identifiers , "01:02:03:04:05:06");
+        Region region = new Region("myRegion", identifiers, "01:02:03:04:05:06");
         assertTrue("Beacon should match region with mac the same", region.matchesBeacon(beacon));
     }
 
@@ -161,8 +158,7 @@ public void rejectsInvalidMac() {
         try {
             Region region = new Region("myRegion", "this string is not a valid mac address!");
             assertTrue("IllegalArgumentException should have been thrown", false);
-        }
-        catch (IllegalArgumentException e) {
+        } catch (IllegalArgumentException e) {
             assertEquals("Error message should be as expected",
                     "Invalid mac address: 'this string is not a valid mac address!' Must be 6 hex bytes separated by colons.",
                     e.getMessage());
@@ -193,6 +189,7 @@ public void testConvenienceIdentifierAccessors() {
             return bos.toByteArray();
         }
     }
+
     private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
         try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
              ObjectInputStream in = new ObjectInputStream(bis)) {
diff --git a/lib/src/test/java/org/altbeacon/beacon/SBeaconTest.java b/lib/src/test/java/org/altbeacon/beacon/SBeaconTest.java
index 9268aa97..d4285b2f 100644
--- a/lib/src/test/java/org/altbeacon/beacon/SBeaconTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/SBeaconTest.java
@@ -18,6 +18,16 @@
  */
 public class SBeaconTest {
 
+    public static byte[] hexStringToByteArray(String s) {
+        int len = s.length();
+        byte[] data = new byte[len / 2];
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
+                    + Character.digit(s.charAt(i + 1), 16));
+        }
+        return data;
+    }
+
     @Test
     public void testDetectsSBeacon() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -31,16 +41,6 @@ public void testDetectsSBeacon() {
         assertEquals("txPower should be parsed", -59, sBeacon.getTxPower());
     }
 
-    public static byte[] hexStringToByteArray(String s) {
-        int len = s.length();
-        byte[] data = new byte[len / 2];
-        for (int i = 0; i < len; i += 2) {
-            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                    + Character.digit(s.charAt(i+1), 16));
-        }
-        return data;
-    }
-
     class SBeacon extends Beacon {
         private static final String TAG = "SBeacon";
         private int mTime;
@@ -58,12 +58,18 @@ protected SBeacon(int group, String id, int time, int txPower, int rssi, int bea
             //BeaconManager.logDebug(TAG, "constructed a new sbeacon with id2: " + getIdentifier(2));
         }
 
+        protected SBeacon(Parcel in) {
+            // TODO: Implement me
+        }
+
         public int getGroup() {
             return mIdentifiers.get(0).toInt();
         }
+
         public int getTime() {
             return mTime;
         }
+
         public String getId() {
             return mIdentifiers.get(1).toString();
         }
@@ -77,10 +83,6 @@ public int describeContents() {
         public void writeToParcel(Parcel dest, int flags) {
             // TODO: Implement me
         }
-
-        protected SBeacon(Parcel in) {
-            // TODO: Implement me
-        }
     }
 
     class SBeaconParser extends BeaconParser {
@@ -91,8 +93,8 @@ public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
             int startByte = 2;
             while (startByte <= 5) {
                 // "m:2-3=0203,i:2-2,i:7-8,i:14-19,d:10-13,p:9-9"
-                if (((int)scanData[startByte+3] & 0xff) == 0x03 &&
-                        ((int)scanData[startByte+4] & 0xff) == 0x15) {
+                if (((int) scanData[startByte + 3] & 0xff) == 0x03 &&
+                        ((int) scanData[startByte + 4] & 0xff) == 0x15) {
                     //BeaconManager.logDebug(TAG, "This is a SBeacon beacon advertisement");
                     // startByte+0 company id (2 bytes)
                     // startByte+2 = 02 (1) byte header
@@ -103,17 +105,17 @@ public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
                     // startByte+9 = Tx Power => Tx Power
                     // startByte+10 = Timestamp (4 bytes) => Minor (2 LSBs) little endian
                     // startByte+14 = Beacon ID (6 bytes) -> UUID little endian
-                    int group = (scanData[startByte+8] & 0xff) * 0x100 + (scanData[startByte+7] & 0xff);
-                    int clock = (scanData[startByte+13] & 0xff) * 0x1000000 + (scanData[startByte+12] & 0xff) * 0x10000 + (scanData[startByte+11] & 0xff) * 0x100 + (scanData[startByte+10] & 0xff);
-                    int txPower = (int)scanData[startByte+9]; // this one is signed
+                    int group = (scanData[startByte + 8] & 0xff) * 0x100 + (scanData[startByte + 7] & 0xff);
+                    int clock = (scanData[startByte + 13] & 0xff) * 0x1000000 + (scanData[startByte + 12] & 0xff) * 0x10000 + (scanData[startByte + 11] & 0xff) * 0x100 + (scanData[startByte + 10] & 0xff);
+                    int txPower = (int) scanData[startByte + 9]; // this one is signed
 
                     byte[] beaconId = new byte[6];
-                    System.arraycopy(scanData, startByte+14, beaconId, 0, 6);
+                    System.arraycopy(scanData, startByte + 14, beaconId, 0, 6);
                     String hexString = bytesToHex(beaconId);
                     StringBuilder sb = new StringBuilder();
-                    sb.append(hexString.substring(0,12));
+                    sb.append(hexString.substring(0, 12));
                     String id = "0x" + sb.toString();
-                    int beaconTypeCode = (scanData[startByte+3] & 0xff) * 0x100 + (scanData[startByte+2] & 0xff);
+                    int beaconTypeCode = (scanData[startByte + 3] & 0xff) * 0x100 + (scanData[startByte + 2] & 0xff);
 
 
                     String mac = null;
diff --git a/lib/src/test/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculatorTest.java b/lib/src/test/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculatorTest.java
index c2910f63..45b27002 100644
--- a/lib/src/test/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculatorTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculatorTest.java
@@ -5,8 +5,8 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 import static org.junit.Assert.assertEquals;
 
@@ -46,61 +46,61 @@ public void testSelectsDefaultModel() {
     @Test
     public void testSelectsNexus4OnExactMatch() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        AndroidModel model = new AndroidModel("4.4.2", "KOT49H","Nexus 4","LGE");
+        AndroidModel model = new AndroidModel("4.4.2", "KOT49H", "Nexus 4", "LGE");
 
         ModelSpecificDistanceCalculator distanceCalculator = new ModelSpecificDistanceCalculator(null, null, model);
         assertEquals("should be Nexus 4", "Nexus 4", distanceCalculator.getModel().getModel());
     }
 
-	@Test
-	public void testCalculatesDistanceForMotoXPro() {
-		final Context applicationContext = RuntimeEnvironment.application;
-		org.robolectric.shadows.ShadowLog.stream = System.err;
-
-		final AndroidModel model = new AndroidModel("5.0.2", "LXG22.67-7.1", "Moto X Pro", "XT1115");
-		ModelSpecificDistanceCalculator distanceCalculator = new ModelSpecificDistanceCalculator(applicationContext, null, model);
-		assertEquals("should be Moto X Pro", "Moto X Pro", distanceCalculator.getModel().getModel());
-		Double distance = distanceCalculator.calculateDistance(-49, -58);
-		assertEquals("Distance should be as predicted by coefficients at 3 meters", 2.661125466, distance, 0.1);
-	}
-
-	@Test
-	public void testConcurrentModificationException() {
-		org.robolectric.shadows.ShadowLog.stream = System.err;
-
-		final Context applicationContext = RuntimeEnvironment.application;
-
-		final AndroidModel model = new AndroidModel("4.4.2", "KOT49H", "Nexus 4", "LGE");
-		final String modelMapJson =
-				"{\"models\":[ \"coefficient1\": 0.89976,\"coefficient2\": 7.7095,\"coefficient3\": 0.111," +
-				"\"version\":\"4.4.2\",\"build_number\":\"KOT49H\",\"model\":\"Nexus 4\"," +
-				"\"manufacturer\":\"LGE\"},{\"coefficient1\": 0.42093,\"coefficient2\": 6.9476," +
-				"\"coefficient3\": 0.54992,\"version\":\"4.4.2\",\"build_number\":\"LPV79\"," +
-				"\"model\":\"Nexus 5\",\"manufacturer\":\"LGE\",\"default\": true}]}";
-		final ModelSpecificDistanceCalculator distanceCalculator =
-				new ModelSpecificDistanceCalculator(applicationContext, null, model);
-
-		Runnable runnable2 = new Runnable() {
-			@Override
-			public void run() {
-				try {
-					while (true) {
-						distanceCalculator.buildModelMapWithLock(modelMapJson);
-					}
-				} catch (Exception ex) {
-					ex.printStackTrace();
-				}
-			}
-		};
-
-		Thread thread2 = new Thread(runnable2);
-		thread2.start();
-
-		int i = 0;
-		while (++i < 1000 && thread2.getState() != Thread.State.TERMINATED) {
-			distanceCalculator.findCalculatorForModelWithLock(model);
-		}
-
-		thread2.interrupt();
-	}
+    @Test
+    public void testCalculatesDistanceForMotoXPro() {
+        final Context applicationContext = RuntimeEnvironment.application;
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+
+        final AndroidModel model = new AndroidModel("5.0.2", "LXG22.67-7.1", "Moto X Pro", "XT1115");
+        ModelSpecificDistanceCalculator distanceCalculator = new ModelSpecificDistanceCalculator(applicationContext, null, model);
+        assertEquals("should be Moto X Pro", "Moto X Pro", distanceCalculator.getModel().getModel());
+        Double distance = distanceCalculator.calculateDistance(-49, -58);
+        assertEquals("Distance should be as predicted by coefficients at 3 meters", 2.661125466, distance, 0.1);
+    }
+
+    @Test
+    public void testConcurrentModificationException() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+
+        final Context applicationContext = RuntimeEnvironment.application;
+
+        final AndroidModel model = new AndroidModel("4.4.2", "KOT49H", "Nexus 4", "LGE");
+        final String modelMapJson =
+                "{\"models\":[ \"coefficient1\": 0.89976,\"coefficient2\": 7.7095,\"coefficient3\": 0.111," +
+                        "\"version\":\"4.4.2\",\"build_number\":\"KOT49H\",\"model\":\"Nexus 4\"," +
+                        "\"manufacturer\":\"LGE\"},{\"coefficient1\": 0.42093,\"coefficient2\": 6.9476," +
+                        "\"coefficient3\": 0.54992,\"version\":\"4.4.2\",\"build_number\":\"LPV79\"," +
+                        "\"model\":\"Nexus 5\",\"manufacturer\":\"LGE\",\"default\": true}]}";
+        final ModelSpecificDistanceCalculator distanceCalculator =
+                new ModelSpecificDistanceCalculator(applicationContext, null, model);
+
+        Runnable runnable2 = new Runnable() {
+            @Override
+            public void run() {
+                try {
+                    while (true) {
+                        distanceCalculator.buildModelMapWithLock(modelMapJson);
+                    }
+                } catch (Exception ex) {
+                    ex.printStackTrace();
+                }
+            }
+        };
+
+        Thread thread2 = new Thread(runnable2);
+        thread2.start();
+
+        int i = 0;
+        while (++i < 1000 && thread2.getState() != Thread.State.TERMINATED) {
+            distanceCalculator.findCalculatorForModelWithLock(model);
+        }
+
+        thread2.interrupt();
+    }
 }
diff --git a/lib/src/test/java/org/altbeacon/beacon/org/altbeacon/beacon/simulator/BeaconSimulatorTest.java b/lib/src/test/java/org/altbeacon/beacon/org/altbeacon/beacon/simulator/BeaconSimulatorTest.java
index 6f8ca3fa..843bbdfe 100644
--- a/lib/src/test/java/org/altbeacon/beacon/org/altbeacon/beacon/simulator/BeaconSimulatorTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/org/altbeacon/beacon/simulator/BeaconSimulatorTest.java
@@ -1,26 +1,19 @@
 package org.altbeacon.beacon.org.altbeacon.beacon.simulator;
 
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-import org.altbeacon.beacon.AltBeacon;
 import org.altbeacon.beacon.AltBeaconParser;
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.simulator.StaticBeaconSimulator;
-import org.robolectric.RobolectricTestRunner;
-
-import org.junit.runner.RunWith;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
-import java.lang.Override;
 import java.util.ArrayList;
-import java.util.List;
 
-import dalvik.annotation.TestTarget;
-import org.robolectric.annotation.Config;
+import static org.junit.Assert.assertEquals;
 
 @Config(sdk = 28)
 
@@ -32,7 +25,7 @@
         byte[] data = new byte[len / 2];
         for (int i = 0; i < len; i += 2) {
             data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                    + Character.digit(s.charAt(i+1), 16));
+                    + Character.digit(s.charAt(i + 1), 16));
         }
         return data;
     }
@@ -47,7 +40,7 @@ public static void testCleanup() {
     }
 
     @Test
-    public void testSetBeacons(){
+    public void testSetBeacons() {
         StaticBeaconSimulator staticBeaconSimulator = new StaticBeaconSimulator();
         byte[] beaconBytes = hexStringToByteArray("02011a1bff1801beac2f234454cf6d4a0fadf2f4911ba9ffa600010002c509");
         Beacon beacon = new AltBeaconParser().fromScanData(beaconBytes, -55, null);
@@ -58,7 +51,7 @@ public void testSetBeacons(){
     }
 
     @Test
-    public void testSetBeaconsEmpty(){
+    public void testSetBeaconsEmpty() {
         StaticBeaconSimulator staticBeaconSimulator = new StaticBeaconSimulator();
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
         staticBeaconSimulator.setBeacons(beacons);
@@ -66,9 +59,9 @@ public void testSetBeaconsEmpty(){
     }
 
     @Test
-    public void testSetBeaconsNull(){
+    public void testSetBeaconsNull() {
         StaticBeaconSimulator staticBeaconSimulator = new StaticBeaconSimulator();
         staticBeaconSimulator.setBeacons(null);
-        assertEquals("getBeacons should return null",staticBeaconSimulator.getBeacons(), null);
+        assertEquals("getBeacons should return null", staticBeaconSimulator.getBeacons(), null);
     }
 }
\ No newline at end of file
diff --git a/lib/src/test/java/org/altbeacon/beacon/service/ArmaRssiFilterTest.java b/lib/src/test/java/org/altbeacon/beacon/service/ArmaRssiFilterTest.java
index 25f0fb30..6d79f20a 100644
--- a/lib/src/test/java/org/altbeacon/beacon/service/ArmaRssiFilterTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/service/ArmaRssiFilterTest.java
@@ -4,6 +4,7 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
+
 import static org.junit.Assert.assertEquals;
 
 @RunWith(RobolectricTestRunner.class)
diff --git a/lib/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java b/lib/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
index ff8398f8..6e68738a 100644
--- a/lib/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
@@ -36,6 +36,7 @@ public void before() {
     /**
      * This test verifies that processing a beacon in a scan (which starts its own thread) does not
      * affect the size of the available threads in the main Android AsyncTask.THREAD_POOL_EXECUTOR
+     *
      * @throws Exception
      */
     @Test
diff --git a/lib/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java b/lib/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
index 5547d495..25ed4b6a 100644
--- a/lib/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
@@ -25,6 +25,7 @@
 @Config(sdk = 28)
 public class MonitoringStatusTest {
     private static final String TAG = MonitoringStatusTest.class.getSimpleName();
+
     @Before
     public void before() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -38,7 +39,7 @@ public void savesStatusOfUpTo50RegionsTest() throws Exception {
         Context context = RuntimeEnvironment.application;
         MonitoringStatus monitoringStatus = new MonitoringStatus(context);
         for (int i = 0; i < 50; i++) {
-            Region region = new Region(""+i, null, null, null);
+            Region region = new Region("" + i, null, null, null);
             monitoringStatus.addRegion(region, null);
         }
         monitoringStatus.saveMonitoringStatusIfOn();
@@ -51,7 +52,7 @@ public void clearsStatusOfOver50RegionsTest() throws Exception {
         Context context = RuntimeEnvironment.application;
         MonitoringStatus monitoringStatus = new MonitoringStatus(context);
         for (int i = 0; i < 51; i++) {
-            Region region = new Region(""+i, null, null, null);
+            Region region = new Region("" + i, null, null, null);
             monitoringStatus.addRegion(region, null);
         }
         monitoringStatus.saveMonitoringStatusIfOn();
@@ -64,12 +65,12 @@ public void refusesToRestoreRegionsIfTooMuchTimeHasPassedSinceSavingTest() throw
         Context context = RuntimeEnvironment.application;
         MonitoringStatus monitoringStatus = new MonitoringStatus(context);
         for (int i = 0; i < 50; i++) {
-            Region region = new Region(""+i, null, null, null);
+            Region region = new Region("" + i, null, null, null);
             monitoringStatus.addRegion(region, null);
         }
         monitoringStatus.saveMonitoringStatusIfOn();
         // Set update time to one hour ago
-        monitoringStatus.updateMonitoringStatusTime(System.currentTimeMillis() - 1000*3600l);
+        monitoringStatus.updateMonitoringStatusTime(System.currentTimeMillis() - 1000 * 3600l);
         MonitoringStatus monitoringStatus2 = new MonitoringStatus(context);
         assertEquals("restored regions should be none", 0, monitoringStatus2.regions().size());
     }
@@ -82,7 +83,7 @@ public void allowsAccessToRegionsAfterRestore() throws Exception {
         MonitoringStatus.getInstanceForApplication(context).clear();
         MonitoringStatus monitoringStatus = new MonitoringStatus(context);
         for (int i = 0; i < 50; i++) {
-            Region region = new Region(""+i, null, null, null);
+            Region region = new Region("" + i, null, null, null);
             monitoringStatus.addRegion(region, null);
         }
         monitoringStatus.saveMonitoringStatusIfOn();
diff --git a/lib/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java b/lib/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
index 7f71f07e..56928411 100644
--- a/lib/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
@@ -1,10 +1,11 @@
 package org.altbeacon.beacon.service;
 
 import android.content.Context;
+import android.os.Bundle;
 
+import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Identifier;
-import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
@@ -12,13 +13,11 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
 
 import java.util.ArrayList;
 
-import android.os.Bundle;
-
 import static org.junit.Assert.assertEquals;
 
 @RunWith(RobolectricTestRunner.class)
@@ -42,14 +41,14 @@ public void testSerialization() throws Exception {
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
         Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers)
-                                            .setRssi(-1)
-                                            .setRunningAverageRssi(-2)
-                                            .setTxPower(-50)
-                                            .setBluetoothAddress("01:02:03:04:05:06")
-                                            .build();
+                .setRssi(-1)
+                .setRunningAverageRssi(-2)
+                .setTxPower(-50)
+                .setBluetoothAddress("01:02:03:04:05:06")
+                .build();
         beacon.setRssiMeasurementCount(1);
         beacon.setPacketCount(2);
-        for (int i=0; i < 10; i++) {
+        for (int i = 0; i < 10; i++) {
             beacons.add(beacon);
         }
         RangingData data = new RangingData(beacons, region);
@@ -77,17 +76,17 @@ public void testSerializationBenchmark() throws Exception {
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
         Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
-        for (int i=0; i < 10; i++) {
+        for (int i = 0; i < 10; i++) {
             beacons.add(beacon);
         }
         RangingData data = new RangingData(beacons, region);
         long time1 = System.currentTimeMillis();
-        for (int i=0; i< 10000; i++) {
+        for (int i = 0; i < 10000; i++) {
             Bundle bundle = data.toBundle();
             RangingData data2 = RangingData.fromBundle(bundle);
         }
         long time2 = System.currentTimeMillis();
-        System.out.println("*** Ranging Data Serialization benchmark: "+(time2-time1));
+        System.out.println("*** Ranging Data Serialization benchmark: " + (time2 - time1));
     }
 
 }
diff --git a/lib/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java b/lib/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
index e124ad7a..e8dc326e 100644
--- a/lib/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
@@ -5,6 +5,7 @@
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
+
 import static org.junit.Assert.assertEquals;
 
 @RunWith(RobolectricTestRunner.class)
@@ -18,6 +19,7 @@ public void initTest1() {
         filter.addMeasurement(-50);
         assertEquals("First measurement should be -50", String.valueOf(filter.calculateRssi()), "-50.0");
     }
+
     @Test
     public void rangedBeaconDoesNotOverrideSampleExpirationMillisecondsText() {
         RangedBeacon.setSampleExpirationMilliseconds(20000);
diff --git a/lib/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java b/lib/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
index 463fdad3..c3bff5a3 100644
--- a/lib/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
@@ -4,9 +4,7 @@
  * Created by dyoung on 7/30/17.
  */
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.os.Build;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
diff --git a/lib/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java b/lib/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
index cb642a3a..bb900caa 100644
--- a/lib/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
@@ -1,10 +1,12 @@
 package org.altbeacon.beacon.service.scanner;
+
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
+
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
@@ -24,33 +26,33 @@ public static void testCleanup() {
     @Test
     public void testSecondDuplicatePacketIsNotDistinct() throws Exception {
         DistinctPacketDetector dpd = new DistinctPacketDetector();
-        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
-        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[]{0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[]{0x01, 0x02});
         assertFalse("second call with same packet should not be distinct", secondResult);
     }
 
     @Test
     public void testSecondNonDuplicatePacketIsDistinct() throws Exception {
         DistinctPacketDetector dpd = new DistinctPacketDetector();
-        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
-        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x03, 0x04});
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[]{0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[]{0x03, 0x04});
         assertTrue("second call with different packet should be distinct", secondResult);
     }
 
     @Test
     public void testSamePacketForDifferentMacIsDistinct() throws Exception {
         DistinctPacketDetector dpd = new DistinctPacketDetector();
-        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
-        boolean secondResult = dpd.isPacketDistinct("01:01:01:01:01:01", new byte[] {0x01, 0x02});
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[]{0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:01:01:01:01:01", new byte[]{0x01, 0x02});
         assertTrue("second packet with different mac should be distinct", secondResult);
     }
 
     @Test
     public void clearingDetectionsPreventsDistinctDetection() throws Exception {
         DistinctPacketDetector dpd = new DistinctPacketDetector();
-        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[]{0x01, 0x02});
         dpd.clearDetections();
-        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[]{0x01, 0x02});
         assertTrue("second call with same packet after clear should be distinct", secondResult);
     }
 
diff --git a/lib/src/test/java/org/altbeacon/beacon/service/scanner/ScanFilterUtilsTest.java b/lib/src/test/java/org/altbeacon/beacon/service/scanner/ScanFilterUtilsTest.java
index c61b9882..25b276de 100644
--- a/lib/src/test/java/org/altbeacon/beacon/service/scanner/ScanFilterUtilsTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/service/scanner/ScanFilterUtilsTest.java
@@ -1,30 +1,21 @@
 package org.altbeacon.beacon.service.scanner;
 
 
-import android.bluetooth.le.ScanFilter;
-import android.content.Context;
-
 import org.altbeacon.beacon.AltBeaconParser;
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.BeaconParser;
-import org.altbeacon.beacon.service.scanner.ScanFilterUtils;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
 import java.util.List;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import org.mockito.Mockito;
 
 @Config(sdk = 28)
 
@@ -51,9 +42,10 @@ public void testGetAltBeaconScanFilter() throws Exception {
         ScanFilterUtils.ScanFilterData sfd = scanFilterDatas.get(0);
         assertEquals("manufacturer should be right", 0x0118, sfd.manufacturer);
         assertEquals("mask length should be right", 2, sfd.mask.length);
-        assertArrayEquals("mask should be right", new byte[] {(byte)0xff, (byte)0xff}, sfd.mask);
-        assertArrayEquals("filter should be right", new byte[] {(byte)0xbe, (byte)0xac}, sfd.filter);
+        assertArrayEquals("mask should be right", new byte[]{(byte) 0xff, (byte) 0xff}, sfd.mask);
+        assertArrayEquals("filter should be right", new byte[]{(byte) 0xbe, (byte) 0xac}, sfd.filter);
     }
+
     @Test
     public void testGenericScanFilter() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -66,9 +58,10 @@ public void testGenericScanFilter() throws Exception {
         assertEquals("manufacturer should be right", 0x004c, sfd.manufacturer);
         assertEquals("mask length should be right", 2, sfd.mask.length);
         assertArrayEquals("mask should be right", new byte[]{(byte) 0xff, (byte) 0xff}, sfd.mask);
-        assertArrayEquals("filter should be right", new byte[] {(byte)0x11, (byte) 0x11}, sfd.filter);
+        assertArrayEquals("filter should be right", new byte[]{(byte) 0x11, (byte) 0x11}, sfd.filter);
         assertNull("serviceUuid should be null", sfd.serviceUuid);
     }
+
     @Test
     public void testEddystoneScanFilterData() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -92,8 +85,8 @@ public void testZeroOffsetScanFilter() throws Exception {
         ScanFilterUtils.ScanFilterData sfd = scanFilterDatas.get(0);
         assertEquals("manufacturer should be right", 0x004c, sfd.manufacturer);
         assertEquals("mask length should be right", 2, sfd.mask.length);
-        assertArrayEquals("mask should be right", new byte[] {(byte)0xff, (byte)0xff}, sfd.mask);
-        assertArrayEquals("filter should be right", new byte[] {(byte)0x33, (byte)0x44}, sfd.filter);
+        assertArrayEquals("mask should be right", new byte[]{(byte) 0xff, (byte) 0xff}, sfd.mask);
+        assertArrayEquals("filter should be right", new byte[]{(byte) 0x33, (byte) 0x44}, sfd.filter);
     }
 
 }
diff --git a/lib/src/test/java/org/altbeacon/beacon/utils/EddystoneTelemetryAccessorTest.java b/lib/src/test/java/org/altbeacon/beacon/utils/EddystoneTelemetryAccessorTest.java
index 2634868d..e6b6b7f4 100644
--- a/lib/src/test/java/org/altbeacon/beacon/utils/EddystoneTelemetryAccessorTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/utils/EddystoneTelemetryAccessorTest.java
@@ -1,18 +1,14 @@
 package org.altbeacon.beacon.utils;
 
-import junit.framework.Assert;
-
-import java.net.MalformedURLException;
-import java.util.ArrayList;
-import java.util.Arrays;
-
 import org.altbeacon.beacon.Beacon;
 import org.junit.Test;
-import org.robolectric.RobolectricTestRunner;
-
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+import java.net.MalformedURLException;
+import java.util.ArrayList;
+
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
diff --git a/lib/src/test/java/org/altbeacon/beacon/utils/UrlBeaconUrlCompressorTest.java b/lib/src/test/java/org/altbeacon/beacon/utils/UrlBeaconUrlCompressorTest.java
index c5984a47..050416db 100644
--- a/lib/src/test/java/org/altbeacon/beacon/utils/UrlBeaconUrlCompressorTest.java
+++ b/lib/src/test/java/org/altbeacon/beacon/utils/UrlBeaconUrlCompressorTest.java
@@ -1,22 +1,31 @@
 package org.altbeacon.beacon.utils;
 
-import java.net.MalformedURLException;
-import java.util.Arrays;
-
 import org.junit.Test;
-import org.robolectric.RobolectricTestRunner;
-
 import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import static org.junit.Assert.assertTrue;
+import java.net.MalformedURLException;
+import java.util.Arrays;
+
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 @Config(sdk = 28)
 @RunWith(RobolectricTestRunner.class)
 public class UrlBeaconUrlCompressorTest {
 
-    final protected static char[] hexArray = "0123456789ABCDEF" .toCharArray();
+    final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();
+
+    private static String bytesToHex(byte[] bytes) {
+        char[] hexChars = new char[bytes.length * 2];
+        for (int j = 0; j < bytes.length; j++) {
+            int v = bytes[j] & 0xFF;
+            hexChars[j * 2] = hexArray[v >>> 4];
+            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
+        }
+        return new String(hexChars);
+    }
 
     /**
      * URLs to test:
@@ -223,15 +232,5 @@ public void testUncompressWithDotInfoTLD() throws MalformedURLException {
         assertEquals(testURL, UrlBeaconUrlCompressor.uncompress(testBytes));
     }
 
-    private static String bytesToHex(byte[] bytes) {
-        char[] hexChars = new char[bytes.length * 2];
-        for (int j = 0; j < bytes.length; j++) {
-            int v = bytes[j] & 0xFF;
-            hexChars[j * 2] = hexArray[v >>> 4];
-            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
-        }
-        return new String(hexChars);
-    }
-
 
 }
diff --git a/lib/src/test/java/org/altbeacon/bluetooth/BleAdvertisementTest.java b/lib/src/test/java/org/altbeacon/bluetooth/BleAdvertisementTest.java
index 0566b824..f31c38f5 100644
--- a/lib/src/test/java/org/altbeacon/bluetooth/BleAdvertisementTest.java
+++ b/lib/src/test/java/org/altbeacon/bluetooth/BleAdvertisementTest.java
@@ -3,11 +3,10 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
 
 import static org.junit.Assert.assertEquals;
 
-import org.robolectric.annotation.Config;
-
 @Config(sdk = 28)
 
 @RunWith(RobolectricTestRunner.class)
@@ -18,7 +17,7 @@
         byte[] data = new byte[len / 2];
         for (int i = 0; i < len; i += 2) {
             data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                    + Character.digit(s.charAt(i+1), 16));
+                    + Character.digit(s.charAt(i + 1), 16));
         }
         return data;
     }
diff --git a/lib/src/test/resources/model-distance-calculations.json b/lib/src/test/resources/model-distance-calculations.json
index 298dc533..883073d3 100644
--- a/lib/src/test/resources/model-distance-calculations.json
+++ b/lib/src/test/resources/model-distance-calculations.json
@@ -1,43 +1,42 @@
 {
-  "models":
-  [
+  "models": [
     {
       "coefficient1": 0.89976,
       "coefficient2": 7.7095,
       "coefficient3": 0.111,
-      "version":"4.4.2",
-      "build_number":"KOT49H",
-      "model":"Nexus 4",
-      "manufacturer":"LGE"
+      "version": "4.4.2",
+      "build_number": "KOT49H",
+      "model": "Nexus 4",
+      "manufacturer": "LGE"
     },
     {
       "coefficient1": 0.42093,
       "coefficient2": 6.9476,
       "coefficient3": 0.54992,
-      "version":"4.4.2",
-      "build_number":"LPV79",
-      "model":"Nexus 5",
-      "manufacturer":"LGE",
+      "version": "4.4.2",
+      "build_number": "LPV79",
+      "model": "Nexus 5",
+      "manufacturer": "LGE",
       "default": true
     },
     {
       "coefficient1": 0.9401940951,
       "coefficient2": 6.170094565,
       "coefficient3": 0.0,
-      "version":"5.0.2",
-      "build_number":"LXG22.67-7.1",
-      "model":"Moto X Pro",
-      "manufacturer":"XT1115",
+      "version": "5.0.2",
+      "build_number": "LXG22.67-7.1",
+      "model": "Moto X Pro",
+      "manufacturer": "XT1115",
       "default": false
     },
     {
       "coefficient1": 0.1862616782,
       "coefficient2": 8.235367435,
       "coefficient3": -0.45324519,
-      "version":"6.0",
-      "build_number":"MPE24.49-18",
-      "model":"XT1092",
-      "manufacturer":"Motorola",
+      "version": "6.0",
+      "build_number": "MPE24.49-18",
+      "model": "XT1092",
+      "manufacturer": "Motorola",
       "default": false
     }
   ]
