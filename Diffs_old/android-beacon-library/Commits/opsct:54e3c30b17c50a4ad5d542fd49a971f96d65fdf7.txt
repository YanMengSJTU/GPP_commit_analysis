diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..f213c0c3
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,288 @@
+### Development
+
+Bug Fixes:
+ - Fix ConcurrentModificationException crashing app on Android 8 when monitored regions are
+   changed at the same time the app shifts from active scanning to passive scanning. 
+   (#578, David G. Young)
+ - Fix ConcurrentModifictionExceptions starting ScanJobs.  (#584, #588, David G. Young)
+ - Fix NullPointerException when BluetoothLeScanner cannot be obtained.
+   (#583, David G. Young)
+
+### 2.12.2 / 2017-08-31
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12.1...2.12.2)
+
+Bug Fixes:
+ - Fix stack overflow caused by scan period of zero seconds, caused by 2.12 upgrade of existing
+  apps.  (#572, David G. Young)
+ - Suppress error log on ScanState deserialization if file does not exist yet.
+   (#570, David G. Young)
+ - Turn off scanning after unbind, which was previously left on forever in some cases.
+  (#569, David G. Young)
+
+### 2.12.1 / 2017-08-16
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12...2.12.1)
+
+
+Bug Fixes:
+ - Fix crash on Android 8.0 background scan when bluetooth is off.
+   (#562 Juliane Lehmann)
+ - Fix "Scanning too frequently" error with non-zero betweenScanPeriod
+   and scanPeriod+betweenScanPeriod < 6000, and full-power scanning
+   staying on for foreground scans with a non-zero betweenScanPeriod
+   (#555, David G. Young)
+
+
+### 2.12 / 2017-08-07
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.11...2.12)
+
+Enhancements:
+ - Add Android O support with ScanJob using  JobScheduler to do scans instead of BeaconService, 
+   set as default for Android O. (#484, David G. Young)
+
+Bug Fixes:
+
+ - Correct accessor method for Beacon#getRunningAverageRssi()
+   (#536, Pietro De Caro)
+
+### 2.11 / 2017-06-28
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.10...2.11)
+
+Enhancements:
+
+- Add ability to circumvent prohibition against scans running for > 30 minutes on Android N.
+  (#529, David G. Young)
+- Add support for running the beacon scanning service in a separate process and working with
+  application setups that have more than one process. (#479, David G. Young)
+
+Bug Fixes:
+
+- Fix Google Play submission errors by no longer using uses-permission-sdk-23 in
+  Manifest (#527, David G. Young)
+- Fix inability to use `RunningAverageRssiFilter.setSampleExpirationMilliseconds(...)` (#523,
+  David G. Young)
+- Fix failure to restart scanning in some cases after bluetooth has been off but then is turned
+  back on. (#519, David G. Young)
+- Fix failure to stop scanning when unbinding from service or when the between scan period
+  is nonzero. (#507, David G. Young)
+- Fix possible `NullPointerException` with `BackgroundPowerSaver` on devices
+  prior to Android 4.3 Jelly Bean MR 2 (API 18) (#516, Aaron Kromer)
+- Fix rare edge case causing `NoSuchElementException` when using the legacy
+  `BeaconManager#getMonitoringNotifier` and `BeaconManager#getRangingNotifier`
+  where the notifier sets were modified external to `BeaconManager` by another
+  thread (#516, Aaron Kromer)
+
+### 2.10 / 2017-04-21
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9.2...2.10)
+
+Enhancements:
+
+- Don't restart BLE scanning periodically if the library confrims device can detect duplicate
+  advertisements in a single scan, leading to more reliable detections with short scan cycles
+  (#491, David G. Young)
+
+Bug Fixes:
+
+- Deprecate misspelled methods `removeMonitoreNotifier` and
+  `setRegionStatePeristenceEnabled` in favor of correctly spelled alternatives.
+  (#461, Marco Salis)
+- Fix bug causing brief scan dropouts after starting a scan after a long period
+  of inactivity (i.e. startup and background-foreground transitions) due to
+  Android N scan limits (#489, Aaron Kromer)
+- Ensure thread safety for singleton creation of `BeaconManager`,
+  `DetectionTracker`, `MonitoringStatus`, and `Stats`. (#494, Aaron Kromer)
+
+
+### 2.9.2 / 2016-11-22
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9.1...2.9.2)
+
+Bug Fixes:
+
+- Provide access to monitored regions after restoring state (#456, David G.
+  Young)
+- Don't start or stop scans if bluetooth state is off to prevent crashes on HTC
+  devices (#452, David G. Young)
+- Protect against SecurityException crashes caused by Samsung Knox (#444, David
+  G. Young)
+- No Monitoring information after killing an application built with the minify
+  mode (#432, ost-ct)
+- Start and stop BLE scans from a background thread to prevent blocking the UI
+  (#430, Marco Salis)
+- Prevent flapping (rapid exit then enter) of restored monitored regions (#426,
+  Elias Lecomte)
+- Don't implicitly require bluetooth in manifest (Commit b3ac622e2b, David G.
+  Young)
+
+
+### 2.9.1 / 2016-08-26
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9...2.9.1)
+
+Bug Fixes:
+
+- Fixes spurious entry/exit events on Android N caused by OS imposed limits of
+  5 scans every 30 seconds. (#419, David G. Young)
+
+
+### 2.9 / 2016-07-25
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.8.1...2.9)
+
+Enhancements:
+
+- Multiple ranging and monitoring notifiers are supported via
+  `BeaconManger#addRangeNotifier(RangeNotifier notifier)` and
+  `BeaconManger#addMonitorNotifier(MonitorNotifier notifier)` (#392, ost-ct)
+- App bootstrap regions by be dynamically changed with
+  new`RegionBootstrap#removeRegion(Region region)` and
+  `RegionBootstrap#addRegion(Region region)` methods. (#369, Aristide)
+- Improved region state behavior by adding
+  `BeaconManager#requestStateForRegion(Region)` and
+  `BeaconManager#setRegionStatePeristenceEnabled(boolean)` (#405, David G.
+  Young)
+- Added a guaranteed callback to
+  `MonitorNotifier#didDetermineStateForRegion(int state, Region region)` when
+  starting monitoring.  At app startup, this returns the previously known
+  persisted state. (#405, David G. Young)
+- Custom distance calculation for Moto X 2nd gen XT1092 (#386, Clément Garcia)
+- More flexible support for combining multi-frame beacons with
+  `Beacon#getExtraDataFields()` (#387, mfatiga)
+
+Bug Fixes:
+
+- Eddystone frame detection on Google's Android BeaconTools and Chrome fixed by
+  adding missing service UUID PDU. (#401, David G. Young)
+- Beacon data fields of over four bytes are now be parsed correctly. (#373,
+  Junsung Lim)
+- Region persistence app freezes resolved by limiting persisted regions to 50
+  (#405, David G. Young)
+- Fixed inability to starting monitoring for a different Region definition with
+  the same uniqueId (#405, David G. Young)
+- Fixes Eddystone-URL layout to support the full 17 bytes for URLs (uses 18
+  bytes total: 1 byte for schema and 17 bytes for URL) (#377, Mario Pucci)
+- Fix potential context leak in `BeaconManager` (#381, Ovidiu Latcu)
+
+
+### 2.8.1 / 2016-04-18
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.8...2.8.1)
+
+Bug Fixes:
+
+- As of the 2.8 release, scanning would never start on Android 4.x devices
+  unless the application manually added ACCESS_COARSE_LOCATION or
+  ACCESS_FINE_LOCATION permissions to the AndroidManifest.xml. This fix makes
+  it so this is not required for 4.x devices, as was the case prior to 2.8.
+  (#365, David G. Young)
+
+
+### 2.8 / 2016-03-28
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.7.1...2.8)
+
+Enhancements:
+
+- Retains monitored regions across service restarts, preventing apps from
+  getting multiple region entry callbacks each time the service restarts.
+  (#315, Mateusz Sarzyński)
+- Add string identifier to BeaconParser which can be referenced by decoded
+  Beacon object, allowing easy determination of beacon type. (#333, David G.
+  Young)
+- Switch to using ELAPSED_REALTIME clocks, so scanning doesn't stop on devices
+  without a battery-backed RTC (#339, Luca Niccoli)
+- Add ability to access raw EDDYSTONE_TLM data for sending info to Google
+  services. (#328, David G. Young)
+- New distance formula for Moto X Pro (#330, David G. Young)
+- Adjust the BackgroundPowerSaver so it accepts any context (#355, Kristof
+  Snyers)
+- Add support for pre-Eddystone UriBeacon layout (#358, David G. Young)
+
+Bug Fixes:
+
+- Multiple consumers of the BeaconService will now each get a
+  onBeaconServiceConnected() callback. (#340, Mateusz Sarzyński)
+- Don't scan for bluetooth devices if permission has not been granted in
+  Android 6. This prevents large number of exceptions in the log. (#327, Alex
+  Urzhumtcev)
+- Fix crash on beacon parsing comparison overrun (#324, David G. Young)
+
+
+### 2.7.1 / 2015-11-17
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.7...2.7.1)
+
+Bug Fixes:
+
+- Stopping and starting monitoring disables scans (#317, David G. Young)
+
+
+### 2.7 / 2015-11-12
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.6.1...2.7)
+
+Enhancements:
+
+- Adds hardware accelerated detection of Eddystone frames in the background on
+  Android 5+ (#314, David G. Young)
+- Provides ability to forward BLE scan callbacks for non-beacon advertisements
+  (#267, Paul Peavyhouse)
+
+Bug Fixes:
+
+- Fix rescheduling of alarms in the distant future so they don't inadvertently
+  go off right away (#312, Mateusz Sarzyński)
+- Only request `ACCESS_COARSE_LOCATION` permission on Android M (#296, Henning
+  Dodenhof)
+
+
+### 2.6.1 / 2015-09-30
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.6...2.6.1)
+
+Bug Fixes:
+
+- Allow Regions to match beacons with fewer identifiers if the extra region
+  identifiers are null. This allows matching Eddystone-UID and Eddystone-URL
+  beacon with the default Region with three null identifiers. This started
+  failing in version 2.6. (#295, David G. Young)
+- Declare the `ACCESS_COARSE_LOCATION` permission in the manifest since it is
+  required for Android 6.0. This is helpful to keep beacon detection working on
+  Android 6.0 for apps that don't explicitly declare this in their own
+  manifest. (#295, David G. Young)
+
+
+### 2.6 / 2015-09-29
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.5.1...2.6)
+
+Enhancements:
+
+- Make region exit period configuration with a default of ten seconds (#283,
+  Alex Urzhumtcev)
+- When scanning in Background on Android 5+, do a full scan without filters
+  during the main scan period (default for 10 seconds once every 5 minutes) in
+  case scan filters are unavailable (#293, David G. Young)
+- Common open-source BeaconParser layouts are defined as constants on
+  BeaconParser (Commit 0101970010, David G. Young)
+- Bluetooth address is now a field on Region, offering the option of monitoring
+  and ranging for all beacon transmissions from a known device's MAC Address
+  (#254, David G. Young)
+- Target SDK bumped to 23 for Android 6.0 (#293, David G. Young)
+
+Bug Fixes:
+
+- Fix potential `ConcurrentModificationException` with distance calculation
+  (#245, Dawid Drozd)
+- Fix potential `NullPointerException` in `Beacon#hashCode` (#249, Sam Yang)
+- Switch BeaconParsers list to be a `CopyOnWriteArrayList` to avoid
+  `UnsupportedOperationException` changing list after starting scanning. (#290,
+  Matthew Michihara)
+- Fix crash when region has more identifiers than beacon (#252, David G. Young)
+- Fix bugs with compressing Eddystone-URL to bytes and back (#263, Michael
+  Harper)
+
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 63114dce..a87a54f1 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,30 +1,30 @@
-#How to Contribute to the Android Beacon Library
+# How to Contribute to the Android Beacon Library
 
-This project welcomes code contributions from the community.  Proposed code changes should be submitted as a pull request on Github.  Please follow the following guidelines when submitting a [pull request](https://github.com/altbeacon/android-beacon-library/pulls).
+This project welcomes code contributions from the communityProposed code changes should be submitted as a pull request on Github. Please follow the following guidelines when submitting a [pull request](https://github.com/altbeacon/android-beacon-library/pulls).
 
-##Style
+## Style
 
 Code style should generally follow the [Android coding style](https://source.android.com/source/code-style.html)
 
-##API Changes
+## API Changes
 
-Changes generally should not break the existing API and should be backward compatible with the current release version.   If the PR does represent a breaking change, the title or description must make this clear.  Breaking changes will be held for the next major version release of the library.
+Changes generally should not break the existing API and should be backward compatible with the current release version If the PR does represent a breaking change, the title or description must make this clear. Breaking changes will be held for the next major version release of the library.
 
-##Testing
+## Testing
 
-PRs must include testing information to ensure the changes are functional and do not adversely affect other library functions.  Testing information must include one or more of the following:
+PRs must include testing information to ensure the changes are functional and do not adversely affect other library functionsTesting information must include one or more of the following:
 
-###1. Automated Robolectric tests:
+### 1. Automated Robolectric tests:
 
-Robolectric tests are required for most changes, and should be submitted along with the PR.  Exceptions include Bluetooth or Android OS-level changes that cannot be tested with Robolectric.  Examples of Robolectric tests exist in the src/test folder.
+Robolectric tests are required for most changes, and should be submitted along with the PRExceptions include Bluetooth or Android OS-level changes that cannot be tested with Robolectric. Examples of Robolectric tests exist in the src/test folder.
 
-Robolectric test updates are absolutely required if existing Robolectric tests exists for the modified code. 
+Robolectric test updates are absolutely required if existing Robolectric tests exists for the modified code.
 
 Regardless of whether Robolectric tests are added or modified, all tests must be passing on the branch of the PR when running `./gradlew test `
 
-###2. Manual tests:
+### 2. Manual tests:
 
-Changes affecting Bluetooth scanning, addressing device-specific issues often cannot be adequately tested using Robolectric since it stubs out Bluetooth and Android OS system calls.  Changes of this nature must be manually tested on a physical device.  Manual tests should be performed with the library's reference application, if possible.
+Changes affecting Bluetooth scanning, addressing device-specific issues often cannot be adequately tested using Robolectric since it stubs out Bluetooth and Android OS system callsChanges of this nature must be manually tested on a physical device. Manual tests should be performed with the library's reference application, if possible.
 
 When submitting a PR, a description of any manual testing performed should include:
 
@@ -36,10 +36,10 @@ When submitting a PR, a description of any manual testing performed should inclu
 
 * A description of the conditions witnessed that verify the code works as designed and that other functions are not broken
 
-###3. Changes that cannot be tested manually or with Robolectric
+### 3. Changes that cannot be tested manually or with Robolectric
 
-In some rare cases where changes cannot be verified manually (e.g. some intermittent issues), a description may be included of why testing cannot be performed and describing why the change is low-risk and can be verified by code review.  For such changes to be considered low-risk they typically must be very small
+In some rare cases where changes cannot be verified manually (e.g. some intermittent issues), a description may be included of why testing cannot be performed and describing why the change is low-risk and can be verified by code reviewFor such changes to be considered low-risk they typically must be very small
 
-##License
+## License
 
-Any code submitted must be the work of the author, or if third party must be covered by the same Apache 2 license as this library or the Android Open Source Project.  Once submitted, the code is covered under the terms of the license of this library.
+Any code submitted must be the work of the author, or if third party must be covered by the same Apache 2 license as this library or the Android Open Source ProjectOnce submitted, the code is covered under the terms of the license of this library.
diff --git a/build.gradle b/build.gradle
index 5a675958..7e267687 100644
--- a/build.gradle
+++ b/build.gradle
@@ -25,11 +25,17 @@ def getVersionName = {
 buildscript {
     repositories {
         jcenter()
+        maven {
+            url 'https://maven.google.com'
+        }
+        maven {
+            url 'https://dl.google.com/dl/android/maven2/'
+        }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.5.0'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'
+        classpath 'com.android.tools.build:gradle:3.0.0-alpha9'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3'
     }
 }
@@ -44,20 +50,30 @@ allprojects {
 
     repositories {
         jcenter()
+        maven {
+            url 'https://maven.google.com'
+        }
+        maven {
+            url 'https://dl.google.com/dl/android/maven2/'
+        }
     }
 }
 
 android {
-    compileSdkVersion 24
-    buildToolsVersion "24.0.2"
+    compileSdkVersion 26
+    buildToolsVersion '26.0.0'
 
     defaultConfig {
-        minSdkVersion 7
-        targetSdkVersion 23
+        // Unfortunately 'com.android.support:appcompat-v7:26.0.0'
+        // requires minSdkVersion 14, forcing a bump verson minSdkVersion 7
+        // But since only 0.8% of Android devices have < SDK 14 as of Une 2017, this will become
+        // the new min version for this library in order to target Android O
+        minSdkVersion 14
+        targetSdkVersion 26
         versionCode 1
         versionName version
-        testInstrumentationRunner "com.google.android.apps.common.testing.testrunner.GoogleInstrumentationTestRunner"
         consumerProguardFiles 'proguard-rules.pro'
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
 
     compileOptions {
@@ -66,12 +82,6 @@ android {
         targetCompatibility JavaVersion.VERSION_1_7
     }
 
-    sourceSets {
-        androidTest {
-            setRoot('src/test')
-        }
-    }
-
     lintOptions {
         abortOnError false
     }
@@ -82,42 +92,31 @@ android {
         exclude 'META-INF/LICENSE.txt'
         exclude 'META-INF/NOTICE'
     }
-
 }
 
 dependencies {
     compile fileTree ( dir: 'libs', include: ['*.jar'] )
-    testCompile 'org.hamcrest:hamcrest-integration:1.3'
-    testCompile 'org.hamcrest:hamcrest-core:1.3'
-    testCompile 'org.hamcrest:hamcrest-library:1.3'
+    compile 'com.android.support:appcompat-v7:26.0.0'
+    compile 'com.android.support:support-annotations:26.0.0'
 
     testCompile('junit:junit:4.12') {
-        exclude module: 'hamcrest-core'
+        exclude group: 'org.hamcrest'
     }
-    testCompile('com.squareup:fest-android:1.0.+@aar') {
-        exclude group: 'com.android.support', module: 'support-v4'
+    testCompile('org.hamcrest:hamcrest-junit:2.0.0.0') {
+        exclude group: 'junit'
     }
-
+    testCompile('com.squareup:fest-android:1.0.+@aar')
     testCompile('org.robolectric:robolectric:3.0') {
-        exclude module: 'classworlds'
-        exclude module: 'commons-logging'
-        exclude module: 'httpclient'
-        exclude module: 'maven-artifact'
-        exclude module: 'maven-artifact-manager'
-        exclude module: 'maven-error-diagnostics'
-        exclude module: 'maven-model'
-        exclude module: 'maven-project'
-        exclude module: 'maven-settings'
-        exclude module: 'plexus-container-default'
-        exclude module: 'plexus-interpolation'
-        exclude module: 'plexus-utils'
-        exclude module: 'wagon-file'
-        exclude module: 'wagon-http-lightweight'
-        exclude module: 'wagon-provider-api'
-        exclude group: 'com.android.support', module: 'support-v4'
-    }
-
-    testCompile 'org.mockito:mockito-core:1.10.19'
+        exclude group: 'junit'
+    }
+    testCompile('org.mockito:mockito-core:1.10.19') {
+        exclude group: 'org.hamcrest'
+    }
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+        exclude group: 'org.hamcrest'
+    })
+    androidTestCompile 'org.apache.commons:commons-math3:3.6.1'
 }
 
 apply plugin: 'idea'
diff --git a/circle.yml b/circle.yml
index 50eb8479..048d01a5 100644
--- a/circle.yml
+++ b/circle.yml
@@ -3,5 +3,7 @@ machine:
     version: openjdk8
 dependencies:
   pre:
-    - echo y | android update sdk --no-ui --all --filter "tools,android-24,build-tools-24.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
-
+    - echo y | android update sdk --no-ui --all --filter "tools,android-26,build-tools-26.0.0,platform-tools,extra-android-m2repository,extra-google-m2repository"
+general:
+  branches:
+    ignore:
diff --git a/gradle/publishing.gradle b/gradle/publishing.gradle
index 6b94dd81..72962328 100644
--- a/gradle/publishing.gradle
+++ b/gradle/publishing.gradle
@@ -14,10 +14,10 @@ publishing {
             version project.version
             artifact "${project.buildDir}/outputs/aar/${project.name}-release.aar"
             artifact androidJavadocsJar {
-                classifier 'source'
+                classifier 'javadoc'
             }
             artifact androidSourcesJar {
-                classifier 'javadoc'
+                classifier 'source'
             }
 
             pom.withXml {
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 2944df68..5e35bbb6 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,9 @@
-#Sat May 10 23:17:01 CDT 2014
+#Sat Apr 01 10:19:45 EDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-rc-1-all.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-milestone-1-all.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-4.0-milestone-1-all.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/ibeacon-service-android.iml b/ibeacon-service-android.iml
deleted file mode 100644
index fd696913..00000000
--- a/ibeacon-service-android.iml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.system.id="GRADLE" type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/classes/main" />
-    <output-test url="file://$MODULE_DIR$/build/classes/test" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="1.6" jdkType="JavaSDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
-
diff --git a/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java b/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java
new file mode 100644
index 00000000..b93ede2e
--- /dev/null
+++ b/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java
@@ -0,0 +1,278 @@
+package org.altbeacon.beacon;
+
+import android.support.test.runner.AndroidJUnit4;
+import android.util.Log;
+
+import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+/*
+ * Set of benchmarks for copying various sized notifier sets.
+ *
+ * As with the current implementation the base sets use `CopyOnWriteArraySet`. In most cases
+ * these notifier sets will only have a single notifier in them. However, it's possible there are
+ * more so this also includes a set of three notifiers. While its very unlikely the notifiers
+ * will grow much larger two bigger sets are also included to help expose the affect of set size on
+ * the performance.
+ *
+ * Sample Test Runs
+ * ================
+ *
+ * All tests were performed with no apps running in the foreground and the devices in airplane
+ * mode. This was done to help minimize background system noise.
+ *
+ * Nexus 6 on Android 7.0
+ *
+ *   |      Type       | Size |   N   |   Min   |   Max   |  Mean   | Std. Dev |     Var     |
+ *   |-----------------|------|-------|---------|---------|---------|----------|-------------|
+ *   |         HashSet |    1 | 10000 |    4062 |   85157 |   11484 |   3429.7 | 1.17626e+07 |
+ *   | UnmodifiableSet |    1 | 10000 |    1718 |  342292 |    4864 |   4907.6 | 2.40841e+07 |
+ *   |         HashSet |    3 | 10000 |    6563 | 4019793 |   14402 |  41514.6 | 1.72346e+09 |
+ *   | UnmodifiableSet |    3 | 10000 |    1666 |  223281 |    5403 |   3091.0 | 9.55441e+06 |
+ *   |         HashSet |   10 | 10000 |    7500 | 1140937 |   16996 |  12741.5 | 1.62345e+08 |
+ *   | UnmodifiableSet |   10 | 10000 |    1666 |  313802 |    4765 |   4146.9 | 1.71966e+07 |
+ *   |         HashSet |   20 | 10000 |   11510 | 1677083 |   21395 |  18560.7 | 3.44500e+08 |
+ *   | UnmodifiableSet |   20 | 10000 |    1718 | 1690104 |    4187 |  17014.1 | 2.89478e+08 |
+ *
+ *
+ * Nexus 5 on Android 4.4.4
+ *
+ *   |      Type       | Size |   N   |   Min   |   Max   |  Mean   | Std. Dev |  Variance   |
+ *   |-----------------|------|-------|---------|---------|---------|----------|-------------|
+ *   |         HashSet |    1 | 10000 |    6354 | 7764219 |   12658 | 154235.5 | 2.37886e+10 |
+ *   | UnmodifiableSet |    1 | 10000 |    1250 |  178334 |    1360 |   1996.4 | 3.98546e+06 |
+ *   |         HashSet |    3 | 10000 |    9479 | 7745833 |   17389 | 171098.2 | 2.92746e+10 |
+ *   | UnmodifiableSet |    3 | 10000 |    1250 |  120001 |    1435 |   1320.4 | 1.74347e+06 |
+ *   |         HashSet |   10 | 10000 |   10000 | 7665208 |   30028 | 252827.8 | 6.39219e+10 |
+ *   | UnmodifiableSet |   10 | 10000 |    1302 |   97865 |    1435 |   1012.2 | 1.02459e+06 |
+ *   |         HashSet |   20 | 10000 |   16354 | 8842240 |   41301 | 333940.7 | 1.11516e+11 |
+ *   | UnmodifiableSet |   20 | 10000 |    1302 |   94479 |    1486 |   1049.3 | 1.10112e+06 |
+ *
+ *
+ * Samsung SM-G900V on Android 4.4.2
+ *
+ *   |      Type       | Size |   N   |   Min   |   Max    |  Mean   | Std. Dev |  Variance   |
+ *   |-----------------|------|-------|---------|----------|---------|----------|-------------|
+ *   |         HashSet |    1 | 10000 |    7084 |   306615 |    8703 |   9694.4 | 9.39809e+07 |
+ *   | UnmodifiableSet |    1 | 10000 |    1562 |    51615 |    1926 |    869.5 | 7.56085e+05 |
+ *   |         HashSet |    3 | 10000 |   10364 |   809427 |   12095 |   9418.6 | 8.87103e+07 |
+ *   | UnmodifiableSet |    3 | 10000 |    1562 |    82605 |    1967 |   1157.5 | 1.33973e+06 |
+ *   |         HashSet |   10 | 10000 |   11094 | 14970052 |   26345 | 155322.0 | 2.41249e+10 |
+ *   | UnmodifiableSet |   10 | 10000 |    1562 |    11563 |    1981 |    545.5 | 2.97536e+05 |
+ *   |         HashSet |   20 | 10000 |   17760 | 13884687 |   29915 | 215507.1 | 4.64433e+10 |
+ *   | UnmodifiableSet |   20 | 10000 |    1562 |   170781 |    1939 |   3229.1 | 1.04269e+07 |
+ *
+ *
+ * Summary
+ * =======
+ *
+ * In all cases usage of the `UnmodifiableSet` was fastest. This is not surprising because the
+ * current implementations are thin object wrappers around the provided set. This means they
+ * store the `CopyOnWriteArraySet` internally and delegate all non-mutation methods to it. So
+ * naturally this is faster than creating a new data structure and copying all elements into it.
+ */
+@RunWith(AndroidJUnit4.class)
+public class NotifierSetCopyBenchmarksTest {
+    private static final Set<RangeNotifier> LARGE_SET  = buildSet(20);
+
+    private static final Set<RangeNotifier> MEDIUM_SET = buildSet(10);
+
+    private static final Set<RangeNotifier> SINGLE_SET = buildSet(1);
+
+    private static final Set<RangeNotifier> SMALL_SET  = buildSet(3);
+
+    private static final String STAT_FORMAT =
+            "| %15s | %4d | %4d | %7d | %7d | %7d | %#8.1f | %.5e |";
+
+    private static final String STAT_HEADER =
+            "|      Type       | Size |   N   |   Min   |   Max   |  Mean   | Std. Dev |  Variance   |\n" +
+            "|-----------------|------|-------|---------|---------|---------|----------|-------------|";
+
+    private static final String TAG = "BenchmarkTests";
+
+    private static final int WARMUP_SIZE = 1_000;
+
+    private static final int SAMPLE_SIZE = 10_000;
+
+    @BeforeClass
+    public static void _displayStatsHeader() {
+        Log.i(TAG, "Benchmarks: NotifierSetCopyBenchmarksTest");
+        Log.i(TAG, STAT_HEADER);
+        // Let things finish loading / processing (such as package name for logging)
+        try {
+            Thread.sleep(2_000);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static Set<RangeNotifier> buildSet(int size) {
+        final Set<RangeNotifier> set = new CopyOnWriteArraySet<>();
+        for (int i = 0; i < size; i++) {
+            set.add(
+                    new RangeNotifier() {
+                        @Override
+                        public void didRangeBeaconsInRegion(Collection<Beacon> beacons, Region region) {
+                        }
+                    }
+            );
+        }
+        return set;
+    }
+
+    @Test
+    public void copyHashSet_Size1() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(SINGLE_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = new HashSet<>(SINGLE_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyHashSet_Size10() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(MEDIUM_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = new HashSet<>(MEDIUM_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyHashSet_Size20() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(LARGE_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = new HashSet<>(LARGE_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyHashSet_Size3() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(SMALL_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = new HashSet<>(SMALL_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyUnmodifiableSet_Size1() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(SINGLE_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = Collections.unmodifiableSet(SINGLE_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyUnmodifiableSet_Size10() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(MEDIUM_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = Collections.unmodifiableSet(MEDIUM_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyUnmodifiableSet_Size20() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(LARGE_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = Collections.unmodifiableSet(LARGE_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyUnmodifiableSet_Size3() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(SMALL_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = Collections.unmodifiableSet(SMALL_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    private void logStats(Set<?> set, double[] raw) {
+        DescriptiveStatistics descStats = new DescriptiveStatistics(raw);
+        Log.i(
+                TAG,
+                String.format(
+                        Locale.US,
+                        STAT_FORMAT,
+                        set.getClass().getSimpleName(),
+                        set.size(),
+                        descStats.getN(),
+                        Math.round(descStats.getMin()),
+                        Math.round(descStats.getMax()),
+                        Math.round(descStats.getMean()),
+                        descStats.getStandardDeviation(),
+                        descStats.getVariance()
+                )
+        );
+    }
+}
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index 2000a4d8..cc3f5ef6 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.BLUETOOTH" android:required="false"/>
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:required="false"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
-    <uses-permission-sdk-23 android:name="android.permission.ACCESS_COARSE_LOCATION"/>
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
 
     <application>
         <receiver android:name="org.altbeacon.beacon.startup.StartupBroadcastReceiver">
@@ -28,6 +28,8 @@
             android:exported="false"
             />
 
+        <service android:name=".service.ScanJob"
+                android:permission="android.permission.BIND_JOB_SERVICE" />
     </application>
 
 </manifest>
diff --git a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
index a0ace8a0..7e98d225 100644
--- a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
@@ -23,7 +23,6 @@
  */
 package org.altbeacon.beacon;
 
-import android.annotation.TargetApi;
 import android.bluetooth.BluetoothDevice;
 import android.util.Log;
 
@@ -63,7 +62,6 @@ public AltBeaconParser() {
      * @param device The Bluetooth device that was detected
      * @return An instance of an <code>Beacon</code>
      */
-    @TargetApi(5)
     @Override
     public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
         return fromScanData(scanData, rssi, device, new AltBeacon());
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index 35cfd9ea..8e1f183f 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -31,8 +31,10 @@
 import org.altbeacon.beacon.distance.DistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
+
 import java.util.List;
 
 /**
@@ -54,7 +56,7 @@
  * @author  David G. Young
  * @see     Region#matchesBeacon(Beacon Beacon)
  */
-public class Beacon implements Parcelable {
+public class Beacon implements Parcelable, Serializable {
     private static final String TAG = "Beacon";
 
     private static final List<Long> UNMODIFIABLE_LIST_OF_LONG =
@@ -168,6 +170,7 @@
      * Required for making object Parcelable.  If you override this class, you must provide an
      * equivalent version of this method.
      */
+    @Deprecated
     public static final Parcelable.Creator<Beacon> CREATOR
             = new Parcelable.Creator<Beacon>() {
         public Beacon createFromParcel(Parcel in) {
@@ -205,10 +208,15 @@ public static void setHardwareEqualityEnforced(boolean e) {
         sHardwareEqualityEnforced = e;
     }
 
+    public static boolean getHardwareEqualityEnforced() {
+        return sHardwareEqualityEnforced;
+    }
+
     /**
      * Required for making Beacon parcelable
      * @param in parcel
      */
+    @Deprecated
     protected Beacon(Parcel in) {
         int size = in.readInt();
 
@@ -228,9 +236,6 @@ protected Beacon(Parcel in) {
             mDataFields.add(in.readLong());
         }
         int extraDataSize = in.readInt();
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG, "reading "+extraDataSize+" extra data fields from parcel");
-        }
         this.mExtraDataFields = new ArrayList<Long>(extraDataSize);
         for (int i = 0; i < extraDataSize; i++) {
             mExtraDataFields.add(in.readLong());
@@ -279,6 +284,27 @@ public void setRunningAverageRssi(double rssi) {
         mDistance = null; // force calculation of accuracy and proximity next time they are requested
     }
 
+    /**
+     * @deprecated To be removed in a future release. Use
+     * {@link org.altbeacon.beacon.Beacon#getRunningAverageRssi()}
+     * instead.
+     */
+    @Deprecated
+    public double getRunningAverageRssi(double rssi) {
+        return mRunningAverageRssi = rssi;
+    }
+
+    /**
+     * Returns the running average rssi
+     * @return double
+     */
+    public double getRunningAverageRssi() {
+        if (mRunningAverageRssi != null){
+            return mRunningAverageRssi;
+        }
+        return mRssi;
+    }
+
     /**
      * Sets the most recently measured rssi for use in distance calculations if a running average is
      * not available
@@ -525,6 +551,7 @@ private StringBuilder toStringBuilder() {
     /**
      * Required for making object Parcelable
      */
+    @Deprecated
     public int describeContents() {
         return 0;
     }
@@ -533,9 +560,9 @@ public int describeContents() {
      * Required for making object Parcelable.  If you override this class, you must override this
      * method if you add any additional fields.
      */
+    @Deprecated
     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mIdentifiers.size());
-        LogManager.d(TAG, "serializing identifiers of size %s", mIdentifiers.size());
         for (Identifier identifier: mIdentifiers) {
             out.writeString(identifier == null ? null : identifier.toString());
         }
@@ -549,9 +576,6 @@ public void writeToParcel(Parcel out, int flags) {
         for (Long dataField: mDataFields) {
             out.writeLong(dataField);
         }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG, "writing "+mExtraDataFields.size()+" extra data fields to parcel");
-        }
         out.writeInt(mExtraDataFields.size());
         for (Long dataField: mExtraDataFields) {
             out.writeLong(dataField);
@@ -707,6 +731,16 @@ public Builder setRssi(int rssi) {
             return this;
         }
 
+        /**
+         * @see Beacon#mRssi
+         * @param rssi
+         * @return builder
+         */
+        public Builder setRunningAverageRssi(double rssi) {
+            mBeacon.mRunningAverageRssi = rssi;
+            return this;
+        }
+
         /**
          * @see Beacon#mTxPower
          * @param txPower
@@ -806,6 +840,7 @@ public Builder setMultiFrameBeacon(boolean multiFrameBeacon) {
             mBeacon.mMultiFrameBeacon = multiFrameBeacon;
             return this;
         }
+
     }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index 7b3c74ba..1f63462e 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -23,20 +23,32 @@
  */
 package org.altbeacon.beacon;
 
-import android.annotation.TargetApi;
 import android.app.IntentService;
 import android.content.Intent;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.MonitoringData;
+import org.altbeacon.beacon.service.MonitoringStatus;
 import org.altbeacon.beacon.service.RangingData;
 
 import java.util.Set;
 
 /**
  * Converts internal intents to notifier callbacks
+ *
+ * This is used with the BeaconService and supports scanning in a separate process.
+ * It is not used with the ScanJob, as an IntentService will not be able to be started in some cases
+ * where the app is in the background on Android O.
+ *
+ * @see BeaconLocalBroadcastProcessor for the equivalent use with ScanJob.
+ *
+ * This IntentService may be running in a different process from the BeaconService, which justifies
+ * its continued existence for multi-process service cases.
+ *
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
  */
-@TargetApi(3)
 public class BeaconIntentProcessor extends IntentService {
     private static final String TAG = "BeaconIntentProcessor";
 
@@ -46,51 +58,6 @@ public BeaconIntentProcessor() {
 
     @Override
     protected void onHandleIntent(Intent intent) {
-        LogManager.d(TAG, "got an intent to process");
-
-        MonitoringData monitoringData = null;
-        RangingData rangingData = null;
-
-        if (intent != null && intent.getExtras() != null) {
-            monitoringData = (MonitoringData) intent.getExtras().get("monitoringData");
-            rangingData = (RangingData) intent.getExtras().get("rangingData");
-        }
-
-        if (rangingData != null) {
-            LogManager.d(TAG, "got ranging data");
-            if (rangingData.getBeacons() == null) {
-                LogManager.w(TAG, "Ranging data has a null beacons collection");
-            }
-            Set<RangeNotifier> notifiers = BeaconManager.getInstanceForApplication(this).getRangingNotifiers();
-            java.util.Collection<Beacon> beacons = rangingData.getBeacons();
-            if (notifiers != null) {
-                for(RangeNotifier notifier : notifiers){
-                    notifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
-                }
-            }
-            else {
-                LogManager.d(TAG, "but ranging notifier is null, so we're dropping it.");
-            }
-            RangeNotifier dataNotifier = BeaconManager.getInstanceForApplication(this).getDataRequestNotifier();
-            if (dataNotifier != null) {
-                dataNotifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
-            }
-        }
-
-        if (monitoringData != null) {
-            LogManager.d(TAG, "got monitoring data");
-            Set<MonitorNotifier> notifiers = BeaconManager.getInstanceForApplication(this).getMonitoringNotifiers();
-            if (notifiers != null) {
-                for(MonitorNotifier notifier : notifiers) {
-                    LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
-                    notifier.didDetermineStateForRegion(monitoringData.isInside() ? MonitorNotifier.INSIDE : MonitorNotifier.OUTSIDE, monitoringData.getRegion());
-                    if (monitoringData.isInside()) {
-                        notifier.didEnterRegion(monitoringData.getRegion());
-                    } else {
-                        notifier.didExitRegion(monitoringData.getRegion());
-                    }
-                }
-            }
-        }
+        new IntentHandler().convertIntentsToCallbacks(this.getApplicationContext(), intent);
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
new file mode 100644
index 00000000..8794252c
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
@@ -0,0 +1,92 @@
+/**
+ * Radius Networks, Inc.
+ * http://www.radiusnetworks.com
+ *
+ * @author David G. Young
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.altbeacon.beacon;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.annotation.NonNull;
+import android.support.v4.content.LocalBroadcastManager;
+
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.Set;
+
+/**
+ * Converts internal intents to notifier callbacks
+ *
+ * This is used with ScanJob and supports delivering intents even under Android O background
+ * restrictions preventing starting a new IntentService.
+ *
+ * It is not used with the BeaconService, as local broadcast intents cannot be deliverd across
+ * different processes which the BeaconService supports.
+ *
+ * @see BeaconIntentProcessor for the equivalent use with BeaconService.
+ **
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
+ */
+public class BeaconLocalBroadcastProcessor {
+    private static final String TAG = "BeaconLocalBroadcastProcessor";
+
+    public static final String RANGE_NOTIFICATION = "org.altbeacon.beacon.range_notification";
+    public static final String MONITOR_NOTIFICATION = "org.altbeacon.beacon.monitor_notification";
+
+    @NonNull
+    private Context mContext;
+    private BeaconLocalBroadcastProcessor() {
+
+    }
+    public BeaconLocalBroadcastProcessor(Context context) {
+        mContext = context;
+
+    }
+
+    static int registerCallCount = 0;
+    int registerCallCountForInstnace = 0;
+    public void register() {
+        registerCallCount += 1;
+        registerCallCountForInstnace += 1;
+        LogManager.d(TAG, "Register calls: global="+registerCallCount+" instance="+registerCallCountForInstnace);
+        unregister();
+        LocalBroadcastManager.getInstance(mContext).registerReceiver(mLocalBroadcastReceiver,
+                new IntentFilter(RANGE_NOTIFICATION));
+        LocalBroadcastManager.getInstance(mContext).registerReceiver(mLocalBroadcastReceiver,
+                new IntentFilter(MONITOR_NOTIFICATION));
+    }
+
+    public void unregister() {
+        LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mLocalBroadcastReceiver);
+    }
+
+
+    private BroadcastReceiver mLocalBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            new IntentHandler().convertIntentsToCallbacks(context, intent);
+        }
+    };
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index e4b8cad8..ea265428 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -30,25 +30,36 @@
 import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Build;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
 import android.os.RemoteException;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
 import org.altbeacon.beacon.service.BeaconService;
+import org.altbeacon.beacon.service.Callback;
 import org.altbeacon.beacon.service.MonitoringStatus;
 import org.altbeacon.beacon.service.RangeState;
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanJobScheduler;
+import org.altbeacon.beacon.service.ScanState;
+import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.simulator.BeaconSimulator;
+import org.altbeacon.beacon.utils.ProcessUtils;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -58,6 +69,9 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CopyOnWriteArraySet;
 
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanState;
+
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
@@ -105,25 +119,55 @@
  * @author David G. Young
  * @author Andrew Reitz <andrew@andrewreitz.com>
  */
-@TargetApi(4)
 public class BeaconManager {
+    @NonNull
     private static final String TAG = "BeaconManager";
-    private Context mContext;
-    protected static BeaconManager client = null;
-    private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<BeaconConsumer,ConsumerInfo>();
+
+    @NonNull
+    private final Context mContext;
+
+    @Nullable
+    protected static volatile BeaconManager sInstance = null;
+
+    @NonNull
+    private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<>();
+
+    @Nullable
     private Messenger serviceMessenger = null;
+
+    @NonNull
     protected final Set<RangeNotifier> rangeNotifiers = new CopyOnWriteArraySet<>();
+
+    @Nullable
     protected RangeNotifier dataRequestNotifier = null;
+
+    @NonNull
     protected final Set<MonitorNotifier> monitorNotifiers = new CopyOnWriteArraySet<>();
-    private final ArrayList<Region> rangedRegions = new ArrayList<Region>();
+
+    @NonNull
+    private final ArrayList<Region> rangedRegions = new ArrayList<>();
+
+    @NonNull
     private final List<BeaconParser> beaconParsers = new CopyOnWriteArrayList<>();
+
+    @Nullable
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+    private boolean mRegionStatePersistenceEnabled = true;
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
-
+    private boolean mMainProcess = false;
+    @Nullable
+    private Boolean mScannerInSameProcess = null;
+    private boolean mScheduledScanJobsEnabled = false;
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
 
+    /**
+     * Private lock object for singleton initialization protecting against denial-of-service attack.
+     */
+    private static final Object SINGLETON_LOCK = new Object();
+
     /**
      * Set to true if you want to show library debugging.
      *
@@ -224,6 +268,10 @@ public void setBackgroundBetweenScanPeriod(long p) {
      */
     public static void setRegionExitPeriod(long regionExitPeriod){
         sExitRegionPeriod = regionExitPeriod;
+        BeaconManager instance = sInstance;
+        if (instance != null) {
+            instance.applySettings();
+        }
     }
     
     /**
@@ -239,27 +287,90 @@ public static long getRegionExitPeriod(){
      * An accessor for the singleton instance of this class.  A context must be provided, but if you need to use it from a non-Activity
      * or non-Service class, you can attach it to another singleton or a subclass of the Android Application class.
      */
-    public static BeaconManager getInstanceForApplication(Context context) {
-        if (client == null) {
-            LogManager.d(TAG, "BeaconManager instance creation");
-            client = new BeaconManager(context);
+    @NonNull
+    public static BeaconManager getInstanceForApplication(@NonNull Context context) {
+        /*
+         * Follow double check pattern from Effective Java v2 Item 71.
+         *
+         * Bloch recommends using the local variable for this for performance reasons:
+         *
+         * > What this variable does is ensure that `field` is read only once in the common case
+         * > where it's already initialized. While not strictly necessary, this may improve
+         * > performance and is more elegant by the standards applied to low-level concurrent
+         * > programming. On my machine, [this] is about 25 percent faster than the obvious
+         * > version without a local variable.
+         *
+         * Joshua Bloch. Effective Java, Second Edition. Addison-Wesley, 2008. pages 283-284
+         */
+        BeaconManager instance = sInstance;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = sInstance;
+                if (instance == null) {
+                    sInstance = instance = new BeaconManager(context);
+                }
+            }
         }
-        return client;
+        return instance;
     }
 
-   protected BeaconManager(Context context) {
-      mContext = context.getApplicationContext();
-      if (!sManifestCheckingDisabled) {
-         verifyServiceDeclaration();
-      }
-      this.beaconParsers.add(new AltBeaconParser());
-   }
+    protected BeaconManager(@NonNull Context context) {
+        mContext = context.getApplicationContext();
+        checkIfMainProcess();
+        if (!sManifestCheckingDisabled) {
+           verifyServiceDeclaration();
+         }
+        this.beaconParsers.add(new AltBeaconParser());
+        mScheduledScanJobsEnabled = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O;
+    }
+
+    /***
+     * Determines if this BeaconManager instance is associated with the main application process that
+     * hosts the user interface.  This is normally true unless the scanning service or another servide
+     * is running in a separate process.
+     * @return
+     */
+    public boolean isMainProcess() {
+        return mMainProcess;
+    }
+
+    /**
+     * 
+     * Determines if this BeaconManager instance is not part of the process hosting the beacon scanning
+     * service.  This is normally false, except when scanning is hosted in a different process.
+     * This will always return false until the scanning service starts up, at which time it will be
+     * known if it is in a different process.
+     *
+     * @return
+     */
+    public boolean isScannerInDifferentProcess() {
+        // may be null if service not started yet, so explicitly check
+        return mScannerInSameProcess != null && !mScannerInSameProcess;
+    }
+
+    /**
+     * Reserved for internal use by the library.
+     * @hide
+     */
+    public void setScannerInSameProcess(boolean isScanner) {
+        mScannerInSameProcess = isScanner;
+    }
+
+    protected void checkIfMainProcess() {
+        ProcessUtils processUtils = new ProcessUtils(mContext);
+        String processName = processUtils.getProcessName();
+        String packageName = processUtils.getPackageName();
+        int pid = processUtils.getPid();
+        mMainProcess = processUtils.isMainProcess();
+        LogManager.i(TAG, "BeaconManager started up on pid "+pid+" named '"+processName+"' for application package '"+packageName+"'.  isMainProcess="+mMainProcess);
+    }
 
    /**
      * Gets a list of the active beaconParsers.
      *
      * @return list of active BeaconParsers
      */
+   @NonNull
     public List<BeaconParser> getBeaconParsers() {
         return beaconParsers;
     }
@@ -272,17 +383,10 @@ protected BeaconManager(Context context) {
      */
     @TargetApi(18)
     public boolean checkAvailability() throws BleNotAvailableException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            throw new BleNotAvailableException("Bluetooth LE not supported by this device");
-        }
-        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+        if (!isBleAvailable()) {
             throw new BleNotAvailableException("Bluetooth LE not supported by this device");
-        } else {
-            if (((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled()) {
-                return true;
-            }
         }
-        return false;
+        return ((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled();
     }
 
     /**
@@ -292,9 +396,13 @@ public boolean checkAvailability() throws BleNotAvailableException {
      *
      * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
      */
-    public void bind(BeaconConsumer consumer) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+    public void bind(@NonNull BeaconConsumer consumer) {
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
+        }
+        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            LogManager.w(TAG, "This device does not support bluetooth LE.  Will not start beacon scanning.");
             return;
         }
         synchronized (consumers) {
@@ -304,9 +412,16 @@ public void bind(BeaconConsumer consumer) {
                 LogManager.d(TAG, "This consumer is already bound");
             }
             else {
-                LogManager.d(TAG, "This consumer is not bound.  binding: %s", consumer);
-                Intent intent = new Intent(consumer.getApplicationContext(), BeaconService.class);
-                consumer.bindService(intent, newConsumerInfo.beaconServiceConnection, Context.BIND_AUTO_CREATE);
+                LogManager.d(TAG, "This consumer is not bound.  Binding now: %s", consumer);
+                if (mScheduledScanJobsEnabled) {
+                    LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
+                    consumer.onBeaconServiceConnect();
+                }
+                else {
+                    LogManager.d(TAG, "Binding to service");
+                    Intent intent = new Intent(consumer.getApplicationContext(), BeaconService.class);
+                    consumer.bindService(intent, newConsumerInfo.beaconServiceConnection, Context.BIND_AUTO_CREATE);
+                }
                 LogManager.d(TAG, "consumer count is now: %s", consumers.size());
             }
         }
@@ -318,15 +433,20 @@ public void bind(BeaconConsumer consumer) {
      *
      * @param consumer the <code>Activity</code> or <code>Service</code> that no longer needs to use the service.
      */
-    public void unbind(BeaconConsumer consumer) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+    public void unbind(@NonNull BeaconConsumer consumer) {
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
         synchronized (consumers) {
             if (consumers.containsKey(consumer)) {
                 LogManager.d(TAG, "Unbinding");
-                consumer.unbindService(consumers.get(consumer).beaconServiceConnection);
+                if (mScheduledScanJobsEnabled) {
+                    LogManager.d(TAG, "Not unbinding from scanning service as we are using scan jobs.");
+                }
+                else {
+                    consumer.unbindService(consumers.get(consumer).beaconServiceConnection);
+                }
                 consumers.remove(consumer);
                 if (consumers.size() == 0) {
                     // If this is the last consumer to disconnect, the service will exit
@@ -336,6 +456,11 @@ public void unbind(BeaconConsumer consumer) {
                     // This way when we restart ranging or monitoring it will always be in
                     // foreground mode
                     mBackgroundMode = false;
+                    // If we are using scan jobs, we cancel the active scan job
+                    if (mScheduledScanJobsEnabled) {
+                        // TODO: Cancel the active scan job.  Without this is keeps scanning as if
+                        // a consumer is bound.
+                    }
                 }
             }
             else {
@@ -355,8 +480,10 @@ public void unbind(BeaconConsumer consumer) {
      * @param consumer
      * @return
      */
-    public boolean isBound(BeaconConsumer consumer) {
+    public boolean isBound(@NonNull BeaconConsumer consumer) {
         synchronized(consumers) {
+            // Annotation doesn't guarantee we get a non-null, but raising an NPE here is excessive
+            //noinspection ConstantConditions
             return consumer != null && consumers.get(consumer) != null && (serviceMessenger != null);
         }
     }
@@ -368,7 +495,7 @@ public boolean isBound(BeaconConsumer consumer) {
      */
     public boolean isAnyConsumerBound() {
         synchronized(consumers) {
-            return consumers.size() > 0 && (serviceMessenger != null);
+            return consumers.isEmpty() && (serviceMessenger != null);
         }
     }
 
@@ -392,8 +519,9 @@ public boolean isAnyConsumerBound() {
      * @see #setBackgroundBetweenScanPeriod(long p)
      */
     public void setBackgroundMode(boolean backgroundMode) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
         }
         mBackgroundModeUninitialized = false;
         if (backgroundMode != mBackgroundMode) {
@@ -406,6 +534,55 @@ public void setBackgroundMode(boolean backgroundMode) {
         }
     }
 
+    /**
+     * Configures using a `ScanJob` run with the `JobScheduler` to perform scans rather than using a
+     * long-running `BeaconService` to do so.
+     *
+     * Calling with true on devices older than Android L (5.0) will not apply the change
+     * as the JobScheduler is not available.
+     *
+     * This value defaults to true on Android O+ and false on devices with older OS versions.
+     * Accepting the default value of false is recommended on Android N and earlier because
+     * otherwise beacon scans may be run only once every 15 minutes in the background, and no low
+     * power scans may be performed between scanning cycles.
+     *
+     * This method may only be called if bind() has not yet been called, otherwise an
+     * `IllegalStateException` is thown.
+     *
+     * @param enabled
+     */
+    public void setEnableScheduledScanJobs(boolean enabled) {
+        if (isAnyConsumerBound()) {
+            LogManager.e(TAG, "ScanJob may not be configured because a consumer is" +
+                    " already bound.");
+            throw new IllegalStateException("Method must be called before calling bind()");
+        }
+        if (enabled && android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            LogManager.e(TAG, "ScanJob may not be configured because JobScheduler is not" +
+                    " availble prior to Android 5.0");
+            return;
+        }
+        mScheduledScanJobsEnabled = enabled;
+    }
+    public boolean getScheduledScanJobsEnabled() {
+        return mScheduledScanJobsEnabled;
+    }
+    public boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+    public long getBackgroundScanPeriod() {
+        return backgroundScanPeriod;
+    }
+    public long getBackgroundBetweenScanPeriod() {
+        return backgroundBetweenScanPeriod;
+    }
+    public long getForegroundScanPeriod() {
+        return foregroundScanPeriod;
+    }
+    public long getForegroundBetweenScanPeriod() {
+        return foregroundBetweenScanPeriod;
+    }
+
     /**
      * @return indicator of whether any calls have yet been made to set the
      * background mode
@@ -427,11 +604,11 @@ public boolean isBackgroundModeUninitialized() {
      * @deprecated replaced by (@link #addRangeNotifier)
      */
     @Deprecated
-    public void setRangeNotifier(RangeNotifier notifier) {
-        synchronized (rangeNotifiers) {
-            rangeNotifiers.clear();
+    public void setRangeNotifier(@Nullable RangeNotifier notifier) {
+        rangeNotifiers.clear();
+        if (null != notifier) {
+            addRangeNotifier(notifier);
         }
-        addRangeNotifier(notifier);
     }
 
     /**
@@ -445,11 +622,10 @@ public void setRangeNotifier(RangeNotifier notifier) {
      * @param notifier The {@link RangeNotifier} to register.
      * @see RangeNotifier
      */
-    public void addRangeNotifier(RangeNotifier notifier) {
+    public void addRangeNotifier(@NonNull RangeNotifier notifier) {
+        //noinspection ConstantConditions
         if (notifier != null) {
-            synchronized (rangeNotifiers) {
-                rangeNotifiers.add(notifier);
-            }
+            rangeNotifiers.add(notifier);
         }
     }
 
@@ -459,19 +635,15 @@ public void addRangeNotifier(RangeNotifier notifier) {
      * @param notifier The {@link RangeNotifier} to unregister.
      * @see RangeNotifier
      */
-    public boolean removeRangeNotifier(RangeNotifier notifier) {
-        synchronized (rangeNotifiers) {
-            return rangeNotifiers.remove(notifier);
-        }
+    public boolean removeRangeNotifier(@NonNull RangeNotifier notifier) {
+        return rangeNotifiers.remove(notifier);
     }
 
     /**
      * Remove all the Range Notifiers.
      */
     public void removeAllRangeNotifiers() {
-        synchronized (rangeNotifiers) {
-            rangeNotifiers.clear();
-        }
+        rangeNotifiers.clear();
     }
 
     /**
@@ -489,11 +661,14 @@ public void removeAllRangeNotifiers() {
      * @deprecated replaced by {@link #addMonitorNotifier}
      */
     @Deprecated
-    public void setMonitorNotifier(MonitorNotifier notifier) {
-        synchronized (monitorNotifiers) {
-            monitorNotifiers.clear();
+    public void setMonitorNotifier(@Nullable MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        monitorNotifiers.clear();
+        if (null != notifier) {
+            addMonitorNotifier(notifier);
         }
-        addMonitorNotifier(notifier);
     }
 
     /**
@@ -509,11 +684,13 @@ public void setMonitorNotifier(MonitorNotifier notifier) {
      * @see #startMonitoringBeaconsInRegion(Region)
      * @see Region
      */
-    public void addMonitorNotifier(MonitorNotifier notifier) {
+    public void addMonitorNotifier(@NonNull MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        //noinspection ConstantConditions
         if (notifier != null) {
-            synchronized (monitorNotifiers) {
-                monitorNotifiers.add(notifier);
-            }
+            monitorNotifiers.add(notifier);
         }
     }
 
@@ -522,7 +699,7 @@ public void addMonitorNotifier(MonitorNotifier notifier) {
      * @deprecated Misspelled. Replaced by {@link #removeMonitorNotifier}
      */
     @Deprecated
-    public boolean removeMonitoreNotifier(MonitorNotifier notifier) {
+    public boolean removeMonitoreNotifier(@NonNull MonitorNotifier notifier) {
         return removeMonitorNotifier(notifier);
     }
 
@@ -534,19 +711,21 @@ public boolean removeMonitoreNotifier(MonitorNotifier notifier) {
      * @see #startMonitoringBeaconsInRegion(Region)
      * @see Region
      */
-    public boolean removeMonitorNotifier(MonitorNotifier notifier) {
-        synchronized (monitorNotifiers) {
-            return monitorNotifiers.remove(notifier);
+    public boolean removeMonitorNotifier(@NonNull MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return false;
         }
+        return monitorNotifiers.remove(notifier);
     }
 
     /**
      * Remove all the Monitor Notifiers.
      */
     public void removeAllMonitorNotifiers() {
-        synchronized (monitorNotifiers) {
-            monitorNotifiers.clear();
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
+        monitorNotifiers.clear();
     }
 
     /**
@@ -568,11 +747,23 @@ public void setRegionStatePeristenceEnabled(boolean enabled) {
      * @param enabled true to enable the region state persistence, false to disable it.
      */
     public void setRegionStatePersistenceEnabled(boolean enabled) {
-        if (enabled) {
-            MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
-        } else {
-            MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+        mRegionStatePersistenceEnabled = enabled;
+        if (!isScannerInDifferentProcess()) {
+            if (enabled) {
+                MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
+            } else {
+                MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+            }
         }
+        this.applySettings();
+    }
+
+    /**
+     * Indicates whether region state preservation is enabled
+     * @return
+     */
+    public boolean isRegionStatePersistenceEnabled() {
+        return mRegionStatePersistenceEnabled;
     }
 
     /**
@@ -581,17 +772,18 @@ public void setRegionStatePersistenceEnabled(boolean enabled) {
      * method.  If it is not a monitored region, it will be ignored.
      * @param region
      */
-    public void requestStateForRegion(Region region) {
+    public void requestStateForRegion(@NonNull Region region) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         MonitoringStatus status = MonitoringStatus.getInstanceForApplication(mContext);
         RegionMonitoringState stateObj = status.stateOf(region);
         int state = MonitorNotifier.OUTSIDE;
         if (stateObj != null && stateObj.getInside()) {
             state = MonitorNotifier.INSIDE;
         }
-        synchronized (monitorNotifiers) {
-            for (MonitorNotifier notifier: monitorNotifiers) {
-                notifier.didDetermineStateForRegion(state, region);
-            }
+        for (MonitorNotifier notifier : monitorNotifiers) {
+            notifier.didDetermineStateForRegion(state, region);
         }
     }
 
@@ -608,21 +800,18 @@ public void requestStateForRegion(Region region) {
      * @see Region
      */
     @TargetApi(18)
-    public void startRangingBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+    public void startRangingBeaconsInRegion(@NonNull Region region) throws RemoteException {
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
-        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             rangedRegions.add(region);
         }
+        applyChangesToServices(BeaconService.MSG_START_RANGING, region);
     }
 
     /**
@@ -636,18 +825,14 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
      * @see Region
      */
     @TargetApi(18)
-    public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+    public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteException {
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
-        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             Region regionToRemove = null;
             for (Region rangedRegion : rangedRegions) {
@@ -657,6 +842,38 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             }
             rangedRegions.remove(regionToRemove);
         }
+        applyChangesToServices(BeaconService.MSG_STOP_RANGING, region);
+    }
+
+    /**
+     * Call this method if you are running the scanner service in a different process in order to
+     * synchronize any configuration settings, including BeaconParsers to the scanner
+     * @see #isScannerInDifferentProcess()
+     */
+    public void applySettings() {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        if (!isAnyConsumerBound()) {
+            LogManager.d(TAG, "Not synchronizing settings to service, as it has not started up yet");
+        } else if (isScannerInDifferentProcess()) {
+            LogManager.d(TAG, "Synchronizing settings to service");
+            syncSettingsToService();
+        } else {
+            LogManager.d(TAG, "Not synchronizing settings to service, as it is in the same process");
+        }
+    }
+
+    protected void syncSettingsToService() {
+        if (mScheduledScanJobsEnabled) {
+            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            return;
+        }
+        try {
+            applyChangesToServices(BeaconService.MSG_SYNC_SETTINGS, null);
+        } catch (RemoteException e) {
+            LogManager.e(TAG, "Failed to sync settings to service", e);
+        }
     }
 
     /**
@@ -671,19 +888,22 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
      * @see Region
      */
     @TargetApi(18)
-    public void startMonitoringBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+    public void startMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteException {
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        if (mScheduledScanJobsEnabled) {
+            MonitoringStatus.getInstanceForApplication(mContext).addRegion(region, new Callback(callbackPackageName()));
+        }
+        applyChangesToServices(BeaconService.MSG_START_MONITORING, region);
+
+        if (isScannerInDifferentProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
         }
-        LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
-        Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
-        serviceMessenger.send(msg);
         this.requestStateForRegion(region);
     }
 
@@ -699,21 +919,23 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
      * @see Region
      */
     @TargetApi(18)
-    public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+    public void stopMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteException {
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        if (mScheduledScanJobsEnabled) {
+            MonitoringStatus.getInstanceForApplication(mContext).removeRegion(region);
+        }
+        applyChangesToServices(BeaconService.MSG_STOP_MONITORING, region);
+        if (isScannerInDifferentProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
-        serviceMessenger.send(msg);
     }
 
-
     /**
      * Updates an already running scan with scanPeriod/betweenScanPeriod according to Background/Foreground state.
      * Change will take effect on the start of the next scan cycle.
@@ -722,18 +944,37 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
      */
     @TargetApi(18)
     public void updateScanPeriods() throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
         LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
         LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
-        StartRMData obj = new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        applyChangesToServices(BeaconService.MSG_SET_SCAN_PERIODS, null);
+    }
+
+    @TargetApi(18)
+    private void applyChangesToServices(int type, Region region) throws RemoteException {
+        if (mScheduledScanJobsEnabled) {
+            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            return;
+        }
+        if (serviceMessenger == null) {
+            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        }
+        Message msg = Message.obtain(null, type, 0, 0);
+        if (type == BeaconService.MSG_SET_SCAN_PERIODS) {
+            msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+        }
+        else if (type == BeaconService.MSG_SYNC_SETTINGS) {
+            msg.setData(new SettingsData().collect(mContext).toBundle());
+        }
+        else {
+            msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(), mBackgroundMode).toBundle());
+        }
         serviceMessenger.send(msg);
     }
 
@@ -748,20 +989,33 @@ private String callbackPackageName() {
      * @deprecated replaced by (@link #getMonitorNotifiers)
      */
     @Deprecated
+    @Nullable
     public MonitorNotifier getMonitoringNotifier() {
-        synchronized (monitorNotifiers) {
-            if (monitorNotifiers.size() > 0) {
-                return monitorNotifiers.iterator().next();
-            }
-            return null;
+        Iterator<MonitorNotifier> iterator = monitorNotifiers.iterator();
+        if (iterator.hasNext()) {
+            return iterator.next();
         }
+        return null;
     }
 
     /**
-     * @return the list of registered monitorNotifier
+     * Read-only access to the registered {@link MonitorNotifier} instances
+     * <p>
+     * This provides a thread-safe "read-only" view of the {@link Set} of registered monitor
+     * notifiers. Attempts to modify the returned set, or its iterator, will throw an
+     * {@link UnsupportedOperationException}. Modifications to the underlying set should be made
+     * through {@link #addMonitorNotifier(MonitorNotifier)} and
+     * {@link #removeMonitorNotifier(MonitorNotifier)}.
+     *
+     * @return a thread-safe {@linkplain Collections#unmodifiableSet(Set) unmodifiable view}
+     * providing "read-only" access to the registered {@link MonitorNotifier} instances
+     * @see #addMonitorNotifier(MonitorNotifier)
+     * @see #removeMonitorNotifier(MonitorNotifier)
+     * @see Collections#unmodifiableSet(Set)
      */
+    @NonNull
     public Set<MonitorNotifier> getMonitoringNotifiers(){
-        return monitorNotifiers;
+        return Collections.unmodifiableSet(monitorNotifiers);
     }
 
     /**
@@ -769,25 +1023,39 @@ public MonitorNotifier getMonitoringNotifier() {
      * @deprecated replaced by (@link #getRangeNotifiers)
      */
     @Deprecated
+    @Nullable
     public RangeNotifier getRangingNotifier() {
-        synchronized (rangeNotifiers) {
-            if (rangeNotifiers.size() > 0) {
-                return rangeNotifiers.iterator().next();
-            }
-            return null;
+        Iterator<RangeNotifier> iterator = rangeNotifiers.iterator();
+        if (iterator.hasNext()) {
+            return iterator.next();
         }
+        return null;
     }
 
     /**
-     * @return the list of registered rangeNotifier
+     * Read-only access to the registered {@link RangeNotifier} instances
+     * <p>
+     * This provides a thread-safe "read-only" view of the {@link Set} of registered range
+     * notifiers. Attempts to modify the returned set, or its iterator, will throw an
+     * {@link UnsupportedOperationException}. Modifications to the underlying set should be made
+     * through {@link #addRangeNotifier(RangeNotifier)} and
+     * {@link #removeRangeNotifier(RangeNotifier)}.
+     *
+     * @return a thread-safe {@linkplain Collections#unmodifiableSet(Set) unmodifiable view}
+     * providing "read-only" access to the registered {@link RangeNotifier} instances
+     * @see #addRangeNotifier(RangeNotifier)
+     * @see #removeRangeNotifier(RangeNotifier)
+     * @see Collections#unmodifiableSet(Set)
      */
+    @NonNull
     public Set<RangeNotifier> getRangingNotifiers() {
-        return rangeNotifiers;
+        return Collections.unmodifiableSet(rangeNotifiers);
     }
 
     /**
      * @return the list of regions currently being monitored
      */
+    @NonNull
     public Collection<Region> getMonitoredRegions() {
         return MonitoringStatus.getInstanceForApplication(mContext).regions();
     }
@@ -795,9 +1063,10 @@ public RangeNotifier getRangingNotifier() {
     /**
      * @return the list of regions currently being ranged
      */
+    @NonNull
     public Collection<Region> getRangedRegions() {
         synchronized(this.rangedRegions) {
-            return new ArrayList<Region>(this.rangedRegions);
+            return new ArrayList<>(this.rangedRegions);
         }
     }
 
@@ -829,6 +1098,7 @@ public static void logDebug(String tag, String message, Throwable t) {
         LogManager.d(t, tag, message);
     }
 
+    @Nullable
     protected static BeaconSimulator beaconSimulator;
 
     protected static String distanceModelUpdateUrl = "http://data.altbeacon.org/android-distance.json";
@@ -837,7 +1107,8 @@ public static String getDistanceModelUpdateUrl() {
         return distanceModelUpdateUrl;
     }
 
-    public static void setDistanceModelUpdateUrl(String url) {
+    public static void setDistanceModelUpdateUrl(@NonNull String url) {
+        warnIfScannerNotInSameProcess();
         distanceModelUpdateUrl = url;
     }
 
@@ -846,7 +1117,8 @@ public static void setDistanceModelUpdateUrl(String url) {
      */
     protected static Class rssiFilterImplClass = RunningAverageRssiFilter.class;
 
-    public static void setRssiFilterImplClass(Class c) {
+    public static void setRssiFilterImplClass(@NonNull Class c) {
+        warnIfScannerNotInSameProcess();
         rssiFilterImplClass = c;
     }
 
@@ -860,6 +1132,9 @@ public static Class getRssiFilterImplClass() {
      */
     public static void setUseTrackingCache(boolean useTrackingCache) {
         RangeState.setUseTrackingCache(useTrackingCache);
+        if (sInstance != null) {
+            sInstance.applySettings();
+        }
     }
 
     /**
@@ -872,30 +1147,46 @@ public void setMaxTrackingAge(int maxTrackingAge) {
     }
 
     public static void setBeaconSimulator(BeaconSimulator beaconSimulator) {
+        warnIfScannerNotInSameProcess();
         BeaconManager.beaconSimulator = beaconSimulator;
     }
 
+    @Nullable
     public static BeaconSimulator getBeaconSimulator() {
         return BeaconManager.beaconSimulator;
     }
 
 
-    protected void setDataRequestNotifier(RangeNotifier notifier) {
+    protected void setDataRequestNotifier(@Nullable RangeNotifier notifier) {
         this.dataRequestNotifier = notifier;
     }
 
+    @Nullable
     protected RangeNotifier getDataRequestNotifier() {
         return this.dataRequestNotifier;
     }
 
+    @Nullable
     public NonBeaconLeScanCallback getNonBeaconLeScanCallback() {
         return mNonBeaconLeScanCallback;
     }
 
-    public void setNonBeaconLeScanCallback(NonBeaconLeScanCallback callback) {
+    public void setNonBeaconLeScanCallback(@Nullable NonBeaconLeScanCallback callback) {
         mNonBeaconLeScanCallback = callback;
     }
 
+    private boolean isBleAvailable() {
+        boolean available = false;
+        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            LogManager.w(TAG, "Bluetooth LE not supported prior to API 18.");
+        } else if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            LogManager.w(TAG, "This device does not support bluetooth LE.");
+        } else {
+            available = true;
+        }
+        return available;
+    }
+
     private long getScanPeriod() {
         if (mBackgroundMode) {
             return backgroundScanPeriod;
@@ -915,16 +1206,18 @@ private long getBetweenScanPeriod() {
     private void verifyServiceDeclaration() {
         final PackageManager packageManager = mContext.getPackageManager();
         final Intent intent = new Intent(mContext, BeaconService.class);
-        List resolveInfo =
+        List<ResolveInfo> resolveInfo =
                 packageManager.queryIntentServices(intent,
                         PackageManager.MATCH_DEFAULT_ONLY);
-        if (resolveInfo.size() == 0) {
+        if (resolveInfo != null && resolveInfo.isEmpty()) {
             throw new ServiceNotDeclaredException();
         }
     }
 
     private class ConsumerInfo {
         public boolean isConnected = false;
+
+        @NonNull
         public BeaconServiceConnection beaconServiceConnection;
 
         public ConsumerInfo() {
@@ -940,7 +1233,12 @@ private BeaconServiceConnection() {
         // Called when the connection with the service is established
         public void onServiceConnected(ComponentName className, IBinder service) {
             LogManager.d(TAG, "we have a connection to the service now");
+            if (mScannerInSameProcess == null) {
+                mScannerInSameProcess = false;
+            }
             serviceMessenger = new Messenger(service);
+            // This will sync settings to the scanning service if it is in a different process
+            applySettings();
             synchronized(consumers) {
                 Iterator<Map.Entry<BeaconConsumer, ConsumerInfo>> iter = consumers.entrySet().iterator();
                 while (iter.hasNext()) {
@@ -986,6 +1284,20 @@ public static boolean isAndroidLScanningDisabled() {
      */
     public static void setAndroidLScanningDisabled(boolean disabled) {
         sAndroidLScanningDisabled = disabled;
+        BeaconManager instance = sInstance;
+        if (instance != null) {
+            instance.applySettings();
+        }
+    }
+
+    /**
+     * Deprecated misspelled method
+     * @see #setManifestCheckingDisabled(boolean)
+     * @param disabled
+     */
+    @Deprecated
+    public static void setsManifestCheckingDisabled(boolean disabled) {
+        sManifestCheckingDisabled = disabled;
     }
 
     /**
@@ -994,7 +1306,33 @@ public static void setAndroidLScanningDisabled(boolean disabled) {
      *
      * @param disabled
      */
-    public static void setsManifestCheckingDisabled(boolean disabled) {
+    public static void setManifestCheckingDisabled(boolean disabled) {
         sManifestCheckingDisabled = disabled;
     }
+
+    /**
+     * Returns whether manifest checking is disabled
+     */
+    public static boolean getManifestCheckingDisabled() {
+        return sManifestCheckingDisabled;
+    }
+
+    private boolean determineIfCalledFromSeparateScannerProcess() {
+        if (isScannerInDifferentProcess() && !isMainProcess()) {
+            LogManager.w(TAG, "Ranging/Monitoring may not be controlled from a separate "+
+                    "BeaconScanner process.  To remove this warning, please wrap this call in:"+
+                    " if (beaconManager.isMainProcess())");
+            return true;
+        }
+        return false;
+    }
+
+    private static void warnIfScannerNotInSameProcess() {
+        BeaconManager instance = sInstance;
+        if (instance != null && instance.isScannerInDifferentProcess()) {
+            LogManager.w(TAG,
+                    "Unsupported configuration change made for BeaconScanner in separate process");
+        }
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index 611a5fa7..8591db4e 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -9,6 +9,7 @@
 import org.altbeacon.bluetooth.BleAdvertisement;
 import org.altbeacon.bluetooth.Pdu;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -36,7 +37,7 @@
  * </p>
  *
  */
-public class BeaconParser {
+public class BeaconParser implements Serializable {
     private static final String TAG = "BeaconParser";
     public static final String ALTBEACON_LAYOUT = "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25";
     public static final String EDDYSTONE_TLM_LAYOUT = "x,s:0-1=feaa,m:2-2=20,d:3-3,d:4-5,d:6-7,d:8-11,d:12-15";
@@ -53,6 +54,7 @@
     private static final String LITTLE_ENDIAN_SUFFIX = "l";
     private static final String VARIABLE_LENGTH_SUFFIX = "v";
 
+    protected String mBeaconLayout;
     private Long mMatchingBeaconTypeCode;
     protected final List<Integer> mIdentifierStartOffsets = new ArrayList<Integer>();
     protected final List<Integer> mIdentifierEndOffsets = new ArrayList<Integer>();
@@ -165,7 +167,7 @@ public BeaconParser(String identifier) {
      * @return the BeaconParser instance
      */
     public BeaconParser setBeaconLayout(String beaconLayout) {
-
+        mBeaconLayout = beaconLayout;
         Log.d(TAG, "Parsing beacon layout: "+beaconLayout);
 
         String[] terms =  beaconLayout.split(",");
@@ -412,12 +414,10 @@ public int getServiceUuidEndOffset() {
      * @param device The Bluetooth device that was detected
      * @return An instance of a <code>Beacon</code>
      */
-    @TargetApi(5)
     public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
         return fromScanData(scanData, rssi, device, new Beacon());
     }
 
-    @TargetApi(5)
     protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice device, Beacon beacon) {
         BleAdvertisement advert = new BleAdvertisement(bytesToProcess);
         boolean parseFailed = false;
@@ -457,12 +457,12 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
             boolean patternFound = false;
 
             if (getServiceUuid() == null) {
-                if (byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
+                if (byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes)) {
                     patternFound = true;
                 }
             } else {
-                if (byteArraysMatch(bytesToProcess, startByte + mServiceUuidStartOffset, serviceUuidBytes, 0) &&
-                        byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
+                if (byteArraysMatch(bytesToProcess, startByte + mServiceUuidStartOffset, serviceUuidBytes) &&
+                        byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes)) {
                     patternFound = true;
                 }
             }
@@ -758,6 +758,13 @@ public int getDataFieldCount() {
         return mDataStartOffsets.size();
     }
 
+    /**
+     * @return the layout string for the parser
+     */
+    public String getLayout() {
+        return mBeaconLayout;
+    }
+
     /**
      * @return the correction value in dBm to apply to the calibrated txPower to get a 1m calibrated value.
      * Some formats like Eddystone use a 0m calibrated value, which requires this correction
@@ -821,18 +828,19 @@ private int calculateLayoutSize() {
         return lastEndOffset+1;
     }
 
-    private boolean byteArraysMatch(byte[] array1, int offset1, byte[] array2, int offset2) {
-        int minSize = array1.length > array2.length ? array2.length : array1.length;
-        if (offset1+minSize > array1.length || offset2+minSize > array2.length) {
+    private boolean byteArraysMatch(byte[] source, int offset, byte[] expected) {
+        int length = expected.length;
+        if (source.length - offset < length) {
             return false;
         }
-        for (int i = 0; i <  minSize; i++) {
-            if (array1[i+offset1] != array2[i+offset2]) {
+        for (int i = 0; i <  length; i++) {
+            if (source[offset + i] != expected[i]) {
                 return false;
             }
         }
         return true;
     }
+
     private String byteArrayToString(byte[] bytes) {
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < bytes.length; i++) {
@@ -925,4 +933,20 @@ public int hashCode() {
             }
         );
     }
+
+    @Override
+    public boolean equals(Object o) {
+        BeaconParser that = null;
+        try {
+            that = (BeaconParser) o;
+            if (that.mBeaconLayout != null && that.mBeaconLayout.equals(this.mBeaconLayout)) {
+                if (that.mIdentifier != null && that.mIdentifier.equals(this.mIdentifier)) {
+                    return true;
+                }
+            }
+        }
+        catch (ClassCastException e ) { }
+        return false;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/IntentHandler.java b/src/main/java/org/altbeacon/beacon/IntentHandler.java
new file mode 100644
index 00000000..6e6c84a7
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/IntentHandler.java
@@ -0,0 +1,85 @@
+package org.altbeacon.beacon;
+
+import android.content.Context;
+import android.content.Intent;
+
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.MonitoringData;
+import org.altbeacon.beacon.service.MonitoringStatus;
+import org.altbeacon.beacon.service.RangingData;
+
+import java.util.Set;
+
+/**
+ * Converts internal Intents for ranging/monitoring to notifier callbacks.
+ * These may be local broadcast intents from BeaconLocalBroadcastProcessor or
+ * global broadcast intents fro BeaconIntentProcessor
+ *
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
+ * Created by dyoung on 7/20/17.
+ */
+
+/* package private*/
+class IntentHandler {
+    private static final String TAG = IntentHandler.class.getSimpleName();
+    public void convertIntentsToCallbacks(Context context, Intent intent) {
+        MonitoringData monitoringData = null;
+        RangingData rangingData = null;
+
+        if (intent != null && intent.getExtras() != null) {
+            if (intent.getExtras().getBundle("monitoringData") != null) {
+                monitoringData = MonitoringData.fromBundle(intent.getExtras().getBundle("monitoringData"));
+            }
+            if (intent.getExtras().getBundle("rangingData") != null) {
+                rangingData = RangingData.fromBundle(intent.getExtras().getBundle("rangingData"));
+            }
+        }
+
+        if (rangingData != null) {
+            LogManager.d(TAG, "got ranging data");
+            if (rangingData.getBeacons() == null) {
+                LogManager.w(TAG, "Ranging data has a null beacons collection");
+            }
+            Set<RangeNotifier> notifiers = BeaconManager.getInstanceForApplication(context).getRangingNotifiers();
+            java.util.Collection<Beacon> beacons = rangingData.getBeacons();
+            if (notifiers != null) {
+                for(RangeNotifier notifier : notifiers){
+                    notifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
+                }
+            }
+            else {
+                LogManager.d(TAG, "but ranging notifier is null, so we're dropping it.");
+            }
+            RangeNotifier dataNotifier = BeaconManager.getInstanceForApplication(context).getDataRequestNotifier();
+            if (dataNotifier != null) {
+                dataNotifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
+            }
+        }
+
+        if (monitoringData != null) {
+            LogManager.d(TAG, "got monitoring data");
+            Set<MonitorNotifier> notifiers = BeaconManager.getInstanceForApplication(context).getMonitoringNotifiers();
+            if (notifiers != null) {
+                for(MonitorNotifier notifier : notifiers) {
+                    LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
+                    Region region = monitoringData.getRegion();
+                    Integer state = monitoringData.isInside() ? MonitorNotifier.INSIDE :
+                            MonitorNotifier.OUTSIDE;
+                    notifier.didDetermineStateForRegion(state, region);
+                    // In case the beacon scanner is running in a separate process, the monitoring
+                    // status in this process  will not have been updated yet as a result of this
+                    // region state change.  We make a call here to keep it in sync.
+                    MonitoringStatus.getInstanceForApplication(context).updateLocalState(region, state);
+                    if (monitoringData.isInside()) {
+                        notifier.didEnterRegion(monitoringData.getRegion());
+                    } else {
+                        notifier.didExitRegion(monitoringData.getRegion());
+                    }
+                }
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/Region.java b/src/main/java/org/altbeacon/beacon/Region.java
index db5886da..24b0ad62 100644
--- a/src/main/java/org/altbeacon/beacon/Region.java
+++ b/src/main/java/org/altbeacon/beacon/Region.java
@@ -51,7 +51,6 @@
 public class Region implements Parcelable, Serializable {
     private static final String TAG = "Region";
     private static final Pattern MAC_PATTERN = Pattern.compile("^[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}$");
-
     /**
      * Required to make class Parcelable
      */
@@ -309,4 +308,5 @@ private void validateMac(String mac) throws IllegalArgumentException {
     public Region clone() {
         return new Region(mUniqueId, mIdentifiers, mBluetoothAddress);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
index 42f7db77..ad4bfe73 100644
--- a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
+++ b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
@@ -189,8 +189,12 @@ private boolean loadModelMapFromFile() {
             buildModelMapWithLock(sb.toString());
             return true;
         } catch (JSONException e) {
-            LogManager.e(TAG, "Cannot update distance models from online database at %s with JSON",
-                    e, mRemoteUpdateUrlString, sb.toString());
+            LogManager.e(
+                    e,
+                    TAG,
+                    "Cannot update distance models from online database at %s with JSON: %s",
+                    mRemoteUpdateUrlString, sb.toString()
+            );
             return false;
         }
     }
@@ -265,7 +269,7 @@ void buildModelMapWithLock(String jsonString) throws JSONException {
     }
 
     private void buildModelMap(String jsonString) throws JSONException {
-        mModelMap = new HashMap<AndroidModel, DistanceCalculator>();
+        HashMap<AndroidModel, DistanceCalculator> map = new HashMap<AndroidModel, DistanceCalculator>();
         JSONObject jsonObject = new JSONObject(jsonString);
         JSONArray array = jsonObject.getJSONArray("models");
         for (int i = 0; i < array.length(); i++) {
@@ -286,19 +290,20 @@ private void buildModelMap(String jsonString) throws JSONException {
                     new CurveFittedDistanceCalculator(coefficient1,coefficient2,coefficient3);
 
             AndroidModel androidModel = new AndroidModel(version, buildNumber, model, manufacturer);
-            mModelMap.put(androidModel, distanceCalculator);
+            map.put(androidModel, distanceCalculator);
             if (defaultFlag) {
                 mDefaultModel = androidModel;
             }
         }
+        mModelMap = map;
     }
 
     private void loadDefaultModelMap() {
-        mModelMap = new HashMap<AndroidModel, DistanceCalculator>();
         try {
             buildModelMap(stringFromFilePath(CONFIG_FILE));
         }
         catch (Exception e) {
+            mModelMap = new HashMap<AndroidModel, DistanceCalculator>();
             LogManager.e(e, TAG, "Cannot build model distance calculations");
         }
     }
diff --git a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
index 5e7367a3..bebb7c91 100644
--- a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
+++ b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
@@ -1,6 +1,5 @@
 package org.altbeacon.beacon.distance;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.os.AsyncTask;
@@ -14,7 +13,6 @@
 /**
  * Created by dyoung on 9/12/14.
  */
-@TargetApi(Build.VERSION_CODES.CUPCAKE)
 public class ModelSpecificDistanceUpdater extends AsyncTask<Void, Void, Void> {
 
     private static final String TAG = "ModelSpecificDistanceUpdater";
diff --git a/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java b/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
new file mode 100644
index 00000000..2b9baec5
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import android.util.Log;
+
+/**
+ * Android logger that only logs out warning and above to the {@link android.util.Log}.
+ *
+ * @since 2.2
+ * @author Andrew Reitz
+ */
+final class InfoAndroidLogger extends AbstractAndroidLogger {
+    @Override
+    public void v(String tag, String message, Object... args) { }
+
+    @Override
+    public void v(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void d(String tag, String message, Object... args) { }
+
+    @Override
+    public void d(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void i(String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args));
+    }
+
+    @Override
+    public void i(Throwable t, String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void w(String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args));
+    }
+
+    @Override
+    public void w(Throwable t, String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void e(String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args));
+    }
+
+    @Override
+    public void e(Throwable t, String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args), t);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/LogManager.java b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
index 4500699e..8420d7a6 100644
--- a/src/main/java/org/altbeacon/beacon/logging/LogManager.java
+++ b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
@@ -24,7 +24,7 @@
  * @since 2.2
  */
 public final class LogManager {
-    private static Logger sLogger = Loggers.warningLogger();
+    private static Logger sLogger = Loggers.infoLogger();
     private static boolean sVerboseLoggingEnabled = false;
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/logging/Loggers.java b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
index 44144026..c243f62c 100644
--- a/src/main/java/org/altbeacon/beacon/logging/Loggers.java
+++ b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
@@ -30,6 +30,9 @@
     /** Debug Logger Singleton. */
     private static final Logger VERBOSE_ANDROID_LOGGER = new VerboseAndroidLogger();
 
+    /** Info Logger Singleton. */
+    private static final Logger INFO_ANDROID_LOGGER = new InfoAndroidLogger();
+
     /** Warning Logger Singleton. */
     private static final Logger WARNING_ANDROID_LOGGER = new WarningAndroidLogger();
 
@@ -48,6 +51,14 @@ public static Logger verboseLogger() {
         return VERBOSE_ANDROID_LOGGER;
     }
 
+    /**
+     * @return Get a logger that logs messages of info and greater.
+     * @see android.util.Log
+     */
+    public static Logger infoLogger() {
+        return INFO_ANDROID_LOGGER;
+    }
+
     /**
      * @return Get a logger that logs messages of warning and greater.
      * @see android.util.Log
diff --git a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
index 4119c465..1349ad49 100644
--- a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
+++ b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
@@ -5,36 +5,37 @@
 import android.app.Application;
 import android.content.Context;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
 /**
- *
  * Simply creating an instance of this class and holding a reference to it in your Application can
  * improve battery life by 60% by slowing down scans when your app is in the background.
- *
  */
 @TargetApi(18)
 public class BackgroundPowerSaver implements Application.ActivityLifecycleCallbacks {
+    @NonNull
     private static final String TAG = "BackgroundPowerSaver";
-    private BeaconManager beaconManager;
+
+    @NonNull
+    private final BeaconManager beaconManager;
+
     private int activeActivityCount = 0;
 
     /**
-     *
      * Constructs a new BackgroundPowerSaver
      *
-     * @param context
-     * @deprecated the countActiveActivityStrategy flag is no longer used.
-     *
+     * @deprecated the {@code countActiveActivityStrategy} flag is no longer used. Use
+     * {@link #BackgroundPowerSaver(Context)}
      */
+    @Deprecated
     public BackgroundPowerSaver(Context context, boolean countActiveActivityStrategy) {
         this(context);
     }
 
     /**
-     *
      * Constructs a new BackgroundPowerSaver using the default background determination strategy
      *
      * @param context
@@ -42,10 +43,9 @@ public BackgroundPowerSaver(Context context, boolean countActiveActivityStrategy
     public BackgroundPowerSaver(Context context) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
             LogManager.w(TAG, "BackgroundPowerSaver requires API 18 or higher.");
-            return;
         }
-        ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
         beaconManager = BeaconManager.getInstanceForApplication(context);
+        ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
     }
 
     @Override
@@ -70,7 +70,12 @@ public void onActivityResumed(Activity activity) {
     @Override
     public void onActivityPaused(Activity activity) {
         activeActivityCount--;
-        LogManager.d(TAG, "activity paused: %s active activities: %s", activity, activeActivityCount);
+        LogManager.d(
+                TAG,
+                "activity paused: %s active activities: %s",
+                activity,
+                activeActivityCount
+        );
         if (activeActivityCount < 1) {
             LogManager.d(TAG, "setting background mode");
             beaconManager.setBackgroundMode(true);
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 5738a50f..37ae6ff2 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -24,21 +24,24 @@
 package org.altbeacon.beacon.service;
 
 
-import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
 import android.app.Service;
-import android.bluetooth.BluetoothDevice;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.ApplicationInfo;
-import android.os.AsyncTask;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
 import android.os.Binder;
 import android.os.Build;
 import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
 import android.os.Message;
 import android.os.Messenger;
+import android.support.annotation.MainThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -49,23 +52,15 @@
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
-import org.altbeacon.beacon.service.scanner.CycledLeScanner;
-import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
+import org.altbeacon.beacon.utils.ProcessUtils;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
 
 import static android.app.PendingIntent.FLAG_ONE_SHOT;
 import static android.app.PendingIntent.getBroadcast;
@@ -74,24 +69,11 @@
  * @author dyoung
  */
 
-@TargetApi(5)
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
-
-    private final Map<Region, RangeState> rangedRegionState = new HashMap<Region, RangeState>();
-    private MonitoringStatus monitoringStatus;
-
-    int trackedBeaconsPacketCount;
     private final Handler handler = new Handler();
     private BluetoothCrashResolver bluetoothCrashResolver;
-    private DistanceCalculator defaultDistanceCalculator = null;
-    private BeaconManager beaconManager;
-    private Set<BeaconParser> beaconParsers  = new HashSet<BeaconParser>();
-    private CycledLeScanner mCycledScanner;
-    private boolean mBackgroundFlag = false;
-    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
-    private ExecutorService mExecutor;
-
+    private ScanHelper mScanHelper;
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -114,8 +96,6 @@
      *
      */
 
-    private List<Beacon> simulatedScanData = null;
-
     /**
      * Class used for the client Binder.  Because we know this service always
      * runs in the same process as its clients, we don't need to deal with IPC.
@@ -136,48 +116,71 @@ public BeaconService getService() {
     public static final int MSG_START_MONITORING = 4;
     public static final int MSG_STOP_MONITORING = 5;
     public static final int MSG_SET_SCAN_PERIODS = 6;
+    public static final int MSG_SYNC_SETTINGS = 7;
 
     static class IncomingHandler extends Handler {
         private final WeakReference<BeaconService> mService;
 
         IncomingHandler(BeaconService service) {
+            /*
+             * Explicitly state this uses the main thread. Without this we defer to where the
+             * service instance is initialized/created; which is usually the main thread anyways.
+             * But by being explicit we document our code design expectations for where things run.
+             */
+            super(Looper.getMainLooper());
             mService = new WeakReference<BeaconService>(service);
         }
 
+        @MainThread
         @Override
         public void handleMessage(Message msg) {
             BeaconService service = mService.get();
-            StartRMData startRMData = (StartRMData) msg.obj;
-
             if (service != null) {
-                switch (msg.what) {
-                    case MSG_START_RANGING:
-                        LogManager.i(TAG, "start ranging received");
-                        service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_STOP_RANGING:
-                        LogManager.i(TAG, "stop ranging received");
-                        service.stopRangingBeaconsInRegion(startRMData.getRegionData());
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_START_MONITORING:
-                        LogManager.i(TAG, "start monitoring received");
-                        service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_STOP_MONITORING:
-                        LogManager.i(TAG, "stop monitoring received");
-                        service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_SET_SCAN_PERIODS:
-                        LogManager.i(TAG, "set scan intervals received");
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    default:
-                        super.handleMessage(msg);
+                StartRMData startRMData = StartRMData.fromBundle(msg.getData());
+                if (startRMData != null) {
+                    switch (msg.what) {
+                        case MSG_START_RANGING:
+                            LogManager.i(TAG, "start ranging received");
+                            service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_STOP_RANGING:
+                            LogManager.i(TAG, "stop ranging received");
+                            service.stopRangingBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_START_MONITORING:
+                            LogManager.i(TAG, "start monitoring received");
+                            service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_STOP_MONITORING:
+                            LogManager.i(TAG, "stop monitoring received");
+                            service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_SET_SCAN_PERIODS:
+                            LogManager.i(TAG, "set scan intervals received");
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        default:
+                            super.handleMessage(msg);
+                    }
+                }
+                else if (msg.what == MSG_SYNC_SETTINGS) {
+                    LogManager.i(TAG, "Received settings update from other process");
+                    SettingsData settingsData = SettingsData.fromBundle(msg.getData());
+                    if (settingsData != null) {
+                        settingsData.apply(service);
+                    }
+                    else {
+                        LogManager.w(TAG, "Settings data missing");
+                    }
+                }
+                else {
+                    LogManager.i(TAG, "Received unknown message from other process : "+msg.what);
                 }
+
             }
         }
     }
@@ -187,46 +190,51 @@ public void handleMessage(Message msg) {
      */
     final Messenger mMessenger = new Messenger(new IncomingHandler(this));
 
-
+    @MainThread
     @Override
     public void onCreate() {
-        LogManager.i(TAG, "beaconService version %s is starting up", BuildConfig.VERSION_NAME);
         bluetoothCrashResolver = new BluetoothCrashResolver(this);
         bluetoothCrashResolver.start();
 
-        // Create a private executor so we don't compete with threads used by AsyncTask
-        // This uses fewer threads than the default executor so it won't hog CPU
-        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
-
-        mCycledScanner = CycledLeScanner.createScanner(this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
-                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag, mCycledLeScanCallback, bluetoothCrashResolver);
-
-        beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        mScanHelper = new ScanHelper(this);
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(false, bluetoothCrashResolver);
+        }
+        mScanHelper.setMonitoringStatus(MonitoringStatus.getInstanceForApplication(this));
+        mScanHelper.setRangedRegionState(new HashMap<Region, RangeState>());
+        mScanHelper.setBeaconParsers(new HashSet<BeaconParser>());
+        mScanHelper.setExtraDataBeaconTracker(new ExtraDataBeaconTracker());
+
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        beaconManager.setScannerInSameProcess(true);
+        if (beaconManager.isMainProcess()) {
+            LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+        }
+        else {
+            LogManager.i(TAG, "beaconService version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(this);
+            LogManager.i(TAG, "beaconService PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
+        }
 
-        //flatMap all beacon parsers
-        boolean matchBeaconsByServiceUUID = true;
-        if (beaconManager.getBeaconParsers() != null) {
-            beaconParsers.addAll(beaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    beaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
+        try {
+            PackageItemInfo info = this.getPackageManager().getServiceInfo(new ComponentName(this, BeaconService.class), PackageManager.GET_META_DATA);
+            if (info != null && info.metaData != null && info.metaData.get("longScanForcingEnabled") != null &&
+                    info.metaData.get("longScanForcingEnabled").toString().equals("true")) {
+                LogManager.i(TAG, "longScanForcingEnabled to keep scans going on Android N for > 30 minutes");
+                mScanHelper.getCycledScanner().setLongScanForcingEnabled(true);
             }
-        }
+        } catch (PackageManager.NameNotFoundException e) {}
 
-        //initialize the extra data beacon tracker
-        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+        mScanHelper.reloadParsers();
 
-        defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
+        DistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
 
-        monitoringStatus = MonitoringStatus.getInstanceForApplication(getApplicationContext());
         // Look for simulated scan data
         try {
             Class klass = Class.forName("org.altbeacon.beacon.SimulatedScanData");
             java.lang.reflect.Field f = klass.getField("beacons");
-            this.simulatedScanData = (List<Beacon>) f.get(null);
+            mScanHelper.setSimulatedScanData((List<Beacon>) f.get(null));
         } catch (ClassNotFoundException e) {
             LogManager.d(TAG, "No org.altbeacon.beacon.SimulatedScanData class exists.");
         } catch (Exception e) {
@@ -234,7 +242,6 @@ public void onCreate() {
         }
     }
 
-
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         LogManager.i(TAG,
@@ -262,6 +269,7 @@ public boolean onUnbind(Intent intent) {
         return false;
     }
 
+    @MainThread
     @Override
     public void onDestroy() {
         LogManager.e(TAG, "onDestroy()");
@@ -272,9 +280,9 @@ public void onDestroy() {
         bluetoothCrashResolver.stop();
         LogManager.i(TAG, "onDestroy called.  stopping scanning");
         handler.removeCallbacksAndMessages(null);
-        mCycledScanner.stop();
-        mCycledScanner.destroy();
-        monitoringStatus.stopStatusPreservation();
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        mScanHelper.getMonitoringStatus().stopStatusPreservation();
     }
 
     @Override
@@ -298,220 +306,62 @@ private PendingIntent getRestartIntent() {
     /**
      * methods for clients
      */
+    @MainThread
     public void startRangingBeaconsInRegion(Region region, Callback callback) {
-        synchronized (rangedRegionState) {
-            if (rangedRegionState.containsKey(region)) {
+        synchronized (mScanHelper.getRangedRegionState()) {
+            if (mScanHelper.getRangedRegionState().containsKey(region)) {
                 LogManager.i(TAG, "Already ranging that region -- will replace existing region.");
-                rangedRegionState.remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
+                mScanHelper.getRangedRegionState().remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
             }
-            rangedRegionState.put(region, new RangeState(callback));
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+            mScanHelper.getRangedRegionState().put(region, new RangeState(callback));
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
-        mCycledScanner.start();
+        mScanHelper.getCycledScanner().start();
     }
 
+    @MainThread
     public void stopRangingBeaconsInRegion(Region region) {
         int rangedRegionCount;
-        synchronized (rangedRegionState) {
-            rangedRegionState.remove(region);
-            rangedRegionCount = rangedRegionState.size();
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+        synchronized (mScanHelper.getRangedRegionState()) {
+            mScanHelper.getRangedRegionState().remove(region);
+            rangedRegionCount = mScanHelper.getRangedRegionState().size();
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
 
-        if (rangedRegionCount == 0 && monitoringStatus.regionsCount() == 0) {
-            mCycledScanner.stop();
+        if (rangedRegionCount == 0 && mScanHelper.getMonitoringStatus().regionsCount() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
+    @MainThread
     public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
         LogManager.d(TAG, "startMonitoring called");
-        monitoringStatus.addRegion(region, callback);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        mCycledScanner.start();
+        mScanHelper.getMonitoringStatus().addRegion(region, callback);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        mScanHelper.getCycledScanner().start();
     }
 
+    @MainThread
     public void stopMonitoringBeaconsInRegion(Region region) {
         LogManager.d(TAG, "stopMonitoring called");
-        monitoringStatus.removeRegion(region);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        if (monitoringStatus.regionsCount() == 0 && rangedRegionState.size() == 0) {
-            mCycledScanner.stop();
+        mScanHelper.getMonitoringStatus().removeRegion(region);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        if (mScanHelper.getMonitoringStatus().regionsCount() == 0 && mScanHelper.getRangedRegionState().size() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
+    @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        mCycledScanner.setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
+        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
     }
 
-    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
-        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-        @Override
-        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
-
-            NonBeaconLeScanCallback nonBeaconLeScanCallback = beaconManager.getNonBeaconLeScanCallback();
-
-            try {
-                new ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
-                        new ScanData(device, rssi, scanRecord));
-            } catch (RejectedExecutionException e) {
-                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
-            }
-        }
-
-        @Override
-        public void onCycleEnd() {
-            monitoringStatus.updateNewlyOutside();
-            processRangeData();
-            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
-            if (simulatedScanData != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
-
-                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                    for (Beacon beacon : simulatedScanData) {
-                        processBeaconFromScan(beacon);
-                    }
-                } else {
-                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
-                }
-            }
-            if (BeaconManager.getBeaconSimulator() != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
-                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
-                            processBeaconFromScan(beacon);
-                        }
-                    } else {
-                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
-                    }
-                } else {
-                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
-                }
-            }
-        }
-    };
-
-    private void processRangeData() {
-        synchronized (rangedRegionState) {
-            for (Region region : rangedRegionState.keySet()) {
-                RangeState rangeState = rangedRegionState.get(region);
-                LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region));
-            }
-        }
+    public void reloadParsers() {
+        mScanHelper.reloadParsers();
     }
 
-    private void processBeaconFromScan(Beacon beacon) {
-        if (Stats.getInstance().isEnabled()) {
-            Stats.getInstance().log(beacon);
-        }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG,
-                    "beacon detected : %s", beacon.toString());
-        }
-
-        beacon = mExtraDataBeaconTracker.track(beacon);
-        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
-        // the above
-        if (beacon == null) {
-            if (LogManager.isVerboseLoggingEnabled()) {
-                LogManager.d(TAG,
-                        "not processing detections for GATT extra data beacon");
-            }
-        } else {
-
-            monitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
-
-            List<Region> matchedRegions = null;
-            Iterator<Region> matchedRegionIterator;
-            LogManager.d(TAG, "looking for ranging region matches for this beacon");
-            synchronized (rangedRegionState) {
-                matchedRegions = matchingRegions(beacon, rangedRegionState.keySet());
-                matchedRegionIterator = matchedRegions.iterator();
-                while (matchedRegionIterator.hasNext()) {
-                    Region region = matchedRegionIterator.next();
-                    LogManager.d(TAG, "matches ranging region: %s", region);
-                    RangeState rangeState = rangedRegionState.get(region);
-                    if (rangeState != null) {
-                        rangeState.addBeacon(beacon);
-                    }
-                }
-            }
-        }
-    }
-
-
-    private class ScanData {
-        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
-            this.device = device;
-            this.rssi = rssi;
-            this.scanRecord = scanRecord;
-        }
-
-        int rssi;
-        BluetoothDevice device;
-        byte[] scanRecord;
-    }
-
-    private class ScanProcessor extends AsyncTask<ScanData, Void, Void> {
-        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
-
-        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-
-        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
-            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
-        }
-
-        @Override
-        protected Void doInBackground(ScanData... params) {
-            ScanData scanData = params[0];
-            Beacon beacon = null;
-
-            for (BeaconParser parser : BeaconService.this.beaconParsers) {
-                beacon = parser.fromScanData(scanData.scanRecord,
-                        scanData.rssi, scanData.device);
-
-                if (beacon != null) {
-                    break;
-                }
-            }
-            if (beacon != null) {
-                mDetectionTracker.recordDetection();
-                trackedBeaconsPacketCount++;
-                processBeaconFromScan(beacon);
-            } else {
-                if (mNonBeaconLeScanCallback != null) {
-                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
-                }
-            }
-            return null;
-        }
-
-        @Override
-        protected void onPostExecute(Void result) {
-        }
-
-        @Override
-        protected void onPreExecute() {
-        }
-
-        @Override
-        protected void onProgressUpdate(Void... values) {
-        }
-    }
-
-    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<Region>();
-        for (Region region : regions) {
-            if (region.matchesBeacon(beacon)) {
-                matched.add(region);
-            } else {
-                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
-            }
-        }
-        return matched;
+    @RestrictTo(Scope.TESTS)
+    protected CycledLeScanCallback getCycledLeScanCallback() {
+        return mScanHelper.getCycledLeScanCallback();
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index aa0ddb6a..a8c9ad92 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -26,8 +26,11 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Parcelable;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
 
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
+import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
 import java.io.IOException;
@@ -35,23 +38,9 @@
 
 public class Callback implements Serializable {
     private static final String TAG = "Callback";
-    private transient Intent intent;
-    private String intentPackageName;
 
+    //TODO: Remove this constructor in favor of an empty one, as the packae name is no longer needed
     public Callback(String intentPackageName) {
-        this.intentPackageName = intentPackageName;
-        initializeIntent();
-    }
-
-    private void initializeIntent() {
-        if (intentPackageName != null) {
-            intent = new Intent();
-            intent.setComponent(new ComponentName(intentPackageName, "org.altbeacon.beacon.BeaconIntentProcessor"));
-        }
-    }
-
-    public Intent getIntent() {
-        return intent;
     }
 
     /**
@@ -62,23 +51,45 @@ public Intent getIntent() {
      * @param data
      * @return false if it callback cannot be made
      */
-    public boolean call(Context context, String dataName, Parcelable data) {
-        if(intent == null){
-            initializeIntent();
+    public boolean call(Context context, String dataName, Bundle data) {
+        boolean useLocalBroadcast = BeaconManager.getInstanceForApplication(context).getScheduledScanJobsEnabled();
+        boolean success = false;
+
+        if(useLocalBroadcast) {
+            String action = null;
+            if (dataName == "rangingData") {
+                action = BeaconLocalBroadcastProcessor.RANGE_NOTIFICATION;
+            }
+            else {
+                action = BeaconLocalBroadcastProcessor.MONITOR_NOTIFICATION;
+            }
+            Intent intent = new Intent(action);
+            intent.putExtra(dataName, data);
+            LogManager.d(TAG, "attempting callback via local broadcast intent: %s",action);
+            success = LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
         }
-        if (intent != null) {
-            LogManager.d(TAG, "attempting callback via intent: %s", intent.getComponent());
+        else {
+            Intent intent = new Intent();
+            intent.setComponent(new ComponentName(context.getPackageName(), "org.altbeacon.beacon.BeaconIntentProcessor"));
             intent.putExtra(dataName, data);
-            context.startService(intent);
-            return true;
+            LogManager.d(TAG, "attempting callback via global broadcast intent: %s",intent.getComponent());
+            try {
+                context.startService(intent);
+                success = true;
+            } catch (Exception e) {
+                LogManager.e(
+                        TAG,
+                        "Failed attempting to start service: " + intent.getComponent().flattenToString(),
+                        e
+                );
+            }
         }
-        return false;
+        return success;
     }
 
     @SuppressWarnings("unused")
     private void readObject(java.io.ObjectInputStream in)
             throws IOException, ClassNotFoundException {
         in.defaultReadObject();
-        initializeIntent();
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java b/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
index 2c5dc5c1..3797d241 100644
--- a/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
@@ -6,16 +6,14 @@
  * Created by dyoung on 1/10/15.
  */
 public class DetectionTracker {
-    private static DetectionTracker sDetectionTracker = null;
+    private static final DetectionTracker INSTANCE = new DetectionTracker();
+
     private long mLastDetectionTime = 0l;
     private DetectionTracker() {
 
     }
-    public static synchronized DetectionTracker getInstance() {
-        if (sDetectionTracker == null) {
-            sDetectionTracker  = new DetectionTracker();
-        }
-        return sDetectionTracker;
+    public static DetectionTracker getInstance() {
+        return INSTANCE;
     }
     public long getLastDetectionTime() {
         return mLastDetectionTime;
diff --git a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
index a93e8fb2..303efdd4 100644
--- a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
@@ -2,6 +2,7 @@
 
 import org.altbeacon.beacon.Beacon;
 
+import java.io.Serializable;
 import java.util.HashMap;
 
 /**
@@ -9,7 +10,7 @@
  * merges them together depending on configured beacon parsers
  * Created by dyoung on 5/5/15.
  */
-public class ExtraDataBeaconTracker {
+public class ExtraDataBeaconTracker implements Serializable {
     private static final String TAG = "BeaconTracker";
     // This is a lookup table to find tracked beacons by the calculated beacon key
     private HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<String,HashMap<Integer,Beacon>>();
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
index e9523536..74356914 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
@@ -25,49 +25,42 @@
 
 import org.altbeacon.beacon.Region;
 
-import android.os.Parcel;
-import android.os.Parcelable;
+import android.os.Bundle;
 
-public class MonitoringData implements Parcelable {
+public class MonitoringData {
     @SuppressWarnings("unused")
     private static final String TAG = "MonitoringData";
-    private final boolean inside;
-    private final Region region;
+    private final boolean mInside;
+    private final Region mRegion;
+    private static final String REGION_KEY = "region";
+    private static final String INSIDE_KEY = "inside";
 
     public MonitoringData (boolean inside, Region region) {
-        this.inside = inside;
-        this.region = region;
+        this.mInside = inside;
+        this.mRegion = region;
     }
     public boolean isInside() {
-        return inside;
+        return mInside;
     }
     public Region getRegion() {
-        return region;
+        return mRegion;
     }
 
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeByte((byte) (inside ? 1 : 0));
-        out.writeParcelable(region, flags);
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(REGION_KEY, mRegion);
+        bundle.putBoolean(INSIDE_KEY, mInside);
 
+        return bundle;
     }
-
-    public static final Parcelable.Creator<MonitoringData> CREATOR
-            = new Parcelable.Creator<MonitoringData>() {
-        public MonitoringData createFromParcel(Parcel in) {
-            return new MonitoringData(in);
-        }
-
-        public MonitoringData[] newArray(int size) {
-            return new MonitoringData[size];
+    public static MonitoringData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
         }
-    };
-
-    private MonitoringData(Parcel in) {
-        inside = in.readByte() == 1;
-        region = in.readParcelable(this.getClass().getClassLoader());
+        Boolean inside = bundle.getBoolean(INSIDE_KEY);
+        return new MonitoringData(inside, region);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index fdf5644d..ea8573e7 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 
 import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.MonitorNotifier;
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -19,11 +20,12 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 import static android.content.Context.MODE_PRIVATE;
 
 public class MonitoringStatus {
-    private static MonitoringStatus sInstance;
+    private static volatile MonitoringStatus sInstance;
     private static final int MAX_REGIONS_FOR_STATUS_PRESERVATION = 50;
     private static final int MAX_STATUS_PRESERVATION_FILE_AGE_TO_RESTORE_SECS = 60 * 15;
     private static final String TAG = MonitoringStatus.class.getSimpleName();
@@ -35,15 +37,35 @@
 
     private boolean mStatePreservationIsOn = true;
 
+    /**
+     * Private lock object for singleton initialization protecting against denial-of-service attack.
+     */
+    private static final Object SINGLETON_LOCK = new Object();
+
     public static MonitoringStatus getInstanceForApplication(Context context) {
-        if (sInstance == null) {
-            synchronized (MonitoringStatus.class) {
-                if (sInstance == null) {
-                    sInstance = new MonitoringStatus(context.getApplicationContext());
+        /*
+         * Follow double check pattern from Effective Java v2 Item 71.
+         *
+         * Bloch recommends using the local variable for this for performance reasons:
+         *
+         * > What this variable does is ensure that `field` is read only once in the common case
+         * > where it's already initialized. While not strictly necessary, this may improve
+         * > performance and is more elegant by the standards applied to low-level concurrent
+         * > programming. On my machine, [this] is about 25 percent faster than the obvious
+         * > version without a local variable.
+         *
+         * Joshua Bloch. Effective Java, Second Edition. Addison-Wesley, 2008. pages 283-284
+         */
+        MonitoringStatus instance = sInstance;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = sInstance;
+                if (instance == null) {
+                    sInstance = instance = new MonitoringStatus(context.getApplicationContext());
                 }
             }
         }
-        return sInstance;
+        return instance;
     }
 
     public MonitoringStatus(Context context) {
@@ -51,31 +73,12 @@ public MonitoringStatus(Context context) {
     }
 
     public synchronized void addRegion(Region region, Callback callback) {
-        if (getRegionsStateMap().containsKey(region)) {
-            // if the region definition hasn't changed, becasue if it has, we need to clear state
-            // otherwise a region with the same uniqueId can never be changed
-            for (Region existingRegion : getRegionsStateMap().keySet()) {
-                if (existingRegion.equals(region)) {
-                    if (existingRegion.hasSameIdentifiers(region)) {
-                        return;
-                    }
-                    else {
-                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
-                        LogManager.d(TAG, "Old definition: "+existingRegion);
-                        LogManager.d(TAG, "New definition: "+region);
-                        LogManager.d(TAG, "clearing state");
-                        getRegionsStateMap().remove(region);
-                        break;
-                    }
-                }
-            }
-        }
-        getRegionsStateMap().put(region, new RegionMonitoringState(callback));
+        addLocalRegion(region, callback);
         saveMonitoringStatusIfOn();
     }
 
     public synchronized void removeRegion(Region region) {
-        getRegionsStateMap().remove(region);
+        removeLocalRegion(region);
         saveMonitoringStatusIfOn();
     }
 
@@ -100,7 +103,7 @@ public synchronized void updateNewlyOutside() {
             if (state.markOutsideIfExpired()) {
                 needsMonitoringStateSaving = true;
                 LogManager.d(TAG, "found a monitor that expired: %s", region);
-                state.getCallback().call(mContext, "monitoringData", new MonitoringData(state.getInside(), region));
+                state.getCallback().call(mContext, "monitoringData", new MonitoringData(state.getInside(), region).toBundle());
             }
         }
         if (needsMonitoringStateSaving) {
@@ -119,7 +122,7 @@ public synchronized void updateNewlyInsideInRegionsContaining(Beacon beacon) {
             if (state != null && state.markInside()) {
                 needsMonitoringStateSaving = true;
                 state.getCallback().call(mContext, "monitoringData",
-                        new MonitoringData(state.getInside(), region));
+                        new MonitoringData(state.getInside(), region).toBundle());
             }
         }
         if (needsMonitoringStateSaving) {
@@ -139,7 +142,7 @@ public synchronized void updateNewlyInsideInRegionsContaining(Beacon beacon) {
 
     private void restoreOrInitializeMonitoringStatus() {
         long millisSinceLastMonitor = System.currentTimeMillis() - getLastMonitoringStatusUpdateTime();
-        mRegionsStatesMap = new HashMap<Region, RegionMonitoringState>();
+        mRegionsStatesMap = new ConcurrentHashMap<Region, RegionMonitoringState>();
         if (!mStatePreservationIsOn) {
             LogManager.d(TAG, "Not restoring monitoring state because persistence is disabled");
         }
@@ -177,10 +180,17 @@ protected void saveMonitoringStatusIfOn() {
             try {
                 outputStream = mContext.openFileOutput(STATUS_PRESERVATION_FILE_NAME, MODE_PRIVATE);
                 objectOutputStream = new ObjectOutputStream(outputStream);
-                objectOutputStream.writeObject(getRegionsStateMap());
-
+                Map<Region,RegionMonitoringState> map = getRegionsStateMap();
+                // Must convert ConcurrentHashMap to HashMap becasue attempting to serialize
+                // ConcurrentHashMap throws a java.io.NotSerializableException
+                HashMap<Region,RegionMonitoringState> serializableMap = new HashMap<Region,RegionMonitoringState>();
+                for (Region region : map.keySet()) {
+                    serializableMap.put(region, map.get(region));
+                }
+                objectOutputStream.writeObject(serializableMap);
             } catch (IOException e) {
-                LogManager.e(TAG, "Error while saving monitored region states to file. %s ", e.getMessage());
+                LogManager.e(TAG, "Error while saving monitored region states to file ", e);
+                e.printStackTrace(System.err);
             } finally {
                 if (null != outputStream) {
                     try {
@@ -271,8 +281,61 @@ public synchronized void startStatusPreservation() {
         }
     }
 
+    public boolean isStatePreservationOn() {
+        return mStatePreservationIsOn;
+    }
+
     public synchronized void clear() {
         mContext.deleteFile(STATUS_PRESERVATION_FILE_NAME);
         getRegionsStateMap().clear();
     }
+
+    public void updateLocalState(Region region, Integer state) {
+        RegionMonitoringState internalState = getRegionsStateMap().get(region);
+        if (internalState == null) {
+            internalState = addLocalRegion(region);
+        }
+        if (state != null) {
+            if (state == MonitorNotifier.OUTSIDE) {
+                internalState.markOutside();
+
+            }
+            if (state == MonitorNotifier.INSIDE) {
+                internalState.markInside();
+            }
+        }
+    }
+
+    public void removeLocalRegion(Region region) {
+        getRegionsStateMap().remove(region);
+    }
+    public RegionMonitoringState addLocalRegion(Region region){
+        Callback dummyCallback = new Callback(null);
+        return addLocalRegion(region, dummyCallback);
+    }
+
+    private RegionMonitoringState addLocalRegion(Region region, Callback callback){
+        if (getRegionsStateMap().containsKey(region)) {
+            // if the region definition hasn't changed, becasue if it has, we need to clear state
+            // otherwise a region with the same uniqueId can never be changed
+            for (Region existingRegion : getRegionsStateMap().keySet()) {
+                if (existingRegion.equals(region)) {
+                    if (existingRegion.hasSameIdentifiers(region)) {
+                        return getRegionsStateMap().get(existingRegion);
+                    }
+                    else {
+                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
+                        LogManager.d(TAG, "Old definition: "+existingRegion);
+                        LogManager.d(TAG, "New definition: "+region);
+                        LogManager.d(TAG, "clearing state");
+                        getRegionsStateMap().remove(region);
+                        break;
+                    }
+                }
+            }
+        }
+        RegionMonitoringState monitoringState = new RegionMonitoringState(callback);
+        getRegionsStateMap().put(region, monitoringState);
+        return monitoringState;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index a8c1e8d4..fd9ed912 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -26,16 +26,17 @@
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
-public class RangeState {
+public class RangeState implements Serializable {
     private static final String TAG = "RangeState";
-    private final Callback mCallback;
+    private Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
-    private static boolean UseTrackingCache = false;
+    private static boolean sUseTrackingCache = false;
 
     public RangeState(Callback c) {
         mCallback = c;
@@ -77,7 +78,7 @@ public void addBeacon(Beacon beacon) {
                 if (!rangedBeacon.noMeasurementsAvailable() == true) {
                     //if TrackingCache is enabled, allow beacon to not receive
                     //measurements for a certain amount of time
-                    if (!UseTrackingCache || rangedBeacon.isExpired())
+                    if (!sUseTrackingCache || rangedBeacon.isExpired())
                         rangedBeacon.setTracked(false);
                     newRangedBeacons.put(beacon, rangedBeacon);
                 }
@@ -92,8 +93,11 @@ public void addBeacon(Beacon beacon) {
     }
 
     public static void setUseTrackingCache(boolean useTrackingCache) {
-        RangeState.UseTrackingCache = useTrackingCache;
+        RangeState.sUseTrackingCache = useTrackingCache;
     }
 
+    public static boolean getUseTrackingCache() {
+        return sUseTrackingCache;
+    }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index a5b321cb..905f6b0d 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -6,9 +6,10 @@
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
-public class RangedBeacon {
+public class RangedBeacon implements Serializable {
 
     private static final String TAG = "RangedBeacon";
     public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
@@ -19,18 +20,9 @@
     private boolean mTracked = true;
     protected long lastTrackedTimeMillis = 0;
     Beacon mBeacon;
-    protected RssiFilter filter = null;
+    protected transient RssiFilter mFilter = null;
 
     public RangedBeacon(Beacon beacon) {
-        //set RSSI filter
-        try {
-            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
-            filter = (RssiFilter)cons.newInstance();
-        } catch (Exception e) {
-            LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
-        }
-
-        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
         updateBeacon(beacon);
     }
 
@@ -53,10 +45,11 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-        if (!filter.noMeasurementsAvailable()) {
-            double runningAverage = filter.calculateRssi();
-            mBeacon.setRunningAverageRssi(runningAverage);
-            LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
+         if (!getFilter().noMeasurementsAvailable()) {
+             double runningAverage = getFilter().calculateRssi();
+             mBeacon.setRunningAverageRssi(runningAverage);
+             LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
         else {
             LogManager.d(TAG, "No measurements available to calculate running average");
@@ -69,13 +62,14 @@ public void addMeasurement(Integer rssi) {
         if (rssi != 127) {
             mTracked = true;
             lastTrackedTimeMillis = SystemClock.elapsedRealtime();
-            filter.addMeasurement(rssi);
+            getFilter().addMeasurement(rssi);
         }
     }
 
     //kept here for backward compatibility
     public static void setSampleExpirationMilliseconds(long milliseconds) {
         sampleExpirationMilliseconds = milliseconds;
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
     }
 
     public static void setMaxTrackinAge(int maxTrackinAge) {
@@ -83,7 +77,7 @@ public static void setMaxTrackinAge(int maxTrackinAge) {
     }
 
     public boolean noMeasurementsAvailable() {
-        return filter.noMeasurementsAvailable();
+        return getFilter().noMeasurementsAvailable();
     }
 
     public long getTrackingAge() {
@@ -94,4 +88,17 @@ public boolean isExpired() {
         return getTrackingAge() > maxTrackingAge;
     }
 
+    private RssiFilter getFilter() {
+        if (mFilter == null) {
+            //set RSSI filter
+            try {
+            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
+                mFilter = (RssiFilter)cons.newInstance();
+            } catch (Exception e) {
+                LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
+            }
+        }
+        return mFilter;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangingData.java b/src/main/java/org/altbeacon/beacon/service/RangingData.java
index f8750b28..d7bb44ff 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -23,66 +23,63 @@
  */
 package org.altbeacon.beacon.service;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 
 import org.altbeacon.beacon.Beacon;
-import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Region;
-import org.altbeacon.beacon.logging.LogManager;
 
-import android.os.Parcel;
-import android.os.Parcelable;
+import android.os.Bundle;
 
-public class RangingData implements Parcelable {
+/**
+ * Internal class used to transfer ranging data between the BeaconService and the client
+ * @hide
+ */
+public class RangingData {
     private static final String TAG = "RangingData";
-    private final Collection<Beacon> beacons;
-    private final Region region;
+    private final Collection<Beacon> mBeacons;
+    private final Region mRegion;
+    private static final String REGION_KEY = "region";
+    private static final String BEACONS_KEY = "beacons";
 
     public RangingData (Collection<Beacon> beacons, Region region) {
         synchronized (beacons) {
-            this.beacons =  beacons;
+            this.mBeacons =  beacons;
         }
-        this.region = region;
+        this.mRegion = region;
     }
 
     public Collection<Beacon> getBeacons() {
-        return beacons;
+        return mBeacons;
     }
     public Region getRegion() {
-        return region;
+        return mRegion;
     }
 
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-    public void writeToParcel(Parcel out, int flags) {
-        LogManager.d(TAG, "writing RangingData");
-        out.writeParcelableArray(beacons.toArray(new Parcelable[0]), flags);
-        out.writeParcelable(region, flags);
-        LogManager.d(TAG, "done writing RangingData");
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(REGION_KEY, mRegion);
+        ArrayList<Serializable> serializableBeacons = new ArrayList<Serializable>();
+        for (Beacon beacon : mBeacons) {
+            serializableBeacons.add(beacon);
+        }
+        bundle.putSerializable(BEACONS_KEY, serializableBeacons);
 
+        return bundle;
     }
-
-    public static final Parcelable.Creator<RangingData> CREATOR
-            = new Parcelable.Creator<RangingData>() {
-        public RangingData createFromParcel(Parcel in) {
-            return new RangingData(in);
+    public static RangingData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        Collection<Beacon> beacons = null;
+        if (bundle.get(BEACONS_KEY) != null) {
+            beacons = (Collection<Beacon>) bundle.getSerializable(BEACONS_KEY);
         }
-
-        public RangingData[] newArray(int size) {
-            return new RangingData[size];
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
         }
-    };
 
-    private RangingData(Parcel in) {
-        LogManager.d(TAG, "parsing RangingData");
-        Parcelable[] parcelables  = in.readParcelableArray(this.getClass().getClassLoader());
-        beacons = new ArrayList<Beacon>(parcelables.length);
-        for (int i = 0; i < parcelables.length; i++) {
-            beacons.add((Beacon)parcelables[i]);
-        }
-        region = in.readParcelable(this.getClass().getClassLoader());
+        return new RangingData(beacons, region);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java b/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
index 0f9cd1ee..d7b36fb3 100644
--- a/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
@@ -54,15 +54,19 @@ public boolean markInside() {
         return false;
     }
 
+    public void markOutside() {
+        inside = false;
+        lastSeenTime = 0l;
+    }
+
     public boolean markOutsideIfExpired() {
         if (inside) {
             if (lastSeenTime > 0 && SystemClock.elapsedRealtime() - lastSeenTime > BeaconManager.getRegionExitPeriod()) {
-                inside = false;
                 LogManager.d(TAG, "We are newly outside the region because the lastSeenTime of %s "
                                 + "was %s seconds ago, and that is over the expiration duration "
                                 + "of %s", lastSeenTime, SystemClock.elapsedRealtime() - lastSeenTime,
                         BeaconManager.getRegionExitPeriod());
-                lastSeenTime = 0l;
+                markOutside();
                 return true;
             }
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
index c5ba36ca..3f45f7df 100644
--- a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
@@ -1,6 +1,8 @@
 package org.altbeacon.beacon.service;
 
 import android.os.SystemClock;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -81,4 +83,8 @@ public static void setSampleExpirationMilliseconds(long newSampleExpirationMilli
         sampleExpirationMilliseconds = newSampleExpirationMilliseconds;
     }
 
+    @RestrictTo(Scope.TESTS)
+    static long getSampleExpirationMilliseconds() {
+        return sampleExpirationMilliseconds;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
new file mode 100644
index 00000000..758f0995
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
@@ -0,0 +1,173 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.Service;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.le.ScanResult;
+import android.content.pm.ApplicationInfo;
+import android.os.Build;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Created by dyoung on 3/24/17.
+ * @hice
+ */
+
+public class ScanDataProcessor {
+    private static final String TAG = ScanDataProcessor.class.getSimpleName();
+    private Service mService;
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    // TODO: implement this
+    private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+    private DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+    int trackedBeaconsPacketCount;
+
+
+    public ScanDataProcessor(Service scanService, ScanState scanState) {
+        mService = scanService;
+        mMonitoringStatus = scanState.getMonitoringStatus();
+        mRangedRegionState = scanState.getRangedRegionState();
+        mMonitoringStatus = scanState.getMonitoringStatus();
+        mExtraDataBeaconTracker = scanState.getExtraBeaconDataTracker();
+        mBeaconParsers = scanState.getBeaconParsers();
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public void process(ScanResult scanResult) {
+        ScanData scanData= new ScanData(scanResult.getDevice(), scanResult.getRssi(), scanResult.getScanRecord().getBytes());
+        process(scanData);
+    }
+
+    public void process(ScanData scanData) {
+        Beacon beacon = null;
+
+        for (BeaconParser parser : mBeaconParsers) {
+            beacon = parser.fromScanData(scanData.scanRecord,
+                    scanData.rssi, scanData.device);
+
+            if (beacon != null) {
+                break;
+            }
+        }
+        if (beacon != null) {
+            mDetectionTracker.recordDetection();
+            trackedBeaconsPacketCount++;
+            processBeaconFromScan(beacon);
+        } else {
+            if (mNonBeaconLeScanCallback != null) {
+                mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+            }
+        }
+
+    }
+    private class ScanData {
+        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        int rssi;
+        BluetoothDevice device;
+        byte[] scanRecord;
+    }
+
+    private void processBeaconFromScan(Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions = null;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon out of "+mRangedRegionState.keySet().size()+" regions.");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<Region>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+
+    public void onCycleEnd() {
+        mMonitoringStatus.updateNewlyOutside();
+        processRangeData();
+        if (BeaconManager.getBeaconSimulator() != null) {
+            // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+            // it will not be used if we are not in debug mode
+            if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                if (0 != (mService.getApplicationContext().getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                }
+            } else {
+                LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+            }
+        }
+    }
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                Callback callback = new Callback(mService.getPackageName());
+                callback.call(mService, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
new file mode 100644
index 00000000..d44700cc
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -0,0 +1,409 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanFilter;
+import android.bluetooth.le.ScanSettings;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.WorkerThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+import org.altbeacon.beacon.service.scanner.ScanFilterUtils;
+import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
+import org.altbeacon.bluetooth.BluetoothCrashResolver;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * Created by dyoung on 6/16/17.
+ *
+ * This is an internal utility class and should not be called directly by library users.
+ *
+ * This encapsulates shared data and methods used by both ScanJob and BeaconService
+ * that deal with the specifics of beacon scanning.
+ *
+ * @hide
+ */
+
+class ScanHelper {
+    private static final String TAG = ScanHelper.class.getSimpleName();
+    private ExecutorService mExecutor;
+    private BeaconManager mBeaconManager;
+    private CycledLeScanner mCycledScanner;
+    private MonitoringStatus mMonitoringStatus;
+    private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
+    private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<>();
+    private List<Beacon> mSimulatedScanData = null;
+    private Context mContext;
+
+    ScanHelper(Context context) {
+        mContext = context;
+        mBeaconManager = BeaconManager.getInstanceForApplication(context);
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
+    }
+
+    CycledLeScanner getCycledScanner() {
+        return mCycledScanner;
+    }
+
+    MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        synchronized (mRangedRegionState) {
+            mRangedRegionState.clear();
+            mRangedRegionState.putAll(rangedRegionState);
+        }
+    }
+
+    void setExtraDataBeaconTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraDataBeaconTracker = extraDataBeaconTracker;
+    }
+
+    void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    void setSimulatedScanData(List<Beacon> simulatedScanData) {
+        mSimulatedScanData = simulatedScanData;
+    }
+
+
+    void createCycledLeScanner(boolean backgroundMode, BluetoothCrashResolver crashResolver) {
+        mCycledScanner = CycledLeScanner.createScanner(mContext, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
+                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, backgroundMode,
+                mCycledLeScanCallback, crashResolver);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    void processScanResult(BluetoothDevice device, int rssi, byte[] scanRecord) {
+        NonBeaconLeScanCallback nonBeaconLeScanCallback = mBeaconManager.getNonBeaconLeScanCallback();
+
+        try {
+            new ScanHelper.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
+                    new ScanHelper.ScanData(device, rssi, scanRecord));
+        } catch (RejectedExecutionException e) {
+
+            LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+        }
+    }
+
+    void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<>();
+        //flatMap all beacon parsers
+        boolean matchBeaconsByServiceUUID = true;
+        newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
+        for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
+            if (beaconParser.getExtraDataParsers().size() > 0) {
+                matchBeaconsByServiceUUID = false;
+                newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
+            }
+        }
+        mBeaconParsers = newBeaconParsers;
+        //initialize the extra data beacon tracker
+        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    void startAndroidOBackgroundScan(Set<BeaconParser> beaconParsers) {
+        ScanSettings settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
+        List<ScanFilter> filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
+                new ArrayList<BeaconParser>(beaconParsers));
+        try {
+            final BluetoothManager bluetoothManager =
+                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();
+            if (bluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            } else if (!bluetoothAdapter.isEnabled()) {
+                LogManager.w(TAG, "Failed to start background scan on Android O: BluetoothAdapter is not enabled");
+            } else {
+                int result = bluetoothAdapter.getBluetoothLeScanner().startScan(filters, settings, getScanCallbackIntent());
+                if (result != 0) {
+                    LogManager.e(TAG, "Failed to start background scan on Android O.  Code: "+result);
+                }
+                else {
+                    LogManager.d(TAG, "Started passive beacon scan");
+                }
+            }
+        }
+        catch (SecurityException e) {
+            LogManager.e(TAG, "SecurityException making Android O background scanner");
+        }
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    void stopAndroidOBackgroundScan() {
+        try {
+            final BluetoothManager bluetoothManager =
+                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();
+            if (bluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            } else if (!bluetoothAdapter.isEnabled()) {
+                LogManager.w(TAG, "BluetoothAdapter is not enabled");
+            } else {
+               BluetoothLeScanner scanner =  bluetoothAdapter.getBluetoothLeScanner();
+               if (scanner != null) {
+                   scanner.stopScan(getScanCallbackIntent());
+               }
+            }
+        } catch (SecurityException e) {
+            LogManager.e(TAG, "SecurityException stopping Android O background scanner");
+        }
+    }
+
+    // Low power scan results in the background will be delivered via Intent
+    PendingIntent getScanCallbackIntent() {
+        Intent intent = new Intent(mContext, StartupBroadcastReceiver.class);
+        intent.putExtra("o-scan", true);
+        return PendingIntent.getBroadcast(mContext,0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+    }
+
+    private final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+        @Override
+        @MainThread
+        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            processScanResult(device, rssi, scanRecord);
+        }
+
+        @Override
+        @MainThread
+        @SuppressLint("WrongThread")
+        public void onCycleEnd() {
+            mDistinctPacketDetector.clearDetections();
+            mMonitoringStatus.updateNewlyOutside();
+            processRangeData();
+            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
+            if (mSimulatedScanData != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
+
+                if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : mSimulatedScanData) {
+                        // This is an expensive call and we do not want to block the main thread.
+                        // But here we are in debug/test mode so we allow it on the main thread.
+                        //noinspection WrongThread
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
+                }
+            }
+            if (BeaconManager.getBeaconSimulator() != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                    if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                            // This is an expensive call and we do not want to block the main thread.
+                            // But here we are in debug/test mode so we allow it on the main thread.
+                            //noinspection WrongThread
+                            processBeaconFromScan(beacon);
+                        }
+                    } else {
+                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                    }
+                } else {
+                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+                }
+            }
+        }
+    };
+
+    @RestrictTo(Scope.TESTS)
+    CycledLeScanCallback getCycledLeScanCallback() {
+        return mCycledLeScanCallback;
+    }
+
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                rangeState.getCallback().call(mContext, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+    /**
+     * Helper for processing BLE beacons. This has been extracted from {@link ScanHelper.ScanProcessor} to
+     * support simulated scan data for test and debug environments.
+     * <p>
+     * Processing beacons is a frequent and expensive operation. It should not be run on the main
+     * thread to avoid UI contention.
+     */
+    @WorkerThread
+    private void processBeaconFromScan(@NonNull Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * <strong>This class is not thread safe.</strong>
+     */
+    private class ScanData {
+        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        final int rssi;
+
+        @NonNull
+        BluetoothDevice device;
+
+        @NonNull
+        byte[] scanRecord;
+    }
+
+    private class ScanProcessor extends AsyncTask<ScanHelper.ScanData, Void, Void> {
+        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+        ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
+            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
+        }
+
+        @WorkerThread
+        @Override
+        protected Void doInBackground(ScanHelper.ScanData... params) {
+            ScanHelper.ScanData scanData = params[0];
+            Beacon beacon = null;
+
+            for (BeaconParser parser : ScanHelper.this.mBeaconParsers) {
+                beacon = parser.fromScanData(scanData.scanRecord,
+                        scanData.rssi, scanData.device);
+
+                if (beacon != null) {
+                    break;
+                }
+            }
+            if (beacon != null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                }
+                mDetectionTracker.recordDetection();
+                if (mCycledScanner != null && !mCycledScanner.getDistinctPacketsDetectedPerScan()) {
+                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
+                            scanData.scanRecord)) {
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
+                    }
+                }
+                processBeaconFromScan(beacon);
+            } else {
+                if (mNonBeaconLeScanCallback != null) {
+                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+                }
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+        }
+
+        @Override
+        protected void onPreExecute() {
+        }
+
+        @Override
+        protected void onProgressUpdate(Void... values) {
+        }
+    }
+
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
new file mode 100644
index 00000000..f97770bc
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -0,0 +1,205 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.job.JobParameters;
+import android.app.job.JobService;
+import android.bluetooth.le.ScanRecord;
+import android.bluetooth.le.ScanResult;
+import android.os.Build;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
+import org.altbeacon.beacon.BuildConfig;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.utils.ProcessUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Used to perform scans periodically using the JobScheduler
+ *
+ * Only one instance of this will be active, even with multiple jobIds.  If one job
+ * is already running when another is scheduled to start, onStartJob gets called again on the same
+ * instance.
+ *
+ * If the OS decides to create a new instance, it will call onStopJob() on the old instance
+ *
+ * Created by dyoung on 3/24/17.
+ * @hide
+ */
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+public class ScanJob extends JobService {
+    private static final String TAG = ScanJob.class.getSimpleName();
+    public static final int PERIODIC_SCAN_JOB_ID = 1;
+    /*
+        Periodic scan jobs are used in general, but they cannot be started immediately.  So we have
+        a second immediate scan job to kick off when scanning gets started or settings changed.
+        Once the periodic one gets run, the immediate is cancelled.
+     */
+    public static final int IMMMEDIATE_SCAN_JOB_ID = 2;
+
+    private ScanState mScanState;
+    private Handler mStopHandler = new Handler();
+    private ScanHelper mScanHelper;
+    private boolean mInitialized = false;
+
+    @Override
+    public boolean onStartJob(final JobParameters jobParameters) {
+        mScanHelper = new ScanHelper(this);
+        if (jobParameters.getJobId() == IMMMEDIATE_SCAN_JOB_ID) {
+            LogManager.i(TAG, "Running immdiate scan job: instance is "+this);
+        }
+        else {
+            LogManager.i(TAG, "Running periodic scan job: instance is "+this);
+        }
+
+        List<ScanResult> queuedScanResults = ScanJobScheduler.getInstance().dumpBackgroundScanResultQueue();
+        LogManager.d(TAG, "Processing %d queued scan resuilts", queuedScanResults.size());
+        for (ScanResult result : queuedScanResults) {
+            ScanRecord scanRecord = result.getScanRecord();
+            if (scanRecord != null) {
+                mScanHelper.processScanResult(result.getDevice(), result.getRssi(), scanRecord.getBytes());
+            }
+        }
+        LogManager.d(TAG, "Done processing queued scan resuilts");
+
+        boolean startedScan;
+        if (mInitialized) {
+            LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
+            startedScan = restartScanning();
+        }
+        else {
+            startedScan = startScanning();
+        }
+        mStopHandler.removeCallbacksAndMessages(null);
+
+        if (startedScan) {
+            LogManager.i(TAG, "Scan job running for "+mScanState.getScanJobRuntimeMillis()+" millis");
+            mStopHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    LogManager.i(TAG, "Scan job runtime expired");
+                    stopScanning();
+                    mScanState.save();
+
+                    startPassiveScanIfNeeded();
+
+                    ScanJob.this.jobFinished(jobParameters , false);
+                }
+            }, mScanState.getScanJobRuntimeMillis());
+        }
+        else {
+            LogManager.i(TAG, "Scanning not started so Scan job is complete.");
+            ScanJob.this.jobFinished(jobParameters , false);
+        }
+        return true;
+    }
+
+    private void startPassiveScanIfNeeded() {
+        LogManager.d(TAG, "Checking to see if we need to start a passive scan");
+        boolean insideAnyRegion = false;
+        // Clone the collection before iterating to prevent ConcurrentModificationException per #577
+        List<Region> regions = new ArrayList<>(mScanState.getMonitoringStatus().regions());
+        for (Region region : regions) {
+            RegionMonitoringState state = mScanState.getMonitoringStatus().stateOf(region);
+            if (state != null && state.getInside()) {
+                insideAnyRegion = true;
+            }
+        }
+        if (insideAnyRegion) {
+            // TODO: Set up a scan filter for not detecting a beacon pattern
+            LogManager.i(TAG, "We are inside a beacon region.  We will not scan between cycles.");
+        }
+        else {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                mScanHelper.startAndroidOBackgroundScan(mScanState.getBeaconParsers());
+            }
+            else {
+                LogManager.d(TAG, "This is not Android O.  No scanning between cycles when using ScanJob");
+            }
+        }
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters params) {
+        if (params.getJobId() == PERIODIC_SCAN_JOB_ID) {
+            LogManager.i(TAG, "onStopJob called for periodic scan");
+        }
+        else {
+            LogManager.i(TAG, "onStopJob called for immediate scan");
+        }
+        // Cancel the stop timer.  The OS is stopping prematurely
+        mStopHandler.removeCallbacksAndMessages(null);
+        stopScanning();
+        startPassiveScanIfNeeded();
+        return false;
+    }
+
+    private void stopScanning() {
+        mInitialized = false;
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        LogManager.d(TAG, "Scanning stopped");
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean restartScanning() {
+        mScanState = ScanState.restore(ScanJob.this);
+        mScanState.setLastScanStartTimeMillis(System.currentTimeMillis());
+        mScanHelper.setMonitoringStatus(mScanState.getMonitoringStatus());
+        mScanHelper.setRangedRegionState(mScanState.getRangedRegionState());
+        mScanHelper.setBeaconParsers(mScanState.getBeaconParsers());
+        mScanHelper.setExtraDataBeaconTracker(mScanState.getExtraBeaconDataTracker());
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
+        }
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            mScanHelper.stopAndroidOBackgroundScan();
+        }
+
+        long scanPeriod = mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod();
+        long betweenScanPeriod = mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod();
+        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod,
+                                                      betweenScanPeriod,
+                                                      mScanState.getBackgroundMode());
+        mInitialized = true;
+        if (scanPeriod <= 0) {
+            LogManager.w(TAG, "Starting scan with scan period of zero.  Exiting ScanJob.");
+            mScanHelper.getCycledScanner().stop();
+            return false;
+        }
+
+        if (mScanHelper.getRangedRegionState().size() > 0 || mScanHelper.getMonitoringStatus().regions().size() > 0) {
+            mScanHelper.getCycledScanner().start();
+            return true;
+        }
+        else {
+            mScanHelper.getCycledScanner().stop();
+            return false;
+        }
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean startScanning() {
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        beaconManager.setScannerInSameProcess(true);
+        if (beaconManager.isMainProcess()) {
+            LogManager.i(TAG, "scanJob version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+        }
+        else {
+            LogManager.i(TAG, "beaconScanJob library version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(ScanJob.this);
+            LogManager.i(TAG, "beaconScanJob PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
+        }
+        ModelSpecificDistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(ScanJob.this, BeaconManager.getDistanceModelUpdateUrl());
+        Beacon.setDistanceCalculator(defaultDistanceCalculator);
+        return restartScanning();
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
new file mode 100644
index 00000000..43ed2699
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -0,0 +1,236 @@
+package org.altbeacon.beacon.service;
+
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.bluetooth.le.ScanResult;
+import android.content.ComponentName;
+import android.content.Context;
+import android.os.Build;
+import android.os.PersistableBundle;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Schedules two types of ScanJobs:
+ *  1. Periodic, which are set to go every scanPeriod+betweenScanPeriod
+ *  2. Immediate, which go right now.
+ *
+ *  Immediate ScanJobs are used when the app is in the foreground and wants to get immediate results
+ *  or when beacons have been detected with background scan filters and delivered via Intents and
+ *  a scan needs to run in a timely manner to collect data about those beacons known to be newly
+ *  in the vicinity despite the app being in the background.
+ *
+ * Created by dyoung on 6/7/17.
+ * @hide
+ */
+@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+public class ScanJobScheduler {
+    private static final String TAG = ScanJobScheduler.class.getSimpleName();
+    private static final Object SINGLETON_LOCK = new Object();
+    private static final long MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING = 10000L;
+    @Nullable
+    private static volatile ScanJobScheduler sInstance = null;
+    @NonNull
+    private Long mScanJobScheduleTime = 0L;
+    @NonNull
+    private List<ScanResult> mBackgroundScanResultQueue = new ArrayList<>();
+    @Nullable
+    private BeaconLocalBroadcastProcessor mBeaconNotificationProcessor;
+
+    @NonNull
+    public static ScanJobScheduler getInstance() {
+        ScanJobScheduler instance = sInstance;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = sInstance;
+                if (instance == null) {
+                    sInstance = instance = new ScanJobScheduler();
+                }
+            }
+        }
+        return instance;
+    }
+
+    private ScanJobScheduler() {
+    }
+
+    private void ensureNotificationProcessorSetup(Context context) {
+        if (mBeaconNotificationProcessor == null) {
+            mBeaconNotificationProcessor = new BeaconLocalBroadcastProcessor(context);
+            mBeaconNotificationProcessor.register();
+        }
+    }
+
+    /**
+     * @return previoulsy queued scan results delivered in the background
+     */
+    List<ScanResult> dumpBackgroundScanResultQueue() {
+        List<ScanResult> retval = mBackgroundScanResultQueue;
+        mBackgroundScanResultQueue = new ArrayList<>();
+        return retval;
+    }
+
+    private void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
+        scanState.applyChanges(beaconManager);
+        LogManager.d(TAG, "Applying scan job settings with background mode "+scanState.getBackgroundMode());
+        schedule(context, scanState, false);
+    }
+
+    public void applySettingsToScheduledJob(Context context, BeaconManager beaconManager) {
+        LogManager.d(TAG, "Applying settings to ScanJob");
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        ScanState scanState = ScanState.restore(context);
+        applySettingsToScheduledJob(context, beaconManager, scanState);
+    }
+
+    // This method appears to be never used, because it is only used by Android O APIs, which
+    // must exist on another branch until the SDKs are released.
+    public void scheduleAfterBackgroundWakeup(Context context, List<ScanResult> scanResults) {
+        if (scanResults != null) {
+            mBackgroundScanResultQueue.addAll(scanResults);
+        }
+        synchronized (this) {
+            // We typically get a bunch of calls in a row here, separated by a few millis.  Only do this once.
+            if (System.currentTimeMillis() - mScanJobScheduleTime > MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING) {
+                LogManager.d(TAG, "scheduling an immediate scan job because last did "+(System.currentTimeMillis() - mScanJobScheduleTime)+"seconds ago.");
+                mScanJobScheduleTime = System.currentTimeMillis();
+            }
+            else {
+                LogManager.d(TAG, "Not scheduling an immediate scan job because we just did recently.");
+                return;
+            }
+        }
+        ScanState scanState = ScanState.restore(context);
+        schedule(context, scanState, true);
+    }
+
+    private void schedule(Context context, ScanState scanState, boolean backgroundWakeup) {
+        ensureNotificationProcessorSetup(context);
+
+        long betweenScanPeriod = scanState.getScanJobIntervalMillis() - scanState.getScanJobRuntimeMillis();
+
+        long millisToNextJobStart;
+        if (backgroundWakeup) {
+            LogManager.d(TAG, "We just woke up in the background based on a new scan result.  Start scan job immediately.");
+            millisToNextJobStart = 0;
+        }
+        else {
+            if (betweenScanPeriod > 0) {
+                // If we pause between scans, then we need to start scanning on a normalized time
+                millisToNextJobStart = (SystemClock.elapsedRealtime() % scanState.getScanJobIntervalMillis());
+            }
+            else {
+                millisToNextJobStart = 0;
+            }
+
+            if (millisToNextJobStart < 50) {
+                // always wait a little bit to start scanning in case settings keep changing.
+                // by user restarting settings and scanning.  50ms should be fine
+                millisToNextJobStart = 50;
+            }
+        }
+
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+
+        if (backgroundWakeup || !scanState.getBackgroundMode()) {
+            // If we are in the foreground, and we want to start a scan soon, we will schedule an
+            // immediate job
+            if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
+                // If the next time we want to scan is less than 50ms from the periodic scan cycle, then]
+                // we schedule it for that specific time.
+                LogManager.d(TAG, "Scheduling immediate ScanJob to run in "+millisToNextJobStart+" millis");
+                JobInfo immediateJob = new JobInfo.Builder(ScanJob.IMMMEDIATE_SCAN_JOB_ID, new ComponentName(context, ScanJob.class))
+                        .setPersisted(true) // This makes it restart after reboot
+                        .setExtras(new PersistableBundle())
+                        .setMinimumLatency(millisToNextJobStart)
+                        .setOverrideDeadline(millisToNextJobStart).build();
+                int error = jobScheduler.schedule(immediateJob);
+                if (error < 0) {
+                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+                }
+            }
+        }
+        else {
+            LogManager.d(TAG, "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
+            jobScheduler.cancel(ScanJob.IMMMEDIATE_SCAN_JOB_ID);
+        }
+
+        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(ScanJob.PERIODIC_SCAN_JOB_ID, new ComponentName(context, ScanJob.class))
+                .setPersisted(true) // This makes it restart after reboot
+                .setExtras(new PersistableBundle());
+
+        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            // ON Android N+ we specify a tolerance of 0ms (capped at 5% by the OS) to ensure
+            // our scans happen within 5% of the schduled time.
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0L).build();
+        }
+        else {
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis()).build();
+        }
+        // On Android O I see this:
+        //
+        // 06-07 22:15:51.361 6455-6455/org.altbeacon.beaconreference W/JobInfo: Specified interval for 1 is +5m10s0ms. Clamped to +15m0s0ms
+        // 06-07 22:15:51.361 6455-6455/org.altbeacon.beaconreference W/JobInfo: Specified flex for 1 is 0. Clamped to +5m0s0ms
+        //
+        // This suggests logs are being clamped at a max of every 15 minutes +/- 5 minutes in the background
+        // This is the same way it worked on Android N per this post: https://stackoverflow.com/questions/38344220/job-scheduler-not-running-on-android-n
+        //
+        // In practice, I see the following runtimes on the Nexus Player with Android O
+        // This shows that the 15 minutes has some slop.
+        //
+        /*
+06-07 22:25:51.380 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@7188bc6
+06-07 22:41:01.227 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@382ed7b
+06-07 22:55:51.373 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@203c928
+06-07 23:10:59.083 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@dc96415
+06-07 23:25:51.371 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@68bed2e
+06-07 23:40:59.142 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c295843
+06-07 23:55:51.369 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@cd047e4
+06-08 00:10:59.082 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@8009a61
+06-08 00:25:51.368 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@f1fa2ca
+06-08 00:40:59.085 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@88dddef
+06-08 00:55:51.374 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@eb2b360
+06-08 01:10:51.670 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@9bca225
+06-08 01:25:51.383 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@871c8fe
+06-08 01:45:51.404 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@3bf42d3
+06-08 01:56:12.354 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c3d4e34
+06-08 02:21:51.771 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@1557571
+06-08 02:37:01.861 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@e2c879a
+06-08 02:52:11.943 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c9f0d7f
+06-08 03:07:22.041 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@4e0cab0
+06-08 03:23:12.696 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@1139a7d
+06-08 03:38:22.776 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@e06b8f6
+06-08 03:52:12.792 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@74147eb
+06-08 04:08:32.872 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@90d9fec
+06-08 04:21:12.856 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@a4abd49
+06-08 04:38:42.959 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@741d912
+06-08 04:50:12.923 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@15bfe17
+06-08 05:08:53.047 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@fa229e8
+06-08 05:19:13.050 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@b0e49d5
+06-08 05:39:03.142 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@18823ee
+06-08 05:54:13.212 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@a72fc03
+06-08 06:10:51.850 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@3fb84a4
+06-08 06:26:01.917 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@53d6c21
+06-08 06:41:11.994 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@848958a
+06-08 06:56:22.053 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@43cdaf
+06-08 07:06:32.119 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@5318c20
+06-08 07:29:12.356 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@34f102d
+06-08 07:44:22.431 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@4d2e9e6
+         */
+
+        LogManager.d(TAG, "Scheduling ScanJob to run every "+scanState.getScanJobIntervalMillis()+" millis");
+        int error = jobScheduler.schedule(periodicJobBuilder.build());
+        if (error < 0) {
+            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+        }
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanState.java b/src/main/java/org/altbeacon/beacon/service/ScanState.java
new file mode 100644
index 00000000..3e3fbddd
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanState.java
@@ -0,0 +1,294 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+import android.util.Log;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InvalidClassException;
+import java.io.FileNotFoundException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static android.content.Context.MODE_PRIVATE;
+
+/**
+ * Stores the full state of scanning for the libary, including all settings so it can be ressurrected easily
+ * for running from a scheduled job
+ *
+ * Created by dyoung on 3/26/17.
+ * @hide
+ */
+
+public class ScanState implements Serializable {
+    private static final String TAG = ScanState.class.getSimpleName();
+    private static final String STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state";
+    private static final String TEMP_STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state-temp";
+    public static int MIN_SCAN_JOB_INTERVAL_MILLIS = 300000; //  5 minutes
+
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private transient MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+    private long mForegroundBetweenScanPeriod;
+    private long mBackgroundBetweenScanPeriod;
+    private long mForegroundScanPeriod;
+    private long mBackgroundScanPeriod;
+    private boolean mBackgroundMode;
+    private long mLastScanStartTimeMillis = 0l;
+    private transient Context mContext;
+
+    public Boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+
+    public void setBackgroundMode(Boolean backgroundMode) {
+        mBackgroundMode = backgroundMode;
+    }
+
+    public Long getBackgroundBetweenScanPeriod() {
+        return mBackgroundBetweenScanPeriod;
+    }
+
+    public void setBackgroundBetweenScanPeriod(Long backgroundBetweenScanPeriod) {
+        mBackgroundBetweenScanPeriod = backgroundBetweenScanPeriod;
+    }
+
+    public Long getBackgroundScanPeriod() {
+        return mBackgroundScanPeriod;
+    }
+
+    public void setBackgroundScanPeriod(Long backgroundScanPeriod) {
+        mBackgroundScanPeriod = backgroundScanPeriod;
+    }
+
+    public Long getForegroundBetweenScanPeriod() {
+        return mForegroundBetweenScanPeriod;
+    }
+
+    public void setForegroundBetweenScanPeriod(Long foregroundBetweenScanPeriod) {
+        mForegroundBetweenScanPeriod = foregroundBetweenScanPeriod;
+    }
+
+    public Long getForegroundScanPeriod() {
+        return mForegroundScanPeriod;
+    }
+
+    public void setForegroundScanPeriod(Long foregroundScanPeriod) {
+        mForegroundScanPeriod = foregroundScanPeriod;
+    }
+
+    public ScanState(Context context) {
+        mContext = context;
+    }
+
+    public MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    public void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    public Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    public void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        mRangedRegionState = rangedRegionState;
+    }
+
+    public ExtraDataBeaconTracker getExtraBeaconDataTracker() {
+        return mExtraBeaconDataTracker;
+    }
+
+    public void setExtraBeaconDataTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraBeaconDataTracker = extraDataBeaconTracker;
+    }
+
+    public Set<BeaconParser> getBeaconParsers() {
+        return mBeaconParsers;
+    }
+
+    public void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    public long getLastScanStartTimeMillis() {
+        return mLastScanStartTimeMillis;
+    }
+    public void setLastScanStartTimeMillis(long time) {
+        mLastScanStartTimeMillis = time;
+    }
+
+    public static ScanState restore(Context context) {
+        ScanState scanState = null;
+        synchronized (ScanState.class) {
+            FileInputStream inputStream = null;
+            ObjectInputStream objectInputStream = null;
+            try {
+                inputStream = context.openFileInput(STATUS_PRESERVATION_FILE_NAME);
+                objectInputStream = new ObjectInputStream(inputStream);
+                scanState = (ScanState) objectInputStream.readObject();
+                scanState.mContext = context;
+            } catch (FileNotFoundException fnfe) {
+                LogManager.w(TAG, "Serialized ScanState does not exist.  This may be normal on first run.");
+            }
+            catch (IOException | ClassNotFoundException | ClassCastException e) {
+                if (e instanceof InvalidClassException) {
+                    LogManager.d(TAG, "Serialized ScanState has wrong class. Just ignoring saved state...");
+                }
+                else {
+                    LogManager.e(TAG, "Deserialization exception");
+                    Log.e(TAG, "error: ", e);
+                }
+
+            } finally {
+                if (null != inputStream) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectInputStream != null) {
+                    try {
+                        objectInputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            if (scanState == null) {
+                scanState = new ScanState(context);
+
+            }
+            if (scanState.mExtraBeaconDataTracker == null) {
+                scanState.mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+            }
+            scanState.mMonitoringStatus = MonitoringStatus.getInstanceForApplication(context);
+            LogManager.d(TAG, "Scan state restore regions: monitored="+scanState.getMonitoringStatus().regions().size()+" ranged="+scanState.getRangedRegionState().keySet().size());
+            return scanState;
+        }
+    }
+
+    public void save() {
+        synchronized (ScanState.class) {
+            // TODO: need to limit how big this object is somehow.
+            // Impose limits on ranged and monitored regions?
+            FileOutputStream outputStream = null;
+            ObjectOutputStream objectOutputStream = null;
+            try {
+                outputStream = mContext.openFileOutput(TEMP_STATUS_PRESERVATION_FILE_NAME, MODE_PRIVATE);
+                objectOutputStream = new ObjectOutputStream(outputStream);
+                objectOutputStream.writeObject(this);
+                File file = new File(mContext.getFilesDir(), STATUS_PRESERVATION_FILE_NAME);
+                File tempFile = new File(mContext.getFilesDir(), TEMP_STATUS_PRESERVATION_FILE_NAME);
+                LogManager.d(TAG, "Temp file is "+tempFile.getAbsolutePath());
+                LogManager.d(TAG, "Perm file is "+file.getAbsolutePath());
+
+                if (!file.delete()) {
+                    LogManager.e(TAG, "Error while saving scan status to file: Cannot delete existing file.");
+                }
+                if (!tempFile.renameTo(file)) {
+                    LogManager.e(TAG, "Error while saving scan status to file: Cannot rename temp file.");
+                }
+            } catch (IOException e) {
+                LogManager.e(TAG, "Error while saving scan status to file: ", e.getMessage());
+            } finally {
+                if (null != outputStream) {
+                    try {
+                        outputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectOutputStream != null) {
+                    try {
+                        objectOutputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            mMonitoringStatus.saveMonitoringStatusIfOn();
+        }
+    }
+
+    public int getScanJobIntervalMillis() {
+        long cyclePeriodMillis;
+        if (getBackgroundMode()) {
+            cyclePeriodMillis = getBackgroundScanPeriod()+getBackgroundBetweenScanPeriod();
+        }
+        else {
+            cyclePeriodMillis = getForegroundScanPeriod()+getForegroundBetweenScanPeriod();
+        }
+        int scanJobIntervalMillis = MIN_SCAN_JOB_INTERVAL_MILLIS;
+        if (cyclePeriodMillis > MIN_SCAN_JOB_INTERVAL_MILLIS) {
+            scanJobIntervalMillis = (int) cyclePeriodMillis;
+        }
+        return scanJobIntervalMillis;
+    }
+
+    public int getScanJobRuntimeMillis() {
+        long scanPeriodMillis;
+        LogManager.d(TAG, "ScanState says background mode for ScanJob is "+getBackgroundMode());
+        if (getBackgroundMode()) {
+            scanPeriodMillis = getBackgroundScanPeriod();
+        }
+        else {
+            scanPeriodMillis = getForegroundScanPeriod();
+        }
+        if (!getBackgroundMode()) {
+            // if we are in the foreground, we keep the scan job going for the minimum interval
+            if (scanPeriodMillis < MIN_SCAN_JOB_INTERVAL_MILLIS) {
+                return MIN_SCAN_JOB_INTERVAL_MILLIS;
+            }
+        }
+        return (int) scanPeriodMillis;
+    }
+
+
+
+    public void applyChanges(BeaconManager beaconManager) {
+        mBeaconParsers = new HashSet<>(beaconManager.getBeaconParsers());
+        mForegroundScanPeriod = beaconManager.getForegroundScanPeriod();
+        mForegroundBetweenScanPeriod = beaconManager.getForegroundBetweenScanPeriod();
+        mBackgroundScanPeriod = beaconManager.getBackgroundScanPeriod();
+        mBackgroundBetweenScanPeriod = beaconManager.getBackgroundBetweenScanPeriod();
+        mBackgroundMode = beaconManager.getBackgroundMode();
+
+        ArrayList<Region> existingMonitoredRegions = new ArrayList<>(mMonitoringStatus.regions());
+        ArrayList<Region> existingRangedRegions = new ArrayList<>(mRangedRegionState.keySet());
+        ArrayList<Region> newMonitoredRegions = new ArrayList<>(beaconManager.getMonitoredRegions());
+        ArrayList<Region> newRangedRegions = new ArrayList<>(beaconManager.getRangedRegions());
+        LogManager.d(TAG, "ranged regions: old="+existingRangedRegions.size()+" new="+newRangedRegions.size());
+        LogManager.d(TAG, "monitored regions: old="+existingMonitoredRegions.size()+" new="+newMonitoredRegions.size());
+
+        for (Region newRangedRegion: newRangedRegions) {
+            if (!existingRangedRegions.contains(newRangedRegion)) {
+                LogManager.d(TAG, "Starting ranging region: "+newRangedRegion);
+                mRangedRegionState.put(newRangedRegion, new RangeState(new Callback(mContext.getPackageName())));
+            }
+        }
+        for (Region existingRangedRegion: existingRangedRegions) {
+            if (!newRangedRegions.contains(existingRangedRegion)) {
+                LogManager.d(TAG, "Stopping ranging region: "+existingRangedRegion);
+                mRangedRegionState.remove(existingRangedRegion);
+            }
+        }
+        LogManager.d(TAG, "Updated state with "+newRangedRegions.size()+" ranging regions and "+newMonitoredRegions.size()+" monitoring regions.");
+
+        this.save();
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/beacon/service/SettingsData.java b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
new file mode 100644
index 00000000..d1202336
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
@@ -0,0 +1,108 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by dyoung on 3/10/17.
+ *
+ * Internal class used to transfer settings between the BeaconService and the client
+ *
+ * @hide
+ */
+public class SettingsData implements Serializable {
+    private static final String TAG = SettingsData.class.getSimpleName();
+    private static final String SETTINGS_DATA_KEY = "SettingsData";
+    ArrayList<BeaconParser> mBeaconParsers;
+    Boolean mRegionStatePersistenceEnabled;
+    Boolean mAndroidLScanningDisabled;
+    Long mRegionExitPeriod;
+    Boolean mUseTrackingCache;
+    Boolean mHardwareEqualityEnforced;
+
+    // The following configuration settings are not implemented here, so they cannot be set when
+    // the scanning service is running in another process
+    //        BeaconManager.setDistanceModelUpdateUrl(...)
+    //        BeaconManager.setRssiFilterImplClass(...)
+    //        BeaconManager.setBeaconSimulator(...)
+    //        beaconManager.setNonBeaconLeScanCallback(...)
+
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(SETTINGS_DATA_KEY, this);
+        return bundle;
+    }
+    public static SettingsData fromBundle(@NonNull Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        SettingsData settingsData = null;
+        if (bundle.get(SETTINGS_DATA_KEY) != null) {
+            settingsData = (SettingsData) bundle.getSerializable(SETTINGS_DATA_KEY);
+        }
+        return settingsData;
+    }
+
+    public void apply(@NonNull BeaconService scanService) {
+        LogManager.d(TAG, "Applying settings changes to scanner in other process");
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(scanService);
+        List<BeaconParser> beaconParsers = beaconManager.getBeaconParsers();
+        boolean beaconParsersChanged = false;
+        if (beaconParsers.size() == mBeaconParsers.size()) {
+            for (int i = 0; i < beaconParsers.size(); i++) {
+                if (!beaconParsers.get(i).equals(mBeaconParsers.get(i))) {
+                    LogManager.d(TAG, "Beacon parsers have changed to: "+mBeaconParsers.get(i).getLayout());
+                    beaconParsersChanged = true;
+                    break;
+                }
+            }
+        }
+        else {
+            beaconParsersChanged = true;
+            LogManager.d(TAG, "Beacon parsers have been added or removed.");
+        }
+        if (beaconParsersChanged) {
+            LogManager.d(TAG, "Updating beacon parsers");
+            beaconManager.getBeaconParsers().clear();
+            beaconManager.getBeaconParsers().addAll(mBeaconParsers);
+            scanService.reloadParsers();
+        }
+        else {
+            LogManager.d(TAG, "Beacon parsers unchanged.");
+        }
+        MonitoringStatus monitoringStatus = MonitoringStatus.getInstanceForApplication(scanService);
+        if (monitoringStatus.isStatePreservationOn() &&
+                !mRegionStatePersistenceEnabled) {
+            monitoringStatus.stopStatusPreservation();
+        }
+        else if (!monitoringStatus.isStatePreservationOn() &&
+                mRegionStatePersistenceEnabled) {
+            monitoringStatus.startStatusPreservation();
+        }
+        beaconManager.setAndroidLScanningDisabled(mAndroidLScanningDisabled);
+        BeaconManager.setRegionExitPeriod(mRegionExitPeriod);
+        RangeState.setUseTrackingCache(mUseTrackingCache);
+        Beacon.setHardwareEqualityEnforced(mHardwareEqualityEnforced);
+    }
+
+    public SettingsData collect(@NonNull Context context) {
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context);
+        mBeaconParsers = new ArrayList<>(beaconManager.getBeaconParsers());
+        mRegionStatePersistenceEnabled = beaconManager.isRegionStatePersistenceEnabled();
+        mAndroidLScanningDisabled = beaconManager.isAndroidLScanningDisabled();
+        mRegionExitPeriod = BeaconManager.getRegionExitPeriod();
+        mUseTrackingCache = RangeState.getUseTrackingCache();
+        mHardwareEqualityEnforced = Beacon.getHardwareEqualityEnforced();
+        return this;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/StartRMData.java b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
index c91e4070..1fa8a6d6 100644
--- a/src/main/java/org/altbeacon/beacon/service/StartRMData.java
+++ b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
@@ -23,58 +23,75 @@
  */
 package org.altbeacon.beacon.service;
 
+import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.support.annotation.NonNull;
 
 import org.altbeacon.beacon.Region;
 
 import java.io.Serializable;
 
+/**
+ *
+ * Internal class used to transfer ranging and monitoring data between the BeaconService and client
+ *
+ * @hide
+ */
 public class StartRMData implements Serializable, Parcelable {
-    private Region region;
-    private long scanPeriod;
-    private long betweenScanPeriod;
-    private boolean backgroundFlag;
-    private String callbackPackageName;
-
-    public StartRMData(Region region, String callbackPackageName) {
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
+    private static final String SCAN_PERIOD_KEY = "scanPeriod";
+    private static final String BETWEEN_SCAN_PERIOD_KEY = "betweenScanPeriod";
+    private static final String BACKGROUND_FLAG_KEY = "backgroundFlag";
+    private static final String CALLBACK_PACKAGE_NAME_KEY = "callbackPackageName";
+    private static final String REGION_KEY = "region";
+
+    private Region mRegion;
+    private long mScanPeriod;
+    private long mBetweenScanPeriod;
+    private boolean mBackgroundFlag;
+    private String mCallbackPackageName;
+
+    private StartRMData() {
+    }
+
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName) {
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
     }
     public StartRMData(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.backgroundFlag = backgroundFlag;
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mBackgroundFlag = backgroundFlag;
     }
 
-    public StartRMData(Region region, String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
-        this.backgroundFlag = backgroundFlag;
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
+        this.mBackgroundFlag = backgroundFlag;
     }
 
 
-    public long getScanPeriod() { return scanPeriod; }
-    public long getBetweenScanPeriod() { return betweenScanPeriod; }
+    public long getScanPeriod() { return mScanPeriod; }
+    public long getBetweenScanPeriod() { return mBetweenScanPeriod; }
     public Region getRegionData() {
-        return region;
+        return mRegion;
     }
     public String getCallbackPackageName() {
-        return callbackPackageName;
+        return mCallbackPackageName;
     }
-    public boolean getBackgroundFlag() { return backgroundFlag; }
+    public boolean getBackgroundFlag() { return mBackgroundFlag; }
     public int describeContents() {
         return 0;
     }
 
     public void writeToParcel(Parcel out, int flags) {
-        out.writeParcelable(region, flags);
-        out.writeString(callbackPackageName);
-        out.writeLong(scanPeriod);
-        out.writeLong(betweenScanPeriod);
-        out.writeByte((byte) (backgroundFlag ? 1 : 0));
+        out.writeParcelable(mRegion, flags);
+        out.writeString(mCallbackPackageName);
+        out.writeLong(mScanPeriod);
+        out.writeLong(mBetweenScanPeriod);
+        out.writeByte((byte) (mBackgroundFlag ? 1 : 0));
     }
 
     public static final Parcelable.Creator<StartRMData> CREATOR
@@ -89,11 +106,52 @@ public StartRMData createFromParcel(Parcel in) {
     };
 
     private StartRMData(Parcel in) {
-        region = in.readParcelable(StartRMData.class.getClassLoader());
-        callbackPackageName = in.readString();
-        scanPeriod = in.readLong();
-        betweenScanPeriod = in.readLong();
-        backgroundFlag = in.readByte() != 0;
+        mRegion = in.readParcelable(StartRMData.class.getClassLoader());
+        mCallbackPackageName = in.readString();
+        mScanPeriod = in.readLong();
+        mBetweenScanPeriod = in.readLong();
+        mBackgroundFlag = in.readByte() != 0;
+    }
+
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putLong(SCAN_PERIOD_KEY, this.mScanPeriod);
+        bundle.putLong(BETWEEN_SCAN_PERIOD_KEY, this.mBetweenScanPeriod);
+        bundle.putBoolean(BACKGROUND_FLAG_KEY, this.mBackgroundFlag);
+        bundle.putString(CALLBACK_PACKAGE_NAME_KEY, this.mCallbackPackageName);
+        if (mRegion != null) {
+            bundle.putSerializable(REGION_KEY, mRegion);
+        }
+        return bundle;
+    }
+
+    public static StartRMData fromBundle(@NonNull Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        boolean valid = false;
+        StartRMData data = new StartRMData();
+        if (bundle.containsKey(REGION_KEY)) {
+            data.mRegion = (Region)bundle.getSerializable(REGION_KEY);
+            valid = true;
+        }
+        if (bundle.containsKey(SCAN_PERIOD_KEY)) {
+            data.mScanPeriod = (Long) bundle.get(SCAN_PERIOD_KEY);
+            valid = true;
+        }
+        if (bundle.containsKey(BETWEEN_SCAN_PERIOD_KEY)) {
+            data.mBetweenScanPeriod = (Long) bundle.get(BETWEEN_SCAN_PERIOD_KEY);
+        }
+        if (bundle.containsKey(BACKGROUND_FLAG_KEY)) {
+            data.mBackgroundFlag = (Boolean) bundle.get(BACKGROUND_FLAG_KEY);
+        }
+        if (bundle.containsKey(CALLBACK_PACKAGE_NAME_KEY)) {
+            data.mCallbackPackageName = (String) bundle.get(CALLBACK_PACKAGE_NAME_KEY);
+        }
+        if (valid) {
+            return data;
+        }
+        else {
+            return null;
+        }
     }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/Stats.java b/src/main/java/org/altbeacon/beacon/service/Stats.java
index 94f5266f..aaac630b 100644
--- a/src/main/java/org/altbeacon/beacon/service/Stats.java
+++ b/src/main/java/org/altbeacon/beacon/service/Stats.java
@@ -12,7 +12,12 @@
  * Created by dyoung on 10/16/14.
  */
 public class Stats {
+    private static final Stats INSTANCE = new Stats();
     private static final String TAG = "Stats";
+
+    /**
+     * Synchronize all usage as this is not a thread safe class.
+     */
     private static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat("HH:mm:ss.SSS");
 
     private ArrayList<Sample> mSamples;
@@ -21,14 +26,11 @@
     private boolean mEnableHistoricalLogging;
     private boolean mEnabled;
     private Sample mSample;
-    private static Stats mInstance;
 
     public static Stats getInstance() {
-        if(mInstance == null) {
-            mInstance = new Stats();
-        }
-        return mInstance;
+        return INSTANCE;
     }
+
     private Stats() {
         mSampleIntervalMillis = 0l;
         clearSamples();
@@ -105,7 +107,13 @@ private void logSample(Sample sample, boolean showHeader) {
     }
 
     private String formattedDate(Date d) {
-        return d == null ? "" : SIMPLE_DATE_FORMAT.format(d);
+        String formattedDate = "";
+        if (d != null) {
+            synchronized (SIMPLE_DATE_FORMAT) {
+                formattedDate = SIMPLE_DATE_FORMAT.format(d);
+            }
+        }
+        return formattedDate;
     }
 
     private void logSamples() {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
index 3fe8904c..f8066130 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
@@ -1,11 +1,18 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.bluetooth.BluetoothDevice;
+import android.support.annotation.MainThread;
 
 /**
+ * Android API agnostic Bluetooth scan callback wrapper.
+ * <p>
+ * Since Android bluetooth scan callbacks occur on the main thread it is expected that these
+ * callbacks will also occur on the main thread.
+ *
  * Created by dyoung on 10/6/14.
  */
+@MainThread
 public interface CycledLeScanCallback {
-    public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);
-    public void onCycleEnd();
+    void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);
+    void onCycleEnd();
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 4d370d55..0089b18e 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -1,7 +1,6 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.Manifest;
-import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
@@ -15,6 +14,10 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.AnyThread;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
@@ -25,6 +28,7 @@
 
 @TargetApi(18)
 public abstract class CycledLeScanner {
+    public static final long ANDROID_N_MAX_SCAN_DURATION_MILLIS = 30 * 60 * 1000l; // 30 minutes
     private static final String TAG = "CycledLeScanner";
     private BluetoothAdapter mBluetoothAdapter;
 
@@ -32,19 +36,49 @@
     private long mLastScanCycleEndTime = 0l;
     protected long mNextScanCycleStartTime = 0l;
     private long mScanCycleStopTime = 0l;
-    private long mLastScanStopTime = 0l;
-
+    // This is the last time this class actually commanded the OS
+    // to start scanning.
+    private long mCurrentScanStartTime = 0l;
+    // True if the app has explicitly requested long running scans that
+    // may go beyond what is normally allowed on Android N.
+    private boolean mLongScanForcingEnabled = false;
     private boolean mScanning;
     protected boolean mScanningPaused;
     private boolean mScanCyclerStarted = false;
     private boolean mScanningEnabled = false;
     protected final Context mContext;
     private long mScanPeriod;
+    // indicates that we decided not to turn scanning off at the end of a scan cycle (e.g. to
+    // avoid doing too many scans in a limited time on Android 7.0 or because we are capable of
+    // multiple detections.  If true, it indicates scanning needs to be stopped when we finish.
+    private boolean mScanningLeftOn = false;
 
     protected long mBetweenScanPeriod;
 
+    /**
+     * Main thread handle for scheduling scan cycle tasks.
+     * <p>
+     * Use this to schedule deferred tasks such as the following:
+     * <ul>
+     *     <li>{@link #scheduleScanCycleStop()}</li>
+     *     <li>{@link #scanLeDevice(Boolean) scanLeDevice(true)} from {@link #deferScanIfNeeded()}</li>
+     * </ul>
+     */
+    @NonNull
     protected final Handler mHandler = new Handler(Looper.getMainLooper());
+
+    /**
+     * Handler to background thread for interacting with the low-level Android BLE scanner.
+     * <p>
+     * Use this to queue any potentially long running BLE scanner actions such as starts and stops.
+     */
+    @NonNull
     protected final Handler mScanHandler;
+
+    /**
+     * Worker thread hosting the internal scanner message queue.
+     */
+    @NonNull
     private final HandlerThread mScanThread;
 
     protected final BluetoothCrashResolver mBluetoothCrashResolver;
@@ -53,6 +87,22 @@
     protected boolean mBackgroundFlag = false;
     protected boolean mRestartNeeded = false;
 
+    /**
+     * Flag indicating device hardware supports detecting multiple identical packets per scan.
+     * <p>
+     * Restarting scanning (stopping and immediately restarting) is necessary on many older Android
+     * devices like the Nexus 4 and Moto G because once they detect a distinct BLE packet in a scan,
+     * subsequent detections do not get a scan callback. Stopping scanning and restarting clears
+     * this out, allowing subsequent detection of identical advertisements. On most newer device,
+     * this is not necessary, and multiple callbacks are given for identical packets detected in
+     * a single scan.
+     * <p>
+     * This is declared {@code volatile} because it may be set by a background scan thread while
+     * we are in a method on the main thread which will end up checking it. Using this modifier
+     * ensures that when we read the flag we'll always see the most recently written value. This is
+     * also true for background scan threads which may be running concurrently.
+     */
+    private volatile boolean mDistinctPacketsDetectedPerScan = false;
     private static final long ANDROID_N_MIN_SCAN_CYCLE_MILLIS = 6000l;
 
     protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
@@ -69,31 +119,49 @@ protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeri
     }
 
     public static CycledLeScanner createScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
-        boolean useAndroidLScanner;
+        boolean useAndroidLScanner = false;
+        boolean useAndroidOScanner = false;
         if (android.os.Build.VERSION.SDK_INT < 18) {
             LogManager.w(TAG, "Not supported prior to API 18.");
             return null;
         }
 
-        if (android.os.Build.VERSION.SDK_INT < 21) {
-            LogManager.i(TAG, "This is not Android 5.0.  We are using old scanning APIs");
+        if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            LogManager.i(TAG, "This is pre Android 5.0.  We are using old scanning APIs");
             useAndroidLScanner = false;
-        } else {
+
+        }
+        else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
             if (BeaconManager.isAndroidLScanningDisabled()) {
-                LogManager.i(TAG, "This Android 5.0, but L scanning is disabled. We are using old scanning APIs");
+                LogManager.i(TAG, "This is Android 5.0, but L scanning is disabled. We are using old scanning APIs");
                 useAndroidLScanner = false;
             } else {
-                LogManager.i(TAG, "This Android 5.0.  We are using new scanning APIs");
+                LogManager.i(TAG, "This is Android 5.0.  We are using new scanning APIs");
                 useAndroidLScanner = true;
             }
         }
+        else {
+            LogManager.i(TAG, "Using Android O scanner");
+            useAndroidOScanner = true;
+        }
 
-        if (useAndroidLScanner) {
+        if (useAndroidOScanner) {
+            return new CycledLeScannerForAndroidO(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
+        }
+        else if (useAndroidLScanner) {
             return new CycledLeScannerForLollipop(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         } else {
             return new CycledLeScannerForJellyBeanMr2(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         }
+    }
 
+    /**
+     * Enables the scanner to go to extra lengths to keep scans going for longer than would
+     * otherwise be allowed.  Useful only for Android N and higher.
+     * @param enabled
+     */
+    public void setLongScanForcingEnabled(boolean enabled) {
+        mLongScanForcingEnabled = enabled;
     }
 
     /**
@@ -102,6 +170,7 @@ public static CycledLeScanner createScanner(Context context, long scanPeriod, lo
      * between LOW_POWER_MODE vs. LOW_LATENCY_MODE
      * @param backgroundFlag
      */
+    @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
         LogManager.d(TAG, "Set scan periods called with %s, %s Background mode must have changed.",
                 scanPeriod, betweenScanPeriod);
@@ -142,6 +211,7 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
         }
     }
 
+    @MainThread
     public void start() {
         LogManager.d(TAG, "start called");
         mScanningEnabled = true;
@@ -152,21 +222,57 @@ public void start() {
         }
     }
 
-    @SuppressLint("NewApi")
+    @MainThread
     public void stop() {
         LogManager.d(TAG, "stop called");
         mScanningEnabled = false;
         if (mScanCyclerStarted) {
             scanLeDevice(false);
+            // If we have left scanning on between scan periods, now is the time to shut it off.
+            if (mScanningLeftOn) {
+                LogManager.d(TAG, "Stopping scanning previously left on.");
+                mScanningLeftOn = false;
+                try {
+                    LogManager.d(TAG, "stopping bluetooth le scan");
+                    finishScan();
+                } catch (Exception e) {
+                    LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
+                }
+            }
+        } else {
+            LogManager.d(TAG, "scanning already stopped");
         }
-        if (mBluetoothAdapter != null) {
-            stopScan();
-            mLastScanCycleEndTime = SystemClock.elapsedRealtime();
-        }
     }
 
+    @AnyThread
+    public boolean getDistinctPacketsDetectedPerScan() {
+        return mDistinctPacketsDetectedPerScan;
+    }
+
+    @AnyThread
+    public void setDistinctPacketsDetectedPerScan(boolean detected) {
+        mDistinctPacketsDetectedPerScan = detected;
+    }
+
+    @MainThread
     public void destroy() {
-        mScanThread.quit();
+        LogManager.d(TAG, "Destroying");
+
+        // Remove any postDelayed Runnables queued for the next scan cycle
+        mHandler.removeCallbacksAndMessages(null);
+
+        // We cannot quit the thread used by the handler until queued Runnables have been processed,
+        // because the handler is what stops scanning, and we do not want scanning left on.
+        // So we stop the thread using the handler, so we make sure it happens after all other
+        // waiting Runnables are finished.
+        mScanHandler.post(new Runnable() {
+            @WorkerThread
+            @Override
+            public void run() {
+                LogManager.d(TAG, "Quitting scan thread");
+                mScanThread.quit();
+            }
+        });
     }
 
     protected abstract void stopScan();
@@ -175,14 +281,14 @@ public void destroy() {
 
     protected abstract void startScan();
 
-    @SuppressLint("NewApi")
+    @MainThread
     protected void scanLeDevice(final Boolean enable) {
         try {
             mScanCyclerStarted = true;
             if (getBluetoothAdapter() == null) {
                 LogManager.e(TAG, "No Bluetooth adapter.  beaconService cannot scan.");
             }
-            if (enable) {
+            if (mScanningEnabled && enable) {
                 if (deferScanIfNeeded()) {
                     return;
                 }
@@ -205,6 +311,7 @@ protected void scanLeDevice(final Boolean enable) {
                                         }
                                         try {
                                             if (android.os.Build.VERSION.SDK_INT < 23 || checkLocationPermission()) {
+                                                mCurrentScanStartTime = SystemClock.elapsedRealtime();
                                                 startScan();
                                             }
                                         } catch (Exception e) {
@@ -223,7 +330,9 @@ protected void scanLeDevice(final Boolean enable) {
                         LogManager.e(e, TAG, "Exception starting Bluetooth scan.  Perhaps Bluetooth is disabled or unavailable?");
                     }
                 } else {
-                    LogManager.d(TAG, "We are already scanning");
+                    LogManager.d(TAG, "We are already scanning and have been for "+(
+                            SystemClock.elapsedRealtime() - mCurrentScanStartTime
+                            )+" millis");
                 }
                 mScanCycleStopTime = (SystemClock.elapsedRealtime() + mScanPeriod);
                 scheduleScanCycleStop();
@@ -234,7 +343,13 @@ protected void scanLeDevice(final Boolean enable) {
                 mScanning = false;
                 mScanCyclerStarted = false;
                 stopScan();
+                mCurrentScanStartTime = 0l;
                 mLastScanCycleEndTime = SystemClock.elapsedRealtime();
+                // Clear any queued schedule tasks as we're done scanning
+                // This must be mHandler not mScanHandler.  mHandler is what does the scanning work.
+                // If this is set to mScanHandler, then this can prevent a scan stop.
+                mHandler.removeCallbacksAndMessages(null);
+                finishScanCycle();
             }
         }
         catch (SecurityException e) {
@@ -242,16 +357,18 @@ protected void scanLeDevice(final Boolean enable) {
         }
     }
 
+    @MainThread
     protected void scheduleScanCycleStop() {
         // Stops scanning after a pre-defined scan period.
         long millisecondsUntilStop = mScanCycleStopTime - SystemClock.elapsedRealtime();
-        if (millisecondsUntilStop > 0) {
+        if (mScanningEnabled && millisecondsUntilStop > 0) {
             LogManager.d(TAG, "Waiting to stop scan cycle for another %s milliseconds",
                     millisecondsUntilStop);
             if (mBackgroundFlag) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scheduleScanCycleStop();
@@ -264,6 +381,7 @@ public void run() {
 
     protected abstract void finishScan();
 
+    @MainThread
     private void finishScanCycle() {
         LogManager.d(TAG, "Done with scan cycle");
         try {
@@ -271,31 +389,50 @@ private void finishScanCycle() {
             if (mScanning) {
                 if (getBluetoothAdapter() != null) {
                     if (getBluetoothAdapter().isEnabled()) {
-                        long now = System.currentTimeMillis();
-                        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
-                                mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
-                                now-mLastScanStopTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
-                            // As of Android N, only 5 scans may be started in a 30 second period (6
-                            // seconds per cycle)  otherwise they are blocked.  So we check here to see
-                            // if the scan period is 6 seconds or less, and if we last stopped scanning
-                            // fewer than 6 seconds ag and if so, we simply do not stop scanning
-                            LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
-                                    " keep scanning for a minimum of 6 seconds at a time. "+
-                                    "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanStopTime))+" millisconds.");
+                        // Determine if we need to restart scanning.  Restarting scanning is only
+                        // needed on devices incapable of detecting multiple distinct BLE advertising
+                        // packets in a single cycle, typically older Android devices (e.g. Nexus 4)
+                        // On such devices, it is necessary to stop scanning and restart to detect
+                        // multiple beacon packets in the same scan, allowing collection of multiple
+                        // rssi measurements.  Restarting however, causes brief detection dropouts
+                        // so it is best avoided.  If we know the device has detected to distinct
+                        // packets in the same cycle, we will not restart scanning and just keep it
+                        // going.
+                        if (!mDistinctPacketsDetectedPerScan ||
+                                mBetweenScanPeriod != 0 ||
+                                mustStopScanToPreventAndroidNScanTimeout()) {
+                            long now = SystemClock.elapsedRealtime();
+                            if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
+                                    mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
+                                    now-mLastScanCycleStartTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
+                                // As of Android N, only 5 scans may be started in a 30 second period (6
+                                // seconds per cycle)  otherwise they are blocked.  So we check here to see
+                                // if the scan period is 6 seconds or less, and if we last stopped scanning
+                                // fewer than 6 seconds ag and if so, we simply do not stop scanning
+                                LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
+                                        " keep scanning for a minimum of 6 seconds at a time. "+
+                                        "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanCycleStartTime))+" millisconds.");
+                                mScanningLeftOn = true;
+                            }
+                            else {
+                                try {
+                                    LogManager.d(TAG, "stopping bluetooth le scan");
+                                    finishScan();
+                                    mScanningLeftOn = false;
+                                } catch (Exception e) {
+                                    LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
+                                }
+                            }
                         }
                         else {
-                            try {
-                                LogManager.d(TAG, "stopping bluetooth le scan");
-                                finishScan();
-                                mLastScanStopTime = now;
-                            } catch (Exception e) {
-                                LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
-                            }
+                            LogManager.d(TAG, "Not stopping scanning.  Device capable of multiple indistinct detections per scan.");
+                            mScanningLeftOn = true;
                         }
 
                         mLastScanCycleEndTime = SystemClock.elapsedRealtime();
                     } else {
                         LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
+                        mRestartNeeded = true;
                     }
                 }
                 mNextScanCycleStartTime = getNextScanStartTime();
@@ -304,7 +441,7 @@ private void finishScanCycle() {
                 }
             }
             if (!mScanningEnabled) {
-                LogManager.d(TAG, "Scanning disabled.  No ranging or monitoring regions are active.");
+                LogManager.d(TAG, "Scanning disabled. ");
                 mScanCyclerStarted = false;
                 cancelWakeUpAlarm();
             }
@@ -401,4 +538,35 @@ private boolean checkLocationPermission() {
     private boolean checkPermission(final String permission) {
         return mContext.checkPermission(permission, android.os.Process.myPid(), android.os.Process.myUid()) == PackageManager.PERMISSION_GRANTED;
     }
+
+    /**
+     * On Android N and later, a scan that runs for more than 30 minutes will be automatically
+     * stopped by the OS and converted to an "opportunistic" scan, meaning that they will only yield
+     * detections if another app is scanning.  This is inteneded to save battery.  This can be
+     * prevented by stopping scanning and restarting.  This method returns true if:
+     *   * this is Android N or later
+     *   * we are close to the 30 minute boundary since the last scan started
+     *   * The app developer has explicitly enabled long-running scans
+     * @return true if we must stop scanning to prevent
+     */
+    private boolean mustStopScanToPreventAndroidNScanTimeout() {
+        long timeOfNextScanCycleEnd = SystemClock.elapsedRealtime() +  mBetweenScanPeriod +
+                mScanPeriod;
+        boolean timeoutAtRisk = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
+                mCurrentScanStartTime > 0 &&
+                (timeOfNextScanCycleEnd - mCurrentScanStartTime > ANDROID_N_MAX_SCAN_DURATION_MILLIS);
+
+        if (timeoutAtRisk) {
+            LogManager.d(TAG, "The next scan cycle would go over the Android N max duration.");
+            if  (mLongScanForcingEnabled) {
+                LogManager.d(TAG, "Stopping scan to prevent Android N scan timeout.");
+                return true;
+            }
+            else {
+                LogManager.w(TAG, "Allowing a long running scan to be stopped by the OS.  To " +
+                        "prevent this, set longScanForcingEnabled in the AndroidBeaconLibrary.");
+            }
+        }
+        return false;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
new file mode 100644
index 00000000..fe095400
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
@@ -0,0 +1,28 @@
+package org.altbeacon.beacon.service.scanner;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import org.altbeacon.bluetooth.BluetoothCrashResolver;
+import java.util.Set;
+
+/**
+ * The scanner used for Android O is effectively the same as used for JellyBeaconMr2.  There is no
+ * point in using the low power scanning APIs introduced in Lollipop, because they only work when
+ * the app is running, effectively requiring a long running service, something newly disallowed
+ * by Android O.  The new strategy for Android O is to use a JobScheduler combined with background
+ * scans delivered by Intents.
+ *
+ * @see org.altbeacon.beacon.service.ScanJob
+ * @see org.altbeacon.beacon.service.ScanHelper#startAndroidOBackgroundScan(Set)
+ *
+ * Created by dyoung on 5/28/17.
+ */
+
+@TargetApi(26)
+class CycledLeScannerForAndroidO extends CycledLeScannerForLollipop {
+    private static final String TAG = CycledLeScannerForAndroidO.class.getSimpleName();
+
+    CycledLeScannerForAndroidO(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
+        super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
index b38f7281..e9f51a74 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
@@ -5,6 +5,8 @@
 import android.bluetooth.BluetoothDevice;
 import android.content.Context;
 import android.os.SystemClock;
+import android.support.annotation.MainThread;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
@@ -36,6 +38,7 @@ protected boolean deferScanIfNeeded() {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scanLeDevice(true);
@@ -65,6 +68,7 @@ private void postStartLeScan() {
         final BluetoothAdapter.LeScanCallback leScanCallback = getLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -85,6 +89,7 @@ private void postStopLeScan() {
         final BluetoothAdapter.LeScanCallback leScanCallback = getLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -107,7 +112,9 @@ public void onLeScan(final BluetoothDevice device, final int rssi,
                                              final byte[] scanRecord) {
                             LogManager.d(TAG, "got record");
                             mCycledLeScanCallback.onLeScan(device, rssi, scanRecord);
-                            mBluetoothCrashResolver.notifyScannedDevice(device, getLeScanCallback());
+                            if (mBluetoothCrashResolver != null) {
+                                mBluetoothCrashResolver.notifyScannedDevice(device, getLeScanCallback());
+                            }
                         }
                     };
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index 82251314..d35031b2 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -10,6 +10,8 @@
 import android.content.Context;
 import android.os.ParcelUuid;
 import android.os.SystemClock;
+import android.support.annotation.MainThread;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
@@ -28,7 +30,6 @@
     private ScanCallback leScanCallback;
     private long mBackgroundLScanStartTime = 0l;
     private long mBackgroundLScanFirstDetectionTime = 0l;
-    private boolean mScanDeferredBefore = false;
     private boolean mMainScanCycleActive = false;
     private final BeaconManager mBeaconManager;
 
@@ -77,51 +78,60 @@ then no beacons will be detected until the next scan cycle starts (5 minutes max
     protected boolean deferScanIfNeeded() {
         // This method is called to see if it is time to start a scan
         long millisecondsUntilStart = mNextScanCycleStartTime - SystemClock.elapsedRealtime();
-        if (millisecondsUntilStart > 0) {
-            mMainScanCycleActive = false;
-            if (true) {
-                long secsSinceLastDetection = SystemClock.elapsedRealtime() -
-                        DetectionTracker.getInstance().getLastDetectionTime();
-                // If we have seen a device recently
-                // devices should behave like pre-Android L devices, because we don't want to drain battery
-                // by continuously delivering packets for beacons visible in the background
-                if (mScanDeferredBefore == false) {
-                    if (secsSinceLastDetection > BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
-                        mBackgroundLScanStartTime = SystemClock.elapsedRealtime();
-                        mBackgroundLScanFirstDetectionTime = 0l;
-                        LogManager.d(TAG, "This is Android L. Doing a filtered scan for the background.");
-
-                        // On Android L, between scan cycles do a scan with a filter looking for any beacon
-                        // if we see one of those beacons, we need to deliver the results
+        final boolean deferScan = millisecondsUntilStart > 0;
+        final boolean scanActiveBefore = mMainScanCycleActive;
+        mMainScanCycleActive = !deferScan;
+        if (deferScan) {
+            long secsSinceLastDetection = SystemClock.elapsedRealtime() -
+                    DetectionTracker.getInstance().getLastDetectionTime();
+            // If we have seen a device recently
+            // devices should behave like pre-Android L devices, because we don't want to drain battery
+            // by continuously delivering packets for beacons visible in the background
+            if (scanActiveBefore) {
+                if (secsSinceLastDetection > BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
+                    mBackgroundLScanStartTime = SystemClock.elapsedRealtime();
+                    mBackgroundLScanFirstDetectionTime = 0l;
+                    LogManager.d(TAG, "This is Android L. Preparing to do a filtered scan for the background.");
+                    // On Android L, between scan cycles do a scan with a filter looking for any beacon
+                    // if we see one of those beacons, we need to deliver the results
+                    // Only scan between cycles if the between can cycle time > 6 seconds.  A shorter low
+                    // power scan is unlikely to be useful, and might trigger a "scanning too frequently"
+                    // error on Android N.
+                    if (mBetweenScanPeriod > 6000l) {
                         startScan();
-                    } else {
-                        // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
-                        // This API is now available in Android M
-                        LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
-                                + "ago, so we will not keep scanning in background.",
-                                secsSinceLastDetection);
                     }
+                    else {
+                        LogManager.d(TAG, "Suppressing scan between cycles because the between scan cycle is too short.");
+                    }
+
+
+                } else {
+                    // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
+                    // This API is now available in Android M
+                    LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
+                            + "ago, so we will not keep scanning in background.",
+                            secsSinceLastDetection);
                 }
-                if (mBackgroundLScanStartTime > 0l) {
-                    // if we are in here, we have detected beacons recently in a background L scan
-                    if (DetectionTracker.getInstance().getLastDetectionTime() > mBackgroundLScanStartTime) {
-                        if (mBackgroundLScanFirstDetectionTime == 0l) {
-                            mBackgroundLScanFirstDetectionTime = DetectionTracker.getInstance().getLastDetectionTime();
-                        }
-                        if (SystemClock.elapsedRealtime() - mBackgroundLScanFirstDetectionTime
-                                >= BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
-                            // if we are in here, it has been more than 10 seconds since we detected
-                            // a beacon in background L scanning mode.  We need to stop scanning
-                            // so we do not drain battery
-                            LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
-                            stopScan();
-                            mBackgroundLScanStartTime = 0l;
-                        }
-                        else {
-                            // report the results up the chain
-                            LogManager.d(TAG, "Delivering Android L background scanning results");
-                            mCycledLeScanCallback.onCycleEnd();
-                        }
+            }
+            if (mBackgroundLScanStartTime > 0l) {
+                // if we are in here, we have detected beacons recently in a background L scan
+                if (DetectionTracker.getInstance().getLastDetectionTime() > mBackgroundLScanStartTime) {
+                    if (mBackgroundLScanFirstDetectionTime == 0l) {
+                        mBackgroundLScanFirstDetectionTime = DetectionTracker.getInstance().getLastDetectionTime();
+                    }
+                    if (SystemClock.elapsedRealtime() - mBackgroundLScanFirstDetectionTime
+                            >= BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
+                        // if we are in here, it has been more than 10 seconds since we detected
+                        // a beacon in background L scanning mode.  We need to stop scanning
+                        // so we do not drain battery
+                        LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
+                        stopScan();
+                        mBackgroundLScanStartTime = 0l;
+                    }
+                    else {
+                        // report the results up the chain
+                        LogManager.d(TAG, "Delivering Android L background scanning results");
+                        mCycledLeScanCallback.onCycleEnd();
                     }
                 }
             }
@@ -130,27 +140,23 @@ protected boolean deferScanIfNeeded() {
             // Don't actually wait until the next scan time -- only wait up to 1 second.  This
             // allows us to start scanning sooner if a consumer enters the foreground and expects
             // results more quickly.
-            if (mScanDeferredBefore == false && mBackgroundFlag) {
+            if (scanActiveBefore && mBackgroundFlag) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scanLeDevice(true);
                 }
             }, millisecondsUntilStart > 1000 ? 1000 : millisecondsUntilStart);
-            mScanDeferredBefore = true;
-            return true;
-        }
-        else {
+        } else {
             if (mBackgroundLScanStartTime > 0l) {
                 stopScan();
                 mBackgroundLScanStartTime = 0;
             }
-            mScanDeferredBefore = false;
-            mMainScanCycleActive = true;
         }
-        return false;
+        return deferScan;
     }
 
     @Override
@@ -160,19 +166,21 @@ protected void startScan() {
             return;
         }
         List<ScanFilter> filters = new ArrayList<ScanFilter>();
-        ScanSettings settings;
+        ScanSettings settings = null;
 
-        if (mBackgroundFlag && !mMainScanCycleActive) {
+        if (!mMainScanCycleActive) {
             LogManager.d(TAG, "starting filtered scan in SCAN_MODE_LOW_POWER");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
             filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
-                    mBeaconManager.getBeaconParsers());
+                          mBeaconManager.getBeaconParsers());
         } else {
             LogManager.d(TAG, "starting non-filtered scan in SCAN_MODE_LOW_LATENCY");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)).build();
         }
 
-        postStartLeScan(filters, settings);
+        if (settings != null) {
+            postStartLeScan(filters, settings);
+        }
     }
 
     @Override
@@ -190,6 +198,7 @@ private void postStartLeScan(final List<ScanFilter> filters, final ScanSettings
         final ScanCallback scanCallback = getNewLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -198,7 +207,7 @@ public void run() {
                     LogManager.w(TAG, "Cannot start scan. Bluetooth may be turned off.");
                 } catch (NullPointerException npe) {
                     // Necessary because of https://code.google.com/p/android/issues/detail?id=160503
-                    LogManager.e(TAG, "Cannot start scan. Unexpected NPE.", npe);
+                    LogManager.e(npe, TAG, "Cannot start scan. Unexpected NPE.");
                 } catch (SecurityException e) {
                     // Thrown by Samsung Knox devices if bluetooth access denied for an app
                     LogManager.e(TAG, "Cannot start scan.  Security Exception");
@@ -220,15 +229,17 @@ private void postStopLeScan() {
         final ScanCallback scanCallback = getNewLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
+                    LogManager.d(TAG, "Stopping LE scan on scan handler");
                     scanner.stopScan(scanCallback);
                 } catch (IllegalStateException e) {
                     LogManager.w(TAG, "Cannot stop scan. Bluetooth may be turned off.");
                 } catch (NullPointerException npe) {
                     // Necessary because of https://code.google.com/p/android/issues/detail?id=160503
-                    LogManager.e(TAG, "Cannot stop scan. Unexpected NPE.", npe);
+                    LogManager.e(npe, TAG, "Cannot stop scan. Unexpected NPE.");
                 } catch (SecurityException e) {
                     // Thrown by Samsung Knox devices if bluetooth access denied for an app
                     LogManager.e(TAG, "Cannot stop scan.  Security Exception");
@@ -274,7 +285,7 @@ private BluetoothLeScanner getScanner() {
     private ScanCallback getNewLeScanCallback() {
         if (leScanCallback == null) {
             leScanCallback = new ScanCallback() {
-
+                @MainThread
                 @Override
                 public void onScanResult(int callbackType, ScanResult scanResult) {
                     if (LogManager.isVerboseLoggingEnabled()) {
@@ -293,6 +304,7 @@ public void onScanResult(int callbackType, ScanResult scanResult) {
                     }
                 }
 
+                @MainThread
                 @Override
                 public void onBatchScanResults(List<ScanResult> results) {
                     LogManager.d(TAG, "got batch records");
@@ -305,9 +317,41 @@ public void onBatchScanResults(List<ScanResult> results) {
                     }
                 }
 
+                @MainThread
                 @Override
-                public void onScanFailed(int i) {
-                    LogManager.e(TAG, "Scan Failed");
+                public void onScanFailed(int errorCode) {
+                    switch (errorCode) {
+                        case SCAN_FAILED_ALREADY_STARTED:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed: a BLE scan with the same settings is already started by the app"
+                            );
+                            break;
+                        case SCAN_FAILED_APPLICATION_REGISTRATION_FAILED:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed: app cannot be registered"
+                            );
+                            break;
+                        case SCAN_FAILED_FEATURE_UNSUPPORTED:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed: power optimized scan feature is not supported"
+                            );
+                            break;
+                        case SCAN_FAILED_INTERNAL_ERROR:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed: internal error"
+                            );
+                            break;
+                        default:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed with unknown error (errorCode=" + errorCode + ")"
+                            );
+                            break;
+                    }
                 }
             };
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
new file mode 100644
index 00000000..daff6763
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
@@ -0,0 +1,46 @@
+package org.altbeacon.beacon.service.scanner;
+
+import android.support.annotation.NonNull;
+
+import java.nio.ByteBuffer;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Created by dyoung on 4/8/17.
+ * <p>
+ * This class tracks whether multiple distinct BLE packets have been seen, with the purpose of
+ * determining if the Android device supports detecting multiple distinct packets in a single scan.
+ * Some older devices are not capable of this (e.g. Nexus 4, Moto G1), so detecting multiple packets
+ * requires stopping and restarting scanning on these devices.  This allows detecting if that is
+ * necessary.
+ * <p>
+ * <strong>This class is not thread safe.</strong>
+ */
+public class DistinctPacketDetector {
+    // Sanity limit for the number of packets to track, so we don't use too much memory
+    private static final int MAX_PACKETS_TO_TRACK = 1000;
+
+    @NonNull
+    private final Set<ByteBuffer> mDistinctPacketsDetected = new HashSet<>();
+
+    public void clearDetections() {
+        mDistinctPacketsDetected.clear();
+    }
+
+    public boolean isPacketDistinct(@NonNull String originMacAddress, @NonNull byte[] scanRecord) {
+        byte[] macBytes = originMacAddress.getBytes();
+        ByteBuffer buffer = ByteBuffer.allocate(macBytes.length+scanRecord.length);
+        buffer.put(macBytes);
+        buffer.put(scanRecord);
+        buffer.rewind(); // rewind puts position back to beginning so .equals and .hashCode work
+
+        if (mDistinctPacketsDetected.size() == MAX_PACKETS_TO_TRACK) {
+            return mDistinctPacketsDetected.contains(buffer);
+        }
+        else {
+            return mDistinctPacketsDetected.add(buffer);
+        }
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java b/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
index f85139cb..15aeda1e 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
@@ -1,6 +1,7 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.bluetooth.BluetoothDevice;
+import android.support.annotation.WorkerThread;
 
 /**
  * Allows an implementation to see non-Beacon BLE devices as they are scanned.
@@ -23,6 +24,7 @@
  *  }
  * </code></pre>
  */
+@WorkerThread
 public interface NonBeaconLeScanCallback {
     /**
      * NOTE: This method is NOT called on the main UI thread.
diff --git a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
index 93eefda9..0a041fe0 100644
--- a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
+++ b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
@@ -1,14 +1,23 @@
 package org.altbeacon.beacon.startup;
 
-import android.annotation.TargetApi;
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanResult;
+import android.bluetooth.le.ScanSettings;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanJobScheduler;
+
+import java.util.ArrayList;
 
-@TargetApi(4)
 public class StartupBroadcastReceiver extends BroadcastReceiver
 {
     private static final String TAG = "StartupBroadcastReceiver";
@@ -21,8 +30,19 @@ public void onReceive(Context context, Intent intent) {
             return;
         }
         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context.getApplicationContext());
-        if (beaconManager.isAnyConsumerBound()) {
-            if (intent.getBooleanExtra("wakeup", false)) {
+        if (beaconManager.isAnyConsumerBound() || beaconManager.getScheduledScanJobsEnabled()) {
+            int bleCallbackType = intent.getIntExtra(BluetoothLeScanner.EXTRA_CALLBACK_TYPE, -1); // e.g. ScanSettings.CALLBACK_TYPE_FIRST_MATCH
+            if (bleCallbackType != -1) {
+                LogManager.d(TAG, "Passive background scan callback type: "+bleCallbackType);
+                LogManager.d(TAG, "got Android O background scan via intent");
+                int errorCode = intent.getIntExtra(BluetoothLeScanner.EXTRA_ERROR_CODE, -1); // e.g.  ScanCallback.SCAN_FAILED_INTERNAL_ERROR
+                if (errorCode != -1) {
+                    LogManager.w(TAG, "Passive background scan failed.  Code; "+errorCode);
+                }
+                ArrayList<ScanResult> scanResults = intent.getParcelableArrayListExtra(BluetoothLeScanner.EXTRA_LIST_SCAN_RESULT);
+                ScanJobScheduler.getInstance().scheduleAfterBackgroundWakeup(context, scanResults);
+            }
+            else if (intent.getBooleanExtra("wakeup", false)) {
                 LogManager.d(TAG, "got wake up intent");
             }
             else {
@@ -30,5 +50,8 @@ public void onReceive(Context context, Intent intent) {
                         intent.getStringExtra("wakeup"));
             }
         }
+        else {
+            LogManager.d(TAG, "No consumers are bound.  Ignoring broadcast receiver.");
+        }
      }
 }
diff --git a/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
new file mode 100644
index 00000000..f0ffb0d7
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
@@ -0,0 +1,42 @@
+package org.altbeacon.beacon.utils;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+/**
+ * Created by dyoung on 3/10/17.
+ *
+ * Internal class used to determine current process state in multi-process setups
+ * @hide
+ */
+
+public class ProcessUtils {
+    Context mContext;
+
+    public ProcessUtils(@NonNull Context context) {
+        mContext = context;
+    }
+
+    public String getProcessName() {
+        ActivityManager manager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        for (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) {
+            if (processInfo.pid == getPid()) {
+                return  processInfo.processName;
+            }
+        }
+        return null;
+    }
+
+    public String getPackageName() {
+        return mContext.getApplicationContext().getPackageName();
+    }
+
+    public int getPid() {
+        return android.os.Process.myPid();
+    }
+
+    public boolean isMainProcess() {
+        return (getPackageName().equals(getProcessName()));
+    }
+}
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
index a1542932..195a770a 100644
--- a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
@@ -39,7 +39,6 @@
  *
  * Created by dyoung on 3/24/14.
  */
-@TargetApi(5)
 public class BluetoothCrashResolver {
     private static final String TAG = "BluetoothCrashResolver";
     private static final boolean PREEMPTIVE_ACTION_ENABLED = true;
diff --git a/src/test/java/org/altbeacon/beacon/BeaconTest.java b/src/test/java/org/altbeacon/beacon/BeaconTest.java
index e31e6f54..d95fb0e7 100644
--- a/src/test/java/org/altbeacon/beacon/BeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/BeaconTest.java
@@ -1,7 +1,5 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.junit.Before;
 import org.junit.Test;
@@ -16,6 +14,12 @@
 import java.util.Arrays;
 import java.util.List;
 
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -160,15 +164,13 @@ public void testCalculateAccuracyWithRssiEqualsPowerOnInternalPropertiesAndRunni
 
 
     @Test
-    public void testCanSerializeParcelable() {
+    public void testCanSerialize() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
                 .setBeaconTypeCode(5).setTxPower(6).setBluetoothName("xx")
                 .setBluetoothAddress("1:2:3:4:5:6").setDataFields(Arrays.asList(100l)).build();
-        beacon.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Beacon beacon2 = new Beacon(parcel);
+        byte[] serializedBeacon = convertToBytes(beacon);
+        Beacon beacon2 = (Beacon) convertFromBytes(serializedBeacon);
         assertEquals("Right number of identifiers after deserialization", 3, beacon2.mIdentifiers.size());
         assertEquals("id1 is same after deserialization", beacon.getIdentifier(0), beacon2.getIdentifier(0));
         assertEquals("id2 is same after deserialization", beacon.getIdentifier(1), beacon2.getIdentifier(1));
@@ -204,4 +206,20 @@ public void testHashCodeWithNullIdentifier() {
                 .build();
         assertTrue("hashCode() should not throw exception", beacon.hashCode() >= Integer.MIN_VALUE);
     }
+    // utilty methods for testing serialization
+
+    private byte[] convertToBytes(Object object) throws IOException {
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(object);
+            return bos.toByteArray();
+        }
+    }
+    private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+             ObjectInputStream in = new ObjectInputStream(bis)) {
+            return in.readObject();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/org/altbeacon/beacon/RegionTest.java b/src/test/java/org/altbeacon/beacon/RegionTest.java
index 4d003273..05ba5952 100644
--- a/src/test/java/org/altbeacon/beacon/RegionTest.java
+++ b/src/test/java/org/altbeacon/beacon/RegionTest.java
@@ -1,7 +1,5 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
 import static android.test.MoreAsserts.assertNotEqual;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -17,6 +15,12 @@
 import java.util.ArrayList;
 import java.util.Collections;
 
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -128,13 +132,11 @@ public void testBeaconMatchesRegionWithSameBluetoothMacAndIdentifiers() {
 
 
     @Test
-    public void testCanSerializeParcelable() {
+    public void testCanSerialize() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Region region = new Region("myRegion", Identifier.parse("1"), Identifier.parse("2"), null);
-        region.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Region region2 = new Region(parcel);
+        byte[] serializedRegion = convertToBytes(region);
+        Region region2 = (Region) convertFromBytes(serializedRegion);
         assertEquals("Right number of identifiers after deserialization", 3, region2.mIdentifiers.size());
         assertEquals("uniqueId is same after deserialization", region.getUniqueId(), region2.getUniqueId());
         assertEquals("id1 is same after deserialization", region.getIdentifier(0), region2.getIdentifier(0));
@@ -144,13 +146,11 @@ public void testCanSerializeParcelable() {
     }
 
     @Test
-    public void testCanSerializeParcelableWithMac() {
+    public void testCanSerializeWithMac() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Region region = new Region("myRegion", "1B:2a:03:4C:6E:9F");
-        region.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Region region2 = new Region(parcel);
+        byte[] serializedRegion = convertToBytes(region);
+        Region region2 = (Region) convertFromBytes(serializedRegion);
         assertEquals("Right number of identifiers after deserialization", 0, region2.mIdentifiers.size());
         assertEquals("ac is same after deserialization", region.getBluetoothAddress(), region2.getBluetoothAddress());
     }
@@ -158,7 +158,6 @@ public void testCanSerializeParcelableWithMac() {
     @Test
     public void rejectsInvalidMac() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         try {
             Region region = new Region("myRegion", "this string is not a valid mac address!");
             assertTrue("IllegalArgumentException should have been thrown", false);
@@ -185,5 +184,21 @@ public void testConvenienceIdentifierAccessors() {
         assertEquals("3", region.getId3().toString());
     }
 
+    // utilty methods for testing serialization
+
+    private byte[] convertToBytes(Object object) throws IOException {
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(object);
+            return bos.toByteArray();
+        }
+    }
+    private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+             ObjectInputStream in = new ObjectInputStream(bis)) {
+            return in.readObject();
+        }
+    }
+
 
 }
diff --git a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
index 37be84e9..d77e7eab 100644
--- a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
@@ -48,7 +48,7 @@ public void beaconScanCallbackTest() throws Exception {
         beaconServiceServiceController.attach();
         BeaconService beaconService = beaconServiceServiceController.get();
         beaconService.onCreate();
-        CycledLeScanCallback callback = beaconService.mCycledLeScanCallback;
+        CycledLeScanCallback callback = beaconService.getCycledLeScanCallback();
 
         ThreadPoolExecutor executor = (ThreadPoolExecutor) AsyncTask.THREAD_POOL_EXECUTOR;
         int activeThreadCountBeforeScan = executor.getActiveCount();
diff --git a/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java b/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
index ec8fef85..0ec70470 100644
--- a/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.os.AsyncTask;
 import android.os.Build;
+import android.util.Log;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Region;
@@ -30,6 +31,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(sdk = 18)
 public class MonitoringStatusTest {
+    private static final String TAG = MonitoringStatusTest.class.getSimpleName();
     @Before
     public void before() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
diff --git a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
new file mode 100644
index 00000000..403cd955
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
@@ -0,0 +1,80 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.Identifier;
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.logging.Loggers;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+
+import java.util.ArrayList;
+
+import android.os.Bundle;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class RangingDataTest {
+    @Before
+    public void before() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        LogManager.setLogger(Loggers.verboseLogger());
+        LogManager.setVerboseLoggingEnabled(true);
+        BeaconManager.setsManifestCheckingDisabled(true);
+    }
+
+    @Test
+    public void testSerialization() throws Exception {
+        Context context = ShadowApplication.getInstance().getApplicationContext();
+        ArrayList<Identifier> identifiers = new ArrayList<Identifier>();
+        identifiers.add(Identifier.parse("2f234454-cf6d-4a0f-adf2-f4911ba9ffa6"));
+        identifiers.add(Identifier.parse("1"));
+        identifiers.add(Identifier.parse("2"));
+        Region region = new Region("testRegion", identifiers);
+        ArrayList<Beacon> beacons = new ArrayList<Beacon>();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        for (int i=0; i < 10; i++) {
+            beacons.add(beacon);
+        }
+        RangingData data = new RangingData(beacons, region);
+        Bundle bundle = data.toBundle();
+        RangingData data2 = RangingData.fromBundle(bundle);
+        assertEquals("beacon count shouild be restored", 10, data2.getBeacons().size());
+        assertEquals("beacon identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getBeacons().iterator().next().getId1().toString());
+        assertEquals("region identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getRegion().getId1().toString());
+    }
+
+    @Test
+    // On MacBookPro 2.5 GHz Core I7, 10000 serialization/deserialiation cycles of RangingData took 22ms
+    public void testSerializationBenchmark() throws Exception {
+        Context context = ShadowApplication.getInstance().getApplicationContext();
+        ArrayList<Identifier> identifiers = new ArrayList<Identifier>();
+        identifiers.add(Identifier.parse("2f234454-cf6d-4a0f-adf2-f4911ba9ffa6"));
+        identifiers.add(Identifier.parse("1"));
+        identifiers.add(Identifier.parse("2"));
+        Region region = new Region("testRegion", identifiers);
+        ArrayList<Beacon> beacons = new ArrayList<Beacon>();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        for (int i=0; i < 10; i++) {
+            beacons.add(beacon);
+        }
+        RangingData data = new RangingData(beacons, region);
+        long time1 = System.currentTimeMillis();
+        for (int i=0; i< 10000; i++) {
+            Bundle bundle = data.toBundle();
+            RangingData data2 = RangingData.fromBundle(bundle);
+        }
+        long time2 = System.currentTimeMillis();
+        System.out.println("*** Ranging Data Serialization benchmark: "+(time2-time1));
+    }
+
+}
diff --git a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
index 562de095..e79c8ee9 100644
--- a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
@@ -1,5 +1,6 @@
 package org.altbeacon.beacon.service;
 
+import org.altbeacon.beacon.Beacon;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -17,4 +18,24 @@ public void initTest1() {
         filter.addMeasurement(-50);
         assertEquals("First measurement should be -50", String.valueOf(filter.calculateRssi()), "-50.0");
     }
+    @Test
+    public void rangedBeaconDoesNotOverrideSampleExpirationMillisecondsText() {
+        RangedBeacon.setSampleExpirationMilliseconds(20000);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(20000);
+        Beacon beacon = new Beacon.Builder().setId1("1").build();
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(33l);
+        RangedBeacon rb = new RangedBeacon(beacon);
+        assertEquals("RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by constructing RangedBeacon", 33l, RunningAverageRssiFilter.getSampleExpirationMilliseconds());
+    }
+
+    @Test
+    public void legacySetSampleExpirationMillisecondsWorksText() {
+        RangedBeacon.setSampleExpirationMilliseconds(20000);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(20000);
+        Beacon beacon = new Beacon.Builder().setId1("1").build();
+        RangedBeacon.setSampleExpirationMilliseconds(33l);
+        RangedBeacon rb = new RangedBeacon(beacon);
+        assertEquals("RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by constructing RangedBeacon", 33l, RunningAverageRssiFilter.getSampleExpirationMilliseconds());
+    }
+
 }
diff --git a/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java b/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
new file mode 100644
index 00000000..ba4b95c0
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
@@ -0,0 +1,57 @@
+package org.altbeacon.beacon.service;
+
+/**
+ * Created by dyoung on 7/30/17.
+ */
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.AsyncTask;
+import android.os.Build;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.logging.Loggers;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+import org.robolectric.util.ServiceController;
+
+import java.util.concurrent.ThreadPoolExecutor;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Created by dyoung on 7/1/15.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class ScanStateTest {
+
+    @Before
+    public void before() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        LogManager.setLogger(Loggers.verboseLogger());
+        LogManager.setVerboseLoggingEnabled(true);
+        BeaconManager.setsManifestCheckingDisabled(true);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void serializationTest() throws Exception {
+        Context context = ShadowApplication.getInstance().getApplicationContext();
+        ScanState scanState = new ScanState(context);
+        MonitoringStatus monitoringStatus = new MonitoringStatus(context);
+        scanState.setMonitoringStatus(monitoringStatus);
+        scanState.setLastScanStartTimeMillis(1234);
+        scanState.save();
+        ScanState scanState2 = ScanState.restore(context);
+        assertEquals("Scan start time should be restored",
+                scanState.getLastScanStartTimeMillis(), scanState2.getLastScanStartTimeMillis());
+    }
+}
\ No newline at end of file
diff --git a/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java b/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
new file mode 100644
index 00000000..f82e152c
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
@@ -0,0 +1,57 @@
+package org.altbeacon.beacon.service.scanner;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@Config(sdk = 18)
+
+@RunWith(RobolectricTestRunner.class)
+public class DistinctPacketDetectorTest {
+    @BeforeClass
+    public static void testSetup() {
+    }
+
+    @AfterClass
+    public static void testCleanup() {
+
+    }
+
+    @Test
+    public void testSecondDuplicatePacketIsNotDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        assertFalse("second call with same packet should not be distinct", secondResult);
+    }
+
+    @Test
+    public void testSecondNonDuplicatePacketIsDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x03, 0x04});
+        assertTrue("second call with different packet should be distinct", secondResult);
+    }
+
+    @Test
+    public void testSamePacketForDifferentMacIsDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:01:01:01:01:01", new byte[] {0x01, 0x02});
+        assertTrue("second packet with different mac should be distinct", secondResult);
+    }
+
+    @Test
+    public void clearingDetectionsPreventsDistinctDetection() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        dpd.clearDetections();
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        assertTrue("second call with same packet after clear should be distinct", secondResult);
+    }
+
+}
\ No newline at end of file
