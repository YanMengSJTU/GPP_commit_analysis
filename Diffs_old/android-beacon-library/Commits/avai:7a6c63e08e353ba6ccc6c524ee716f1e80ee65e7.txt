diff --git a/README.md b/README.md
index b5d29ed7..6f288a95 100644
--- a/README.md
+++ b/README.md
@@ -100,20 +100,11 @@ The following instructions are for project administrators.
     bintrayUserName=<bintray username>
     bintrayKey=<bintray api key>
 
-1. Run the build and upload
+3. Run the build and upload
 
    git tag <version>
    git push --tags 
    ./gradlew release -Prelease
    ./gradlew bintrayUpload -Prelease
-   ./gradlew bintrayPublishContent -Prelease
-   ./gradlew bintraySign -Prelease
-   ./gradlew bintrayPublishContent -Prelease
-   ./gradlew bintrayToMavenCentral -Prelease
 
-   -or-
-
-   git tag <version>
-   git push --tags
-   ./gradlew release -Prelease
-   ./gradlew bintrayRelease -Prelease
+4. Log in to JCenter, hit the button to publish the release, then select the Maven tab and enter your credentials to Sync to Maven
diff --git a/build.gradle b/build.gradle
index f0a29c56..f117ff4d 100644
--- a/build.gradle
+++ b/build.gradle
@@ -121,6 +121,8 @@ dependencies {
     }
 
     androidTestCompile 'com.android.support:support-v4:21.0.2'
+
+    androidTestCompile 'org.mockito:mockito-core:1.10.19'
 }
 
 apply plugin: 'idea'
@@ -158,9 +160,8 @@ android.libraryVariants.all { variant ->
         source = variant.javaCompile.source
         ext.androidJar =
                 "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
-        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
-        options.links("http://docs.oracle.com/javase/7/docs/api/");
-        options.links("http://d.android.com/reference/");
+        classpath = files(variant.javaCompile.classpath.files, ext.androidJar)
+        options.linksOffline "http://d.android.com/reference/", "${android.sdkDirectory}/docs/reference"
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
     }
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index 89c284c3..fdb76aaa 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -25,11 +25,11 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.util.Log;
 
 import org.altbeacon.beacon.client.BeaconDataFactory;
 import org.altbeacon.beacon.client.NullBeaconDataFactory;
 import org.altbeacon.beacon.distance.DistanceCalculator;
+import org.altbeacon.beacon.logging.LogManager;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -113,9 +113,20 @@
      * A two byte code indicating the beacon manufacturer.  A list of registered manufacturer codes
      * may be found here:
      * https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers
+     *
+     * If the beacon is a GATT-based beacon, this field will be set to -1
      */
     protected int mManufacturer;
 
+    /**
+     * A 32 bit service uuid for the beacon
+     *
+     * This is valid only for GATT-based beacons.   If the beacon is a manufacturer data-based
+     * beacon, this field will be -1
+     */
+
+    protected int mServiceUuid;
+
     /**
      * The bluetooth device name.  This is a field transmitted by the remote beacon device separate
      * from the advertisement data
@@ -168,6 +179,7 @@ protected Beacon(Parcel in) {
         mTxPower = in.readInt();
         mBluetoothAddress = in.readString();
         mBeaconTypeCode = in.readInt();
+        mServiceUuid = in.readInt();
         int dataSize = in.readInt();
         this.mDataFields = new ArrayList<Long>(dataSize);
         for (int i = 0; i < dataSize; i++) {
@@ -186,7 +198,7 @@ protected Beacon(Beacon otherBeacon) {
         mIdentifiers = new ArrayList<Identifier>(otherBeacon.mIdentifiers.size());
         mDataFields = new ArrayList<Long>(otherBeacon.mDataFields.size());
         for (int i = 0; i < otherBeacon.mIdentifiers.size(); i++) {
-            mIdentifiers.add(new Identifier(otherBeacon.mIdentifiers.get(i)));
+            mIdentifiers.add(otherBeacon.mIdentifiers.get(i));
         }
         this.mDistance = otherBeacon.mDistance;
         this.mRunningAverageRssi = otherBeacon.mRunningAverageRssi;
@@ -194,6 +206,7 @@ protected Beacon(Beacon otherBeacon) {
         this.mTxPower = otherBeacon.mTxPower;
         this.mBluetoothAddress = otherBeacon.mBluetoothAddress;
         this.mBeaconTypeCode = otherBeacon.getBeaconTypeCode();
+        this.mServiceUuid = otherBeacon.getServiceUuid();
         this.mBluetoothName = otherBeacon.mBluetoothName;
     }
 
@@ -230,6 +243,13 @@ public int getManufacturer() {
         return mManufacturer;
     }
 
+    /**
+     * @see #mServiceUuid
+     */
+    public int getServiceUuid() {
+        return mServiceUuid;
+    }
+
     /**
      * Returns the specified identifier - 0 indexed
      * Note:  to read id1, call getIdentifier(0);
@@ -296,7 +316,7 @@ public double getDistance() {
                 bestRssiAvailable = mRunningAverageRssi;
             }
             else {
-                BeaconManager.logDebug(TAG, "Not using running average RSSI because it is null");
+                LogManager.d(TAG, "Not using running average RSSI because it is null");
             }
             mDistance = calculateDistance(mTxPower, bestRssiAvailable);
 		}
@@ -422,7 +442,7 @@ public int describeContents() {
      */
     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mIdentifiers.size());
-        BeaconManager.logDebug(TAG, "serializing identifiers of size "+mIdentifiers.size());
+        LogManager.d(TAG, "serializing identifiers of size %s", mIdentifiers.size());
         for (Identifier identifier: mIdentifiers) {
             out.writeString(identifier == null ? null : identifier.toString());
         }
@@ -431,6 +451,7 @@ public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mTxPower);
         out.writeString(mBluetoothAddress);
         out.writeInt(mBeaconTypeCode);
+        out.writeInt(mServiceUuid);
         out.writeInt(mDataFields.size());
         for (Long dataField: mDataFields) {
             out.writeLong(dataField);
@@ -454,7 +475,7 @@ protected static Double calculateDistance(int txPower, double bestRssiAvailable)
             return Beacon.getDistanceCalculator().calculateDistance(txPower, bestRssiAvailable);
         }
         else {
-            Log.e(TAG, "Distance calculator not set.  Distance will bet set to -1");
+            LogManager.e(TAG, "Distance calculator not set.  Distance will bet set to -1");
             return -1.0;
         }
     }
@@ -577,6 +598,16 @@ public Builder setBeaconTypeCode(int beaconTypeCode) {
             return this;
         }
 
+        /**
+         * @see Beacon#mServiceUuid
+         * @param serviceUuid
+         * @return builder
+         */
+        public Builder setServiceUuid(int serviceUuid) {
+            mBeacon.mServiceUuid = serviceUuid;
+            return this;
+        }
+
         /**
          * @see Beacon#mBluetoothAddress
          * @param bluetoothAddress
@@ -618,7 +649,4 @@ public Builder setBluetoothName(String name) {
         }
 
     }
-
-
-
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index f375e2c9..bb2e30ec 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -23,13 +23,13 @@
  */
 package org.altbeacon.beacon;
 
+import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.MonitoringData;
 import org.altbeacon.beacon.service.RangingData;
 
 import android.annotation.TargetApi;
 import android.app.IntentService;
 import android.content.Intent;
-import android.util.Log;
 
 /**
  * Converts internal intents to notifier callbacks
@@ -37,7 +37,6 @@
 @TargetApi(3)
 public class BeaconIntentProcessor extends IntentService {
 	private static final String TAG = "BeaconIntentProcessor";
-	private boolean initialized = false;
 
 	public BeaconIntentProcessor() {
 		super("BeaconIntentProcessor");
@@ -45,7 +44,7 @@ public BeaconIntentProcessor() {
 
 	@Override
 	protected void onHandleIntent(Intent intent) {
-		BeaconManager.logDebug(TAG, "got an intent to process");
+		LogManager.d(TAG, "got an intent to process");
 		
 		MonitoringData monitoringData = null;
 		RangingData rangingData = null;
@@ -56,9 +55,9 @@ protected void onHandleIntent(Intent intent) {
 		}
 		
 		if (rangingData != null) {
-			BeaconManager.logDebug(TAG, "got ranging data");
+            LogManager.d(TAG, "got ranging data");
             if (rangingData.getBeacons() == null) {
-                Log.w(TAG, "Ranging data has a null beacons collection");
+                LogManager.w(TAG, "Ranging data has a null beacons collection");
             }
 			RangeNotifier notifier = BeaconManager.getInstanceForApplication(this).getRangingNotifier();
             java.util.Collection<Beacon> beacons = rangingData.getBeacons();
@@ -66,7 +65,7 @@ protected void onHandleIntent(Intent intent) {
 				notifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
 			}
             else {
-                BeaconManager.logDebug(TAG, "but ranging notifier is null, so we're dropping it.");
+                LogManager.d(TAG, "but ranging notifier is null, so we're dropping it.");
             }
             RangeNotifier dataNotifier = BeaconManager.getInstanceForApplication(this).getDataRequestNotifier();
             if (dataNotifier != null) {
@@ -75,10 +74,10 @@ protected void onHandleIntent(Intent intent) {
 
 		}
 		if (monitoringData != null) {
-			BeaconManager.logDebug(TAG, "got monitoring data");
+            LogManager.d(TAG, "got monitoring data");
 			MonitorNotifier notifier = BeaconManager.getInstanceForApplication(this).getMonitoringNotifier();
 			if (notifier != null) {
-				BeaconManager.logDebug(TAG, "Calling monitoring notifier:"+notifier);
+                LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
 				notifier.didDetermineStateForRegion(monitoringData.isInside() ? MonitorNotifier.INSIDE : MonitorNotifier.OUTSIDE, monitoringData.getRegion());
 				if (monitoringData.isInside()) {
 					notifier.didEnterRegion(monitoringData.getRegion());
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 943dd65a..92b78649 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -1,9 +1,9 @@
 /**
  * Radius Networks, Inc.
  * http://www.radiusnetworks.com
- * 
+ *
  * @author David G. Young
- * 
+ *
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- * 
+ *
  *   http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -23,18 +23,6 @@
  */
 package org.altbeacon.beacon;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.altbeacon.beacon.service.BeaconService;
-import org.altbeacon.beacon.simulator.BeaconSimulator;
-import org.altbeacon.beacon.service.StartRMData;
-
 import android.annotation.TargetApi;
 import android.bluetooth.BluetoothManager;
 import android.content.ComponentName;
@@ -46,81 +34,108 @@
 import android.os.Message;
 import android.os.Messenger;
 import android.os.RemoteException;
-import android.util.Log;
+
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.logging.Loggers;
+import org.altbeacon.beacon.service.BeaconService;
+import org.altbeacon.beacon.service.RangeState;
+import org.altbeacon.beacon.service.RangedBeacon;
+import org.altbeacon.beacon.service.RunningAverageRssiFilter;
+import org.altbeacon.beacon.service.StartRMData;
+import org.altbeacon.beacon.simulator.BeaconSimulator;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 /**
  * An class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
  * when the <code>BeaconService</code> is ready to use.  Until this callback is made, ranging and monitoring
  * of beacons is not possible.
- * 
+ *
  * In the example below, an Activity implements the <code>BeaconConsumer</code> interface, binds
  * to the service, then when it gets the callback saying the service is ready, it starts ranging.
- * 
- *  <pre><code>
+ *
+ * <pre><code>
  *  public class RangingActivity extends Activity implements BeaconConsumer {
  *  	protected static final String TAG = "RangingActivity";
  *  	private BeaconManager beaconManager = BeaconManager.getInstanceForApplication(this);
- *  	 {@literal @}Override
+ *     {@literal @}Override
  *  	protected void onCreate(Bundle savedInstanceState) {
  *  		super.onCreate(savedInstanceState);
  *  		setContentView(R.layout.activity_ranging);
  *  		beaconManager.bind(this);
- *  	}
- *  	 {@literal @}Override 
+ *    }
+ *     {@literal @}Override
  *  	protected void onDestroy() {
  *  		super.onDestroy();
  *  		beaconManager.unbind(this);
- *  	}
- *  	 {@literal @}Override
+ *    }
+ *     {@literal @}Override
  *  	public void onBeaconServiceConnect() {
  *  		beaconManager.setRangeNotifier(new RangeNotifier() {
- *        	 {@literal @}Override 
+ *             {@literal @}Override
  *        	public void didRangeBeaconsInRegion(Collection<Beacon> beacons, Region region) {
  *     			if (beacons.size() > 0) {
- *	      			Log.i(TAG, "The first beacon I see is about "+beacons.iterator().next().getDistance()+" meters away.");		
- *     			}
- *        	}
- *  		});
- *  		
+ * 	      			Log.i(TAG, "The first beacon I see is about "+beacons.iterator().next().getDistance()+" meters away.");
+ *                }
+ *            }
+ *        });
+ *
  *  		try {
  *  			beaconManager.startRangingBeaconsInRegion(new Region("myRangingUniqueId", null, null, null));
- *  		} catch (RemoteException e) {	}
- *  	}
+ *        } catch (RemoteException e) {    }
+ *    }
  *  }
  *  </code></pre>
- * 
- * @author David G. Young
  *
+ * @author David G. Young
+ * @author Andrew Reitz <andrew@andrewreitz.com>
  */
 @TargetApi(4)
 public class BeaconManager {
 	private static final String TAG = "BeaconManager";
 	private Context mContext;
 	protected static BeaconManager client = null;
-	private Map<BeaconConsumer,ConsumerInfo> consumers = new HashMap<BeaconConsumer,ConsumerInfo>();
+	private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<BeaconConsumer,ConsumerInfo>();
 	private Messenger serviceMessenger = null;
 	protected RangeNotifier rangeNotifier = null;
     protected RangeNotifier dataRequestNotifier = null;
     protected MonitorNotifier monitorNotifier = null;
-    private ArrayList<Region> monitoredRegions = new ArrayList<Region>();
-    private ArrayList<Region> rangedRegions = new ArrayList<Region>();
-    private ArrayList<BeaconParser> beaconParsers = new ArrayList<BeaconParser>();
+    private final ArrayList<Region> monitoredRegions = new ArrayList<Region>();
+    private final ArrayList<Region> rangedRegions = new ArrayList<Region>();
+    private final ArrayList<BeaconParser> beaconParsers = new ArrayList<BeaconParser>();
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
 
-    /**
-     * set to true if you want to see debug messages associated with this library
-     */
-    public static boolean debug = false;
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
 
     /**
-     * Set to true if you want to show library debugging
+     * Set to true if you want to show library debugging.
+     *
+     * @param debug True turn on all logs for this library to be printed out to logcat. False turns
+     *              off all logging.
+     * @deprecated To be removed in a future release. Use
+     * {@link org.altbeacon.beacon.logging.LogManager#setLogger(org.altbeacon.beacon.logging.Logger)}
+     * instead.
      */
+    @Deprecated
     public static void setDebug(boolean debug) {
-        BeaconManager.debug = debug;
+        if (debug) {
+            LogManager.setLogger(Loggers.verboseLogger());
+            LogManager.setVerboseLoggingEnabled(true);
+        } else {
+            LogManager.setLogger(Loggers.empty());
+            LogManager.setVerboseLoggingEnabled(false);
+        }
     }
 
     /**
@@ -138,7 +153,7 @@ public static void setDebug(boolean debug) {
     /**
      * The default duration in milliseconds spent not scanning between each bluetooth scan cycle when no ranging/monitoring clients are in the foreground
      */
-    public static final long DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD = 5*60*1000;
+    public static final long DEFAULT_BACKGROUND_BETWEEN_SCAN_PERIOD = 5 * 60 * 1000;
 
     private long foregroundScanPeriod = DEFAULT_FOREGROUND_SCAN_PERIOD;
     private long foregroundBetweenScanPeriod = DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD;
@@ -150,15 +165,19 @@ public static void setDebug(boolean debug) {
      * This function is used to setup the period before calling {@link #bind}  or when switching
      * between background/foreground. To have it effect on an already running scan (when the next
      * cycle starts), call {@link #updateScanPeriods}
+     *
      * @param p
      */
-    public void setForegroundScanPeriod(long p) { foregroundScanPeriod = p; }
+    public void setForegroundScanPeriod(long p) {
+        foregroundScanPeriod = p;
+    }
 
     /**
      * Sets the duration in milliseconds between each Bluetooth LE scan cycle to look for beacons.
      * This function is used to setup the period before calling {@link #bind}  or when switching
      * between background/foreground. To have it effect on an already running scan (when the next
      * cycle starts), call {@link #updateScanPeriods}
+     *
      * @param p
      */
     public void setForegroundBetweenScanPeriod(long p) {
@@ -170,13 +189,16 @@ public void setForegroundBetweenScanPeriod(long p) {
      * This function is used to setup the period before calling {@link #bind}  or when switching
      * between background/foreground. To have it effect on an already running scan (when the next
      * cycle starts), call {@link #updateScanPeriods}
+     *
      * @param p
      */
     public void setBackgroundScanPeriod(long p) {
         backgroundScanPeriod = p;
     }
+
     /**
      * Sets the duration in milliseconds spent not scanning between each Bluetooth LE scan cycle when no ranging/monitoring clients are in the foreground
+     *
      * @param p
      */
     public void setBackgroundBetweenScanPeriod(long p) {
@@ -189,7 +211,7 @@ public void setBackgroundBetweenScanPeriod(long p) {
 	 */
 	public static BeaconManager getInstanceForApplication(Context context) {
 		if (client == null) {
-			BeaconManager.logDebug(TAG, "BeaconManager instance creation");
+            LogManager.d(TAG, "BeaconManager instance creation");
 			client = new BeaconManager(context);
 		}
 		return client;
@@ -209,73 +231,75 @@ public static BeaconManager getInstanceForApplication(Context context) {
         return beaconParsers;
     }
 
-	protected BeaconManager(Context context) {
-		mContext = context;
+    protected BeaconManager(Context context) {
+        mContext = context;
         if (!sManifestCheckingDisabled) {
             verifyServiceDeclaration();
         }
         this.beaconParsers.add(new AltBeaconParser());
-	}
-	/**
-	 * Check if Bluetooth LE is supported by this Android device, and if so, make sure it is enabled.
-	 * @throws  BleNotAvailableException if Bluetooth LE is not supported.  (Note: The Android emulator will do this)
-	 * @return false if it is supported and not enabled
-	 */
+    }
+
+    /**
+     * Check if Bluetooth LE is supported by this Android device, and if so, make sure it is enabled.
+     *
+     * @return false if it is supported and not enabled
+     * @throws BleNotAvailableException if Bluetooth LE is not supported.  (Note: The Android emulator will do this)
+     */
     @TargetApi(18)
-	public boolean checkAvailability() throws BleNotAvailableException {
+    public boolean checkAvailability() throws BleNotAvailableException {
         if (android.os.Build.VERSION.SDK_INT < 18) {
             throw new BleNotAvailableException("Bluetooth LE not supported by this device");
         }
-		if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
-			throw new BleNotAvailableException("Bluetooth LE not supported by this device"); 
-		}		
-		else {
-			if (((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled()){
-				return true;
-			}
-		}	
-		return false;
-	}
-	/**
-	 * Binds an Android <code>Activity</code> or <code>Service</code> to the <code>BeaconService</code>.  The
-	 * <code>Activity</code> or <code>Service</code> must implement the <code>beaconConsuemr</code> interface so
-	 * that it can get a callback when the service is ready to use.
-	 * 
-	 * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
-	 */
-	public void bind(BeaconConsumer consumer) {
+        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            throw new BleNotAvailableException("Bluetooth LE not supported by this device");
+        } else {
+            if (((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Binds an Android <code>Activity</code> or <code>Service</code> to the <code>BeaconService</code>.  The
+     * <code>Activity</code> or <code>Service</code> must implement the <code>beaconConsuemr</code> interface so
+     * that it can get a callback when the service is ready to use.
+     *
+     * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
+     */
+    public void bind(BeaconConsumer consumer) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
             return;
         }
         synchronized (consumers) {
-            if (consumers.keySet().contains(consumer)) {
-                BeaconManager.logDebug(TAG, "This consumer is already bound");
+            ConsumerInfo consumerInfo = consumers.putIfAbsent(consumer, new ConsumerInfo());
+            if (consumerInfo != null) {
+                LogManager.d(TAG, "This consumer is already bound");
             }
             else {
-                BeaconManager.logDebug(TAG, "This consumer is not bound.  binding: "+consumer);
-                consumers.put(consumer, new ConsumerInfo());
+                LogManager.d(TAG, "This consumer is not bound.  binding: %s", consumer);
                 Intent intent = new Intent(consumer.getApplicationContext(), BeaconService.class);
                 consumer.bindService(intent, beaconServiceConnection, Context.BIND_AUTO_CREATE);
-                BeaconManager.logDebug(TAG, "consumer count is now:"+consumers.size());
+                LogManager.d(TAG, "consumer count is now: %s", consumers.size());
             }
         }
-	}
-	
-	/**
-	 * Unbinds an Android <code>Activity</code> or <code>Service</code> to the <code>BeaconService</code>.  This should
-	 * typically be called in the onDestroy() method.
-	 * 
-	 * @param consumer the <code>Activity</code> or <code>Service</code> that no longer needs to use the service.
-	 */
-	public void unbind(BeaconConsumer consumer) {
+    }
+
+    /**
+     * Unbinds an Android <code>Activity</code> or <code>Service</code> to the <code>BeaconService</code>.  This should
+     * typically be called in the onDestroy() method.
+     *
+     * @param consumer the <code>Activity</code> or <code>Service</code> that no longer needs to use the service.
+     */
+    public void unbind(BeaconConsumer consumer) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
             return;
         }
-        synchronized(consumers) {
-            if (consumers.keySet().contains(consumer)) {
-                Log.d(TAG, "Unbinding");
+        synchronized (consumers) {
+            if (consumers.containsKey(consumer)) {
+                LogManager.d(TAG, "Unbinding");
                 consumer.unbindService(beaconServiceConnection);
                 consumers.remove(consumer);
                 if (consumers.size() == 0) {
@@ -285,33 +309,39 @@ public void unbind(BeaconConsumer consumer) {
                 }
             }
             else {
-                BeaconManager.logDebug(TAG, "This consumer is not bound to: "+consumer);
-                BeaconManager.logDebug(TAG, "Bound consumers: ");
-                for (int i = 0; i < consumers.size(); i++) {
-                    Log.i(TAG, " "+consumers.get(i));
+                LogManager.d(TAG, "This consumer is not bound to: %s", consumer);
+                LogManager.d(TAG, "Bound consumers: ");
+                Set<Map.Entry<BeaconConsumer, ConsumerInfo>> consumers = this.consumers.entrySet();
+                for (Map.Entry<BeaconConsumer, ConsumerInfo> consumerEntry : consumers) {
+                    LogManager.d(TAG, String.valueOf(consumerEntry.getValue()));
                 }
             }
         }
- 	}
+    }
 
     /**
      * Tells you if the passed beacon consumer is bound to the service
+     *
      * @param consumer
      * @return
      */
     public boolean isBound(BeaconConsumer consumer) {
         synchronized(consumers) {
-            return consumers.keySet().contains(consumer) && (serviceMessenger != null);
+            return consumer != null && consumers.get(consumer) != null && (serviceMessenger != null);
         }
     }
 
     /**
      * Tells you if the any beacon consumer is bound to the service
+     *
      * @return
      */
     public boolean isAnyConsumerBound() {
-        return consumers.size() > 0 && (serviceMessenger != null);
+        synchronized(consumers) {
+            return consumers.size() > 0 && (serviceMessenger != null);
+        }
     }
+
     /**
      * This method notifies the beacon service that the application is either moving to background
      * mode or foreground mode.  When in background mode, BluetoothLE scans to look for beacons are
@@ -321,6 +351,7 @@ public boolean isAnyConsumerBound() {
      * the foreground.  Updates will come every time interval equal to the sum total of the
      * BackgroundScanPeriod and the BackgroundBetweenScanPeriod.
      *
+     * @param backgroundMode true indicates the app is in the background
      * @see #DEFAULT_FOREGROUND_SCAN_PERIOD
      * @see #DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD;
      * @see #DEFAULT_BACKGROUND_SCAN_PERIOD;
@@ -329,116 +360,115 @@ public boolean isAnyConsumerBound() {
      * @see #setForegroundBetweenScanPeriod(long p)
      * @see #setBackgroundScanPeriod(long p)
      * @see #setBackgroundBetweenScanPeriod(long p)
-     * @param backgroundMode true indicates the app is in the background
      */
     public void setBackgroundMode(boolean backgroundMode) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
         }
         mBackgroundModeUninitialized = false;
         if (backgroundMode != mBackgroundMode) {
             mBackgroundMode = backgroundMode;
             try {
                 this.updateScanPeriods();
-            }
-            catch (RemoteException e) {
-                Log.e(TAG, "Cannot contact service to set scan periods");
+            } catch (RemoteException e) {
+                LogManager.e(TAG, "Cannot contact service to set scan periods");
             }
         }
     }
 
     /**
-      * @return indicator of whether any calls have yet been made to set the
-      * background mode 
-      */
+     * @return indicator of whether any calls have yet been made to set the
+     * background mode
+     */
     public boolean isBackgroundModeUninitialized() {
         return mBackgroundModeUninitialized;
     }
 
-	/**
-	 * Specifies a class that should be called each time the <code>BeaconService</code> gets ranging
-	 * data, which is nominally once per second when beacons are detected.
-     *
+    /**
+     * Specifies a class that should be called each time the <code>BeaconService</code> gets ranging
+     * data, which is nominally once per second when beacons are detected.
+     * <p/>
      * IMPORTANT:  Only one RangeNotifier may be active for a given application.  If two different
      * activities or services set different RangeNotifier instances, the last one set will receive
      * all the notifications.
-	 *  
-	 * @see RangeNotifier 
-	 * @param notifier
-	 */
-	public void setRangeNotifier(RangeNotifier notifier) {
-		rangeNotifier = notifier;
-	}
-
-	/**
-	 * Specifies a class that should be called each time the <code>BeaconService</code> sees
-	 * or stops seeing a Region of beacons.
      *
+     * @param notifier
+     * @see RangeNotifier
+     */
+    public void setRangeNotifier(RangeNotifier notifier) {
+        rangeNotifier = notifier;
+    }
+
+    /**
+     * Specifies a class that should be called each time the <code>BeaconService</code> sees
+     * or stops seeing a Region of beacons.
+     * <p/>
      * IMPORTANT:  Only one MonitorNotifier may be active for a given application.  If two different
      * activities or services set different MonitorNotifier instances, the last one set will receive
      * all the notifications.
-	 *
-	 * @see MonitorNotifier 
-	 * @see #startMonitoringBeaconsInRegion(Region region)
-	 * @see Region 
-	 * @param notifier
-	 */
-	public void setMonitorNotifier(MonitorNotifier notifier) {
-		monitorNotifier = notifier;
-	}
-	
-	/**
-	 * Tells the <code>BeaconService</code> to start looking for beacons that match the passed
-	 * <code>Region</code> object, and providing updates on the estimated mDistance every seconds while
-	 * beacons in the Region are visible.  Note that the Region's unique identifier must be retained to
-	 * later call the stopRangingBeaconsInRegion method.
-	 *  
-	 * @see BeaconManager#setRangeNotifier(RangeNotifier)
-	 * @see BeaconManager#stopRangingBeaconsInRegion(Region region)
-	 * @see RangeNotifier 
-	 * @see Region
-	 * @param region
-	 */
+     *
+     * @param notifier
+     * @see MonitorNotifier
+     * @see #startMonitoringBeaconsInRegion(Region region)
+     * @see Region
+     */
+    public void setMonitorNotifier(MonitorNotifier notifier) {
+        monitorNotifier = notifier;
+    }
+
+    /**
+     * Tells the <code>BeaconService</code> to start looking for beacons that match the passed
+     * <code>Region</code> object, and providing updates on the estimated mDistance every seconds while
+     * beacons in the Region are visible.  Note that the Region's unique identifier must be retained to
+     * later call the stopRangingBeaconsInRegion method.
+     *
+     * @param region
+     * @see BeaconManager#setRangeNotifier(RangeNotifier)
+     * @see BeaconManager#stopRangingBeaconsInRegion(Region region)
+     * @see RangeNotifier
+     * @see Region
+     */
     @TargetApi(18)
-	public void startRangingBeaconsInRegion(Region region) throws RemoteException {
+    public void startRangingBeaconsInRegion(Region region) throws RemoteException {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
             return;
         }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
-		Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-		StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode );
-		msg.obj = obj;
-		serviceMessenger.send(msg);
+        Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
+        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        msg.obj = obj;
+        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
-            rangedRegions.add((Region) region.clone());
+            rangedRegions.add(region);
         }
-	}
-	/**
-	 * Tells the <code>BeaconService</code> to stop looking for beacons that match the passed
-	 * <code>Region</code> object and providing mDistance information for them.
-	 *  
-	 * @see #setMonitorNotifier(MonitorNotifier notifier)
-	 * @see #startMonitoringBeaconsInRegion(Region region)
-	 * @see MonitorNotifier 
-	 * @see Region 
-	 * @param region
-	 */
+    }
+
+    /**
+     * Tells the <code>BeaconService</code> to stop looking for beacons that match the passed
+     * <code>Region</code> object and providing mDistance information for them.
+     *
+     * @param region
+     * @see #setMonitorNotifier(MonitorNotifier notifier)
+     * @see #startMonitoringBeaconsInRegion(Region region)
+     * @see MonitorNotifier
+     * @see Region
+     */
     @TargetApi(18)
-	public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
+    public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to SDK 18.  Method invocation will be ignored");
             return;
         }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
-		Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-		StartRMData obj = new StartRMData(region, callbackPackageName(),this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode );
-		msg.obj = obj;
-		serviceMessenger.send(msg);
+        Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
+        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        msg.obj = obj;
+        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             Region regionToRemove = null;
             for (Region rangedRegion : rangedRegions) {
@@ -448,59 +478,61 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             }
             rangedRegions.remove(regionToRemove);
         }
-	}
-	/**
-	 * Tells the <code>BeaconService</code> to start looking for beacons that match the passed
-	 * <code>Region</code> object.  Note that the Region's unique identifier must be retained to
-	 * later call the stopMonitoringBeaconsInRegion method.
-	 *  
-	 * @see BeaconManager#setMonitorNotifier(MonitorNotifier)
-	 * @see BeaconManager#stopMonitoringBeaconsInRegion(Region region)
-	 * @see MonitorNotifier 
-	 * @see Region 
-	 * @param region
-	 */
+    }
+
+    /**
+     * Tells the <code>BeaconService</code> to start looking for beacons that match the passed
+     * <code>Region</code> object.  Note that the Region's unique identifier must be retained to
+     * later call the stopMonitoringBeaconsInRegion method.
+     *
+     * @param region
+     * @see BeaconManager#setMonitorNotifier(MonitorNotifier)
+     * @see BeaconManager#stopMonitoringBeaconsInRegion(Region region)
+     * @see MonitorNotifier
+     * @see Region
+     */
     @TargetApi(18)
-	public void startMonitoringBeaconsInRegion(Region region) throws RemoteException {
+    public void startMonitoringBeaconsInRegion(Region region) throws RemoteException {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
-		Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-		StartRMData obj = new StartRMData(region, callbackPackageName(),this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode  );
-		msg.obj = obj;
-		serviceMessenger.send(msg);
+        Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
+        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        msg.obj = obj;
+        serviceMessenger.send(msg);
         synchronized (monitoredRegions) {
-            monitoredRegions.add((Region) region.clone());
+            monitoredRegions.add(region);
         }
-	}
-	/**
-	 * Tells the <code>BeaconService</code> to stop looking for beacons that match the passed
-	 * <code>Region</code> object.  Note that the Region's unique identifier is used to match it to
-	 * an existing monitored Region.
-	 *  
-	 * @see BeaconManager#setMonitorNotifier(MonitorNotifier)
-	 * @see BeaconManager#startMonitoringBeaconsInRegion(Region region)
-	 * @see MonitorNotifier 
-	 * @see Region 
-	 * @param region
-	 */
+    }
+
+    /**
+     * Tells the <code>BeaconService</code> to stop looking for beacons that match the passed
+     * <code>Region</code> object.  Note that the Region's unique identifier is used to match it to
+     * an existing monitored Region.
+     *
+     * @param region
+     * @see BeaconManager#setMonitorNotifier(MonitorNotifier)
+     * @see BeaconManager#startMonitoringBeaconsInRegion(Region region)
+     * @see MonitorNotifier
+     * @see Region
+     */
     @TargetApi(18)
-	public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException {
+    public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
-		Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-		StartRMData obj = new StartRMData(region, callbackPackageName(),this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode );
-		msg.obj = obj;
-		serviceMessenger.send(msg);
+        Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
+        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        msg.obj = obj;
+        serviceMessenger.send(msg);
         synchronized (monitoredRegions) {
             Region regionToRemove = null;
             for (Region monitoredRegion : monitoredRegions) {
@@ -510,26 +542,27 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
             }
             monitoredRegions.remove(regionToRemove);
         }
-	}
+    }
 
 
     /**
-     Updates an already running scan with scanPeriod/betweenScanPeriod according to Background/Foreground state.
-     Change will take effect on the start of the next scan cycle.
-     @throws RemoteException - If the BeaconManager is not bound to the service.
+     * Updates an already running scan with scanPeriod/betweenScanPeriod according to Background/Foreground state.
+     * Change will take effect on the start of the next scan cycle.
+     *
+     * @throws RemoteException - If the BeaconManager is not bound to the service.
      */
     @TargetApi(18)
     public void updateScanPeriods() throws RemoteException {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
-        BeaconManager.logDebug(TAG, "updating background flag to "+this.mBackgroundMode );
-        BeaconManager.logDebug(TAG, "updating scan period to "+this.getScanPeriod()+", "+this.getBetweenScanPeriod() );
+        LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
+        LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
         StartRMData obj = new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
         msg.obj = obj;
         serviceMessenger.send(msg);
@@ -537,95 +570,95 @@ public void updateScanPeriods() throws RemoteException {
 
 	private String callbackPackageName() {
 		String packageName = mContext.getPackageName();
-		BeaconManager.logDebug(TAG, "callback packageName: "+packageName);
+        LogManager.d(TAG, "callback packageName: %s", packageName);
 		return packageName;
 	}
 
 	private ServiceConnection beaconServiceConnection = new ServiceConnection() {
-		// Called when the connection with the service is established
-	    public void onServiceConnected(ComponentName className, IBinder service) {
-            BeaconManager.logDebug(TAG,  "we have a connection to the service now");
-	        serviceMessenger = new Messenger(service);
+        // Called when the connection with the service is established
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            LogManager.d(TAG, "we have a connection to the service now");
+            serviceMessenger = new Messenger(service);
             synchronized(consumers) {
-                Iterator<BeaconConsumer> consumerIterator = consumers.keySet().iterator();
-                while (consumerIterator.hasNext()) {
-                    BeaconConsumer consumer = consumerIterator.next();
-                    Boolean alreadyConnected = consumers.get(consumer).isConnected;
-                    if (!alreadyConnected) {
-                        consumer.onBeaconServiceConnect();
-                        ConsumerInfo consumerInfo = consumers.get(consumer);
-                        consumerInfo.isConnected = true;
-                        consumers.put(consumer,consumerInfo);
+                Iterator<Map.Entry<BeaconConsumer, ConsumerInfo>> iter = consumers.entrySet().iterator();
+                while (iter.hasNext()) {
+                    Map.Entry<BeaconConsumer, ConsumerInfo> entry = iter.next();
+
+                    if (!entry.getValue().isConnected) {
+                        entry.getKey().onBeaconServiceConnect();
+                        entry.getValue().isConnected = true;
                     }
                 }
             }
-	    }
+        }
 
 	    // Called when the connection with the service disconnects
 	    public void onServiceDisconnected(ComponentName className) {
-            Log.e(TAG, "onServiceDisconnected");
+            LogManager.e(TAG, "onServiceDisconnected");
             serviceMessenger = null;
         }
-	};	
+    };
 
     /**
-     * @see #monitorNotifier
      * @return monitorNotifier
+     * @see #monitorNotifier
      */
-	public MonitorNotifier getMonitoringNotifier() {
-		return this.monitorNotifier;		
-	}	
-	/**
-	 * @see #rangeNotifier
-	 * @return rangeNotifier
-	 */
-	public RangeNotifier getRangingNotifier() {
-		return this.rangeNotifier;		
-	}
+    public MonitorNotifier getMonitoringNotifier() {
+        return this.monitorNotifier;
+    }
+
+    /**
+     * @return rangeNotifier
+     * @see #rangeNotifier
+     */
+    public RangeNotifier getRangingNotifier() {
+        return this.rangeNotifier;
+    }
 
     /**
      * @return the list of regions currently being monitored
      */
     public Collection<Region> getMonitoredRegions() {
-        ArrayList<Region> clonedMontoredRegions = new ArrayList<Region>();
         synchronized(this.monitoredRegions) {
-            for (Region montioredRegion : this.monitoredRegions) {
-                clonedMontoredRegions.add((Region) montioredRegion.clone());
-            }
+            return new ArrayList<Region>(this.monitoredRegions);
         }
-        return clonedMontoredRegions;
     }
 
     /**
      * @return the list of regions currently being ranged
      */
     public Collection<Region> getRangedRegions() {
-        ArrayList<Region> clonedRangedRegions = new ArrayList<Region>();
         synchronized(this.rangedRegions) {
-            for (Region rangedRegion : this.rangedRegions) {
-                clonedRangedRegions.add((Region) rangedRegion.clone());
-            }
+            return new ArrayList<Region>(this.rangedRegions);
         }
-        return clonedRangedRegions;
     }
 
     /**
      * Convenience method for logging debug by the library
+     *
      * @param tag
      * @param message
+     * @deprecated This will be removed in a later release. Use
+     * {@link org.altbeacon.beacon.logging.LogManager#d(String, String, Object...)} instead.
      */
+    @Deprecated
     public static void logDebug(String tag, String message) {
-        if (debug) Log.d(tag, message);
+        LogManager.d(tag, message);
     }
 
     /**
      * Convenience method for logging debug by the library
+     *
      * @param tag
      * @param message
      * @param t
+     * @deprecated This will be removed in a later release. Use
+     * {@link org.altbeacon.beacon.logging.LogManager#d(Throwable, String, String, Object...)}
+     * instead.
      */
+    @Deprecated
     public static void logDebug(String tag, String message, Throwable t) {
-        if (debug) Log.d(tag, message, t);
+        LogManager.d(t, tag, message);
     }
 
     protected static BeaconSimulator beaconSimulator;
@@ -640,16 +673,52 @@ public static void setDistanceModelUpdateUrl(String url) {
         distanceModelUpdateUrl = url;
     }
 
+    /**
+     * Default class for rssi filter/calculation implementation
+     */
+    protected static Class rssiFilterImplClass = RunningAverageRssiFilter.class;
+
+    public static void setRssiFilterImplClass(Class c) {
+        rssiFilterImplClass = c;
+    }
+
+    public static Class getRssiFilterImplClass() {
+        return rssiFilterImplClass;
+    }
+
+    /**
+     * Allow the library to use a tracking cache
+     * @param useTrackingCache
+     */
+    public static void setUseTrackingCache(boolean useTrackingCache) {
+        RangeState.setUseTrackingCache(useTrackingCache);
+    }
+
+    /**
+     * Set the period of time, in which a beacon did not receive new
+     * measurements
+     * @param maxTrackingAge in milliseconds
+     */
+    public void setMaxTrackingAge(int maxTrackingAge) {
+        RangedBeacon.setMaxTrackinAge(maxTrackingAge);
+    }
+
     public static void setBeaconSimulator(BeaconSimulator beaconSimulator) {
         BeaconManager.beaconSimulator = beaconSimulator;
     }
+
     public static BeaconSimulator getBeaconSimulator() {
         return BeaconManager.beaconSimulator;
     }
 
 
-    protected void setDataRequestNotifier(RangeNotifier notifier) { this.dataRequestNotifier = notifier; }
-    protected RangeNotifier getDataRequestNotifier() { return this.dataRequestNotifier; }
+    protected void setDataRequestNotifier(RangeNotifier notifier) {
+        this.dataRequestNotifier = notifier;
+    }
+
+    protected RangeNotifier getDataRequestNotifier() {
+        return this.dataRequestNotifier;
+    }
 
     private class ConsumerInfo {
         public boolean isConnected = false;
@@ -658,16 +727,15 @@ public static BeaconSimulator getBeaconSimulator() {
     private long getScanPeriod() {
         if (mBackgroundMode) {
             return backgroundScanPeriod;
-        }
-        else {
+        } else {
             return foregroundScanPeriod;
         }
     }
+
     private long getBetweenScanPeriod() {
         if (mBackgroundMode) {
             return backgroundBetweenScanPeriod;
-        }
-        else {
+        } else {
             return foregroundBetweenScanPeriod;
         }
     }
@@ -686,13 +754,14 @@ private void verifyServiceDeclaration() {
 
     public class ServiceNotDeclaredException extends RuntimeException {
         public ServiceNotDeclaredException() {
-            super("The BeaconService is not properly declared in AndroidManifest.xml.  If using Eclipse,"+
-            " please verify that your project.properties has manifestmerger.enabled=true");
+            super("The BeaconService is not properly declared in AndroidManifest.xml.  If using Eclipse," +
+                    " please verify that your project.properties has manifestmerger.enabled=true");
         }
     }
 
     /**
      * Determines if Android L Scanning is disabled by user selection
+     *
      * @return
      */
     public static boolean isAndroidLScanningDisabled() {
@@ -703,6 +772,7 @@ public static boolean isAndroidLScanningDisabled() {
      * Allows disabling use of Android L BLE Scanning APIs on devices with API 21+
      * If set to false (default), devices with API 21+ will use the Android L APIs to
      * scan for beacons
+     *
      * @param disabled
      */
     public static void setAndroidLScanningDisabled(boolean disabled) {
@@ -712,6 +782,7 @@ public static void setAndroidLScanningDisabled(boolean disabled) {
     /**
      * Allows disabling check of manifest for proper configuration of service.  Useful for unit
      * testing
+     *
      * @param disabled
      */
     public static void setsManifestCheckingDisabled(boolean disabled) {
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index aa21e170..4d8739bf 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -2,7 +2,8 @@
 
 import android.annotation.TargetApi;
 import android.bluetooth.BluetoothDevice;
-import android.util.Log;
+
+import org.altbeacon.beacon.logging.LogManager;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -33,7 +34,8 @@
 public class BeaconParser {
     private static final String TAG = "BeaconParser";
     private static final Pattern I_PATTERN = Pattern.compile("i\\:(\\d+)\\-(\\d+)(l?)");
-    private static final Pattern M_PATTERN = Pattern.compile("m\\:(\\d+)-(\\d+)\\=([0-9A-F-a-f]+)");
+    private static final Pattern M_PATTERN = Pattern.compile("m\\:(\\d+)-(\\d+)\\=([0-9A-Fa-f]+)");
+    private static final Pattern S_PATTERN = Pattern.compile("s\\:(\\d+)-(\\d+)\\=([0-9A-Fa-f]+)");
     private static final Pattern D_PATTERN = Pattern.compile("d\\:(\\d+)\\-(\\d+)([bl]?)");
     private static final Pattern P_PATTERN = Pattern.compile("p\\:(\\d+)\\-(\\d+)");
     private static final char[] HEX_ARRAY = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
@@ -47,6 +49,10 @@
     protected List<Boolean> mDataLittleEndianFlags;
     protected Integer mMatchingBeaconTypeCodeStartOffset;
     protected Integer mMatchingBeaconTypeCodeEndOffset;
+    protected Integer mServiceUuidStartOffset;
+    protected Integer mServiceUuidEndOffset;
+    protected Long mServiceUuid;
+
     protected Integer mPowerStartOffset;
     protected Integer mPowerEndOffset;
     protected int[] mHardwareAssistManufacturers = new int[] { 0x004c };
@@ -75,6 +81,7 @@ public BeaconParser() {
      *
      * <pre>
      *   m - matching byte sequence for this beacon type to parse (exactly one required)
+     *   s - ServiceUuuid for this beacon type to parse (optional, only for Gatt-based becons)
      *   i - identifier (at least one required, multiple allowed)
      *   p - power calibration field (exactly one required)
      *   d - data field (optional, multiple allowed)
@@ -185,8 +192,28 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
                     throw new BeaconLayoutException("Cannot parse beacon type code: "+hexString+" in term: " + term);
                 }
             }
+            matcher = S_PATTERN.matcher(term);
+            while (matcher.find()) {
+                found = true;
+                try {
+                    int startOffset = Integer.parseInt(matcher.group(1));
+                    int endOffset = Integer.parseInt(matcher.group(2));
+                    mServiceUuidStartOffset = startOffset;
+                    mServiceUuidEndOffset = endOffset;
+                } catch (NumberFormatException e) {
+                    throw new BeaconLayoutException("Cannot parse integer byte offset in term: " + term);
+                }
+                String hexString = matcher.group(3);
+                try {
+                    mServiceUuid = Long.decode("0x"+hexString);
+                }
+                catch (NumberFormatException e) {
+                    throw new BeaconLayoutException("Cannot parse serviceUuid: "+hexString+" in term: " + term);
+                }
+            }
+
             if (!found) {
-                BeaconManager.logDebug(TAG, "cannot parse term "+term);
+                LogManager.d(TAG, "cannot parse term %s", term);
                 throw new BeaconLayoutException("Cannot parse beacon layout term: " + term);
             }
         }
@@ -251,6 +278,32 @@ public int getMatchingBeaconTypeCodeEndOffset() {
         return mMatchingBeaconTypeCodeEndOffset;
     }
 
+
+    /**
+     * @see #mServiceUuid
+     * @return
+     */
+    public Long getServiceUuid() {
+        return mServiceUuid;
+    }
+
+    /**
+     * see #mServiceUuidStartOffset
+     * @return
+     */
+    public int getMServiceUuidStartOffset() {
+        return mServiceUuidStartOffset;
+    }
+
+    /**
+     * see #mServiceUuidEndOffset
+     * @return
+     */
+    public int getServiceUuidEndOffset() {
+        return mServiceUuidEndOffset;
+    }
+
+
     /**
      * Construct a Beacon from a Bluetooth LE packet collected by Android's Bluetooth APIs,
      * including the raw bluetooth device info
@@ -268,37 +321,70 @@ public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
     @TargetApi(5)
     protected Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device, Beacon beacon) {
 
+        int maxByteForMatch = 5; // for manufacturer data-based beacons
+        byte[] serviceUuidBytes = null;
+        byte[] typeCodeBytes = longToByteArray(getMatchingBeaconTypeCode(), mMatchingBeaconTypeCodeEndOffset-mMatchingBeaconTypeCodeStartOffset+1);
+        if (getServiceUuid() != null) {
+            maxByteForMatch = 11; // for uuid-based beacons
+            serviceUuidBytes = longToByteArray(getServiceUuid(), mServiceUuidEndOffset-mServiceUuidStartOffset+1);
+        }
         int startByte = 2;
         boolean patternFound = false;
-        byte[] typeCodeBytes = longToByteArray(getMatchingBeaconTypeCode(), mMatchingBeaconTypeCodeEndOffset-mMatchingBeaconTypeCodeStartOffset+1);
 
-        while (startByte <= 5) {
-            if (byteArraysMatch(scanData, startByte+mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
-                patternFound = true;
-                break;
+        while (startByte <= maxByteForMatch) {
+            if (getServiceUuid() == null) {
+                if (byteArraysMatch(scanData, startByte+mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
+                    patternFound = true;
+                    break;
+                }
+            }
+            else {
+                if (byteArraysMatch(scanData, startByte+mServiceUuidStartOffset, serviceUuidBytes, 0) &&
+                    byteArraysMatch(scanData, startByte+mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
+                    patternFound = true;
+                    break;
+                }
             }
             startByte++;
         }
 
         if (patternFound == false) {
-            // This is not an beacon
-            BeaconManager.logDebug(TAG, "This is not a matching Beacon advertisement.  (Was expecting "+byteArrayToString(typeCodeBytes)+".  The bytes I see are: "+bytesToHex(scanData));
+            // This is not a beacon
+            if (getServiceUuid() == null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "This is not a matching Beacon advertisement. (Was expecting %s.  "
+                                    + "The bytes I see are: %s", byteArrayToString(typeCodeBytes),
+                            bytesToHex(scanData));
+
+                }
+            }
+            else {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "This is not a matching Beacon advertisement. (Was expecting %s and %s.  "
+                                    + "The bytes I see are: %s", byteArrayToString(serviceUuidBytes),
+                            byteArrayToString(typeCodeBytes),
+                            bytesToHex(scanData));
+                }
+            }
+
             return null;
         }
         else {
-            BeaconManager.logDebug(TAG, "This is a recognized beacon advertisement -- "+String.format("%04x", getMatchingBeaconTypeCode())+" seen");
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG, "This is a recognized beacon advertisement -- %s seen",
+                        byteArrayToString(typeCodeBytes));
+            }
         }
 
         ArrayList<Identifier> identifiers = new ArrayList<Identifier>();
         for (int i = 0; i < mIdentifierEndOffsets.size(); i++) {
-            String idString = byteArrayToFormattedString(scanData, mIdentifierStartOffsets.get(i)+startByte, mIdentifierEndOffsets.get(i)+startByte, mIdentifierLittleEndianFlags.get(i));
-            identifiers.add(Identifier.parse(idString));
+            Identifier identifier = Identifier.fromBytes(scanData, mIdentifierStartOffsets.get(i)+startByte, mIdentifierEndOffsets.get(i)+startByte + 1, mIdentifierLittleEndianFlags.get(i));
+            identifiers.add(identifier);
         }
         ArrayList<Long> dataFields = new ArrayList<Long>();
         for (int i = 0; i < mDataEndOffsets.size(); i++) {
             String dataString = byteArrayToFormattedString(scanData, mDataStartOffsets.get(i)+startByte, mDataEndOffsets.get(i)+startByte, mDataLittleEndianFlags.get(i));
             dataFields.add(Long.parseLong(dataString));
-            BeaconManager.logDebug(TAG, "parsing found data field "+i);
             // TODO: error handling needed here on the parse
         }
 
@@ -333,6 +419,13 @@ protected Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device,
         beacon.mTxPower = txPower;
         beacon.mRssi = rssi;
         beacon.mBeaconTypeCode = beaconTypeCode;
+        if (mServiceUuid != null) {
+            beacon.mServiceUuid = (int) mServiceUuid.longValue();
+        }
+        else {
+            beacon.mServiceUuid = -1;
+        }
+
         beacon.mBluetoothAddress = macAddress;
         beacon.mBluetoothName= name;
         beacon.mManufacturer = manufacturer;
@@ -421,6 +514,19 @@ public int getIdentifierByteCount(int identifierNum) {
         return mIdentifierEndOffsets.get(identifierNum) - mIdentifierStartOffsets.get(identifierNum) + 1;
     }
 
+    /**
+     * @return the number of identifiers in this beacon format
+     */
+    public int getIdentifierCount() {
+        return mIdentifierStartOffsets.size();
+    }
+
+    /**
+     * @return the number of data fields in this beacon format
+     */
+    public int getDataFieldCount() {
+        return mDataStartOffsets.size();
+    }
 
     protected static String bytesToHex(byte[] bytes) {
         char[] hexChars = new char[bytes.length * 2];
@@ -446,9 +552,6 @@ public BeaconLayoutException(String s) {
             long mask = 0xffl << (length-i-1)*8;
             long shift = (length-i-1)*8;
             long value = ((longValue & mask)  >> shift);
-            //BeaconManager.logDebug(TAG, "masked value is "+String.format("%08x",longValue & mask));
-            //BeaconManager.logDebug(TAG, "masked value shifted is "+String.format("%08x",(longValue & mask) >> shift));
-            //BeaconManager.logDebug(TAG, "for long "+String.format("%08x",longValue)+" at position: "+i+" of "+length+" mask: "+String.format("%08x",mask)+" shift: "+shift+" the value is "+String.format("%02x",value));
             array[i] = (byte) value;
 
         }
@@ -472,7 +575,7 @@ private String byteArrayToString(byte[] bytes) {
         return sb.toString().trim();
     }
 
-    private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int endIndex, Boolean littleEndian) {
+    private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int endIndex, boolean littleEndian) {
         byte[] bytes = new byte[endIndex-startIndex+1];
         if (littleEndian) {
             for (int i = 0; i <= endIndex-startIndex; i++) {
@@ -489,17 +592,14 @@ private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int
         int length = endIndex-startIndex +1;
         // We treat a 1-4 byte number as decimal string
         if (length < 5) {
-            Long number = 0l;
-            BeaconManager.logDebug(TAG, "Byte array is size "+bytes.length);
+            long number = 0l;
             for (int i = 0; i < bytes.length; i++)  {
-                BeaconManager.logDebug(TAG, "index is "+i);
                 long byteValue = (long) (bytes[bytes.length - i-1] & 0xff);
                 long positionValue = (long) Math.pow(256.0,i*1.0);
-                long calculatedValue =  (long) (byteValue * positionValue);
-                BeaconManager.logDebug(TAG, "calculatedValue for position "+i+" with positionValue "+positionValue+" and byteValue "+byteValue+" is "+calculatedValue);
+                long calculatedValue =  (byteValue * positionValue);
                 number += calculatedValue;
             }
-            return number.toString();
+            return Long.toString(number);
         }
 
         // We treat a 7+ byte number as a hex string
diff --git a/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java b/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
index f13df5a3..ce69bd5b 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
@@ -1,21 +1,21 @@
 package org.altbeacon.beacon;
 
-import java.nio.ByteBuffer;
-import java.util.UUID;
-
-import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.logging.LogManager;
 
 import android.annotation.TargetApi;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothManager;
+import java.nio.ByteOrder;
+import java.nio.ByteBuffer;
+import java.util.UUID;
 import android.bluetooth.le.AdvertiseCallback;
 import android.bluetooth.le.AdvertiseSettings;
 import android.bluetooth.le.AdvertiseData;
 import android.bluetooth.le.BluetoothLeAdvertiser;
 import android.content.Context;
 import android.content.pm.PackageManager;
-import android.os.Build;
-import android.util.Log;
+
+import android.os.ParcelUuid;
 
 /**
  * Provides a mechanism for transmitting as a beacon.   Requires Android 5.0
@@ -25,8 +25,12 @@
     public static final int SUPPORTED = 0;
     public static final int NOT_SUPPORTED_MIN_SDK = 1;
     public static final int NOT_SUPPORTED_BLE = 2;
+    // isMultipleAdvertisementSupported returning false no longer indicates that transmission is not
+    // possible
+    @Deprecated
     public static final int NOT_SUPPORTED_MULTIPLE_ADVERTISEMENTS = 3;
     public static final int NOT_SUPPORTED_CANNOT_GET_ADVERTISER = 4;
+    public static final int NOT_SUPPORTED_CANNOT_GET_ADVERTISER_MULTIPLE_ADVERTISEMENTS = 5;
     private static final String TAG = "BeaconTransmitter";
     private BluetoothAdapter mBluetoothAdapter;
     private BluetoothLeAdvertiser mBluetoothLeAdvertiser;
@@ -51,11 +55,11 @@ public BeaconTransmitter(Context context, BeaconParser parser) {
         if (bluetoothManager != null) {
             mBluetoothAdapter = bluetoothManager.getAdapter();
             mBluetoothLeAdvertiser = mBluetoothAdapter.getBluetoothLeAdvertiser();
-            Log.d(TAG, "new BeaconTransmitter constructed.  mbluetoothLeAdvertiser is " +
+            LogManager.d(TAG, "new BeaconTransmitter constructed.  mbluetoothLeAdvertiser is %s",
                     mBluetoothLeAdvertiser);
         }
         else {
-            Log.e(TAG, "Failed to get BluetoothManager");
+            LogManager.e(TAG, "Failed to get BluetoothManager");
         }
     }
 
@@ -146,6 +150,7 @@ public void startAdvertising() {
             throw new NullPointerException("Beacon cannot be null.  Set beacon before starting advertising");
         }
         int manufacturerCode = mBeacon.getManufacturer();
+        int serviceUuid = mBeacon.getServiceUuid();
 
         if (mBeaconParser == null) {
             throw new NullPointerException("You must supply a BeaconParser instance to BeaconTransmitter.");
@@ -157,12 +162,24 @@ public void startAdvertising() {
             byteString += String.format("%02X", advertisingBytes[i]);
             byteString += " ";
         }
-        Log.d(TAG, "Starting advertising with ID1: "+mBeacon.getId1()+" ID2: "+mBeacon.getId2()
-                +" ID3: "+mBeacon.getId3()+" and data: "+byteString+" of size "+advertisingBytes.length);
+        LogManager.d(TAG, "Starting advertising with ID1: %s ID2: %s ID3: %s and data: %s of size "
+                        + "%s", mBeacon.getId1(),
+                        mBeacon.getIdentifiers().size() > 1 ? mBeacon.getId2() : "",
+                        mBeacon.getIdentifiers().size() > 2 ? mBeacon.getId3() : "", byteString,
+                advertisingBytes.length);
 
         try{
             AdvertiseData.Builder dataBuilder = new AdvertiseData.Builder();
-            dataBuilder.addManufacturerData(manufacturerCode, advertisingBytes);
+            if (serviceUuid > 0) {
+                byte[] serviceUuidBytes = new byte[] {
+                        (byte) ((serviceUuid >> 8) & 0xff),
+                        (byte) (serviceUuid & 0xff)};
+                ParcelUuid parcelUuid = parseUuidFrom(serviceUuidBytes);
+                dataBuilder.addServiceData(parcelUuid, advertisingBytes);
+            }
+            else {
+                dataBuilder.addManufacturerData(manufacturerCode, advertisingBytes);
+            }
 
             AdvertiseSettings.Builder settingsBuilder = new AdvertiseSettings.Builder();
 
@@ -172,10 +189,10 @@ public void startAdvertising() {
             settingsBuilder.setConnectable(false);
 
             mBluetoothLeAdvertiser.startAdvertising(settingsBuilder.build(), dataBuilder.build(), getAdvertiseCallback());
-            Log.d(TAG, "Started advertisement with callback: "+getAdvertiseCallback());
+            LogManager.d(TAG, "Started advertisement with callback: %s", getAdvertiseCallback());
 
         } catch (Exception e){
-            Log.e(TAG, "Cannot start advetising due to excepton: ",e);
+            LogManager.e(e, TAG, "Cannot start advertising due to exception");
         }
     }
 
@@ -184,12 +201,17 @@ public void startAdvertising() {
      */
     public void stopAdvertising() {
         if (!mStarted) {
-            Log.d(TAG, "Skipping stop advertising -- not started");
+            LogManager.d(TAG, "Skipping stop advertising -- not started");
             return;
         }
-        Log.d(TAG, "Stopping advertising with object "+mBluetoothLeAdvertiser);
+        LogManager.d(TAG, "Stopping advertising with object %s", mBluetoothLeAdvertiser);
         mAdvertisingClientCallback = null;
-        mBluetoothLeAdvertiser.stopAdvertising(getAdvertiseCallback());
+        try {
+            mBluetoothLeAdvertiser.stopAdvertising(getAdvertiseCallback());
+        }
+        catch (IllegalStateException e) {
+            LogManager.w(TAG, "Bluetooth is turned off. Transmitter stop call failed.");
+        }
         mStarted = false;
     }
 
@@ -202,22 +224,31 @@ public void stopAdvertising() {
      *          NOT_SUPPORTED_CANNOT_GET_ADVERTISER
      */
     public static int checkTransmissionSupported(Context context) {
+        int returnCode = SUPPORTED;
+
         if (android.os.Build.VERSION.SDK_INT < 21) {
-            return NOT_SUPPORTED_MIN_SDK;
+            returnCode = NOT_SUPPORTED_MIN_SDK;
         }
-        if (!context.getApplicationContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
-            return NOT_SUPPORTED_BLE;
+        else if (!context.getApplicationContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            returnCode = NOT_SUPPORTED_BLE;
         }
-        if (!((BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isMultipleAdvertisementSupported()) {
-            return NOT_SUPPORTED_MULTIPLE_ADVERTISEMENTS;
-        }
-        try {
-            // Check to see if the getBluetoothLeAdvertiser is available.  If not, this will throw an exception indicating we are not running Android L
-            ((BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().getBluetoothLeAdvertiser();
-        } catch (Exception e) {
-            return NOT_SUPPORTED_CANNOT_GET_ADVERTISER;
+        else {
+            try {
+                // Check to see if the getBluetoothLeAdvertiser is available.  If not, this will throw an exception indicating we are not running Android L
+                if (((BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().getBluetoothLeAdvertiser() == null) {
+                    if (!((BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isMultipleAdvertisementSupported()) {
+                        returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER_MULTIPLE_ADVERTISEMENTS;
+                    }
+                    else {
+                        returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER;
+                    }
+                }
+            } catch (Exception e) {
+                returnCode = NOT_SUPPORTED_CANNOT_GET_ADVERTISER;
+            }
         }
-        return SUPPORTED;
+
+        return returnCode;
     }
 
     private AdvertiseCallback getAdvertiseCallback() {
@@ -225,7 +256,7 @@ private AdvertiseCallback getAdvertiseCallback() {
             mAdvertiseCallback = new AdvertiseCallback() {
                 @Override
                 public void onStartFailure(int errorCode) {
-                    Log.e(TAG,"Advertisement start failed, code: "+errorCode);
+                    LogManager.e(TAG,"Advertisement start failed, code: %s", errorCode);
                     if (mAdvertisingClientCallback != null) {
                         mAdvertisingClientCallback.onStartFailure(errorCode);
                     }
@@ -234,7 +265,7 @@ public void onStartFailure(int errorCode) {
 
                 @Override
                 public void onStartSuccess(AdvertiseSettings settingsInEffect) {
-                    Log.i(TAG,"Advertisement start succeeded.");
+                    LogManager.i(TAG,"Advertisement start succeeded.");
                     mStarted = true;
                     if (mAdvertisingClientCallback != null) {
                         mAdvertisingClientCallback.onStartSuccess(settingsInEffect);
@@ -248,4 +279,58 @@ public void onStartSuccess(AdvertiseSettings settingsInEffect) {
         return mAdvertiseCallback;
     }
 
+    /**
+     * Parse UUID from bytes. The {@code uuidBytes} can represent a 16-bit, 32-bit or 128-bit UUID,
+     * but the returned UUID is always in 128-bit format.
+     * Note UUID is little endian in Bluetooth.
+     *
+     * @param uuidBytes Byte representation of uuid.
+     * @return {@link ParcelUuid} parsed from bytes.
+     * @throws IllegalArgumentException If the {@code uuidBytes} cannot be parsed.
+     *
+     * Copied from java/android/bluetooth/BluetoothUuid.java
+     * Copyright (C) 2009 The Android Open Source Project
+     * Licensed under the Apache License, Version 2.0
+     */
+    private static ParcelUuid parseUuidFrom(byte[] uuidBytes) {
+        /** Length of bytes for 16 bit UUID */
+        final int UUID_BYTES_16_BIT = 2;
+        /** Length of bytes for 32 bit UUID */
+        final int UUID_BYTES_32_BIT = 4;
+        /** Length of bytes for 128 bit UUID */
+        final int UUID_BYTES_128_BIT = 16;
+        final ParcelUuid BASE_UUID =
+                ParcelUuid.fromString("00000000-0000-1000-8000-00805F9B34FB");
+        if (uuidBytes == null) {
+            throw new IllegalArgumentException("uuidBytes cannot be null");
+        }
+        int length = uuidBytes.length;
+        if (length != UUID_BYTES_16_BIT && length != UUID_BYTES_32_BIT &&
+                length != UUID_BYTES_128_BIT) {
+            throw new IllegalArgumentException("uuidBytes length invalid - " + length);
+        }
+        // Construct a 128 bit UUID.
+        if (length == UUID_BYTES_128_BIT) {
+            ByteBuffer buf = ByteBuffer.wrap(uuidBytes).order(ByteOrder.LITTLE_ENDIAN);
+            long msb = buf.getLong(8);
+            long lsb = buf.getLong(0);
+            return new ParcelUuid(new UUID(msb, lsb));
+        }
+        // For 16 bit and 32 bit UUID we need to convert them to 128 bit value.
+        // 128_bit_value = uuid * 2^96 + BASE_UUID
+        long shortUuid;
+        if (length == UUID_BYTES_16_BIT) {
+            shortUuid = uuidBytes[0] & 0xFF;
+            shortUuid += (uuidBytes[1] & 0xFF) << 8;
+        } else {
+            shortUuid = uuidBytes[0] & 0xFF ;
+            shortUuid += (uuidBytes[1] & 0xFF) << 8;
+            shortUuid += (uuidBytes[2] & 0xFF) << 16;
+            shortUuid += (uuidBytes[3] & 0xFF) << 24;
+        }
+        long msb = BASE_UUID.getUuid().getMostSignificantBits() + (shortUuid << 32);
+        long lsb = BASE_UUID.getUuid().getLeastSignificantBits();
+        return new ParcelUuid(new UUID(msb, lsb));
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/Identifier.java b/src/main/java/org/altbeacon/beacon/Identifier.java
index c49981d4..c7de777e 100644
--- a/src/main/java/org/altbeacon/beacon/Identifier.java
+++ b/src/main/java/org/altbeacon/beacon/Identifier.java
@@ -1,182 +1,333 @@
 package org.altbeacon.beacon;
 
-import java.util.regex.Matcher;
+import java.nio.ByteBuffer;
+import java.nio.LongBuffer;
+import java.util.Arrays;
+import java.util.UUID;
 import java.util.regex.Pattern;
 
 /**
- *
- * Encapsulates a beacon identifier of arbitrary byte length
- * It can encapsulate an identifier that is a 16-byte UUID, or an integer
- * Internally this is stored as a normalized string representation for ease of serialization
- *
- * Created by dyoung on 7/18/14.
+ * Encapsulates a beacon identifier of arbitrary byte length.
+ * It can encapsulate an identifier that is a 16-byte UUID, or an integer.
+ * <p>
+ * Instances of this class are immutable, so those can be shared without problem between threads.
+ * <p>
+ * The value is internally this is stored as a byte array.
  */
-public class Identifier {
-    private static final String TAG = "Identifier";
-    private static final Pattern HEX_PATTERN = Pattern.compile("^0x[0-9A-F-a-f]+$");
-    private static final Pattern DECIMAL_PATTERN = Pattern.compile("^[0-9]+$");
-    private static final Pattern UUID_PATTERN = Pattern.compile("^[0-9A-F-a-f]+-[0-9A-F-a-f]+-[0-9A-F-a-f]+-[0-9A-F-a-f]+-[0-9A-F-a-f]+$");
+public class Identifier implements Comparable<Identifier> {
+    private static final Pattern HEX_PATTERN = Pattern.compile("^0x[0-9A-Fa-f]*$");
+    private static final Pattern DECIMAL_PATTERN = Pattern.compile("^[0-9]{1,5}$");
+    // BUG: Dashes in UUIDs are not optional!
+    private static final Pattern UUID_PATTERN = Pattern.compile("^[0-9A-Fa-f]{8}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{4}-?[0-9A-Fa-f]{12}$");
+    private static final int MAX_INTEGER = 65535;
 
-    private String mStringValue;
+    private final byte[] mValue;
 
     /**
+     * Takes the passed string and tries to figure out what format it is in.
+     * Then turns the string into plain bytes and constructs an Identifier.
+     *
+     * Known bug: This method happily parses UUIDs without dashes (normally
+     * invalid). Although the bug is left unfixed for backward compatibility,
+     * please check your UUIDs or even better, use
+     * {@link #fromUuid(java.util.UUID)} directly, which is safe.
+     *
      * Allowed formats:
-     *   UUID: 2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6
-     *   HEX: 0x000000000003 
-     *   decimal: 65536 
-     * @param identifierString
-     * @return
+     * <ul>
+     *   <li>UUID: 2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6 (16 bytes)</li>
+     *   <li>Hexadecimal: 0x000000000003 (variable length)</li>
+     *   <li>Decimal: 1337 (2 bytes)</li>
+     * </ul>
+     *
+     * @param  stringValue string to parse
+     * @return             Identifier representing the specified value
+     * @throws             IllegalArgumentException if the passed string cannot be parsed
+     * @throws             NullPointerException if the passed string is <code>null</code>
+     * @see                <a href="https://www.ietf.org/rfc/rfc4122.txt">RFC 4122 on UUIDs</a>
      */
-    public static Identifier parse(String identifierString) {
-        return new Identifier(identifierString);
+    public static Identifier parse(String stringValue) {
+        if (stringValue == null) {
+            throw new NullPointerException("Identifiers cannot be constructed from null pointers but \"stringValue\" is null.");
+        }
+
+        if (HEX_PATTERN.matcher(stringValue).matches()) {
+            return parseHex(stringValue.substring(2));
+        }
+
+        if (UUID_PATTERN.matcher(stringValue).matches()) {
+            return parseHex(stringValue.replace("-", ""));
+        }
+
+        if (DECIMAL_PATTERN.matcher(stringValue).matches()) {
+            int value = -1;
+            try {
+                value = Integer.valueOf(stringValue);
+            }
+            catch (Throwable t) {
+                throw new IllegalArgumentException("Unable to parse Identifier in decimal format.", t);
+            }
+            return fromInt(value);
+        }
+
+        throw new IllegalArgumentException("Unable to parse Identifier.");
+    }
+
+    private static Identifier parseHex(String identifierString) {
+        String str = identifierString.length() % 2 == 0 ? "" : "0";
+        str += identifierString.toUpperCase();
+        byte[] result = new byte[str.length() / 2];
+        for (int i = 0; i < result.length; i++) {
+            result[i] = (byte)(Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16) & 0xFF);
+        }
+        return new Identifier(result);
     }
-    public static Identifier fromInt(int identifierInt) {
-        return new Identifier(Integer.toString(identifierInt));
+
+    /**
+     * Creates an Identifier backed by a two byte Array (big endian).
+     * @param intValue an integer between 0 and 65535 (inclusive)
+     * @return an Identifier with the specified value
+     */
+    public static Identifier fromInt(int intValue) {
+        if (intValue < 0 || intValue > MAX_INTEGER) {
+            throw new IllegalArgumentException("Identifers can only be constructed from integers between 0 and " + MAX_INTEGER + " (inclusive).");
+        }
+
+        byte[] newValue = new byte[2];
+
+        newValue[0] = (byte) (intValue >> 8);
+        newValue[1] = (byte) (intValue);
+
+        return new Identifier(newValue);
     }
+
+    /**
+     * Creates an Identifier from the specified byte array.
+     * @param bytes array to copy from
+     * @param start the start index, inclusive
+     * @param end the end index, exclusive
+     * @param littleEndian whether the bytes are ordered in little endian
+     * @return a new Identifier
+     * @throws java.lang.NullPointerException <code>bytes</code> must not be <code>null</code>
+     * @throws java.lang.ArrayIndexOutOfBoundsException start or end are outside the bounds of the array
+     * @throws java.lang.IllegalArgumentException start is larger than end
+     */
+    public static Identifier fromBytes(byte[] bytes, int start, int end, boolean littleEndian) {
+        if (bytes == null) {
+            throw new NullPointerException("Identifiers cannot be constructed from null pointers but \"bytes\" is null.");
+        }
+        if (start < 0 || start > bytes.length) {
+            throw new ArrayIndexOutOfBoundsException("start < 0 || start > bytes.length");
+        }
+        if (end > bytes.length) {
+            throw new ArrayIndexOutOfBoundsException("end > bytes.length");
+        }
+        if (start > end) {
+            throw new IllegalArgumentException("start > end");
+        }
+
+        byte[] byteRange = Arrays.copyOfRange(bytes, start, end);
+        if (littleEndian) {
+            reverseArray(byteRange);
+        }
+        return new Identifier(byteRange);
+    }
+
+    /**
+     * Transforms a {@link java.util.UUID} into an Identifier.
+     * No mangling with strings, only the underlying bytes of the
+     * UUID are used so this is fast and stable.
+     */
+    public static Identifier fromUuid(UUID uuid) {
+        ByteBuffer buf = ByteBuffer.allocate(16);
+        buf.putLong(uuid.getMostSignificantBits());
+        buf.putLong(uuid.getLeastSignificantBits());
+        return new Identifier(buf.array());
+    }
+
+    /**
+     * Creates a new copy of the specified Identifier.
+     * @param identifier identifier to copy
+     * @deprecated objects of this class are immutable and therefore don't have to be cloned when
+     * used from multiple threads
+     */
+    @Deprecated
     public Identifier(Identifier identifier) {
-        if (identifier != null) {
-            mStringValue = identifier.mStringValue;
+        if (identifier == null) {
+            throw new NullPointerException("Identifiers cannot be constructed from null pointers but \"identifier\" is null.");
         }
-        else {
-            throw new NullPointerException("cannot construct Identifier from a null value");
+        mValue = identifier.mValue;
+    }
+
+    /**
+     * Creates a new instance of Identifier
+     * @param value value to use. This value isn't copied, so don't change the value after using it to create an instance!
+     */
+    protected Identifier(byte[] value) {
+        if (value == null) {
+            throw new NullPointerException("Identifiers cannot be constructed from null pointers but \"value\" is null.");
         }
+        this.mValue = value;
     }
 
-    // Note:  the toString() method is also used for serialization and deserialization.  So
-    // toString() and parse() must always return objects that return true when you call equals()
+    /**
+     * Represents the value as a String. The output varies based on the length of the value.
+     * <ul><li>When the value is 2 bytes long: decimal, for example 6536
+     * <li>When the value is 16 bytes long: uuid, for example 2f234454-cf6d-4a0f-adf2-f4911ba9ffa6
+     * <li>Else: hexadecimal prefixed with <code>0x</code>, for example 0x0012ab</ul>
+     * @return string representation of the current value
+     */
     public String toString() {
-        return mStringValue;
+        // Note:  the toString() method is also used for serialization and deserialization.  So
+        // toString() and parse() must always return objects that return true when you call equals()
+        if (mValue.length == 2) {
+            return Integer.toString(toInt());
+        }
+        if (mValue.length == 16) {
+            return toUuid().toString();
+        }
+        return toHexString();
     }
+
+    /**
+     * Represents the value as an <code>int</code>.
+     * @return value represented as int
+     * @throws java.lang.UnsupportedOperationException when value length is longer than 2
+     */
     public int toInt() {
-        return Integer.parseInt(mStringValue);
+        if (mValue.length > 2) {
+            throw new UnsupportedOperationException("Only supported for Identifiers with max byte length of 2");
+        }
+        int result = 0;
+
+        for (int i = 0; i < mValue.length; i++) {
+            result |= (mValue[i] & 0xFF) << ((mValue.length - i - 1) * 8);
+        }
+
+        return result;
     }
 
     /**
      * Converts identifier to a byte array
      * @param bigEndian true if bytes are MSB first
-     * @return
+     * @return a new byte array with a copy of the value
      */
     public byte[] toByteArrayOfSpecifiedEndianness(boolean bigEndian) {
-        String hexString = toHexString();
-        int length = hexString.length()/2;
-        byte[] bytes = new byte[length];
-        for (int i = 0; i < length; i++) {
-            String hexByte = hexString.substring(i*2, i*2+2);
-            byte b = (byte) Integer.parseInt(hexByte, 16);
-            if (bigEndian) {
-                bytes[i] = b;
-            }
-            else {
-                bytes[length-i-1] = b;
-            }
+        byte[] copy = Arrays.copyOf(mValue, mValue.length);
+
+        if (!bigEndian) {
+            reverseArray(copy);
+        }
+
+        return copy;
+    }
+
+    private static void reverseArray(byte[] bytes) {
+        for (int i = 0; i < bytes.length / 2; i++) {
+            int mirroredIndex = bytes.length - i - 1;
+            byte tmp = bytes[i];
+            bytes[i] = bytes[mirroredIndex];
+            bytes[mirroredIndex] = tmp;
         }
-        return bytes;
     }
 
     /**
-     * Returns the byte length of this identifier
-     * @return
+     * Returns the byte length of this identifier.
+     * @return length of identifier
      */
     public int getByteCount() {
-        String hexString = toHexString();
-        return hexString.length()/2;
+        return mValue.length;
     }
 
-    //TODO:  Add other conversion methods for UUID, int, etc for various identifier types
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(mValue);
+    }
 
+    /**
+     * Returns whether both Identifiers contain equal value. This is the case when the value is the same
+     * and has the same length
+     * @param that object to compare to
+     * @return whether that equals this
+     */
     @Override
     public boolean equals(Object that) {
         if (!(that instanceof Identifier)) {
             return false;
         }
         Identifier thatIdentifier = (Identifier) that;
-        return (this.mStringValue.equals(thatIdentifier.mStringValue));
-    }
-    private Identifier(String stringValue) {
-        if (stringValue != null) {
-            if (!formatValid(stringValue)) {
-                String formatProblem = null;
-                if (DECIMAL_PATTERN.matcher(stringValue).find()) {
-                    formatProblem = "Decimal identifiers must be between 0 and 65535";
-                }
-                else if (HEX_PATTERN.matcher(stringValue).find()) {
-                    if (stringValue.length() % 2 != 0) {
-                        formatProblem = "Hex identifier must have an even number of digits.";
-                    }
-                    else {
-                        formatProblem = "Hex identifier: "+stringValue+" is invalid";
-                    }
-                }
-                else {
-                    formatProblem = "Identifier: "+stringValue+"  must be a decimal number, a 16-byte UUID, or a hex number starting with 0x";
-                }
-                throw new NumberFormatException(formatProblem);
-
-            }
-            this.mStringValue = stringValue.toLowerCase();
-        }
-        else {
-            mStringValue = null;
-        }
+        return Arrays.equals(mValue, thatIdentifier.mValue);
     }
-    private static boolean isHex(String string) {
-        if (string.length() < 4) {
-            return false;
-        }
-        if (string.length() % 2 != 0) {
-            return false;
-        }
 
-        return HEX_PATTERN.matcher(string).find();
-    }
-    private static boolean isDecimal(String string) {
-        if (string.length() == 0) {
-            return false;
-        }
-        if (!DECIMAL_PATTERN.matcher(string).find()) {
-            return false;
-        }
-        if (Integer.parseInt(string) > 65535) {
-            return false;
-        }
-        return true;
-    }
-    private static boolean isUuid(String string) {
-        if (string.length() != 36) {
-            return false;
-        }
-        return UUID_PATTERN.matcher(string).find();
-    }
-    private static boolean formatValid(String string) {
-        return (isDecimal(string)|| isHex(string) || isUuid(string));
-    }
+    /**
+     * Represents the value as a hexadecimal String. The String is prefixed with <code>0x</code>. For example 0x0034ab
+     * @return value as hexadecimal String
+     */
     public String toHexString() {
-        if (isHex(mStringValue)) {
-            return mStringValue.substring(2);
-        }
-        if (isUuid(mStringValue)) {
-            return mStringValue.replaceAll("-", "");
+        StringBuilder sb = new StringBuilder(2 + 2 * mValue.length);
+        sb.append("0x");
+        for (byte item : mValue) {
+            sb.append(String.format("%02x", item));
         }
-        Integer i = Integer.parseInt(mStringValue);
-        return String.format("%04x", i);
+        return sb.toString();
     }
 
+    /**
+     * Returns the value of this Identifier in UUID format. For example 2f234454-cf6d-4a0f-adf2-f4911ba9ffa6
+     * @deprecated Replaced by stronger typed variant.
+     *    This mathod returns a string, therefore does not offer type safety on
+     *    the UUID per se. It was replaced by {@link #toUuid()}.
+     * @return value in UUID format
+     * @throws UnsupportedOperationException when value length is not 16 bytes
+     */
+    @Deprecated
+    public String toUuidString() {
+        return toUuid().toString();
+    }
 
-    private Identifier() {}
+    /**
+     * Gives you the Identifier as a UUID if possible.
+     *
+     * @throws UnsupportedOperationException if the byte array backing this Identifier is not exactly
+     *         16 bytes long.
+     */
+    public UUID toUuid() {
+        if (mValue.length != 16) {
+            throw new UnsupportedOperationException("Only Identifiers backed by a byte array with length of exactly 16 can be UUIDs.");
+        }
+        LongBuffer buf = ByteBuffer.wrap(mValue).asLongBuffer();
+        return new UUID(buf.get(), buf.get());
+    }
 
+    /**
+     * Gives you the byte array backing this Identifier. Note that Identifiers are immutable,
+     * so changing the the returned array will not result in a changed Identifier.
+     *
+     * @return a deep copy of the data backing this Identifier.
+     */
+    public byte[] toByteArray() {
+        return mValue.clone();
+    }
 
     /**
-     * Compares two identifiers
-     * @param that the other identifier
-     * @return 0 if both identifiers are equal.  Otherwise returns -1 or 1 depending on which is
-     * bigger than the other
+     * Compares two identifiers.
+     * When the Identifiers don't have the same length, the Identifier having the shortest
+     * array is considered smaller than the other.
+     *
+     * @param  that the other identifier
+     * @return      0 if both identifiers are equal.  Otherwise returns -1 or 1 depending
+     *              on which is bigger than the other.
+     * @see         Comparable#compareTo
      */
+    @Override
     public int compareTo(Identifier that) {
-        if (mStringValue == null &&  that.mStringValue == null) {
-            return 0;
+        if (mValue.length != that.mValue.length) {
+            return mValue.length < that.mValue.length ? -1 : 1;
+        }
+        for (int i = 0; i < mValue.length; i++) {
+            if (mValue[i] != that.mValue[i]) {
+                return mValue[i] < that.mValue[i] ? -1 : 1;
+            }
         }
-        return mStringValue.compareTo(that.mStringValue);
+        return 0;
     }
-
-
 }
diff --git a/src/main/java/org/altbeacon/beacon/Region.java b/src/main/java/org/altbeacon/beacon/Region.java
index 205b58d7..b69b2d74 100644
--- a/src/main/java/org/altbeacon/beacon/Region.java
+++ b/src/main/java/org/altbeacon/beacon/Region.java
@@ -25,7 +25,6 @@
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.util.Log;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -63,8 +62,8 @@ public Region createFromParcel(Parcel in) {
             return new Region[size];
         }
     };
-    protected List<Identifier> mIdentifiers;
-	protected String mUniqueId;
+    protected final List<Identifier> mIdentifiers;
+	protected final String mUniqueId;
 
 	/**
 	 * Constructs a new Region object to be used for Ranging or Monitoring
@@ -89,8 +88,8 @@ public Region(String uniqueId, Identifier id1, Identifier id2, Identifier id3) {
      * @param uniqueId - A unique identifier used to later cancel Ranging and Monitoring, or change the region being Ranged/Monitored
      * @param identifiers - list of identifiers for this region
      */
-    public Region(String uniqueId, ArrayList<Identifier> identifiers) {
-        this.mIdentifiers = new ArrayList<Identifier>(3);
+    public Region(String uniqueId, List<Identifier> identifiers) {
+        this.mIdentifiers = new ArrayList<Identifier>(identifiers);
         this.mUniqueId = uniqueId;
         if (uniqueId == null) {
             throw new NullPointerException("uniqueId may not be null");
@@ -102,7 +101,7 @@ public Region(String uniqueId, ArrayList<Identifier> identifiers) {
      * @return
      */
     public Identifier getId1() {
-        return mIdentifiers.get(0);
+        return getIdentifier(0);
     }
 
     /**
@@ -110,7 +109,7 @@ public Identifier getId1() {
      * @return
      */
     public Identifier getId2() {
-        return mIdentifiers.get(1);
+        return getIdentifier(1);
     }
 
     /**
@@ -118,7 +117,7 @@ public Identifier getId2() {
      * @return
      */
     public Identifier getId3() {
-        return mIdentifiers.get(2);
+        return getIdentifier(2);
     }
 
     /**
@@ -128,7 +127,7 @@ public Identifier getId3() {
      * @return
      */
     public Identifier getIdentifier(int i) {
-        return mIdentifiers.get(i);
+        return mIdentifiers.size() > i ? mIdentifiers.get(i) : null;
     }
 
     /**
@@ -150,7 +149,7 @@ public boolean matchesBeacon(Beacon beacon) {
         for (int i = 0; i < this.mIdentifiers.size(); i++) {
             if (beacon.getIdentifiers().size() <= i && mIdentifiers.get(i) == null) {
                 // If the beacon has fewer identifiers than the region, but the region's
-                // corresponding identifer is null, consider it a match
+                // corresponding identifier is null, consider it a match
             }
             else {
                 if (mIdentifiers.get(i) != null && !mIdentifiers.get(i).equals(beacon.mIdentifiers.get(i))) {
@@ -161,19 +160,20 @@ public boolean matchesBeacon(Beacon beacon) {
         return true;
 	}
 
-	@Override
-	public int hashCode() {
-		return this.mUniqueId.hashCode();
-	}
+    @Override
+    public int hashCode() {
+        return this.mUniqueId.hashCode();
+    }
 
-	public boolean equals(Object other) {
-		 if (other instanceof Region) {
-			return ((Region)other).mUniqueId.equals(this.mUniqueId);
-		 }
-		 return false;
-	}
-	
-	public String toString() {
+    @Override
+    public boolean equals(Object other) {
+        if (other instanceof Region) {
+            return ((Region)other).mUniqueId.equals(this.mUniqueId);
+        }
+        return false;
+    }
+
+    public String toString() {
         StringBuilder sb = new StringBuilder();
         int i = 1;
         for (Identifier identifier: mIdentifiers) {
@@ -207,18 +207,6 @@ public void writeToParcel(Parcel out, int flags) {
         }
     }
 
-    protected Region(Region otherRegion) {
-        super();
-        mIdentifiers = new ArrayList<Identifier>(otherRegion.mIdentifiers.size());
-        for (int i = 0; i < otherRegion.mIdentifiers.size(); i++) {
-            Identifier otherIdentifier = otherRegion.mIdentifiers.get(i);
-            mIdentifiers.add(otherIdentifier != null ? new Identifier(otherIdentifier) : null);
-        }
-        mUniqueId = otherRegion.mUniqueId;
-    }
-    
-    protected Region() {
-    }
 
     protected Region(Parcel in) {
         mUniqueId = in.readString();
@@ -234,9 +222,16 @@ protected Region(Parcel in) {
             }
         }
     }
+
+    /**
+     * Returns a clone of this instance.
+     * @deprecated instances of this class are immutable and therefore don't have to be cloned when
+     * used in concurrent code.
+     * @return a new instance of this class with the same uniqueId and identifiers
+     */
     @Override
-    public Object clone() {
-        return new Region(this);
+    @Deprecated
+    public Region clone() {
+        return new Region(mUniqueId, mIdentifiers);
     }
-
 }
diff --git a/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java b/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
index 3aec46e4..032fd97f 100644
--- a/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
+++ b/src/main/java/org/altbeacon/beacon/distance/AndroidModel.java
@@ -1,7 +1,8 @@
 package org.altbeacon.beacon.distance;
 
 import android.os.Build;
-import android.util.Log;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
 
 /**
  * Represents a specific Android device model based on the available device build information
@@ -86,7 +87,7 @@ public int matchScore(AndroidModel otherModel) {
         if (score == 3 && this.mVersion.equals(otherModel.mVersion)) {
             score = 4;
         }
-        Log.d(TAG, "Score is " + score + " for " + this + " compared to " + otherModel);
+        LogManager.d(TAG, "Score is %s for %s compared to %s", score, toString(), otherModel);
         return score;
     }
 
diff --git a/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java b/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
index e571f8c5..8cd4e417 100644
--- a/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
+++ b/src/main/java/org/altbeacon/beacon/distance/CurveFittedDistanceCalculator.java
@@ -1,6 +1,7 @@
 package org.altbeacon.beacon.distance;
 
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
 
 /**
  * This class estimates the distance between the mobile device and a BLE beacon based on the measured
@@ -47,7 +48,7 @@ public double calculateDistance(int txPower, double rssi) {
             return -1.0; // if we cannot determine accuracy, return -1.
         }
 
-        BeaconManager.logDebug(TAG, "calculating distance based on mRssi of " + rssi + " and txPower of " + txPower);
+        LogManager.d(TAG, "calculating distance based on mRssi of %s and txPower of %s", rssi, txPower);
 
 
         double ratio = rssi*1.0/txPower;
@@ -58,7 +59,7 @@ public double calculateDistance(int txPower, double rssi) {
         else {
             distance =  (mCoefficient1)*Math.pow(ratio,mCoefficient2) + mCoefficient3;
         }
-        BeaconManager.logDebug(TAG, " avg mRssi: "+rssi+" distance: "+distance);
+        LogManager.d(TAG, "avg mRssi: %s distance: %s", rssi, distance);
         return distance;
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/distance/DistanceConfigFetcher.java b/src/main/java/org/altbeacon/beacon/distance/DistanceConfigFetcher.java
index d6bf365f..4a57d5b1 100644
--- a/src/main/java/org/altbeacon/beacon/distance/DistanceConfigFetcher.java
+++ b/src/main/java/org/altbeacon/beacon/distance/DistanceConfigFetcher.java
@@ -1,9 +1,7 @@
 package org.altbeacon.beacon.distance;
 
-import android.util.Log;
+import org.altbeacon.beacon.logging.LogManager;
 
-import org.altbeacon.beacon.BeaconManager;
-import org.json.JSONObject;
 import java.io.BufferedReader;
 import java.io.FileNotFoundException;
 import java.io.InputStreamReader;
@@ -50,8 +48,8 @@ public void request() {
         HttpURLConnection conn = null;
         do {
             if (requestCount != 0) {
-                if (BeaconManager.debug)
-                    Log.d(TAG, "Following redirect from " + mUrlString + " to " + conn.getHeaderField("Location"));
+                LogManager.d(TAG, "Following redirect from %s to %s",
+                        mUrlString, conn.getHeaderField("Location"));
                 currentUrlString = conn.getHeaderField("Location");
             }
             requestCount++;
@@ -60,27 +58,26 @@ public void request() {
             try {
                 url = new URL(currentUrlString);
             } catch (Exception e) {
-                Log.e(TAG, "Can't construct URL from: " + mUrlString);
+                LogManager.e(TAG, "Can't construct URL from: %s", mUrlString);
                 mException = e;
 
             }
             if (url == null) {
-                if (BeaconManager.debug) Log.d(TAG, "URL is null.  Cannot make request");
+                LogManager.d(TAG, "URL is null.  Cannot make request");
             } else {
                 try {
                     conn = (HttpURLConnection) url.openConnection();
                     conn.addRequestProperty("User-Agent", mUserAgentString);
                     mResponseCode = conn.getResponseCode();
-                    if (BeaconManager.debug)
-                        Log.d(TAG, "response code is " + conn.getResponseCode());
+                    LogManager.d(TAG, "response code is %s", conn.getResponseCode());
                 } catch (SecurityException e1) {
-                    Log.w(TAG, "Can't reach sever.  Have you added android.permission.INTERNET to your manifest?", e1);
+                    LogManager.w(e1, TAG, "Can't reach sever.  Have you added android.permission.INTERNET to your manifest?");
                     mException = e1;
                 } catch (FileNotFoundException e2) {
-                    Log.w(TAG, "No data exists at \"+urlString", e2);
+                    LogManager.w(e2, TAG, "No data exists at \"+urlString");
                     mException = e2;
                 } catch (java.io.IOException e3) {
-                    Log.w(TAG, "Can't reach server", e3);
+                    LogManager.w(e3, TAG, "Can't reach server");
                     mException = e3;
                 }
             }
@@ -103,7 +100,7 @@ public void request() {
                 mResponse = responseBuilder.toString();
             } catch (Exception e) {
                 mException = e;
-                Log.w(TAG, "error reading beacon data", e);
+                LogManager.w(e, TAG, "error reading beacon data");
             }
         }
 
diff --git a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
index 1a817472..655d620a 100644
--- a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
+++ b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
@@ -5,9 +5,9 @@
 import android.content.pm.PackageManager;
 import android.os.AsyncTask;
 import android.os.Build;
-import android.util.Log;
 
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
 import org.json.JSONArray;
 import org.json.JSONException;
 import org.json.JSONObject;
@@ -15,6 +15,7 @@
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -89,19 +90,19 @@ public AndroidModel getRequestedModel() {
     @Override
     public double calculateDistance(int txPower, double rssi) {
         if (mDistanceCalculator == null) {
-            Log.w(TAG, "distance calculator has not been set");
+            LogManager.w(TAG, "distance calculator has not been set");
             return -1.0;
         }
         return mDistanceCalculator.calculateDistance(txPower, rssi);
     }
 
     private DistanceCalculator findCalculatorForModel(AndroidModel model) {
-        BeaconManager.logDebug(TAG, "Finding best distance calculator for "+model.getVersion()+","+
-                model.getBuildNumber()+","+model.getModel()+"," +
-                ""+model.getManufacturer());
+        LogManager.d(TAG, "Finding best distance calculator for %s, %s, %s, %s",
+                model.getVersion(), model.getBuildNumber(), model.getModel(),
+                model.getManufacturer());
 
         if (mModelMap == null) {
-            Log.d(TAG, "Cannot get distance calculator because modelMap was never initialized");
+            LogManager.d(TAG, "Cannot get distance calculator because modelMap was never initialized");
             return null;
         }
 
@@ -114,14 +115,14 @@ private DistanceCalculator findCalculatorForModel(AndroidModel model) {
             }
         }
         if (bestMatchingModel != null) {
-            BeaconManager.logDebug(TAG, "found a match with score "+highestScore);
-            BeaconManager.logDebug(TAG, "Finding best distance calculator for "+bestMatchingModel.getVersion()+","+
-                    bestMatchingModel.getBuildNumber()+","+bestMatchingModel.getModel()+"," +
-                    ""+bestMatchingModel.getManufacturer());
+            LogManager.d(TAG, "found a match with score %s", highestScore);
+            LogManager.d(TAG, "Finding best distance calculator for %s, %s, %s, %s",
+                    bestMatchingModel.getVersion(), bestMatchingModel.getBuildNumber(),
+                    bestMatchingModel.getModel(), bestMatchingModel.getManufacturer());
             mModel = bestMatchingModel;
         } else {
             mModel = mDefaultModel;
-            Log.w(TAG, "Cannot find match for this device.  Using default");
+            LogManager.w(TAG, "Cannot find match for this device.  Using default");
         }
         return mModelMap.get(mModel);
     }
@@ -151,13 +152,17 @@ private boolean loadModelMapFromFile() {
         try {
             inputStream = new FileInputStream(file);
             reader = new BufferedReader(new InputStreamReader(inputStream));
-            String line = null;
+            String line;
             while ((line = reader.readLine()) != null) {
                 sb.append(line).append("\n");
             }
         }
+        catch (FileNotFoundException fnfe){
+            //This occurs on the first time the app is run, no error message necessary.
+            return false;
+        }
         catch (IOException e) {
-            Log.w(TAG, "Cannot open distance model file "+file);
+            LogManager.e(e, TAG, "Cannot open distance model file %s", file);
             return false;
         }
         finally {
@@ -172,8 +177,8 @@ private boolean loadModelMapFromFile() {
             buildModelMap(sb.toString());
             return true;
         } catch (JSONException e) {
-            Log.w(TAG, "Cannot update distance models from online database at "+mRemoteUpdateUrlString+
-                    " with JSON of "+sb.toString()+" due to exception ", e);
+            LogManager.e(TAG, "Cannot update distance models from online database at %s with JSON",
+                    e, mRemoteUpdateUrlString, sb.toString());
             return false;
         }
     }
@@ -187,7 +192,7 @@ private boolean saveJson(String jsonString) {
             outputStream.write(jsonString.getBytes());
             outputStream.close();
         } catch (Exception e) {
-            Log.w(TAG, "Cannot write updated distance model to local storage", e);
+            LogManager.w(e, TAG, "Cannot write updated distance model to local storage");
             return false;
         }
         finally {
@@ -196,7 +201,7 @@ private boolean saveJson(String jsonString) {
             }
             catch (Exception e) {}
         }
-        Log.i(TAG, "Successfully saved new distance model file");
+        LogManager.i(TAG, "Successfully saved new distance model file");
         return true;
     }
 
@@ -204,7 +209,7 @@ private boolean saveJson(String jsonString) {
     private void requestModelMapFromWeb() {
 
         if (mContext.checkCallingOrSelfPermission("android.permission.INTERNET") != PackageManager.PERMISSION_GRANTED) {
-            Log.w(TAG, "App has no android.permission.INTERNET permission.  Cannot check for distance model updates");
+            LogManager.w(TAG, "App has no android.permission.INTERNET permission.  Cannot check for distance model updates");
             return;
         }
 
@@ -213,26 +218,26 @@ private void requestModelMapFromWeb() {
             @Override
             public void onComplete(String body, Exception ex, int code) {
                 if (ex != null) {
-                    Log.w(TAG, "Cannot updated distance models from online database at "+mRemoteUpdateUrlString+
-                            " due to exception: "+ex);
+                    LogManager.w(TAG, "Cannot updated distance models from online database at %s",
+                            ex, mRemoteUpdateUrlString);
                 }
                 else if (code != 200) {
-                    Log.w(TAG, "Cannot updated distance models from online database at "+mRemoteUpdateUrlString+
-                            " due to HTTP status code "+code);
+                    LogManager.w(TAG, "Cannot updated distance models from online database at %s "
+                            + "due to HTTP status code %s", mRemoteUpdateUrlString, code);
 
                 }
                 else {
-                    BeaconManager.logDebug(TAG,
+                    LogManager.d(TAG,
                             "Successfully downloaded distance models from online database");
                     try {
                         buildModelMap(body);
                         if (saveJson(body)) {
                             loadModelMapFromFile();
                             mDistanceCalculator = findCalculatorForModel(mRequestedModel);
-                            Log.i(TAG, "Successfully updated distance model with latest from online database");
+                            LogManager.i(TAG, "Successfully updated distance model with latest from online database");
                         }
                     } catch (JSONException e) {
-                        Log.w(TAG, "Cannot parse json from downloaded distance model",e);
+                        LogManager.w(e, TAG, "Cannot parse json from downloaded distance model");
                     }
                 }
             }
@@ -273,25 +278,38 @@ private void loadDefaultModelMap() {
             buildModelMap(stringFromFilePath(CONFIG_FILE));
         }
         catch (Exception e) {
-            Log.e(TAG, "Cannot build model distance calculations", e);
+            LogManager.e(e, TAG, "Cannot build model distance calculations");
         }
     }
 
     private String stringFromFilePath(String path) throws IOException {
-        InputStream stream = ModelSpecificDistanceCalculator.class.getResourceAsStream("/"+path);
-        if (stream == null) {
-            stream = this.getClass().getClassLoader().getResourceAsStream("/"+path);
-        }
+        InputStream stream = null;
+        BufferedReader bufferedReader = null;
+        StringBuilder inputStringBuilder = new StringBuilder();
+        try {
+            stream = ModelSpecificDistanceCalculator.class.getResourceAsStream("/"+path);
+            if (stream == null) {
+                stream = this.getClass().getClassLoader().getResourceAsStream("/"+path);
+            }
+
+            if (stream == null) {
+                throw new RuntimeException("Cannot load resource at "+path);
+            }
+            bufferedReader = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
+            String line = bufferedReader.readLine();
+            while(line != null){
+                inputStringBuilder.append(line);inputStringBuilder.append('\n');
+                line = bufferedReader.readLine();
+            }
 
-        if (stream == null) {
-            throw new RuntimeException("Cannot load resource at "+path);
         }
-        StringBuilder inputStringBuilder = new StringBuilder();
-        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(stream, "UTF-8"));
-        String line = bufferedReader.readLine();
-        while(line != null){
-            inputStringBuilder.append(line);inputStringBuilder.append('\n');
-            line = bufferedReader.readLine();
+        finally {
+            if (bufferedReader != null) {
+                bufferedReader.close();
+            }
+            if (stream != null) {
+                stream.close();
+            }
         }
         return inputStringBuilder.toString();
     }
diff --git a/src/main/java/org/altbeacon/beacon/logging/AbstractAndroidLogger.java b/src/main/java/org/altbeacon/beacon/logging/AbstractAndroidLogger.java
new file mode 100644
index 00000000..4515d96c
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/AbstractAndroidLogger.java
@@ -0,0 +1,8 @@
+package org.altbeacon.beacon.logging;
+
+abstract class AbstractAndroidLogger implements Logger {
+    protected String formatString(String message, Object... args) {
+        // If no varargs are supplied, treat it as a request to log the string without formatting.
+        return args.length == 0 ? message : String.format(message, args);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/EmptyLogger.java b/src/main/java/org/altbeacon/beacon/logging/EmptyLogger.java
new file mode 100644
index 00000000..33ec077f
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/EmptyLogger.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+/**
+ * A logger that doesn't do anything.
+ *
+ * @author Android Reitz
+ * @since 2.2
+ */
+final class EmptyLogger implements Logger {
+
+    @Override
+    public void v(String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void v(Throwable t, String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void d(String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void d(Throwable t, String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void i(String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void i(Throwable t, String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void w(String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void w(Throwable t, String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void e(String tag, String message, Object... args) {
+
+    }
+
+    @Override
+    public void e(Throwable t, String tag, String message, Object... args) {
+
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/LogManager.java b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
new file mode 100644
index 00000000..4500699e
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+/**
+ * Manager for logging in the Altbeacon library. The default is a
+ * {@link Loggers#warningLogger()} ()}.
+ *
+ * @author Andrew Reitz
+ * @since 2.2
+ */
+public final class LogManager {
+    private static Logger sLogger = Loggers.warningLogger();
+    private static boolean sVerboseLoggingEnabled = false;
+
+    /**
+     * Set the logger that the Altbeacon library will use to send it's log messages to.
+     *
+     * @param logger The logger implementation that logs will be sent to for logging.
+     * @throws java.lang.NullPointerException if logger is null.
+     * @see org.altbeacon.beacon.logging.Logger
+     * @see org.altbeacon.beacon.logging.Loggers
+     */
+    public static void setLogger(Logger logger) {
+        if (logger == null) {
+            throw new NullPointerException("Logger may not be null.");
+        }
+
+        sLogger = logger;
+    }
+
+    /**
+     * Gets the currently set logger
+     *
+     * @see org.altbeacon.beacon.logging.Logger
+     * @return logger
+     */
+    public static Logger getLogger() {
+        return sLogger;
+    }
+
+    /**
+     * Indicates whether verbose logging is enabled.   If not, expensive calculations to create
+     * log strings should be avoided.
+     * @return
+     */
+    public static boolean isVerboseLoggingEnabled() {
+        return sVerboseLoggingEnabled;
+    }
+
+    /**
+     * Sets whether verbose logging is enabled.  If not, expensive calculations to create
+     * log strings should be avoided.
+     *
+     * @param enabled
+     */
+    public static void setVerboseLoggingEnabled(boolean enabled) {
+        sVerboseLoggingEnabled = enabled;
+    }
+
+    /**
+     * Send a verbose log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     */
+    public static void v(String tag, String message, Object... args) {
+        sLogger.v(tag, message, args);
+    }
+
+    /**
+     * Send a verbose log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     */
+    public static void v(Throwable t, String tag, String message, Object... args) {
+        sLogger.v(t, tag, message, args);
+    }
+
+    /**
+     * Send a debug log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     */
+    public static void d(String tag, String message, Object... args) {
+        sLogger.d(tag, message, args);
+    }
+
+    /**
+     * Send a debug log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     */
+    public static void d(Throwable t, String tag, String message, Object... args) {
+        sLogger.d(t, tag, message, args);
+    }
+
+    /**
+     * Send a info log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     */
+    public static void i(String tag, String message, Object... args) {
+        sLogger.i(tag, message, args);
+    }
+
+    /**
+     * Send a info log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     */
+    public static void i(Throwable t, String tag, String message, Object... args) {
+        sLogger.i(t, tag, message, args);
+    }
+
+    /**
+     * Send a warning log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     */
+    public static void w(String tag, String message, Object... args) {
+        sLogger.w(tag, message, args);
+    }
+
+    /**
+     * Send a warning log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     */
+    public static void w(Throwable t, String tag, String message, Object... args) {
+        sLogger.w(t, tag, message, args);
+    }
+
+    /**
+     * Send a error log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     */
+    public static void e(String tag, String message, Object... args) {
+        sLogger.e(tag, message, args);
+    }
+
+    /**
+     * Send a error log message to the logger.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     */
+    public static void e(Throwable t, String tag, String message, Object... args) {
+        sLogger.e(t, tag, message, args);
+    }
+
+    private LogManager() {
+        // no instances
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/Logger.java b/src/main/java/org/altbeacon/beacon/logging/Logger.java
new file mode 100644
index 00000000..3322e049
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/Logger.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+/**
+ * Logging interface for logging messages in the android-beacon-library. To set a custom logger
+ * implement this interface and set it with {@link org.altbeacon.beacon.logging.LogManager#setLogger(Logger)}.
+ *
+ * @author Andrew Reitz
+ * @see org.altbeacon.beacon.logging.LogManager
+ * @since 2.2
+ */
+public interface Logger {
+    /**
+     * Send a verbose log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#v(String, String)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void v(String tag, String message, Object... args);
+
+    /**
+     * Send a verbose log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#v(String, String, Throwable)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void v(Throwable t, String tag, String message, Object... args);
+
+    /**
+     * Send a debug log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#d(String, String)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void d(String tag, String message, Object... args);
+
+    /**
+     * Send a debug log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#d(String, String, Throwable)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void d(Throwable t, String tag, String message, Object... args);
+
+    /**
+     * Send a info log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#i(String, String)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void i(String tag, String message, Object... args);
+
+    /**
+     * Send a info log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#i(String, String, Throwable)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void i(Throwable t, String tag, String message, Object... args);
+
+    /**
+     * Send a warning log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#w(String, String)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void w(String tag, String message, Object... args);
+
+    /**
+     * Send a warning log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#w(String, String, Throwable)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void w(Throwable t, String tag, String message, Object... args);
+
+    /**
+     * Send a error log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#e(String, String)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void e(String tag, String message, Object... args);
+
+    /**
+     * Send a error log message.
+     *
+     * @param tag     Used to identify the source of a log message.  It usually identifies
+     *                the class or activity where the log call occurs.
+     * @param message The message you would like logged. This message may contain string formatting
+     *                which will be replaced with values from args.
+     * @param t       An exception to log.
+     * @param args    Arguments for string formatting.
+     * @see android.util.Log#e(String, String, Throwable)
+     * @see java.util.Formatter
+     * @see String#format(String, Object...)
+     */
+    void e(Throwable t, String tag, String message, Object... args);
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/Loggers.java b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
new file mode 100644
index 00000000..44144026
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+/**
+ * Static factory methods for getting different {@link org.altbeacon.beacon.logging.Logger}
+ * implementations.
+ *
+ * @author Andrew Reitz
+ * @since 2.2
+ */
+public final class Loggers {
+    /** Empty Logger Singleton. */
+    private static final Logger EMPTY_LOGGER = new EmptyLogger();
+
+    /** Debug Logger Singleton. */
+    private static final Logger VERBOSE_ANDROID_LOGGER = new VerboseAndroidLogger();
+
+    /** Warning Logger Singleton. */
+    private static final Logger WARNING_ANDROID_LOGGER = new WarningAndroidLogger();
+
+    /**
+     * @return Get a logger that does nothing.
+     */
+    public static Logger empty() {
+        return EMPTY_LOGGER;
+    }
+
+    /**
+     * @return Get a logger that logs all messages to default Android logs.
+     * @see android.util.Log
+     */
+    public static Logger verboseLogger() {
+        return VERBOSE_ANDROID_LOGGER;
+    }
+
+    /**
+     * @return Get a logger that logs messages of warning and greater.
+     * @see android.util.Log
+     */
+    public static Logger warningLogger() {
+        return WARNING_ANDROID_LOGGER;
+    }
+
+    private Loggers() {
+        // No instances
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/VerboseAndroidLogger.java b/src/main/java/org/altbeacon/beacon/logging/VerboseAndroidLogger.java
new file mode 100644
index 00000000..f9014b0b
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/VerboseAndroidLogger.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import android.util.Log;
+
+/**
+ * Logger class that logs using the default Android logging mechanism. This class will log verbose
+ * messages and above (all logs).
+ *
+ * @author Android Reitz
+ * @since 2.2
+ */
+final class VerboseAndroidLogger extends AbstractAndroidLogger {
+
+    @Override
+    public void v(String tag, String message, Object... args) {
+        Log.v(tag, formatString(message, args));
+    }
+
+    @Override
+    public void v(Throwable t, String tag, String message, Object... args) {
+        Log.v(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void d(String tag, String message, Object... args) {
+        Log.d(tag, formatString(message, args));
+    }
+
+    @Override
+    public void d(Throwable t, String tag, String message, Object... args) {
+        Log.d(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void i(String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args));
+    }
+
+    @Override
+    public void i(Throwable t, String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void w(String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args));
+    }
+
+    @Override
+    public void w(Throwable t, String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void e(String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args));
+    }
+
+    @Override
+    public void e(Throwable t, String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args), t);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/WarningAndroidLogger.java b/src/main/java/org/altbeacon/beacon/logging/WarningAndroidLogger.java
new file mode 100644
index 00000000..130931f3
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/WarningAndroidLogger.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import android.util.Log;
+
+/**
+ * Android logger that only logs out warning and above to the {@link android.util.Log}.
+ *
+ * @since 2.2
+ * @author Andrew Reitz
+ */
+final class WarningAndroidLogger extends AbstractAndroidLogger {
+    @Override
+    public void v(String tag, String message, Object... args) { }
+
+    @Override
+    public void v(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void d(String tag, String message, Object... args) { }
+
+    @Override
+    public void d(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void i(String tag, String message, Object... args) { }
+
+    @Override
+    public void i(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void w(String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args));
+    }
+
+    @Override
+    public void w(Throwable t, String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void e(String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args));
+    }
+
+    @Override
+    public void e(Throwable t, String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args), t);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
index 3f5b2a5e..5db9a87c 100644
--- a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
+++ b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
@@ -5,10 +5,9 @@
 import android.app.Application;
 import android.content.Context;
 import android.os.Bundle;
-import android.util.Log;
 
-import org.altbeacon.beacon.BeaconConsumer;
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
 
 /**
  *
@@ -31,14 +30,14 @@
      */
     public BackgroundPowerSaver(Context context, boolean countActiveActivityStrategy) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "BackgroundPowerSaver requires SDK 18 or higher.");
+            LogManager.w(TAG, "BackgroundPowerSaver requires SDK 18 or higher.");
             return;
         }
         if (context instanceof Application ) {
             ((Application)context).registerActivityLifecycleCallbacks(this);
         }
         else {
-            Log.e(TAG, "Context is not an application instance, so we cannot use the BackgroundPowerSaver");
+            LogManager.e(TAG, "Context is not an application instance, so we cannot use the BackgroundPowerSaver");
         }
         beaconManager = beaconManager.getInstanceForApplication(context);
     }
@@ -65,19 +64,19 @@ public void onActivityStarted(Activity activity) {
     public void onActivityResumed(Activity activity) {
         activeActivityCount++;
         if (activeActivityCount < 1) {
-            BeaconManager.logDebug(TAG, "reset active activity count on resume.  It was "+activeActivityCount);
+            LogManager.d(TAG, "reset active activity count on resume.  It was %s", activeActivityCount);
             activeActivityCount = 1;
         }
         beaconManager.setBackgroundMode(false);
-        BeaconManager.logDebug(TAG, "activity resumed: "+activity+"  active activities: " + activeActivityCount);
+        LogManager.d(TAG, "activity resumed: %s active activities: %s", activity, activeActivityCount);
     }
 
     @Override
     public void onActivityPaused(Activity activity) {
         activeActivityCount--;
-        BeaconManager.logDebug(TAG, "activity paused: "+activity+"  active activities: " + activeActivityCount);
+        LogManager.d(TAG, "activity paused: %s active activities: %s", activity, activeActivityCount);
         if (activeActivityCount < 1) {
-            BeaconManager.logDebug(TAG, "setting background mode");
+            LogManager.d(TAG, "setting background mode");
             beaconManager.setBackgroundMode(true);
         }
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
new file mode 100644
index 00000000..f818790e
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
@@ -0,0 +1,56 @@
+package org.altbeacon.beacon.service;
+
+import org.altbeacon.beacon.logging.LogManager;
+
+/**
+ * This filter calculates its rssi on base of an auto regressive moving average (ARMA)
+ * It needs only the current value to do this; the general formula is  n(t) = n(t-1) - c * (n(t-1) - n(t))
+ * where c is a coefficient, that denotes the smoothness - the lower the value, the smoother the average
+ * Note: a smoother average needs longer to "settle down"
+ * Note: For signals, that change rather frequently (say, 1Hz or faster) and tend to vary more a recommended
+ *       value would be 0,1 (that means the actual value is changed by 10% of the difference between the
+ *       actual measurement and the actual average)
+ *       For signals at lower rates (10Hz) a value of 0.25 to 0.5 would be appropriate
+ */
+public class ArmaRssiFilter implements RssiFilter {
+
+    private static double DEFAULT_ARMA_SPEED = 0.1;     //How likely is it that the RSSI value changes?
+                                                        //Note: the more unlikely, the higher can that value be
+                                                        //      also, the lower the (expected) sending frequency,
+                                                        //      the higher should that value be
+
+    private static final String TAG = "ArmaRssiFilter";
+    //initially set to min value
+    private int armaMeasurement;
+    private double armaSpeed = 0.1;
+    private boolean isInitialized = false;
+
+    public ArmaRssiFilter() {
+        this.armaSpeed = DEFAULT_ARMA_SPEED;
+    }
+
+	public void addMeasurement(Integer rssi) {
+        LogManager.d(TAG, "adding rssi: %s", rssi);
+        //use first measurement as initialization
+        if (!isInitialized) {
+            armaMeasurement = rssi;
+            isInitialized = true;
+        };
+        armaMeasurement = Double.valueOf(armaMeasurement - armaSpeed * (armaMeasurement - rssi)).intValue();
+        LogManager.d(TAG, "armaMeasurement: %s", armaMeasurement);
+	}
+
+	public boolean noMeasurementsAvailable() {
+        return false;
+	}
+
+	public double calculateRssi() {
+		return armaMeasurement;
+
+	}
+
+    public static void setDEFAULT_ARMA_SPEED(double default_arma_speed) {
+        DEFAULT_ARMA_SPEED = default_arma_speed;
+    }
+	
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 8d61799e..f1a10b4f 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -36,17 +36,18 @@
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
-import android.util.Log;
+
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.BuildConfig;
+import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.distance.DistanceCalculator;
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
+import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.altbeacon.beacon.service.scanner.CycledLeScanner;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
-import org.altbeacon.beacon.BuildConfig;
-import org.altbeacon.beacon.Region;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
@@ -56,7 +57,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Executor;
+import java.util.concurrent.RejectedExecutionException;
 
 /**
  * @author dyoung
@@ -109,7 +110,7 @@
      */
     public class BeaconBinder extends Binder {
         public BeaconService getService() {
-            Log.i(TAG, "getService of BeaconBinder called");
+            LogManager.i(TAG, "getService of BeaconBinder called");
             // Return this instance of LocalService so clients can call public methods
             return BeaconService.this;
         }
@@ -139,27 +140,27 @@ public void handleMessage(Message msg) {
             if (service != null) {
                 switch (msg.what) {
                     case MSG_START_RANGING:
-                        Log.i(TAG, "start ranging received");
+                        LogManager.i(TAG, "start ranging received");
                         service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
                         service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
                         break;
                     case MSG_STOP_RANGING:
-                        Log.i(TAG, "stop ranging received");
+                        LogManager.i(TAG, "stop ranging received");
                         service.stopRangingBeaconsInRegion(startRMData.getRegionData());
                         service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
                         break;
                     case MSG_START_MONITORING:
-                        Log.i(TAG, "start monitoring received");
+                        LogManager.i(TAG, "start monitoring received");
                         service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
                         service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
                         break;
                     case MSG_STOP_MONITORING:
-                        Log.i(TAG, "stop monitoring received");
+                        LogManager.i(TAG, "stop monitoring received");
                         service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
                         service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
                         break;
                     case MSG_SET_SCAN_PERIODS:
-                        Log.i(TAG, "set scan intervals received");
+                        LogManager.i(TAG, "set scan intervals received");
                         service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
                         break;
                     default:
@@ -180,14 +181,14 @@ public void handleMessage(Message msg) {
      */
     @Override
     public IBinder onBind(Intent intent) {
-        Log.i(TAG, "binding");
+        LogManager.i(TAG, "binding");
         bindCount++;
         return mMessenger.getBinder();
     }
 
     @Override
     public boolean onUnbind(Intent intent) {
-        Log.i(TAG, "unbinding");
+        LogManager.i(TAG, "unbinding");
         bindCount--;
         return false;
     }
@@ -195,7 +196,7 @@ public boolean onUnbind(Intent intent) {
 
     @Override
     public void onCreate() {
-        Log.i(TAG, "beaconService version " + BuildConfig.VERSION_NAME + " is starting up");
+        LogManager.i(TAG, "beaconService version %s is starting up", BuildConfig.VERSION_NAME );
         bluetoothCrashResolver = new BluetoothCrashResolver(this);
         bluetoothCrashResolver.start();
         mCycledScanner = CycledLeScanner.createScanner(this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
@@ -211,9 +212,9 @@ public void onCreate() {
             java.lang.reflect.Field f = klass.getField("beacons");
             this.simulatedScanData = (List<Beacon>) f.get(null);
         } catch (ClassNotFoundException e) {
-            BeaconManager.logDebug(TAG, "No org.altbeacon.beacon.SimulatedScanData class exists.");
+            LogManager.d(TAG, "No org.altbeacon.beacon.SimulatedScanData class exists.");
         } catch (Exception e) {
-            Log.e(TAG, "Cannot get simulated Scan data.  Make sure your org.altbeacon.beacon.SimulatedScanData class defines a field with the signature 'public static List<Beacon> beacons'", e);
+            LogManager.e(e, TAG, "Cannot get simulated Scan data.  Make sure your org.altbeacon.beacon.SimulatedScanData class defines a field with the signature 'public static List<Beacon> beacons'");
         }
     }
 
@@ -221,11 +222,11 @@ public void onCreate() {
     @TargetApi(18)
     public void onDestroy() {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to API 18.");
+            LogManager.w(TAG, "Not supported prior to API 18.");
             return;
         }
         bluetoothCrashResolver.stop();
-        Log.i(TAG, "onDestroy called.  stopping scanning");
+        LogManager.i(TAG, "onDestroy called.  stopping scanning");
         handler.removeCallbacksAndMessages(null);
         mCycledScanner.stop();
     }
@@ -237,11 +238,11 @@ public void onDestroy() {
     public void startRangingBeaconsInRegion(Region region, Callback callback) {
         synchronized (rangedRegionState) {
             if (rangedRegionState.containsKey(region)) {
-                Log.i(TAG, "Already ranging that region -- will replace existing region.");
+                LogManager.i(TAG, "Already ranging that region -- will replace existing region.");
                 rangedRegionState.remove(region); // need to remove it, otherwise the old object will be retained because they are .equal
             }
             rangedRegionState.put(region, new RangeState(callback));
-            BeaconManager.logDebug(TAG, "Currently ranging " + rangedRegionState.size() + " regions.");
+            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
         }
         if (!scanningEnabled) {
             mCycledScanner.start();
@@ -253,7 +254,7 @@ public void stopRangingBeaconsInRegion(Region region) {
         synchronized (rangedRegionState) {
             rangedRegionState.remove(region);
             rangedRegionCount = rangedRegionState.size();
-            BeaconManager.logDebug(TAG, "Currently ranging " + rangedRegionState.size() + " regions.");
+            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
         }
 
         if (scanningEnabled && rangedRegionCount == 0 && monitoredRegionState.size() == 0) {
@@ -262,15 +263,15 @@ public void stopRangingBeaconsInRegion(Region region) {
     }
 
     public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
-        BeaconManager.logDebug(TAG, "startMonitoring called");
+        LogManager.d(TAG, "startMonitoring called");
         synchronized (monitoredRegionState) {
             if (monitoredRegionState.containsKey(region)) {
-                Log.i(TAG, "Already monitoring that region -- will replace existing region monitor.");
+                LogManager.i(TAG, "Already monitoring that region -- will replace existing region monitor.");
                 monitoredRegionState.remove(region); // need to remove it, otherwise the old object will be retained because they are .equal
             }
             monitoredRegionState.put(region, new MonitorState(callback));
         }
-        BeaconManager.logDebug(TAG, "Currently monitoring " + monitoredRegionState.size() + " regions.");
+        LogManager.d(TAG, "Currently monitoring %s regions.", monitoredRegionState.size());
         if (!scanningEnabled) {
             mCycledScanner.start();
         }
@@ -278,12 +279,12 @@ public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
 
     public void stopMonitoringBeaconsInRegion(Region region) {
         int monitoredRegionCount;
-        BeaconManager.logDebug(TAG, "stopMonitoring called");
+        LogManager.d(TAG, "stopMonitoring called");
         synchronized (monitoredRegionState) {
             monitoredRegionState.remove(region);
             monitoredRegionCount = monitoredRegionState.size();
         }
-        BeaconManager.logDebug(TAG, "Currently monitoring " + monitoredRegionState.size() + " regions.");
+        LogManager.d(TAG, "Currently monitoring %s regions.", monitoredRegionState.size());
         if (scanningEnabled && monitoredRegionCount == 0 && monitoredRegionState.size() == 0) {
             mCycledScanner.stop();
         }
@@ -297,8 +298,13 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
         @TargetApi(Build.VERSION_CODES.HONEYCOMB)
         @Override
         public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
-            new ScanProcessor().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,
-                    new ScanData(device, rssi, scanRecord));
+            try {
+                new ScanProcessor().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,
+                        new ScanData(device, rssi, scanRecord));
+            }
+            catch (RejectedExecutionException e) {
+                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+            }
         }
 
         @Override
@@ -309,14 +315,14 @@ public void onCycleEnd() {
             if (simulatedScanData != null) {
                 // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
                 // it will not be used if we are not in debug mode
-                Log.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
+                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
 
                 if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
                     for (Beacon beacon : simulatedScanData) {
                         processBeaconFromScan(beacon);
                     }
                 } else {
-                    Log.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
+                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
                 }
             }
             if (BeaconManager.getBeaconSimulator() != null) {
@@ -328,10 +334,10 @@ public void onCycleEnd() {
                             processBeaconFromScan(beacon);
                         }
                     } else {
-                        Log.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
                     }
                 } else {
-                    Log.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
                 }
             }
         }
@@ -343,7 +349,7 @@ private void processRangeData() {
             while (regionIterator.hasNext()) {
                 Region region = regionIterator.next();
                 RangeState rangeState = rangedRegionState.get(region);
-                BeaconManager.logDebug(TAG, "Calling ranging callback");
+                LogManager.d(TAG, "Calling ranging callback");
                 rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region));
             }
         }
@@ -356,7 +362,7 @@ private void processExpiredMonitors() {
                 Region region = monitoredRegionIterator.next();
                 MonitorState state = monitoredRegionState.get(region);
                 if (state.isNewlyOutside()) {
-                    BeaconManager.logDebug(TAG, "found a monitor that expired: " + region);
+                    LogManager.d(TAG, "found a monitor that expired: %s", region);
                     state.getCallback().call(BeaconService.this, "monitoringData", new MonitoringData(state.isInside(), region));
                 }
             }
@@ -365,19 +371,19 @@ private void processExpiredMonitors() {
 
     private void processBeaconFromScan(Beacon beacon) {
         if (trackedBeacons == null){
-            trackedBeacons = new HashSet();
+            trackedBeacons = new HashSet<>();
         }
         if (Stats.getInstance().isEnabled()) {
             Stats.getInstance().log(beacon);
         }
         trackedBeaconsPacketCount++;
         if (trackedBeacons.contains(beacon)) {
-            BeaconManager.logDebug(TAG,
-                    "beacon detected multiple times in scan cycle :" + beacon.toString());
+            LogManager.d(TAG,
+                    "beacon detected multiple times in scan cycle : %s", beacon.toString());
         }
         trackedBeacons.add(beacon);
-        BeaconManager.logDebug(TAG,
-                "beacon detected :" + beacon.toString());
+        LogManager.d(TAG,
+                "beacon detected : %s", beacon.toString());
 
         List<Region> matchedRegions = null;
         synchronized(monitoredRegionState) {
@@ -388,21 +394,23 @@ private void processBeaconFromScan(Beacon beacon) {
         while (matchedRegionIterator.hasNext()) {
             Region region = matchedRegionIterator.next();
             MonitorState state = monitoredRegionState.get(region);
-            if (state.markInside()) {
+            if (state != null && state.markInside()) {
                 state.getCallback().call(BeaconService.this, "monitoringData",
                         new MonitoringData(state.isInside(), region));
             }
         }
 
-        BeaconManager.logDebug(TAG, "looking for ranging region matches for this beacon");
+        LogManager.d(TAG, "looking for ranging region matches for this beacon");
         synchronized (rangedRegionState) {
             matchedRegions = matchingRegions(beacon, rangedRegionState.keySet());
             matchedRegionIterator = matchedRegions.iterator();
             while (matchedRegionIterator.hasNext()) {
                 Region region = matchedRegionIterator.next();
-                BeaconManager.logDebug(TAG, "matches ranging region: " + region);
+                LogManager.d(TAG, "matches ranging region: %s", region);
                 RangeState rangeState = rangedRegionState.get(region);
-                rangeState.addBeacon(beacon);
+                if (rangeState != null) {
+                    rangeState.addBeacon(beacon);
+                }
             }
         }
     }
@@ -462,7 +470,7 @@ protected void onProgressUpdate(Void... values) {
                 if (region.matchesBeacon(beacon)) {
                     matched.add(region);
                 } else {
-                    BeaconManager.logDebug(TAG, "This region ("+region+") does not match beacon: " + beacon);
+                    LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
                 }
 
             }
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index 7122deea..a3beb07c 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -26,13 +26,12 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Messenger;
 import android.os.Parcelable;
-import android.util.Log;
+
+import org.altbeacon.beacon.logging.LogManager;
 
 public class Callback {
-	private String TAG = "Callback";
-	private Messenger messenger;
+	private static final String TAG = "Callback";
 	private Intent intent;
 	public Callback(String intentPackageName) {
 		if (intentPackageName != null) {
@@ -56,7 +55,7 @@ public void setIntent(Intent intent) {
 	 */
 	public boolean call(Context context, String dataName, Parcelable data) {
 		if (intent != null) {
-			Log.d(TAG, "attempting callback via intent: "+intent.getComponent());
+			LogManager.d(TAG, "attempting callback via intent: %s", intent.getComponent());
 			intent.putExtra(dataName, data);
 			context.startService(intent);		
 			return true;			
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitorState.java b/src/main/java/org/altbeacon/beacon/service/MonitorState.java
index 5dabe863..5d9df8aa 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitorState.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitorState.java
@@ -25,7 +25,7 @@
 
 import java.util.Date;
 
-import android.util.Log;
+import org.altbeacon.beacon.logging.LogManager;
 
 public class MonitorState {
 	private static final String TAG = "MonitorState";
@@ -44,7 +44,7 @@ public Callback getCallback() {
 
 	// returns true if it is newly inside 
 	public boolean markInside() {
-		lastSeenTime = (new Date()).getTime();
+		lastSeenTime = System.currentTimeMillis();
 		if (!inside) {
 			inside = true;
 			return true;
@@ -55,7 +55,10 @@ public boolean isNewlyOutside() {
 		if (inside) {
 			if (lastSeenTime > 0 && (new Date()).getTime() - lastSeenTime > INSIDE_EXPIRATION_MILLIS) {
 				inside = false;
-				Log.d(TAG, "We are newly outside the region because the lastSeenTime of "+lastSeenTime+" was "+((new Date()).getTime() - lastSeenTime)+" seconds ago, and that is over the expiration duration of  "+INSIDE_EXPIRATION_MILLIS);
+				LogManager.d(TAG, "We are newly outside the region because the lastSeenTime of %s "
+                                + "was %s seconds ago, and that is over the expiration duration "
+                                + "of %s", lastSeenTime, System.currentTimeMillis() - lastSeenTime,
+                        INSIDE_EXPIRATION_MILLIS);
 				lastSeenTime = 0l;
 				return true;
 			}			
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index 7a86a1a0..c0d4bb5e 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -23,21 +23,19 @@
  */
 package org.altbeacon.beacon.service;
 
-import android.util.Log;
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.logging.LogManager;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
-
-import org.altbeacon.beacon.Beacon;
-import org.altbeacon.beacon.BeaconManager;
-
 public class RangeState {
     private static final String TAG = "RangeState";
 	private Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
+    private static boolean UseTrackingCache = false;
 
 	public RangeState(Callback c) {
 		mCallback = c;
@@ -47,15 +45,14 @@ public Callback getCallback() {
 		return mCallback;
 	}
 
-
     public void addBeacon(Beacon beacon) {
         if (mRangedBeacons.containsKey(beacon)) {
             RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
-            BeaconManager.logDebug(TAG, "adding " + beacon.toString() + " to existing range for: " + rangedBeacon.toString());
+            LogManager.d(TAG, "adding %s to existing range for: %s", beacon, rangedBeacon);
             rangedBeacon.updateBeacon(beacon);
         }
         else {
-            BeaconManager.logDebug(TAG, "adding "+ beacon.toString()+" to new rangedBeacon");
+            LogManager.d(TAG, "adding %s to new rangedBeacon", beacon);
             mRangedBeacons.put(beacon, new RangedBeacon(beacon));
         }
     }
@@ -78,11 +75,14 @@ public void addBeacon(Beacon beacon) {
                 // If we still have useful measurements, keep it around but mark it as not
                 // tracked anymore so we don't pass it on as visible unless it is seen again
                 if (!rangedBeacon.noMeasurementsAvailable() == true) {
-                    rangedBeacon.setTracked(false);
+                    //if TrackingCache is enabled, allow beacon to not receive
+                    //measurements for a certain amount of time
+                    if (!UseTrackingCache || rangedBeacon.isExpired())
+                        rangedBeacon.setTracked(false);
                     newRangedBeacons.put(beacon, rangedBeacon);
                 }
                 else {
-                    BeaconManager.logDebug(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
+                    LogManager.d(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
                 }
             }
             mRangedBeacons = newRangedBeacons;
@@ -91,7 +91,9 @@ public void addBeacon(Beacon beacon) {
         return finalizedBeacons;
     }
 
-
+    public static void setUseTrackingCache(boolean useTrackingCache) {
+        RangeState.UseTrackingCache = useTrackingCache;
+    }
 
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index 7d67916a..3b6bc6a2 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -1,26 +1,35 @@
 package org.altbeacon.beacon.service;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.Iterator;
-
-
-import android.util.Log;
-
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.lang.reflect.Constructor;
 
 public class RangedBeacon {
-	private static String TAG = "RangedBeacon";
-	public static long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
-	private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
+
+    private static final String TAG = "RangedBeacon";
+    public static long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
+    public static long maxTrackingAge = DEFAULT_MAX_TRACKING_AGE; /* 5 Seconds */
+    //kept here for backward compatibility
+    public static long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
+    private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
     private boolean mTracked = true;
-    private ArrayList<Measurement> mMeasurements = new ArrayList<Measurement>();
+    protected long lastTrackedTimeMillis = 0;
     Beacon mBeacon;
+    protected RssiFilter filter = null;
 
 	public RangedBeacon(Beacon beacon) {
-		updateBeacon(beacon);
+        //set RSSI filter
+        try {
+            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
+            filter = (RssiFilter)cons.newInstance();
+            if ((filter != null) && (filter instanceof RunningAverageRssiFilter))
+                ((RunningAverageRssiFilter)filter).setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
+        } catch (Exception e) {
+            LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
+        }
+        updateBeacon(beacon);
 	}
 
     public void updateBeacon(Beacon beacon) {
@@ -42,74 +51,41 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-        if (mMeasurements.size() > 0) {
-            double runningAverage = calculateRunningAverage();
+        if (!filter.noMeasurementsAvailable()) {
+            double runningAverage = filter.calculateRssi();
             mBeacon.setRunningAverageRssi(runningAverage);
-            BeaconManager.logDebug(TAG, "calculated new runningAverageRssi:"+ runningAverage);
+            LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
         else {
-            BeaconManager.logDebug(TAG, "No measurements available to calculate running average");
+            LogManager.d(TAG, "No measurements available to calculate running average");
         }
     }
 
-	public static void setSampleExpirationMilliseconds(long milliseconds) {
-		sampleExpirationMilliseconds = milliseconds;
-	}
 	public void addMeasurement(Integer rssi) {
-            mTracked = true;
-			Measurement measurement = new Measurement();
-			measurement.rssi = rssi;
-			measurement.timestamp = new Date().getTime();
-			mMeasurements.add(measurement);
+        mTracked = true;
+        lastTrackedTimeMillis = System.currentTimeMillis();
+        filter.addMeasurement(rssi);
 	}
 
-	public boolean noMeasurementsAvailable() {
-		return mMeasurements.size() == 0;
-	}
+    //kept here for backward compatibility
+    public static void setSampleExpirationMilliseconds(long milliseconds) {
+        sampleExpirationMilliseconds = milliseconds;
+    }
 
-	private class Measurement implements Comparable<Measurement> {
-		Integer rssi;
-		long timestamp;
-		@Override
-		public int compareTo(Measurement arg0) {			
-			return rssi.compareTo(arg0.rssi);
-		}
-	}	
-	
-	private synchronized void refreshMeasurements() {
-		Date now = new Date();
-		ArrayList<Measurement> newMeasurements = new ArrayList<Measurement>();
-		Iterator<Measurement> iterator = mMeasurements.iterator();
-		while (iterator.hasNext()) {
-			Measurement measurement = iterator.next();
-			if (now.getTime() - measurement.timestamp < sampleExpirationMilliseconds ) {
-				newMeasurements.add(measurement);
-			}
-		}
-		mMeasurements = newMeasurements;
-		Collections.sort(mMeasurements);
-	}
-	
-	private double calculateRunningAverage() {
-		refreshMeasurements();
-		int size = mMeasurements.size();
-		int startIndex = 0;
-		int endIndex = size -1;
-		if (size > 2) {
-			startIndex = size/10+1;
-			endIndex = size-size/10-2;
-		}
-
-		double sum = 0;
-		for (int i = startIndex; i <= endIndex; i++) {
-			sum += mMeasurements.get(i).rssi;
-		}
-		double runningAverage = sum/(endIndex-startIndex+1);
-
-		BeaconManager.logDebug(TAG, "Running average mRssi based on "+size+" measurements: "+runningAverage);
-		return runningAverage;
+    public static void setMaxTrackinAge(int maxTrackinAge) {
+        RangedBeacon.maxTrackingAge = maxTrackinAge;
+    }
 
-	}
-	
+    public boolean noMeasurementsAvailable() {
+        return filter.noMeasurementsAvailable();
+    }
+
+    public long getTrackingAge() {
+        return System.currentTimeMillis() - lastTrackedTimeMillis;
+    }
 	
+    public boolean isExpired() {
+        return getTrackingAge() > maxTrackingAge;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangingData.java b/src/main/java/org/altbeacon/beacon/service/RangingData.java
index 883b6792..58135d33 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -29,10 +29,10 @@
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
 
 import android.os.Parcel;
 import android.os.Parcelable;
-import android.util.Log;
 
 public class RangingData implements Parcelable {
 	private static final String TAG = "RangingData";
@@ -58,10 +58,10 @@ public int describeContents() {
 		return 0;
 	}
     public void writeToParcel(Parcel out, int flags) {    
-    	BeaconManager.logDebug(TAG, "writing RangingData");
+    	LogManager.d(TAG, "writing RangingData");
     	out.writeParcelableArray(beacons.toArray(new Parcelable[0]), flags);
     	out.writeParcelable(region, flags);
-    	BeaconManager.logDebug(TAG, "done writing RangingData");
+        LogManager.d(TAG, "done writing RangingData");
 
     }
 
@@ -77,7 +77,7 @@ public RangingData createFromParcel(Parcel in) {
     };
     
     private RangingData(Parcel in) {
-    	BeaconManager.logDebug(TAG, "parsing RangingData");
+        LogManager.d(TAG, "parsing RangingData");
     	Parcelable[] parcelables  = in.readParcelableArray(this.getClass().getClassLoader());
     	beacons = new ArrayList<Beacon>(parcelables.length);
     	for (int i = 0; i < parcelables.length; i++) {
diff --git a/src/main/java/org/altbeacon/beacon/service/RssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
new file mode 100644
index 00000000..57a587e8
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
@@ -0,0 +1,13 @@
+package org.altbeacon.beacon.service;
+
+/**
+ * Interface that can be implemented to overwrite measurement and filtering
+ * of RSSI values
+ */
+public interface RssiFilter {
+
+    public void addMeasurement(Integer rssi);
+    public boolean noMeasurementsAvailable();
+    public double calculateRssi();
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
new file mode 100644
index 00000000..ccffdd3e
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
@@ -0,0 +1,84 @@
+package org.altbeacon.beacon.service;
+
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.Iterator;
+
+/**
+ * Calculate a RSSI value on base of an arbitrary list of measured RSSI values
+ * The list is clipped by a certain length at start and end and the average
+ * is calculate by simple arithmetic average
+ */
+public class RunningAverageRssiFilter implements RssiFilter {
+
+    private static final String TAG = "RunningAverageRssiFilter";
+    public static long DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS = 20000; /* 20 seconds */
+    private static long sampleExpirationMilliseconds = DEFAULT_SAMPLE_EXPIRATION_MILLISECONDS;
+    private ArrayList<Measurement> mMeasurements = new ArrayList<Measurement>();
+
+    @Override
+    public void addMeasurement(Integer rssi) {
+        Measurement measurement = new Measurement();
+        measurement.rssi = rssi;
+        measurement.timestamp = new Date().getTime();
+        mMeasurements.add(measurement);
+    }
+
+    @Override
+    public boolean noMeasurementsAvailable() {
+        return mMeasurements.size() == 0;
+    }
+
+    @Override
+    public double calculateRssi() {
+        refreshMeasurements();
+        int size = mMeasurements.size();
+        int startIndex = 0;
+        int endIndex = size -1;
+        if (size > 2) {
+            startIndex = size/10+1;
+            endIndex = size-size/10-2;
+        }
+
+        double sum = 0;
+        for (int i = startIndex; i <= endIndex; i++) {
+            sum += mMeasurements.get(i).rssi;
+        }
+        double runningAverage = sum/(endIndex-startIndex+1);
+
+        LogManager.d(TAG, "Running average mRssi based on %s measurements: %s",
+                size, runningAverage);
+        return runningAverage;
+    }
+
+    private synchronized void refreshMeasurements() {
+        Date now = new Date();
+        ArrayList<Measurement> newMeasurements = new ArrayList<Measurement>();
+        Iterator<Measurement> iterator = mMeasurements.iterator();
+        while (iterator.hasNext()) {
+            Measurement measurement = iterator.next();
+            if (now.getTime() - measurement.timestamp < sampleExpirationMilliseconds ) {
+                newMeasurements.add(measurement);
+            }
+        }
+        mMeasurements = newMeasurements;
+        Collections.sort(mMeasurements);
+    }
+
+    private class Measurement implements Comparable<Measurement> {
+        Integer rssi;
+        long timestamp;
+        @Override
+        public int compareTo(Measurement arg0) {
+            return rssi.compareTo(arg0.rssi);
+        }
+    }
+
+    public static void setSampleExpirationMilliseconds(long newSampleExpirationMilliseconds) {
+        sampleExpirationMilliseconds = newSampleExpirationMilliseconds;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/Stats.java b/src/main/java/org/altbeacon/beacon/service/Stats.java
index 4be83ecf..94f5266f 100644
--- a/src/main/java/org/altbeacon/beacon/service/Stats.java
+++ b/src/main/java/org/altbeacon/beacon/service/Stats.java
@@ -1,8 +1,7 @@
 package org.altbeacon.beacon.service;
 
-import android.util.Log;
-
 import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.logging.LogManager;
 
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
@@ -13,7 +12,8 @@
  * Created by dyoung on 10/16/14.
  */
 public class Stats {
-    private static final SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss.SSS");
+    private static final String TAG = "Stats";
+    private static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat("HH:mm:ss.SSS");
 
     private ArrayList<Sample> mSamples;
     private long mSampleIntervalMillis;
@@ -21,7 +21,6 @@
     private boolean mEnableHistoricalLogging;
     private boolean mEnabled;
     private Sample mSample;
-    private static final String TAG = "Stats";
     private static Stats mInstance;
 
     public static Stats getInstance() {
@@ -96,18 +95,21 @@ public void clearSamples() {
 
     private void logSample(Sample sample, boolean showHeader) {
         if (showHeader) {
-            Log.d(TAG, "sample start time, sample stop time, first detection"+
+            LogManager.d(TAG, "sample start time, sample stop time, first detection" +
                     " time, last detection time, max millis between detections, detection count");
         }
-        Log.d(TAG, formattedDate(sample.sampleStartTime)+","+formattedDate(sample.sampleStopTime)+
-                ", "+formattedDate(sample.firstDetectionTime)+", "+formattedDate(sample.lastDetectionTime)+", "+
-                sample.maxMillisBetweenDetections+", "+sample.detectionCount );
+        LogManager.d(TAG, "%s, %s, %s, %s, %s, %s",
+                formattedDate(sample.sampleStartTime), formattedDate(sample.sampleStopTime),
+                formattedDate(sample.firstDetectionTime), formattedDate(sample.lastDetectionTime),
+                sample.maxMillisBetweenDetections, sample.detectionCount);
     }
+
     private String formattedDate(Date d) {
-        return d == null ? "" : sdf.format(d);
+        return d == null ? "" : SIMPLE_DATE_FORMAT.format(d);
     }
+
     private void logSamples() {
-        Log.d(TAG, "--- Stats for "+mSamples.size()+" samples");
+        LogManager.d(TAG, "--- Stats for %s samples", mSamples.size());
         boolean firstPass = true;
         for (Sample sample : mSamples) {
             logSample(sample, firstPass);
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 2ab1f470..41db29a5 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -12,6 +12,7 @@
 import android.util.Log;
 
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
@@ -55,19 +56,19 @@ protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeri
     public static CycledLeScanner createScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
         boolean useAndroidLScanner;
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not supported prior to API 18.");
+            LogManager.w(TAG, "Not supported prior to API 18.");
             return null;
         }
 
         if (android.os.Build.VERSION.SDK_INT < 21) {
-            Log.i(TAG, "This is not Android 5.0.  We are using old scanning APIs");
+            LogManager.i(TAG, "This is not Android 5.0.  We are using old scanning APIs");
             useAndroidLScanner = false;
         } else {
             if (BeaconManager.isAndroidLScanningDisabled()) {
-                Log.i(TAG, "This Android 5.0, but L scanning is disabled. We are using old scanning APIs");
+                LogManager.i(TAG, "This Android 5.0, but L scanning is disabled. We are using old scanning APIs");
                 useAndroidLScanner = false;
             } else {
-                Log.i(TAG, "This Android 5.0.  We are using new scanning APIs");
+                LogManager.i(TAG, "This Android 5.0.  We are using new scanning APIs");
                 useAndroidLScanner = true;
             }
         }
@@ -87,7 +88,8 @@ public static CycledLeScanner createScanner(Context context, long scanPeriod, lo
      * @param backgroundFlag
      */
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        BeaconManager.logDebug(TAG, "Set scan periods called with " + scanPeriod + ", " + betweenScanPeriod + "  Background mode must have changed.");
+        LogManager.d(TAG, "Set scan periods called with %s, %s Background mode must have changed.",
+                scanPeriod, betweenScanPeriod);
         if (mBackgroundFlag != backgroundFlag) {
             mRestartNeeded = true;
         }
@@ -95,10 +97,10 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
         mScanPeriod = scanPeriod;
         mBetweenScanPeriod = betweenScanPeriod;
         if (mBackgroundFlag) {
-            BeaconManager.logDebug(TAG, "We are in the background.  Setting wakeup alarm");
+            LogManager.d(TAG, "We are in the background.  Setting wakeup alarm");
             setWakeUpAlarm();
         } else {
-            BeaconManager.logDebug(TAG, "We are not in the background.  Cancelling wakeup alarm");
+            LogManager.d(TAG, "We are not in the background.  Cancelling wakeup alarm");
             cancelWakeUpAlarm();
         }
         long now = new Date().getTime();
@@ -109,7 +111,7 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
             long proposedNextScanStartTime = (mLastScanCycleEndTime + betweenScanPeriod);
             if (proposedNextScanStartTime < mNextScanCycleStartTime) {
                 mNextScanCycleStartTime = proposedNextScanStartTime;
-                Log.i(TAG, "Adjusted nextScanStartTime to be " + new Date(mNextScanCycleStartTime));
+                LogManager.i(TAG, "Adjusted nextScanStartTime to be %s", new Date(mNextScanCycleStartTime));
             }
         }
         if (mScanCycleStopTime > now) {
@@ -119,24 +121,24 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
             long proposedScanStopTime = (mLastScanCycleStartTime + scanPeriod);
             if (proposedScanStopTime < mScanCycleStopTime) {
                 mScanCycleStopTime = proposedScanStopTime;
-                Log.i(TAG, "Adjusted scanStopTime to be " + new Date(mScanCycleStopTime));
+                LogManager.i(TAG, "Adjusted scanStopTime to be %s", mScanCycleStopTime);
             }
         }
     }
 
     public void start() {
-        BeaconManager.logDebug(TAG, "start called");
+        LogManager.d(TAG, "start called");
         mScanningEnabled = true;
         if (!mScanCyclerStarted) {
             scanLeDevice(true);
         } else {
-            BeaconManager.logDebug(TAG, "scanning already started");
+            LogManager.d(TAG, "scanning already started");
         }
     }
 
     @SuppressLint("NewApi")
     public void stop() {
-        BeaconManager.logDebug(TAG, "stop called");
+        LogManager.d(TAG, "stop called");
         mScanningEnabled = false;
         if (mScanCyclerStarted) {
             scanLeDevice(false);
@@ -157,13 +159,13 @@ public void stop() {
     protected void scanLeDevice(final Boolean enable) {
         mScanCyclerStarted = true;
         if (getBluetoothAdapter() == null) {
-            Log.e(TAG, "No bluetooth adapter.  beaconService cannot scan.");
+            LogManager.e(TAG, "No bluetooth adapter.  beaconService cannot scan.");
         }
         if (enable) {
             if (deferScanIfNeeded()) {
                 return;
             }
-            BeaconManager.logDebug(TAG, "starting a new scan cycle");
+            LogManager.d(TAG, "starting a new scan cycle");
             if (!mScanning || mScanningPaused || mRestartNeeded) {
                 mScanning = true;
                 mScanningPaused = false;
@@ -171,41 +173,41 @@ protected void scanLeDevice(final Boolean enable) {
                     if (getBluetoothAdapter() != null) {
                         if (getBluetoothAdapter().isEnabled()) {
                             if (mBluetoothCrashResolver != null && mBluetoothCrashResolver.isRecoveryInProgress()) {
-                                Log.w(TAG, "Skipping scan because crash recovery is in progress.");
+                                LogManager.w(TAG, "Skipping scan because crash recovery is in progress.");
                             } else {
                                 if (mScanningEnabled) {
                                     if (mRestartNeeded) {
                                         mRestartNeeded = false;
-                                        BeaconManager.logDebug(TAG, "restarting a bluetooth le scan");
+                                        LogManager.d(TAG, "restarting a bluetooth le scan");
                                     } else {
-                                        BeaconManager.logDebug(TAG, "starting a new bluetooth le scan");
+                                        LogManager.d(TAG, "starting a new bluetooth le scan");
                                     }
                                     try {
                                         startScan();
                                     } catch (Exception e) {
-                                        Log.w("Internal Android exception scanning for beacons: ", e);
+                                        LogManager.e(e, TAG, "Internal Android exception scanning for beacons");
                                     }
                                 } else {
-                                    BeaconManager.logDebug(TAG, "Scanning unnecessary - no monitoring or ranging active.");
+                                    LogManager.d(TAG, "Scanning unnecessary - no monitoring or ranging active.");
                                 }
                             }
                             mLastScanCycleStartTime = new Date().getTime();
                         } else {
-                            Log.w(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
+                            LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
                         }
                     }
                 } catch (Exception e) {
-                    Log.e("TAG", "Exception starting bluetooth scan.  Perhaps bluetooth is disabled or unavailable?", e);
+                    LogManager.e(e, TAG, "Exception starting bluetooth scan.  Perhaps bluetooth is disabled or unavailable?");
                 }
             } else {
-                BeaconManager.logDebug(TAG, "We are already scanning");
+                LogManager.d(TAG, "We are already scanning");
             }
             mScanCycleStopTime = (new Date().getTime() + mScanPeriod);
             scheduleScanCycleStop();
 
-            BeaconManager.logDebug(TAG, "Scan started");
+            LogManager.d(TAG, "Scan started");
         } else {
-            BeaconManager.logDebug(TAG, "disabling scan");
+            LogManager.d(TAG, "disabling scan");
             mScanning = false;
 
             stopScan();
@@ -217,7 +219,8 @@ protected void scheduleScanCycleStop() {
         // Stops scanning after a pre-defined scan period.
         long millisecondsUntilStop = mScanCycleStopTime - (new Date().getTime());
         if (millisecondsUntilStop > 0) {
-            BeaconManager.logDebug(TAG, "Waiting to stop scan cycle for another " + millisecondsUntilStop + " milliseconds");
+            LogManager.d(TAG, "Waiting to stop scan cycle for another %s milliseconds",
+                    millisecondsUntilStop);
             if (mBackgroundFlag) {
                 setWakeUpAlarm();
             }
@@ -235,29 +238,29 @@ public void run() {
     protected abstract void finishScan();
 
     private void finishScanCycle() {
-        BeaconManager.logDebug(TAG, "Done with scan cycle");
+        LogManager.d(TAG, "Done with scan cycle");
         mCycledLeScanCallback.onCycleEnd();
         if (mScanning) {
             if (getBluetoothAdapter() != null) {
                 if (getBluetoothAdapter().isEnabled()) {
                     try {
-                        BeaconManager.logDebug(TAG, "stopping bluetooth le scan");
+                        LogManager.d(TAG, "stopping bluetooth le scan");
 
                         finishScan();
 
                     } catch (Exception e) {
-                        Log.w("Internal Android exception scanning for beacons: ", e);
+                        LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
                     }
                     mLastScanCycleEndTime = new Date().getTime();
                 } else {
-                    Log.w(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
+                    LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
                 }
             }
             mNextScanCycleStartTime = getNextScanStartTime();
             if (mScanningEnabled) {
                 scanLeDevice(true);
             } else {
-                BeaconManager.logDebug(TAG, "Scanning disabled.  No ranging or monitoring regions are active.");
+                LogManager.d(TAG, "Scanning disabled.  No ranging or monitoring regions are active.");
                 mScanCyclerStarted = false;
                 cancelWakeUpAlarm();
             }
@@ -271,6 +274,9 @@ protected BluetoothAdapter getBluetoothAdapter() {
             final BluetoothManager bluetoothManager =
                     (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
             mBluetoothAdapter = bluetoothManager.getAdapter();
+            if (mBluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            }
         }
         return mBluetoothAdapter;
     }
@@ -296,11 +302,11 @@ protected void setWakeUpAlarm() {
         cancelWakeUpAlarm();
         mWakeUpOperation = PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);
         alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, System.currentTimeMillis() + milliseconds, mWakeUpOperation);
-        BeaconManager.logDebug(TAG, "Set a wakeup alarm to go off in " + milliseconds + " ms: " + mWakeUpOperation);
+        LogManager.d(TAG, "Set a wakeup alarm to go off in %s ms: %s", milliseconds, mWakeUpOperation);
     }
 
     protected void cancelWakeUpAlarm() {
-        BeaconManager.logDebug(TAG, "cancel wakeup alarm: " + mWakeUpOperation);
+        LogManager.d(TAG, "cancel wakeup alarm: %s", mWakeUpOperation);
         if (mWakeUpOperation != null) {
             AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
             alarmManager.cancel(mWakeUpOperation);
@@ -321,9 +327,9 @@ private long getNextScanStartTime() {
         }
         long fullScanCycle = mScanPeriod + mBetweenScanPeriod;
         long normalizedBetweenScanPeriod = mBetweenScanPeriod-(System.currentTimeMillis() % fullScanCycle);
-        BeaconManager.logDebug(TAG, "Normalizing between scan period from  "+mBetweenScanPeriod+" to "+
+        LogManager.d(TAG, "Normalizing between scan period from %s to %s", mBetweenScanPeriod,
                 normalizedBetweenScanPeriod);
 
         return System.currentTimeMillis()+normalizedBetweenScanPeriod;
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
index 6e91ba7d..bacfc829 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
@@ -4,9 +4,8 @@
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
 import android.content.Context;
-import android.util.Log;
 
-import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.util.Date;
@@ -29,7 +28,7 @@ protected void stopScan() {
                 bluetoothAdapter.stopLeScan(getLeScanCallback());
             }
         } catch (Exception e) {
-            Log.w("Internal Android exception scanning for beacons: ", e);
+            LogManager.e(e, TAG, "Internal Android exception scanning for beacons");
         }
     }
 
@@ -37,7 +36,8 @@ protected void stopScan() {
     protected boolean deferScanIfNeeded() {
         long millisecondsUntilStart = mNextScanCycleStartTime - (new Date().getTime());
         if (millisecondsUntilStart > 0) {
-            BeaconManager.logDebug(TAG, "Waiting to start next bluetooth scan for another " + millisecondsUntilStart + " milliseconds");
+            LogManager.d(TAG, "Waiting to start next bluetooth scan for another %s milliseconds",
+                    millisecondsUntilStart);
             // Don't actually wait until the next scan time -- only wait up to 1 second.  this
             // allows us to start scanning sooner if a consumer enters the foreground and expects
             // results more quickly
@@ -76,7 +76,7 @@ protected void finishScan() {
                         @Override
                         public void onLeScan(final BluetoothDevice device, final int rssi,
                                              final byte[] scanRecord) {
-                            BeaconManager.logDebug(TAG, "got record");
+                            LogManager.d(TAG, "got record");
                             mCycledLeScanCallback.onLeScan(device, rssi, scanRecord);
                             mBluetoothCrashResolver.notifyScannedDevice(device, getLeScanCallback());
                         }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index e9d0a31b..ee1f9d5b 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -1,6 +1,5 @@
 package org.altbeacon.beacon.service.scanner;
 
-import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.bluetooth.le.BluetoothLeScanner;
 import android.bluetooth.le.ScanCallback;
@@ -8,10 +7,9 @@
 import android.bluetooth.le.ScanResult;
 import android.bluetooth.le.ScanSettings;
 import android.content.Context;
-import android.util.Log;
-import org.altbeacon.beacon.BeaconParser;
 
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.DetectionTracker;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
@@ -37,10 +35,12 @@ public CycledLeScannerForLollipop(Context context, long scanPeriod, long between
     @Override
     protected void stopScan() {
         try {
-            mScanner.stopScan(getNewLeScanCallback());
+            if (getScanner() != null) {
+                getScanner().stopScan(getNewLeScanCallback());
+            }
         }
         catch (Exception e) {
-            Log.w("Internal Android exception scanning for beacons: ", e);
+            LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
         }
     }
 
@@ -89,18 +89,26 @@ protected boolean deferScanIfNeeded() {
                     if (secsSinceLastDetection > BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
                         mBackgroundLScanStartTime = System.currentTimeMillis();
                         mBackgroundLScanFirstDetectionTime = 0l;
-                        BeaconManager.logDebug(TAG, "This is Android L. Doing a filtered scan for the background.");
+                        LogManager.d(TAG, "This is Android L. Doing a filtered scan for the background.");
 
                         // On Android L, between scan cycles do a scan with a filter looking for any beacon
                         // if we see one of those beacons, we need to deliver the results
                         ScanSettings settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
 
-                        mScanner.startScan(new ScanFilterUtils().createScanFiltersForBeaconParsers(mBeaconManager.getBeaconParsers()), settings,
-                                (android.bluetooth.le.ScanCallback) getNewLeScanCallback());
-                    }
-                    else {
-                        BeaconManager.logDebug(TAG, "This is Android L, but we last saw a beacon only "+
-                                secsSinceLastDetection+" ago, so we will not keep scanning in background.");
+                        try {
+                            if (getScanner() != null) {
+                                getScanner().startScan(new ScanFilterUtils().createScanFiltersForBeaconParsers(
+                                        mBeaconManager.getBeaconParsers()), settings, getNewLeScanCallback());
+                            }
+                        }
+                        catch (IllegalStateException e) {
+                            LogManager.w(TAG, "Cannot start scan.  Bluetooth may be turned off.");
+                        }
+
+                    } else {
+                        LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
+                                + "ago, so we will not keep scanning in background.",
+                                secsSinceLastDetection);
                     }
                 }
                 if (mBackgroundLScanStartTime > 0l) {
@@ -114,19 +122,27 @@ protected boolean deferScanIfNeeded() {
                             // if we are in here, it has been more than 10 seconds since we detected
                             // a beacon in background L scanning mode.  We need to stop scanning
                             // so we do not drain battery
-                            BeaconManager.logDebug(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
-                            mScanner.stopScan((android.bluetooth.le.ScanCallback) getNewLeScanCallback());
+                            LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
+                            try {
+                                if (getScanner() != null) {
+                                    getScanner().stopScan((android.bluetooth.le.ScanCallback) getNewLeScanCallback());
+                                }
+                            }
+                            catch (IllegalStateException e) {
+                                LogManager.w(TAG, "Cannot stop scan.  Bluetooth may be turned off.");
+                            }
                             mBackgroundLScanStartTime = 0l;
                         }
                         else {
                             // report the results up the chain
-                            BeaconManager.logDebug(TAG, "Delivering Android L background scanning results");
+                            LogManager.d(TAG, "Delivering Android L background scanning results");
                             mCycledLeScanCallback.onCycleEnd();
                         }
                     }
                 }
             }
-            BeaconManager.logDebug(TAG, "Waiting to start full bluetooth scan for another " + millisecondsUntilStart + " milliseconds");
+            LogManager.d(TAG, "Waiting to start full bluetooth scan for another %s milliseconds",
+                    millisecondsUntilStart);
             // Don't actually wait until the next scan time -- only wait up to 1 second.  this
             // allows us to start scanning sooner if a consumer enters the foreground and expects
             // results more quickly
@@ -144,8 +160,15 @@ public void run() {
         }
         else {
             if (mBackgroundLScanStartTime > 0l) {
-                BeaconManager.logDebug(TAG, "Stopping Android L background scanning to start full scan");
-                mScanner.stopScan((android.bluetooth.le.ScanCallback) getNewLeScanCallback());
+                try {
+                    if (getScanner() != null) {
+                        getScanner().stopScan((android.bluetooth.le.ScanCallback) getNewLeScanCallback());
+                    }
+                }
+                catch (IllegalStateException e) {
+                    LogManager.w(TAG, "Cannot stop scan.  Bluetooth may be turned off.");
+                }
+
                 mBackgroundLScanStartTime = 0;
             }
             mScanDeferredBefore = false;
@@ -153,63 +176,83 @@ public void run() {
         return false;
     }
 
-
     @Override
     protected void startScan() {
         List<ScanFilter> filters = new ArrayList<ScanFilter>();
-        if (mScanner == null) {
-            BeaconManager.logDebug(TAG, "Making new Android L scanner");
-            mScanner = getBluetoothAdapter().getBluetoothLeScanner();
-        }
         ScanSettings settings;
 
         if (mBackgroundFlag) {
-            BeaconManager.logDebug(TAG, "starting scan in SCAN_MODE_LOW_POWER");
+            LogManager.d(TAG, "starting scan in SCAN_MODE_LOW_POWER");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
         } else {
-            BeaconManager.logDebug(TAG, "starting scan in SCAN_MODE_LOW_LATENCY");
+            LogManager.d(TAG, "starting scan in SCAN_MODE_LOW_LATENCY");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)).build();
 
         }
-        mScanner.startScan(filters, settings, getNewLeScanCallback());
-
+        try {
+            if (getScanner() != null) {
+                getScanner().startScan(filters, settings, getNewLeScanCallback());
+            }
+        }
+        catch (IllegalStateException e) {
+            LogManager.w(TAG, "Cannot start scan.  Bluetooth may be turned off.");
+        }
     }
 
     @Override
     protected void finishScan() {
-        mScanner.stopScan(getNewLeScanCallback());
+        try {
+            if (getScanner() != null) {
+                getScanner().stopScan(getNewLeScanCallback());
+            }
+        }
+        catch (IllegalStateException e) {
+            LogManager.w(TAG, "Cannot stop scan.  Bluetooth may be turned off.");
+        }
+
         mScanningPaused = true;
     }
 
+    private BluetoothLeScanner getScanner() {
+        if (mScanner == null) {
+            LogManager.d(TAG, "Making new Android L scanner");
+            mScanner = getBluetoothAdapter().getBluetoothLeScanner();
+            if (mScanner == null) {
+                LogManager.w(TAG, "Failed to make new Android L scanner");
+            }
+        }
+        return mScanner;
+    }
+
     private ScanCallback getNewLeScanCallback() {
         if (leScanCallback == null) {
             leScanCallback = new ScanCallback() {
 
                 @Override
                 public void onScanResult(int callbackType, ScanResult scanResult) {
-                    BeaconManager.logDebug(TAG, "got record");
+                    LogManager.d(TAG, "got record");
                     mCycledLeScanCallback.onLeScan(scanResult.getDevice(),
                             scanResult.getRssi(), scanResult.getScanRecord().getBytes());
                     if (mBackgroundLScanStartTime > 0) {
-                        mBeaconManager.logDebug(TAG, "got a filtered scan result in the background.");
+                        LogManager.d(TAG, "got a filtered scan result in the background.");
                     }
                 }
 
                 @Override
                 public void onBatchScanResults(List<ScanResult> results) {
-                    BeaconManager.logDebug(TAG, "got batch records");
+                    LogManager.d(TAG, "got batch records");
                     for (ScanResult scanResult : results) {
                         mCycledLeScanCallback.onLeScan(scanResult.getDevice(),
                                 scanResult.getRssi(), scanResult.getScanRecord().getBytes());
                     }
                     if (mBackgroundLScanStartTime > 0) {
-                        mBeaconManager.logDebug(TAG, "got a filtered batch scan result in the background.");
+                        LogManager.d(TAG, "got a filtered batch scan result in the background.");
                     }
                 }
 
                 @Override
                 public void onScanFailed(int i) {
-                    Log.e(TAG, "Scan Failed");
+                    LogManager.e(TAG, "Scan Failed");
                 }
             };
         }
diff --git a/src/main/java/org/altbeacon/beacon/startup/RegionBootstrap.java b/src/main/java/org/altbeacon/beacon/startup/RegionBootstrap.java
index d721b0b8..4fc23390 100644
--- a/src/main/java/org/altbeacon/beacon/startup/RegionBootstrap.java
+++ b/src/main/java/org/altbeacon/beacon/startup/RegionBootstrap.java
@@ -9,6 +9,7 @@
 import org.altbeacon.beacon.BeaconConsumer;
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -55,7 +56,7 @@ public RegionBootstrap(BootstrapNotifier application, Region region) {
         regions.add(region);
 		beaconConsumer = new InternalBeaconConsumer();
         beaconManager.bind(beaconConsumer);
-        BeaconManager.logDebug(TAG, "Waiting for BeaconService connection");
+        LogManager.d(TAG, "Waiting for BeaconService connection");
 	}
 
 	/**
@@ -74,7 +75,7 @@ public RegionBootstrap(BootstrapNotifier application, List<Region> regions) {
 
         beaconConsumer = new InternalBeaconConsumer();
         beaconManager.bind(beaconConsumer);
-        BeaconManager.logDebug(TAG, "Waiting for BeaconService connection");
+        LogManager.d(TAG, "Waiting for BeaconService connection");
 	}
 	
 	/**
@@ -90,8 +91,8 @@ public void disable() {
         	for (Region region : regions) {
                 beaconManager.stopMonitoringBeaconsInRegion(region);        		
         	}
-        } catch (RemoteException e) {   
-        	Log.e(TAG, "Can't stop bootstrap regions due to "+e);
+        } catch (RemoteException e) {
+            LogManager.e(e, TAG, "Can't stop bootstrap regions");
         }	
 		beaconManager.unbind(beaconConsumer);
 	}
@@ -103,18 +104,18 @@ public void disable() {
 		 */
 	    @Override
 	    public void onBeaconServiceConnect() {
-            BeaconManager.logDebug(TAG, "Activating background region monitoring");
+            LogManager.d(TAG, "Activating background region monitoring");
 	        beaconManager.setMonitorNotifier(application);
 	        try {
 	        	for (Region region : regions) {
-                    BeaconManager.logDebug(TAG, "Background region monitoring activated for region "+region);
+                    LogManager.d(TAG, "Background region monitoring activated for region %s", region);
 	                beaconManager.startMonitoringBeaconsInRegion(region);
                         if (beaconManager.isBackgroundModeUninitialized()) {
                             beaconManager.setBackgroundMode(true);
                         }
 	        	}
 	        } catch (RemoteException e) {   
-	        	Log.e(TAG, "Can't set up bootstrap regions due to "+e);
+	        	LogManager.e(e, TAG, "Can't set up bootstrap regions");
 	        }
 	    }
 	
diff --git a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
index 621fa853..49ddb9f8 100644
--- a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
+++ b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
@@ -4,10 +4,8 @@
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
-import android.util.Log;
 
-import org.altbeacon.beacon.BeaconIntentProcessor;
-import org.altbeacon.beacon.service.BeaconService;
+import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.BeaconManager;
 
 @TargetApi(4)
@@ -17,20 +15,20 @@
 
 	@Override
     public void onReceive(Context context, Intent intent) {
-        BeaconManager.logDebug(TAG, "onReceive called in startup broadcast receiver");
+        LogManager.d(TAG, "onReceive called in startup broadcast receiver");
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            Log.w(TAG, "Not starting up beacon service because we do not have SDK version 18 (Android 4.3).  We have: "+android.os.Build.VERSION.SDK_INT);
+            LogManager.w(TAG, "Not starting up beacon service because we do not have SDK version 18 (Android 4.3).  We have: %s", android.os.Build.VERSION.SDK_INT);
             return;
         }
         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context.getApplicationContext());
         if (beaconManager.isAnyConsumerBound()) {
             if (intent.getBooleanExtra("wakeup", false)) {
-                BeaconManager.logDebug(TAG, "got wake up intent");
+                LogManager.d(TAG, "got wake up intent");
             }
             else {
-                BeaconManager.logDebug(TAG, "Already started.  Ignoring intent: "+intent+" of type:  "+intent.getStringExtra("wakeup"));
+                LogManager.d(TAG, "Already started.  Ignoring intent: %s of type: %s", intent,
+                        intent.getStringExtra("wakeup"));
             }
-            return;
         }
      }
 }
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
index a425caf5..2d4de68c 100644
--- a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
@@ -7,7 +7,8 @@
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
-import android.util.Log;
+
+import org.altbeacon.beacon.logging.LogManager;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;
@@ -42,7 +43,6 @@
 public class BluetoothCrashResolver {
     private static final String TAG = "BluetoothCrashResolver";
     private static final boolean PREEMPTIVE_ACTION_ENABLED = true;
-    private boolean debugEnabled = false;
     /**
      * This is not the same file that bluedroid uses.  This is just to maintain state of this module
      */
@@ -61,7 +61,7 @@
 
     private Context context = null;
     private UpdateNotifier updateNotifier;
-    private Set<String> distinctBluetoothAddresses = new HashSet<String>();
+    private final Set<String> distinctBluetoothAddresses = new HashSet<String>();
     /**
      // It is very likely a crash if Bluetooth turns off and comes
      // back on in an extremely short interval.  Testing on a Nexus 4 shows
@@ -102,7 +102,7 @@
      */
     public BluetoothCrashResolver(Context context) {
         this.context = context.getApplicationContext();
-        if (isDebugEnabled()) Log.d(TAG, "constructed");
+        LogManager.d(TAG, "constructed");
         loadState();
     }
 
@@ -118,7 +118,7 @@ public void start() {
         filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
         context.registerReceiver(receiver, filter);
 
-        if (isDebugEnabled()) Log.d(TAG, "started listening for BluetoothAdapter events");
+        LogManager.d(TAG, "started listening for BluetoothAdapter events");
     }
 
     /**
@@ -127,22 +127,33 @@ public void start() {
      */
     public void stop() {
         context.unregisterReceiver(receiver);
-        if (isDebugEnabled()) Log.d(TAG, "stopped listening for BluetoothAdapter events");
+        LogManager.d(TAG, "stopped listening for BluetoothAdapter events");
         saveState();
     }
 
     /**
      * Enable debug logging.  By default no debug lines are logged.
+     * @deprecated Since the default logger used by the android-beacon-library only logs warnings and
+     * above, this method is no logger used. To log debug messages use the
+     * {@link org.altbeacon.beacon.logging.Loggers#verboseLogger()}
+     * @see org.altbeacon.beacon.logging.LogManager
+     * @see org.altbeacon.beacon.logging.Loggers
      */
+    @Deprecated
     public void enableDebug() {
-        debugEnabled = true;
+
     }
+    
     /**
-     * Disable debug logging
+     * Disable debug logging.
+     * @deprecated Since the default logger used by the android-beacon-library only logs warnings and
+     * above, this method is no logger used. To log debug messages use the
+     * {@link org.altbeacon.beacon.logging.Loggers#verboseLogger()}
+     * @see org.altbeacon.beacon.logging.LogManager
+     * @see org.altbeacon.beacon.logging.Loggers
      */
-    public void disableDebug() {
-        debugEnabled = false;
-    }
+    @Deprecated
+    public void disableDebug() { }
 
     /**
      * Call this method from your BluetoothAdapter.LeScanCallback method.
@@ -164,23 +175,24 @@ public void disableDebug() {
      */
     @TargetApi(18)
     public void notifyScannedDevice(BluetoothDevice device, BluetoothAdapter.LeScanCallback scanner) {
-        int oldSize = 0, newSize = 0;
+        int oldSize, newSize;
 
-        if (isDebugEnabled()) oldSize = distinctBluetoothAddresses.size();
+        oldSize = distinctBluetoothAddresses.size();
 
         synchronized(distinctBluetoothAddresses) {
             distinctBluetoothAddresses.add(device.getAddress());
         }
-        if (isDebugEnabled()) {
-            newSize = distinctBluetoothAddresses.size();
-            if (oldSize != newSize && newSize % 100 == 0) {
-                if (isDebugEnabled()) Log.d(TAG, "Distinct bluetooth devices seen: "+distinctBluetoothAddresses.size());
-            }
+
+        newSize = distinctBluetoothAddresses.size();
+        if (oldSize != newSize && newSize % 100 == 0) {
+            LogManager.d(TAG, "Distinct bluetooth devices seen: %s", distinctBluetoothAddresses.size());
         }
         if (distinctBluetoothAddresses.size()  > getCrashRiskDeviceCount()) {
             if (PREEMPTIVE_ACTION_ENABLED && !recoveryInProgress) {
-                Log.w(TAG, "Large number of bluetooth devices detected: "+distinctBluetoothAddresses.size()+" Proactively attempting to clear out address list to prevent a crash");
-                Log.w(TAG, "Stopping LE Scan");
+                LogManager.w(TAG, "Large number of bluetooth devices detected: %s Proactively "
+                        + "attempting to clear out address list to prevent a crash",
+                        distinctBluetoothAddresses.size());
+                LogManager.w(TAG, "Stopping LE Scan");
                 BluetoothAdapter.getDefaultAdapter().stopLeScan(scanner);
                 startRecovery();
                 processStateChange();
@@ -190,19 +202,20 @@ public void notifyScannedDevice(BluetoothDevice device, BluetoothAdapter.LeScanC
 
     public void crashDetected() {
         if (android.os.Build.VERSION.SDK_INT < 18) {
-            if (isDebugEnabled()) Log.d(TAG, "Ignoring crashes before SDK 18, because BLE is unsupported.");
+            LogManager.d(TAG, "Ignoring crashes before SDK 18, because BLE is unsupported.");
             return;
         }
-        Log.w(TAG, "BluetoothService crash detected");
+        LogManager.w(TAG, "BluetoothService crash detected");
         if (distinctBluetoothAddresses.size() > 0) {
-            if (isDebugEnabled()) Log.d(TAG, "Distinct bluetooth devices seen at crash: "+distinctBluetoothAddresses.size());
+            LogManager.d(TAG, "Distinct bluetooth devices seen at crash: %s",
+                    distinctBluetoothAddresses.size());
         }
         long nowTimestamp = new Date().getTime();
         lastBluetoothCrashDetectionTime = nowTimestamp;
         detectedCrashCount++;
 
         if (recoveryInProgress) {
-            if (isDebugEnabled()) Log.d(TAG, "Ignoring bluetooth crash because recovery is already in progress.");
+            LogManager.d(TAG, "Ignoring bluetooth crash because recovery is already in progress.");
         }
         else {
             startRecovery();
@@ -241,10 +254,6 @@ public void forceFlush() {
         processStateChange();
     }
 
-    private boolean isDebugEnabled() {
-        return debugEnabled;
-    }
-
     private int getCrashRiskDeviceCount() {
         // 1990 distinct devices tracked by Bluedroid will cause a crash.  But we don't know how many
         // devices bluedroid is tracking, we only know how many we have seen, which will be smaller
@@ -258,7 +267,7 @@ private void processStateChange() {
         if (updateNotifier != null) {
             updateNotifier.dataUpdated();
         }
-        if (new Date().getTime() - lastStateSaveTime > MIN_TIME_BETWEEN_STATE_SAVES_MILLIS) {
+        if (System.currentTimeMillis() - lastStateSaveTime > MIN_TIME_BETWEEN_STATE_SAVES_MILLIS) {
             saveState();
         }
     }
@@ -269,34 +278,34 @@ private void startRecovery() {
         // most recently seen BLE mac addresses.
         recoveryAttemptCount++;
         BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-        if (isDebugEnabled()) Log.d(TAG, "about to check if discovery is active");
+        LogManager.d(TAG, "about to check if discovery is active");
         if (!adapter.isDiscovering()) {
-            Log.w(TAG, "Recovery attempt started");
+            LogManager.w(TAG, "Recovery attempt started");
             recoveryInProgress = true;
             discoveryStartConfirmed = false;
-            if (isDebugEnabled()) Log.d(TAG, "about to command discovery");
+            LogManager.d(TAG, "about to command discovery");
             if (!adapter.startDiscovery()) {
-                Log.w(TAG, "Can't start discovery.  Is bluetooth turned on?");
+                LogManager.w(TAG, "Can't start discovery.  Is bluetooth turned on?");
             }
-            if (isDebugEnabled()) Log.d(TAG, "startDiscovery commanded.  isDiscovering()="+adapter.isDiscovering());
+            LogManager.d(TAG, "startDiscovery commanded.  isDiscovering()=%s", adapter.isDiscovering());
             // We don't actually need to do a discovery -- we just need to kick one off so the
             // mac list will be pared back to 256.  Because discovery is an expensive operation in
             // terms of battery, we will cancel it.
             if (TIME_TO_LET_DISCOVERY_RUN_MILLIS > 0 ) {
-                if (isDebugEnabled()) Log.d(TAG, "We will be cancelling this discovery in "+TIME_TO_LET_DISCOVERY_RUN_MILLIS+" milliseconds.");
+                LogManager.d(TAG, "We will be cancelling this discovery in %s milliseconds.", TIME_TO_LET_DISCOVERY_RUN_MILLIS);
                 cancelDiscovery();
             }
             else {
-                if (isDebugEnabled()) Log.d(TAG, "We will let this discovery run its course.");
+                LogManager.d(TAG, "We will let this discovery run its course.");
             }
         }
         else {
-            Log.w(TAG, "Already discovering.  Recovery attempt abandoned.");
+            LogManager.w(TAG, "Already discovering.  Recovery attempt abandoned.");
         }
 
     }
     private void finishRecovery() {
-        Log.w(TAG, "Recovery attempt finished");
+        LogManager.w(TAG, "Recovery attempt finished");
         synchronized(distinctBluetoothAddresses) {
             distinctBluetoothAddresses.clear();
         }
@@ -310,20 +319,20 @@ public void onReceive(Context context, Intent intent) {
 
             if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)) {
                 if (recoveryInProgress) {
-                    if (isDebugEnabled()) Log.d(TAG, "Bluetooth discovery finished");
+                    LogManager.d(TAG, "Bluetooth discovery finished");
                     finishRecovery();
                 }
                 else {
-                    if (isDebugEnabled()) Log.d(TAG, "Bluetooth discovery finished (external)");
+                    LogManager.d(TAG, "Bluetooth discovery finished (external)");
                 }
             }
             if (action.equals(BluetoothAdapter.ACTION_DISCOVERY_STARTED)) {
                 if (recoveryInProgress) {
                     discoveryStartConfirmed = true;
-                    if (isDebugEnabled()) Log.d(TAG, "Bluetooth discovery started");
+                    LogManager.d(TAG, "Bluetooth discovery started");
                 }
                 else {
-                    if (isDebugEnabled()) Log.d(TAG, "Bluetooth discovery started (external)");
+                    LogManager.d(TAG, "Bluetooth discovery started (external)");
                 }
             }
 
@@ -332,24 +341,24 @@ public void onReceive(Context context, Intent intent) {
                         BluetoothAdapter.ERROR);
                 switch (state) {
                     case BluetoothAdapter.ERROR:
-                        if (isDebugEnabled()) Log.d(TAG, "Bluetooth state is ERROR");
+                        LogManager.d(TAG, "Bluetooth state is ERROR");
                         break;
                     case BluetoothAdapter.STATE_OFF:
-                        if (isDebugEnabled()) Log.d(TAG, "Bluetooth state is OFF");
-                        lastBluetoothOffTime = new Date().getTime();
+                        LogManager.d(TAG, "Bluetooth state is OFF");
+                        lastBluetoothOffTime = System.currentTimeMillis();
                         break;
                     case BluetoothAdapter.STATE_TURNING_OFF:
                         break;
                     case BluetoothAdapter.STATE_ON:
-                        if (isDebugEnabled()) Log.d(TAG, "Bluetooth state is ON");
-                        if (isDebugEnabled()) Log.d(TAG, "Bluetooth was turned off for "+(lastBluetoothTurningOnTime - lastBluetoothOffTime)+" milliseconds");
+                        LogManager.d(TAG, "Bluetooth state is ON");
+                        LogManager.d(TAG, "Bluetooth was turned off for %s milliseconds", lastBluetoothTurningOnTime - lastBluetoothOffTime);
                         if (lastBluetoothTurningOnTime - lastBluetoothOffTime < SUSPICIOUSLY_SHORT_BLUETOOTH_OFF_INTERVAL_MILLIS) {
                             crashDetected();
                         }
                         break;
                     case BluetoothAdapter.STATE_TURNING_ON:
                         lastBluetoothTurningOnTime = new Date().getTime();
-                        if (isDebugEnabled()) Log.d(TAG, "Bluetooth state is TURNING_ON");
+                        LogManager.d(TAG, "Bluetooth state is TURNING_ON");
                         break;
                 }
             }
@@ -358,7 +367,7 @@ public void onReceive(Context context, Intent intent) {
 
 
     private void saveState() {
-        FileOutputStream outputStream = null;
+        FileOutputStream outputStream;
         OutputStreamWriter writer = null;
         lastStateSaveTime = new Date().getTime();
 
@@ -376,7 +385,7 @@ private void saveState() {
                 }
             }
         } catch (IOException e) {
-            Log.w(TAG, "Can't write macs to "+DISTINCT_BLUETOOTH_ADDRESSES_FILE);
+            LogManager.w(TAG, "Can't write macs to %s", DISTINCT_BLUETOOTH_ADDRESSES_FILE);
         }
         finally {
             if (writer != null) {
@@ -385,12 +394,12 @@ private void saveState() {
                 } catch (IOException e1) { }
             }
         }
-        if (isDebugEnabled()) Log.d(TAG, "Wrote "+distinctBluetoothAddresses.size()+" bluetooth addresses");
+        LogManager.d(TAG, "Wrote %s bluetooth addresses", distinctBluetoothAddresses.size());
 
     }
 
     private void loadState() {
-        FileInputStream inputStream = null;
+        FileInputStream inputStream;
         BufferedReader reader = null;
 
         try {
@@ -423,9 +432,9 @@ private void loadState() {
             }
 
         } catch (IOException e) {
-            Log.w(TAG, "Can't read macs from "+DISTINCT_BLUETOOTH_ADDRESSES_FILE);
+            LogManager.w(TAG, "Can't read macs from %s", DISTINCT_BLUETOOTH_ADDRESSES_FILE);
         } catch (NumberFormatException e) {
-            Log.w(TAG, "Can't parse file "+DISTINCT_BLUETOOTH_ADDRESSES_FILE);
+            LogManager.w(TAG, "Can't parse file %s", DISTINCT_BLUETOOTH_ADDRESSES_FILE);
         }
         finally {
             if (reader != null) {
@@ -434,28 +443,27 @@ private void loadState() {
                 } catch (IOException e1) { }
             }
         }
-        if (isDebugEnabled()) Log.d(TAG, "Read "+distinctBluetoothAddresses.size()+" bluetooth addresses");
+        LogManager.d(TAG, "Read %s bluetooth addresses", distinctBluetoothAddresses.size());
     }
 
     private void cancelDiscovery() {
         try {
             Thread.sleep(TIME_TO_LET_DISCOVERY_RUN_MILLIS);
             if (!discoveryStartConfirmed) {
-                Log.w(TAG, "BluetoothAdapter.ACTION_DISCOVERY_STARTED never received.  Recovery may fail.");
+                LogManager.w(TAG, "BluetoothAdapter.ACTION_DISCOVERY_STARTED never received.  Recovery may fail.");
             }
 
             final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
             if (adapter.isDiscovering()) {
-                if (isDebugEnabled()) Log.d(TAG, "Cancelling discovery");
+                LogManager.d(TAG, "Cancelling discovery");
                 adapter.cancelDiscovery();
             }
             else {
-                if (isDebugEnabled()) Log.d(TAG, "Discovery not running.  Won't cancel it");
+                LogManager.d(TAG, "Discovery not running.  Won't cancel it");
             }
         } catch (InterruptedException e) {
-            if (isDebugEnabled()) Log.d(TAG, "DiscoveryCanceller sleep interrupted.");
+            LogManager.d(TAG, "DiscoveryCanceller sleep interrupted.");
         }
     }
-
 }
 
diff --git a/src/test/AndroidManifest.xml b/src/test/AndroidManifest.xml
index a885a555..bd9c66be 100644
--- a/src/test/AndroidManifest.xml
+++ b/src/test/AndroidManifest.xml
@@ -16,14 +16,15 @@
         </receiver>
 
         <service android:enabled="true"
-            android:exported="true"
+            android:exported="false"
             android:isolatedProcess="false"
             android:label="beacon"
             android:name=".service.BeaconService"
             />
 
-        <service android:enabled="true"
-            android:name=".BeaconIntentProcessor"
+        <service android:name=".BeaconIntentProcessor"
+            android:enabled="true"
+            android:exported="false"
             />
 
     </application>
diff --git a/src/test/java/org/altbeacon/beacon/AltBeaconParserTest.java b/src/test/java/org/altbeacon/beacon/AltBeaconParserTest.java
index cac8a41c..d23dde6f 100644
--- a/src/test/java/org/altbeacon/beacon/AltBeaconParserTest.java
+++ b/src/test/java/org/altbeacon/beacon/AltBeaconParserTest.java
@@ -1,11 +1,7 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
-import static android.test.MoreAsserts.assertNotEqual;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
 
 import org.robolectric.RobolectricTestRunner;
 
@@ -48,7 +44,6 @@ public void testRecognizeBeacon() {
 
     @Test
     public void testDetectsDaveMHardwareBeacon() {
-        BeaconManager.debug = true;
         org.robolectric.shadows.ShadowLog.stream = System.err;
         byte[] bytes = hexStringToByteArray("02011a1bff1801beac2f234454cf6d4a0fadf2f4911ba9ffa600050003be020e09526164426561636f6e20555342020a0300000000000000000000000000");
         AltBeaconParser parser = new AltBeaconParser();
@@ -57,7 +52,6 @@ public void testDetectsDaveMHardwareBeacon() {
     }
     @Test
     public void testDetectsAlternateBeconType() {
-        BeaconManager.debug = true;
         org.robolectric.shadows.ShadowLog.stream = System.err;
         byte[] bytes = hexStringToByteArray("02011a1aff1801aabb2f234454cf6d4a0fadf2f4911ba9ffa600010002c509");
         AltBeaconParser parser = new AltBeaconParser();
diff --git a/src/test/java/org/altbeacon/beacon/AltBeaconTest.java b/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
index a32a0727..cccec0ea 100644
--- a/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
@@ -2,10 +2,9 @@
 
 import android.os.Parcel;
 
-import static android.test.MoreAsserts.assertNotEqual;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 
+import org.altbeacon.beacon.logging.Loggers;
 import org.robolectric.RobolectricTestRunner;
 
 import org.junit.runner.RunWith;
@@ -40,7 +39,6 @@
 
   @Test
   public void testRecognizeBeacon() {
-    BeaconManager.debug = true;
 	byte[] bytes = hexStringToByteArray("02011a1affbeac2f234454cf6d4a0fadf2f4911ba9ffa600010002c509");
     AltBeaconParser parser = new AltBeaconParser();
 	Beacon beacon = parser.fromScanData(bytes, -55, null);
@@ -60,6 +58,4 @@ public void testCanSerializeParcelable() {
         Beacon beacon2 = new AltBeacon(parcel);
         assertEquals("beaconMfgReserved is same after deserialization", ((AltBeacon)beacon).getMfgReserved(), ((AltBeacon)beacon2).getMfgReserved());
     }
-
-
-} 
\ No newline at end of file
+} 
diff --git a/src/test/java/org/altbeacon/beacon/BeaconTransmitterTest.java b/src/test/java/org/altbeacon/beacon/BeaconTransmitterTest.java
index 1b273030..9d657f24 100644
--- a/src/test/java/org/altbeacon/beacon/BeaconTransmitterTest.java
+++ b/src/test/java/org/altbeacon/beacon/BeaconTransmitterTest.java
@@ -1,12 +1,6 @@
 package org.altbeacon.beacon;
 
-import android.annotation.TargetApi;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.le.AdvertiseCallback;
-import android.bluetooth.le.AdvertiseSettings;
 import android.content.Context;
-import android.os.Build;
-import android.os.Parcel;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -14,12 +8,9 @@
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
-import java.util.ArrayList;
 import java.util.Arrays;
 
 import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertNotNull;
-import static junit.framework.Assert.fail;
 
 @Config(emulateSdk = 18)
 
@@ -31,7 +22,6 @@
 
     @Test
     public void testBeaconAdvertisingBytes() {
-        BeaconManager.debug = true;
         org.robolectric.shadows.ShadowLog.stream = System.err;
         Context context = Robolectric.getShadowApplication().getApplicationContext();
 
@@ -41,7 +31,7 @@ public void testBeaconAdvertisingBytes() {
                 .setId3("2")
                 .setManufacturer(0x0118)
                 .setTxPower(-59)
-                .setDataFields(Arrays.asList(new Long[]{0l}))
+                .setDataFields(Arrays.asList(0L))
                 .build();
         BeaconParser beaconParser = new BeaconParser()
                 .setBeaconLayout("m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25");
@@ -51,7 +41,7 @@ public void testBeaconAdvertisingBytes() {
 
         assertEquals("Data should be 24 bytes long", 24, data.length);
         String byteString = "";
-        for (int i= 0; i < data.length; i++) {
+        for (int i = 0; i < data.length; i++) {
             byteString += String.format("%02X", data[i]);
             byteString += " ";
         }
diff --git a/src/test/java/org/altbeacon/beacon/GattBeaconTest.java b/src/test/java/org/altbeacon/beacon/GattBeaconTest.java
new file mode 100644
index 00000000..b6d4d75e
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/GattBeaconTest.java
@@ -0,0 +1,85 @@
+package org.altbeacon.beacon;
+
+import android.annotation.TargetApi;
+import android.bluetooth.BluetoothDevice;
+import android.os.Build;
+import android.os.Parcel;
+import android.content.Context;
+
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.logging.Loggers;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertNotNull;
+import org.robolectric.annotation.Config;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.junit.runner.RunWith;
+
+@Config(emulateSdk = 18)
+
+/**
+ * Created by dyoung on 2/6/15.
+ * This test verifies that a beacon can be parsed that uses a Gatt UUID
+ */
+@RunWith(RobolectricTestRunner.class)
+public class GattBeaconTest {
+    @Test
+    public void testDetectsGattBeacon() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        LogManager.setLogger(Loggers.verboseLogger());
+        byte[] bytes = hexStringToByteArray("0201060303f4fe161601230025c5454452e29735323d81c0060504030201");
+        BeaconParser parser = new BeaconParser().setBeaconLayout("s:0-1=0123,m:2-2=00,d:3-3,p:4-4,i:5-14,i:15-20");
+        assertNotNull("Service uuid parsed should not be null", parser.getServiceUuid());
+        Beacon gattBeacon = parser.fromScanData(bytes, -55, null);
+        assertNotNull("GattBeacon should be not null if parsed successfully", gattBeacon);
+        assertEquals("id1 should be parsed", "0x454452e29735323d81c0", gattBeacon.getId1().toString());
+        assertEquals("id2 should be parsed", "0x060504030201", gattBeacon.getId2().toString());
+        assertEquals("serviceUuid should be parsed", 0x0123, gattBeacon.getServiceUuid());
+        assertEquals("txPower should be parsed", -59, gattBeacon.getTxPower());
+    }
+
+    @Test
+    public void testBeaconAdvertisingBytes() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        Context context = Robolectric.getShadowApplication().getApplicationContext();
+
+
+        Beacon beacon = new Beacon.Builder()
+                .setId1("0x454452e29735323d81c0")
+                .setId2("0x060504030201")
+                .setDataFields(Arrays.asList(0x25l))
+                .setTxPower(-59)
+                .build();
+        // TODO: need to use something other than the d: prefix here for an internally generated field
+        BeaconParser beaconParser = new BeaconParser()
+                .setBeaconLayout("s:0-1=0123,m:2-2=00,d:3-3,p:4-4,i:5-14,i:15-20");
+        byte[] data = beaconParser.getBeaconAdvertisementData(beacon);
+        BeaconTransmitter beaconTransmitter = new BeaconTransmitter(context, beaconParser);
+        // TODO: can't actually start transmitter here because Robolectric does not support API 21
+
+        assertEquals("Data should be 19 bytes long", 19, data.length);
+        String byteString = "";
+        for (int i = 0; i < data.length; i++) {
+            byteString += String.format("%02X", data[i]);
+            byteString += " ";
+        }
+        assertEquals("Advertisement bytes should be as expected", "00 25 C5 45 44 52 E2 97 35 32 3D 81 C0 06 05 04 03 02 01 ", byteString);
+    }
+
+
+    public static byte[] hexStringToByteArray(String s) {
+        int len = s.length();
+        byte[] data = new byte[len / 2];
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
+                    + Character.digit(s.charAt(i+1), 16));
+        }
+        return data;
+    }
+
+}
diff --git a/src/test/java/org/altbeacon/beacon/IdentifierTest.java b/src/test/java/org/altbeacon/beacon/IdentifierTest.java
index e9c60e9d..4bfe2cf3 100644
--- a/src/test/java/org/altbeacon/beacon/IdentifierTest.java
+++ b/src/test/java/org/altbeacon/beacon/IdentifierTest.java
@@ -4,6 +4,7 @@
 
 import static android.test.MoreAsserts.assertNotEqual;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertTrue;
 
 import org.robolectric.RobolectricTestRunner;
@@ -12,6 +13,9 @@
 import org.junit.Test;
 import org.robolectric.annotation.Config;
 
+import java.util.Arrays;
+import java.util.UUID;
+
 @Config(emulateSdk = 18)
 @RunWith(RobolectricTestRunner.class)
 
@@ -34,6 +38,7 @@ public void testEqualsNormalizationIgnoresCase() {
 
         assertTrue("Identifiers of different case should match", identifier1.equals(identifier2));
     }
+
     @Test
     public void testToStringNormalizesCase() {
         Identifier identifier1 = Identifier.parse("2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6");
@@ -41,6 +46,20 @@ public void testToStringNormalizesCase() {
         assertEquals("Identifiers of different case should match", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", identifier1.toString());
     }
 
+    @Test
+    public void testToStringEqualsUuid() {
+        Identifier identifier1 = Identifier.parse("2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6");
+
+        assertEquals("uuidString of Identifier should match", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", identifier1.toUuidString());
+    }
+
+    @Test
+    public void testToUuidEqualsToUuidString() {
+        Identifier identifier1 = Identifier.parse("2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6");
+
+        assertEquals("uuidString of Identifier should match", identifier1.toUuid().toString(), identifier1.toUuidString());
+    }
+
     @Test
     public void testToByteArrayConvertsUuids() {
         Identifier identifier1 = Identifier.parse("2F234454-CF6D-4A0F-ADF2-F4911BA9FFA6");
@@ -73,7 +92,90 @@ public void testToByteArrayConvertsDecimal() {
         Identifier identifier1 = Identifier.parse("65534");
         byte[] bytes = identifier1.toByteArrayOfSpecifiedEndianness(true);
         assertEquals("byte array is correct length", bytes.length, 2);
+        assertEquals("reported byte array is correct length", identifier1.getByteCount(), 2);
         assertEquals("first byte of decimal converted properly", 0xff, bytes[0] & 0xFF);
         assertEquals("last byte of decimal converted properly", 0xfe, bytes[1] & 0xFF);
     }
+
+    @Test
+    public void testToByteArrayConvertsInt() {
+        Identifier identifier1 = Identifier.fromInt(65534);
+        byte[] bytes = identifier1.toByteArrayOfSpecifiedEndianness(true);
+        assertEquals("byte array is correct length", bytes.length, 2);
+        assertEquals("reported byte array is correct length", identifier1.getByteCount(), 2);
+        assertEquals("conversion back equals original value", identifier1.toInt(), 65534);
+        assertEquals("first byte of decimal converted properly", 0xff, bytes[0] & 0xFF);
+        assertEquals("last byte of decimal converted properly", 0xfe, bytes[1] & 0xFF);
+    }
+
+    @Test
+    public void testToByteArrayFromByteArray() {
+        byte[] value = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25};
+        Identifier identifier1 = Identifier.fromBytes(value, 0, value.length, false);
+        byte[] bytes = identifier1.toByteArrayOfSpecifiedEndianness(true);
+
+        assertEquals("byte array is correct length", bytes.length, 4);
+        assertEquals("correct string representation", identifier1.toString(), "0xffab1225");
+        assertTrue("arrays equal", Arrays.equals(value, bytes));
+        assertNotSame("arrays are copied", bytes, value);
+    }
+
+    @Test
+    public void testComparableDifferentLength() {
+        byte[] value1 = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25};
+        Identifier identifier1 = Identifier.fromBytes(value1, 0, value1.length, false);
+        byte[] value2 = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x11, 0x11};
+        Identifier identifier2 = Identifier.fromBytes(value2, 0, value2.length, false);
+
+        assertEquals("identifier1 is smaller than identifier2", identifier1.compareTo(identifier2), -1);
+        assertEquals("identifier2 is larger than identifier1", identifier2.compareTo(identifier1), 1);
+    }
+
+    @Test
+    public void testComparableSameLength() {
+        byte[] value1 = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x22, 0x25};
+        Identifier identifier1 = Identifier.fromBytes(value1, 0, value1.length, false);
+        byte[] value2 = new byte[] {(byte) 0xFF, (byte) 0xAB, 0x12, 0x25, 0x11, 0x11};
+        Identifier identifier2 = Identifier.fromBytes(value2, 0, value2.length, false);
+
+        assertEquals("identifier1 is equal to identifier2", identifier1.compareTo(identifier1), 0);
+        assertEquals("identifier1 is larger than identifier2", identifier1.compareTo(identifier2), 1);
+        assertEquals("identifier2 is smaller than identifier1", identifier2.compareTo(identifier1), -1);
+    }
+
+    @Test
+    public void testParseIntegerMaxInclusive() {
+        Identifier.parse("65535");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testParseIntegerAboveMax() {
+        Identifier.parse("65536");
+    }
+
+    @Test
+    public void testParseIntegerMinInclusive() {
+        Identifier.parse("0");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testParseIntegerBelowMin() {
+        Identifier.parse("-1");
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testParseIntegerWayTooBig() {
+        Identifier.parse("3133742");
+    }
+
+    /*
+     * This is here because Identifier.parse wrongly accepts UUIDs without
+     * dashes, but we want to be backward compatible.
+     */
+    @Test
+    public void testParseInvalidUuid() {
+        UUID ref = UUID.fromString("2f234454-cf6d-4a0f-adf2-f4911ba9ffa6");
+        Identifier id = Identifier.parse("2f234454cf6d4a0fadf2f4911ba9ffa6");
+        assertEquals("Malformed UUID was parsed as expected.", id.toUuid(), ref);
+    }
 }
diff --git a/src/test/java/org/altbeacon/beacon/RegionTest.java b/src/test/java/org/altbeacon/beacon/RegionTest.java
index e84b314f..a5a4affc 100644
--- a/src/test/java/org/altbeacon/beacon/RegionTest.java
+++ b/src/test/java/org/altbeacon/beacon/RegionTest.java
@@ -13,6 +13,9 @@
 import org.junit.Test;
 import org.robolectric.annotation.Config;
 
+import java.util.ArrayList;
+import java.util.Collections;
+
 @Config(emulateSdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -60,6 +63,14 @@ public void testBeaconMatchesRegionWithDifferentIdentifier1() {
         assertTrue("Beacon should not match region with first identifier different", !region.matchesBeacon(beacon));
     }
 
+    @Test
+    public void testBeaconMatchesRegionWithShorterIdentifierList() {
+        Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
+                .setBeaconTypeCode(5).setTxPower(6).setBluetoothAddress("1:2:3:4:5:6").build();
+        Region region = new Region("myRegion", Collections.singletonList(Identifier.parse("1")));
+        assertTrue("Beacon should match region with first identifier equal and shorter Identifier list", region.matchesBeacon(beacon));
+    }
+
     @Test
     public void testCanSerializeParcelable() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
@@ -82,15 +93,6 @@ public void testToString() {
         assertEquals("id1: 1 id2: 2 id3: null", region.toString());
     }
 
-    @Test
-    public void testCopyConstructor() {
-        Region region = new Region("myRegion", Identifier.parse("1"), Identifier.parse("2"), null);
-        Region region2 = new Region(region);
-        assertEquals(region, region2);
-        assertNull(region2.getId3());
-    }
-
-
     @Test
     public void testConvenienceIdentifierAccessors() {
         Region region = new Region("myRegion", Identifier.parse("1"), Identifier.parse("2"), Identifier.parse("3"));
diff --git a/src/test/java/org/altbeacon/beacon/SBeaconTest.java b/src/test/java/org/altbeacon/beacon/SBeaconTest.java
index 0f97f3e2..4353a4b2 100644
--- a/src/test/java/org/altbeacon/beacon/SBeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/SBeaconTest.java
@@ -4,9 +4,10 @@
 import android.bluetooth.BluetoothDevice;
 import android.os.Build;
 import android.os.Parcel;
-import android.util.Log;
 
 
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.logging.Loggers;
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -24,13 +25,12 @@
 
     @Test
     public void testDetectsSBeacon() {
-        BeaconManager.debug = true;
         org.robolectric.shadows.ShadowLog.stream = System.err;
         byte[] bytes = hexStringToByteArray("02011a1bff1801031501000100c502000000000000000003");
         SBeaconParser parser = new SBeaconParser();
         SBeacon sBeacon = (SBeacon) parser.fromScanData(bytes, -55, null);
         assertNotNull("SBeacon should be not null if parsed successfully", sBeacon);
-        assertEquals("id should be parsed", "000000000003", sBeacon.getId());
+        assertEquals("id should be parsed", "0x000000000003", sBeacon.getId());
         assertEquals("group should be parsed", 1, sBeacon.getGroup());
         assertEquals("time should be parsed", 2, sBeacon.getTime());
         assertEquals("txPower should be parsed", -59, sBeacon.getTxPower());
@@ -117,7 +117,7 @@ public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
                     String hexString = bytesToHex(beaconId);
                     StringBuilder sb = new StringBuilder();
                     sb.append(hexString.substring(0,12));
-                    String id = sb.toString();
+                    String id = "0x" + sb.toString();
                     int beaconTypeCode = (scanData[startByte+3] & 0xff) * 0x100 + (scanData[startByte+2] & 0xff);
 
 
diff --git a/src/test/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculatorTest.java b/src/test/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculatorTest.java
index 9f3f7d9b..afd079de 100644
--- a/src/test/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculatorTest.java
+++ b/src/test/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculatorTest.java
@@ -16,6 +16,7 @@
 import org.junit.Test;
 import org.robolectric.annotation.Config;
 
+
 @Config(emulateSdk = 18)
 @RunWith(RobolectricTestRunner.class)
 /*
diff --git a/src/test/java/org/altbeacon/beacon/logging/LogManagerTest.java b/src/test/java/org/altbeacon/beacon/logging/LogManagerTest.java
new file mode 100644
index 00000000..4f1e2280
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/logging/LogManagerTest.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+import static org.mockito.Mockito.verify;
+
+/**
+ * Tests for LogManager, ensuring correct delegation and expectations are met.
+ *
+ * @author Andrew Reitz
+ */
+public class LogManagerTest {
+
+    @Mock
+    Logger logger;
+
+    @Before
+    public void setup() {
+        MockitoAnnotations.initMocks(this);
+        LogManager.setLogger(logger);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void canNotSetNullLogger() {
+        LogManager.setLogger(null);
+    }
+
+    @Test
+    public void verbose() {
+        String tag = "TestTag";
+        String message = "Test message";
+
+        LogManager.v(tag, message);
+
+        verify(logger).v(tag, message);
+    }
+
+    @Test
+    public void verboseWithThrowable() {
+        String tag = "TestTag";
+        String message = "Test message";
+        Throwable t = new Throwable();
+
+        LogManager.v(t, tag, message);
+
+        verify(logger).v(t, tag, message);
+    }
+
+    @Test
+    public void debug() {
+        String tag = "TestTag";
+        String message = "Test message";
+
+        LogManager.d(tag, message);
+
+        verify(logger).d(tag, message);
+    }
+
+    @Test
+    public void debugWithThrowable() {
+        String tag = "TestTag";
+        String message = "Test message";
+        Throwable t = new Throwable();
+
+        LogManager.d(t, tag, message);
+
+        verify(logger).d(t, tag, message);
+    }
+
+    @Test
+    public void info() {
+        String tag = "TestTag";
+        String message = "Test message";
+
+        LogManager.i(tag, message);
+
+        verify(logger).i(tag, message);
+    }
+
+    @Test
+    public void infoWithThrowable() {
+        String tag = "TestTag";
+        String message = "Test message";
+        Throwable t = new Throwable();
+
+        LogManager.i(t, tag, message);
+
+        verify(logger).i(t, tag, message);
+    }
+
+    @Test
+    public void warning() {
+        String tag = "TestTag";
+        String message = "Test message";
+
+        LogManager.w(tag, message);
+
+        verify(logger).w(tag, message);
+    }
+
+    @Test
+    public void warningWithThrowable() {
+        String tag = "TestTag";
+        String message = "Test message";
+        Throwable t = new Throwable();
+
+        LogManager.w(t, tag, message);
+
+        verify(logger).w(t, tag, message);
+    }
+
+    @Test
+    public void error() {
+        String tag = "TestTag";
+        String message = "Test message";
+
+        LogManager.e(tag, message);
+
+        verify(logger).e(tag, message);
+    }
+
+    @Test
+    public void errorWithThrowable() {
+        String tag = "TestTag";
+        String message = "Test message";
+        Throwable t = new Throwable();
+
+        LogManager.e(t, tag, message);
+
+        verify(logger).e(t, tag, message);
+    }
+}
diff --git a/src/test/java/org/altbeacon/beacon/logging/LoggersTest.java b/src/test/java/org/altbeacon/beacon/logging/LoggersTest.java
new file mode 100644
index 00000000..80a38880
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/logging/LoggersTest.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import org.junit.Test;
+
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.sameInstance;
+import static org.junit.Assert.assertThat;
+
+/**
+ * Ensure correct instances are returned from factory methods.
+ *
+ * @author Andrew Reitz
+ */
+public class LoggersTest {
+    @Test
+    public void loggersReturnsVerboseInstance() {
+        Logger logger = Loggers.verboseLogger();
+
+        assertThat(logger, instanceOf(VerboseAndroidLogger.class));
+    }
+
+    @Test
+    public void verboseLoggerReturnsSameInstance() {
+        Logger logger1 = Loggers.verboseLogger();
+        Logger logger2 = Loggers.verboseLogger();
+
+        assertThat(logger1, sameInstance(logger2));
+    }
+
+    @Test
+    public void loggersReturnsEmptyInstance() {
+        Logger logger = Loggers.empty();
+
+        assertThat(logger, instanceOf(EmptyLogger.class));
+    }
+
+    @Test
+    public void emptyLoggerReturnsSameInstance() {
+        Logger logger1 = Loggers.empty();
+        Logger logger2 = Loggers.empty();
+
+        assertThat(logger1, sameInstance(logger2));
+    }
+
+    @Test
+    public void loggersReturnsWarningLoggerInstance() {
+        Logger logger = Loggers.warningLogger();
+
+        assertThat(logger, instanceOf(WarningAndroidLogger.class));
+    }
+
+    @Test
+    public void warningLoggerReturnsSameInstance() {
+        Logger logger1 = Loggers.warningLogger();
+        Logger logger2 = Loggers.warningLogger();
+
+        assertThat(logger1, sameInstance(logger2));
+    }
+}
diff --git a/src/test/java/org/altbeacon/beacon/logging/VerboseAndroidLoggerTest.java b/src/test/java/org/altbeacon/beacon/logging/VerboseAndroidLoggerTest.java
new file mode 100644
index 00000000..aacc5e49
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/logging/VerboseAndroidLoggerTest.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
+
+import static android.util.Log.DEBUG;
+import static android.util.Log.ERROR;
+import static android.util.Log.INFO;
+import static android.util.Log.VERBOSE;
+import static android.util.Log.WARN;
+import static junit.framework.Assert.assertEquals;
+
+/**
+ * Ensure the verbose logger logs correctly.
+ *
+ * @author Andrew Reitz
+ */
+@Config(emulateSdk = 18)
+@RunWith(RobolectricTestRunner.class)
+public class VerboseAndroidLoggerTest {
+    private String tag = getClass().getName();
+    private Logger logger = new VerboseAndroidLogger();
+
+    @Test
+    public void verboseLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+
+        logger.v(tag, "Hello %s", "World");
+
+        assertLogged(VERBOSE, tag, expectedMessage, null);
+    }
+
+    @Test
+    public void verboseWithThrowableLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.v(t, tag, "Hello %s", "World");
+
+        assertLogged(VERBOSE, tag, expectedMessage, t);
+    }
+
+    @Test
+    public void debugLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+
+        logger.d(tag, "Hello %s", "World");
+
+        assertLogged(DEBUG, tag, expectedMessage, null);
+    }
+
+    @Test
+    public void debugWithThrowableLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.d(t, tag, "Hello %s", "World");
+
+        assertLogged(DEBUG, tag, expectedMessage, t);
+    }
+
+    @Test
+    public void infoLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+
+        logger.v(tag, "Hello %s", "World");
+
+        assertLogged(VERBOSE, tag, expectedMessage, null);
+    }
+
+    @Test
+    public void infoWithThrowableLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.i(t, tag, "Hello %s", "World");
+
+        assertLogged(INFO, tag, expectedMessage, t);
+    }
+
+    @Test
+    public void warningLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+
+        logger.w(tag, "Hello %s", "World");
+
+        assertLogged(WARN, tag, expectedMessage, null);
+    }
+
+    @Test
+    public void warningWithThrowableLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.w(t, tag, "Hello %s", "World");
+
+        assertLogged(WARN, tag, expectedMessage, t);
+    }
+
+    @Test
+    public void errorLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+
+        logger.e(tag, "Hello %s", "World");
+
+        assertLogged(ERROR, tag, expectedMessage, null);
+    }
+
+    @Test
+    public void errorWithThrowableLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.e(t, tag, "Hello %s", "World");
+
+        assertLogged(ERROR, tag, expectedMessage, t);
+    }
+
+    private void assertLogged(int type, String tag, String msg, Throwable throwable) {
+        ShadowLog.LogItem lastLog = ShadowLog.getLogs().get(0);
+        assertEquals(type, lastLog.type);
+        assertEquals(msg, lastLog.msg);
+        assertEquals(tag, lastLog.tag);
+        assertEquals(throwable, lastLog.throwable);
+    }
+}
diff --git a/src/test/java/org/altbeacon/beacon/logging/WarningAndroidLoggerTest.java b/src/test/java/org/altbeacon/beacon/logging/WarningAndroidLoggerTest.java
new file mode 100644
index 00000000..eaa4a8f0
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/logging/WarningAndroidLoggerTest.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import org.hamcrest.Matchers;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLog;
+
+import java.util.List;
+
+import static android.util.Log.DEBUG;
+import static android.util.Log.ERROR;
+import static android.util.Log.INFO;
+import static android.util.Log.VERBOSE;
+import static android.util.Log.WARN;
+import static junit.framework.Assert.assertEquals;
+import static org.hamcrest.Matchers.empty;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertThat;
+
+/**
+ * Ensure the warning logger logs correctly.
+ *
+ * @author Andrew Reitz
+ */
+@Config(emulateSdk = 18)
+@RunWith(RobolectricTestRunner.class)
+public class WarningAndroidLoggerTest {
+    private String tag = getClass().getName();
+    private Logger logger = new WarningAndroidLogger();
+
+    @Test
+    public void verboseNotLogged() {
+        logger.v(tag, "Hello %s", "World");
+
+        assertNotLogged();
+    }
+
+    @Test
+    public void verboseWithThrowableNotLogged() {
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.v(t, tag, "Hello %s", "World");
+
+        assertNotLogged();
+    }
+
+    @Test
+    public void debugNotLogged() {
+        String expectedTag = "TestTag";
+
+        logger.d(expectedTag, "Hello %s", "World");
+
+        assertNotLogged();
+    }
+
+    @Test
+    public void debugWithThrowableNotLogged() {
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.d(t, tag, "Hello %s", "World");
+
+        assertNotLogged();
+    }
+
+    @Test
+    public void infoNotLogged() {
+        String expectedTag = "TestTag";
+
+        logger.v(expectedTag, "Hello %s", "World");
+
+        assertNotLogged();
+    }
+
+    @Test
+    public void infoWithThrowableNotLogged() {
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.i(t, tag, "Hello %s", "World");
+
+        assertNotLogged();
+    }
+
+    @Test
+    public void warningLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+
+        logger.w(tag, "Hello %s", "World");
+
+        assertLogged(WARN, tag, expectedMessage, null);
+    }
+
+    @Test
+    public void warningWithThrowableLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.w(t, tag, "Hello %s", "World");
+
+        assertLogged(WARN, tag, expectedMessage, t);
+    }
+
+    @Test
+    public void errorLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+
+        logger.e(tag, "Hello %s", "World");
+
+        assertLogged(ERROR, tag, expectedMessage, null);
+    }
+
+    @Test
+    public void errorWithThrowableLoggedCorrectly() {
+        String expectedMessage = "Hello World";
+        Throwable t = new Throwable("Test Throwable");
+
+        logger.e(t, tag, "Hello %s", "World");
+
+        assertLogged(ERROR, tag, expectedMessage, t);
+    }
+
+    private void assertLogged(int type, String tag, String msg, Throwable throwable) {
+        ShadowLog.LogItem lastLog = ShadowLog.getLogs().get(0);
+        assertEquals(type, lastLog.type);
+        assertEquals(msg, lastLog.msg);
+        assertEquals(tag, lastLog.tag);
+        assertEquals(throwable, lastLog.throwable);
+    }
+
+    private void assertNotLogged() {
+        final List<ShadowLog.LogItem> logs = ShadowLog.getLogs();
+        assertThat(logs, empty());
+    }
+}
diff --git a/src/test/java/org/altbeacon/beacon/service/ArmaRssiFilterTest.java b/src/test/java/org/altbeacon/beacon/service/ArmaRssiFilterTest.java
new file mode 100644
index 00000000..43fe7456
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/ArmaRssiFilterTest.java
@@ -0,0 +1,21 @@
+package org.altbeacon.beacon.service;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(emulateSdk = 18)
+
+public class ArmaRssiFilterTest {
+
+    @Test
+    public void initTest1() {
+        ArmaRssiFilter filter = new ArmaRssiFilter();
+        filter.addMeasurement(-50);
+        assertEquals("First measurement should be -50", String.valueOf(filter.calculateRssi()), "-50.0");
+    }
+
+}
diff --git a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
new file mode 100644
index 00000000..e105ba52
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
@@ -0,0 +1,20 @@
+package org.altbeacon.beacon.service;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(emulateSdk = 18)
+
+public class RunningAverageRssiFilterTest {
+
+    @Test
+    public void initTest1() {
+        RunningAverageRssiFilter filter = new RunningAverageRssiFilter();
+        filter.addMeasurement(-50);
+        assertEquals("First measurement should be -50", String.valueOf(filter.calculateRssi()), "-50.0");
+    }
+}
