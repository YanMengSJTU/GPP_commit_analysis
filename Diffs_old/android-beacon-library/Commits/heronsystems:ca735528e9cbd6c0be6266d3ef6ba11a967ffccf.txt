diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index a0a9a674..1964cbf0 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -31,6 +31,7 @@
 import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
+import android.os.Build;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
@@ -320,6 +321,8 @@ protected BeaconManager(@NonNull Context context) {
            verifyServiceDeclaration();
          }
         this.beaconParsers.add(new AltBeaconParser());
+        // TODO: Change this to >= Build.VERSION_CODES.O when the SDK is released
+        mScheduledScanJobsEnabled = android.os.Build.VERSION.SDK_INT > Build.VERSION_CODES.N;
     }
 
     /***
@@ -408,12 +411,6 @@ public void bind(@NonNull BeaconConsumer consumer) {
             consumer.onBeaconServiceConnect();
             return;
         }
-        if (mScheduledScanJobsEnabled) {
-            LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
-            consumer.onBeaconServiceConnect();
-            return;
-        }
-
         synchronized (consumers) {
             ConsumerInfo newConsumerInfo = new ConsumerInfo();
             ConsumerInfo alreadyBoundConsumerInfo = consumers.putIfAbsent(consumer, newConsumerInfo);
@@ -525,11 +522,39 @@ public void setBackgroundMode(boolean backgroundMode) {
             }
         }
     }
+
+    /**
+     * Configures using a `ScanJob` run with the `JobScheduler` to perform scans rather than using a
+     * long-running `BeaconService` to do so.
+     *
+     * Calling with true on devices older than Android L (5.0) will not apply the change
+     * as the JobScheduler is not available.
+     *
+     * This value defaults to true on Android O+ and false on devices with older OS versions.
+     * Accepting the default value of false is recommended on Android N and earlier because
+     * otherwise beacon scans may be run only once every 15 minutes in the background, and no low
+     * power scans may be performed between scanning cycles.
+     *
+     * This method may only be called if bind() has not yet been called, otherwise an
+     * `IllegalStateException` is thown.
+     *
+     * @param enabled
+     */
     public void setEnableScheduledScanJobs(boolean enabled) {
-        this.mScheduledScanJobsEnabled = enabled;
+        if (isAnyConsumerBound()) {
+            LogManager.e(TAG, "ScanJob may not be configured because a consumer is" +
+                    " already bound.");
+            throw new IllegalStateException("Method must be called before calling bind()");
+        }
+        if (enabled && android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            LogManager.e(TAG, "ScanJob may not be configured because JobScheduler is not" +
+                    " availble prior to Android 5.0");
+            return;
+        }
+        mScheduledScanJobsEnabled = enabled;
     }
     public boolean getScheduledScanJobsEnabled() {
-        return this.mScheduledScanJobsEnabled;
+        return mScheduledScanJobsEnabled;
     }
     public boolean getBackgroundMode() {
         return mBackgroundMode;
@@ -775,17 +800,7 @@ public void startRangingBeaconsInRegion(@NonNull Region region) throws RemoteExc
         synchronized (rangedRegions) {
             rangedRegions.add(region);
         }
-        if (mScheduledScanJobsEnabled) {
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-        }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
-        }
+        applyChangesToServices(BeaconService.MSG_START_RANGING, region);
     }
 
     /**
@@ -816,17 +831,7 @@ public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteExce
             }
             rangedRegions.remove(regionToRemove);
         }
-        if (mScheduledScanJobsEnabled) {
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-        }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
-        }
+        applyChangesToServices(BeaconService.MSG_STOP_RANGING, region);
     }
 
     /**
@@ -853,18 +858,10 @@ protected void syncSettingsToService() {
             ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
             return;
         }
-        if (serviceMessenger == null) {
-            LogManager.e(TAG, "The BeaconManager is not bound to the service.  Settings synchronization will fail.");
-            return;
-        }
-        else {
-            try {
-                Message msg = Message.obtain(null, BeaconService.MSG_SYNC_SETTINGS, 0, 0);
-                msg.setData(new SettingsData().collect(mContext).toBundle());
-                serviceMessenger.send(msg);
-            } catch (RemoteException e) {
-                LogManager.e(TAG, "Failed to sync settings to service", e);
-            }
+        try {
+            applyChangesToServices(BeaconService.MSG_SYNC_SETTINGS, null);
+        } catch (RemoteException e) {
+            LogManager.e(TAG, "Failed to sync settings to service", e);
         }
     }
 
@@ -890,17 +887,9 @@ public void startMonitoringBeaconsInRegion(@NonNull Region region) throws Remote
         }
         if (mScheduledScanJobsEnabled) {
             MonitoringStatus.getInstanceForApplication(mContext).addRegion(region, new Callback(callbackPackageName()));
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-        }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
-            Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
         }
+        applyChangesToServices(BeaconService.MSG_START_MONITORING, region);
+
         if (isScannerInDifferentProcess()) {
             MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
         }
@@ -929,22 +918,13 @@ public void stopMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteE
         }
         if (mScheduledScanJobsEnabled) {
             MonitoringStatus.getInstanceForApplication(mContext).removeRegion(region);
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-        }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
         }
+        applyChangesToServices(BeaconService.MSG_STOP_MONITORING, region);
         if (isScannerInDifferentProcess()) {
             MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
         }
     }
 
-
     /**
      * Updates an already running scan with scanPeriod/betweenScanPeriod according to Background/Foreground state.
      * Change will take effect on the start of the next scan cycle.
@@ -962,17 +942,29 @@ public void updateScanPeriods() throws RemoteException {
         }
         LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
         LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
+        applyChangesToServices(BeaconService.MSG_SET_SCAN_PERIODS, null);
+    }
+
+    @TargetApi(18)
+    private void applyChangesToServices(int type, Region region) throws RemoteException {
         if (mScheduledScanJobsEnabled) {
             ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            return;
         }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
+        if (serviceMessenger == null) {
+            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        }
+        Message msg = Message.obtain(null, type, 0, 0);
+        if (type == BeaconService.MSG_SET_SCAN_PERIODS) {
             msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
         }
+        else if (type == BeaconService.MSG_SYNC_SETTINGS) {
+            msg.setData(new SettingsData().collect(mContext).toBundle());
+        }
+        else {
+            msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(), mBackgroundMode).toBundle());
+        }
+        serviceMessenger.send(msg);
     }
 
     private String callbackPackageName() {
@@ -1206,7 +1198,7 @@ private void verifyServiceDeclaration() {
         List<ResolveInfo> resolveInfo =
                 packageManager.queryIntentServices(intent,
                         PackageManager.MATCH_DEFAULT_ONLY);
-        if (resolveInfo != null && resolveInfo.size() == 0) {
+        if (resolveInfo != null && resolveInfo.isEmpty()) {
             throw new ServiceNotDeclaredException();
         }
     }
