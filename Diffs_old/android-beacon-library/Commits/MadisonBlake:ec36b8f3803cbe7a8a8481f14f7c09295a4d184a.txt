diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..9e00ee1d
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,209 @@
+### Development
+
+Enhancements:
+
+- Don't restart BLE scanning periodically if the library confrims device can detect duplicate
+  advertisements in a single scan, leading to more reliable detections with short scan cycles
+  (#491, David G. Young)
+
+Bug Fixes:
+
+- Deprecate misspelled methods `removeMonitoreNotifier` and
+  `setRegionStatePeristenceEnabled` in favor of correctly spelled alternatives.
+  (#461, Marco Salis)
+- Fix bug causing brief scan dropouts after starting a scan after a long period
+  of inactivity (i.e. startup and background-foreground transitions) due to
+  Android N scan limits (#489, Aaron Kromer)
+- Ensure thread safety for singleton creation of `BeaconManager`,
+  `DetectionTracker`, `MonitoringStatus`, and `Stats`. (#494, Aaron Kromer)
+
+
+### 2.9.2 / 2016-11-22
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9.1...2.9.2)
+
+Bug Fixes:
+
+- Provide access to monitored regions after restoring state (#456, David G.
+  Young)
+- Don't start or stop scans if bluetooth state is off to prevent crashes on HTC
+  devices (#452, David G. Young)
+- Protect against SecurityException crashes caused by Samsung Knox (#444, David
+  G. Young)
+- No Monitoring information after killing an application built with the minify
+  mode (#432, ost-ct)
+- Start and stop BLE scans from a background thread to prevent blocking the UI
+  (#430, Marco Salis)
+- Prevent flapping (rapid exit then enter) of restored monitored regions (#426,
+  Elias Lecomte)
+- Don't implicitly require bluetooth in manifest (Commit b3ac622e2b, David G.
+  Young)
+
+
+### 2.9.1 / 2016-08-26
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9...2.9.1)
+
+Bug Fixes:
+
+- Fixes spurious entry/exit events on Android N caused by OS imposed limits of
+  5 scans every 30 seconds. (#419, David G. Young)
+
+
+### 2.9 / 2016-07-25
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.8.1...2.9)
+
+Enhancements:
+
+- Multiple ranging and monitoring notifiers are supported via
+  `BeaconManger#addRangeNotifier(RangeNotifier notifier)` and
+  `BeaconManger#addMonitorNotifier(MonitorNotifier notifier)` (#392, ost-ct)
+- App bootstrap regions by be dynamically changed with
+  new`RegionBootstrap#removeRegion(Region region)` and
+  `RegionBootstrap#addRegion(Region region)` methods. (#369, Aristide)
+- Improved region state behavior by adding
+  `BeaconManager#requestStateForRegion(Region)` and
+  `BeaconManager#setRegionStatePeristenceEnabled(boolean)` (#405, David G.
+  Young)
+- Added a guaranteed callback to
+  `MonitorNotifier#didDetermineStateForRegion(int state, Region region)` when
+  starting monitoring.  At app startup, this returns the previously known
+  persisted state. (#405, David G. Young)
+- Custom distance calculation for Moto X 2nd gen XT1092 (#386, Clément Garcia)
+- More flexible support for combining multi-frame beacons with
+  `Beacon#getExtraDataFields()` (#387, mfatiga)
+
+Bug Fixes:
+
+- Eddystone frame detection on Google's Android BeaconTools and Chrome fixed by
+  adding missing service UUID PDU. (#401, David G. Young)
+- Beacon data fields of over four bytes are now be parsed correctly. (#373,
+  Junsung Lim)
+- Region persistence app freezes resolved by limiting persisted regions to 50
+  (#405, David G. Young)
+- Fixed inability to starting monitoring for a different Region definition with
+  the same uniqueId (#405, David G. Young)
+- Fixes Eddystone-URL layout to support the full 17 bytes for URLs (uses 18
+  bytes total: 1 byte for schema and 17 bytes for URL) (#377, Mario Pucci)
+- Fix potential context leak in `BeaconManager` (#381, Ovidiu Latcu)
+
+
+### 2.8.1 / 2016-04-18
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.8...2.8.1)
+
+Bug Fixes:
+
+- As of the 2.8 release, scanning would never start on Android 4.x devices
+  unless the application manually added ACCESS_COARSE_LOCATION or
+  ACCESS_FINE_LOCATION permissions to the AndroidManifest.xml. This fix makes
+  it so this is not required for 4.x devices, as was the case prior to 2.8.
+  (#365, David G. Young)
+
+
+### 2.8 / 2016-03-28
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.7.1...2.8)
+
+Enhancements:
+
+- Retains monitored regions across service restarts, preventing apps from
+  getting multiple region entry callbacks each time the service restarts.
+  (#315, Mateusz Sarzyński)
+- Add string identifier to BeaconParser which can be referenced by decoded
+  Beacon object, allowing easy determination of beacon type. (#333, David G.
+  Young)
+- Switch to using ELAPSED_REALTIME clocks, so scanning doesn't stop on devices
+  without a battery-backed RTC (#339, Luca Niccoli)
+- Add ability to access raw EDDYSTONE_TLM data for sending info to Google
+  services. (#328, David G. Young)
+- New distance formula for Moto X Pro (#330, David G. Young)
+- Adjust the BackgroundPowerSaver so it accepts any context (#355, Kristof
+  Snyers)
+- Add support for pre-Eddystone UriBeacon layout (#358, David G. Young)
+
+Bug Fixes:
+
+- Multiple consumers of the BeaconService will now each get a
+  onBeaconServiceConnected() callback. (#340, Mateusz Sarzyński)
+- Don't scan for bluetooth devices if permission has not been granted in
+  Android 6. This prevents large number of exceptions in the log. (#327, Alex
+  Urzhumtcev)
+- Fix crash on beacon parsing comparison overrun (#324, David G. Young)
+
+
+### 2.7.1 / 2015-11-17
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.7...2.7.1)
+
+Bug Fixes:
+
+- Stopping and starting monitoring disables scans (#317, David G. Young)
+
+
+### 2.7 / 2015-11-12
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.6.1...2.7)
+
+Enhancements:
+
+- Adds hardware accelerated detection of Eddystone frames in the background on
+  Android 5+ (#314, David G. Young)
+- Provides ability to forward BLE scan callbacks for non-beacon advertisements
+  (#267, Paul Peavyhouse)
+
+Bug Fixes:
+
+- Fix rescheduling of alarms in the distant future so they don't inadvertently
+  go off right away (#312, Mateusz Sarzyński)
+- Only request `ACCESS_COARSE_LOCATION` permission on Android M (#296, Henning
+  Dodenhof)
+
+
+### 2.6.1 / 2015-09-30
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.6...2.6.1)
+
+Bug Fixes:
+
+- Allow Regions to match beacons with fewer identifiers if the extra region
+  identifiers are null. This allows matching Eddystone-UID and Eddystone-URL
+  beacon with the default Region with three null identifiers. This started
+  failing in version 2.6. (#295, David G. Young)
+- Declare the `ACCESS_COARSE_LOCATION` permission in the manifest since it is
+  required for Android 6.0. This is helpful to keep beacon detection working on
+  Android 6.0 for apps that don't explicitly declare this in their own
+  manifest. (#295, David G. Young)
+
+
+### 2.6 / 2015-09-29
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.5.1...2.6)
+
+Enhancements:
+
+- Make region exit period configuration with a default of ten seconds (#283,
+  Alex Urzhumtcev)
+- When scanning in Background on Android 5+, do a full scan without filters
+  during the main scan period (default for 10 seconds once every 5 minutes) in
+  case scan filters are unavailable (#293, David G. Young)
+- Common open-source BeaconParser layouts are defined as constants on
+  BeaconParser (Commit 0101970010, David G. Young)
+- Bluetooth address is now a field on Region, offering the option of monitoring
+  and ranging for all beacon transmissions from a known device's MAC Address
+  (#254, David G. Young)
+- Target SDK bumped to 23 for Android 6.0 (#293, David G. Young)
+
+Bug Fixes:
+
+- Fix potential `ConcurrentModificationException` with distance calculation
+  (#245, Dawid Drozd)
+- Fix potential `NullPointerException` in `Beacon#hashCode` (#249, Sam Yang)
+- Switch BeaconParsers list to be a `CopyOnWriteArrayList` to avoid
+  `UnsupportedOperationException` changing list after starting scanning. (#290,
+  Matthew Michihara)
+- Fix crash when region has more identifiers than beacon (#252, David G. Young)
+- Fix bugs with compressing Eddystone-URL to bytes and back (#263, Michael
+  Harper)
+
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 63114dce..a87a54f1 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,30 +1,30 @@
-#How to Contribute to the Android Beacon Library
+# How to Contribute to the Android Beacon Library
 
-This project welcomes code contributions from the community.  Proposed code changes should be submitted as a pull request on Github.  Please follow the following guidelines when submitting a [pull request](https://github.com/altbeacon/android-beacon-library/pulls).
+This project welcomes code contributions from the communityProposed code changes should be submitted as a pull request on Github. Please follow the following guidelines when submitting a [pull request](https://github.com/altbeacon/android-beacon-library/pulls).
 
-##Style
+## Style
 
 Code style should generally follow the [Android coding style](https://source.android.com/source/code-style.html)
 
-##API Changes
+## API Changes
 
-Changes generally should not break the existing API and should be backward compatible with the current release version.   If the PR does represent a breaking change, the title or description must make this clear.  Breaking changes will be held for the next major version release of the library.
+Changes generally should not break the existing API and should be backward compatible with the current release version If the PR does represent a breaking change, the title or description must make this clear. Breaking changes will be held for the next major version release of the library.
 
-##Testing
+## Testing
 
-PRs must include testing information to ensure the changes are functional and do not adversely affect other library functions.  Testing information must include one or more of the following:
+PRs must include testing information to ensure the changes are functional and do not adversely affect other library functionsTesting information must include one or more of the following:
 
-###1. Automated Robolectric tests:
+### 1. Automated Robolectric tests:
 
-Robolectric tests are required for most changes, and should be submitted along with the PR.  Exceptions include Bluetooth or Android OS-level changes that cannot be tested with Robolectric.  Examples of Robolectric tests exist in the src/test folder.
+Robolectric tests are required for most changes, and should be submitted along with the PRExceptions include Bluetooth or Android OS-level changes that cannot be tested with Robolectric. Examples of Robolectric tests exist in the src/test folder.
 
-Robolectric test updates are absolutely required if existing Robolectric tests exists for the modified code. 
+Robolectric test updates are absolutely required if existing Robolectric tests exists for the modified code.
 
 Regardless of whether Robolectric tests are added or modified, all tests must be passing on the branch of the PR when running `./gradlew test `
 
-###2. Manual tests:
+### 2. Manual tests:
 
-Changes affecting Bluetooth scanning, addressing device-specific issues often cannot be adequately tested using Robolectric since it stubs out Bluetooth and Android OS system calls.  Changes of this nature must be manually tested on a physical device.  Manual tests should be performed with the library's reference application, if possible.
+Changes affecting Bluetooth scanning, addressing device-specific issues often cannot be adequately tested using Robolectric since it stubs out Bluetooth and Android OS system callsChanges of this nature must be manually tested on a physical device. Manual tests should be performed with the library's reference application, if possible.
 
 When submitting a PR, a description of any manual testing performed should include:
 
@@ -36,10 +36,10 @@ When submitting a PR, a description of any manual testing performed should inclu
 
 * A description of the conditions witnessed that verify the code works as designed and that other functions are not broken
 
-###3. Changes that cannot be tested manually or with Robolectric
+### 3. Changes that cannot be tested manually or with Robolectric
 
-In some rare cases where changes cannot be verified manually (e.g. some intermittent issues), a description may be included of why testing cannot be performed and describing why the change is low-risk and can be verified by code review.  For such changes to be considered low-risk they typically must be very small
+In some rare cases where changes cannot be verified manually (e.g. some intermittent issues), a description may be included of why testing cannot be performed and describing why the change is low-risk and can be verified by code reviewFor such changes to be considered low-risk they typically must be very small
 
-##License
+## License
 
-Any code submitted must be the work of the author, or if third party must be covered by the same Apache 2 license as this library or the Android Open Source Project.  Once submitted, the code is covered under the terms of the license of this library.
+Any code submitted must be the work of the author, or if third party must be covered by the same Apache 2 license as this library or the Android Open Source ProjectOnce submitted, the code is covered under the terms of the license of this library.
diff --git a/build.gradle b/build.gradle
index 5a675958..ac54f10a 100644
--- a/build.gradle
+++ b/build.gradle
@@ -28,8 +28,8 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.5.0'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'
+        classpath 'com.android.tools.build:gradle:2.3.0'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3'
     }
 }
@@ -49,7 +49,7 @@ allprojects {
 
 android {
     compileSdkVersion 24
-    buildToolsVersion "24.0.2"
+    buildToolsVersion "25.0.2"
 
     defaultConfig {
         minSdkVersion 7
@@ -66,12 +66,6 @@ android {
         targetCompatibility JavaVersion.VERSION_1_7
     }
 
-    sourceSets {
-        androidTest {
-            setRoot('src/test')
-        }
-    }
-
     lintOptions {
         abortOnError false
     }
@@ -82,42 +76,25 @@ android {
         exclude 'META-INF/LICENSE.txt'
         exclude 'META-INF/NOTICE'
     }
-
 }
 
 dependencies {
     compile fileTree ( dir: 'libs', include: ['*.jar'] )
-    testCompile 'org.hamcrest:hamcrest-integration:1.3'
-    testCompile 'org.hamcrest:hamcrest-core:1.3'
-    testCompile 'org.hamcrest:hamcrest-library:1.3'
+    compile 'com.android.support:support-annotations:24.2.1'
 
     testCompile('junit:junit:4.12') {
-        exclude module: 'hamcrest-core'
+        exclude group: 'org.hamcrest'
     }
-    testCompile('com.squareup:fest-android:1.0.+@aar') {
-        exclude group: 'com.android.support', module: 'support-v4'
+    testCompile('org.hamcrest:hamcrest-junit:2.0.0.0') {
+        exclude group: 'junit'
     }
-
+    testCompile('com.squareup:fest-android:1.0.+@aar')
     testCompile('org.robolectric:robolectric:3.0') {
-        exclude module: 'classworlds'
-        exclude module: 'commons-logging'
-        exclude module: 'httpclient'
-        exclude module: 'maven-artifact'
-        exclude module: 'maven-artifact-manager'
-        exclude module: 'maven-error-diagnostics'
-        exclude module: 'maven-model'
-        exclude module: 'maven-project'
-        exclude module: 'maven-settings'
-        exclude module: 'plexus-container-default'
-        exclude module: 'plexus-interpolation'
-        exclude module: 'plexus-utils'
-        exclude module: 'wagon-file'
-        exclude module: 'wagon-http-lightweight'
-        exclude module: 'wagon-provider-api'
-        exclude group: 'com.android.support', module: 'support-v4'
-    }
-
-    testCompile 'org.mockito:mockito-core:1.10.19'
+        exclude group: 'junit'
+    }
+    testCompile('org.mockito:mockito-core:1.10.19') {
+        exclude group: 'org.hamcrest'
+    }
 }
 
 apply plugin: 'idea'
diff --git a/circle.yml b/circle.yml
index 50eb8479..dc4aa38b 100644
--- a/circle.yml
+++ b/circle.yml
@@ -3,5 +3,5 @@ machine:
     version: openjdk8
 dependencies:
   pre:
-    - echo y | android update sdk --no-ui --all --filter "tools,android-24,build-tools-24.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
+    - echo y | android update sdk --no-ui --all --filter "tools,android-24,build-tools-25.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 2944df68..388ee27b 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat May 10 23:17:01 CDT 2014
+#Sat Apr 01 10:19:45 EDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/ibeacon-service-android.iml b/ibeacon-service-android.iml
deleted file mode 100644
index fd696913..00000000
--- a/ibeacon-service-android.iml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.system.id="GRADLE" type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/classes/main" />
-    <output-test url="file://$MODULE_DIR$/build/classes/test" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="1.6" jdkType="JavaSDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
-
diff --git a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
index a0ace8a0..7e98d225 100644
--- a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
@@ -23,7 +23,6 @@
  */
 package org.altbeacon.beacon;
 
-import android.annotation.TargetApi;
 import android.bluetooth.BluetoothDevice;
 import android.util.Log;
 
@@ -63,7 +62,6 @@ public AltBeaconParser() {
      * @param device The Bluetooth device that was detected
      * @return An instance of an <code>Beacon</code>
      */
-    @TargetApi(5)
     @Override
     public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
         return fromScanData(scanData, rssi, device, new AltBeacon());
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index 35cfd9ea..e49c232a 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -228,9 +228,6 @@ protected Beacon(Parcel in) {
             mDataFields.add(in.readLong());
         }
         int extraDataSize = in.readInt();
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG, "reading "+extraDataSize+" extra data fields from parcel");
-        }
         this.mExtraDataFields = new ArrayList<Long>(extraDataSize);
         for (int i = 0; i < extraDataSize; i++) {
             mExtraDataFields.add(in.readLong());
@@ -535,7 +532,6 @@ public int describeContents() {
      */
     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mIdentifiers.size());
-        LogManager.d(TAG, "serializing identifiers of size %s", mIdentifiers.size());
         for (Identifier identifier: mIdentifiers) {
             out.writeString(identifier == null ? null : identifier.toString());
         }
@@ -549,9 +545,6 @@ public void writeToParcel(Parcel out, int flags) {
         for (Long dataField: mDataFields) {
             out.writeLong(dataField);
         }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG, "writing "+mExtraDataFields.size()+" extra data fields to parcel");
-        }
         out.writeInt(mExtraDataFields.size());
         for (Long dataField: mExtraDataFields) {
             out.writeLong(dataField);
diff --git a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index 7b3c74ba..a3968df4 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -23,7 +23,6 @@
  */
 package org.altbeacon.beacon;
 
-import android.annotation.TargetApi;
 import android.app.IntentService;
 import android.content.Intent;
 
@@ -36,7 +35,6 @@
 /**
  * Converts internal intents to notifier callbacks
  */
-@TargetApi(3)
 public class BeaconIntentProcessor extends IntentService {
     private static final String TAG = "BeaconIntentProcessor";
 
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index df8deb40..46028bf7 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -105,11 +105,10 @@
  * @author David G. Young
  * @author Andrew Reitz <andrew@andrewreitz.com>
  */
-@TargetApi(4)
 public class BeaconManager {
     private static final String TAG = "BeaconManager";
     private Context mContext;
-    protected static BeaconManager client = null;
+    protected static volatile BeaconManager client = null;
     private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<BeaconConsumer,ConsumerInfo>();
     private Messenger serviceMessenger = null;
     protected final Set<RangeNotifier> rangeNotifiers = new CopyOnWriteArraySet<>();
@@ -124,6 +123,11 @@
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
 
+    /**
+     * Private lock object for singleton initialization protecting against denial-of-service attack.
+     */
+    private static final Object SINGLETON_LOCK = new Object();
+
     /**
      * Set to true if you want to show library debugging.
      *
@@ -278,11 +282,29 @@ public static long getRegionExitPeriod(){
      * or non-Service class, you can attach it to another singleton or a subclass of the Android Application class.
      */
     public static BeaconManager getInstanceForApplication(Context context) {
-        if (client == null) {
-            LogManager.d(TAG, "BeaconManager instance creation");
-            client = new BeaconManager(context);
+        /*
+         * Follow double check pattern from Effective Java v2 Item 71.
+         *
+         * Bloch recommends using the local variable for this for performance reasons:
+         *
+         * > What this variable does is ensure that `field` is read only once in the common case
+         * > where it's already initialized. While not strictly necessary, this may improve
+         * > performance and is more elegant by the standards applied to low-level concurrent
+         * > programming. On my machine, [this] is about 25 percent faster than the obvious
+         * > version without a local variable.
+         *
+         * Joshua Bloch. Effective Java, Second Edition. Addison-Wesley, 2008. pages 283-284
+         */
+        BeaconManager instance = client;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = client;
+                if (instance == null) {
+                    client = instance = new BeaconManager(context);
+                }
+            }
         }
-        return client;
+        return instance;
     }
 
    protected BeaconManager(Context context) {
@@ -310,17 +332,10 @@ protected BeaconManager(Context context) {
      */
     @TargetApi(18)
     public boolean checkAvailability() throws BleNotAvailableException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
+        if (!isBleAvailable()) {
             throw new BleNotAvailableException("Bluetooth LE not supported by this device");
         }
-        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
-            throw new BleNotAvailableException("Bluetooth LE not supported by this device");
-        } else {
-            if (((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled()) {
-                return true;
-            }
-        }
-        return false;
+        return ((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled();
     }
 
     /**
@@ -331,8 +346,12 @@ public boolean checkAvailability() throws BleNotAvailableException {
      * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
      */
     public void bind(BeaconConsumer consumer) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
+        }
+        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            LogManager.w(TAG, "This device does not support bluetooth LE.  Will not start beacon scanning.");
             return;
         }
         synchronized (consumers) {
@@ -357,8 +376,8 @@ public void bind(BeaconConsumer consumer) {
      * @param consumer the <code>Activity</code> or <code>Service</code> that no longer needs to use the service.
      */
     public void unbind(BeaconConsumer consumer) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
         synchronized (consumers) {
@@ -430,8 +449,9 @@ public boolean isAnyConsumerBound() {
      * @see #setBackgroundBetweenScanPeriod(long p)
      */
     public void setBackgroundMode(boolean backgroundMode) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
         }
         mBackgroundModeUninitialized = false;
         if (backgroundMode != mBackgroundMode) {
@@ -647,8 +667,8 @@ public void requestStateForRegion(Region region) {
      */
     @TargetApi(18)
     public void startRangingBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
         if (serviceMessenger == null) {
@@ -681,8 +701,8 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
      */
     @TargetApi(18)
     public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
         if (serviceMessenger == null) {
@@ -722,8 +742,8 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
      */
     @TargetApi(18)
     public void startMonitoringBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
         if (serviceMessenger == null) {
@@ -756,8 +776,8 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
      */
     @TargetApi(18)
     public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
         if (serviceMessenger == null) {
@@ -784,8 +804,8 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
      */
     @TargetApi(18)
     public void updateScanPeriods() throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
         if (serviceMessenger == null) {
@@ -965,6 +985,18 @@ public void setNonBeaconLeScanCallback(NonBeaconLeScanCallback callback) {
         mNonBeaconLeScanCallback = callback;
     }
 
+    private boolean isBleAvailable() {
+        boolean available = false;
+        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            LogManager.w(TAG, "Bluetooth LE not supported prior to API 18.");
+        } else if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            LogManager.w(TAG, "This device does not support bluetooth LE.");
+        } else {
+            available = true;
+        }
+        return available;
+    }
+
     private long getScanPeriod() {
         if (mBackgroundMode) {
             return backgroundScanPeriod;
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index 611a5fa7..c049b994 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -412,12 +412,10 @@ public int getServiceUuidEndOffset() {
      * @param device The Bluetooth device that was detected
      * @return An instance of a <code>Beacon</code>
      */
-    @TargetApi(5)
     public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
         return fromScanData(scanData, rssi, device, new Beacon());
     }
 
-    @TargetApi(5)
     protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice device, Beacon beacon) {
         BleAdvertisement advert = new BleAdvertisement(bytesToProcess);
         boolean parseFailed = false;
@@ -457,12 +455,12 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
             boolean patternFound = false;
 
             if (getServiceUuid() == null) {
-                if (byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
+                if (byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes)) {
                     patternFound = true;
                 }
             } else {
-                if (byteArraysMatch(bytesToProcess, startByte + mServiceUuidStartOffset, serviceUuidBytes, 0) &&
-                        byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
+                if (byteArraysMatch(bytesToProcess, startByte + mServiceUuidStartOffset, serviceUuidBytes) &&
+                        byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes)) {
                     patternFound = true;
                 }
             }
@@ -821,18 +819,19 @@ private int calculateLayoutSize() {
         return lastEndOffset+1;
     }
 
-    private boolean byteArraysMatch(byte[] array1, int offset1, byte[] array2, int offset2) {
-        int minSize = array1.length > array2.length ? array2.length : array1.length;
-        if (offset1+minSize > array1.length || offset2+minSize > array2.length) {
+    private boolean byteArraysMatch(byte[] source, int offset, byte[] expected) {
+        int length = expected.length;
+        if (source.length - offset < length) {
             return false;
         }
-        for (int i = 0; i <  minSize; i++) {
-            if (array1[i+offset1] != array2[i+offset2]) {
+        for (int i = 0; i <  length; i++) {
+            if (source[offset + i] != expected[i]) {
                 return false;
             }
         }
         return true;
     }
+
     private String byteArrayToString(byte[] bytes) {
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < bytes.length; i++) {
diff --git a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
index 5e7367a3..bebb7c91 100644
--- a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
+++ b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
@@ -1,6 +1,5 @@
 package org.altbeacon.beacon.distance;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.os.AsyncTask;
@@ -14,7 +13,6 @@
 /**
  * Created by dyoung on 9/12/14.
  */
-@TargetApi(Build.VERSION_CODES.CUPCAKE)
 public class ModelSpecificDistanceUpdater extends AsyncTask<Void, Void, Void> {
 
     private static final String TAG = "ModelSpecificDistanceUpdater";
diff --git a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
index 4119c465..ff6186c9 100644
--- a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
+++ b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
@@ -44,8 +44,8 @@ public BackgroundPowerSaver(Context context) {
             LogManager.w(TAG, "BackgroundPowerSaver requires API 18 or higher.");
             return;
         }
-        ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
         beaconManager = BeaconManager.getInstanceForApplication(context);
+        ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
     }
 
     @Override
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index c640fbf0..6a617fbc 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -50,6 +50,7 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
@@ -74,7 +75,6 @@
  * @author dyoung
  */
 
-@TargetApi(5)
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
 
@@ -91,7 +91,8 @@
     private boolean mBackgroundFlag = false;
     private ExtraDataBeaconTracker mExtraDataBeaconTracker;
     private ExecutorService mExecutor;
-
+    private final DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
+    
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -384,6 +385,7 @@ public void onMidScanRange() {
 
         @Override
         public void onCycleEnd() {
+            mDistinctPacketDetector.clearDetections();
             monitoringStatus.updateNewlyOutside();
             processRangeData();
             // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
@@ -504,6 +506,13 @@ protected Void doInBackground(ScanData... params) {
             }
             if (beacon != null) {
                 mDetectionTracker.recordDetection();
+                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
+                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
+                            scanData.scanRecord)) {
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
+                    }
+                }
                 trackedBeaconsPacketCount++;
                 processBeaconFromScan(beacon);
             } else {
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index aa0ddb6a..419b47f7 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -66,13 +66,22 @@ public boolean call(Context context, String dataName, Parcelable data) {
         if(intent == null){
             initializeIntent();
         }
+        boolean success = false;
         if (intent != null) {
             LogManager.d(TAG, "attempting callback via intent: %s", intent.getComponent());
             intent.putExtra(dataName, data);
-            context.startService(intent);
-            return true;
+            try {
+                context.startService(intent);
+                success = true;
+            } catch (Exception e) {
+                LogManager.e(
+                        TAG,
+                        "Failed attempting to start service: " + intent.getComponent().flattenToString(),
+                        e
+                );
+            }
         }
-        return false;
+        return success;
     }
 
     @SuppressWarnings("unused")
diff --git a/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java b/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
index 2c5dc5c1..3797d241 100644
--- a/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
@@ -6,16 +6,14 @@
  * Created by dyoung on 1/10/15.
  */
 public class DetectionTracker {
-    private static DetectionTracker sDetectionTracker = null;
+    private static final DetectionTracker INSTANCE = new DetectionTracker();
+
     private long mLastDetectionTime = 0l;
     private DetectionTracker() {
 
     }
-    public static synchronized DetectionTracker getInstance() {
-        if (sDetectionTracker == null) {
-            sDetectionTracker  = new DetectionTracker();
-        }
-        return sDetectionTracker;
+    public static DetectionTracker getInstance() {
+        return INSTANCE;
     }
     public long getLastDetectionTime() {
         return mLastDetectionTime;
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index fdf5644d..3185fdc6 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -23,7 +23,7 @@
 import static android.content.Context.MODE_PRIVATE;
 
 public class MonitoringStatus {
-    private static MonitoringStatus sInstance;
+    private static volatile MonitoringStatus sInstance;
     private static final int MAX_REGIONS_FOR_STATUS_PRESERVATION = 50;
     private static final int MAX_STATUS_PRESERVATION_FILE_AGE_TO_RESTORE_SECS = 60 * 15;
     private static final String TAG = MonitoringStatus.class.getSimpleName();
@@ -35,15 +35,35 @@
 
     private boolean mStatePreservationIsOn = true;
 
+    /**
+     * Private lock object for singleton initialization protecting against denial-of-service attack.
+     */
+    private static final Object SINGLETON_LOCK = new Object();
+
     public static MonitoringStatus getInstanceForApplication(Context context) {
-        if (sInstance == null) {
-            synchronized (MonitoringStatus.class) {
-                if (sInstance == null) {
-                    sInstance = new MonitoringStatus(context.getApplicationContext());
+        /*
+         * Follow double check pattern from Effective Java v2 Item 71.
+         *
+         * Bloch recommends using the local variable for this for performance reasons:
+         *
+         * > What this variable does is ensure that `field` is read only once in the common case
+         * > where it's already initialized. While not strictly necessary, this may improve
+         * > performance and is more elegant by the standards applied to low-level concurrent
+         * > programming. On my machine, [this] is about 25 percent faster than the obvious
+         * > version without a local variable.
+         *
+         * Joshua Bloch. Effective Java, Second Edition. Addison-Wesley, 2008. pages 283-284
+         */
+        MonitoringStatus instance = sInstance;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = sInstance;
+                if (instance == null) {
+                    sInstance = instance = new MonitoringStatus(context.getApplicationContext());
                 }
             }
         }
-        return sInstance;
+        return instance;
     }
 
     public MonitoringStatus(Context context) {
diff --git a/src/main/java/org/altbeacon/beacon/service/RangingData.java b/src/main/java/org/altbeacon/beacon/service/RangingData.java
index f8750b28..2d400787 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -58,11 +58,8 @@ public int describeContents() {
         return 0;
     }
     public void writeToParcel(Parcel out, int flags) {
-        LogManager.d(TAG, "writing RangingData");
         out.writeParcelableArray(beacons.toArray(new Parcelable[0]), flags);
         out.writeParcelable(region, flags);
-        LogManager.d(TAG, "done writing RangingData");
-
     }
 
     public static final Parcelable.Creator<RangingData> CREATOR
@@ -76,8 +73,7 @@ public RangingData createFromParcel(Parcel in) {
         }
     };
 
-    private RangingData(Parcel in) {
-        LogManager.d(TAG, "parsing RangingData");
+    protected RangingData(Parcel in) {
         Parcelable[] parcelables  = in.readParcelableArray(this.getClass().getClassLoader());
         beacons = new ArrayList<Beacon>(parcelables.length);
         for (int i = 0; i < parcelables.length; i++) {
diff --git a/src/main/java/org/altbeacon/beacon/service/Stats.java b/src/main/java/org/altbeacon/beacon/service/Stats.java
index 94f5266f..aaac630b 100644
--- a/src/main/java/org/altbeacon/beacon/service/Stats.java
+++ b/src/main/java/org/altbeacon/beacon/service/Stats.java
@@ -12,7 +12,12 @@
  * Created by dyoung on 10/16/14.
  */
 public class Stats {
+    private static final Stats INSTANCE = new Stats();
     private static final String TAG = "Stats";
+
+    /**
+     * Synchronize all usage as this is not a thread safe class.
+     */
     private static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat("HH:mm:ss.SSS");
 
     private ArrayList<Sample> mSamples;
@@ -21,14 +26,11 @@
     private boolean mEnableHistoricalLogging;
     private boolean mEnabled;
     private Sample mSample;
-    private static Stats mInstance;
 
     public static Stats getInstance() {
-        if(mInstance == null) {
-            mInstance = new Stats();
-        }
-        return mInstance;
+        return INSTANCE;
     }
+
     private Stats() {
         mSampleIntervalMillis = 0l;
         clearSamples();
@@ -105,7 +107,13 @@ private void logSample(Sample sample, boolean showHeader) {
     }
 
     private String formattedDate(Date d) {
-        return d == null ? "" : SIMPLE_DATE_FORMAT.format(d);
+        String formattedDate = "";
+        if (d != null) {
+            synchronized (SIMPLE_DATE_FORMAT) {
+                formattedDate = SIMPLE_DATE_FORMAT.format(d);
+            }
+        }
+        return formattedDate;
     }
 
     private void logSamples() {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 2896ba46..06d80594 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -20,7 +20,6 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
-
 import java.util.Date;
 
 @TargetApi(18)
@@ -32,7 +31,6 @@
     private long mLastScanCycleEndTime = 0l;
     protected long mNextScanCycleStartTime = 0l;
     private long mScanCycleStopTime = 0l;
-    private long mLastScanStopTime = 0l;
 
     private boolean mIsMidScanRangeUpdate = false;
     private long mRangeCycleUpdateTime = 0l;
@@ -58,6 +56,7 @@
     protected boolean mBackgroundFlag = false;
     protected boolean mRestartNeeded = false;
 
+    private boolean mDistinctPacketsDetectedPerScan = false;
     private static final long ANDROID_N_MIN_SCAN_CYCLE_MILLIS = 6000l;
 
     protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
@@ -175,13 +174,19 @@ public void stop() {
         mScanningEnabled = false;
         if (mScanCyclerStarted) {
             scanLeDevice(false);
-        }
-        if (mBluetoothAdapter != null) {
-            stopScan();
-            mLastScanCycleEndTime = SystemClock.elapsedRealtime();
+        } else {
+            LogManager.d(TAG, "scanning already stopped");
         }
     }
 
+    public boolean getDistinctPacketsDetectedPerScan() {
+        return mDistinctPacketsDetectedPerScan;
+    }
+
+    public void setDistinctPacketsDetectedPerScan(boolean detected) {
+        mDistinctPacketsDetectedPerScan = detected;
+    }
+
     public void destroy() {
         mScanThread.quit();
     }
@@ -307,26 +312,39 @@ private void finishScanCycle() {
             if (mScanning) {
                 if (getBluetoothAdapter() != null) {
                     if (getBluetoothAdapter().isEnabled()) {
-                        long now = System.currentTimeMillis();
-                        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
-                                mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
-                                now-mLastScanStopTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
-                            // As of Android N, only 5 scans may be started in a 30 second period (6
-                            // seconds per cycle)  otherwise they are blocked.  So we check here to see
-                            // if the scan period is 6 seconds or less, and if we last stopped scanning
-                            // fewer than 6 seconds ag and if so, we simply do not stop scanning
-                            LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
-                                    " keep scanning for a minimum of 6 seconds at a time. "+
-                                    "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanStopTime))+" millisconds.");
+                        // Determine if we need to restart scanning.  Restarting scanning is only
+                        // needed on devices incapable of detecting multiple distinct BLE advertising
+                        // packets in a single cycle, typically older Android devices (e.g. Nexus 4)
+                        // On such devices, it is necessary to stop scanning and restart to detect
+                        // multiple beacon packets in the same scan, allowing collection of multiple
+                        // rssi measurements.  Restarting however, causes brief detection dropouts
+                        // so it is best avoided.  If we know the device has detected to distinct
+                        // packets in the same cycle, we will not restart scanning and just keep it
+                        // going.
+                        if (!getDistinctPacketsDetectedPerScan()) {
+                            long now = SystemClock.elapsedRealtime();
+                            if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
+                                    mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
+                                    now-mLastScanCycleStartTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
+                                // As of Android N, only 5 scans may be started in a 30 second period (6
+                                // seconds per cycle)  otherwise they are blocked.  So we check here to see
+                                // if the scan period is 6 seconds or less, and if we last stopped scanning
+                                // fewer than 6 seconds ag and if so, we simply do not stop scanning
+                                LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
+                                        " keep scanning for a minimum of 6 seconds at a time. "+
+                                        "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanCycleStartTime))+" millisconds.");
+                            }
+                            else {
+                                try {
+                                    LogManager.d(TAG, "stopping bluetooth le scan");
+                                    finishScan();
+                                } catch (Exception e) {
+                                    LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
+                                }
+                            }
                         }
                         else {
-                            try {
-                                LogManager.d(TAG, "stopping bluetooth le scan");
-                                finishScan();
-                                mLastScanStopTime = now;
-                            } catch (Exception e) {
-                                LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
-                            }
+                            LogManager.d(TAG, "Not stopping scanning.  Device capable of multiple indistinct detections per scan.");
                         }
 
                         mLastScanCycleEndTime = SystemClock.elapsedRealtime();
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
new file mode 100644
index 00000000..42978d30
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
@@ -0,0 +1,43 @@
+package org.altbeacon.beacon.service.scanner;
+
+import android.util.Log;
+
+import java.nio.ByteBuffer;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Created by dyoung on 4/8/17.
+ *
+ * This class tracks whether multiple distinct BLE packets have been seen, with the purpose of
+ * determining if the Android device supports detecting multiple distinct packets in a single scan.
+ * Some older devices are not capable of this (e.g. Nexus 4, Moto G1), so detecting multiple packets
+ * requires stopping and restarting scanning on these devices.  This allows detecting if that is
+ * neessary
+ */
+public class DistinctPacketDetector {
+    // Sanity limit for the number of packets to track, so we don't use too much memory
+    private static final int MAX_PACKETS_TO_TRACK = 1000;
+    protected Set<ByteBuffer> mDistinctPacketsDetected = new HashSet<ByteBuffer>();
+
+    public void clearDetections() {
+        mDistinctPacketsDetected.clear();
+    }
+
+    public boolean isPacketDistinct(String originMacAddress, byte[] scanRecord) {
+        byte[] macBytes = originMacAddress.getBytes();
+        ByteBuffer buffer = ByteBuffer.allocate(macBytes.length+scanRecord.length);
+        buffer.put(macBytes);
+        buffer.put(scanRecord);
+        buffer.rewind(); // rewind puts position back to beginning so .equals and .hashCode work
+
+        boolean distinct = !mDistinctPacketsDetected.contains(buffer);
+        if (mDistinctPacketsDetected.size() == MAX_PACKETS_TO_TRACK) {
+            return mDistinctPacketsDetected.contains(buffer);
+        }
+        else {
+            return mDistinctPacketsDetected.add(buffer);
+        }
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
index 93eefda9..8964e607 100644
--- a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
+++ b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
@@ -1,6 +1,5 @@
 package org.altbeacon.beacon.startup;
 
-import android.annotation.TargetApi;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -8,7 +7,6 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.BeaconManager;
 
-@TargetApi(4)
 public class StartupBroadcastReceiver extends BroadcastReceiver
 {
     private static final String TAG = "StartupBroadcastReceiver";
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
index a1542932..195a770a 100644
--- a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
@@ -39,7 +39,6 @@
  *
  * Created by dyoung on 3/24/14.
  */
-@TargetApi(5)
 public class BluetoothCrashResolver {
     private static final String TAG = "BluetoothCrashResolver";
     private static final boolean PREEMPTIVE_ACTION_ENABLED = true;
diff --git a/src/test/java/org/altbeacon/beacon/RegionTest.java b/src/test/java/org/altbeacon/beacon/RegionTest.java
index 4d003273..b57d3503 100644
--- a/src/test/java/org/altbeacon/beacon/RegionTest.java
+++ b/src/test/java/org/altbeacon/beacon/RegionTest.java
@@ -135,6 +135,7 @@ public void testCanSerializeParcelable() {
         region.writeToParcel(parcel, 0);
         parcel.setDataPosition(0);
         Region region2 = new Region(parcel);
+        parcel.recycle();
         assertEquals("Right number of identifiers after deserialization", 3, region2.mIdentifiers.size());
         assertEquals("uniqueId is same after deserialization", region.getUniqueId(), region2.getUniqueId());
         assertEquals("id1 is same after deserialization", region.getIdentifier(0), region2.getIdentifier(0));
@@ -151,6 +152,7 @@ public void testCanSerializeParcelableWithMac() {
         region.writeToParcel(parcel, 0);
         parcel.setDataPosition(0);
         Region region2 = new Region(parcel);
+        parcel.recycle();
         assertEquals("Right number of identifiers after deserialization", 0, region2.mIdentifiers.size());
         assertEquals("ac is same after deserialization", region.getBluetoothAddress(), region2.getBluetoothAddress());
     }
@@ -158,7 +160,6 @@ public void testCanSerializeParcelableWithMac() {
     @Test
     public void rejectsInvalidMac() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         try {
             Region region = new Region("myRegion", "this string is not a valid mac address!");
             assertTrue("IllegalArgumentException should have been thrown", false);
diff --git a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
new file mode 100644
index 00000000..3042a904
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
@@ -0,0 +1,94 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.AsyncTask;
+import android.os.Build;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.Identifier;
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.logging.Loggers;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+import org.robolectric.util.ServiceController;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import android.os.Parcel;
+import android.os.Bundle;
+import org.altbeacon.beacon.service.RangingData;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class RangingDataTest {
+    @Before
+    public void before() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        LogManager.setLogger(Loggers.verboseLogger());
+        LogManager.setVerboseLoggingEnabled(true);
+        BeaconManager.setsManifestCheckingDisabled(true);
+    }
+
+    @Test
+    public void testSerialization() throws Exception {
+        Context context = ShadowApplication.getInstance().getApplicationContext();
+        ArrayList<Identifier> identifiers = new ArrayList<Identifier>();
+        identifiers.add(Identifier.parse("2f234454-cf6d-4a0f-adf2-f4911ba9ffa6"));
+        identifiers.add(Identifier.parse("1"));
+        identifiers.add(Identifier.parse("2"));
+        Region region = new Region("testRegion", identifiers);
+        ArrayList<Beacon> beacons = new ArrayList<Beacon>();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        for (int i=0; i < 10; i++) {
+            beacons.add(beacon);
+        }
+        RangingData data = new RangingData(beacons, region);
+        Parcel parcel = Parcel.obtain();
+        data.writeToParcel(parcel, 0);
+        parcel.setDataPosition(0);
+        RangingData data2 = new RangingData(parcel);
+        assertEquals("beacon count shouild be restored", 10, data2.getBeacons().size());
+        assertEquals("beacon identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getBeacons().iterator().next().getId1().toString());
+        assertEquals("region identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getRegion().getId1().toString());
+    }
+
+    @Test
+    // On MacBookPro 2.5 GHz Core I7, 10000 serialization/deserialiation cycles of RangingData took 22ms
+    public void testSerializationBenchmark() throws Exception {
+        Context context = ShadowApplication.getInstance().getApplicationContext();
+        ArrayList<Identifier> identifiers = new ArrayList<Identifier>();
+        identifiers.add(Identifier.parse("2f234454-cf6d-4a0f-adf2-f4911ba9ffa6"));
+        identifiers.add(Identifier.parse("1"));
+        identifiers.add(Identifier.parse("2"));
+        Region region = new Region("testRegion", identifiers);
+        ArrayList<Beacon> beacons = new ArrayList<Beacon>();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        for (int i=0; i < 10; i++) {
+            beacons.add(beacon);
+        }
+        RangingData data = new RangingData(beacons, region);
+        long time1 = System.currentTimeMillis();
+        for (int i=0; i< 10000; i++) {
+            Parcel parcel = Parcel.obtain();
+            data.writeToParcel(parcel, 0);
+            parcel.setDataPosition(0);
+            RangingData data2 = new RangingData(parcel);
+        }
+        long time2 = System.currentTimeMillis();
+        System.out.println("*** Ranging Data Serialization benchmark: "+(time2-time1));
+    }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java b/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
new file mode 100644
index 00000000..f82e152c
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
@@ -0,0 +1,57 @@
+package org.altbeacon.beacon.service.scanner;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@Config(sdk = 18)
+
+@RunWith(RobolectricTestRunner.class)
+public class DistinctPacketDetectorTest {
+    @BeforeClass
+    public static void testSetup() {
+    }
+
+    @AfterClass
+    public static void testCleanup() {
+
+    }
+
+    @Test
+    public void testSecondDuplicatePacketIsNotDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        assertFalse("second call with same packet should not be distinct", secondResult);
+    }
+
+    @Test
+    public void testSecondNonDuplicatePacketIsDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x03, 0x04});
+        assertTrue("second call with different packet should be distinct", secondResult);
+    }
+
+    @Test
+    public void testSamePacketForDifferentMacIsDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:01:01:01:01:01", new byte[] {0x01, 0x02});
+        assertTrue("second packet with different mac should be distinct", secondResult);
+    }
+
+    @Test
+    public void clearingDetectionsPreventsDistinctDetection() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        dpd.clearDetections();
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        assertTrue("second call with same packet after clear should be distinct", secondResult);
+    }
+
+}
\ No newline at end of file
