diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index d3ad8af1..dab06293 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -29,9 +29,12 @@
 import android.app.PendingIntent;
 import android.app.Service;
 import android.bluetooth.BluetoothDevice;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
 import android.os.AsyncTask;
 import android.os.Binder;
 import android.os.Build;
@@ -240,6 +243,14 @@ public void onCreate() {
             LogManager.i(TAG, "beaconService PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
         }
 
+        try {
+            PackageItemInfo info = this.getPackageManager().getServiceInfo(new ComponentName(this, BeaconService.class), PackageManager.GET_META_DATA);
+            if (info.metaData.get("longScanForcingEnabled").toString().equals("true")) {
+                LogManager.i(TAG, "longScanForcingEnabled from AndroidManifest");
+                mCycledScanner.setLongScanForcingEnabled(true);
+            }
+        } catch (PackageManager.NameNotFoundException e) {}
+
         reloadParsers();
 
         defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index dc12e78e..e9c7a3b0 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -28,6 +28,7 @@
 
 @TargetApi(18)
 public abstract class CycledLeScanner {
+    public static final long ANDROID_N_MAX_SCAN_DURATION = 30 * 60 * 1000l; // 30 minutes
     private static final String TAG = "CycledLeScanner";
     private BluetoothAdapter mBluetoothAdapter;
 
@@ -35,7 +36,12 @@
     private long mLastScanCycleEndTime = 0l;
     protected long mNextScanCycleStartTime = 0l;
     private long mScanCycleStopTime = 0l;
-
+    // This is the last time this class actually commanded the OS
+    // to start scanning.
+    private long mCurrentScanStartTime = 0l;
+    // True if the app has explicitly requested long running scans that
+    // may go beyond what is normally allowed on Android N.
+    private boolean mLongScanForcingEnabled = false;
     private boolean mScanning;
     protected boolean mScanningPaused;
     private boolean mScanCyclerStarted = false;
@@ -136,6 +142,15 @@ public static CycledLeScanner createScanner(Context context, long scanPeriod, lo
 
     }
 
+    /**
+     * Enables the scanner to go to extra lengths to keep scans going for longer than would
+     * otherwise be allowed.  Useful only for Android N and higher.
+     * @param enabled
+     */
+    public void setLongScanForcingEnabled(boolean enabled) {
+        mLongScanForcingEnabled = enabled;
+    }
+
     /**
      * Tells the cycler the scan rate and whether it is in operating in background mode.
      * Background mode flag  is used only with the Android 5.0 scanning implementations to switch
@@ -272,6 +287,7 @@ protected void scanLeDevice(final Boolean enable) {
                                         }
                                         try {
                                             if (android.os.Build.VERSION.SDK_INT < 23 || checkLocationPermission()) {
+                                                mCurrentScanStartTime = SystemClock.elapsedRealtime();
                                                 startScan();
                                             }
                                         } catch (Exception e) {
@@ -301,6 +317,7 @@ protected void scanLeDevice(final Boolean enable) {
                 mScanning = false;
                 mScanCyclerStarted = false;
                 stopScan();
+                mCurrentScanStartTime = 0l;
                 mLastScanCycleEndTime = SystemClock.elapsedRealtime();
                 // Clear any queued schedule tasks as we're done scanning
                 mScanHandler.removeCallbacksAndMessages(null);
@@ -353,7 +370,9 @@ private void finishScanCycle() {
                         // so it is best avoided.  If we know the device has detected to distinct
                         // packets in the same cycle, we will not restart scanning and just keep it
                         // going.
-                        if (!mDistinctPacketsDetectedPerScan || mBetweenScanPeriod != 0) {
+                        if (!mDistinctPacketsDetectedPerScan ||
+                                mBetweenScanPeriod != 0 ||
+                                mustStopScanToPreventAndroidNScanTimeout()) {
                             long now = SystemClock.elapsedRealtime();
                             if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
                                     mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
@@ -488,4 +507,34 @@ private boolean checkLocationPermission() {
     private boolean checkPermission(final String permission) {
         return mContext.checkPermission(permission, android.os.Process.myPid(), android.os.Process.myUid()) == PackageManager.PERMISSION_GRANTED;
     }
+
+    /**
+     * On Android N and later, a scan that runs for more than 30 minutes will be automatically
+     * stopped by the OS and converted to an "opportunistic" scan, meaning that they will only yield
+     * detections if another app is scanning.  This is inteneded to save battery.  This can be
+     * prevented by stopping scanning and restarting.  This method returns true if:
+     *   * this is Android N or later
+     *   * we are close to the 30 minute boundary since the last scan started
+     *   * The app developer has explicitly enabled long-running scans
+     * @return true if we must stop scanning to prevent
+     */
+    private boolean mustStopScanToPreventAndroidNScanTimeout() {
+        long timeOfNextScanCycleEnd = SystemClock.elapsedRealtime() +  mBetweenScanPeriod +
+                mScanPeriod;
+        boolean timeoutAtRisk = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
+                mCurrentScanStartTime > 0 &&
+                ( timeOfNextScanCycleEnd - mCurrentScanStartTime > ANDROID_N_MAX_SCAN_DURATION);
+        if (timeoutAtRisk) {
+            LogManager.d(TAG, "The next scan cycle would go over the Android N max duration.");
+        }
+        if (timeoutAtRisk && mLongScanForcingEnabled) {
+            LogManager.d(TAG, "Stopping scan to prevent Android N scan timeout.");
+            return true;
+        }
+        else {
+            LogManager.w(TAG, "Allowing a long running scan to be stopped by the OS.  To" +
+                    "prevent this, enable long running scans in the AndroidBeaconLibrary.");
+            return false;
+        }
+    }
 }
