diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 621fd239..37ae6ff2 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -24,18 +24,14 @@
 package org.altbeacon.beacon.service;
 
 
-import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
 import android.app.Service;
-import android.bluetooth.BluetoothDevice;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageItemInfo;
 import android.content.pm.PackageManager;
-import android.os.AsyncTask;
 import android.os.Binder;
 import android.os.Build;
 import android.os.Handler;
@@ -44,8 +40,8 @@
 import android.os.Message;
 import android.os.Messenger;
 import android.support.annotation.MainThread;
-import android.support.annotation.NonNull;
-import android.support.annotation.WorkerThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -56,25 +52,15 @@
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
-import org.altbeacon.beacon.service.scanner.CycledLeScanner;
-import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
-import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.beacon.utils.ProcessUtils;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
 
 import static android.app.PendingIntent.FLAG_ONE_SHOT;
 import static android.app.PendingIntent.getBroadcast;
@@ -85,22 +71,9 @@
 
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
-
-    private final Map<Region, RangeState> rangedRegionState = new HashMap<Region, RangeState>();
-    private MonitoringStatus monitoringStatus;
-
-    int trackedBeaconsPacketCount;
     private final Handler handler = new Handler();
     private BluetoothCrashResolver bluetoothCrashResolver;
-    private DistanceCalculator defaultDistanceCalculator = null;
-    private BeaconManager beaconManager;
-    private Set<BeaconParser> beaconParsers  = new HashSet<BeaconParser>();
-    private CycledLeScanner mCycledScanner;
-    private boolean mBackgroundFlag = false;
-    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
-    private ExecutorService mExecutor;
-    private final DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
-
+    private ScanHelper mScanHelper;
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -123,8 +96,6 @@
      *
      */
 
-    private List<Beacon> simulatedScanData = null;
-
     /**
      * Class used for the client Binder.  Because we know this service always
      * runs in the same process as its clients, we don't need to deal with IPC.
@@ -225,14 +196,16 @@ public void onCreate() {
         bluetoothCrashResolver = new BluetoothCrashResolver(this);
         bluetoothCrashResolver.start();
 
-        // Create a private executor so we don't compete with threads used by AsyncTask
-        // This uses fewer threads than the default executor so it won't hog CPU
-        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
-
-        mCycledScanner = CycledLeScanner.createScanner(this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
-                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag, mCycledLeScanCallback, bluetoothCrashResolver);
+        mScanHelper = new ScanHelper(this);
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(false, bluetoothCrashResolver);
+        }
+        mScanHelper.setMonitoringStatus(MonitoringStatus.getInstanceForApplication(this));
+        mScanHelper.setRangedRegionState(new HashMap<Region, RangeState>());
+        mScanHelper.setBeaconParsers(new HashSet<BeaconParser>());
+        mScanHelper.setExtraDataBeaconTracker(new ExtraDataBeaconTracker());
 
-        beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
         beaconManager.setScannerInSameProcess(true);
         if (beaconManager.isMainProcess()) {
             LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
@@ -248,21 +221,20 @@ public void onCreate() {
             if (info != null && info.metaData != null && info.metaData.get("longScanForcingEnabled") != null &&
                     info.metaData.get("longScanForcingEnabled").toString().equals("true")) {
                 LogManager.i(TAG, "longScanForcingEnabled to keep scans going on Android N for > 30 minutes");
-                mCycledScanner.setLongScanForcingEnabled(true);
+                mScanHelper.getCycledScanner().setLongScanForcingEnabled(true);
             }
         } catch (PackageManager.NameNotFoundException e) {}
 
-        reloadParsers();
+        mScanHelper.reloadParsers();
 
-        defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
+        DistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
 
-        monitoringStatus = MonitoringStatus.getInstanceForApplication(getApplicationContext());
         // Look for simulated scan data
         try {
             Class klass = Class.forName("org.altbeacon.beacon.SimulatedScanData");
             java.lang.reflect.Field f = klass.getField("beacons");
-            this.simulatedScanData = (List<Beacon>) f.get(null);
+            mScanHelper.setSimulatedScanData((List<Beacon>) f.get(null));
         } catch (ClassNotFoundException e) {
             LogManager.d(TAG, "No org.altbeacon.beacon.SimulatedScanData class exists.");
         } catch (Exception e) {
@@ -270,25 +242,6 @@ public void onCreate() {
         }
     }
 
-    protected void reloadParsers() {
-        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
-        //flatMap all beacon parsers
-        boolean matchBeaconsByServiceUUID = true;
-        if (beaconManager.getBeaconParsers() != null) {
-            newBeaconParsers.addAll(beaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
-            }
-        }
-        beaconParsers = newBeaconParsers;
-        //initialize the extra data beacon tracker
-        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
-    }
-
-
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         LogManager.i(TAG,
@@ -327,9 +280,9 @@ public void onDestroy() {
         bluetoothCrashResolver.stop();
         LogManager.i(TAG, "onDestroy called.  stopping scanning");
         handler.removeCallbacksAndMessages(null);
-        mCycledScanner.stop();
-        mCycledScanner.destroy();
-        monitoringStatus.stopStatusPreservation();
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        mScanHelper.getMonitoringStatus().stopStatusPreservation();
     }
 
     @Override
@@ -355,246 +308,60 @@ private PendingIntent getRestartIntent() {
      */
     @MainThread
     public void startRangingBeaconsInRegion(Region region, Callback callback) {
-        synchronized (rangedRegionState) {
-            if (rangedRegionState.containsKey(region)) {
+        synchronized (mScanHelper.getRangedRegionState()) {
+            if (mScanHelper.getRangedRegionState().containsKey(region)) {
                 LogManager.i(TAG, "Already ranging that region -- will replace existing region.");
-                rangedRegionState.remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
+                mScanHelper.getRangedRegionState().remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
             }
-            rangedRegionState.put(region, new RangeState(callback));
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+            mScanHelper.getRangedRegionState().put(region, new RangeState(callback));
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
-        mCycledScanner.start();
+        mScanHelper.getCycledScanner().start();
     }
 
     @MainThread
     public void stopRangingBeaconsInRegion(Region region) {
         int rangedRegionCount;
-        synchronized (rangedRegionState) {
-            rangedRegionState.remove(region);
-            rangedRegionCount = rangedRegionState.size();
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+        synchronized (mScanHelper.getRangedRegionState()) {
+            mScanHelper.getRangedRegionState().remove(region);
+            rangedRegionCount = mScanHelper.getRangedRegionState().size();
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
 
-        if (rangedRegionCount == 0 && monitoringStatus.regionsCount() == 0) {
-            mCycledScanner.stop();
+        if (rangedRegionCount == 0 && mScanHelper.getMonitoringStatus().regionsCount() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
     @MainThread
     public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
         LogManager.d(TAG, "startMonitoring called");
-        monitoringStatus.addRegion(region, callback);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        mCycledScanner.start();
+        mScanHelper.getMonitoringStatus().addRegion(region, callback);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        mScanHelper.getCycledScanner().start();
     }
 
     @MainThread
     public void stopMonitoringBeaconsInRegion(Region region) {
         LogManager.d(TAG, "stopMonitoring called");
-        monitoringStatus.removeRegion(region);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        if (monitoringStatus.regionsCount() == 0 && rangedRegionState.size() == 0) {
-            mCycledScanner.stop();
+        mScanHelper.getMonitoringStatus().removeRegion(region);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        if (mScanHelper.getMonitoringStatus().regionsCount() == 0 && mScanHelper.getRangedRegionState().size() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
     @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        mCycledScanner.setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
-    }
-
-    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
-        @MainThread
-        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-        @Override
-        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
-
-            NonBeaconLeScanCallback nonBeaconLeScanCallback = beaconManager.getNonBeaconLeScanCallback();
-
-            try {
-                new ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
-                        new ScanData(device, rssi, scanRecord));
-            } catch (RejectedExecutionException e) {
-                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
-            }
-        }
-
-        @MainThread
-        @Override
-        public void onCycleEnd() {
-            mDistinctPacketDetector.clearDetections();
-            monitoringStatus.updateNewlyOutside();
-            processRangeData();
-            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
-            if (simulatedScanData != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
-
-                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                    for (Beacon beacon : simulatedScanData) {
-                        // This is an expensive call and we do not want to block the main thread.
-                        // But here we are in debug/test mode so we allow it on the main thread.
-                        //noinspection WrongThread
-                        processBeaconFromScan(beacon);
-                    }
-                } else {
-                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
-                }
-            }
-            if (BeaconManager.getBeaconSimulator() != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
-                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
-                            // This is an expensive call and we do not want to block the main thread.
-                            // But here we are in debug/test mode so we allow it on the main thread.
-                            //noinspection WrongThread
-                            processBeaconFromScan(beacon);
-                        }
-                    } else {
-                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
-                    }
-                } else {
-                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
-                }
-            }
-        }
-    };
-
-    private void processRangeData() {
-        synchronized (rangedRegionState) {
-            for (Region region : rangedRegionState.keySet()) {
-                RangeState rangeState = rangedRegionState.get(region);
-                LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
-            }
-        }
-    }
-
-    /**
-     * Helper for processing BLE beacons. This has been extracted from {@link ScanProcessor} to
-     * support simulated scan data for test and debug environments.
-     * <p>
-     * Processing beacons is a frequent and expensive operation. It should not be run on the main
-     * thread to avoid UI contention.
-     */
-    @WorkerThread
-    private void processBeaconFromScan(@NonNull Beacon beacon) {
-        if (Stats.getInstance().isEnabled()) {
-            Stats.getInstance().log(beacon);
-        }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG,
-                    "beacon detected : %s", beacon.toString());
-        }
-
-        beacon = mExtraDataBeaconTracker.track(beacon);
-        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
-        // the above
-        if (beacon == null) {
-            if (LogManager.isVerboseLoggingEnabled()) {
-                LogManager.d(TAG,
-                        "not processing detections for GATT extra data beacon");
-            }
-        } else {
-
-            monitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
-
-            List<Region> matchedRegions = null;
-            Iterator<Region> matchedRegionIterator;
-            LogManager.d(TAG, "looking for ranging region matches for this beacon");
-            synchronized (rangedRegionState) {
-                matchedRegions = matchingRegions(beacon, rangedRegionState.keySet());
-                matchedRegionIterator = matchedRegions.iterator();
-                while (matchedRegionIterator.hasNext()) {
-                    Region region = matchedRegionIterator.next();
-                    LogManager.d(TAG, "matches ranging region: %s", region);
-                    RangeState rangeState = rangedRegionState.get(region);
-                    if (rangeState != null) {
-                        rangeState.addBeacon(beacon);
-                    }
-                }
-            }
-        }
+        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
     }
 
-
-    /**
-     * <strong>This class is not thread safe.</strong>
-     */
-    private static class ScanData {
-        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
-            this.device = device;
-            this.rssi = rssi;
-            this.scanRecord = scanRecord;
-        }
-
-        final int rssi;
-
-        @NonNull
-        final BluetoothDevice device;
-
-        @NonNull
-        final byte[] scanRecord;
+    public void reloadParsers() {
+        mScanHelper.reloadParsers();
     }
 
-    private class ScanProcessor extends AsyncTask<ScanData, Void, Void> {
-        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
-
-        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-
-        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
-            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
-        }
-
-        @WorkerThread
-        @Override
-        protected Void doInBackground(ScanData... params) {
-            ScanData scanData = params[0];
-            Beacon beacon = null;
-
-            for (BeaconParser parser : beaconParsers) {
-                beacon = parser.fromScanData(scanData.scanRecord,
-                        scanData.rssi, scanData.device);
-
-                if (beacon != null) {
-                    break;
-                }
-            }
-            if (beacon != null) {
-                if (LogManager.isVerboseLoggingEnabled()) {
-                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
-                }
-                mDetectionTracker.recordDetection();
-                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
-                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
-                            scanData.scanRecord)) {
-                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unnecessary.");
-                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
-                    }
-                }
-                trackedBeaconsPacketCount++;
-                processBeaconFromScan(beacon);
-            } else {
-                if (mNonBeaconLeScanCallback != null) {
-                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
-                }
-            }
-            return null;
-        }
-    }
-
-    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<Region>();
-        for (Region region : regions) {
-            if (region.matchesBeacon(beacon)) {
-                matched.add(region);
-            } else {
-                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
-            }
-        }
-        return matched;
+    @RestrictTo(Scope.TESTS)
+    protected CycledLeScanCallback getCycledLeScanCallback() {
+        return mScanHelper.getCycledLeScanCallback();
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
index 1da8691b..3ac5fbdc 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -1,11 +1,17 @@
 package org.altbeacon.beacon.service;
 
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.bluetooth.BluetoothDevice;
 import android.content.Context;
 import android.content.pm.ApplicationInfo;
 import android.os.AsyncTask;
 import android.os.Build;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.WorkerThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -33,86 +39,77 @@
 /**
  * Created by dyoung on 6/16/17.
  *
- * This is an internal untilty class and should not be called directly by library users.
+ * This is an internal utilty class and should not be called directly by library users.
  *
  * This encapsulates shared data and methods used by both ScanJob and BeaconService
+ * that deal with the specifics of beacon scanning.
+ *
  * @hide
  */
 
-public class ScanHelper {
+class ScanHelper {
     private static final String TAG = ScanHelper.class.getSimpleName();
     private ExecutorService mExecutor;
     private BeaconManager mBeaconManager;
     private CycledLeScanner mCycledScanner;
     private MonitoringStatus mMonitoringStatus;
-    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
     private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
     private ExtraDataBeaconTracker mExtraDataBeaconTracker;
-    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<>();
     private List<Beacon> mSimulatedScanData = null;
     private Context mContext;
 
-    public ScanHelper(Context context) {
+    ScanHelper(Context context) {
         mContext = context;
         mBeaconManager = BeaconManager.getInstanceForApplication(context);
         mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
     }
 
-    public CycledLeScanner getCycledScanner() {
+    CycledLeScanner getCycledScanner() {
         return mCycledScanner;
     }
 
-    public void setCycledScanner(CycledLeScanner cycledScanner) {
-        mCycledScanner = cycledScanner;
-    }
-
-    public MonitoringStatus getMonitoringStatus() {
+    MonitoringStatus getMonitoringStatus() {
         return mMonitoringStatus;
     }
 
-    public void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+    void setMonitoringStatus(MonitoringStatus monitoringStatus) {
         mMonitoringStatus = monitoringStatus;
     }
 
-    public Map<Region, RangeState> getRangedRegionState() {
+    Map<Region, RangeState> getRangedRegionState() {
         return mRangedRegionState;
     }
 
-    public void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
-        mRangedRegionState = rangedRegionState;
-    }
-
-    public DistinctPacketDetector getDistinctPacketDetector() {
-        return mDistinctPacketDetector;
-    }
-
-    public void setDistinctPacketDetector(DistinctPacketDetector distinctPacketDetector) {
-        mDistinctPacketDetector = distinctPacketDetector;
-    }
-
-    public ExtraDataBeaconTracker getExtraDataBeaconTracker() {
-        return mExtraDataBeaconTracker;
+    void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        synchronized (mRangedRegionState) {
+            mRangedRegionState.clear();
+            mRangedRegionState.putAll(rangedRegionState);
+        }
     }
 
-    public void setExtraDataBeaconTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+    void setExtraDataBeaconTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
         mExtraDataBeaconTracker = extraDataBeaconTracker;
     }
 
-    public Set<BeaconParser> getBeaconParsers() {
-        return mBeaconParsers;
+    void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
     }
 
-    public void setBeaconParsers(Set<BeaconParser> beaconParsers) {
-        mBeaconParsers = beaconParsers;
+    void setSimulatedScanData(List<Beacon> simulatedScanData) {
+        mSimulatedScanData = simulatedScanData;
     }
 
-    public void createCycledLeScanner(boolean backgroundMode, BluetoothCrashResolver crashResolver) {
+
+    void createCycledLeScanner(boolean backgroundMode, BluetoothCrashResolver crashResolver) {
         mCycledScanner = CycledLeScanner.createScanner(mContext, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
-                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, backgroundMode, mCycledLeScanCallback, null);
+                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, backgroundMode,
+                mCycledLeScanCallback, crashResolver);
     }
 
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public void processScanResult(BluetoothDevice device, int rssi, byte[] scanRecord) {
+    void processScanResult(BluetoothDevice device, int rssi, byte[] scanRecord) {
         NonBeaconLeScanCallback nonBeaconLeScanCallback = mBeaconManager.getNonBeaconLeScanCallback();
 
         try {
@@ -124,31 +121,33 @@ public void processScanResult(BluetoothDevice device, int rssi, byte[] scanRecor
         }
     }
 
-    protected void reloadParsers() {
-        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
+    void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<>();
         //flatMap all beacon parsers
         boolean matchBeaconsByServiceUUID = true;
-        if (mBeaconManager.getBeaconParsers() != null) {
-            newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
+        newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
+        for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
+            if (beaconParser.getExtraDataParsers().size() > 0) {
+                matchBeaconsByServiceUUID = false;
+                newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
             }
         }
         mBeaconParsers = newBeaconParsers;
         //initialize the extra data beacon tracker
         mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
     }
-    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+
+    private final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
         @TargetApi(Build.VERSION_CODES.HONEYCOMB)
         @Override
+        @MainThread
         public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
             processScanResult(device, rssi, scanRecord);
         }
 
         @Override
+        @MainThread
+        @SuppressLint("WrongThread")
         public void onCycleEnd() {
             mDistinctPacketDetector.clearDetections();
             mMonitoringStatus.updateNewlyOutside();
@@ -161,6 +160,9 @@ public void onCycleEnd() {
 
                 if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
                     for (Beacon beacon : mSimulatedScanData) {
+                        // This is an expensive call and we do not want to block the main thread.
+                        // But here we are in debug/test mode so we allow it on the main thread.
+                        //noinspection WrongThread
                         processBeaconFromScan(beacon);
                     }
                 } else {
@@ -173,6 +175,9 @@ public void onCycleEnd() {
                 if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
                     if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
                         for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                            // This is an expensive call and we do not want to block the main thread.
+                            // But here we are in debug/test mode so we allow it on the main thread.
+                            //noinspection WrongThread
                             processBeaconFromScan(beacon);
                         }
                     } else {
@@ -185,6 +190,11 @@ public void onCycleEnd() {
         }
     };
 
+    @RestrictTo(Scope.TESTS)
+    CycledLeScanCallback getCycledLeScanCallback() {
+        return mCycledLeScanCallback;
+    }
+
     private void processRangeData() {
         synchronized (mRangedRegionState) {
             for (Region region : mRangedRegionState.keySet()) {
@@ -195,7 +205,15 @@ private void processRangeData() {
         }
     }
 
-    private void processBeaconFromScan(Beacon beacon) {
+    /**
+     * Helper for processing BLE beacons. This has been extracted from {@link ScanHelper.ScanProcessor} to
+     * support simulated scan data for test and debug environments.
+     * <p>
+     * Processing beacons is a frequent and expensive operation. It should not be run on the main
+     * thread to avoid UI contention.
+     */
+    @WorkerThread
+    private void processBeaconFromScan(@NonNull Beacon beacon) {
         if (Stats.getInstance().isEnabled()) {
             Stats.getInstance().log(beacon);
         }
@@ -216,7 +234,7 @@ private void processBeaconFromScan(Beacon beacon) {
 
             mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
 
-            List<Region> matchedRegions = null;
+            List<Region> matchedRegions;
             Iterator<Region> matchedRegionIterator;
             LogManager.d(TAG, "looking for ranging region matches for this beacon");
             synchronized (mRangedRegionState) {
@@ -234,16 +252,22 @@ private void processBeaconFromScan(Beacon beacon) {
         }
     }
 
-
+    /**
+     * <strong>This class is not thread safe.</strong>
+     */
     private class ScanData {
-        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
+        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
             this.device = device;
             this.rssi = rssi;
             this.scanRecord = scanRecord;
         }
 
-        int rssi;
+        final int rssi;
+
+        @NonNull
         BluetoothDevice device;
+
+        @NonNull
         byte[] scanRecord;
     }
 
@@ -252,10 +276,11 @@ public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
 
         private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
 
-        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
+        ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
             mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
         }
 
+        @WorkerThread
         @Override
         protected Void doInBackground(ScanHelper.ScanData... params) {
             ScanHelper.ScanData scanData = params[0];
@@ -304,7 +329,7 @@ protected void onProgressUpdate(Void... values) {
     }
 
     private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<Region>();
+        List<Region> matched = new ArrayList<>();
         for (Region region : regions) {
             if (region.matchesBeacon(beacon)) {
                 matched.add(region);
diff --git a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
index 37be84e9..d77e7eab 100644
--- a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
@@ -48,7 +48,7 @@ public void beaconScanCallbackTest() throws Exception {
         beaconServiceServiceController.attach();
         BeaconService beaconService = beaconServiceServiceController.get();
         beaconService.onCreate();
-        CycledLeScanCallback callback = beaconService.mCycledLeScanCallback;
+        CycledLeScanCallback callback = beaconService.getCycledLeScanCallback();
 
         ThreadPoolExecutor executor = (ThreadPoolExecutor) AsyncTask.THREAD_POOL_EXECUTOR;
         int activeThreadCountBeforeScan = executor.getActiveCount();
