diff --git a/.circleci/config.yml b/.circleci/config.yml
new file mode 100644
index 00000000..c12c6971
--- /dev/null
+++ b/.circleci/config.yml
@@ -0,0 +1,31 @@
+version: 2
+jobs:
+  build:
+    working_directory: ~/code
+    docker:
+      - image: circleci/android:api-25-alpha
+    environment:
+      JVM_OPTS: -Xmx3200m
+    steps:
+      - checkout
+      - restore_cache:
+          key: jars-{{ checksum "build.gradle" }}-{{ checksum  "./build.gradle" }}
+#      - run:
+#         name: Chmod permissions #if permission for Gradlew Dependencies fail, use this.
+#         command: sudo chmod +x ./gradlew
+      - run:
+          name: Download Dependencies
+          command: ./gradlew androidDependencies
+      - save_cache:
+          paths:
+            - ~/.gradle
+          key: jars-{{ checksum "build.gradle" }}-{{ checksum  "./build.gradle" }}
+      - run:
+          name: Run Tests
+          command: ./gradlew test
+      - store_artifacts:
+          path: ./build/reports
+          destination: reports
+      - store_test_results:
+          path: ./build/test-results
+      # See https://circleci.com/docs/2.0/deployment-integrations/ for deploy examples
diff --git a/CHANGELOG.md b/CHANGELOG.md
index e41f4100..661fe92b 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,21 @@
 ### Development
 
-Bug Fixes:
- - Stop running scheduled jobs to do sscans after last consumer unbound. (#702, David G. Young)
+- Prevent NPE on access CycledLEScanner after OOM on Android 8+.  (#766, David G. Young)
+
+### 2.15.2 / 2018-10-17
+
+- Prevent infrequent out of memory crashes on Android 8+ (#750 Pappas Christodoulos, David G. Young)
+- Prevent duplicate ranging/monitoring callbacks casued by bind/unbind with a service
+  (#748, Adrián Nieto Rodríguez, #745, David G. Young)
+- Allow starting foreground service at boot (#746, David G. Young)
+- Re-enable broken BeaconSimulator (#751, David G. Young)
+
+### 2.15.1 / 2018-09-01
+
+ - Prevent crash caused by internal Android exception when stopping scanning (#724, David G. Young)
+ - Fix Android 8 crashing apps on background monitoring/ranging data delivery (#720, David G. Young)
+ - Fix intermittent NPE on ranging beacons (#716, Federico Bertoli, David G. Young)
+ - Stop running scheduled jobs to do scans after last consumer unbound. (#702, David G. Young)
 
 ### 2.15 / 2018-07-04
 
diff --git a/README.md b/README.md
index 5a48df65..2c827a66 100644
--- a/README.md
+++ b/README.md
@@ -48,7 +48,7 @@ to use the JCenter Repository
 ```groovy
 dependencies {
     ...
-    compile 'org.altbeacon:android-beacon-library:${altbeacon.version}'
+    implementation 'org.altbeacon:android-beacon-library:${altbeacon.version}'
     ...
 }
 ```
diff --git a/build.gradle b/build.gradle
index f267f1de..5951f331 100644
--- a/build.gradle
+++ b/build.gradle
@@ -60,8 +60,8 @@ allprojects {
 }
 
 android {
-    compileSdkVersion 27
-    buildToolsVersion '27.0.3'
+    compileSdkVersion 28
+    buildToolsVersion '28.0.0'
 
     defaultConfig {
         // Unfortunately 'com.android.support:appcompat-v7:26.0.0'
@@ -69,7 +69,7 @@ android {
         // But since only 0.8% of Android devices have < SDK 14 as of Une 2017, this will become
         // the new min version for this library in order to target Android O
         minSdkVersion 14
-        targetSdkVersion 27
+        targetSdkVersion 28
         versionCode 1
         versionName version
         consumerProguardFiles 'proguard-rules.pro'
@@ -102,9 +102,10 @@ configurations {
 
 dependencies {
     compile fileTree ( dir: 'libs', include: ['*.jar'] )
-    compile 'com.android.support:support-v4:27.0.0'
-    compile 'com.android.support:support-annotations:26.0.0'
+    compile 'com.android.support:support-v4:28.0.0-rc02'
+    compile 'com.android.support:support-annotations:28.0.0-rc02'
 
+    testCompile 'com.google.android:android-test:4.1.1.4'
     testCompile('junit:junit:4.12') {
         exclude group: 'org.hamcrest'
     }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
index 8794252c..b2fe9039 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
@@ -40,10 +40,10 @@
  * This is used with ScanJob and supports delivering intents even under Android O background
  * restrictions preventing starting a new IntentService.
  *
- * It is not used with the BeaconService, as local broadcast intents cannot be deliverd across
- * different processes which the BeaconService supports.
+ * It is not used with the BeaconService, if running in a separate process, as local broadcast
+ * intents cannot be deliverd across different processes which the BeaconService supports.
  *
- * @see BeaconIntentProcessor for the equivalent use with BeaconService.
+ * @see BeaconIntentProcessor for the equivalent use with BeaconService in a separate process.
  **
  * Internal library class.  Do not use directly from outside the library
  *
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 4cd455bd..9dac4c40 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -177,12 +177,13 @@
      * Set to true if you want to show library debugging.
      *
      * @param debug True turn on all logs for this library to be printed out to logcat. False turns
-     *              off all logging.
-     * @deprecated To be removed in a future release. Use
+     *              off detailed logging..
+     *
+     * This is a convenience method that calls setLogger to a verbose logger and enables verbose
+     * logging. For more fine grained control, use:
      * {@link org.altbeacon.beacon.logging.LogManager#setLogger(org.altbeacon.beacon.logging.Logger)}
      * instead.
      */
-    @Deprecated
     public static void setDebug(boolean debug) {
         if (debug) {
             LogManager.setLogger(Loggers.verboseLogger());
@@ -393,7 +394,7 @@ protected void checkIfMainProcess() {
      */
     @TargetApi(18)
     public boolean checkAvailability() throws BleNotAvailableException {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             throw new BleNotAvailableException("Bluetooth LE not supported by this device");
         }
         return ((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled();
@@ -407,14 +408,10 @@ public boolean checkAvailability() throws BleNotAvailableException {
      * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
      */
     public void bind(@NonNull BeaconConsumer consumer) {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
-            LogManager.w(TAG, "This device does not support bluetooth LE.  Will not start beacon scanning.");
-            return;
-        }
         synchronized (consumers) {
             ConsumerInfo newConsumerInfo = new ConsumerInfo();
             ConsumerInfo alreadyBoundConsumerInfo = consumers.putIfAbsent(consumer, newConsumerInfo);
@@ -430,6 +427,13 @@ public void bind(@NonNull BeaconConsumer consumer) {
                 else {
                     LogManager.d(TAG, "Binding to service");
                     Intent intent = new Intent(consumer.getApplicationContext(), BeaconService.class);
+                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
+                            this.getForegroundServiceNotification() != null) {
+                        LogManager.i(TAG, "Starting foreground beacon scanning service.");
+                        mContext.startForegroundService(intent);
+                    }
+                    else {
+                    }
                     consumer.bindService(intent, newConsumerInfo.beaconServiceConnection, Context.BIND_AUTO_CREATE);
                 }
                 LogManager.d(TAG, "consumer count is now: %s", consumers.size());
@@ -444,7 +448,7 @@ public void bind(@NonNull BeaconConsumer consumer) {
      * @param consumer the <code>Activity</code> or <code>Service</code> that no longer needs to use the service.
      */
     public void unbind(@NonNull BeaconConsumer consumer) {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
@@ -533,7 +537,7 @@ public boolean isAnyConsumerBound() {
      * @see #setBackgroundBetweenScanPeriod(long p)
      */
     public void setBackgroundMode(boolean backgroundMode) {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
@@ -824,7 +828,7 @@ public void requestStateForRegion(@NonNull Region region) {
      */
     @TargetApi(18)
     public void startRangingBeaconsInRegion(@NonNull Region region) throws RemoteException {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
@@ -849,7 +853,7 @@ public void startRangingBeaconsInRegion(@NonNull Region region) throws RemoteExc
      */
     @TargetApi(18)
     public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteException {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
@@ -912,7 +916,7 @@ protected void syncSettingsToService() {
      */
     @TargetApi(18)
     public void startMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteException {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
@@ -943,7 +947,7 @@ public void startMonitoringBeaconsInRegion(@NonNull Region region) throws Remote
      */
     @TargetApi(18)
     public void stopMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteException {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
@@ -967,7 +971,7 @@ public void stopMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteE
      */
     @TargetApi(18)
     public void updateScanPeriods() throws RemoteException {
-        if (!isBleAvailable()) {
+        if (!isBleAvailableOrSimulated()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
@@ -1126,7 +1130,7 @@ public static void logDebug(String tag, String message, Throwable t) {
     @Nullable
     protected static BeaconSimulator beaconSimulator;
 
-    protected static String distanceModelUpdateUrl = "http://data.altbeacon.org/android-distance.json";
+    protected static String distanceModelUpdateUrl = "https://s3.amazonaws.com/android-beacon-library/android-distance.json";
 
     public static String getDistanceModelUpdateUrl() {
         return distanceModelUpdateUrl;
@@ -1200,6 +1204,12 @@ public void setNonBeaconLeScanCallback(@Nullable NonBeaconLeScanCallback callbac
         mNonBeaconLeScanCallback = callback;
     }
 
+    private boolean isBleAvailableOrSimulated() {
+        if (getBeaconSimulator() != null) {
+            return true;
+        }
+        return isBleAvailable();
+    }
     private boolean isBleAvailable() {
         boolean available = false;
         if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index f7bc12a7..2febe77f 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -45,6 +45,7 @@
 import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.BeaconParser;
 import org.altbeacon.beacon.BuildConfig;
@@ -75,6 +76,8 @@
     private final Handler handler = new Handler();
     private BluetoothCrashResolver bluetoothCrashResolver;
     private ScanHelper mScanHelper;
+    private BeaconLocalBroadcastProcessor mBeaconNotificationProcessor;
+
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -210,6 +213,8 @@ public void onCreate() {
         beaconManager.setScannerInSameProcess(true);
         if (beaconManager.isMainProcess()) {
             LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+            // if we are on the main process, we use local broadcast notifications to deliver results.
+            ensureNotificationProcessorSetup();
         }
         else {
             LogManager.i(TAG, "beaconService version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
@@ -220,7 +225,9 @@ public void onCreate() {
         String longScanForcingEnabled = getManifestMetadataValue("longScanForcingEnabled");
         if (longScanForcingEnabled != null && longScanForcingEnabled.equals("true")) {
             LogManager.i(TAG, "longScanForcingEnabled to keep scans going on Android N for > 30 minutes");
-            mScanHelper.getCycledScanner().setLongScanForcingEnabled(true);
+            if (mScanHelper.getCycledScanner() != null) {
+                mScanHelper.getCycledScanner().setLongScanForcingEnabled(true);
+            }
         }
 
         mScanHelper.reloadParsers();
@@ -241,6 +248,15 @@ public void onCreate() {
         this.startForegroundIfConfigured();
     }
 
+
+    private void ensureNotificationProcessorSetup() {
+        if (mBeaconNotificationProcessor == null) {
+            mBeaconNotificationProcessor = new BeaconLocalBroadcastProcessor(this);
+            mBeaconNotificationProcessor.register();
+        }
+    }
+
+
     /*
      * This starts the scanning service as a foreground service if it is so configured in the
      * manifest
@@ -306,12 +322,18 @@ public void onDestroy() {
             LogManager.w(TAG, "Not supported prior to API 18.");
             return;
         }
+        if (mBeaconNotificationProcessor != null) {
+            mBeaconNotificationProcessor.unregister();
+        }
         stopForeground(true);
         bluetoothCrashResolver.stop();
         LogManager.i(TAG, "onDestroy called.  stopping scanning");
         handler.removeCallbacksAndMessages(null);
-        mScanHelper.getCycledScanner().stop();
-        mScanHelper.getCycledScanner().destroy();
+
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.getCycledScanner().stop();
+            mScanHelper.getCycledScanner().destroy();
+        }
         mScanHelper.getMonitoringStatus().stopStatusPreservation();
     }
 
@@ -346,7 +368,9 @@ public void startRangingBeaconsInRegion(Region region, Callback callback) {
             mScanHelper.getRangedRegionState().put(region, new RangeState(callback));
             LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
-        mScanHelper.getCycledScanner().start();
+        if (mScanHelper.getCycledScanner() != null) {
+            mScanHelper.getCycledScanner().start();
+        }
     }
 
     @MainThread
@@ -359,7 +383,9 @@ public void stopRangingBeaconsInRegion(Region region) {
         }
 
         if (rangedRegionCount == 0 && mScanHelper.getMonitoringStatus().regionsCount() == 0) {
-            mScanHelper.getCycledScanner().stop();
+            if (mScanHelper.getCycledScanner() != null) {
+                mScanHelper.getCycledScanner().stop();
+            }
         }
     }
 
@@ -368,7 +394,9 @@ public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
         LogManager.d(TAG, "startMonitoring called");
         mScanHelper.getMonitoringStatus().addRegion(region, callback);
         LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
-        mScanHelper.getCycledScanner().start();
+        if (mScanHelper.getCycledScanner() != null) {
+            mScanHelper.getCycledScanner().start();
+        }
     }
 
     @MainThread
@@ -377,13 +405,17 @@ public void stopMonitoringBeaconsInRegion(Region region) {
         mScanHelper.getMonitoringStatus().removeRegion(region);
         LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
         if (mScanHelper.getMonitoringStatus().regionsCount() == 0 && mScanHelper.getRangedRegionState().size() == 0) {
-            mScanHelper.getCycledScanner().stop();
+            if (mScanHelper.getCycledScanner() != null) {
+                mScanHelper.getCycledScanner().stop();
+            }
         }
     }
 
     @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
+        if (mScanHelper.getCycledScanner() != null) {
+            mScanHelper.getCycledScanner().setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
+        }
     }
 
     public void reloadParsers() {
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index a8c9ad92..512f031d 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -52,7 +52,7 @@ public Callback(String intentPackageName) {
      * @return false if it callback cannot be made
      */
     public boolean call(Context context, String dataName, Bundle data) {
-        boolean useLocalBroadcast = BeaconManager.getInstanceForApplication(context).getScheduledScanJobsEnabled();
+        boolean useLocalBroadcast = BeaconManager.getInstanceForApplication(context).isMainProcess();
         boolean success = false;
 
         if(useLocalBroadcast) {
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index bba10079..ed5aa765 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -47,8 +47,8 @@ public Callback getCallback() {
     }
 
     public void addBeacon(Beacon beacon) {
-        if (mRangedBeacons.containsKey(beacon)) {
-            RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
+        RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
+        if (rangedBeacon != null) {
             if (LogManager.isVerboseLoggingEnabled()) {
                 LogManager.d(TAG, "adding %s to existing range for: %s", beacon, rangedBeacon);
             }
@@ -71,23 +71,25 @@ public void addBeacon(Beacon beacon) {
         synchronized (mRangedBeacons) {
             for (Beacon beacon : mRangedBeacons.keySet()) {
                 RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
-                if (rangedBeacon.isTracked()) {
-                    rangedBeacon.commitMeasurements(); // calculates accuracy
-                    if (!rangedBeacon.noMeasurementsAvailable()) {
-                        finalizedBeacons.add(rangedBeacon.getBeacon());
+                if (rangedBeacon != null) {
+                    if (rangedBeacon.isTracked()) {
+                        rangedBeacon.commitMeasurements(); // calculates accuracy
+                        if (!rangedBeacon.noMeasurementsAvailable()) {
+                            finalizedBeacons.add(rangedBeacon.getBeacon());
+                        }
+                    }
+                    // If we still have useful measurements, keep it around but mark it as not
+                    // tracked anymore so we don't pass it on as visible unless it is seen again
+                    if (!rangedBeacon.noMeasurementsAvailable() == true) {
+                        //if TrackingCache is enabled, allow beacon to not receive
+                        //measurements for a certain amount of time
+                        if (!sUseTrackingCache || rangedBeacon.isExpired())
+                            rangedBeacon.setTracked(false);
+                        newRangedBeacons.put(beacon, rangedBeacon);
+                    }
+                    else {
+                        LogManager.d(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
                     }
-                }
-                // If we still have useful measurements, keep it around but mark it as not
-                // tracked anymore so we don't pass it on as visible unless it is seen again
-                if (!rangedBeacon.noMeasurementsAvailable() == true) {
-                    //if TrackingCache is enabled, allow beacon to not receive
-                    //measurements for a certain amount of time
-                    if (!sUseTrackingCache || rangedBeacon.isExpired())
-                        rangedBeacon.setTracked(false);
-                    newRangedBeacons.put(beacon, rangedBeacon);
-                }
-                else {
-                    LogManager.d(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
                 }
             }
             mRangedBeacons = newRangedBeacons;
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
deleted file mode 100644
index 758f0995..00000000
--- a/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
+++ /dev/null
@@ -1,173 +0,0 @@
-package org.altbeacon.beacon.service;
-
-import android.annotation.TargetApi;
-import android.app.Service;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.le.ScanResult;
-import android.content.pm.ApplicationInfo;
-import android.os.Build;
-
-import org.altbeacon.beacon.Beacon;
-import org.altbeacon.beacon.BeaconManager;
-import org.altbeacon.beacon.BeaconParser;
-import org.altbeacon.beacon.Region;
-import org.altbeacon.beacon.logging.LogManager;
-import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-/**
- * Created by dyoung on 3/24/17.
- * @hice
- */
-
-public class ScanDataProcessor {
-    private static final String TAG = ScanDataProcessor.class.getSimpleName();
-    private Service mService;
-    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
-    private MonitoringStatus mMonitoringStatus;
-    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
-    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
-    // TODO: implement this
-    private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-    private DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
-
-    int trackedBeaconsPacketCount;
-
-
-    public ScanDataProcessor(Service scanService, ScanState scanState) {
-        mService = scanService;
-        mMonitoringStatus = scanState.getMonitoringStatus();
-        mRangedRegionState = scanState.getRangedRegionState();
-        mMonitoringStatus = scanState.getMonitoringStatus();
-        mExtraDataBeaconTracker = scanState.getExtraBeaconDataTracker();
-        mBeaconParsers = scanState.getBeaconParsers();
-    }
-
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    public void process(ScanResult scanResult) {
-        ScanData scanData= new ScanData(scanResult.getDevice(), scanResult.getRssi(), scanResult.getScanRecord().getBytes());
-        process(scanData);
-    }
-
-    public void process(ScanData scanData) {
-        Beacon beacon = null;
-
-        for (BeaconParser parser : mBeaconParsers) {
-            beacon = parser.fromScanData(scanData.scanRecord,
-                    scanData.rssi, scanData.device);
-
-            if (beacon != null) {
-                break;
-            }
-        }
-        if (beacon != null) {
-            mDetectionTracker.recordDetection();
-            trackedBeaconsPacketCount++;
-            processBeaconFromScan(beacon);
-        } else {
-            if (mNonBeaconLeScanCallback != null) {
-                mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
-            }
-        }
-
-    }
-    private class ScanData {
-        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
-            this.device = device;
-            this.rssi = rssi;
-            this.scanRecord = scanRecord;
-        }
-
-        int rssi;
-        BluetoothDevice device;
-        byte[] scanRecord;
-    }
-
-    private void processBeaconFromScan(Beacon beacon) {
-        if (Stats.getInstance().isEnabled()) {
-            Stats.getInstance().log(beacon);
-        }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG,
-                    "beacon detected : %s", beacon.toString());
-        }
-
-        beacon = mExtraDataBeaconTracker.track(beacon);
-        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
-        // the above
-        if (beacon == null) {
-            if (LogManager.isVerboseLoggingEnabled()) {
-                LogManager.d(TAG,
-                        "not processing detections for GATT extra data beacon");
-            }
-        } else {
-            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
-
-            List<Region> matchedRegions = null;
-            Iterator<Region> matchedRegionIterator;
-            LogManager.d(TAG, "looking for ranging region matches for this beacon out of "+mRangedRegionState.keySet().size()+" regions.");
-            synchronized (mRangedRegionState) {
-                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
-                matchedRegionIterator = matchedRegions.iterator();
-                while (matchedRegionIterator.hasNext()) {
-                    Region region = matchedRegionIterator.next();
-                    LogManager.d(TAG, "matches ranging region: %s", region);
-                    RangeState rangeState = mRangedRegionState.get(region);
-                    if (rangeState != null) {
-                        rangeState.addBeacon(beacon);
-                    }
-                }
-            }
-        }
-    }
-    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<Region>();
-        for (Region region : regions) {
-            if (region.matchesBeacon(beacon)) {
-                matched.add(region);
-            } else {
-                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
-            }
-        }
-        return matched;
-    }
-
-    public void onCycleEnd() {
-        mMonitoringStatus.updateNewlyOutside();
-        processRangeData();
-        if (BeaconManager.getBeaconSimulator() != null) {
-            // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-            // it will not be used if we are not in debug mode
-            if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
-                if (0 != (mService.getApplicationContext().getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                    for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
-                        processBeaconFromScan(beacon);
-                    }
-                } else {
-                    LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
-                }
-            } else {
-                LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
-            }
-        }
-    }
-    private void processRangeData() {
-        synchronized (mRangedRegionState) {
-            for (Region region : mRangedRegionState.keySet()) {
-                RangeState rangeState = mRangedRegionState.get(region);
-                LogManager.d(TAG, "Calling ranging callback");
-                Callback callback = new Callback(mService.getPackageName());
-                callback.call(mService, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
-            }
-        }
-    }
-
-}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
index 8821006e..21802232 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -16,6 +16,7 @@
 import android.os.Build;
 import android.support.annotation.MainThread;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.support.annotation.RequiresApi;
 import android.support.annotation.WorkerThread;
 import android.support.annotation.RestrictTo;
@@ -61,6 +62,7 @@
     private static final String TAG = ScanHelper.class.getSimpleName();
     private ExecutorService mExecutor;
     private BeaconManager mBeaconManager;
+    @Nullable
     private CycledLeScanner mCycledScanner;
     private MonitoringStatus mMonitoringStatus;
     private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
@@ -79,7 +81,7 @@
         mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
     }
 
-    CycledLeScanner getCycledScanner() {
+    @Nullable CycledLeScanner getCycledScanner() {
         return mCycledScanner;
     }
 
@@ -129,8 +131,9 @@ void processScanResult(BluetoothDevice device, int rssi, byte[] scanRecord) {
             new ScanHelper.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
                     new ScanHelper.ScanData(device, rssi, scanRecord));
         } catch (RejectedExecutionException e) {
-
             LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+        } catch (OutOfMemoryError e) {
+            LogManager.w(TAG, "Ignoring scan result because we cannot start a thread to keep up.");
         }
     }
 
@@ -196,6 +199,9 @@ void stopAndroidOBackgroundScan() {
             }
         } catch (SecurityException e) {
             LogManager.e(TAG, "SecurityException stopping Android O background scanner");
+        } catch (RuntimeException e) {
+            // Needed to stop a crash caused by internal Android throw.  See issue #701
+            LogManager.e(TAG, "Unexpected runtime exception stopping Android O background scanner", e);
         }
     }
 
@@ -218,31 +224,13 @@ public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
         @MainThread
         @SuppressLint("WrongThread")
         public void onCycleEnd() {
-            mDistinctPacketDetector.clearDetections();
-            mMonitoringStatus.updateNewlyOutside();
-            processRangeData();
-            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
-            if (mSimulatedScanData != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
-
-                if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                    for (Beacon beacon : mSimulatedScanData) {
-                        // This is an expensive call and we do not want to block the main thread.
-                        // But here we are in debug/test mode so we allow it on the main thread.
-                        //noinspection WrongThread
-                        processBeaconFromScan(beacon);
-                    }
-                } else {
-                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
-                }
-            }
             if (BeaconManager.getBeaconSimulator() != null) {
+                LogManager.d(TAG, "Beacon simulator enabled");
                 // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
                 // it will not be used if we are not in debug mode
                 if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
                     if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                        LogManager.d(TAG, "Beacon simulator returns "+BeaconManager.getBeaconSimulator().getBeacons().size()+" beacons.");
                         for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
                             // This is an expensive call and we do not want to block the main thread.
                             // But here we are in debug/test mode so we allow it on the main thread.
@@ -256,6 +244,14 @@ public void onCycleEnd() {
                     LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
                 }
             }
+            else {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon simulator not enabled");
+                }
+            }
+            mDistinctPacketDetector.clearDetections();
+            mMonitoringStatus.updateNewlyOutside();
+            processRangeData();
         }
     };
 
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
index 9e580d9b..deb08039 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJob.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -54,7 +54,10 @@
 
     @Override
     public boolean onStartJob(final JobParameters jobParameters) {
-        initialzeScanHelper();
+        if (!initialzeScanHelper()) {
+            LogManager.e(TAG, "Cannot allocate a scanner to look for beacons.  System resources are low.");
+            return false;
+        }
         if (jobParameters.getJobId() == getImmediateScanJobId(this)) {
             LogManager.i(TAG, "Running immediate scan job: instance is "+this);
         }
@@ -163,12 +166,15 @@ public boolean onStopJob(JobParameters params) {
 
     private void stopScanning() {
         mInitialized = false;
-        mScanHelper.getCycledScanner().stop();
-        mScanHelper.getCycledScanner().destroy();
+        if (mScanHelper.getCycledScanner() != null) {
+            mScanHelper.getCycledScanner().stop();
+            mScanHelper.getCycledScanner().destroy();
+        }
         LogManager.d(TAG, "Scanning stopped");
     }
 
-    private void initialzeScanHelper() {
+    // Returns false if cycle thread cannot be allocated
+    private boolean initialzeScanHelper() {
         mScanHelper = new ScanHelper(this);
         mScanState = ScanState.restore(ScanJob.this);
         mScanState.setLastScanStartTimeMillis(System.currentTimeMillis());
@@ -177,8 +183,15 @@ private void initialzeScanHelper() {
         mScanHelper.setBeaconParsers(mScanState.getBeaconParsers());
         mScanHelper.setExtraDataBeaconTracker(mScanState.getExtraBeaconDataTracker());
         if (mScanHelper.getCycledScanner() == null) {
-            mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
+            try {
+                mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
+            }
+            catch (OutOfMemoryError e) {
+                LogManager.w(TAG, "Failed to create CycledLeScanner thread.");
+                return false;
+            }
         }
+        return true;
     }
 
     // Returns true of scanning actually was started, false if it did not need to be
@@ -188,22 +201,30 @@ private boolean restartScanning() {
         }
         long scanPeriod = mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod();
         long betweenScanPeriod = mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod();
-        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod,
-                                                      betweenScanPeriod,
-                                                      mScanState.getBackgroundMode());
+        if (mScanHelper.getCycledScanner() != null) {
+            mScanHelper.getCycledScanner().setScanPeriods(scanPeriod,
+                    betweenScanPeriod,
+                    mScanState.getBackgroundMode());
+        }
         mInitialized = true;
         if (scanPeriod <= 0) {
             LogManager.w(TAG, "Starting scan with scan period of zero.  Exiting ScanJob.");
-            mScanHelper.getCycledScanner().stop();
+            if (mScanHelper.getCycledScanner() != null) {
+                mScanHelper.getCycledScanner().stop();
+            }
             return false;
         }
 
         if (mScanHelper.getRangedRegionState().size() > 0 || mScanHelper.getMonitoringStatus().regions().size() > 0) {
-            mScanHelper.getCycledScanner().start();
+            if (mScanHelper.getCycledScanner() != null) {
+                mScanHelper.getCycledScanner().start();
+            }
             return true;
         }
         else {
-            mScanHelper.getCycledScanner().stop();
+            if (mScanHelper.getCycledScanner() != null) {
+                mScanHelper.getCycledScanner().stop();
+            }
             return false;
         }
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
index 6e8b592e..6eb17c23 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -96,6 +96,10 @@ public void cancelSchedule(Context context) {
         JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
         jobScheduler.cancel(ScanJob.getImmediateScanJobId(context));
         jobScheduler.cancel(ScanJob.getPeriodicScanJobId(context));
+
+        if (mBeaconNotificationProcessor != null) {
+            mBeaconNotificationProcessor.unregister();
+        }
     }
 
     // This method appears to be never used, because it is only used by Android O APIs, which
