diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 63f38787..3a50855a 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -39,6 +39,7 @@
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
+import android.support.annotation.NonNull;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -93,7 +94,7 @@
     private ExtraDataBeaconTracker mExtraDataBeaconTracker;
     private ExecutorService mExecutor;
     private final DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
-    
+
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -476,16 +477,23 @@ private void processBeaconFromScan(Beacon beacon) {
     }
 
 
-    private class ScanData {
-        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
+    /**
+     * <strong>This class is not thread safe.</strong>
+     */
+    private static class ScanData {
+        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
             this.device = device;
             this.rssi = rssi;
             this.scanRecord = scanRecord;
         }
 
-        int rssi;
-        BluetoothDevice device;
-        byte[] scanRecord;
+        final int rssi;
+
+        @NonNull
+        final BluetoothDevice device;
+
+        @NonNull
+        final byte[] scanRecord;
     }
 
     private class ScanProcessor extends AsyncTask<ScanData, Void, Void> {
@@ -502,7 +510,7 @@ protected Void doInBackground(ScanData... params) {
             ScanData scanData = params[0];
             Beacon beacon = null;
 
-            for (BeaconParser parser : BeaconService.this.beaconParsers) {
+            for (BeaconParser parser : beaconParsers) {
                 beacon = parser.fromScanData(scanData.scanRecord,
                         scanData.rssi, scanData.device);
 
@@ -518,7 +526,7 @@ protected Void doInBackground(ScanData... params) {
                 if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
                     if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
                             scanData.scanRecord)) {
-                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unnecessary.");
                         mCycledScanner.setDistinctPacketsDetectedPerScan(true);
                     }
                 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
index 42978d30..daff6763 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
@@ -1,6 +1,6 @@
 package org.altbeacon.beacon.service.scanner;
 
-import android.util.Log;
+import android.support.annotation.NonNull;
 
 import java.nio.ByteBuffer;
 import java.util.HashSet;
@@ -8,30 +8,33 @@
 
 /**
  * Created by dyoung on 4/8/17.
- *
+ * <p>
  * This class tracks whether multiple distinct BLE packets have been seen, with the purpose of
  * determining if the Android device supports detecting multiple distinct packets in a single scan.
  * Some older devices are not capable of this (e.g. Nexus 4, Moto G1), so detecting multiple packets
  * requires stopping and restarting scanning on these devices.  This allows detecting if that is
- * neessary
+ * necessary.
+ * <p>
+ * <strong>This class is not thread safe.</strong>
  */
 public class DistinctPacketDetector {
     // Sanity limit for the number of packets to track, so we don't use too much memory
     private static final int MAX_PACKETS_TO_TRACK = 1000;
-    protected Set<ByteBuffer> mDistinctPacketsDetected = new HashSet<ByteBuffer>();
+
+    @NonNull
+    private final Set<ByteBuffer> mDistinctPacketsDetected = new HashSet<>();
 
     public void clearDetections() {
         mDistinctPacketsDetected.clear();
     }
 
-    public boolean isPacketDistinct(String originMacAddress, byte[] scanRecord) {
+    public boolean isPacketDistinct(@NonNull String originMacAddress, @NonNull byte[] scanRecord) {
         byte[] macBytes = originMacAddress.getBytes();
         ByteBuffer buffer = ByteBuffer.allocate(macBytes.length+scanRecord.length);
         buffer.put(macBytes);
         buffer.put(scanRecord);
         buffer.rewind(); // rewind puts position back to beginning so .equals and .hashCode work
 
-        boolean distinct = !mDistinctPacketsDetected.contains(buffer);
         if (mDistinctPacketsDetected.size() == MAX_PACKETS_TO_TRACK) {
             return mDistinctPacketsDetected.contains(buffer);
         }
