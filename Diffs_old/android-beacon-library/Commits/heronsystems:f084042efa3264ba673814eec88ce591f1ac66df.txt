diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index 2000a4d8..e457e835 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -28,6 +28,8 @@
             android:exported="false"
             />
 
+        <service android:name=".service.ScanJob"
+                 android:permission="android.permission.BIND_JOB_SERVICE" />
     </application>
 
 </manifest>
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index a8d9c049..aad80f91 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -43,6 +43,8 @@
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanState;
 import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
@@ -339,6 +341,12 @@ public void bind(BeaconConsumer consumer) {
             LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
+        if (mScheduledScanJobsEnabled) {
+            LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
+            consumer.onBeaconServiceConnect();
+            return;
+        }
+
         synchronized (consumers) {
             ConsumerInfo newConsumerInfo = new ConsumerInfo();
             ConsumerInfo alreadyBoundConsumerInfo = consumers.putIfAbsent(consumer, newConsumerInfo);
@@ -447,6 +455,25 @@ public void setBackgroundMode(boolean backgroundMode) {
             }
         }
     }
+    private boolean mScheduledScanJobsEnabled = false;
+    public void setEnableScheduledScanJobs(boolean enabled) {
+        this.mScheduledScanJobsEnabled = enabled;
+    }
+    public boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+    public long getBackgroundScanPeriod() {
+        return backgroundScanPeriod;
+    }
+    public long getBackgroundBetweenScanPeriod() {
+        return backgroundBetweenScanPeriod;
+    }
+    public long getForegroundScanPeriod() {
+        return foregroundScanPeriod;
+    }
+    public long getForegroundBetweenScanPeriod() {
+        return foregroundBetweenScanPeriod;
+    }
 
     /**
      * @return indicator of whether any calls have yet been made to set the
@@ -663,12 +690,17 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
             LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             rangedRegions.add(region);
         }
@@ -690,12 +722,14 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (!mScheduledScanJobsEnabled) {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             Region regionToRemove = null;
             for (Region rangedRegion : rangedRegions) {
@@ -705,6 +739,9 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             }
             rangedRegions.remove(regionToRemove);
         }
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.startMonitoring(mContext, this, region);
+        }
     }
 
     /**
@@ -733,13 +770,18 @@ protected void syncSettingsToService() {
             LogManager.e(TAG, "The BeaconManager is not bound to the service.  Settings synchronization will fail.");
             return;
         }
-        try {
-            Message msg = Message.obtain(null, BeaconService.MSG_SYNC_SETTINGS, 0, 0);
-            msg.setData(new SettingsData().collect(mContext).toBundle());
-            serviceMessenger.send(msg);
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
         }
-        catch (RemoteException e) {
-            LogManager.e(TAG, "Failed to sync settings to service", e);
+        else {
+            try {
+                Message msg = Message.obtain(null, BeaconService.MSG_SYNC_SETTINGS, 0, 0);
+                msg.setData(new SettingsData().collect(mContext).toBundle());
+                serviceMessenger.send(msg);
+            }
+            catch (RemoteException e) {
+                LogManager.e(TAG, "Failed to sync settings to service", e);
+            }
         }
     }
 
@@ -760,13 +802,18 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
             LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
+            Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
         }
-        LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
-        Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         this.requestStateForRegion(region);
     }
 
@@ -787,12 +834,18 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
             LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+            ScanJob.stopMonitoring(mContext, this, region);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
     }
 
 
@@ -808,6 +861,10 @@ public void updateScanPeriods() throws RemoteException {
             LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
             return;
         }
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+            return;
+        }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
index a93e8fb2..303efdd4 100644
--- a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
@@ -2,6 +2,7 @@
 
 import org.altbeacon.beacon.Beacon;
 
+import java.io.Serializable;
 import java.util.HashMap;
 
 /**
@@ -9,7 +10,7 @@
  * merges them together depending on configured beacon parsers
  * Created by dyoung on 5/5/15.
  */
-public class ExtraDataBeaconTracker {
+public class ExtraDataBeaconTracker implements Serializable {
     private static final String TAG = "BeaconTracker";
     // This is a lookup table to find tracked beacons by the calculated beacon key
     private HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<String,HashMap<Integer,Beacon>>();
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index 0c1ad59e..1ea9c7b0 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -26,14 +26,15 @@
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
-public class RangeState {
+public class RangeState implements Serializable {
     private static final String TAG = "RangeState";
-    private final Callback mCallback;
+    private transient Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
     private static boolean sUseTrackingCache = false;
 
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index a5b321cb..99bb25ce 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -6,9 +6,11 @@
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
-public class RangedBeacon {
+public class RangedBeacon implements Serializable {
 
     private static final String TAG = "RangedBeacon";
     public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
@@ -19,18 +21,9 @@
     private boolean mTracked = true;
     protected long lastTrackedTimeMillis = 0;
     Beacon mBeacon;
-    protected RssiFilter filter = null;
+    protected transient RssiFilter mFilter = null;
 
     public RangedBeacon(Beacon beacon) {
-        //set RSSI filter
-        try {
-            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
-            filter = (RssiFilter)cons.newInstance();
-        } catch (Exception e) {
-            LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
-        }
-
-        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
         updateBeacon(beacon);
     }
 
@@ -53,8 +46,11 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-        if (!filter.noMeasurementsAvailable()) {
-            double runningAverage = filter.calculateRssi();
+
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
+
+        if (!getFilter().noMeasurementsAvailable()) {
+            double runningAverage = getFilter().calculateRssi();
             mBeacon.setRunningAverageRssi(runningAverage);
             LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
@@ -69,8 +65,22 @@ public void addMeasurement(Integer rssi) {
         if (rssi != 127) {
             mTracked = true;
             lastTrackedTimeMillis = SystemClock.elapsedRealtime();
-            filter.addMeasurement(rssi);
+            getFilter().addMeasurement(rssi);
+        }
+    }
+
+    private RssiFilter getFilter() {
+        if (mFilter == null) {
+            //set RSSI filter
+            try {
+                Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
+                mFilter = (RssiFilter)cons.newInstance();
+            } catch (Exception e) {
+                LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
+            }
+
         }
+        return mFilter;
     }
 
     //kept here for backward compatibility
@@ -83,7 +93,7 @@ public static void setMaxTrackinAge(int maxTrackinAge) {
     }
 
     public boolean noMeasurementsAvailable() {
-        return filter.noMeasurementsAvailable();
+        return getFilter().noMeasurementsAvailable();
     }
 
     public long getTrackingAge() {
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
new file mode 100644
index 00000000..716946bd
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
@@ -0,0 +1,173 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.Service;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.le.ScanResult;
+import android.content.pm.ApplicationInfo;
+import android.os.Build;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Created by dyoung on 3/24/17.
+ */
+
+public class ScanDataProcessor {
+    private static final String TAG = ScanDataProcessor.class.getSimpleName();
+    private Service mService;
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    // TODO: implement this
+    private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+    // TODO: re-evaluate the need for this
+    private DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+    int trackedBeaconsPacketCount;
+
+
+    public ScanDataProcessor(Service scanService, ScanState scanState) {
+        mService = scanService;
+        mMonitoringStatus = scanState.getMonitoringStatus();
+        mRangedRegionState = scanState.getRangedRegionState();
+        mMonitoringStatus = scanState.getMonitoringStatus();
+        mExtraDataBeaconTracker = scanState.getExtraBeaconDataTracker();
+        mBeaconParsers = scanState.getBeaconParsers();
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public void process(ScanResult scanResult) {
+        ScanData scanData= new ScanData(scanResult.getDevice(), scanResult.getRssi(), scanResult.getScanRecord().getBytes());
+        process(scanData);
+    }
+
+    public void process(ScanData scanData) {
+        Beacon beacon = null;
+
+        for (BeaconParser parser : mBeaconParsers) {
+            beacon = parser.fromScanData(scanData.scanRecord,
+                    scanData.rssi, scanData.device);
+
+            if (beacon != null) {
+                break;
+            }
+        }
+        if (beacon != null) {
+            mDetectionTracker.recordDetection();
+            trackedBeaconsPacketCount++;
+            processBeaconFromScan(beacon);
+        } else {
+            if (mNonBeaconLeScanCallback != null) {
+                mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+            }
+        }
+
+    }
+    private class ScanData {
+        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        int rssi;
+        BluetoothDevice device;
+        byte[] scanRecord;
+    }
+
+    private void processBeaconFromScan(Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions = null;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon out of "+mRangedRegionState.keySet().size()+" regions.");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<Region>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+
+    public void onCycleEnd() {
+        mMonitoringStatus.updateNewlyOutside();
+        processRangeData();
+        if (BeaconManager.getBeaconSimulator() != null) {
+            // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+            // it will not be used if we are not in debug mode
+            if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                if (0 != (mService.getApplicationContext().getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                }
+            } else {
+                LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+            }
+        }
+    }
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                Callback callback = new Callback(mService.getPackageName());
+                callback.call(mService, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
new file mode 100644
index 00000000..a36e1fe4
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -0,0 +1,270 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.job.JobInfo;
+import android.app.job.JobParameters;
+import android.app.job.JobScheduler;
+import android.app.job.JobService;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanResult;
+import android.content.ComponentName;
+import android.content.Context;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.os.ParcelUuid;
+import android.os.PersistableBundle;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/**
+ * Created by dyoung on 3/24/17.
+ */
+
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+public class ScanJob extends JobService {
+    private static final String TAG = ScanJob.class.getSimpleName();
+    private ScanDataProcessor mScanDataProcessor;
+    private ScanState mScanState;
+    private ExecutorService mExecutor;
+    private BluetoothLeScanner mBluetoothLeScanner;
+    private BluetoothAdapter mBluetoothAdapter;
+    private BluetoothLeScanner mScanner;
+    private int mPacketsDetected;
+    private int mPacketsProcessed;
+
+
+    @Override
+    public boolean onStartJob(JobParameters jobParameters) {
+        // TODO: deserializing and serializing scanState every 1 second is pretty heavy weight
+        // There should be a way of running this longer if in the foreground to cut down on this.
+        // Also consider using jobParameters instead of persisting to disk in ScanState, however
+        // Since the job state may be changed externally by a client app, we would need to
+        // update the schedule job each time this is done.
+        // TODO: this deserialization should not be on the main thread.
+        LogManager.i(TAG, "Running scan job");
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
+        new JobTask(this).executeOnExecutor(mExecutor, jobParameters);
+        return true;
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters params) {
+        return false;
+    }
+
+
+    private class JobTask extends AsyncTask<JobParameters, Void, JobParameters> {
+        private JobService mJobService;
+
+        public JobTask(JobService jobService) {
+            this.mJobService = jobService;
+        }
+
+        @Override
+        protected JobParameters doInBackground(JobParameters... params) {
+            mScanState = ScanState.restore(ScanJob.this);
+            mScanDataProcessor = new ScanDataProcessor(ScanJob.this, mScanState);
+            // TODO: set up filters
+            mPacketsDetected = 0;
+            mPacketsProcessed = 0;
+            BluetoothLeScanner scanner = getScanner();
+            if (getScanner() != null) {
+                LogManager.d(TAG, "Starting scan cycle");
+                getScanner().startScan(mLeScanCallback);
+                try {
+                    Thread.sleep(mScanState.getBackgroundScanPeriod());
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+                if (mPacketsProcessed < mPacketsDetected) {
+                    LogManager.d(TAG, "Waiting to finish processing packets.  "+mPacketsProcessed+" of "+mPacketsDetected+" complete");
+                    try {
+                        Thread.sleep(20l);
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+                LogManager.d(TAG, "Stopping scan cycle");
+                scanner.stopScan(mLeScanCallback);
+                mScanState.save();
+                mScanDataProcessor.onCycleEnd();
+            }
+            else {
+                LogManager.d(TAG, "Cannot get scanner.");
+            }
+            // TODO: the saving here may conflict with changes made by the manager while the scan
+            // Remember the settings timestamp, and only save if the file is unchanged.  This would
+            // Discard the last scan results if  the scan settings changed while in this process.
+            // Alternately, figure out a way to merge the two copies.
+            return params[0];
+        }
+
+        @Override
+        protected void onPostExecute(JobParameters jobParameters) {
+            LogManager.i(TAG, "Finished scan job");
+            mJobService.jobFinished(jobParameters, false);
+        }
+    }
+
+    private class ProcessScanResultTask extends AsyncTask<ScanResult, Void, Void> {
+
+        public ProcessScanResultTask() {
+        }
+
+        @Override
+        protected Void doInBackground(ScanResult... scanResult) {
+            mScanDataProcessor.process(scanResult[0]);
+            mPacketsProcessed += 1;
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void params) {
+        }
+    }
+
+
+    //TODO: Move this and the static methods below to its own utility class
+
+    private static int sJobId = 9826351; // TODO: make this configurable
+
+    public static void startMonitoring(Context context, BeaconManager beaconManager, Region region) {
+        ScanState scanState = ScanState.restore(context);
+        scanState.getMonitoringStatus().addRegion(region, new Callback(context.getPackageName()));
+        applySettingsToScheduledJob(context, beaconManager, scanState);
+    }
+    public static void stopMonitoring(Context context, BeaconManager beaconManager, Region region) {
+        ScanState scanState = ScanState.restore(context);
+        scanState.getMonitoringStatus().removeRegion(region);
+        applySettingsToScheduledJob(context, beaconManager, scanState);
+    }
+    public static void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
+        scanState.applyChanges(beaconManager);
+
+        int periodMillis = (int) (beaconManager.getBackgroundMode() ?
+                beaconManager.getBackgroundScanPeriod()+beaconManager.getBackgroundBetweenScanPeriod() :
+                beaconManager.getForegroundScanPeriod()+beaconManager.getForegroundBetweenScanPeriod());
+
+        schedule(context, sJobId, new PersistableBundle(), periodMillis);
+    }
+
+    public static void applySettingsToScheduledJob(Context context, BeaconManager beaconManager) {
+        LogManager.d(TAG, "Applying settings to ScanJob");
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        jobScheduler.cancel(sJobId);
+        ScanState scanState = ScanState.restore(context);
+        applySettingsToScheduledJob(context, beaconManager, scanState);
+    }
+    /**
+     *
+     * @param context
+     */
+    public static void schedule(Context context, Integer jobId, PersistableBundle scanJobSettings, int periodMillis) {
+        LogManager.d(TAG, "Scheduling ScanJob");
+        JobInfo job = new JobInfo.Builder(jobId, new ComponentName(context, ScanJob.class))
+                .setPersisted(true) // This makes it restart after reboot
+                .setExtras(scanJobSettings)
+                .setPeriodic(periodMillis)
+                .build();
+
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        int error = jobScheduler.schedule(job);
+        if (error < 0) {
+            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+        }
+    }
+
+    private boolean isBluetoothOn() {
+        try {
+            BluetoothAdapter bluetoothAdapter = getBluetoothAdapter();
+            if (bluetoothAdapter != null) {
+                return (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON);
+            }
+            LogManager.w(TAG, "Cannot get bluetooth adapter");
+        }
+        catch (SecurityException e) {
+            LogManager.w(TAG, "SecurityException checking if bluetooth is on");
+        }
+        return false;
+    }
+
+    private BluetoothLeScanner getScanner() {
+        try {
+            if (mScanner == null) {
+                LogManager.d(TAG, "Making new Android L scanner");
+                BluetoothAdapter bluetoothAdapter = getBluetoothAdapter();
+                if (bluetoothAdapter != null) {
+                    mScanner = getBluetoothAdapter().getBluetoothLeScanner();
+                }
+                if (mScanner == null) {
+                    LogManager.w(TAG, "Failed to make new Android L scanner");
+                }
+            }
+        }
+        catch (SecurityException e) {
+            LogManager.w(TAG, "SecurityException making new Android L scanner");
+        }
+        return mScanner;
+    }
+
+    ScanCallback mLeScanCallback = new ScanCallback() {
+
+                @Override
+                public void onScanResult(int callbackType, ScanResult scanResult) {
+                    if (LogManager.isVerboseLoggingEnabled()) {
+                        LogManager.d(TAG, "got record");
+                        List<ParcelUuid> uuids = scanResult.getScanRecord().getServiceUuids();
+                        if (uuids != null) {
+                            for (ParcelUuid uuid : uuids) {
+                                LogManager.d(TAG, "with service uuid: "+uuid);
+                            }
+                        }
+                    }
+                    mPacketsDetected += 1;
+                    new ProcessScanResultTask().executeOnExecutor(mExecutor, scanResult);
+                }
+
+                @Override
+                public void onBatchScanResults(List<ScanResult> results) {
+                    LogManager.d(TAG, "got batch records");
+                    for (ScanResult scanResult : results) {
+                        mPacketsDetected += 1;
+                        new ProcessScanResultTask().executeOnExecutor(mExecutor, scanResult);
+                    }
+                }
+
+                @Override
+                public void onScanFailed(int i) {
+                    LogManager.e(TAG, "Scan Failed");
+                }
+            };
+
+
+    protected BluetoothAdapter getBluetoothAdapter() {
+        try {
+            if (mBluetoothAdapter == null) {
+                // Initializes Bluetooth adapter.
+                final BluetoothManager bluetoothManager =
+                        (BluetoothManager) ScanJob.this.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+                mBluetoothAdapter = bluetoothManager.getAdapter();
+                if (mBluetoothAdapter == null) {
+                    LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+                }
+            }
+        }
+        catch (SecurityException e) {
+            // Thrown by Samsung Knox devices if bluetooth access denied for an app
+            LogManager.e(TAG, "Cannot consruct bluetooth adapter.  Security Exception");
+        }
+        return mBluetoothAdapter;
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanState.java b/src/main/java/org/altbeacon/beacon/service/ScanState.java
new file mode 100644
index 00000000..3eaaf47c
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanState.java
@@ -0,0 +1,235 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+import android.util.Log;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InvalidClassException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static android.content.Context.MODE_PRIVATE;
+
+/**
+ * Created by dyoung on 3/26/17.
+ */
+
+public class ScanState implements Serializable {
+    private static final String TAG = ScanState.class.getSimpleName();
+    private static final String STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state";
+
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private transient MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+    private long mForegroundBetweenScanPeriod;
+    private long mBackgroundBetweenScanPeriod;
+    private long mForegroundScanPeriod;
+    private long mBackgroundScanPeriod;
+    private boolean mBackgroundMode;
+    private transient Context mContext;
+
+    public Boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+
+    public void setBackgroundMode(Boolean backgroundMode) {
+        mBackgroundMode = backgroundMode;
+    }
+
+    public Long getBackgroundBetweenScanPeriod() {
+        return mBackgroundBetweenScanPeriod;
+    }
+
+    public void setBackgroundBetweenScanPeriod(Long backgroundBetweenScanPeriod) {
+        mBackgroundBetweenScanPeriod = backgroundBetweenScanPeriod;
+    }
+
+    public Long getBackgroundScanPeriod() {
+        return mBackgroundScanPeriod;
+    }
+
+    public void setBackgroundScanPeriod(Long backgroundScanPeriod) {
+        mBackgroundScanPeriod = backgroundScanPeriod;
+    }
+
+    public Long getForegroundBetweenScanPeriod() {
+        return mForegroundBetweenScanPeriod;
+    }
+
+    public void setForegroundBetweenScanPeriod(Long foregroundBetweenScanPeriod) {
+        mForegroundBetweenScanPeriod = foregroundBetweenScanPeriod;
+    }
+
+    public Long getForegroundScanPeriod() {
+        return mForegroundScanPeriod;
+    }
+
+    public void setForegroundScanPeriod(Long foregroundScanPeriod) {
+        mForegroundScanPeriod = foregroundScanPeriod;
+    }
+
+    public ScanState(Context context) {
+        mContext = context;
+    }
+
+    public MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    public void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    public Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    public void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        mRangedRegionState = rangedRegionState;
+    }
+
+    public ExtraDataBeaconTracker getExtraBeaconDataTracker() {
+        return mExtraBeaconDataTracker;
+    }
+
+    public void setExtraBeaconDataTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraBeaconDataTracker = extraDataBeaconTracker;
+    }
+
+    public Set<BeaconParser> getBeaconParsers() {
+        return mBeaconParsers;
+    }
+
+    public void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    public static ScanState restore(Context context) {
+        ScanState scanState = null;
+        synchronized (ScanState.class) {
+            FileInputStream inputStream = null;
+            ObjectInputStream objectInputStream = null;
+            try {
+                inputStream = context.openFileInput(STATUS_PRESERVATION_FILE_NAME);
+                objectInputStream = new ObjectInputStream(inputStream);
+                scanState = (ScanState) objectInputStream.readObject();
+                scanState.mContext = context;
+                ;
+            } catch (IOException | ClassNotFoundException | ClassCastException e) {
+                if (e instanceof InvalidClassException) {
+                    LogManager.d(TAG, "Serialized ScanState has wrong class. Just ignoring saved state...");
+                }
+                else {
+                    LogManager.e(TAG, "Deserialization exception");
+                    Log.e(TAG, "error: ", e);
+                }
+
+            } finally {
+                if (null != inputStream) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectInputStream != null) {
+                    try {
+                        objectInputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            if (scanState == null) {
+                scanState = new ScanState(context);
+
+            }
+            // TODO: this should not be necessary.
+            if (scanState.mExtraBeaconDataTracker == null) {
+                scanState.mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+            }
+            scanState.mMonitoringStatus = MonitoringStatus.getInstanceForApplication(context);
+            LogManager.d(TAG, "Scan state restore regions: monitored="+scanState.getMonitoringStatus().regions().size()+" ranged="+scanState.getRangedRegionState().keySet().size());
+            return scanState;
+        }
+    }
+
+    public void save() {
+        synchronized (ScanState.class) {
+            // TODO: need to limit how big this object is somehow.
+            // Impose limits on ranged and monitored regions?
+            FileOutputStream outputStream = null;
+            ObjectOutputStream objectOutputStream = null;
+            try {
+                outputStream = mContext.openFileOutput(STATUS_PRESERVATION_FILE_NAME, MODE_PRIVATE);
+                objectOutputStream = new ObjectOutputStream(outputStream);
+                objectOutputStream.writeObject(this);
+
+            } catch (IOException e) {
+                LogManager.e(TAG, "Error while saving scan status to file: ", e.getMessage());
+                Log.e(TAG, "error: ", e);
+            } finally {
+                if (null != outputStream) {
+                    try {
+                        outputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectOutputStream != null) {
+                    try {
+                        objectOutputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            mMonitoringStatus.saveMonitoringStatusIfOn();
+        }
+    }
+
+    public void applyChanges(BeaconManager beaconManager) {
+        mBeaconParsers = new HashSet<>(beaconManager.getBeaconParsers());
+        mForegroundScanPeriod = beaconManager.getForegroundScanPeriod();
+        mForegroundBetweenScanPeriod = beaconManager.getForegroundBetweenScanPeriod();
+        mBackgroundScanPeriod = beaconManager.getBackgroundScanPeriod();
+        mBackgroundBetweenScanPeriod = beaconManager.getBackgroundBetweenScanPeriod();
+        mBackgroundMode = beaconManager.getBackgroundMode();
+
+        ArrayList<Region> existingMonitoredRegions = new ArrayList<>(mMonitoringStatus.regions());
+        ArrayList<Region> existingRangedRegions = new ArrayList<>(mRangedRegionState.keySet());
+        ArrayList<Region> newMonitoredRegions = new ArrayList<>(beaconManager.getMonitoredRegions());
+        ArrayList<Region> newRangedRegions = new ArrayList<>(beaconManager.getRangedRegions());
+        LogManager.d(TAG, "ranged regions: old="+existingRangedRegions.size()+" new="+newRangedRegions.size());
+        LogManager.d(TAG, "monitored regions: old="+existingMonitoredRegions.size()+" new="+newMonitoredRegions.size());
+
+        for (Region newRangedRegion: newRangedRegions) {
+            if (!existingRangedRegions.contains(newRangedRegion)) {
+                LogManager.d(TAG, "Starting ranging region: "+newRangedRegion);
+                mRangedRegionState.put(newRangedRegion, new RangeState(new Callback(mContext.getPackageName())));
+            }
+        }
+
+        for (Region existingRangedRegion: existingRangedRegions) {
+            if (!newRangedRegions.contains(existingRangedRegion)) {
+                LogManager.d(TAG, "Stopping ranging region: "+existingRangedRegion);
+                mRangedRegionState.remove(existingRangedRegion);
+            }
+        }
+        LogManager.d(TAG, "Updated state with "+newRangedRegions.size()+" ranging regions and "+newMonitoredRegions.size()+" monitoring regions.");
+
+        this.save();
+    }
+
+}
+
