diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index e49c232a..dab588bc 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -31,8 +31,10 @@
 import org.altbeacon.beacon.distance.DistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
+
 import java.util.List;
 
 /**
@@ -54,7 +56,7 @@
  * @author  David G. Young
  * @see     Region#matchesBeacon(Beacon Beacon)
  */
-public class Beacon implements Parcelable {
+public class Beacon implements Parcelable, Serializable {
     private static final String TAG = "Beacon";
 
     private static final List<Long> UNMODIFIABLE_LIST_OF_LONG =
@@ -168,6 +170,7 @@
      * Required for making object Parcelable.  If you override this class, you must provide an
      * equivalent version of this method.
      */
+    @Deprecated
     public static final Parcelable.Creator<Beacon> CREATOR
             = new Parcelable.Creator<Beacon>() {
         public Beacon createFromParcel(Parcel in) {
@@ -205,10 +208,15 @@ public static void setHardwareEqualityEnforced(boolean e) {
         sHardwareEqualityEnforced = e;
     }
 
+    public static boolean getHardwareEqualityEnforced() {
+        return sHardwareEqualityEnforced;
+    }
+
     /**
      * Required for making Beacon parcelable
      * @param in parcel
      */
+    @Deprecated
     protected Beacon(Parcel in) {
         int size = in.readInt();
 
@@ -276,6 +284,16 @@ public void setRunningAverageRssi(double rssi) {
         mDistance = null; // force calculation of accuracy and proximity next time they are requested
     }
 
+    /**
+     * Returns the running average rssi
+     * @param rssi
+     * @return
+     */
+    public double getRunningAverageRssi(double rssi) {
+        return mRunningAverageRssi = rssi;
+    }
+
+
     /**
      * Sets the most recently measured rssi for use in distance calculations if a running average is
      * not available
@@ -522,6 +540,7 @@ private StringBuilder toStringBuilder() {
     /**
      * Required for making object Parcelable
      */
+    @Deprecated
     public int describeContents() {
         return 0;
     }
@@ -530,6 +549,7 @@ public int describeContents() {
      * Required for making object Parcelable.  If you override this class, you must override this
      * method if you add any additional fields.
      */
+    @Deprecated
     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mIdentifiers.size());
         for (Identifier identifier: mIdentifiers) {
@@ -700,6 +720,16 @@ public Builder setRssi(int rssi) {
             return this;
         }
 
+        /**
+         * @see Beacon#mRssi
+         * @param rssi
+         * @return builder
+         */
+        public Builder setRunningAverageRssi(double rssi) {
+            mBeacon.mRunningAverageRssi = rssi;
+            return this;
+        }
+
         /**
          * @see Beacon#mTxPower
          * @param txPower
@@ -799,6 +829,7 @@ public Builder setMultiFrameBeacon(boolean multiFrameBeacon) {
             mBeacon.mMultiFrameBeacon = multiFrameBeacon;
             return this;
         }
+
     }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index 7b3c74ba..2520fc6f 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -52,8 +52,12 @@ protected void onHandleIntent(Intent intent) {
         RangingData rangingData = null;
 
         if (intent != null && intent.getExtras() != null) {
-            monitoringData = (MonitoringData) intent.getExtras().get("monitoringData");
-            rangingData = (RangingData) intent.getExtras().get("rangingData");
+            if (intent.getExtras().getBundle("monitoringData") != null) {
+                monitoringData = MonitoringData.fromBundle(intent.getExtras().getBundle("monitoringData"));
+            }
+            if (intent.getExtras().getBundle("rangingData") != null) {
+                rangingData = RangingData.fromBundle(intent.getExtras().getBundle("rangingData"));
+            }
         }
 
         if (rangingData != null) {
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index e4b8cad8..a8d9c049 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -43,9 +43,11 @@
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
+import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.simulator.BeaconSimulator;
+import org.altbeacon.beacon.utils.ProcessUtils;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -109,7 +111,7 @@
 public class BeaconManager {
     private static final String TAG = "BeaconManager";
     private Context mContext;
-    protected static BeaconManager client = null;
+    protected static BeaconManager sInstance = null;
     private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<BeaconConsumer,ConsumerInfo>();
     private Messenger serviceMessenger = null;
     protected final Set<RangeNotifier> rangeNotifiers = new CopyOnWriteArraySet<>();
@@ -120,6 +122,8 @@
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
+    private boolean mMainProcess = false;
+    private Boolean mScannerInSameProcess = null;
 
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
@@ -240,20 +244,58 @@ public static long getRegionExitPeriod(){
      * or non-Service class, you can attach it to another singleton or a subclass of the Android Application class.
      */
     public static BeaconManager getInstanceForApplication(Context context) {
-        if (client == null) {
+        if (sInstance == null) {
             LogManager.d(TAG, "BeaconManager instance creation");
-            client = new BeaconManager(context);
+            sInstance = new BeaconManager(context);
         }
-        return client;
+        return sInstance;
     }
 
-   protected BeaconManager(Context context) {
-      mContext = context.getApplicationContext();
-      if (!sManifestCheckingDisabled) {
-         verifyServiceDeclaration();
-      }
-      this.beaconParsers.add(new AltBeaconParser());
-   }
+    protected BeaconManager(Context context) {
+        mContext = context.getApplicationContext();
+        checkIfMainProcess();
+        if (!sManifestCheckingDisabled) {
+           verifyServiceDeclaration();
+         }
+        this.beaconParsers.add(new AltBeaconParser());
+    }
+
+    /***
+     * Determines if this BeaconManager instance is associated with the main application process that
+     * hosts the user interface.  This is normally true unless the scanning service or another servide
+     * is running in a separate process.
+     * @return
+     */
+    public boolean isMainProcess() {
+        return mMainProcess;
+    }
+
+    /**
+     * Determines if this BeaconManager instance is part of the process hosting the beacon scanning
+     * service.  This is normally true, except when scanning is hosted in a different service.
+     * This will return null until the scanning service starts up, at which time it will be known.
+     * @return
+     */
+    public Boolean isScannerInSameProcess() {
+        return mScannerInSameProcess;
+    }
+
+    /**
+     * Reserved for internal by the library.
+     * @hide
+     */
+    public void setScannerInSameProcess(boolean isScanner) {
+        mScannerInSameProcess = isScanner;
+    }
+
+    protected void checkIfMainProcess() {
+        ProcessUtils processUtils = new ProcessUtils(mContext);
+        String processName = processUtils.getProcessName();
+        String packageName = processUtils.getPackageName();
+        int pid = processUtils.getPid();
+        mMainProcess = processUtils.isMainProcess();
+        LogManager.i(TAG, "BeaconManager started up on pid "+pid+" named '"+processName+"' for application package '"+packageName+"'.  isMainProcess="+mMainProcess);
+    }
 
    /**
      * Gets a list of the active beaconParsers.
@@ -575,6 +617,14 @@ public void setRegionStatePersistenceEnabled(boolean enabled) {
         }
     }
 
+    /**
+     * Indicates whether region state preservation is enabled
+     * @return
+     */
+    public boolean isRegionStatePersistenceEnabled() {
+        return MonitoringStatus.getInstanceForApplication(mContext).isStatePreservationOn();
+    }
+
     /**
      * Requests the current in/out state on the specified region. If the region is being monitored,
      * this will cause an asynchronous callback on the `MonitorNotifier`'s `didDetermineStateForRegion`
@@ -617,8 +667,7 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             rangedRegions.add(region);
@@ -645,8 +694,7 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             Region regionToRemove = null;
@@ -659,6 +707,42 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
         }
     }
 
+    /**
+     * Call this method if you are running the scanner service in a different process in order to
+     * synchronize any configuration settings, including BeaconParsers to the scanner
+     * @see #isScannerInSameProcess()
+     */
+    public void applySettings() {
+        if (isScannerInSameProcess() != null && isScannerInSameProcess() == false) {
+            LogManager.d(TAG, "Synchronizing settings to service");
+            syncSettingsToService();
+        }
+        else {
+            if (isScannerInSameProcess() == null) {
+                LogManager.d(TAG, "Not synchronizing settings to service, as it has not started up yet");
+
+            }
+            else {
+                LogManager.d(TAG, "Not synchronizing settings to service, as it is in the same process");
+            }
+        }
+    }
+
+    protected void syncSettingsToService() {
+        if (serviceMessenger == null) {
+            LogManager.e(TAG, "The BeaconManager is not bound to the service.  Settings synchronization will fail.");
+            return;
+        }
+        try {
+            Message msg = Message.obtain(null, BeaconService.MSG_SYNC_SETTINGS, 0, 0);
+            msg.setData(new SettingsData().collect(mContext).toBundle());
+            serviceMessenger.send(msg);
+        }
+        catch (RemoteException e) {
+            LogManager.e(TAG, "Failed to sync settings to service", e);
+        }
+    }
+
     /**
      * Tells the <code>BeaconService</code> to start looking for beacons that match the passed
      * <code>Region</code> object.  Note that the Region's unique identifier must be retained to
@@ -681,8 +765,7 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
         }
         LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
         Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
         this.requestStateForRegion(region);
     }
@@ -708,8 +791,7 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
     }
 
@@ -732,8 +814,7 @@ public void updateScanPeriods() throws RemoteException {
         Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
         LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
         LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
-        StartRMData obj = new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
     }
 
@@ -860,6 +941,9 @@ public static Class getRssiFilterImplClass() {
      */
     public static void setUseTrackingCache(boolean useTrackingCache) {
         RangeState.setUseTrackingCache(useTrackingCache);
+        if (sInstance != null) {
+            sInstance.applySettings();
+        }
     }
 
     /**
@@ -940,7 +1024,12 @@ private BeaconServiceConnection() {
         // Called when the connection with the service is established
         public void onServiceConnected(ComponentName className, IBinder service) {
             LogManager.d(TAG, "we have a connection to the service now");
+            if (mScannerInSameProcess == null) {
+                mScannerInSameProcess = false;
+            }
             serviceMessenger = new Messenger(service);
+            // This will sync settings to the scanning service if it is in a different process
+            applySettings();
             synchronized(consumers) {
                 Iterator<Map.Entry<BeaconConsumer, ConsumerInfo>> iter = consumers.entrySet().iterator();
                 while (iter.hasNext()) {
@@ -986,6 +1075,19 @@ public static boolean isAndroidLScanningDisabled() {
      */
     public static void setAndroidLScanningDisabled(boolean disabled) {
         sAndroidLScanningDisabled = disabled;
+        if (sInstance != null) {
+            sInstance.applySettings();
+        }
+    }
+
+    /**
+     * Deprecated misspelled method
+     * @see #setManifestCheckingDisabled(boolean)
+     * @param disabled
+     */
+    @Deprecated
+    public static void setsManifestCheckingDisabled(boolean disabled) {
+        sManifestCheckingDisabled = disabled;
     }
 
     /**
@@ -994,7 +1096,15 @@ public static void setAndroidLScanningDisabled(boolean disabled) {
      *
      * @param disabled
      */
-    public static void setsManifestCheckingDisabled(boolean disabled) {
+    public static void setManifestCheckingDisabled(boolean disabled) {
         sManifestCheckingDisabled = disabled;
     }
+
+    /**
+     * Returns whether manifest checking is disabled
+     */
+    public static boolean getManifestCheckingDisabled() {
+        return sManifestCheckingDisabled;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index 611a5fa7..803b8dfb 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -9,6 +9,7 @@
 import org.altbeacon.bluetooth.BleAdvertisement;
 import org.altbeacon.bluetooth.Pdu;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -36,7 +37,7 @@
  * </p>
  *
  */
-public class BeaconParser {
+public class BeaconParser implements Serializable {
     private static final String TAG = "BeaconParser";
     public static final String ALTBEACON_LAYOUT = "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25";
     public static final String EDDYSTONE_TLM_LAYOUT = "x,s:0-1=feaa,m:2-2=20,d:3-3,d:4-5,d:6-7,d:8-11,d:12-15";
@@ -53,6 +54,7 @@
     private static final String LITTLE_ENDIAN_SUFFIX = "l";
     private static final String VARIABLE_LENGTH_SUFFIX = "v";
 
+    protected String mBeaconLayout;
     private Long mMatchingBeaconTypeCode;
     protected final List<Integer> mIdentifierStartOffsets = new ArrayList<Integer>();
     protected final List<Integer> mIdentifierEndOffsets = new ArrayList<Integer>();
@@ -165,7 +167,7 @@ public BeaconParser(String identifier) {
      * @return the BeaconParser instance
      */
     public BeaconParser setBeaconLayout(String beaconLayout) {
-
+        mBeaconLayout = beaconLayout;
         Log.d(TAG, "Parsing beacon layout: "+beaconLayout);
 
         String[] terms =  beaconLayout.split(",");
@@ -758,6 +760,13 @@ public int getDataFieldCount() {
         return mDataStartOffsets.size();
     }
 
+    /**
+     * @return the layout string for the parser
+     */
+    public String getLayout() {
+        return mBeaconLayout;
+    }
+
     /**
      * @return the correction value in dBm to apply to the calibrated txPower to get a 1m calibrated value.
      * Some formats like Eddystone use a 0m calibrated value, which requires this correction
@@ -925,4 +934,20 @@ public int hashCode() {
             }
         );
     }
+
+    @Override
+    public boolean equals(Object o) {
+        BeaconParser that = null;
+        try {
+            that = (BeaconParser) o;
+            if (that.mBeaconLayout != null && that.mBeaconLayout.equals(this.mBeaconLayout)) {
+                if (that.mIdentifier != null && that.mIdentifier.equals(this.mIdentifier)) {
+                    return true;
+                }
+            }
+        }
+        catch (ClassCastException e ) { }
+        return false;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/Region.java b/src/main/java/org/altbeacon/beacon/Region.java
index db5886da..24b0ad62 100644
--- a/src/main/java/org/altbeacon/beacon/Region.java
+++ b/src/main/java/org/altbeacon/beacon/Region.java
@@ -51,7 +51,6 @@
 public class Region implements Parcelable, Serializable {
     private static final String TAG = "Region";
     private static final Pattern MAC_PATTERN = Pattern.compile("^[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}$");
-
     /**
      * Required to make class Parcelable
      */
@@ -309,4 +308,5 @@ private void validateMac(String mac) throws IllegalArgumentException {
     public Region clone() {
         return new Region(mUniqueId, mIdentifiers, mBluetoothAddress);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java b/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
new file mode 100644
index 00000000..2b9baec5
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import android.util.Log;
+
+/**
+ * Android logger that only logs out warning and above to the {@link android.util.Log}.
+ *
+ * @since 2.2
+ * @author Andrew Reitz
+ */
+final class InfoAndroidLogger extends AbstractAndroidLogger {
+    @Override
+    public void v(String tag, String message, Object... args) { }
+
+    @Override
+    public void v(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void d(String tag, String message, Object... args) { }
+
+    @Override
+    public void d(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void i(String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args));
+    }
+
+    @Override
+    public void i(Throwable t, String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void w(String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args));
+    }
+
+    @Override
+    public void w(Throwable t, String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void e(String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args));
+    }
+
+    @Override
+    public void e(Throwable t, String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args), t);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/LogManager.java b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
index 4500699e..8420d7a6 100644
--- a/src/main/java/org/altbeacon/beacon/logging/LogManager.java
+++ b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
@@ -24,7 +24,7 @@
  * @since 2.2
  */
 public final class LogManager {
-    private static Logger sLogger = Loggers.warningLogger();
+    private static Logger sLogger = Loggers.infoLogger();
     private static boolean sVerboseLoggingEnabled = false;
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/logging/Loggers.java b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
index 44144026..c243f62c 100644
--- a/src/main/java/org/altbeacon/beacon/logging/Loggers.java
+++ b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
@@ -30,6 +30,9 @@
     /** Debug Logger Singleton. */
     private static final Logger VERBOSE_ANDROID_LOGGER = new VerboseAndroidLogger();
 
+    /** Info Logger Singleton. */
+    private static final Logger INFO_ANDROID_LOGGER = new InfoAndroidLogger();
+
     /** Warning Logger Singleton. */
     private static final Logger WARNING_ANDROID_LOGGER = new WarningAndroidLogger();
 
@@ -48,6 +51,14 @@ public static Logger verboseLogger() {
         return VERBOSE_ANDROID_LOGGER;
     }
 
+    /**
+     * @return Get a logger that logs messages of info and greater.
+     * @see android.util.Log
+     */
+    public static Logger infoLogger() {
+        return INFO_ANDROID_LOGGER;
+    }
+
     /**
      * @return Get a logger that logs messages of warning and greater.
      * @see android.util.Log
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 5738a50f..2edb68a6 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -52,6 +52,7 @@
 import org.altbeacon.beacon.service.scanner.CycledLeScanner;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
+import org.altbeacon.beacon.utils.ProcessUtils;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.lang.ref.WeakReference;
@@ -136,6 +137,7 @@ public BeaconService getService() {
     public static final int MSG_START_MONITORING = 4;
     public static final int MSG_STOP_MONITORING = 5;
     public static final int MSG_SET_SCAN_PERIODS = 6;
+    public static final int MSG_SYNC_SETTINGS = 7;
 
     static class IncomingHandler extends Handler {
         private final WeakReference<BeaconService> mService;
@@ -147,37 +149,52 @@ public BeaconService getService() {
         @Override
         public void handleMessage(Message msg) {
             BeaconService service = mService.get();
-            StartRMData startRMData = (StartRMData) msg.obj;
-
             if (service != null) {
-                switch (msg.what) {
-                    case MSG_START_RANGING:
-                        LogManager.i(TAG, "start ranging received");
-                        service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_STOP_RANGING:
-                        LogManager.i(TAG, "stop ranging received");
-                        service.stopRangingBeaconsInRegion(startRMData.getRegionData());
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_START_MONITORING:
-                        LogManager.i(TAG, "start monitoring received");
-                        service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_STOP_MONITORING:
-                        LogManager.i(TAG, "stop monitoring received");
-                        service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_SET_SCAN_PERIODS:
-                        LogManager.i(TAG, "set scan intervals received");
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    default:
-                        super.handleMessage(msg);
+                StartRMData startRMData = StartRMData.fromBundle(msg.getData());
+                if (startRMData != null) {
+                    switch (msg.what) {
+                        case MSG_START_RANGING:
+                            LogManager.i(TAG, "start ranging received");
+                            service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_STOP_RANGING:
+                            LogManager.i(TAG, "stop ranging received");
+                            service.stopRangingBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_START_MONITORING:
+                            LogManager.i(TAG, "start monitoring received");
+                            service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_STOP_MONITORING:
+                            LogManager.i(TAG, "stop monitoring received");
+                            service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_SET_SCAN_PERIODS:
+                            LogManager.i(TAG, "set scan intervals received");
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        default:
+                            super.handleMessage(msg);
+                    }
+                }
+                else if (msg.what == MSG_SYNC_SETTINGS) {
+                    LogManager.i(TAG, "Received settings update from other process");
+                    SettingsData settingsData = SettingsData.fromBundle(msg.getData());
+                    if (settingsData != null) {
+                        settingsData.apply(service);
+                    }
+                    else {
+                        LogManager.w(TAG, "Settings data missing");
+                    }
+                }
+                else {
+                    LogManager.i(TAG, "Received unknown message from other process : "+msg.what);
                 }
+
             }
         }
     }
@@ -190,7 +207,6 @@ public void handleMessage(Message msg) {
 
     @Override
     public void onCreate() {
-        LogManager.i(TAG, "beaconService version %s is starting up", BuildConfig.VERSION_NAME);
         bluetoothCrashResolver = new BluetoothCrashResolver(this);
         bluetoothCrashResolver.start();
 
@@ -202,21 +218,17 @@ public void onCreate() {
                 BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag, mCycledLeScanCallback, bluetoothCrashResolver);
 
         beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
-
-        //flatMap all beacon parsers
-        boolean matchBeaconsByServiceUUID = true;
-        if (beaconManager.getBeaconParsers() != null) {
-            beaconParsers.addAll(beaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    beaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
-            }
+        beaconManager.setScannerInSameProcess(true);
+        if (beaconManager.isMainProcess()) {
+            LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+        }
+        else {
+            LogManager.i(TAG, "beaconService version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(this);
+            LogManager.i(TAG, "beaconService PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
         }
 
-        //initialize the extra data beacon tracker
-        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+        reloadParsers();
 
         defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
@@ -234,6 +246,24 @@ public void onCreate() {
         }
     }
 
+    protected void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
+        //flatMap all beacon parsers
+        boolean matchBeaconsByServiceUUID = true;
+        if (beaconManager.getBeaconParsers() != null) {
+            newBeaconParsers.addAll(beaconManager.getBeaconParsers());
+            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
+                if (beaconParser.getExtraDataParsers().size() > 0) {
+                    matchBeaconsByServiceUUID = false;
+                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
+                }
+            }
+        }
+        beaconParsers = newBeaconParsers;
+        //initialize the extra data beacon tracker
+        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+    }
+
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
@@ -399,7 +429,7 @@ private void processRangeData() {
             for (Region region : rangedRegionState.keySet()) {
                 RangeState rangeState = rangedRegionState.get(region);
                 LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region));
+                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
             }
         }
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index aa0ddb6a..193c1386 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -26,7 +26,7 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Parcelable;
+import android.os.Bundle;
 
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -35,23 +35,23 @@
 
 public class Callback implements Serializable {
     private static final String TAG = "Callback";
-    private transient Intent intent;
-    private String intentPackageName;
+    private transient Intent mIntent;
+    private String mIntentPackageName;
 
     public Callback(String intentPackageName) {
-        this.intentPackageName = intentPackageName;
+        mIntentPackageName = intentPackageName;
         initializeIntent();
     }
 
     private void initializeIntent() {
-        if (intentPackageName != null) {
-            intent = new Intent();
-            intent.setComponent(new ComponentName(intentPackageName, "org.altbeacon.beacon.BeaconIntentProcessor"));
+        if (mIntentPackageName != null) {
+            mIntent = new Intent();
+            mIntent.setComponent(new ComponentName(mIntentPackageName, "org.altbeacon.beacon.BeaconIntentProcessor"));
         }
     }
 
     public Intent getIntent() {
-        return intent;
+        return mIntent;
     }
 
     /**
@@ -62,14 +62,14 @@ public Intent getIntent() {
      * @param data
      * @return false if it callback cannot be made
      */
-    public boolean call(Context context, String dataName, Parcelable data) {
-        if(intent == null){
+    public boolean call(Context context, String dataName, Bundle data) {
+        if(mIntent == null){
             initializeIntent();
         }
-        if (intent != null) {
-            LogManager.d(TAG, "attempting callback via intent: %s", intent.getComponent());
-            intent.putExtra(dataName, data);
-            context.startService(intent);
+        if (mIntent != null) {
+            LogManager.d(TAG, "attempting callback via intent: %s", mIntent.getComponent());
+            mIntent.putExtra(dataName, data);
+            context.startService(mIntent);
             return true;
         }
         return false;
diff --git a/src/main/java/org/altbeacon/beacon/service/DataSerializer.java b/src/main/java/org/altbeacon/beacon/service/DataSerializer.java
new file mode 100644
index 00000000..b00bce35
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/DataSerializer.java
@@ -0,0 +1,46 @@
+package org.altbeacon.beacon.service;
+
+import org.altbeacon.beacon.Beacon;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * Created by dyoung on 3/10/17.
+ */
+
+public class DataSerializer {
+    /*
+    public Serializable getSerializableRegion(Region region) {
+        return new SerializableRegion(region);
+    }
+
+    public Serializable getSerializableBeacon(Beacon beacon) {
+        return new SerializableBeacon(beacon);
+    }
+    */
+
+    public Serializable getSerializableBeaconList(Collection<Beacon> beacons) {
+        ArrayList<Serializable> serializableBeacons = new ArrayList<Serializable>();
+        for (Beacon beacon : beacons) {
+            serializableBeacons.add(beacon);
+        }
+        return serializableBeacons;
+    }
+
+    /*
+    private class SerializableBeacon extends Beacon implements Serializable {
+        public SerializableBeacon(Beacon beacon)  {
+            super(beacon);
+        }
+    }
+
+    private class SerializableRegion extends Region implements Serializable {
+        public SerializableRegion(Region region)  {
+            super(region);
+        }
+    }
+    */
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
index e9523536..74356914 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
@@ -25,49 +25,42 @@
 
 import org.altbeacon.beacon.Region;
 
-import android.os.Parcel;
-import android.os.Parcelable;
+import android.os.Bundle;
 
-public class MonitoringData implements Parcelable {
+public class MonitoringData {
     @SuppressWarnings("unused")
     private static final String TAG = "MonitoringData";
-    private final boolean inside;
-    private final Region region;
+    private final boolean mInside;
+    private final Region mRegion;
+    private static final String REGION_KEY = "region";
+    private static final String INSIDE_KEY = "inside";
 
     public MonitoringData (boolean inside, Region region) {
-        this.inside = inside;
-        this.region = region;
+        this.mInside = inside;
+        this.mRegion = region;
     }
     public boolean isInside() {
-        return inside;
+        return mInside;
     }
     public Region getRegion() {
-        return region;
+        return mRegion;
     }
 
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeByte((byte) (inside ? 1 : 0));
-        out.writeParcelable(region, flags);
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(REGION_KEY, mRegion);
+        bundle.putBoolean(INSIDE_KEY, mInside);
 
+        return bundle;
     }
-
-    public static final Parcelable.Creator<MonitoringData> CREATOR
-            = new Parcelable.Creator<MonitoringData>() {
-        public MonitoringData createFromParcel(Parcel in) {
-            return new MonitoringData(in);
-        }
-
-        public MonitoringData[] newArray(int size) {
-            return new MonitoringData[size];
+    public static MonitoringData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
         }
-    };
-
-    private MonitoringData(Parcel in) {
-        inside = in.readByte() == 1;
-        region = in.readParcelable(this.getClass().getClassLoader());
+        Boolean inside = bundle.getBoolean(INSIDE_KEY);
+        return new MonitoringData(inside, region);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index fdf5644d..a311fba3 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -100,7 +100,7 @@ public synchronized void updateNewlyOutside() {
             if (state.markOutsideIfExpired()) {
                 needsMonitoringStateSaving = true;
                 LogManager.d(TAG, "found a monitor that expired: %s", region);
-                state.getCallback().call(mContext, "monitoringData", new MonitoringData(state.getInside(), region));
+                state.getCallback().call(mContext, "monitoringData", new MonitoringData(state.getInside(), region).toBundle());
             }
         }
         if (needsMonitoringStateSaving) {
@@ -119,7 +119,7 @@ public synchronized void updateNewlyInsideInRegionsContaining(Beacon beacon) {
             if (state != null && state.markInside()) {
                 needsMonitoringStateSaving = true;
                 state.getCallback().call(mContext, "monitoringData",
-                        new MonitoringData(state.getInside(), region));
+                        new MonitoringData(state.getInside(), region).toBundle());
             }
         }
         if (needsMonitoringStateSaving) {
@@ -271,6 +271,10 @@ public synchronized void startStatusPreservation() {
         }
     }
 
+    public boolean isStatePreservationOn() {
+        return mStatePreservationIsOn;
+    }
+
     public synchronized void clear() {
         mContext.deleteFile(STATUS_PRESERVATION_FILE_NAME);
         getRegionsStateMap().clear();
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index a8c1e8d4..0c1ad59e 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -35,7 +35,7 @@
     private static final String TAG = "RangeState";
     private final Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
-    private static boolean UseTrackingCache = false;
+    private static boolean sUseTrackingCache = false;
 
     public RangeState(Callback c) {
         mCallback = c;
@@ -77,7 +77,7 @@ public void addBeacon(Beacon beacon) {
                 if (!rangedBeacon.noMeasurementsAvailable() == true) {
                     //if TrackingCache is enabled, allow beacon to not receive
                     //measurements for a certain amount of time
-                    if (!UseTrackingCache || rangedBeacon.isExpired())
+                    if (!sUseTrackingCache || rangedBeacon.isExpired())
                         rangedBeacon.setTracked(false);
                     newRangedBeacons.put(beacon, rangedBeacon);
                 }
@@ -92,8 +92,11 @@ public void addBeacon(Beacon beacon) {
     }
 
     public static void setUseTrackingCache(boolean useTrackingCache) {
-        RangeState.UseTrackingCache = useTrackingCache;
+        RangeState.sUseTrackingCache = useTrackingCache;
     }
 
+    public static boolean getUseTrackingCache() {
+        return sUseTrackingCache;
+    }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangingData.java b/src/main/java/org/altbeacon/beacon/service/RangingData.java
index 2d400787..79e47240 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -23,62 +23,53 @@
  */
 package org.altbeacon.beacon.service;
 
-import java.util.ArrayList;
 import java.util.Collection;
 
 import org.altbeacon.beacon.Beacon;
-import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Region;
-import org.altbeacon.beacon.logging.LogManager;
 
-import android.os.Parcel;
-import android.os.Parcelable;
+import android.os.Bundle;
 
-public class RangingData implements Parcelable {
+public class RangingData {
     private static final String TAG = "RangingData";
-    private final Collection<Beacon> beacons;
-    private final Region region;
+    private final Collection<Beacon> mBeacons;
+    private final Region mRegion;
+    private static final String REGION_KEY = "region";
+    private static final String BEACONS_KEY = "beacons";
 
     public RangingData (Collection<Beacon> beacons, Region region) {
         synchronized (beacons) {
-            this.beacons =  beacons;
+            this.mBeacons =  beacons;
         }
-        this.region = region;
+        this.mRegion = region;
     }
 
     public Collection<Beacon> getBeacons() {
-        return beacons;
+        return mBeacons;
     }
     public Region getRegion() {
-        return region;
+        return mRegion;
     }
 
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeParcelableArray(beacons.toArray(new Parcelable[0]), flags);
-        out.writeParcelable(region, flags);
-    }
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(REGION_KEY, mRegion);
+        bundle.putSerializable(BEACONS_KEY, new DataSerializer().getSerializableBeaconList(mBeacons));
 
-    public static final Parcelable.Creator<RangingData> CREATOR
-            = new Parcelable.Creator<RangingData>() {
-        public RangingData createFromParcel(Parcel in) {
-            return new RangingData(in);
+        return bundle;
+    }
+    public static RangingData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        Collection<Beacon> beacons = null;
+        if (bundle.get(BEACONS_KEY) != null) {
+            beacons = (Collection<Beacon>) bundle.getSerializable(BEACONS_KEY);
         }
-
-        public RangingData[] newArray(int size) {
-            return new RangingData[size];
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
         }
-    };
 
-    protected RangingData(Parcel in) {
-        Parcelable[] parcelables  = in.readParcelableArray(this.getClass().getClassLoader());
-        beacons = new ArrayList<Beacon>(parcelables.length);
-        for (int i = 0; i < parcelables.length; i++) {
-            beacons.add((Beacon)parcelables[i]);
-        }
-        region = in.readParcelable(this.getClass().getClassLoader());
+        return new RangingData(beacons, region);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/SettingsData.java b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
new file mode 100644
index 00000000..a5cd5e48
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
@@ -0,0 +1,100 @@
+package org.altbeacon.beacon.service;
+
+import android.app.Service;
+import android.content.Context;
+import android.os.Bundle;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by dyoung on 3/10/17.
+ */
+
+public class SettingsData implements Serializable {
+    private static final String TAG = SettingsData.class.getSimpleName();
+    private static final String SETTINGS_DATA_KEY = "SettingsData";
+    ArrayList<BeaconParser> mBeaconParsers;
+    Boolean mRegionStatePersistenceEnabled;
+    Boolean mAndroidLScanningDisabled;
+    Long mRegionExitPeriod;
+    Boolean mUseTrackingCache;
+    Boolean mHardwareEqualityEnforced;
+
+    // The following configuration settings are not implemented here, so they cannot be set when
+    // the scanning service is running in anothr process
+    //   beaconSimulator *
+    //   rssiFilterImplClass *
+    //   distanceCalculator *
+    //   logger *
+    //   verboseLoggingEnabled *
+    //   mNonBeaconLeScanCallback *
+    //   manifestCheckingDisabled (no point in synchronizing this one... only used at startup)
+
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(SETTINGS_DATA_KEY, this);
+        return bundle;
+    }
+    public static SettingsData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        SettingsData settingsData = null;
+        if (bundle.get(SETTINGS_DATA_KEY) != null) {
+            settingsData = (SettingsData) bundle.getSerializable(SETTINGS_DATA_KEY);
+        }
+        return settingsData;
+    }
+
+    public void apply(BeaconService scanService) {
+        LogManager.d(TAG, "Applying settings changes to scanner in other process");
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(scanService);
+        List<BeaconParser> beaconParsers = beaconManager.getBeaconParsers();
+        boolean beaconParsersChanged = false;
+        if (beaconParsers.size() == mBeaconParsers.size()) {
+            for (int i = 0; i < beaconParsers.size(); i++) {
+                if (!beaconParsers.get(i).equals(mBeaconParsers.get(i))) {
+                    LogManager.d(TAG, "Beacon parsers have changed to: "+mBeaconParsers.get(i).getLayout());
+                    beaconParsersChanged = true;
+                    break;
+                }
+            }
+        }
+        else {
+            beaconParsersChanged = true;
+            LogManager.d(TAG, "Beacon parsers have been added or removed.");
+        }
+        if (beaconParsersChanged) {
+            LogManager.d(TAG, "Updating beacon parsers");
+            beaconManager.getBeaconParsers().clear();
+            beaconManager.getBeaconParsers().addAll(mBeaconParsers);
+            scanService.reloadParsers();
+        }
+        else {
+            LogManager.d(TAG, "Beacon parsers unchanged.");
+        }
+        beaconManager.setRegionStatePersistenceEnabled(mRegionStatePersistenceEnabled);
+        beaconManager.setAndroidLScanningDisabled(mAndroidLScanningDisabled);
+        BeaconManager.setRegionExitPeriod(mRegionExitPeriod);
+        RangeState.setUseTrackingCache(mUseTrackingCache);
+        Beacon.setHardwareEqualityEnforced(mHardwareEqualityEnforced);
+    }
+
+    public SettingsData collect(Context context) {
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context);
+        mBeaconParsers = new ArrayList<>(beaconManager.getBeaconParsers());
+        mRegionStatePersistenceEnabled = beaconManager.isRegionStatePersistenceEnabled();
+        mAndroidLScanningDisabled = beaconManager.isAndroidLScanningDisabled();
+        mRegionExitPeriod = BeaconManager.getRegionExitPeriod();
+        mUseTrackingCache = RangeState.getUseTrackingCache();
+        mHardwareEqualityEnforced = Beacon.getHardwareEqualityEnforced();
+        return this;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/StartRMData.java b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
index c91e4070..ab7a58f5 100644
--- a/src/main/java/org/altbeacon/beacon/service/StartRMData.java
+++ b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
@@ -23,6 +23,7 @@
  */
 package org.altbeacon.beacon.service;
 
+import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
 
@@ -31,50 +32,59 @@
 import java.io.Serializable;
 
 public class StartRMData implements Serializable, Parcelable {
-    private Region region;
-    private long scanPeriod;
-    private long betweenScanPeriod;
-    private boolean backgroundFlag;
-    private String callbackPackageName;
+    private static final String SCAN_PERIOD_KEY = "scanPeriod";
+    private static final String BETWEEN_SCAN_PERIOD_KEY = "betweenScanPeriod";
+    private static final String BACKGROUND_FLAG_KEY = "backgroundFlag";
+    private static final String CALLBACK_PACKAGE_NAME_KEY = "callbackPackageName";
+    private static final String REGION_KEY = "region";
+
+    private Region mRegion;
+    private long mScanPeriod;
+    private long mBetweenScanPeriod;
+    private boolean mBackgroundFlag;
+    private String mCallbackPackageName;
+
+    private StartRMData() {
+    }
 
     public StartRMData(Region region, String callbackPackageName) {
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
     }
     public StartRMData(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.backgroundFlag = backgroundFlag;
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mBackgroundFlag = backgroundFlag;
     }
 
     public StartRMData(Region region, String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
-        this.backgroundFlag = backgroundFlag;
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
+        this.mBackgroundFlag = backgroundFlag;
     }
 
 
-    public long getScanPeriod() { return scanPeriod; }
-    public long getBetweenScanPeriod() { return betweenScanPeriod; }
+    public long getScanPeriod() { return mScanPeriod; }
+    public long getBetweenScanPeriod() { return mBetweenScanPeriod; }
     public Region getRegionData() {
-        return region;
+        return mRegion;
     }
     public String getCallbackPackageName() {
-        return callbackPackageName;
+        return mCallbackPackageName;
     }
-    public boolean getBackgroundFlag() { return backgroundFlag; }
+    public boolean getBackgroundFlag() { return mBackgroundFlag; }
     public int describeContents() {
         return 0;
     }
 
     public void writeToParcel(Parcel out, int flags) {
-        out.writeParcelable(region, flags);
-        out.writeString(callbackPackageName);
-        out.writeLong(scanPeriod);
-        out.writeLong(betweenScanPeriod);
-        out.writeByte((byte) (backgroundFlag ? 1 : 0));
+        out.writeParcelable(mRegion, flags);
+        out.writeString(mCallbackPackageName);
+        out.writeLong(mScanPeriod);
+        out.writeLong(mBetweenScanPeriod);
+        out.writeByte((byte) (mBackgroundFlag ? 1 : 0));
     }
 
     public static final Parcelable.Creator<StartRMData> CREATOR
@@ -89,11 +99,52 @@ public StartRMData createFromParcel(Parcel in) {
     };
 
     private StartRMData(Parcel in) {
-        region = in.readParcelable(StartRMData.class.getClassLoader());
-        callbackPackageName = in.readString();
-        scanPeriod = in.readLong();
-        betweenScanPeriod = in.readLong();
-        backgroundFlag = in.readByte() != 0;
+        mRegion = in.readParcelable(StartRMData.class.getClassLoader());
+        mCallbackPackageName = in.readString();
+        mScanPeriod = in.readLong();
+        mBetweenScanPeriod = in.readLong();
+        mBackgroundFlag = in.readByte() != 0;
+    }
+
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putLong(SCAN_PERIOD_KEY, this.mScanPeriod);
+        bundle.putLong(BETWEEN_SCAN_PERIOD_KEY, this.mBetweenScanPeriod);
+        bundle.putBoolean(BACKGROUND_FLAG_KEY, this.mBackgroundFlag);
+        bundle.putString(CALLBACK_PACKAGE_NAME_KEY, this.mCallbackPackageName);
+        if (mRegion != null) {
+            bundle.putSerializable(REGION_KEY, mRegion);
+        }
+        return bundle;
+    }
+
+    public static StartRMData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        boolean valid = false;
+        StartRMData data = new StartRMData();
+        if (bundle.containsKey(REGION_KEY)) {
+            data.mRegion = (Region)bundle.getSerializable(REGION_KEY);
+            valid = true;
+        }
+        if (bundle.containsKey(SCAN_PERIOD_KEY)) {
+            data.mScanPeriod = (Long) bundle.get(SCAN_PERIOD_KEY);
+            valid = true;
+        }
+        if (bundle.containsKey(BETWEEN_SCAN_PERIOD_KEY)) {
+            data.mBetweenScanPeriod = (Long) bundle.get(BETWEEN_SCAN_PERIOD_KEY);
+        }
+        if (bundle.containsKey(BACKGROUND_FLAG_KEY)) {
+            data.mBackgroundFlag = (Boolean) bundle.get(BACKGROUND_FLAG_KEY);
+        }
+        if (bundle.containsKey(CALLBACK_PACKAGE_NAME_KEY)) {
+            data.mCallbackPackageName = (String) bundle.get(CALLBACK_PACKAGE_NAME_KEY);
+        }
+        if (valid) {
+            return data;
+        }
+        else {
+            return null;
+        }
     }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
new file mode 100644
index 00000000..229b3d7d
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
@@ -0,0 +1,38 @@
+package org.altbeacon.beacon.utils;
+
+import android.app.ActivityManager;
+import android.content.Context;
+
+/**
+ * Created by dyoung on 3/10/17.
+ */
+
+public class ProcessUtils {
+    Context mContext;
+
+    public ProcessUtils(Context context) {
+        mContext = context;
+    }
+
+    public String getProcessName() {
+        ActivityManager manager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        for (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) {
+            if (processInfo.pid == getPid()) {
+                return  processInfo.processName;
+            }
+        }
+        return null;
+    }
+
+    public String getPackageName() {
+        return mContext.getApplicationContext().getPackageName();
+    }
+
+    public int getPid() {
+        return android.os.Process.myPid();
+    }
+
+    public boolean isMainProcess() {
+        return (getPackageName().equals(getProcessName()));
+    }
+}
diff --git a/src/test/java/org/altbeacon/beacon/BeaconTest.java b/src/test/java/org/altbeacon/beacon/BeaconTest.java
index e31e6f54..d95fb0e7 100644
--- a/src/test/java/org/altbeacon/beacon/BeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/BeaconTest.java
@@ -1,7 +1,5 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.junit.Before;
 import org.junit.Test;
@@ -16,6 +14,12 @@
 import java.util.Arrays;
 import java.util.List;
 
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -160,15 +164,13 @@ public void testCalculateAccuracyWithRssiEqualsPowerOnInternalPropertiesAndRunni
 
 
     @Test
-    public void testCanSerializeParcelable() {
+    public void testCanSerialize() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
                 .setBeaconTypeCode(5).setTxPower(6).setBluetoothName("xx")
                 .setBluetoothAddress("1:2:3:4:5:6").setDataFields(Arrays.asList(100l)).build();
-        beacon.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Beacon beacon2 = new Beacon(parcel);
+        byte[] serializedBeacon = convertToBytes(beacon);
+        Beacon beacon2 = (Beacon) convertFromBytes(serializedBeacon);
         assertEquals("Right number of identifiers after deserialization", 3, beacon2.mIdentifiers.size());
         assertEquals("id1 is same after deserialization", beacon.getIdentifier(0), beacon2.getIdentifier(0));
         assertEquals("id2 is same after deserialization", beacon.getIdentifier(1), beacon2.getIdentifier(1));
@@ -204,4 +206,20 @@ public void testHashCodeWithNullIdentifier() {
                 .build();
         assertTrue("hashCode() should not throw exception", beacon.hashCode() >= Integer.MIN_VALUE);
     }
+    // utilty methods for testing serialization
+
+    private byte[] convertToBytes(Object object) throws IOException {
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(object);
+            return bos.toByteArray();
+        }
+    }
+    private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+             ObjectInputStream in = new ObjectInputStream(bis)) {
+            return in.readObject();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/org/altbeacon/beacon/RegionTest.java b/src/test/java/org/altbeacon/beacon/RegionTest.java
index 4d003273..05ba5952 100644
--- a/src/test/java/org/altbeacon/beacon/RegionTest.java
+++ b/src/test/java/org/altbeacon/beacon/RegionTest.java
@@ -1,7 +1,5 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
 import static android.test.MoreAsserts.assertNotEqual;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -17,6 +15,12 @@
 import java.util.ArrayList;
 import java.util.Collections;
 
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -128,13 +132,11 @@ public void testBeaconMatchesRegionWithSameBluetoothMacAndIdentifiers() {
 
 
     @Test
-    public void testCanSerializeParcelable() {
+    public void testCanSerialize() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Region region = new Region("myRegion", Identifier.parse("1"), Identifier.parse("2"), null);
-        region.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Region region2 = new Region(parcel);
+        byte[] serializedRegion = convertToBytes(region);
+        Region region2 = (Region) convertFromBytes(serializedRegion);
         assertEquals("Right number of identifiers after deserialization", 3, region2.mIdentifiers.size());
         assertEquals("uniqueId is same after deserialization", region.getUniqueId(), region2.getUniqueId());
         assertEquals("id1 is same after deserialization", region.getIdentifier(0), region2.getIdentifier(0));
@@ -144,13 +146,11 @@ public void testCanSerializeParcelable() {
     }
 
     @Test
-    public void testCanSerializeParcelableWithMac() {
+    public void testCanSerializeWithMac() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Region region = new Region("myRegion", "1B:2a:03:4C:6E:9F");
-        region.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Region region2 = new Region(parcel);
+        byte[] serializedRegion = convertToBytes(region);
+        Region region2 = (Region) convertFromBytes(serializedRegion);
         assertEquals("Right number of identifiers after deserialization", 0, region2.mIdentifiers.size());
         assertEquals("ac is same after deserialization", region.getBluetoothAddress(), region2.getBluetoothAddress());
     }
@@ -158,7 +158,6 @@ public void testCanSerializeParcelableWithMac() {
     @Test
     public void rejectsInvalidMac() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         try {
             Region region = new Region("myRegion", "this string is not a valid mac address!");
             assertTrue("IllegalArgumentException should have been thrown", false);
@@ -185,5 +184,21 @@ public void testConvenienceIdentifierAccessors() {
         assertEquals("3", region.getId3().toString());
     }
 
+    // utilty methods for testing serialization
+
+    private byte[] convertToBytes(Object object) throws IOException {
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(object);
+            return bos.toByteArray();
+        }
+    }
+    private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+             ObjectInputStream in = new ObjectInputStream(bis)) {
+            return in.readObject();
+        }
+    }
+
 
 }
diff --git a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
index 3042a904..b101143a 100644
--- a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
@@ -25,7 +25,6 @@
 import java.util.Collection;
 import java.util.concurrent.ThreadPoolExecutor;
 
-import android.os.Parcel;
 import android.os.Bundle;
 import org.altbeacon.beacon.service.RangingData;
 
@@ -51,15 +50,13 @@ public void testSerialization() throws Exception {
         identifiers.add(Identifier.parse("2"));
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
-        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
         for (int i=0; i < 10; i++) {
             beacons.add(beacon);
         }
         RangingData data = new RangingData(beacons, region);
-        Parcel parcel = Parcel.obtain();
-        data.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        RangingData data2 = new RangingData(parcel);
+        Bundle bundle = data.toBundle();
+        RangingData data2 = RangingData.fromBundle(bundle);
         assertEquals("beacon count shouild be restored", 10, data2.getBeacons().size());
         assertEquals("beacon identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getBeacons().iterator().next().getId1().toString());
         assertEquals("region identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getRegion().getId1().toString());
@@ -75,20 +72,18 @@ public void testSerializationBenchmark() throws Exception {
         identifiers.add(Identifier.parse("2"));
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
-        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
         for (int i=0; i < 10; i++) {
             beacons.add(beacon);
         }
         RangingData data = new RangingData(beacons, region);
         long time1 = System.currentTimeMillis();
         for (int i=0; i< 10000; i++) {
-            Parcel parcel = Parcel.obtain();
-            data.writeToParcel(parcel, 0);
-            parcel.setDataPosition(0);
-            RangingData data2 = new RangingData(parcel);
+            Bundle bundle = data.toBundle();
+            RangingData data2 = RangingData.fromBundle(bundle);
         }
         long time2 = System.currentTimeMillis();
         System.out.println("*** Ranging Data Serialization benchmark: "+(time2-time1));
     }
 
-}
\ No newline at end of file
+}
