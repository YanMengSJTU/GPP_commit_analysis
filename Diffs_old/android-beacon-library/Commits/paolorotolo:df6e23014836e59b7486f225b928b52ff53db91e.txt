diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1ff89484..32be0f16 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,9 +1,15 @@
 ### Development
 
-Bug Fixes:
+- Prevent NPE in BluetoothMedic#runScanTest. (#893 Van Hoang Tran) 
+
+### 2.16.2 / 2019-05-29
+
+- Prevent crash on alarms going off with a different user active (#886, David G. Young)
+- Fix thread leak caused by scheduling ScanJob when no consumers bound. (#885, David G. Young)
 - Protect against a NPE when changing ranged regions.  (#770, David G. Young)
 - Fix intermittent failed ranging/monitoring callbacks in race conditions. (#842, David G. Young) 
 - Prevent duplicate callbacks on Android 8+ with a foreground service by stopping ScanJob.  (#847, Stephen Ruda)
+- Only apply Samsung-specific non-empty scan filters when the screen is off (#855, Marcel Schnelle)
 
 ### 2.16.1 / 2019-02-10
 
diff --git a/README.md b/README.md
index 6d02e7e4..b59ac048 100644
--- a/README.md
+++ b/README.md
@@ -58,14 +58,14 @@ replacing `${altbeacon.version}` with the version you wish to use.
 ## How to build this Library
 
 This project uses an AndroidStudio/gradle build system and is known working with Android Studio
-3.2.1 and Gradle 4.10.3
+3.4.1 and Gradle 5.1.1
 
 Key Gradle build targets:
 
     ./gradlew test # run unit tests
     ./gradlew build # development build
     ./gradlew release -Prelease # release build
-    ./gradlew generateJavadoc
+    ./gradlew generateReleaseJavadoc
 
 ## License
 
diff --git a/build.gradle b/build.gradle
index b1f77267..34444127 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,14 +2,25 @@ buildscript {
     repositories {
         google()
         jcenter()
+        mavenCentral()
+        repositories {
+            maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
+        }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.4.0'
+
+        classpath 'com.android.tools.build:gradle:3.4.1'
         //noinspection GradleDependency
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.1'
         //noinspection GradleDependency
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3'
+        // The 3.0 version of this plugin does not support Gradle 5, The latest source does support
+        // Grale 5. So we are using a snapshot until the 4.0 version is released.
+        //classpath "com.vanniktech:gradle-android-javadoc-plugin:0.3.0"
+        dependencies {
+            classpath "com.vanniktech:gradle-android-javadoc-plugin:0.4.0-SNAPSHOT"
+        }
     }
 }
 allprojects {
diff --git a/gradle/eclipse.gradle b/gradle/eclipse.gradle
deleted file mode 100644
index 7fbfd935..00000000
--- a/gradle/eclipse.gradle
+++ /dev/null
@@ -1,31 +0,0 @@
-// tasks for creating an eclipse bundle
-task unzipAar(type: Copy, dependsOn: build) {
-    description = 'Unzip the aar in order to create an eclipse project'
-
-    from zipTree(file("$buildDir/outputs/aar/${project.name}-release.aar"))
-    into file("$buildDir/outputs/aar/android-beacon-library")
-}
-
-task bundleEclipse(type: Tar, dependsOn: unzipAar) {
-    description = 'Creates a tar file for eclipse distributions'
-
-    destinationDir = file("$buildDir/outputs/aar/")
-    extension = 'tar.gz'
-    compression = Compression.GZIP
-    includeEmptyDirs = true
-
-    from("$buildDir/outputs/aar/android-beacon-library") {
-        into 'android-beacon-library'
-        exclude '*.jar'
-    }
-
-    from("$buildDir/outputs/aar/android-beacon-library") {
-        into 'android-beacon-library/libs'
-        include '*.jar'
-    }
-
-    from("$rootDir/eclipse-support/") {
-        into 'android-beacon-library/'
-        exclude '**/.retain'
-    }
-}
diff --git a/gradle/package.gradle b/gradle/package.gradle
index 2387db71..0916aa3d 100644
--- a/gradle/package.gradle
+++ b/gradle/package.gradle
@@ -43,7 +43,6 @@ android.libraryVariants.all { variant ->
         exclude '**/BuildConfig.java'
         exclude '**/R.java'
     }
-
 }
 
 build.mustRunAfter clean
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index e98af8d4..b27fe572 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -4,4 +4,4 @@ distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
 distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
-org.gradle.configureondemand=false
+org.gradle.configureondemand=false
\ No newline at end of file
diff --git a/lib/build.gradle b/lib/build.gradle
index d22b5b09..555890b4 100644
--- a/lib/build.gradle
+++ b/lib/build.gradle
@@ -1,6 +1,6 @@
 apply plugin: 'com.android.library'
-apply from: '../gradle/eclipse.gradle'
 apply from: '../gradle/version.gradle'
+apply plugin: "com.vanniktech.android.javadoc"
 
 android {
     compileSdkVersion 28
@@ -46,7 +46,9 @@ android {
 }
 
 dependencies {
+
     implementation fileTree ( dir: 'libs', include: ['*.jar'] )
+    
     implementation 'androidx.legacy:legacy-support-v4:1.0.0'
     implementation 'androidx.annotation:annotation:1.0.0'
 
@@ -63,4 +65,6 @@ dependencies {
     androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0'
 }
 
-apply from: '../gradle/package.gradle'
\ No newline at end of file
+apply from: '../gradle/package.gradle'
+
+
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconManager.java b/lib/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 54db6500..67149aaf 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -576,6 +576,7 @@ public void setBackgroundMode(boolean backgroundMode) {
      *
      * @param enabled
      */
+
     public void setEnableScheduledScanJobs(boolean enabled) {
         if (isAnyConsumerBound()) {
             LogManager.e(TAG, "ScanJob may not be configured because a consumer is" +
@@ -993,15 +994,16 @@ public void updateScanPeriods() throws RemoteException {
 
     @TargetApi(18)
     private void applyChangesToServices(int type, Region region) throws RemoteException {
+        if (!isAnyConsumerBound()) {
+            LogManager.w(TAG, "The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            return;
+        }
         if (mScheduledScanJobsEnabled) {
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                 ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
             }
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
         Message msg = Message.obtain(null, type, 0, 0);
         if (type == BeaconService.MSG_SET_SCAN_PERIODS) {
             msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/lib/src/main/java/org/altbeacon/beacon/service/ScanJob.java
index 18b66651..b13e0e99 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/ScanJob.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -54,63 +54,71 @@
 
     @Override
     public boolean onStartJob(final JobParameters jobParameters) {
-        if (!initialzeScanHelper()) {
-            LogManager.e(TAG, "Cannot allocate a scanner to look for beacons.  System resources are low.");
-            return false;
-        }
-        ScanJobScheduler.getInstance().ensureNotificationProcessorSetup(getApplicationContext());
-        if (jobParameters.getJobId() == getImmediateScanJobId(this)) {
-            LogManager.i(TAG, "Running immediate scan job: instance is "+this);
-        }
-        else {
-            LogManager.i(TAG, "Running periodic scan job: instance is "+this);
-        }
-
-        List<ScanResult> queuedScanResults = ScanJobScheduler.getInstance().dumpBackgroundScanResultQueue();
-        LogManager.d(TAG, "Processing %d queued scan resuilts", queuedScanResults.size());
-        for (ScanResult result : queuedScanResults) {
-            ScanRecord scanRecord = result.getScanRecord();
-            if (scanRecord != null) {
-                mScanHelper.processScanResult(result.getDevice(), result.getRssi(), scanRecord.getBytes());
-            }
-        }
-        LogManager.d(TAG, "Done processing queued scan resuilts");
+        // We start off on the main UI thread here.
+        // But the ScanState restore from storage sometimes hangs, so we start new thread here just
+        // to kick that off.  This way if the restore hangs, we don't hang the UI thread.
+        new Thread(new Runnable() {
+            public void run() {
+                if (!initialzeScanHelper()) {
+                    LogManager.e(TAG, "Cannot allocate a scanner to look for beacons.  System resources are low.");
+                    ScanJob.this.jobFinished(jobParameters , false);
+                }
+                ScanJobScheduler.getInstance().ensureNotificationProcessorSetup(getApplicationContext());
+                if (jobParameters.getJobId() == getImmediateScanJobId(ScanJob.this)) {
+                    LogManager.i(TAG, "Running immediate scan job: instance is "+this);
+                }
+                else {
+                    LogManager.i(TAG, "Running periodic scan job: instance is "+this);
+                }
 
-        boolean startedScan;
-        if (mInitialized) {
-            LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
-            startedScan = restartScanning();
-        }
-        else {
-            startedScan = startScanning();
-        }
-        mStopHandler.removeCallbacksAndMessages(null);
+                List<ScanResult> queuedScanResults = ScanJobScheduler.getInstance().dumpBackgroundScanResultQueue();
+                LogManager.d(TAG, "Processing %d queued scan resuilts", queuedScanResults.size());
+                for (ScanResult result : queuedScanResults) {
+                    ScanRecord scanRecord = result.getScanRecord();
+                    if (scanRecord != null) {
+                        mScanHelper.processScanResult(result.getDevice(), result.getRssi(), scanRecord.getBytes());
+                    }
+                }
+                LogManager.d(TAG, "Done processing queued scan resuilts");
 
-        if (startedScan) {
-            LogManager.i(TAG, "Scan job running for "+mScanState.getScanJobRuntimeMillis()+" millis");
-            mStopHandler.postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    LogManager.i(TAG, "Scan job runtime expired: " + ScanJob.this);
-                    stopScanning();
-                    mScanState.save();
-                    ScanJob.this.jobFinished(jobParameters , false);
+                boolean startedScan;
+                if (mInitialized) {
+                    LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
+                    startedScan = restartScanning();
+                }
+                else {
+                    startedScan = startScanning();
+                }
+                mStopHandler.removeCallbacksAndMessages(null);
 
-                    // need to execute this after the current block or Android stops this job prematurely
-                    mStopHandler.post(new Runnable() {
+                if (startedScan) {
+                    LogManager.i(TAG, "Scan job running for "+mScanState.getScanJobRuntimeMillis()+" millis");
+                    mStopHandler.postDelayed(new Runnable() {
                         @Override
                         public void run() {
-                            scheduleNextScan();
-                        }
-                    });
+                            LogManager.i(TAG, "Scan job runtime expired: " + ScanJob.this);
+                            stopScanning();
+                            mScanState.save();
+                            ScanJob.this.jobFinished(jobParameters , false);
 
+                            // need to execute this after the current block or Android stops this job prematurely
+                            mStopHandler.post(new Runnable() {
+                                @Override
+                                public void run() {
+                                    scheduleNextScan();
+                                }
+                            });
+
+                        }
+                    }, mScanState.getScanJobRuntimeMillis());
                 }
-            }, mScanState.getScanJobRuntimeMillis());
-        }
-        else {
-            LogManager.i(TAG, "Scanning not started so Scan job is complete.");
-            ScanJob.this.jobFinished(jobParameters , false);
-        }
+                else {
+                    LogManager.i(TAG, "Scanning not started so Scan job is complete.");
+                    ScanJob.this.jobFinished(jobParameters , false);
+                }
+            }
+        }).start();
+
         return true;
     }
 
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 3f803ac6..b9f051c2 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -6,13 +6,16 @@
 import android.app.PendingIntent;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothManager;
+import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.content.IntentFilter;
 import android.content.pm.PackageManager;
 import android.os.Build;
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.Looper;
+import android.os.PowerManager;
 import android.os.SystemClock;
 import androidx.annotation.AnyThread;
 import androidx.annotation.MainThread;
@@ -52,6 +55,7 @@
     // avoid doing too many scans in a limited time on Android 7.0 or because we are capable of
     // multiple detections.  If true, it indicates scanning needs to be stopped when we finish.
     private boolean mScanningLeftOn = false;
+    private BroadcastReceiver mCancelAlarmOnUserSwitchBroadcastReceiver = null;
 
     protected long mBetweenScanPeriod;
 
@@ -260,7 +264,6 @@ public void destroy() {
 
         // Remove any postDelayed Runnables queued for the next scan cycle
         mHandler.removeCallbacksAndMessages(null);
-
         // We cannot quit the thread used by the handler until queued Runnables have been processed,
         // because the handler is what stops scanning, and we do not want scanning left on.
         // So we stop the thread using the handler, so we make sure it happens after all other
@@ -273,6 +276,7 @@ public void run() {
                 mScanThread.quit();
             }
         });
+        cleanupCancelAlarmOnUserSwitch();
     }
 
     protected abstract void stopScan();
@@ -484,12 +488,37 @@ protected void setWakeUpAlarm() {
         if (milliseconds < mScanPeriod) {
             milliseconds = mScanPeriod;
         }
-
         AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
         alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + milliseconds, getWakeUpOperation());
         LogManager.d(TAG, "Set a wakeup alarm to go off in %s ms: %s", milliseconds, getWakeUpOperation());
+        cancelAlarmOnUserSwitch();
     }
 
+    // Added to prevent crash on switching users.  See #876
+    protected void cancelAlarmOnUserSwitch() {
+        if (mCancelAlarmOnUserSwitchBroadcastReceiver == null) {
+            IntentFilter filter = new IntentFilter();
+            filter.addAction( Intent.ACTION_USER_BACKGROUND );
+            filter.addAction( Intent.ACTION_USER_FOREGROUND );
+
+            mCancelAlarmOnUserSwitchBroadcastReceiver = new BroadcastReceiver() {
+                @Override
+                public void onReceive(Context context, Intent intent) {
+                    LogManager.w(TAG, "User switch detected.  Cancelling alarm to prevent potential crash.");
+                    cancelWakeUpAlarm();
+                }
+            };
+            mContext.registerReceiver(mCancelAlarmOnUserSwitchBroadcastReceiver, filter);
+        }
+    }
+    protected void cleanupCancelAlarmOnUserSwitch() {
+        if (mCancelAlarmOnUserSwitchBroadcastReceiver != null) {
+            mContext.unregisterReceiver(mCancelAlarmOnUserSwitchBroadcastReceiver);
+            mCancelAlarmOnUserSwitchBroadcastReceiver = null;
+        }
+    }
+
+
     protected PendingIntent getWakeUpOperation() {
         if (mWakeUpOperation == null) {
             Intent wakeupIntent = new Intent(mContext, StartupBroadcastReceiver.class);
diff --git a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index b1d8b26b..1cc98bba 100644
--- a/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/lib/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -11,6 +11,7 @@
 import android.content.Intent;
 import android.os.Build;
 import android.os.ParcelUuid;
+import android.os.PowerManager;
 import android.os.SystemClock;
 import androidx.annotation.MainThread;
 import androidx.annotation.WorkerThread;
@@ -34,10 +35,12 @@
     private long mBackgroundLScanFirstDetectionTime = 0;
     private boolean mMainScanCycleActive = false;
     private final BeaconManager mBeaconManager;
+    private final PowerManager mPowerManager;
 
     public CycledLeScannerForLollipop(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
         super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         mBeaconManager = BeaconManager.getInstanceForApplication(mContext);
+        mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
     }
 
     @Override
@@ -186,7 +189,7 @@ protected void startScan() {
             // We only add these filters on 8.1+ devices, because adding scan filters has been reported
             // to cause scan failures on some Samsung devices with Android 5.x
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {
-                if (Build.MANUFACTURER.equalsIgnoreCase("samsung")) {
+                if (Build.MANUFACTURER.equalsIgnoreCase("samsung") && !mPowerManager.isInteractive()) {
                     // On the Samsung Galaxy Note 8.1, scans are blocked with screen off when the
                     // scan filter is empty (wildcard).  We do a more detailed filter on Samsung only
                     // because it might block detections of AltBeacon packets with non-standard
diff --git a/lib/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java b/lib/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
index 2e9790a9..489f26b9 100644
--- a/lib/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
+++ b/lib/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
@@ -276,6 +276,9 @@ public void onScanFailed(int errorCode) {
                     scanner.stopScan(callback);
                 } catch (IllegalStateException e) {
                     LogManager.d(TAG, "Bluetooth is off.  Cannot run scan test.");
+                } catch (NullPointerException e) {
+                    // Needed to stop a crash caused by internal NPE thrown by Android.  See issue #636
+                    LogManager.e(TAG, "NullPointerException. Cannot run scan test.", e);
                 }
             }
             else {
@@ -468,4 +471,4 @@ private BluetoothLeAdvertiser getAdvertiserSafely(BluetoothAdapter adapter) {
         }
         return null;
     }
-}
\ No newline at end of file
+}
