diff --git a/lib/build.gradle b/lib/build.gradle
index 1d483c1e..9645b25b 100644
--- a/lib/build.gradle
+++ b/lib/build.gradle
@@ -50,23 +50,21 @@ configurations {
 }
 
 dependencies {
-    implementation fileTree ( dir: 'libs', include: ['*.jar'] )
+    implementation fileTree(include: ['*.jar'], dir: 'libs')
     implementation 'com.android.support:support-v4:28.0.0'
     implementation 'com.android.support:support-annotations:28.0.0'
-
     testImplementation 'junit:junit:4.12'
     testImplementation 'org.robolectric:robolectric:4.1'
     testImplementation 'com.google.android:android-test:4.1.1.4'
     testImplementation 'com.squareup:fest-android:1.0.8@aar'
     testImplementation 'org.mockito:mockito-core:2.23.4'
-
     androidTestUtil 'com.android.support.test:orchestrator:1.0.2'
-
     androidTestImplementation 'com.android.support.test:rules:1.0.2'
     androidTestImplementation 'org.apache.commons:commons-math3:3.6.1'
     androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
-    
     doclava 'com.google.doclava:doclava:1.0.6'
+    implementation files('src/main/resources/sensoro-beacon-kit-4.3.jar')
+    implementation files('src/main/resources/sensoro-scanner-1.0.1.jar')
 }
 
 apply from: '../gradle/package.gradle'
\ No newline at end of file
diff --git a/lib/src/main/java/org/altbeacon/beacon/Beacon.java b/lib/src/main/java/org/altbeacon/beacon/Beacon.java
index 9b012b99..50fe1d51 100644
--- a/lib/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/lib/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -181,6 +181,10 @@
      */
     protected boolean mMultiFrameBeacon = false;
 
+    protected int batteryLevel;
+
+    protected Integer temperature;
+
     /**
      * Required for making object Parcelable.  If you override this class, you must provide an
      * equivalent version of this method.
diff --git a/lib/src/main/java/org/altbeacon/beacon/BeaconParser.java b/lib/src/main/java/org/altbeacon/beacon/BeaconParser.java
index 4fea00c5..f25ea524 100644
--- a/lib/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/lib/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -5,6 +5,9 @@
 import android.os.Build;
 import android.util.Log;
 
+import com.android.scanner.ScanBLERecord;
+import com.android.scanner.ScanBLEResult;
+
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.bluetooth.BleAdvertisement;
 import org.altbeacon.bluetooth.Pdu;
@@ -12,6 +15,7 @@
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -35,7 +39,6 @@
  * For more information on how to set up parsing of a beacon,
  * {@link #setBeaconLayout(String) see setBeaconLayout(String)}
  * </p>
- *
  */
 public class BeaconParser implements Serializable {
     private static final String TAG = "BeaconParser";
@@ -50,9 +53,13 @@
     private static final Pattern D_PATTERN = Pattern.compile("d\\:(\\d+)\\-(\\d+)([bl]*)?");
     private static final Pattern P_PATTERN = Pattern.compile("p\\:(\\d+)\\-(\\d+)\\:?([\\-\\d]+)?");
     private static final Pattern X_PATTERN = Pattern.compile("x");
-    private static final char[] HEX_ARRAY = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
+    private static final char[] HEX_ARRAY = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
     private static final String LITTLE_ENDIAN_SUFFIX = "l";
     private static final String VARIABLE_LENGTH_SUFFIX = "v";
+    private static final String SENSORO_BROADCAST_KEY = "7b4b5ff594fdaf8f9fc7f2b494e400016f461205";
+    private static final char[] HEX_CHAR_TABLE = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+    private static final byte[] HEX_TABLE = new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
+
 
     protected String mBeaconLayout;
     private Long mMatchingBeaconTypeCode;
@@ -76,9 +83,10 @@
     protected Integer mLayoutSize;
     protected Boolean mAllowPduOverflow = true;
     protected String mIdentifier;
-    protected int[] mHardwareAssistManufacturers = new int[] { 0x004c };
+    protected int[] mHardwareAssistManufacturers = new int[]{0x004c};
 
     protected List<BeaconParser> extraParsers = new ArrayList<BeaconParser>();
+    private HashMap<String, byte[]> sensoroBroadcastKeyMap;
 
 
     /**
@@ -139,14 +147,14 @@ public BeaconParser(String identifier) {
      * <p>Example of a parser string for AltBeacon:</p>
      *
      * </pre>
-     *   "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25"
+     * "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25"
      * </pre>
      *
      * <p>This signifies that the beacon type will be decoded when an advertisement is found with
      * 0xbeac in bytes 2-3, and a three-part identifier will be pulled out of bytes 4-19, bytes
      * 20-21 and bytes 22-23, respectively.  A signed power calibration value will be pulled out of
      * byte 24, and a data field will be pulled out of byte 25.</p>
-     *
+     * <p>
      * Note: bytes 0-1 of the BLE manufacturer advertisements are the two byte manufacturer code.
      * Generally you should not match on these two bytes when using a BeaconParser, because it will
      * limit your parser to matching only a transmitter made by a specific manufacturer.  Software
@@ -158,19 +166,19 @@ public BeaconParser(String identifier) {
      *
      * <p>
      * Extra layouts can also be added by using:
+     *
+     * @param beaconLayout
+     * @return the BeaconParser instance
      * @see #addExtraDataParser(BeaconParser)
      * This is the preferred method and matching BeaconLayouts by serviceUUID will be deprecated in
      * the future.
      * </p>
-     *
-     * @param beaconLayout
-     * @return the BeaconParser instance
      */
     public BeaconParser setBeaconLayout(String beaconLayout) {
         mBeaconLayout = beaconLayout;
-        Log.d(TAG, "Parsing beacon layout: "+beaconLayout);
+        Log.d(TAG, "Parsing beacon layout: " + beaconLayout);
 
-        String[] terms =  beaconLayout.split(",");
+        String[] terms = beaconLayout.split(",");
         mExtraFrame = false; // this is not an extra frame by default
 
         for (String term : terms) {
@@ -216,9 +224,9 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
                     if (matcher.group(3) != null) {
                         dBmCorrection = Integer.parseInt(matcher.group(3));
                     }
-                    mDBmCorrection=dBmCorrection;
-                    mPowerStartOffset=startOffset;
-                    mPowerEndOffset=endOffset;
+                    mDBmCorrection = dBmCorrection;
+                    mPowerStartOffset = startOffset;
+                    mPowerEndOffset = endOffset;
                 } catch (NumberFormatException e) {
                     throw new BeaconLayoutException("Cannot parse integer power byte offset in term: " + term);
                 }
@@ -236,10 +244,9 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
                 }
                 String hexString = matcher.group(3);
                 try {
-                    mMatchingBeaconTypeCode = Long.decode("0x"+hexString);
-                }
-                catch (NumberFormatException e) {
-                    throw new BeaconLayoutException("Cannot parse beacon type code: "+hexString+" in term: " + term);
+                    mMatchingBeaconTypeCode = Long.decode("0x" + hexString);
+                } catch (NumberFormatException e) {
+                    throw new BeaconLayoutException("Cannot parse beacon type code: " + hexString + " in term: " + term);
                 }
             }
             matcher = S_PATTERN.matcher(term);
@@ -255,10 +262,9 @@ public BeaconParser setBeaconLayout(String beaconLayout) {
                 }
                 String hexString = matcher.group(3);
                 try {
-                    mServiceUuid = Long.decode("0x"+hexString);
-                }
-                catch (NumberFormatException e) {
-                    throw new BeaconLayoutException("Cannot parse serviceUuid: "+hexString+" in term: " + term);
+                    mServiceUuid = Long.decode("0x" + hexString);
+                } catch (NumberFormatException e) {
+                    throw new BeaconLayoutException("Cannot parse serviceUuid: " + hexString + " in term: " + term);
                 }
             }
             matcher = X_PATTERN.matcher(term);
@@ -303,9 +309,9 @@ public boolean addExtraDataParser(BeaconParser extraDataParser) {
     /**
      * Gets a list of extra parsers configured for this <code>BeaconParser</code>.
      *
+     * @return
      * @see #addExtraDataParser
      * @see #setBeaconLayout
-     * @return
      */
     public List<BeaconParser> getExtraDataParsers() {
         return new ArrayList<>(extraParsers);
@@ -314,6 +320,7 @@ public boolean addExtraDataParser(BeaconParser extraDataParser) {
     /**
      * Gets an optional identifier field that may be used to identify this parser.  If set, it will
      * be passed along to any beacons decoded with this parser.
+     *
      * @return
      */
     public String getIdentifier() {
@@ -323,7 +330,7 @@ public String getIdentifier() {
     /**
      * Returns a list of Bluetooth manufacturer codes which will be used for hardware-assisted
      * accelerated looking for this beacon type
-     *
+     * <p>
      * The possible codes are defined on this list:
      * https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers
      *
@@ -336,10 +343,9 @@ public String getIdentifier() {
     /**
      * Sets a list of Bluetooth manufacturer codes which will be used for hardware-assisted
      * accelerated looking for this beacon type
-     *
+     * <p>
      * The possible codes are defined on this list:
      * https://www.bluetooth.org/en-us/specification/assigned-numbers/company-identifiers
-     *
      */
     public void setHardwareAssistManufacturerCodes(int[] manufacturers) {
         mHardwareAssistManufacturers = manufacturers;
@@ -349,6 +355,7 @@ public void setHardwareAssistManufacturerCodes(int[] manufacturers) {
      * Setting to true indicates that packets should be rejected if the PDU length is too short for
      * the fields.  Some beacons transmit malformed PDU packets that understate their length, so
      * this defaults to false.
+     *
      * @param enabled
      */
     public void setAllowPduOverflow(Boolean enabled) {
@@ -356,8 +363,8 @@ public void setAllowPduOverflow(Boolean enabled) {
     }
 
     /**
-     * @see #mMatchingBeaconTypeCode
      * @return
+     * @see #mMatchingBeaconTypeCode
      */
     public Long getMatchingBeaconTypeCode() {
         return mMatchingBeaconTypeCode;
@@ -365,6 +372,7 @@ public Long getMatchingBeaconTypeCode() {
 
     /**
      * see #mMatchingBeaconTypeCodeStartOffset
+     *
      * @return
      */
     public int getMatchingBeaconTypeCodeStartOffset() {
@@ -373,6 +381,7 @@ public int getMatchingBeaconTypeCodeStartOffset() {
 
     /**
      * see #mMatchingBeaconTypeCodeEndOffset
+     *
      * @return
      */
     public int getMatchingBeaconTypeCodeEndOffset() {
@@ -381,8 +390,8 @@ public int getMatchingBeaconTypeCodeEndOffset() {
 
 
     /**
-     * @see #mServiceUuid
      * @return
+     * @see #mServiceUuid
      */
     public Long getServiceUuid() {
         return mServiceUuid;
@@ -390,6 +399,7 @@ public Long getServiceUuid() {
 
     /**
      * see #mServiceUuidStartOffset
+     *
      * @return
      */
     public int getMServiceUuidStartOffset() {
@@ -398,6 +408,7 @@ public int getMServiceUuidStartOffset() {
 
     /**
      * see #mServiceUuidEndOffset
+     *
      * @return
      */
     public int getServiceUuidEndOffset() {
@@ -410,8 +421,8 @@ public int getServiceUuidEndOffset() {
      * including the raw Bluetooth device info
      *
      * @param scanData The actual packet bytes
-     * @param rssi The measured signal strength of the packet
-     * @param device The Bluetooth device that was detected
+     * @param rssi     The measured signal strength of the packet
+     * @param device   The Bluetooth device that was detected
      * @return An instance of a <code>Beacon</code>
      */
     public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
@@ -427,7 +438,7 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
         ArrayList<Identifier> identifiers = new ArrayList<Identifier>();
         ArrayList<Long> dataFields = new ArrayList<Long>();
 
-        for (Pdu pdu: advert.getPdus()) {
+        for (Pdu pdu : advert.getPdus()) {
             if (pdu.getType() == Pdu.GATT_SERVICE_UUID_PDU_TYPE ||
                     pdu.getType() == Pdu.MANUFACTURER_DATA_PDU_TYPE) {
                 pduToParse = pdu;
@@ -435,8 +446,7 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
                     LogManager.d(TAG, "Processing pdu type %02X: %s with startIndex: %d, endIndex: %d", pdu.getType(), bytesToHex(bytesToProcess), pdu.getStartIndex(), pdu.getEndIndex());
                 }
                 break;
-            }
-            else {
+            } else {
                 if (LogManager.isVerboseLoggingEnabled()) {
                     LogManager.d(TAG, "Ignoring pdu type %02X", pdu.getType());
                 }
@@ -447,8 +457,7 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
                 LogManager.d(TAG, "No PDUs to process in this packet.");
             }
             parseFailed = true;
-        }
-        else {
+        } else {
             byte[] serviceUuidBytes = null;
             byte[] typeCodeBytes = longToByteArray(getMatchingBeaconTypeCode(), mMatchingBeaconTypeCodeEndOffset - mMatchingBeaconTypeCodeStartOffset + 1);
             if (getServiceUuid() != null) {
@@ -489,7 +498,7 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
                     }
                 }
                 parseFailed = true;
-                beacon =  null;
+                beacon = null;
             } else {
                 if (LogManager.isVerboseLoggingEnabled()) {
                     LogManager.d(TAG, "This is a recognized beacon advertisement -- %s seen",
@@ -499,41 +508,39 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
             }
 
             if (patternFound) {
-                if (bytesToProcess.length <= startByte+mLayoutSize && mAllowPduOverflow) {
+                if (bytesToProcess.length <= startByte + mLayoutSize && mAllowPduOverflow) {
                     // If the layout size is bigger than this PDU, and we allow overflow.  Make sure
                     // the byte buffer is big enough by zero padding the end so we don't try to read
                     // outside the byte array of the advertisement
                     if (LogManager.isVerboseLoggingEnabled()) {
-                        LogManager.d(TAG, "Expanding buffer because it is too short to parse: "+bytesToProcess.length+", needed: "+(startByte+mLayoutSize));
+                        LogManager.d(TAG, "Expanding buffer because it is too short to parse: " + bytesToProcess.length + ", needed: " + (startByte + mLayoutSize));
                     }
-                    bytesToProcess = ensureMaxSize(bytesToProcess, startByte+mLayoutSize);
+                    bytesToProcess = ensureMaxSize(bytesToProcess, startByte + mLayoutSize);
                 }
                 for (int i = 0; i < mIdentifierEndOffsets.size(); i++) {
                     int endIndex = mIdentifierEndOffsets.get(i) + startByte;
 
                     if (endIndex > pduToParse.getEndIndex() && mIdentifierVariableLengthFlags.get(i)) {
                         if (LogManager.isVerboseLoggingEnabled()) {
-                            LogManager.d(TAG, "Need to truncate identifier by "+(endIndex-pduToParse.getEndIndex()));
+                            LogManager.d(TAG, "Need to truncate identifier by " + (endIndex - pduToParse.getEndIndex()));
                         }
                         // If this is a variable length identifier, we truncate it to the size that
                         // is available in the packet
                         int start = mIdentifierStartOffsets.get(i) + startByte;
-                        int end = pduToParse.getEndIndex()+1;
+                        int end = pduToParse.getEndIndex() + 1;
                         if (end <= start) {
                             LogManager.d(TAG, "PDU is too short for identifer.  Packet is malformed");
                             return null;
                         }
                         Identifier identifier = Identifier.fromBytes(bytesToProcess, start, end, mIdentifierLittleEndianFlags.get(i));
                         identifiers.add(identifier);
-                    }
-                    else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
+                    } else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                         parseFailed = true;
                         if (LogManager.isVerboseLoggingEnabled()) {
-                            LogManager.d(TAG, "Cannot parse identifier "+i+" because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex());
+                            LogManager.d(TAG, "Cannot parse identifier " + i + " because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex());
                         }
-                    }
-                    else {
-                        Identifier identifier = Identifier.fromBytes(bytesToProcess, mIdentifierStartOffsets.get(i) + startByte, endIndex+1, mIdentifierLittleEndianFlags.get(i));
+                    } else {
+                        Identifier identifier = Identifier.fromBytes(bytesToProcess, mIdentifierStartOffsets.get(i) + startByte, endIndex + 1, mIdentifierLittleEndianFlags.get(i));
                         identifiers.add(identifier);
                     }
                 }
@@ -541,11 +548,10 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                     int endIndex = mDataEndOffsets.get(i) + startByte;
                     if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                         if (LogManager.isVerboseLoggingEnabled()) {
-                            LogManager.d(TAG, "Cannot parse data field "+i+" because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex()+".  Setting value to 0");
+                            LogManager.d(TAG, "Cannot parse data field " + i + " because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex() + ".  Setting value to 0");
                         }
                         dataFields.add(new Long(0l));
-                    }
-                    else {
+                    } else {
                         String dataString = byteArrayToFormattedString(bytesToProcess, mDataStartOffsets.get(i) + startByte, endIndex, mDataLittleEndianFlags.get(i));
                         dataFields.add(Long.decode(dataString));
                     }
@@ -560,21 +566,18 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                             if (LogManager.isVerboseLoggingEnabled()) {
                                 LogManager.d(TAG, "Cannot parse power field because PDU is too short.  endIndex: " + endIndex + " PDU endIndex: " + pduToParse.getEndIndex());
                             }
-                        }
-                        else {
+                        } else {
                             String powerString = byteArrayToFormattedString(bytesToProcess, mPowerStartOffset + startByte, mPowerEndOffset + startByte, false);
-                            txPower = Integer.parseInt(powerString)+mDBmCorrection;
+                            txPower = Integer.parseInt(powerString) + mDBmCorrection;
                             // make sure it is a signed integer
                             if (txPower > 127) {
                                 txPower -= 256;
                             }
                             beacon.mTxPower = txPower;
                         }
-                    }
-                    catch (NumberFormatException e1) {
+                    } catch (NumberFormatException e1) {
                         // keep default value
-                    }
-                    catch (NullPointerException e2) {
+                    } catch (NullPointerException e2) {
                         // keep default value
                     }
                 }
@@ -583,15 +586,14 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
 
         if (parseFailed) {
             beacon = null;
-        }
-        else {
+        } else {
             int beaconTypeCode = 0;
-            String beaconTypeString = byteArrayToFormattedString(bytesToProcess, mMatchingBeaconTypeCodeStartOffset+startByte, mMatchingBeaconTypeCodeEndOffset+startByte, false);
+            String beaconTypeString = byteArrayToFormattedString(bytesToProcess, mMatchingBeaconTypeCodeStartOffset + startByte, mMatchingBeaconTypeCodeEndOffset + startByte, false);
             beaconTypeCode = Integer.parseInt(beaconTypeString);
             // TODO: error handling needed on the parse
 
             int manufacturer = 0;
-            String manufacturerString = byteArrayToFormattedString(bytesToProcess, startByte, startByte+1, true);
+            String manufacturerString = byteArrayToFormattedString(bytesToProcess, startByte, startByte + 1, true);
             manufacturer = Integer.parseInt(manufacturerString);
 
             String macAddress = null;
@@ -607,22 +609,89 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
             beacon.mBeaconTypeCode = beaconTypeCode;
             if (mServiceUuid != null) {
                 beacon.mServiceUuid = (int) mServiceUuid.longValue();
-            }
-            else {
+            } else {
                 beacon.mServiceUuid = -1;
             }
 
             beacon.mBluetoothAddress = macAddress;
-            beacon.mBluetoothName= name;
+            beacon.mBluetoothName = name;
             beacon.mManufacturer = manufacturer;
             beacon.mParserIdentifier = mIdentifier;
             beacon.mMultiFrameBeacon = extraParsers.size() > 0 || mExtraFrame;
+            beacon = parseSensoroBeacon(beacon, device);
+        }
+        return beacon;
+    }
+
+    public Beacon parseSensoroBeacon(Beacon beacon, BluetoothDevice device) {
+        addSensoroKey();
+
+        if (this.sensoroBroadcastKeyMap.isEmpty()) {
+            return beacon;
         }
+
+        ScanBLERecord scanBLERecord = ScanBLERecord.parseFromBytes(beacon.mAdvertismentByte);
+        ScanBLEResult scanBLEResult = new ScanBLEResult(device, scanBLERecord, beacon.getRssi(), System.nanoTime());
+
+        E781 e781 = E781.createE781(scanBLEResult, this.sensoroBroadcastKeyMap);
+        if (e781 != null) {
+            beacon.batteryLevel = e781.batteryLevel;
+            beacon.temperature = e781.temperature;
+        }
+
+        this.sensoroBroadcastKeyMap.clear();
+
         return beacon;
     }
 
+    private void addSensoroKey() {
+        String secret = SENSORO_BROADCAST_KEY.substring(0, 28);
+        byte[] secretBytes = this.hexToByte(secret);
+        String keyId = SENSORO_BROADCAST_KEY.substring(28, 32);
+        if (this.sensoroBroadcastKeyMap != null) {
+            this.sensoroBroadcastKeyMap.put(keyId, secretBytes);
+        }
+    }
+
+    private byte[] hexToByte(String hexString) {
+        if (hexString != null && hexString.length() != 0) {
+            if (hexString.length() % 2 != 0) {
+                throw new RuntimeException();
+            } else {
+                byte[] data = new byte[hexString.length() / 2];
+                char[] chars = hexString.toCharArray();
+
+                for (int i = 0; i < hexString.length(); i += 2) {
+                    data[i / 2] = (byte) (HEX_TABLE[this.getHexCharValue(chars[i])] << 4 | HEX_TABLE[this.getHexCharValue(chars[i + 1])]);
+                }
+
+                return data;
+            }
+        } else {
+            return null;
+        }
+    }
+
+    private int getHexCharValue(char c) {
+        int index = 0;
+        char[] var3 = HEX_CHAR_TABLE;
+        int var4 = var3.length;
+
+        for (int var5 = 0; var5 < var4; ++var5) {
+            char c1 = var3[var5];
+            if (c == c1) {
+                return index;
+            }
+
+            ++index;
+        }
+
+        return 0;
+    }
+
     /**
      * Get BLE advertisement bytes for a Beacon
+     *
      * @param beacon the beacon containing the data to be transmitted
      * @return the byte array of the advertisement
      */
@@ -631,7 +700,7 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
         byte[] advertisingBytes;
 
         if (beacon.getIdentifiers().size() != getIdentifierCount()) {
-            throw new IllegalArgumentException("Beacon has "+beacon.getIdentifiers().size()+" identifiers but format requires "+getIdentifierCount());
+            throw new IllegalArgumentException("Beacon has " + beacon.getIdentifiers().size() + " identifiers but format requires " + getIdentifierCount());
         }
 
         int lastIndex = -1;
@@ -656,7 +725,7 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
         int adjustedIdentifiersLength = 0;
         for (int identifierNum = 0; identifierNum < this.mIdentifierStartOffsets.size(); identifierNum++) {
             if (mIdentifierVariableLengthFlags.get(identifierNum)) {
-                int declaredIdentifierLength = (this.mIdentifierEndOffsets.get(identifierNum) - this.mIdentifierStartOffsets.get(identifierNum)+1);
+                int declaredIdentifierLength = (this.mIdentifierEndOffsets.get(identifierNum) - this.mIdentifierStartOffsets.get(identifierNum) + 1);
                 int actualIdentifierLength = beacon.getIdentifier(identifierNum).getByteCount();
                 adjustedIdentifiersLength += actualIdentifierLength;
                 adjustedIdentifiersLength -= declaredIdentifierLength;
@@ -664,13 +733,13 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
         }
         lastIndex += adjustedIdentifiersLength;
 
-        advertisingBytes = new byte[lastIndex+1-2];
+        advertisingBytes = new byte[lastIndex + 1 - 2];
         long beaconTypeCode = this.getMatchingBeaconTypeCode();
 
         // set type code
         for (int index = this.mMatchingBeaconTypeCodeStartOffset; index <= this.mMatchingBeaconTypeCodeEndOffset; index++) {
-            byte value = (byte) (this.getMatchingBeaconTypeCode() >> (8*(this.mMatchingBeaconTypeCodeEndOffset-index)) & 0xff);
-            advertisingBytes[index-2] = value;
+            byte value = (byte) (this.getMatchingBeaconTypeCode() >> (8 * (this.mMatchingBeaconTypeCodeEndOffset - index)) & 0xff);
+            advertisingBytes[index - 2] = value;
         }
 
         // set identifiers
@@ -684,41 +753,37 @@ else if (endIndex > pduToParse.getEndIndex() && !mAllowPduOverflow) {
                     // Pad it, but only if this is not a variable length identifier
                     if (mIdentifierLittleEndianFlags.get(identifierNum)) {
                         // this is little endian.  Pad at the end of the array
-                        identifierBytes = Arrays.copyOf(identifierBytes,getIdentifierByteCount(identifierNum));
-                    }
-                    else {
+                        identifierBytes = Arrays.copyOf(identifierBytes, getIdentifierByteCount(identifierNum));
+                    } else {
                         // this is big endian.  Pad at the beginning of the array
                         byte[] newIdentifierBytes = new byte[getIdentifierByteCount(identifierNum)];
-                        System.arraycopy(identifierBytes, 0, newIdentifierBytes, getIdentifierByteCount(identifierNum)-identifierBytes.length, identifierBytes.length);
+                        System.arraycopy(identifierBytes, 0, newIdentifierBytes, getIdentifierByteCount(identifierNum) - identifierBytes.length, identifierBytes.length);
                         identifierBytes = newIdentifierBytes;
                     }
                 }
-                LogManager.d(TAG, "Expanded identifier because it is too short.  It is now: "+byteArrayToString(identifierBytes));
-            }
-            else if (identifierBytes.length > getIdentifierByteCount(identifierNum)) {
+                LogManager.d(TAG, "Expanded identifier because it is too short.  It is now: " + byteArrayToString(identifierBytes));
+            } else if (identifierBytes.length > getIdentifierByteCount(identifierNum)) {
                 if (mIdentifierLittleEndianFlags.get(identifierNum)) {
                     // Truncate it at the beginning for big endian
-                    identifierBytes = Arrays.copyOfRange(identifierBytes, getIdentifierByteCount(identifierNum)-identifierBytes.length, getIdentifierByteCount(identifierNum));
-                }
-                else {
+                    identifierBytes = Arrays.copyOfRange(identifierBytes, getIdentifierByteCount(identifierNum) - identifierBytes.length, getIdentifierByteCount(identifierNum));
+                } else {
                     // Truncate it at the end for little endian
-                    identifierBytes = Arrays.copyOf(identifierBytes,getIdentifierByteCount(identifierNum));
+                    identifierBytes = Arrays.copyOf(identifierBytes, getIdentifierByteCount(identifierNum));
                 }
-                LogManager.d(TAG, "Truncated identifier because it is too long.  It is now: "+byteArrayToString(identifierBytes));
-            }
-            else {
-                LogManager.d(TAG, "Identifier size is just right: "+byteArrayToString(identifierBytes));
+                LogManager.d(TAG, "Truncated identifier because it is too long.  It is now: " + byteArrayToString(identifierBytes));
+            } else {
+                LogManager.d(TAG, "Identifier size is just right: " + byteArrayToString(identifierBytes));
             }
-            for (int index = this.mIdentifierStartOffsets.get(identifierNum); index <= this.mIdentifierStartOffsets.get(identifierNum)+identifierBytes.length-1; index ++) {
-                advertisingBytes[index-2] = (byte) identifierBytes[index-this.mIdentifierStartOffsets.get(identifierNum)];
+            for (int index = this.mIdentifierStartOffsets.get(identifierNum); index <= this.mIdentifierStartOffsets.get(identifierNum) + identifierBytes.length - 1; index++) {
+                advertisingBytes[index - 2] = (byte) identifierBytes[index - this.mIdentifierStartOffsets.get(identifierNum)];
             }
         }
 
         // set power
 
         if (this.mPowerStartOffset != null && this.mPowerEndOffset != null) {
-            for (int index = this.mPowerStartOffset; index <= this.mPowerEndOffset; index ++) {
-                advertisingBytes[index-2] = (byte) (beacon.getTxPower() >> (8*(index - this.mPowerStartOffset)) & 0xff);
+            for (int index = this.mPowerStartOffset; index <= this.mPowerEndOffset; index++) {
+                advertisingBytes[index - 2] = (byte) (beacon.getTxPower() >> (8 * (index - this.mPowerStartOffset)) & 0xff);
             }
         }
 
@@ -726,12 +791,12 @@ else if (identifierBytes.length > getIdentifierByteCount(identifierNum)) {
         for (int dataFieldNum = 0; dataFieldNum < this.mDataStartOffsets.size(); dataFieldNum++) {
             long dataField = beacon.getDataFields().get(dataFieldNum);
             int dataFieldLength = this.mDataEndOffsets.get(dataFieldNum) - this.mDataStartOffsets.get(dataFieldNum);
-            for (int index = 0; index <= dataFieldLength; index ++) {
+            for (int index = 0; index <= dataFieldLength; index++) {
                 int endianCorrectedIndex = index;
                 if (!this.mDataLittleEndianFlags.get(dataFieldNum)) {
-                    endianCorrectedIndex = dataFieldLength-index;
+                    endianCorrectedIndex = dataFieldLength - index;
                 }
-                advertisingBytes[this.mDataStartOffsets.get(dataFieldNum)-2+endianCorrectedIndex] = (byte) (dataField >> (8*index) & 0xff);
+                advertisingBytes[this.mDataStartOffsets.get(dataFieldNum) - 2 + endianCorrectedIndex] = (byte) (dataField >> (8 * index) & 0xff);
             }
         }
         return advertisingBytes;
@@ -744,6 +809,7 @@ public BeaconParser setMatchingBeaconTypeCode(Long typeCode) {
 
     /**
      * Caclculates the byte size of the specified identifier in this format
+     *
      * @param identifierNum
      * @return bytes
      */
@@ -776,12 +842,14 @@ public String getLayout() {
      * @return the correction value in dBm to apply to the calibrated txPower to get a 1m calibrated value.
      * Some formats like Eddystone use a 0m calibrated value, which requires this correction
      */
-    public int getPowerCorrection() { return mDBmCorrection; }
+    public int getPowerCorrection() {
+        return mDBmCorrection;
+    }
 
     protected static String bytesToHex(byte[] bytes) {
         char[] hexChars = new char[bytes.length * 2];
         int v;
-        for ( int j = 0; j < bytes.length; j++ ) {
+        for (int j = 0; j < bytes.length; j++) {
             v = bytes[j] & 0xFF;
             hexChars[j * 2] = HEX_ARRAY[v >>> 4];
             hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
@@ -791,7 +859,7 @@ protected static String bytesToHex(byte[] bytes) {
 
     public static class BeaconLayoutException extends RuntimeException {
         public BeaconLayoutException(String s) {
-        super(s);
+            super(s);
         }
     }
 
@@ -801,15 +869,16 @@ public BeaconLayoutException(String s) {
 
     public static byte[] longToByteArray(long longValue, int length, boolean bigEndian) {
         byte[] array = new byte[length];
-        for (int i = 0; i < length; i++){
-            int adjustedI = bigEndian ? i : length - i -1;
-            long mask = 0xffl << (length-adjustedI-1)*8;
-            long shift = (length-adjustedI-1)*8;
-            long value = ((longValue & mask)  >> shift);
+        for (int i = 0; i < length; i++) {
+            int adjustedI = bigEndian ? i : length - i - 1;
+            long mask = 0xffl << (length - adjustedI - 1) * 8;
+            long shift = (length - adjustedI - 1) * 8;
+            long value = ((longValue & mask) >> shift);
             array[i] = (byte) value;
         }
         return array;
     }
+
     private int calculateLayoutSize() {
         int lastEndOffset = 0;
         if (mIdentifierEndOffsets != null) {
@@ -826,13 +895,13 @@ private int calculateLayoutSize() {
                 }
             }
         }
-        if (mPowerEndOffset != null && mPowerEndOffset > lastEndOffset ) {
+        if (mPowerEndOffset != null && mPowerEndOffset > lastEndOffset) {
             lastEndOffset = mPowerEndOffset;
         }
         if (mServiceUuidEndOffset != null && mServiceUuidEndOffset > lastEndOffset) {
             lastEndOffset = mServiceUuidEndOffset;
         }
-        return lastEndOffset+1;
+        return lastEndOffset + 1;
     }
 
     private boolean byteArraysMatch(byte[] source, int offset, byte[] expected) {
@@ -840,7 +909,7 @@ private boolean byteArraysMatch(byte[] source, int offset, byte[] expected) {
         if (source.length - offset < length) {
             return false;
         }
-        for (int i = 0; i <  length; i++) {
+        for (int i = 0; i < length; i++) {
             if (source[offset + i] != expected[i]) {
                 return false;
             }
@@ -858,27 +927,26 @@ private String byteArrayToString(byte[] bytes) {
     }
 
     private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int endIndex, boolean littleEndian) {
-        byte[] bytes = new byte[endIndex-startIndex+1];
+        byte[] bytes = new byte[endIndex - startIndex + 1];
         if (littleEndian) {
-            for (int i = 0; i <= endIndex-startIndex; i++) {
-                bytes[i] = byteBuffer[startIndex+bytes.length-1-i];
+            for (int i = 0; i <= endIndex - startIndex; i++) {
+                bytes[i] = byteBuffer[startIndex + bytes.length - 1 - i];
             }
-        }
-        else {
-            for (int i = 0; i <= endIndex-startIndex; i++) {
-                bytes[i] = byteBuffer[startIndex+i];
+        } else {
+            for (int i = 0; i <= endIndex - startIndex; i++) {
+                bytes[i] = byteBuffer[startIndex + i];
             }
         }
 
 
-        int length = endIndex-startIndex +1;
+        int length = endIndex - startIndex + 1;
         // We treat a 1-4 byte number as decimal string
         if (length < 5) {
             long number = 0l;
-            for (int i = 0; i < bytes.length; i++)  {
-                long byteValue = (long) (bytes[bytes.length - i-1] & 0xff);
-                long positionValue = (long) Math.pow(256.0,i*1.0);
-                long calculatedValue =  (byteValue * positionValue);
+            for (int i = 0; i < bytes.length; i++) {
+                long byteValue = (long) (bytes[bytes.length - i - 1] & 0xff);
+                long positionValue = (long) Math.pow(256.0, i * 1.0);
+                long calculatedValue = (byteValue * positionValue);
                 number += calculatedValue;
             }
             return Long.toString(number);
@@ -890,18 +958,18 @@ private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int
         // And if it is a 12 byte number we add dashes to it to make it look like a standard UUID
         if (bytes.length == 16) {
             StringBuilder sb = new StringBuilder();
-            sb.append(hexString.substring(0,8));
+            sb.append(hexString.substring(0, 8));
             sb.append("-");
-            sb.append(hexString.substring(8,12));
+            sb.append(hexString.substring(8, 12));
             sb.append("-");
-            sb.append(hexString.substring(12,16));
+            sb.append(hexString.substring(12, 16));
             sb.append("-");
-            sb.append(hexString.substring(16,20));
+            sb.append(hexString.substring(16, 20));
             sb.append("-");
-            sb.append(hexString.substring(20,32));
+            sb.append(hexString.substring(20, 32));
             return sb.toString();
         }
-        return "0x"+hexString;
+        return "0x" + hexString;
     }
 
     @TargetApi(Build.VERSION_CODES.GINGERBREAD)
@@ -914,30 +982,30 @@ private String byteArrayToFormattedString(byte[] byteBuffer, int startIndex, int
 
     @Override
     public int hashCode() {
-        return Arrays.hashCode(new Object[] {
-                mMatchingBeaconTypeCode,
-                mIdentifierStartOffsets,
-                mIdentifierEndOffsets,
-                mIdentifierLittleEndianFlags,
-                mDataStartOffsets,
-                mDataEndOffsets,
-                mDataLittleEndianFlags,
-                mIdentifierVariableLengthFlags,
-                mMatchingBeaconTypeCodeStartOffset,
-                mMatchingBeaconTypeCodeEndOffset,
-                mServiceUuidStartOffset,
-                mServiceUuidEndOffset,
-                mServiceUuid,
-                mExtraFrame,
-                mPowerStartOffset,
-                mPowerEndOffset,
-                mDBmCorrection,
-                mLayoutSize,
-                mAllowPduOverflow,
-                mIdentifier,
-                mHardwareAssistManufacturers,
-                extraParsers
-            }
+        return Arrays.hashCode(new Object[]{
+                        mMatchingBeaconTypeCode,
+                        mIdentifierStartOffsets,
+                        mIdentifierEndOffsets,
+                        mIdentifierLittleEndianFlags,
+                        mDataStartOffsets,
+                        mDataEndOffsets,
+                        mDataLittleEndianFlags,
+                        mIdentifierVariableLengthFlags,
+                        mMatchingBeaconTypeCodeStartOffset,
+                        mMatchingBeaconTypeCodeEndOffset,
+                        mServiceUuidStartOffset,
+                        mServiceUuidEndOffset,
+                        mServiceUuid,
+                        mExtraFrame,
+                        mPowerStartOffset,
+                        mPowerEndOffset,
+                        mDBmCorrection,
+                        mLayoutSize,
+                        mAllowPduOverflow,
+                        mIdentifier,
+                        mHardwareAssistManufacturers,
+                        extraParsers
+                }
         );
     }
 
@@ -951,8 +1019,8 @@ public boolean equals(Object o) {
                     return true;
                 }
             }
+        } catch (ClassCastException e) {
         }
-        catch (ClassCastException e ) { }
         return false;
     }
 
diff --git a/lib/src/main/java/org/altbeacon/beacon/CRC8.java b/lib/src/main/java/org/altbeacon/beacon/CRC8.java
new file mode 100644
index 00000000..2ce9199e
--- /dev/null
+++ b/lib/src/main/java/org/altbeacon/beacon/CRC8.java
@@ -0,0 +1,58 @@
+package org.altbeacon.beacon;
+
+class CRC8 {
+    private static byte[] dscrc_table = new byte[256];
+
+    private CRC8() {
+    }
+
+    public static int compute(int dataToCRC, int seed) {
+        return dscrc_table[(seed ^ dataToCRC) & 255] & 255;
+    }
+
+    public static int compute(int dataToCRC) {
+        return dscrc_table[dataToCRC & 255] & 255;
+    }
+
+    public static int compute(byte[] dataToCrc) {
+        return compute(dataToCrc, 0, dataToCrc.length);
+    }
+
+    public static int compute(byte[] dataToCrc, int off, int len) {
+        return compute(dataToCrc, off, len, 0);
+    }
+
+    public static int compute(byte[] dataToCrc, int off, int len, int seed) {
+        int CRC8 = seed;
+
+        for(int i = 0; i < len; ++i) {
+            CRC8 = dscrc_table[(CRC8 ^ dataToCrc[i + off]) & 255];
+        }
+
+        return CRC8 & 255;
+    }
+
+    public static int compute(byte[] dataToCrc, int seed) {
+        return compute(dataToCrc, 0, dataToCrc.length, seed);
+    }
+
+    static {
+        for(int i = 0; i < 256; ++i) {
+            int acc = i;
+            int crc = 0;
+
+            for(int j = 0; j < 8; ++j) {
+                if (((acc ^ crc) & 1) == 1) {
+                    crc = (crc ^ 24) >> 1 | 128;
+                } else {
+                    crc >>= 1;
+                }
+
+                acc >>= 1;
+            }
+
+            dscrc_table[i] = (byte)crc;
+        }
+
+    }
+}
diff --git a/lib/src/main/java/org/altbeacon/beacon/E781.java b/lib/src/main/java/org/altbeacon/beacon/E781.java
new file mode 100644
index 00000000..8fd0ceae
--- /dev/null
+++ b/lib/src/main/java/org/altbeacon/beacon/E781.java
@@ -0,0 +1,438 @@
+package org.altbeacon.beacon;
+
+import android.bluetooth.BluetoothDevice;
+import android.os.ParcelUuid;
+import com.android.scanner.BLEFilter;
+import com.android.scanner.ScanBLEResult;
+import com.sensoro.beacon.kit.Beacon.MovingState;
+import android.os.ParcelUuid;
+import com.android.scanner.BLEFilter;
+import com.android.scanner.ScanBLEResult;
+import com.sensoro.beacon.kit.Beacon.MovingState;
+import com.sensoro.beacon.kit.constants.AdvertisingInterval;
+import com.sensoro.beacon.kit.constants.EnergySavingMode;
+import com.sensoro.beacon.kit.constants.TransmitPower;
+import java.util.HashMap;
+import java.util.Map;
+
+class E781 extends SensoroUUID {
+    private static final int MODE_1 = 16;
+    private static final int MODE_2 = 32;
+    private static final int MODE_3 = 48;
+    private static final int MODE_4 = 64;
+    private static final int MODE_41 = 65;
+    private static final int MODE_42 = 66;
+    private static final int MODE_5 = 80;
+    private static final int RANDOM_CODE_LENGTH = 2;
+    private static final int KEY_LENGTH = 14;
+    private static final int KEY_ID_LENGTH = 2;
+    private static final int DATA_START_INDEX = 0;
+    private static final int DECRYPT_DATA_START_INDEX = 0;
+    private static final String KEY_MAJOR = "major";
+    private static final String KEY_MINOR = "minor";
+    private static final String KEY_TEMPERATURE = "temperature";
+    private static final String KEY_LIGNT = "light";
+    private static final String KEY_ACCELEROMETERCOUNT = "accelerometerCount";
+    private static final String KEY_MOVINGSTATE = "movingState";
+    private static final String KEY_MEASUREPOWER = "measuredPower";
+    private static HashMap<String, Integer> majorMap = new HashMap();
+    private static HashMap<String, Integer> minorMap = new HashMap();
+    private static HashMap<String, Integer> temperatureMap = new HashMap();
+    private static HashMap<String, Double> lightMap = new HashMap();
+    private static HashMap<String, Integer> accelerometerCountMap = new HashMap();
+    private static HashMap<String, Integer> measuredPowerMap = new HashMap();
+    String sn;
+    String hardwareVersion;
+    String firmwareVersion;
+    int batteryLevel;
+    TransmitPower transmitPower;
+    AdvertisingInterval advertisingInterval;
+    EnergySavingMode energySavingMode;
+    boolean isPasswordEnabled;
+    boolean isSecretEnabled;
+    boolean isEnergySavingEnabled;
+    boolean isAliBeaconEnabled;
+    boolean isBackgroundEnhancementEnabled;
+    boolean isEddystoneEnabled;
+    boolean isEddystoneEIDEnable;
+    boolean isEddystoneOnly;
+    Integer major;
+    Integer minor;
+    int measuredPower;
+    Integer temperature;
+    Double light;
+    int accelerometerCount;
+    MovingState movingState;
+
+    E781() {
+        this.movingState = MovingState.UNKNOWN;
+    }
+
+    static E781 createE781(ScanBLEResult scanBLEResult, HashMap<String, byte[]> broadcastKeyMap) {
+        Map<ParcelUuid, byte[]> serviceData = scanBLEResult.getScanRecord().getServiceData();
+        if (serviceData == null) {
+            return null;
+        } else {
+            ParcelUuid parcelUuid = BLEFilter.createServiceDataUUID("81E7");
+            byte[] e781Bytes = scanBLEResult.getScanRecord().getServiceData(parcelUuid);
+            return e781Bytes != null ? parseE781(e781Bytes, broadcastKeyMap) : null;
+        }
+    }
+
+    private static E781 parseE781(byte[] e781Bytes, HashMap<String, byte[]> broadcastKeyMap) {
+        E781 e781 = new E781();
+        int hardwareCode = e781Bytes[0] & 255;
+        e781.hardwareVersion = Integer.toHexString(hardwareCode).toUpperCase();
+        int firmwareCode = e781Bytes[1] & 255;
+        e781.firmwareVersion = Integer.toHexString(firmwareCode / 16).toUpperCase() + "." + Integer.toHexString(firmwareCode % 16).toUpperCase();
+        if (!VersionUtils.isSupportedFiremware(firmwareCode)) {
+            return null;
+        } else if (!VersionUtils.isSupportedHardware(hardwareCode)) {
+            return null;
+        } else {
+            boolean parseResult = false;
+            switch(e781Bytes[2] & 112) {
+                case 16:
+                    parseResult = parseMode1(e781, e781Bytes, broadcastKeyMap);
+                    break;
+                case 32:
+                    parseResult = parseMode2(e781, e781Bytes, broadcastKeyMap);
+                    break;
+                case 48:
+                    parseResult = parseMode3(e781, e781Bytes, broadcastKeyMap);
+                    break;
+                case 64:
+                    parseResult = parseMode4(e781, e781Bytes, broadcastKeyMap);
+                    break;
+                case 80:
+                    parseResult = parseMode5(e781, e781Bytes);
+                    break;
+                default:
+                    return null;
+            }
+
+            return parseResult ? e781 : null;
+        }
+    }
+
+    private static boolean isTheLastestVersion(int hardwareCode, int firmwareCode) {
+        return hardwareCode <= 193 && firmwareCode <= 65;
+    }
+
+    private static boolean parseMode1(E781 e781, byte[] e781Bytes, HashMap<String, byte[]> broadcastKeyMap) {
+        byte[] sn;
+        if ((e781Bytes[3] & 255) == 0 && (e781Bytes[4] & 255) == 0) {
+            if (e781Bytes.length < 21) {
+                return false;
+            } else {
+                sn = new byte[3];
+                System.arraycopy(e781Bytes, 7, sn, 0, sn.length);
+                e781.sn = parseSN(sn);
+                e781.major = ((e781Bytes[13] & 255) << 8) + (e781Bytes[14] & 255);
+                e781.minor = ((e781Bytes[15] & 255) << 8) + (e781Bytes[16] & 255);
+                e781.batteryLevel = e781Bytes[17] & 255;
+                E781.BitFields bitFields = parseBitFields(e781Bytes[18], e781Bytes[19]);
+                e781.transmitPower = TransmitPower.getTransmitPower(bitFields.transmitPower);
+                e781.advertisingInterval = AdvertisingInterval.getAdvertisingInterval(bitFields.advertisingInterval);
+                e781.isPasswordEnabled = bitFields.isPasswordEnabled;
+                e781.isSecretEnabled = bitFields.isSecretEnabled;
+                e781.isEnergySavingEnabled = bitFields.isEnergySavingEnabled;
+                e781.isAliBeaconEnabled = bitFields.isAliBeaconEnabled;
+                e781.isBackgroundEnhancementEnabled = bitFields.isBackgroundEnhancementEnabled;
+                e781.isEddystoneEnabled = bitFields.isEddystoneEnabled;
+                e781.energySavingMode = getEnergySavingMode(e781.isEnergySavingEnabled);
+                e781.movingState = MovingState.DISABLED;
+                e781.accelerometerCount = 0;
+                e781.measuredPower = e781Bytes[20];
+                return true;
+            }
+        } else {
+            sn = new byte[2];
+            System.arraycopy(e781Bytes, 3, sn, 0, sn.length);
+            byte[] keyBytes = parseBroadcastKey(sn, broadcastKeyMap);
+            if (keyBytes != null && keyBytes.length == 14) {
+                byte[] encrypt = new byte[16];
+                System.arraycopy(e781Bytes, 7, encrypt, 0, encrypt.length);
+                byte[] key = new byte[16];
+                System.arraycopy(keyBytes, 0, key, 0, keyBytes.length);
+                System.arraycopy(e781Bytes, 5, key, 14, 2);
+                byte[] decrypt = SensoroUtils.decrypt_AES_128(encrypt, key);
+                byte[] snT = new byte[3];
+                System.arraycopy(decrypt, 0, sn, 0, sn.length);
+                e781.sn = parseSN(snT);
+                e781.major = ((decrypt[6] & 255) << 8) + (decrypt[7] & 255);
+                e781.minor = ((decrypt[8] & 255) << 8) + (decrypt[9] & 255);
+                e781.batteryLevel = decrypt[10] & 255;
+                E781.BitFields bitFields = parseBitFields(decrypt[11], decrypt[12]);
+                e781.transmitPower = TransmitPower.getTransmitPower(bitFields.transmitPower);
+                e781.advertisingInterval = AdvertisingInterval.getAdvertisingInterval(bitFields.advertisingInterval);
+                e781.isPasswordEnabled = bitFields.isPasswordEnabled;
+                e781.isSecretEnabled = bitFields.isSecretEnabled;
+                e781.isEnergySavingEnabled = bitFields.isEnergySavingEnabled;
+                e781.isAliBeaconEnabled = bitFields.isAliBeaconEnabled;
+                e781.isBackgroundEnhancementEnabled = bitFields.isBackgroundEnhancementEnabled;
+                e781.isEddystoneEnabled = bitFields.isEddystoneEnabled;
+                e781.energySavingMode = getEnergySavingMode(e781.isEnergySavingEnabled);
+                e781.movingState = MovingState.DISABLED;
+                e781.accelerometerCount = 0;
+                e781.measuredPower = decrypt[13];
+                int crc8 = CRC8.compute(sn);
+                return (decrypt[15] & 255) == crc8;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    private static boolean parseMode2(E781 e781, byte[] e781Bytes, HashMap<String, byte[]> broadcastKeyMap) {
+        byte[] keyIdBytes;
+        if ((e781Bytes[3] & 255) == 0 && (e781Bytes[4] & 255) == 0) {
+            keyIdBytes = new byte[3];
+            System.arraycopy(e781Bytes, 7, keyIdBytes, 0, keyIdBytes.length);
+            e781.sn = parseSN(keyIdBytes);
+            e781.batteryLevel = e781Bytes[10] & 255;
+            E781.BitFields bitFields = parseBitFields(e781Bytes[11], e781Bytes[12]);
+            e781.transmitPower = TransmitPower.getTransmitPower(bitFields.transmitPower);
+            e781.advertisingInterval = AdvertisingInterval.getAdvertisingInterval(bitFields.advertisingInterval);
+            e781.isPasswordEnabled = bitFields.isPasswordEnabled;
+            e781.isSecretEnabled = bitFields.isSecretEnabled;
+            e781.isEnergySavingEnabled = bitFields.isEnergySavingEnabled;
+            e781.isAliBeaconEnabled = bitFields.isAliBeaconEnabled;
+            e781.isBackgroundEnhancementEnabled = bitFields.isBackgroundEnhancementEnabled;
+            e781.isEddystoneEnabled = bitFields.isEddystoneEnabled;
+            e781.energySavingMode = getEnergySavingMode(e781.isEnergySavingEnabled);
+            e781.temperature = parseTemperature(e781Bytes[13]);
+            e781.light = parseBrightnessLux(e781Bytes[14], e781Bytes[15]);
+            e781.accelerometerCount = (e781Bytes[16] & 255) + ((e781Bytes[17] & 255) << 8);
+            e781.measuredPower = e781Bytes[19];
+            return true;
+        } else {
+            keyIdBytes = new byte[2];
+            System.arraycopy(e781Bytes, 3, keyIdBytes, 0, keyIdBytes.length);
+            byte[] keyBytes = parseBroadcastKey(keyIdBytes, broadcastKeyMap);
+            if (keyBytes != null && keyBytes.length == 14) {
+                byte[] encrypt = new byte[16];
+                System.arraycopy(e781Bytes, 7, encrypt, 0, encrypt.length);
+                byte[] key = new byte[16];
+                System.arraycopy(keyBytes, 0, key, 0, keyBytes.length);
+                System.arraycopy(e781Bytes, 5, key, 14, 2);
+                byte[] decrypt = SensoroUtils.decrypt_AES_128(encrypt, key);
+                byte[] sn = new byte[3];
+                System.arraycopy(decrypt, 0, sn, 0, sn.length);
+                e781.sn = parseSN(sn);
+                e781.batteryLevel = decrypt[3] & 255;
+                E781.BitFields bitFields = parseBitFields(decrypt[4], decrypt[5]);
+                e781.transmitPower = TransmitPower.getTransmitPower(bitFields.transmitPower);
+                e781.advertisingInterval = AdvertisingInterval.getAdvertisingInterval(bitFields.advertisingInterval);
+                e781.isPasswordEnabled = bitFields.isPasswordEnabled;
+                e781.isSecretEnabled = bitFields.isSecretEnabled;
+                e781.isEnergySavingEnabled = bitFields.isEnergySavingEnabled;
+                e781.isAliBeaconEnabled = bitFields.isAliBeaconEnabled;
+                e781.isBackgroundEnhancementEnabled = bitFields.isBackgroundEnhancementEnabled;
+                e781.isEddystoneEnabled = bitFields.isEddystoneEnabled;
+                e781.energySavingMode = getEnergySavingMode(e781.isEnergySavingEnabled);
+                e781.temperature = parseTemperature(decrypt[6]);
+                e781.light = parseBrightnessLux(decrypt[7], decrypt[8]);
+                e781.accelerometerCount = (decrypt[9] & 255) + ((decrypt[10] & 255) << 8);
+                e781.measuredPower = decrypt[12];
+                int crc8 = CRC8.compute(sn);
+                return (decrypt[15] & 255) == crc8;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    private static boolean parseMode3(E781 e781, byte[] e781Bytes, HashMap<String, byte[]> broadcastKeyMap) {
+        if (e781Bytes.length < 23) {
+            return false;
+        } else {
+            byte[] sn = new byte[3];
+            System.arraycopy(e781Bytes, 3, sn, 0, sn.length);
+            e781.sn = parseSN(sn);
+            e781.major = ((e781Bytes[9] & 255) << 8) + (e781Bytes[10] & 255);
+            e781.minor = ((e781Bytes[11] & 255) << 8) + (e781Bytes[12] & 255);
+            e781.batteryLevel = e781Bytes[13] & 255;
+            E781.BitFields bitFields = parseBitFields(e781Bytes[14], e781Bytes[15]);
+            e781.transmitPower = TransmitPower.getTransmitPower(bitFields.transmitPower);
+            e781.advertisingInterval = AdvertisingInterval.getAdvertisingInterval(bitFields.advertisingInterval);
+            e781.isPasswordEnabled = bitFields.isPasswordEnabled;
+            e781.isSecretEnabled = bitFields.isSecretEnabled;
+            e781.isEnergySavingEnabled = bitFields.isEnergySavingEnabled;
+            e781.isAliBeaconEnabled = bitFields.isAliBeaconEnabled;
+            e781.isBackgroundEnhancementEnabled = bitFields.isBackgroundEnhancementEnabled;
+            e781.isEddystoneEnabled = bitFields.isEddystoneEnabled;
+            e781.energySavingMode = getEnergySavingMode(e781.isEnergySavingEnabled);
+            e781.temperature = parseTemperature(e781Bytes[16]);
+            e781.light = parseBrightnessLux(e781Bytes[17], e781Bytes[18]);
+            e781.accelerometerCount = (e781Bytes[19] & 255) + ((e781Bytes[20] & 255) << 8);
+            e781.measuredPower = e781Bytes[22];
+            return true;
+        }
+    }
+
+    private static boolean parseMode4(E781 e781, byte[] e781Bytes, HashMap<String, byte[]> broadcastKeyMap) {
+        if ((e781Bytes[2] & 255) == 65) {
+            return parseMode41(e781, e781Bytes, broadcastKeyMap);
+        } else {
+            return (e781Bytes[2] & 255) == 66 ? parseMode42(e781, e781Bytes, broadcastKeyMap) : false;
+        }
+    }
+
+    private static boolean parseMode5(E781 e781, byte[] e781Bytes) {
+        e781.isEddystoneOnly = true;
+        byte[] sn = new byte[3];
+        System.arraycopy(e781Bytes, 3, sn, 0, sn.length);
+        e781.sn = parseSN(sn);
+        e781.batteryLevel = 255;
+        return true;
+    }
+
+    private static boolean parseMode41(E781 e781, byte[] e781Bytes, HashMap<String, byte[]> broadcastKeyMap) {
+        if ((e781Bytes[3] & 255) == 0 && (e781Bytes[4] & 255) == 0) {
+            return false;
+        } else {
+            byte[] keyIdBytes = new byte[2];
+            System.arraycopy(e781Bytes, 3, keyIdBytes, 0, keyIdBytes.length);
+            byte[] keyBytes = parseBroadcastKey(keyIdBytes, broadcastKeyMap);
+            if (keyBytes != null && keyBytes.length == 14) {
+                byte[] encrypt = new byte[16];
+                System.arraycopy(e781Bytes, 7, encrypt, 0, encrypt.length);
+                byte[] key = new byte[16];
+                System.arraycopy(keyBytes, 0, key, 0, keyBytes.length);
+                System.arraycopy(e781Bytes, 5, key, 14, 2);
+                byte[] decrypt = SensoroUtils.decrypt_AES_128(encrypt, key);
+                byte[] sn = new byte[3];
+                System.arraycopy(decrypt, 0, sn, 0, sn.length);
+                e781.sn = parseSN(sn);
+                e781.major = ((decrypt[6] & 255) << 8) + (decrypt[7] & 255);
+                e781.minor = ((decrypt[8] & 255) << 8) + (decrypt[9] & 255);
+                e781.batteryLevel = decrypt[10] & 255;
+                E781.BitFields bitFields = parseBitFields(decrypt[11], decrypt[12]);
+                e781.transmitPower = TransmitPower.getTransmitPower(bitFields.transmitPower);
+                e781.advertisingInterval = AdvertisingInterval.getAdvertisingInterval(bitFields.advertisingInterval);
+                e781.isPasswordEnabled = bitFields.isPasswordEnabled;
+                e781.isSecretEnabled = bitFields.isSecretEnabled;
+                e781.isEnergySavingEnabled = bitFields.isEnergySavingEnabled;
+                e781.isAliBeaconEnabled = bitFields.isAliBeaconEnabled;
+                e781.isBackgroundEnhancementEnabled = bitFields.isBackgroundEnhancementEnabled;
+                e781.isEddystoneEnabled = bitFields.isEddystoneEnabled;
+                e781.energySavingMode = getEnergySavingMode(e781.isEnergySavingEnabled);
+                e781.temperature = (Integer)temperatureMap.get("temperature");
+                e781.light = (Double)lightMap.get("light");
+                if (accelerometerCountMap.get("accelerometerCount") != null) {
+                    e781.accelerometerCount = (Integer)accelerometerCountMap.get("accelerometerCount");
+                }
+
+                if (measuredPowerMap.get("measuredPower") != null) {
+                    e781.measuredPower = (Integer)measuredPowerMap.get("measuredPower");
+                }
+
+                majorMap.put("major", e781.major);
+                minorMap.put("minor", e781.minor);
+                int crc8 = CRC8.compute(sn);
+                return (decrypt[15] & 255) == crc8;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    private static boolean parseMode42(E781 e781, byte[] e781Bytes, HashMap<String, byte[]> broadcastKeyMap) {
+        if ((e781Bytes[3] & 255) == 0 && (e781Bytes[4] & 255) == 0) {
+            return false;
+        } else {
+            byte[] keyIdBytes = new byte[2];
+            System.arraycopy(e781Bytes, 3, keyIdBytes, 0, keyIdBytes.length);
+            byte[] keyBytes = parseBroadcastKey(keyIdBytes, broadcastKeyMap);
+            if (keyBytes != null && keyBytes.length == 14) {
+                byte[] encrypt = new byte[16];
+                System.arraycopy(e781Bytes, 7, encrypt, 0, encrypt.length);
+                byte[] key = new byte[16];
+                System.arraycopy(keyBytes, 0, key, 0, keyBytes.length);
+                System.arraycopy(e781Bytes, 5, key, 14, 2);
+                byte[] decrypt = SensoroUtils.decrypt_AES_128(encrypt, key);
+                byte[] sn = new byte[3];
+                System.arraycopy(decrypt, 0, sn, 0, sn.length);
+                e781.sn = parseSN(sn);
+                e781.batteryLevel = decrypt[3] & 255;
+                E781.BitFields bitFields = parseBitFields(decrypt[4], decrypt[5]);
+                e781.transmitPower = TransmitPower.getTransmitPower(bitFields.transmitPower);
+                e781.advertisingInterval = AdvertisingInterval.getAdvertisingInterval(bitFields.advertisingInterval);
+                e781.isPasswordEnabled = bitFields.isPasswordEnabled;
+                e781.isSecretEnabled = bitFields.isSecretEnabled;
+                e781.isEnergySavingEnabled = bitFields.isEnergySavingEnabled;
+                e781.isAliBeaconEnabled = bitFields.isAliBeaconEnabled;
+                e781.isBackgroundEnhancementEnabled = bitFields.isBackgroundEnhancementEnabled;
+                e781.isEddystoneEnabled = bitFields.isEddystoneEnabled;
+                e781.energySavingMode = getEnergySavingMode(e781.isEnergySavingEnabled);
+                e781.temperature = parseTemperature(decrypt[6]);
+                e781.light = parseBrightnessLux(decrypt[7], decrypt[8]);
+                e781.accelerometerCount = (decrypt[9] & 255) + ((decrypt[10] & 255) << 8);
+                e781.measuredPower = decrypt[12];
+                temperatureMap.put("temperature", e781.temperature);
+                lightMap.put("light", e781.light);
+                accelerometerCountMap.put("accelerometerCount", e781.accelerometerCount);
+                measuredPowerMap.put("measuredPower", e781.measuredPower);
+                if (majorMap.get("major") != null) {
+                    e781.major = (Integer)majorMap.get("major");
+                }
+
+                if (minorMap.get("minor") != null) {
+                    e781.minor = (Integer)minorMap.get("minor");
+                }
+
+                int crc8 = CRC8.compute(sn);
+                return (decrypt[15] & 255) == crc8;
+            } else {
+                return false;
+            }
+        }
+    }
+
+    private static E781.BitFields parseBitFields(byte bitFieldsByteHigh, byte bitFieldsByteLow) {
+        E781.BitFields bitFields = new E781.BitFields();
+        bitFields.transmitPower = (bitFieldsByteHigh & 240) >> 4;
+        bitFields.advertisingInterval = bitFieldsByteHigh & 15;
+        bitFields.isPasswordEnabled = (bitFieldsByteLow & 128) != 0;
+        bitFields.isSecretEnabled = (bitFieldsByteLow & 64) != 0;
+        bitFields.isEnergySavingEnabled = (bitFieldsByteLow & 32) != 0;
+        bitFields.isAliBeaconEnabled = (bitFieldsByteLow & 16) != 0;
+        bitFields.isBackgroundEnhancementEnabled = (bitFieldsByteLow & 8) != 0;
+        bitFields.isEddystoneEnabled = (bitFieldsByteLow & 4) != 0;
+        return bitFields;
+    }
+
+    private static EnergySavingMode getEnergySavingMode(boolean isEnergySavingEnabled) {
+        return isEnergySavingEnabled ? EnergySavingMode.LIGHT_SENSOR : EnergySavingMode.DISABLED;
+    }
+
+    private static byte[] parseBroadcastKey(byte[] keyIdBytes, HashMap<String, byte[]> broadcastKeyMap) {
+        byte[] keyBytes = null;
+        if (keyIdBytes.length != 2) {
+            return null;
+        } else {
+            String keyId = SensoroUtils.bytesToHex(keyIdBytes);
+            if (keyId != null && broadcastKeyMap != null) {
+                keyBytes = (byte[])broadcastKeyMap.get(keyId.toLowerCase());
+            }
+
+            return keyBytes;
+        }
+    }
+
+    static class BitFields {
+        int transmitPower;
+        int advertisingInterval;
+        boolean isPasswordEnabled;
+        boolean isSecretEnabled;
+        boolean isEnergySavingEnabled;
+        boolean isAliBeaconEnabled;
+        boolean isBackgroundEnhancementEnabled;
+        boolean isEddystoneEnabled;
+
+        BitFields() {
+        }
+    }
+}
+
diff --git a/lib/src/main/java/org/altbeacon/beacon/SensoroUUID.java b/lib/src/main/java/org/altbeacon/beacon/SensoroUUID.java
new file mode 100644
index 00000000..30a2d9d9
--- /dev/null
+++ b/lib/src/main/java/org/altbeacon/beacon/SensoroUUID.java
@@ -0,0 +1,74 @@
+package org.altbeacon.beacon;
+
+import com.sensoro.beacon.kit.Beacon;
+import com.sensoro.beacon.kit.SensoroUtils;
+
+import java.math.BigDecimal;
+
+public class SensoroUUID {
+    public SensoroUUID() {
+    }
+
+    static String parseSN(byte[] sn) {
+        String serialNumber = null;
+        if (sn.length == 3) {
+            serialNumber = "0117C5" + SensoroUtils.bytesToHex(sn);
+        } else if (sn.length == 6) {
+            serialNumber = SensoroUtils.bytesToHex(sn);
+        }
+
+        return serialNumber != null ? serialNumber.toUpperCase() : null;
+    }
+
+    static Integer parseTemperature(byte temperatureByte) {
+        return temperatureByte == 255 ? null : temperatureByte - 10;
+    }
+
+    static Double parseBrightnessLux(byte luxHighByte, byte luxLowByte) {
+        int luxRawHigh = luxHighByte & 255;
+        int luxRawLow = luxLowByte & 255;
+        return luxRawHigh == 255 ? null : calculateLux(luxRawHigh, luxRawLow);
+    }
+
+    private static double calculateLux(int luxRawHigh, int luxRawLow) {
+        double light = Math.pow(2.0D, (double)(luxRawHigh / 16)) * (double)(luxRawHigh % 16 * 16 + luxRawLow % 16) * 0.045D;
+        BigDecimal bigDecimal = (new BigDecimal(Double.toString(light))).setScale(3, 4);
+        return bigDecimal.doubleValue();
+    }
+
+    public static int byteArrayToInt(byte[] b) {
+        byte[] a = new byte[4];
+        int i = a.length - 1;
+
+        for(int j = b.length - 1; i >= 0; --j) {
+            if (j >= 0) {
+                a[i] = b[j];
+            } else {
+                a[i] = 0;
+            }
+
+            --i;
+        }
+
+        int v0 = (a[0] & 255) << 24;
+        int v1 = (a[1] & 255) << 16;
+        int v2 = (a[2] & 255) << 8;
+        int v3 = a[3] & 255;
+        return v0 + v1 + v2 + v3;
+    }
+
+    public static byte[] intToByteArray(int source, int length) {
+        byte[] data = new byte[length];
+
+        for(int i = 0; i < 4 && i < length; ++i) {
+            data[i] = (byte)(source >> 8 * i & 255);
+        }
+
+        return data;
+    }
+
+    public static int byteArrayToInt(byte[] src, int offset) {
+        int value = src[offset] & 255 | (src[offset + 1] & 255) << 8;
+        return value;
+    }
+}
diff --git a/lib/src/main/java/org/altbeacon/beacon/SensoroUtils.java b/lib/src/main/java/org/altbeacon/beacon/SensoroUtils.java
new file mode 100644
index 00000000..076c80d5
--- /dev/null
+++ b/lib/src/main/java/org/altbeacon/beacon/SensoroUtils.java
@@ -0,0 +1,372 @@
+package org.altbeacon.beacon;
+
+import android.util.Base64;
+import android.util.Log;
+import android.util.SparseArray;
+import android.webkit.URLUtil;
+import com.sensoro.beacon.kit.Beacon.Proximity;
+import com.sensoro.beacon.kit.constants.SecureBroadcastInterval;
+import java.io.UnsupportedEncodingException;
+import java.math.BigDecimal;
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.util.ArrayList;
+import java.util.Arrays;
+import javax.crypto.Cipher;
+import javax.crypto.KeyGenerator;
+import javax.crypto.Mac;
+import javax.crypto.SecretKey;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+public class SensoroUtils {
+    private static final char[] HEX_CHAR_TABLE = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+    private static final SparseArray<String> URI_SCHEMES = new SparseArray<String>() {
+        {
+            this.put(0, "http://www.");
+            this.put(1, "https://www.");
+            this.put(2, "http://");
+            this.put(3, "https://");
+            this.put(4, "urn:uuid:");
+        }
+    };
+    private static final SparseArray<String> URL_CODES = new SparseArray<String>() {
+        {
+            this.put(0, ".com/");
+            this.put(1, ".org/");
+            this.put(2, ".edu/");
+            this.put(3, ".net/");
+            this.put(4, ".info/");
+            this.put(5, ".biz/");
+            this.put(6, ".gov/");
+            this.put(7, ".com");
+            this.put(8, ".org");
+            this.put(9, ".edu");
+            this.put(10, ".net");
+            this.put(11, ".info");
+            this.put(12, ".biz");
+            this.put(13, ".gov");
+        }
+    };
+    private static final int FIVE_SECONDS = 5;
+    private static final int ONE_MINUTE = 60;
+    private static final int ONE_HOUR = 3600;
+    private static final int ONE_DAY = 86400;
+    private static final int SEVEN_DAYS = 604800;
+    private static final int THIRTY_DAYS = 2592000;
+
+    public SensoroUtils() {
+    }
+
+    public static int getSecureBroadcastIntervalInt(SecureBroadcastInterval secureBroadcastInterval) {
+        switch(secureBroadcastInterval) {
+            case UNKNOWN:
+                return 0;
+            case DISABLED:
+                return 0;
+            case SECURE_BROADCAST_INTERVAL_5_SECONDS:
+                return 5;
+            case SECURE_BROADCAST_INTERVAL_1_MINTE:
+                return 60;
+            case SECURE_BROADCAST_INTERVAL_1_HONR:
+                return 3600;
+            case SECURE_BROADCAST_INTERVAL_1_DAY:
+                return 86400;
+            case SECURE_BROADCAST_INTERVAL_7_DAYS:
+                return 604800;
+            case SECURE_BROADCAST_INTERVAL_30_DAYS:
+                return 2592000;
+            default:
+                return 0;
+        }
+    }
+
+    public static SecureBroadcastInterval getSecureBroadcastInterval(int secureBroadcastIntervalInt) {
+        switch(secureBroadcastIntervalInt) {
+            case 0:
+                return SecureBroadcastInterval.DISABLED;
+            case 5:
+                return SecureBroadcastInterval.SECURE_BROADCAST_INTERVAL_5_SECONDS;
+            case 60:
+                return SecureBroadcastInterval.SECURE_BROADCAST_INTERVAL_1_MINTE;
+            case 3600:
+                return SecureBroadcastInterval.SECURE_BROADCAST_INTERVAL_1_HONR;
+            case 86400:
+                return SecureBroadcastInterval.SECURE_BROADCAST_INTERVAL_1_DAY;
+            case 604800:
+                return SecureBroadcastInterval.SECURE_BROADCAST_INTERVAL_7_DAYS;
+            case 2592000:
+                return SecureBroadcastInterval.SECURE_BROADCAST_INTERVAL_30_DAYS;
+            default:
+                return SecureBroadcastInterval.UNKNOWN;
+        }
+    }
+
+    public static byte[] convertUUIDToBytes(String uuid) {
+        uuid = uuid.replace("-", "");
+        byte[] uuidBytes = HexString2Bytes(uuid);
+        return uuidBytes;
+    }
+
+    public static ArrayList<byte[]> parseBytes2ByteList(byte[] bytes) {
+        ArrayList<byte[]> byteList = null;
+        if (bytes != null) {
+            byteList = new ArrayList();
+
+            for(int i = 0; i < bytes.length; ++i) {
+                int length = bytes[i] & 255;
+                if (length == 0) {
+                    return byteList;
+                }
+
+                byte[] byteData = new byte[length + 1];
+                System.arraycopy(bytes, i, byteData, 0, length + 1);
+                byteList.add(byteData);
+                i += length;
+            }
+        }
+
+        return byteList;
+    }
+
+    public static byte[] encodeUrl(String url) {
+        int i;
+        for(i = 0; i < URI_SCHEMES.size(); ++i) {
+            if (url.startsWith((String)URI_SCHEMES.get(i))) {
+                url = url.replace((CharSequence)URI_SCHEMES.get(i), String.valueOf((char)((byte)i)));
+            }
+        }
+
+        for(i = 0; i < URL_CODES.size(); ++i) {
+            url = url.replace((CharSequence)URL_CODES.get(i), String.valueOf((char)((byte)i)));
+        }
+
+        byte[] bytes = new byte[url.length()];
+
+        for(int k = 0; k < url.length(); ++k) {
+            bytes[k] = (byte)url.charAt(k);
+        }
+
+        return bytes;
+    }
+
+    public static String decodeUrl(byte[] urlBytes) {
+        StringBuilder url = new StringBuilder();
+        byte offset = 0;
+
+        try {
+            byte var10001 = offset;
+            int offset1 = offset + 1;
+            byte b = urlBytes[var10001];
+            String scheme = (String)URI_SCHEMES.get(b);
+            if (scheme != null) {
+                url.append(scheme);
+                if (URLUtil.isNetworkUrl(scheme)) {
+                    return decodeUrl(urlBytes, offset1, url);
+                }
+            }
+
+            return url.toString();
+        } catch (Exception var5) {
+            return null;
+        }
+    }
+
+    private static String decodeUrl(byte[] serviceData, int offset, StringBuilder urlBuilder) {
+        while(offset < serviceData.length) {
+            byte b = serviceData[offset++];
+            String code = (String)URL_CODES.get(b);
+            if (code != null) {
+                urlBuilder.append(code);
+            } else {
+                urlBuilder.append((char)b);
+            }
+        }
+
+        return urlBuilder.toString();
+    }
+
+    public static byte[] HexString2Bytes(String src) {
+        int length = src.length() / 2;
+        byte[] ret = new byte[length];
+        byte[] tmp = src.getBytes();
+
+        for(int i = 0; i < length; ++i) {
+            ret[i] = uniteBytes(tmp[i * 2], tmp[i * 2 + 1]);
+        }
+
+        return ret;
+    }
+
+    public static byte uniteBytes(byte src0, byte src1) {
+        byte _b0 = Byte.decode("0x" + new String(new byte[]{src0}));
+        _b0 = (byte)(_b0 << 4);
+        byte _b1 = Byte.decode("0x" + new String(new byte[]{src1}));
+        byte ret = (byte)(_b0 ^ _b1);
+        return ret;
+    }
+
+    public static byte[] HMacSHA512(byte[] data, String passwordKey) {
+        byte[] secretBytes = passwordKey.getBytes();
+        byte[] signatureBytes = null;
+
+        try {
+            Mac shaMac = Mac.getInstance("HmacSHA512");
+            SecretKey secretKey = new SecretKeySpec(secretBytes, "HmacSHA512");
+            shaMac.init(secretKey);
+            signatureBytes = shaMac.doFinal(data);
+        } catch (InvalidKeyException var6) {
+            var6.printStackTrace();
+        } catch (NoSuchAlgorithmException var7) {
+            var7.printStackTrace();
+        }
+
+        return signatureBytes;
+    }
+
+    public static String bytesToHex(byte[] bytes) {
+        char[] hexChars = new char[bytes.length * 2];
+
+        for(int j = 0; j < bytes.length; ++j) {
+            int v = bytes[j] & 255;
+            hexChars[j * 2] = HEX_CHAR_TABLE[v >>> 4];
+            hexChars[j * 2 + 1] = HEX_CHAR_TABLE[v & 15];
+        }
+
+        return (new String(hexChars)).toUpperCase();
+    }
+
+    public static int getHexCharValue(char c) {
+        int index = 0;
+        char[] var2 = HEX_CHAR_TABLE;
+        int var3 = var2.length;
+
+        for(int var4 = 0; var4 < var3; ++var4) {
+            char c1 = var2[var4];
+            if (c == c1) {
+                return index;
+            }
+
+            ++index;
+        }
+
+        return 0;
+    }
+
+    public static byte[] decrypt_AES_128(byte[] src, byte[] key) {
+        byte[] original = null;
+        if (key == null) {
+            return null;
+        } else if (key.length != 16) {
+            return null;
+        } else {
+            try {
+                SecretKeySpec skeySpec = new SecretKeySpec(key, "AES");
+                Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");
+                cipher.init(2, skeySpec);
+                original = cipher.doFinal(src);
+                return original;
+            } catch (Exception var5) {
+                return null;
+            }
+        }
+    }
+
+    public static String decrypt_AES_256(String src, String key) {
+        if (key == null) {
+            return null;
+        } else if (src == null) {
+            return null;
+        } else {
+            try {
+                SecretKey secretKey = getKey(key);
+                byte[] iv = new byte[16];
+                Arrays.fill(iv, (byte)0);
+                IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
+                byte[] encrypedPwdBytes = Base64.decode(src, 0);
+                Cipher cipher = Cipher.getInstance("AES/CBC/PKCS7Padding");
+                cipher.init(2, secretKey, ivParameterSpec);
+                byte[] decrypedValueBytes = cipher.doFinal(encrypedPwdBytes);
+                String decrypedValue = new String(decrypedValueBytes);
+                return decrypedValue;
+            } catch (Exception var9) {
+                return null;
+            }
+        }
+    }
+
+    public static byte[] encrypt(byte[] key, byte[] src) throws Exception {
+        byte[] rawKey = getRawKey(key);
+        SecretKeySpec skeySpec = new SecretKeySpec(key, "AES");
+        Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");
+        cipher.init(1, skeySpec);
+        byte[] encrypted = cipher.doFinal(src);
+        return encrypted;
+    }
+
+    private static byte[] getRawKey(byte[] seed) throws Exception {
+        KeyGenerator kgen = KeyGenerator.getInstance("AES");
+        SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
+        sr.setSeed(seed);
+        kgen.init(128, sr);
+        SecretKey skey = kgen.generateKey();
+        byte[] raw = skey.getEncoded();
+        return raw;
+    }
+
+    private static SecretKeySpec getKey(String password) throws UnsupportedEncodingException {
+        int keyLength = 256;
+        byte[] keyBytes = new byte[keyLength / 8];
+        Arrays.fill(keyBytes, (byte)0);
+        byte[] passwordBytes = password.getBytes("UTF-8");
+        int length = passwordBytes.length < keyBytes.length ? passwordBytes.length : keyBytes.length;
+        System.arraycopy(passwordBytes, 0, keyBytes, 0, length);
+        SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
+        return key;
+    }
+
+    public static double calculateAccuracy(int txPower, double rssi) {
+        if (txPower != 0 && txPower != 2147483647) {
+            if (rssi == 0.0D) {
+                return -1.0D;
+            } else {
+                double accuracy = 0.0D;
+                double ratio = rssi * 1.0D / (double)txPower;
+                if (ratio < 1.0D) {
+                    accuracy = Math.pow(ratio, 10.0D);
+                } else {
+                    accuracy = 0.89976D * Math.pow(ratio, 7.7095D) + 0.111D;
+                }
+
+                return (new BigDecimal(Double.toString(accuracy))).setScale(4, 4).doubleValue();
+            }
+        } else {
+            Log.v("", "");
+            return -1.0D;
+        }
+    }
+
+    public static Proximity calculateProximity(double accuracy) {
+        if (accuracy < 0.0D) {
+            return Proximity.PROXIMITY_UNKNOWN;
+        } else if (accuracy < 0.5D) {
+            return Proximity.PROXIMITY_IMMEDIATE;
+        } else {
+            return accuracy <= 4.0D ? Proximity.PROXIMITY_NEAR : Proximity.PROXIMITY_FAR;
+        }
+    }
+
+    public static String parseEddystoneURL(byte[] eddystoneURLBytes) {
+        String url = null;
+        return (String)url;
+    }
+
+    public static <T> T checkNotNull(T reference, Object errorMessage) {
+        if (reference == null) {
+            throw new NullPointerException(String.valueOf(errorMessage));
+        } else {
+            return reference;
+        }
+    }
+}
diff --git a/lib/src/main/java/org/altbeacon/beacon/VersionUtils.java b/lib/src/main/java/org/altbeacon/beacon/VersionUtils.java
new file mode 100644
index 00000000..b7a507ab
--- /dev/null
+++ b/lib/src/main/java/org/altbeacon/beacon/VersionUtils.java
@@ -0,0 +1,108 @@
+package org.altbeacon.beacon;
+
+import com.sensoro.beacon.kit.Beacon;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class VersionUtils {
+    public static List<String> HW_NO_SENSOR = Arrays.asList("A0");
+    public static List<String> HW_THREE_SENSOR = Arrays.asList("B0", "C0");
+    public static List<String> HW_TWO_SENSOR = Arrays.asList("C1");
+    public static String FV_EDDYSTONE_MINI = "4.0";
+    public static String FV_PREVENT_TAMPER_MINI = "3.0";
+    public static String FV_PREVENT_SQUATTER_MINI = "2.3";
+    public static List<String> FV_EID = Arrays.asList("4.3", "4.4", "4.5", "4.6");
+    static int[] supportFirmwareVersion = new int[]{16, 32, 33, 34, 35, 48, 49, 64, 65, 66, 67, 68, 69, 70};
+    static int[] supportHardwareVersion = new int[]{160, 176, 192, 193, 200};
+
+    public VersionUtils() {
+    }
+
+    public static boolean isSupportedFiremware(int firmwareVersion) {
+        return Arrays.binarySearch(supportFirmwareVersion, firmwareVersion) != -1;
+    }
+
+    public static boolean isSupportedHardware(int hardwareVersion) {
+        return Arrays.binarySearch(supportHardwareVersion, hardwareVersion) != -1;
+    }
+
+    public static boolean isAbove2_3(com.sensoro.beacon.kit.Beacon beacon) {
+        int result = beacon.getFirmwareVersion().compareTo("2.3");
+        return result >= 0;
+    }
+
+    public static boolean isSupportPreventTamper(com.sensoro.beacon.kit.Beacon beacon) {
+        if (beacon == null) {
+            return false;
+        } else {
+            String fw = beacon.getFirmwareVersion();
+            int result = fw.compareTo(FV_PREVENT_TAMPER_MINI);
+            return result >= 0;
+        }
+    }
+
+    public static boolean isSupportPreventSquatter(com.sensoro.beacon.kit.Beacon beacon) {
+        if (beacon == null) {
+            return false;
+        } else {
+            String fw = beacon.getFirmwareVersion();
+            int result = fw.compareTo(FV_PREVENT_SQUATTER_MINI);
+            return result >= 0;
+        }
+    }
+
+    public static boolean isSupportEnergySavingMode(com.sensoro.beacon.kit.Beacon beacon) {
+        if (beacon == null) {
+            return false;
+        } else {
+            return beacon.getHardwareModelName().equals("B0") && isAbove3_0(beacon);
+        }
+    }
+
+    public static boolean isSupportInfoInBroadcast(com.sensoro.beacon.kit.Beacon beacon) {
+        if (beacon == null) {
+            return false;
+        } else {
+            return beacon.getHardwareModelName().equals("B0") && isAbove3_0(beacon);
+        }
+    }
+
+    public static boolean isNoSensor(com.sensoro.beacon.kit.Beacon beacon) {
+        if (beacon == null) {
+            return false;
+        } else {
+            return HW_NO_SENSOR.contains(beacon.getHardwareModelName());
+        }
+    }
+
+    public static boolean isSupportEID(com.sensoro.beacon.kit.Beacon beacon) {
+        if (beacon == null) {
+            return false;
+        } else {
+            return FV_EID.contains(beacon.getFirmwareVersion());
+        }
+    }
+
+    public static boolean isTwoSensors(com.sensoro.beacon.kit.Beacon beacon) {
+        if (beacon == null) {
+            return false;
+        } else {
+            return HW_TWO_SENSOR.contains(beacon.getHardwareModelName());
+        }
+    }
+
+    public static boolean isAbove3_0(com.sensoro.beacon.kit.Beacon beacon) {
+        int result = beacon.getFirmwareVersion().compareTo("3.0");
+        return result >= 0;
+    }
+
+    public static boolean isAbove3_1(com.sensoro.beacon.kit.Beacon beacon) {
+        int result = beacon.getFirmwareVersion().compareTo("3.1");
+        return result >= 0;
+    }
+
+    public static boolean isAbove4_0(Beacon beacon) {
+        return beacon.getFirmwareVersion().compareTo("4.0") >= 0;
+    }
+}
diff --git a/lib/src/main/resources/sensoro-beacon-kit-4.3.jar b/lib/src/main/resources/sensoro-beacon-kit-4.3.jar
new file mode 100644
index 00000000..61b4bc4a
Binary files /dev/null and b/lib/src/main/resources/sensoro-beacon-kit-4.3.jar differ
diff --git a/lib/src/main/resources/sensoro-scanner-1.0.1.jar b/lib/src/main/resources/sensoro-scanner-1.0.1.jar
new file mode 100644
index 00000000..d58ab30d
Binary files /dev/null and b/lib/src/main/resources/sensoro-scanner-1.0.1.jar differ
