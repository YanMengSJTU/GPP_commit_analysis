diff --git a/CHANGELOG.md b/CHANGELOG.md
index f70765f1..14769faf 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,7 @@
 
-### Development
+### 2.11 / 2017-06-28
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.10...2.11)
 
 Enhancements:
 
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index a0a9a674..1964cbf0 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -31,6 +31,7 @@
 import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
+import android.os.Build;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
@@ -320,6 +321,8 @@ protected BeaconManager(@NonNull Context context) {
            verifyServiceDeclaration();
          }
         this.beaconParsers.add(new AltBeaconParser());
+        // TODO: Change this to >= Build.VERSION_CODES.O when the SDK is released
+        mScheduledScanJobsEnabled = android.os.Build.VERSION.SDK_INT > Build.VERSION_CODES.N;
     }
 
     /***
@@ -408,12 +411,6 @@ public void bind(@NonNull BeaconConsumer consumer) {
             consumer.onBeaconServiceConnect();
             return;
         }
-        if (mScheduledScanJobsEnabled) {
-            LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
-            consumer.onBeaconServiceConnect();
-            return;
-        }
-
         synchronized (consumers) {
             ConsumerInfo newConsumerInfo = new ConsumerInfo();
             ConsumerInfo alreadyBoundConsumerInfo = consumers.putIfAbsent(consumer, newConsumerInfo);
@@ -525,11 +522,39 @@ public void setBackgroundMode(boolean backgroundMode) {
             }
         }
     }
+
+    /**
+     * Configures using a `ScanJob` run with the `JobScheduler` to perform scans rather than using a
+     * long-running `BeaconService` to do so.
+     *
+     * Calling with true on devices older than Android L (5.0) will not apply the change
+     * as the JobScheduler is not available.
+     *
+     * This value defaults to true on Android O+ and false on devices with older OS versions.
+     * Accepting the default value of false is recommended on Android N and earlier because
+     * otherwise beacon scans may be run only once every 15 minutes in the background, and no low
+     * power scans may be performed between scanning cycles.
+     *
+     * This method may only be called if bind() has not yet been called, otherwise an
+     * `IllegalStateException` is thown.
+     *
+     * @param enabled
+     */
     public void setEnableScheduledScanJobs(boolean enabled) {
-        this.mScheduledScanJobsEnabled = enabled;
+        if (isAnyConsumerBound()) {
+            LogManager.e(TAG, "ScanJob may not be configured because a consumer is" +
+                    " already bound.");
+            throw new IllegalStateException("Method must be called before calling bind()");
+        }
+        if (enabled && android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            LogManager.e(TAG, "ScanJob may not be configured because JobScheduler is not" +
+                    " availble prior to Android 5.0");
+            return;
+        }
+        mScheduledScanJobsEnabled = enabled;
     }
     public boolean getScheduledScanJobsEnabled() {
-        return this.mScheduledScanJobsEnabled;
+        return mScheduledScanJobsEnabled;
     }
     public boolean getBackgroundMode() {
         return mBackgroundMode;
@@ -775,17 +800,7 @@ public void startRangingBeaconsInRegion(@NonNull Region region) throws RemoteExc
         synchronized (rangedRegions) {
             rangedRegions.add(region);
         }
-        if (mScheduledScanJobsEnabled) {
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-        }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
-        }
+        applyChangesToServices(BeaconService.MSG_START_RANGING, region);
     }
 
     /**
@@ -816,17 +831,7 @@ public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteExce
             }
             rangedRegions.remove(regionToRemove);
         }
-        if (mScheduledScanJobsEnabled) {
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-        }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
-        }
+        applyChangesToServices(BeaconService.MSG_STOP_RANGING, region);
     }
 
     /**
@@ -853,18 +858,10 @@ protected void syncSettingsToService() {
             ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
             return;
         }
-        if (serviceMessenger == null) {
-            LogManager.e(TAG, "The BeaconManager is not bound to the service.  Settings synchronization will fail.");
-            return;
-        }
-        else {
-            try {
-                Message msg = Message.obtain(null, BeaconService.MSG_SYNC_SETTINGS, 0, 0);
-                msg.setData(new SettingsData().collect(mContext).toBundle());
-                serviceMessenger.send(msg);
-            } catch (RemoteException e) {
-                LogManager.e(TAG, "Failed to sync settings to service", e);
-            }
+        try {
+            applyChangesToServices(BeaconService.MSG_SYNC_SETTINGS, null);
+        } catch (RemoteException e) {
+            LogManager.e(TAG, "Failed to sync settings to service", e);
         }
     }
 
@@ -890,17 +887,9 @@ public void startMonitoringBeaconsInRegion(@NonNull Region region) throws Remote
         }
         if (mScheduledScanJobsEnabled) {
             MonitoringStatus.getInstanceForApplication(mContext).addRegion(region, new Callback(callbackPackageName()));
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-        }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
-            Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
         }
+        applyChangesToServices(BeaconService.MSG_START_MONITORING, region);
+
         if (isScannerInDifferentProcess()) {
             MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
         }
@@ -929,22 +918,13 @@ public void stopMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteE
         }
         if (mScheduledScanJobsEnabled) {
             MonitoringStatus.getInstanceForApplication(mContext).removeRegion(region);
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-        }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
         }
+        applyChangesToServices(BeaconService.MSG_STOP_MONITORING, region);
         if (isScannerInDifferentProcess()) {
             MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
         }
     }
 
-
     /**
      * Updates an already running scan with scanPeriod/betweenScanPeriod according to Background/Foreground state.
      * Change will take effect on the start of the next scan cycle.
@@ -962,17 +942,29 @@ public void updateScanPeriods() throws RemoteException {
         }
         LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
         LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
+        applyChangesToServices(BeaconService.MSG_SET_SCAN_PERIODS, null);
+    }
+
+    @TargetApi(18)
+    private void applyChangesToServices(int type, Region region) throws RemoteException {
         if (mScheduledScanJobsEnabled) {
             ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            return;
         }
-        else {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
+        if (serviceMessenger == null) {
+            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        }
+        Message msg = Message.obtain(null, type, 0, 0);
+        if (type == BeaconService.MSG_SET_SCAN_PERIODS) {
             msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
         }
+        else if (type == BeaconService.MSG_SYNC_SETTINGS) {
+            msg.setData(new SettingsData().collect(mContext).toBundle());
+        }
+        else {
+            msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(), mBackgroundMode).toBundle());
+        }
+        serviceMessenger.send(msg);
     }
 
     private String callbackPackageName() {
@@ -1206,7 +1198,7 @@ private void verifyServiceDeclaration() {
         List<ResolveInfo> resolveInfo =
                 packageManager.queryIntentServices(intent,
                         PackageManager.MATCH_DEFAULT_ONLY);
-        if (resolveInfo != null && resolveInfo.size() == 0) {
+        if (resolveInfo != null && resolveInfo.isEmpty()) {
             throw new ServiceNotDeclaredException();
         }
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
index 716946bd..758f0995 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
@@ -25,6 +25,7 @@
 
 /**
  * Created by dyoung on 3/24/17.
+ * @hice
  */
 
 public class ScanDataProcessor {
@@ -36,7 +37,6 @@
     private ExtraDataBeaconTracker mExtraDataBeaconTracker;
     // TODO: implement this
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-    // TODO: re-evaluate the need for this
     private DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
 
     int trackedBeaconsPacketCount;
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
index 3ac5fbdc..644a4584 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -2,13 +2,20 @@
 
 import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.ScanFilter;
+import android.bluetooth.le.ScanSettings;
 import android.content.Context;
+import android.content.Intent;
 import android.content.pm.ApplicationInfo;
 import android.os.AsyncTask;
 import android.os.Build;
 import android.support.annotation.MainThread;
 import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
 import android.support.annotation.WorkerThread;
 import android.support.annotation.RestrictTo;
 import android.support.annotation.RestrictTo.Scope;
@@ -22,6 +29,8 @@
 import org.altbeacon.beacon.service.scanner.CycledLeScanner;
 import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+import org.altbeacon.beacon.service.scanner.ScanFilterUtils;
+import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.util.ArrayList;
@@ -39,7 +48,7 @@
 /**
  * Created by dyoung on 6/16/17.
  *
- * This is an internal utilty class and should not be called directly by library users.
+ * This is an internal utility class and should not be called directly by library users.
  *
  * This encapsulates shared data and methods used by both ScanJob and BeaconService
  * that deal with the specifics of beacon scanning.
@@ -137,6 +146,56 @@ void reloadParsers() {
         mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
     }
 
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    void startAndroidOBackgroundScan(Set<BeaconParser> beaconParsers) {
+        ScanSettings settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
+        List<ScanFilter> filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
+                new ArrayList<BeaconParser>(beaconParsers));
+        try {
+            final BluetoothManager bluetoothManager =
+                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();
+            if (bluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            }
+            else {
+                int result = bluetoothAdapter.getBluetoothLeScanner().startScan(filters, settings, getScanCallbackIntent());
+                if (result != 0) {
+                    LogManager.e(TAG, "Failed to start background scan on Android O.  Code: "+result);
+                }
+                else {
+                    LogManager.d(TAG, "Started passive beacon scan");
+                }
+            }
+        }
+        catch (SecurityException e) {
+            LogManager.e(TAG, "SecurityException making Android O background scanner");
+        }
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    void stopAndroidOBackgroundScan() {
+        try {
+            final BluetoothManager bluetoothManager =
+                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();
+            if (bluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            } else {
+                bluetoothAdapter.getBluetoothLeScanner().stopScan(getScanCallbackIntent());
+            }
+        } catch (SecurityException e) {
+            LogManager.e(TAG, "SecurityException stopping Android O background scanner");
+        }
+    }
+
+    // Low power scan results in the background will be delivered via Intent
+    PendingIntent getScanCallbackIntent() {
+        Intent intent = new Intent(mContext, StartupBroadcastReceiver.class);
+        intent.putExtra("o-scan", true);
+        return PendingIntent.getBroadcast(mContext,0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+    }
+
     private final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
         @TargetApi(Build.VERSION_CODES.HONEYCOMB)
         @Override
@@ -339,4 +398,5 @@ protected void onProgressUpdate(Void... values) {
         }
         return matched;
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
index 8842ac3c..1ea67edf 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJob.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -2,10 +2,9 @@
 
 import android.annotation.TargetApi;
 import android.app.job.JobParameters;
-import android.app.job.JobScheduler;
 import android.app.job.JobService;
+import android.bluetooth.le.ScanRecord;
 import android.bluetooth.le.ScanResult;
-import android.content.Context;
 import android.os.Build;
 import android.os.Handler;
 import org.altbeacon.beacon.Beacon;
@@ -14,21 +13,21 @@
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
-import org.altbeacon.beacon.service.scanner.CycledLeScannerForAndroidO;
-import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.utils.ProcessUtils;
 import java.util.List;
 
-/**
- * Created by dyoung on 3/24/17.
- */
 
 /**
+ * Used to perform scans periodically using the JobScheduler
+ *
  * Only one instance of this will be active, even with multiple jobIds.  If one job
  * is already running when another is scheduled to start, onStartJob gets called again on the same
  * instance.
  *
  * If the OS decides to create a new instance, it will call onStopJob() on the old instance
+ *
+ * Created by dyoung on 3/24/17.
+ * @hide
  */
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
 public class ScanJob extends JobService {
@@ -43,30 +42,30 @@
 
     private ScanState mScanState;
     private Handler mStopHandler = new Handler();
-    private BeaconManager mBeaconManager;
     private ScanHelper mScanHelper;
     private boolean mInitialized = false;
 
     @Override
     public boolean onStartJob(final JobParameters jobParameters) {
         mScanHelper = new ScanHelper(this);
-        JobScheduler jobScheduler = (JobScheduler) this.getSystemService(Context.JOB_SCHEDULER_SERVICE);
         if (jobParameters.getJobId() == IMMMEDIATE_SCAN_JOB_ID) {
             LogManager.i(TAG, "Running immdiate scan job: instance is "+this);
         }
         else {
             LogManager.i(TAG, "Running periodic scan job: instance is "+this);
         }
-        NonBeaconLeScanCallback nonBeaconLeScanCallback = BeaconManager.getInstanceForApplication(this).getNonBeaconLeScanCallback();
 
         List<ScanResult> queuedScanResults = ScanJobScheduler.getInstance().dumpBackgroundScanResultQueue();
         LogManager.d(TAG, "Processing %d queued scan resuilts", queuedScanResults.size());
         for (ScanResult result : queuedScanResults) {
-            mScanHelper.processScanResult(result.getDevice(), result.getRssi(), result.getScanRecord().getBytes());
+            ScanRecord scanRecord = result.getScanRecord();
+            if (scanRecord != null) {
+                mScanHelper.processScanResult(result.getDevice(), result.getRssi(), scanRecord.getBytes());
+            }
         }
         LogManager.d(TAG, "Done processing queued scan resuilts");
 
-        boolean startedScan = false;
+        boolean startedScan;
         if (mInitialized) {
             LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
             startedScan = restartScanning();
@@ -112,17 +111,13 @@ private void startPassiveScanIfNeeded() {
             LogManager.i(TAG, "We are inside a beacon region.  We will not scan between cycles.");
         }
         else {
-            LogManager.i(TAG, "We are outside all beacon regions.  We will scan between cycles.");
-            // TODO:  Ew. figure out a better way to know to call this
-            if (mScanHelper.getCycledScanner() instanceof CycledLeScannerForAndroidO) {
-                // We are in backround mode for Anrdoid O and the background scan cycle
-                // has ended.  Now we kick off a background scan with a lower power
-                // mode and set it to deliver an intent if it sees anything that will
-                // wake us up and start this craziness all over again
-                ((CycledLeScannerForAndroidO)mScanHelper.getCycledScanner()).startAndroidOBackgroundScan(mScanState.getBeaconParsers());
+            // TODO: Change this to >= Build.VERSION_CODES.O when the SDK is released
+            if (Build.VERSION.SDK_INT > 10000) {
+                LogManager.i(TAG, "We are outside all beacon regions.  We will scan between cycles.");
+                mScanHelper.startAndroidOBackgroundScan(mScanState.getBeaconParsers());
             }
             else {
-                LogManager.d(TAG, "This is not an Android O scanner.  No scanning between cycles.");
+                LogManager.d(TAG, "This is not Android O.  No scanning between cycles when using ScanJob");
             }
         }
     }
@@ -160,6 +155,10 @@ private boolean restartScanning() {
         if (mScanHelper.getCycledScanner() == null) {
             mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
         }
+        // TODO: Change this to >= Build.VERSION_CODES.O when the SDK is released
+        if (Build.VERSION.SDK_INT > 10000) {
+            mScanHelper.stopAndroidOBackgroundScan();
+        }
         mScanHelper.getCycledScanner().setScanPeriods(mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod(),
                                       mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod(),
                                       mScanState.getBackgroundMode());
@@ -176,9 +175,9 @@ private boolean restartScanning() {
 
     // Returns true of scanning actually was started, false if it did not need to be
     private boolean startScanning() {
-        mBeaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
-        mBeaconManager.setScannerInSameProcess(true);
-        if (mBeaconManager.isMainProcess()) {
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        beaconManager.setScannerInSameProcess(true);
+        if (beaconManager.isMainProcess()) {
             LogManager.i(TAG, "scanJob version %s is starting up on the main process", BuildConfig.VERSION_NAME);
         }
         else {
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
index 92785406..bfe8d354 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -10,6 +10,7 @@
 import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
@@ -18,17 +19,27 @@
 import java.util.List;
 
 /**
+ * Schedules two types of ScanJobs:
+ *  1. Periodic, which are set to go every scanPeriod+betweenScanPeriod
+ *  2. Immediate, which go right now.
+ *
+ *  Immediate ScanJobs are used when the app is in the foreground and wants to get immediate results
+ *  or when beacons have been detected with background scan filters and delivered via Intents and
+ *  a scan needs to run in a timely manner to collect data about those beacons known to be newly
+ *  in the vicinity despite the app being in the background.
+ *
  * Created by dyoung on 6/7/17.
+ * @hide
  */
-
+@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
 public class ScanJobScheduler {
     private static final String TAG = ScanJobScheduler.class.getSimpleName();
     private static final Object SINGLETON_LOCK = new Object();
-    private static final long MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING = 10000l;
+    private static final long MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING = 10000L;
     @Nullable
     private static volatile ScanJobScheduler sInstance = null;
     @NonNull
-    private Long mScanJobScheduleTime = 0l;
+    private Long mScanJobScheduleTime = 0L;
     @NonNull
     private List<ScanResult> mBackgroundScanResultQueue = new ArrayList<>();
 
@@ -46,14 +57,13 @@ public static ScanJobScheduler getInstance() {
         return instance;
     }
 
-    protected ScanJobScheduler() {
+    private ScanJobScheduler() {
     }
 
     /**
-     * Returns queued scan results delivered in the background
-     * @return
+     * @return previoulsy queued scan results delivered in the background
      */
-    public List<ScanResult> dumpBackgroundScanResultQueue() {
+    List<ScanResult> dumpBackgroundScanResultQueue() {
         List<ScanResult> retval = mBackgroundScanResultQueue;
         mBackgroundScanResultQueue = new ArrayList<>();
         return retval;
@@ -72,11 +82,13 @@ public void applySettingsToScheduledJob(Context context, BeaconManager beaconMan
         applySettingsToScheduledJob(context, beaconManager, scanState);
     }
 
+    // This method appears to be never used, because it is only used by Android O APIs, which
+    // must exist on another branch until the SDKs are released.
     public void scheduleAfterBackgroundWakeup(Context context, List<ScanResult> scanResults) {
         if (scanResults != null) {
             mBackgroundScanResultQueue.addAll(scanResults);
         }
-        synchronized (mScanJobScheduleTime) {
+        synchronized (this) {
             // We typically get a bunch of calls in a row here, separated by a few millis.  Only do this once.
             if (System.currentTimeMillis() - mScanJobScheduleTime > MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING) {
                 LogManager.d(TAG, "scheduling an immediate scan job because last did "+(System.currentTimeMillis() - mScanJobScheduleTime)+"seconds ago.");
@@ -91,14 +103,10 @@ public void scheduleAfterBackgroundWakeup(Context context, List<ScanResult> scan
         schedule(context, scanState, true);
     }
 
-    /**
-     *
-     * @param context
-     */
-    public void schedule(Context context, ScanState scanState, boolean backgroundWakeup) {
+    private void schedule(Context context, ScanState scanState, boolean backgroundWakeup) {
         long betweenScanPeriod = scanState.getScanJobIntervalMillis() - scanState.getScanJobRuntimeMillis();
 
-        long millisToNextJobStart = scanState.getScanJobIntervalMillis();
+        long millisToNextJobStart;
         if (backgroundWakeup) {
             LogManager.d(TAG, "We just woke up in the background based on a new scan result.  Start scan job immediately.");
             millisToNextJobStart = 0;
@@ -151,7 +159,7 @@ public void schedule(Context context, ScanState scanState, boolean backgroundWak
         if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
             // ON Android N+ we specify a tolerance of 0ms (capped at 5% by the OS) to ensure
             // our scans happen within 5% of the schduled time.
-            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0l).build();
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0L).build();
         }
         else {
             periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis()).build();
@@ -165,6 +173,7 @@ public void schedule(Context context, ScanState scanState, boolean backgroundWak
         // This is the same way it worked on Android N per this post: https://stackoverflow.com/questions/38344220/job-scheduler-not-running-on-android-n
         //
         // In practice, I see the following runtimes on the Nexus Player with Android O
+        // This shows that the 15 minutes has some slop.
         //
         /*
 06-07 22:25:51.380 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@7188bc6
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanState.java b/src/main/java/org/altbeacon/beacon/service/ScanState.java
index 25f8264a..251316a8 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanState.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanState.java
@@ -28,6 +28,7 @@
  * for running from a scheduled job
  *
  * Created by dyoung on 3/26/17.
+ * @hide
  */
 
 public class ScanState implements Serializable {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
index 403c25b7..0c981956 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
@@ -1,61 +1,30 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.annotation.TargetApi;
-import android.app.PendingIntent;
-import android.bluetooth.le.ScanFilter;
-import android.bluetooth.le.ScanSettings;
 import android.content.Context;
-import android.content.Intent;
 
-import org.altbeacon.beacon.BeaconParser;
-import org.altbeacon.beacon.logging.LogManager;
-import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Set;
 
 /**
+ * The scanner used for Android O is effectively the same as used for JellyBeaconMr2.  There is no
+ * point in using the low power scanning APIs introduced in Lollipop, because they only work when
+ * the app is running, effectively requiring a long running service, something newly disallowed
+ * by Android O.  The new strategy for Android O is to use a JobScheduler combined with background
+ * scans delivered by Intents.
+ *
+ * @see org.altbeacon.beacon.service.ScanJob
+ * @see org.altbeacon.beacon.service.ScanHelper#startAndroidOBackgroundScan(Set)
+ *
  * Created by dyoung on 5/28/17.
  */
 
-@TargetApi(25)
-public class CycledLeScannerForAndroidO extends CycledLeScannerForJellyBeanMr2 {
+@TargetApi(26)
+class CycledLeScannerForAndroidO extends CycledLeScannerForJellyBeanMr2 {
     private static final String TAG = CycledLeScannerForAndroidO.class.getSimpleName();
 
-    public CycledLeScannerForAndroidO(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
+    CycledLeScannerForAndroidO(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
         super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
-        // We stop scanning here in case we were doing a passive background scan
-        getBluetoothAdapter().getBluetoothLeScanner().stopScan(getScanCallbackIntent());
     }
-
-    /**
-     * @param beaconParsers
-     */
-    public void startAndroidOBackgroundScan(Set<BeaconParser> beaconParsers) {
-        ScanSettings settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
-        List<ScanFilter> filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
-                new ArrayList(beaconParsers));
-        try {
-            int result = getBluetoothAdapter().getBluetoothLeScanner().startScan(filters, settings, getScanCallbackIntent());
-            if (result != 0) {
-                LogManager.e(TAG, "Failed to start background scan on Android O.  Code: "+result);
-            }
-            else {
-                LogManager.d(TAG, "Started passive beacon scan");
-            }
-         }
-        catch (SecurityException e) {
-            LogManager.e(TAG, "SecurityException making Android O background scanner");
-         }
-    }
-
-    // Low power scan results in the background will be delivered via Intent
-    private PendingIntent getScanCallbackIntent() {
-        Intent intent = new Intent(mContext, StartupBroadcastReceiver.class);
-        intent.putExtra("o-scan", true);
-        return PendingIntent.getBroadcast(mContext,0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
-    }
-
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index 673aeb8c..26d0b074 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -30,7 +30,6 @@
     private ScanCallback leScanCallback;
     private long mBackgroundLScanStartTime = 0l;
     private long mBackgroundLScanFirstDetectionTime = 0l;
-    private boolean mScanDeferredBefore = false;
     private boolean mMainScanCycleActive = false;
     private final BeaconManager mBeaconManager;
 
@@ -79,51 +78,51 @@ then no beacons will be detected until the next scan cycle starts (5 minutes max
     protected boolean deferScanIfNeeded() {
         // This method is called to see if it is time to start a scan
         long millisecondsUntilStart = mNextScanCycleStartTime - SystemClock.elapsedRealtime();
-        if (millisecondsUntilStart > 0) {
-            mMainScanCycleActive = false;
-            if (true) {
-                long secsSinceLastDetection = SystemClock.elapsedRealtime() -
-                        DetectionTracker.getInstance().getLastDetectionTime();
-                // If we have seen a device recently
-                // devices should behave like pre-Android L devices, because we don't want to drain battery
-                // by continuously delivering packets for beacons visible in the background
-                if (mScanDeferredBefore == false) {
-                    if (secsSinceLastDetection > BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
-                        mBackgroundLScanStartTime = SystemClock.elapsedRealtime();
-                        mBackgroundLScanFirstDetectionTime = 0l;
-                        LogManager.d(TAG, "This is Android L. Doing a filtered scan for the background.");
+        final boolean deferScan = millisecondsUntilStart > 0;
+        final boolean scanActiveBefore = mMainScanCycleActive;
+        mMainScanCycleActive = !deferScan;
+        if (deferScan) {
+            long secsSinceLastDetection = SystemClock.elapsedRealtime() -
+                    DetectionTracker.getInstance().getLastDetectionTime();
+            // If we have seen a device recently
+            // devices should behave like pre-Android L devices, because we don't want to drain battery
+            // by continuously delivering packets for beacons visible in the background
+            if (scanActiveBefore) {
+                if (secsSinceLastDetection > BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
+                    mBackgroundLScanStartTime = SystemClock.elapsedRealtime();
+                    mBackgroundLScanFirstDetectionTime = 0l;
+                    LogManager.d(TAG, "This is Android L. Doing a filtered scan for the background.");
 
-                        // On Android L, between scan cycles do a scan with a filter looking for any beacon
-                        // if we see one of those beacons, we need to deliver the results
-                        startScan();
-                    } else {
-                        // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
-                        // This API is now available in Android M
-                        LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
-                                + "ago, so we will not keep scanning in background.",
-                                secsSinceLastDetection);
-                    }
+                    // On Android L, between scan cycles do a scan with a filter looking for any beacon
+                    // if we see one of those beacons, we need to deliver the results
+                    startScan();
+                } else {
+                    // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
+                    // This API is now available in Android M
+                    LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
+                            + "ago, so we will not keep scanning in background.",
+                            secsSinceLastDetection);
                 }
-                if (mBackgroundLScanStartTime > 0l) {
-                    // if we are in here, we have detected beacons recently in a background L scan
-                    if (DetectionTracker.getInstance().getLastDetectionTime() > mBackgroundLScanStartTime) {
-                        if (mBackgroundLScanFirstDetectionTime == 0l) {
-                            mBackgroundLScanFirstDetectionTime = DetectionTracker.getInstance().getLastDetectionTime();
-                        }
-                        if (SystemClock.elapsedRealtime() - mBackgroundLScanFirstDetectionTime
-                                >= BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
-                            // if we are in here, it has been more than 10 seconds since we detected
-                            // a beacon in background L scanning mode.  We need to stop scanning
-                            // so we do not drain battery
-                            LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
-                            stopScan();
-                            mBackgroundLScanStartTime = 0l;
-                        }
-                        else {
-                            // report the results up the chain
-                            LogManager.d(TAG, "Delivering Android L background scanning results");
-                            mCycledLeScanCallback.onCycleEnd();
-                        }
+            }
+            if (mBackgroundLScanStartTime > 0l) {
+                // if we are in here, we have detected beacons recently in a background L scan
+                if (DetectionTracker.getInstance().getLastDetectionTime() > mBackgroundLScanStartTime) {
+                    if (mBackgroundLScanFirstDetectionTime == 0l) {
+                        mBackgroundLScanFirstDetectionTime = DetectionTracker.getInstance().getLastDetectionTime();
+                    }
+                    if (SystemClock.elapsedRealtime() - mBackgroundLScanFirstDetectionTime
+                            >= BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
+                        // if we are in here, it has been more than 10 seconds since we detected
+                        // a beacon in background L scanning mode.  We need to stop scanning
+                        // so we do not drain battery
+                        LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
+                        stopScan();
+                        mBackgroundLScanStartTime = 0l;
+                    }
+                    else {
+                        // report the results up the chain
+                        LogManager.d(TAG, "Delivering Android L background scanning results");
+                        mCycledLeScanCallback.onCycleEnd();
                     }
                 }
             }
@@ -132,7 +131,7 @@ protected boolean deferScanIfNeeded() {
             // Don't actually wait until the next scan time -- only wait up to 1 second.  This
             // allows us to start scanning sooner if a consumer enters the foreground and expects
             // results more quickly.
-            if (mScanDeferredBefore == false && mBackgroundFlag) {
+            if (scanActiveBefore && mBackgroundFlag) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
@@ -142,18 +141,13 @@ public void run() {
                     scanLeDevice(true);
                 }
             }, millisecondsUntilStart > 1000 ? 1000 : millisecondsUntilStart);
-            mScanDeferredBefore = true;
-            return true;
-        }
-        else {
+        } else {
             if (mBackgroundLScanStartTime > 0l) {
                 stopScan();
                 mBackgroundLScanStartTime = 0;
             }
-            mScanDeferredBefore = false;
-            mMainScanCycleActive = true;
         }
-        return false;
+        return deferScan;
     }
 
     @Override
