diff --git a/CHANGELOG.md b/CHANGELOG.md
index 1a72f8fb..3347bcaf 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,38 @@
+### 2.13.1 / 2018-03-05
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.13.1...2.13)
+
+ Bug Fixes:
+ - Fix incorrect immediateScanJobId meta-data name in manifest causing crash  (#653, David G. Young)
+
+
+### 2.13 / 2018-03-05
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12.4...2.13)
+
+Enhancements:
+ - Add BluetoothMedic to fix crashing bluetooth stacks.  (#644, David G. Young)
+ - Allow configuring job ids (#645, David G. Young)
+
+ Bug Fixes:
+ - Allow scans with screen off on Android 8.1 (#637, David G. Young)
+
+### 2.12.4 / 2017-12-16
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12.3...2.12.4)
+
+Bug Fixes:
+ - Fix performance problems when using identifiers 3-15 bytes caused by
+   Identifier#toHexString(). (#615, David G. Young)
+ - Restore missing runningAverageRssi values  (#621, David G. Young)
+ - Fix NPE on ExtraBeaconDataTracker (#626, David G. Young)
+ - Fix regression with `RunningAverageRssiFilter.setSampleExpirationMilliseconds`
+   being overwritten when committing ranged beacon measurements. (#629, Aaron Kromer)
+ - Fix missing running average RSSI in callbacks when apps do not use the
+   scheduled scan job feature. (#630, Aaron Kromer)
+ - Fix copying of multi-frame beacon flag in `Beacon(Beacon)` constructor (#630, Aaron Kromer)
+ - Fix the `AltBeaon(Beacon)` copy constructor which omitted some data fields (#630, Aaron Kromer)
+
 ### 2.12.3 / 2017-10-14
 
 [Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12.2...2.12.3)
@@ -5,7 +40,7 @@
 Bug Fixes:
  - Fix NullPointerException in ProcessUtils.  (#598, David G. Young)
  - Fix ConcurrentModificationException crashing app on Android 8 when monitored regions are
-   changed at the same time the app shifts from active scanning to passive scanning. 
+   changed at the same time the app shifts from active scanning to passive scanning.
    (#578, David G. Young)
  - Fix ConcurrentModifictionExceptions starting ScanJobs.  (#584, #588, David G. Young)
  - Fix NullPointerException when BluetoothLeScanner cannot be obtained.
@@ -42,7 +77,7 @@ Bug Fixes:
 [Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.11...2.12)
 
 Enhancements:
- - Add Android O support with ScanJob using  JobScheduler to do scans instead of BeaconService, 
+ - Add Android O support with ScanJob using  JobScheduler to do scans instead of BeaconService,
    set as default for Android O. (#484, David G. Young)
 
 Bug Fixes:
diff --git a/circle.yml b/circle.yml
index 048d01a5..74b551da 100644
--- a/circle.yml
+++ b/circle.yml
@@ -3,7 +3,7 @@ machine:
     version: openjdk8
 dependencies:
   pre:
-    - echo y | android update sdk --no-ui --all --filter "tools,android-26,build-tools-26.0.0,platform-tools,extra-android-m2repository,extra-google-m2repository"
+    - echo y | android update sdk --no-ui --all --filter "tools,android-26,build-tools-26.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
 general:
   branches:
     ignore:
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 5e35bbb6..9a16f53a 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,7 +3,7 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-rc-1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
 #distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-milestone-1-all.zip
 #distributionUrl=https\://services.gradle.org/distributions/gradle-4.0-milestone-1-all.zip
 #distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index cc3f5ef6..1da97bff 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -29,7 +29,16 @@
             />
 
         <service android:name=".service.ScanJob"
-                android:permission="android.permission.BIND_JOB_SERVICE" />
+                android:permission="android.permission.BIND_JOB_SERVICE">
+            <meta-data android:name="immediateScanJobId" android:value="208352939" />
+            <meta-data android:name="periodicScanJobId" android:value="208352940" />
+        </service>
+  
+        <service android:name="org.altbeacon.bluetooth.BluetoothTestJob"
+            android:permission="android.permission.BIND_JOB_SERVICE" >
+            <meta-data android:name="jobId" android:value="1799803768"/>
+        </service>
+
     </application>
 
 </manifest>
diff --git a/src/main/java/org/altbeacon/beacon/AltBeacon.java b/src/main/java/org/altbeacon/beacon/AltBeacon.java
index 891829e8..ccfd2777 100644
--- a/src/main/java/org/altbeacon/beacon/AltBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/AltBeacon.java
@@ -64,20 +64,14 @@ public AltBeacon createFromParcel(Parcel in) {
      * @param beacon
      */
     protected AltBeacon(Beacon beacon) {
-        super();
-        this.mBluetoothAddress = beacon.mBluetoothAddress;
-        this.mIdentifiers = beacon.mIdentifiers;
-        this.mBeaconTypeCode = beacon.mBeaconTypeCode;
-        this.mDataFields = beacon.mDataFields;
-        this.mDistance = beacon.mDistance;
-        this.mRssi = beacon.mRssi;
-        this.mTxPower = beacon.mTxPower;
+        super(beacon);
     }
 
     /**
      * @see AltBeacon.Builder to make AltBeacon instances
      */
     protected AltBeacon() {
+        super();
     }
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index 8e1f183f..f46e9edc 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -112,6 +112,16 @@
      */
     protected String mBluetoothAddress;
 
+    /**
+     * The number of rssi samples available, if known
+     */
+    private int mRssiMeasurementCount = 0;
+
+    /**
+     * The number of packets detected in the last cycle
+     */
+    private int mPacketCount = 0;
+
     /**
      * If multiple RSSI samples were available, this is the running average
      */
@@ -244,6 +254,9 @@ protected Beacon(Parcel in) {
         mBluetoothName = in.readString();
         mParserIdentifier = in.readString();
         mMultiFrameBeacon = in.readByte() != 0;
+        mRunningAverageRssi = (Double) in.readValue(null);
+        mRssiMeasurementCount = in.readInt();
+        mPacketCount = in.readInt();
     }
 
     /**
@@ -257,6 +270,8 @@ protected Beacon(Beacon otherBeacon) {
         mExtraDataFields = new ArrayList<>(otherBeacon.mExtraDataFields);
         this.mDistance = otherBeacon.mDistance;
         this.mRunningAverageRssi = otherBeacon.mRunningAverageRssi;
+        this.mPacketCount = otherBeacon.mPacketCount;
+        this.mRssiMeasurementCount = otherBeacon.mRssiMeasurementCount;
         this.mRssi = otherBeacon.mRssi;
         this.mTxPower = otherBeacon.mTxPower;
         this.mBluetoothAddress = otherBeacon.mBluetoothAddress;
@@ -264,6 +279,8 @@ protected Beacon(Beacon otherBeacon) {
         this.mServiceUuid = otherBeacon.getServiceUuid();
         this.mBluetoothName = otherBeacon.mBluetoothName;
         this.mParserIdentifier = otherBeacon.mParserIdentifier;
+        this.mMultiFrameBeacon = otherBeacon.mMultiFrameBeacon;
+        this.mManufacturer = otherBeacon.mManufacturer;
     }
 
     /**
@@ -275,6 +292,38 @@ protected Beacon() {
         mExtraDataFields = new ArrayList<Long>(1);
     }
 
+
+    /**
+     * Sets the measurement count that went into the rssi sample
+     * @param rssiMeasurementCount
+     */
+    public void setRssiMeasurementCount(int rssiMeasurementCount) {
+        mRssiMeasurementCount = rssiMeasurementCount;
+    }
+
+    /**
+     * Returns the number of packet detections in the last ranging cycle
+     */
+    public int getPacketCount() {
+        return mPacketCount;
+    }
+
+    /**
+     * Sets the packet detections in the last ranging cycle
+     * @param packetCount
+     */
+    public void setPacketCount(int packetCount) {
+        mPacketCount = packetCount;
+    }
+
+    /**
+     * Returns the number of packet detections that went in to the runningAverageRssi, if known.
+     * If not known or inapplicable for the rssi filter used, this is zero.
+     */
+    public int getMeasurementCount() {
+        return mRssiMeasurementCount;
+    }
+
     /**
      * Sets the running average rssi for use in distance calculations
      * @param rssi the running average rssi
@@ -584,6 +633,9 @@ public void writeToParcel(Parcel out, int flags) {
         out.writeString(mBluetoothName);
         out.writeString(mParserIdentifier);
         out.writeByte((byte) (mMultiFrameBeacon ? 1: 0));
+        out.writeValue(mRunningAverageRssi);
+        out.writeInt(mRssiMeasurementCount);
+        out.writeInt(mPacketCount);
     }
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 06e4dee5..869302de 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -477,7 +477,8 @@ public boolean isBound(@NonNull BeaconConsumer consumer) {
         synchronized (consumers) {
             // Annotation doesn't guarantee we get a non-null, but raising an NPE here is excessive
             //noinspection ConstantConditions
-            return consumer != null && consumers.get(consumer) != null && (serviceMessenger != null);
+            return consumer != null && consumers.get(consumer) != null &&
+                    (mScheduledScanJobsEnabled || serviceMessenger != null);
         }
     }
 
@@ -487,8 +488,9 @@ public boolean isBound(@NonNull BeaconConsumer consumer) {
      * @return
      */
     public boolean isAnyConsumerBound() {
-        synchronized (consumers) {
-            return consumers.isEmpty() && (serviceMessenger != null);
+        synchronized(consumers) {
+            return !consumers.isEmpty() &&
+                    (mScheduledScanJobsEnabled || serviceMessenger != null);
         }
     }
 
diff --git a/src/main/java/org/altbeacon/beacon/Identifier.java b/src/main/java/org/altbeacon/beacon/Identifier.java
index 8112cc4f..d96e567a 100644
--- a/src/main/java/org/altbeacon/beacon/Identifier.java
+++ b/src/main/java/org/altbeacon/beacon/Identifier.java
@@ -3,6 +3,8 @@
 import android.annotation.TargetApi;
 import android.os.Build;
 
+import org.altbeacon.beacon.logging.LogManager;
+
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.LongBuffer;
@@ -315,17 +317,23 @@ public boolean equals(Object that) {
         return Arrays.equals(mValue, thatIdentifier.mValue);
     }
 
+    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
     /**
      * Represents the value as a hexadecimal String. The String is prefixed with <code>0x</code>. For example 0x0034ab
      * @return value as hexadecimal String
      */
     public String toHexString() {
-        StringBuilder sb = new StringBuilder(2 + 2 * mValue.length);
-        sb.append("0x");
-        for (byte item : mValue) {
-            sb.append(String.format("%02x", item));
+        final int l = mValue.length;
+        final char[] out = new char[l*2+2];
+        out[0] = '0';
+        out[1] = 'x';
+        for( int i=0,j=2; i<l; i++ ){
+            out[j++] = HEX_DIGITS[(0xF0 & mValue[i]) >>> 4];
+            out[j++] = HEX_DIGITS[0x0F & mValue[i]];
         }
-        return sb.toString();
+        String s = new String(out);
+        return s;
     }
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
index 20858087..78c8eea6 100644
--- a/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
@@ -40,6 +40,9 @@ public void addMeasurement(Integer rssi) {
         LogManager.d(TAG, "armaMeasurement: %s", armaMeasurement);
     }
 
+    @Override
+    public int getMeasurementCount() { return 0; }
+
     public boolean noMeasurementsAvailable() {
         return false;
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
index 303efdd4..ae1bbbb1 100644
--- a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
@@ -1,5 +1,8 @@
 package org.altbeacon.beacon.service;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import org.altbeacon.beacon.Beacon;
 
 import java.io.Serializable;
@@ -12,11 +15,17 @@
  */
 public class ExtraDataBeaconTracker implements Serializable {
     private static final String TAG = "BeaconTracker";
-    // This is a lookup table to find tracked beacons by the calculated beacon key
-    private HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<String,HashMap<Integer,Beacon>>();
 
-    private boolean matchBeaconsByServiceUUID = true;
+    /**
+     * This is a lookup table to find tracked beacons by the calculated beacon key
+     */
+    @NonNull
+    private final HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<>();
+
+    private final boolean matchBeaconsByServiceUUID;
+
     public ExtraDataBeaconTracker() {
+        this(true);
     }
 
     public ExtraDataBeaconTracker(boolean matchBeaconsByServiceUUID) {
@@ -25,12 +34,10 @@ public ExtraDataBeaconTracker(boolean matchBeaconsByServiceUUID) {
 
     /**
      * Tracks a beacon. For Gatt-based beacons, returns a merged copy of fields from multiple
-     * frames.  Returns null when passed a Gatt-based beacon that has is only extra beacon data.
-     *
-     * @param beacon
-     * @return
+     * frames. Returns null when passed a Gatt-based beacon that has is only extra beacon data.
      */
-    public synchronized Beacon track(Beacon beacon) {
+    @Nullable
+    public synchronized Beacon track(@NonNull Beacon beacon) {
         Beacon trackedBeacon = null;
         if (beacon.isMultiFrameBeacon() || beacon.getServiceUuid() != -1) {
             trackedBeacon = trackGattBeacon(beacon);
@@ -41,42 +48,42 @@ public synchronized Beacon track(Beacon beacon) {
         return trackedBeacon;
     }
 
-    // The following code is for dealing with merging data fields in beacons
-    private Beacon trackGattBeacon(Beacon beacon) {
-        Beacon trackedBeacon = null;
-        HashMap<Integer,Beacon> matchingTrackedBeacons = mBeaconsByKey.get(getBeaconKey(beacon));
-        if (matchingTrackedBeacons != null) {
-            for (Beacon matchingTrackedBeacon: matchingTrackedBeacons.values()) {
-                if (beacon.isExtraBeaconData()) {
-                    matchingTrackedBeacon.setRssi(beacon.getRssi());
-                    matchingTrackedBeacon.setExtraDataFields(beacon.getDataFields());
-                }
-                else {
-                    beacon.setExtraDataFields(matchingTrackedBeacon.getExtraDataFields());
-                    // replace the tracked beacon instance with this one so it has updated values
-                    trackedBeacon = beacon;
-                }
-            }
-        }
-        if (!beacon.isExtraBeaconData()) {
-            updateTrackingHashes(beacon, matchingTrackedBeacons);
+    /**
+     * The following code is for dealing with merging data fields in beacons
+     */
+    @Nullable
+    private Beacon trackGattBeacon(@NonNull Beacon beacon) {
+        if (beacon.isExtraBeaconData()) {
+            updateTrackedBeacons(beacon);
+            return null;
         }
 
-        if (trackedBeacon == null && !beacon.isExtraBeaconData()) {
-            trackedBeacon = beacon;
+        String key = getBeaconKey(beacon);
+        HashMap<Integer,Beacon> matchingTrackedBeacons = mBeaconsByKey.get(key);
+        if (null == matchingTrackedBeacons) {
+            matchingTrackedBeacons = new HashMap<>();
         }
-        return trackedBeacon;
+        else {
+            Beacon trackedBeacon = matchingTrackedBeacons.values().iterator().next();
+            beacon.setExtraDataFields(trackedBeacon.getExtraDataFields());
+        }
+        matchingTrackedBeacons.put(beacon.hashCode(), beacon);
+        mBeaconsByKey.put(key, matchingTrackedBeacons);
+
+        return beacon;
     }
 
-    private void updateTrackingHashes(Beacon trackedBeacon, HashMap<Integer,Beacon> matchingTrackedBeacons) {
-        if (matchingTrackedBeacons == null) {
-            matchingTrackedBeacons = new HashMap<Integer,Beacon>();
+    private void updateTrackedBeacons(@NonNull Beacon beacon) {
+        HashMap<Integer,Beacon> matchingTrackedBeacons = mBeaconsByKey.get(getBeaconKey(beacon));
+        if (null != matchingTrackedBeacons) {
+            for (Beacon matchingTrackedBeacon : matchingTrackedBeacons.values()) {
+                matchingTrackedBeacon.setRssi(beacon.getRssi());
+                matchingTrackedBeacon.setExtraDataFields(beacon.getDataFields());
+            }
         }
-        matchingTrackedBeacons.put(trackedBeacon.hashCode(), trackedBeacon);
-        mBeaconsByKey.put(getBeaconKey(trackedBeacon), matchingTrackedBeacons);
     }
 
-    private String getBeaconKey(Beacon beacon) {
+    private String getBeaconKey(@NonNull Beacon beacon) {
         if (matchBeaconsByServiceUUID) {
             return beacon.getBluetoothAddress() + beacon.getServiceUuid();
         } else {
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index fd9ed912..bba10079 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -49,11 +49,15 @@ public Callback getCallback() {
     public void addBeacon(Beacon beacon) {
         if (mRangedBeacons.containsKey(beacon)) {
             RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
-            LogManager.d(TAG, "adding %s to existing range for: %s", beacon, rangedBeacon);
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG, "adding %s to existing range for: %s", beacon, rangedBeacon);
+            }
             rangedBeacon.updateBeacon(beacon);
         }
         else {
-            LogManager.d(TAG, "adding %s to new rangedBeacon", beacon);
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG, "adding %s to new rangedBeacon", beacon);
+            }
             mRangedBeacons.put(beacon, new RangedBeacon(beacon));
         }
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index 905f6b0d..d02bef83 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -21,12 +21,14 @@
     protected long lastTrackedTimeMillis = 0;
     Beacon mBeacon;
     protected transient RssiFilter mFilter = null;
+    private int packetCount = 0;
 
     public RangedBeacon(Beacon beacon) {
         updateBeacon(beacon);
     }
 
     public void updateBeacon(Beacon beacon) {
+        packetCount += 1;
         mBeacon = beacon;
         addMeasurement(mBeacon.getRssi());
     }
@@ -45,15 +47,17 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
          if (!getFilter().noMeasurementsAvailable()) {
              double runningAverage = getFilter().calculateRssi();
              mBeacon.setRunningAverageRssi(runningAverage);
+             mBeacon.setRssiMeasurementCount(getFilter().getMeasurementCount());
              LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
         else {
             LogManager.d(TAG, "No measurements available to calculate running average");
         }
+        mBeacon.setPacketCount(packetCount);
+        packetCount = 0;
     }
 
     public void addMeasurement(Integer rssi) {
diff --git a/src/main/java/org/altbeacon/beacon/service/RssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
index 57a587e8..d092c6ac 100644
--- a/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
@@ -9,5 +9,6 @@
     public void addMeasurement(Integer rssi);
     public boolean noMeasurementsAvailable();
     public double calculateRssi();
+    public int getMeasurementCount();
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
index 3f45f7df..7672f3b1 100644
--- a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
@@ -35,6 +35,10 @@ public boolean noMeasurementsAvailable() {
         return mMeasurements.size() == 0;
     }
 
+
+    @Override
+    public int getMeasurementCount() { return mMeasurements.size(); }
+
     @Override
     public double calculateRssi() {
         refreshMeasurements();
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
index d44700cc..8821006e 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -65,7 +65,10 @@
     private MonitoringStatus mMonitoringStatus;
     private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
     private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
-    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+
+    @NonNull
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker = new ExtraDataBeaconTracker();
+
     private Set<BeaconParser> mBeaconParsers  = new HashSet<>();
     private List<Beacon> mSimulatedScanData = null;
     private Context mContext;
@@ -99,7 +102,7 @@ void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
         }
     }
 
-    void setExtraDataBeaconTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+    void setExtraDataBeaconTracker(@NonNull ExtraDataBeaconTracker extraDataBeaconTracker) {
         mExtraDataBeaconTracker = extraDataBeaconTracker;
     }
 
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
index fcd01e4f..9e580d9b 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJob.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -5,6 +5,10 @@
 import android.app.job.JobService;
 import android.bluetooth.le.ScanRecord;
 import android.bluetooth.le.ScanResult;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
 import android.os.Build;
 import android.os.Handler;
 
@@ -35,13 +39,13 @@
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
 public class ScanJob extends JobService {
     private static final String TAG = ScanJob.class.getSimpleName();
-    public static final int PERIODIC_SCAN_JOB_ID = 1;
     /*
         Periodic scan jobs are used in general, but they cannot be started immediately.  So we have
         a second immediate scan job to kick off when scanning gets started or settings changed.
         Once the periodic one gets run, the immediate is cancelled.
      */
-    public static final int IMMEDIATE_SCAN_JOB_ID = 2;
+    private static int sOverrideImmediateScanJobId = -1;
+    private static int sOverridePeriodicScanJobId = -1;
 
     private ScanState mScanState;
     private Handler mStopHandler = new Handler();
@@ -50,8 +54,8 @@
 
     @Override
     public boolean onStartJob(final JobParameters jobParameters) {
-        mScanHelper = new ScanHelper(this);
-        if (jobParameters.getJobId() == IMMEDIATE_SCAN_JOB_ID) {
+        initialzeScanHelper();
+        if (jobParameters.getJobId() == getImmediateScanJobId(this)) {
             LogManager.i(TAG, "Running immediate scan job: instance is "+this);
         }
         else {
@@ -143,7 +147,7 @@ private void startPassiveScanIfNeeded() {
 
     @Override
     public boolean onStopJob(JobParameters params) {
-        if (params.getJobId() == PERIODIC_SCAN_JOB_ID) {
+        if (params.getJobId() == getPeriodicScanJobId(this)) {
             LogManager.i(TAG, "onStopJob called for periodic scan " + this);
         }
         else {
@@ -164,8 +168,8 @@ private void stopScanning() {
         LogManager.d(TAG, "Scanning stopped");
     }
 
-    // Returns true of scanning actually was started, false if it did not need to be
-    private boolean restartScanning() {
+    private void initialzeScanHelper() {
+        mScanHelper = new ScanHelper(this);
         mScanState = ScanState.restore(ScanJob.this);
         mScanState.setLastScanStartTimeMillis(System.currentTimeMillis());
         mScanHelper.setMonitoringStatus(mScanState.getMonitoringStatus());
@@ -175,10 +179,13 @@ private boolean restartScanning() {
         if (mScanHelper.getCycledScanner() == null) {
             mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
         }
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean restartScanning() {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
             mScanHelper.stopAndroidOBackgroundScan();
         }
-
         long scanPeriod = mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod();
         long betweenScanPeriod = mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod();
         mScanHelper.getCycledScanner().setScanPeriods(scanPeriod,
@@ -217,4 +224,93 @@ private boolean startScanning() {
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
         return restartScanning();
     }
+
+    /**
+     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
+     * will default to the value in the AndroidManifest.xml
+     *
+     * WARNING:  If using this library in a multi-process application, this method may not work.
+     * This is considered a private API and may be removed at any time.
+     *
+     * the preferred way of setting this is in the AndroidManifest.xml as so:
+     * <code>
+     * <service android:name="org.altbeacon.beacon.service.ScanJob">
+     * </service>
+     * </code>
+     *
+     * @param id identifier to give the job
+     */
+    @SuppressWarnings("unused")
+    public static void setOverrideImmediateScanJobId(int id) {
+        sOverrideImmediateScanJobId = id;
+    }
+
+    /**
+     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
+     * will default to the value in the AndroidManifest.xml
+     *
+     * WARNING:  If using this library in a multi-process application, this method may not work.
+     * This is considered a private API and may be removed at any time.
+     *
+     * the preferred way of setting this is in the AndroidManifest.xml as so:
+     * <code>
+     * <service android:name="org.altbeacon.beacon.service.ScanJob">
+     *   <meta-data android:name="immmediateScanJobId" android:value="1001" tools:replace="android:value"/>
+     *   <meta-data android:name="periodicScanJobId" android:value="1002" tools:replace="android:value"/>
+     * </service>
+     * </code>
+     *
+     * @param id identifier to give the job
+     */
+    @SuppressWarnings("unused")
+    public static void setOverridePeriodicScanJobId(int id) {
+        sOverridePeriodicScanJobId = id;
+    }
+
+    /**
+     * Returns the job id to be used to schedule this job.  This may be set in the
+     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     * @param context the application context
+     * @return the job id
+     */
+    public static int getImmediateScanJobId(Context context) {
+        if (sOverrideImmediateScanJobId >= 0) {
+            LogManager.i(TAG, "Using ImmediateScanJobId from static override: "+
+                    sOverrideImmediateScanJobId);
+            return sOverrideImmediateScanJobId;
+        }
+        return getJobIdFromManifest(context, "immediateScanJobId");
+    }
+
+    /**
+     * Returns the job id to be used to schedule this job.  This may be set in the
+     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     * @param context the application context
+     * @return the job id
+     */
+    public static int getPeriodicScanJobId(Context context) {
+        if (sOverrideImmediateScanJobId >= 0) {
+            LogManager.i(TAG, "Using PeriodicScanJobId from static override: "+
+                    sOverridePeriodicScanJobId);
+            return sOverridePeriodicScanJobId;
+        }
+        return getJobIdFromManifest(context, "periodicScanJobId");
+    }
+
+    private static int getJobIdFromManifest(Context context, String name) {
+        PackageItemInfo info = null;
+        try {
+            info = context.getPackageManager().getServiceInfo(new ComponentName(context,
+                    ScanJob.class), PackageManager.GET_META_DATA);
+        } catch (PackageManager.NameNotFoundException e) { /* do nothing here */ }
+        if (info != null && info.metaData != null && info.metaData.get(name) != null) {
+            int jobId = info.metaData.getInt(name);
+            LogManager.i(TAG, "Using "+name+" from manifest: "+jobId);
+            return jobId;
+        }
+        else {
+            throw new RuntimeException("Cannot get job id from manifest.  " +
+                    "Make sure that the "+name+" is configured in the manifest for the ScanJob.");
+        }
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
index 2b051d3e..c822af7f 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -158,8 +158,8 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
             if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
                 // If the next time we want to scan is less than 50ms from the periodic scan cycle, then]
                 // we schedule it for that specific time.
-                LogManager.d(TAG, "Scheduling immediate ScanJob to run in " + millisToNextJobStart + " millis");
-                JobInfo immediateJob = new JobInfo.Builder(ScanJob.IMMEDIATE_SCAN_JOB_ID,
+                LogManager.d(TAG, "Scheduling immediate ScanJob to run in "+millisToNextJobStart+" millis");
+                JobInfo immediateJob = new JobInfo.Builder(ScanJob.getImmediateScanJobId(context),
                                                            new ComponentName(context, ScanJob.class))
                         .setPersisted(true) // This makes it restart after reboot
                         .setExtras(new PersistableBundle())
@@ -172,13 +172,14 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
             } else {
                 LogManager.d(TAG, "Not scheduling immediate scan, assuming periodic is about to run");
             }
-        } else {
+        }
+        else {
             LogManager.d(TAG,
                          "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
-            jobScheduler.cancel(ScanJob.IMMEDIATE_SCAN_JOB_ID);
+            jobScheduler.cancel(ScanJob.getImmediateScanJobId(context));
         }
 
-        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(ScanJob.PERIODIC_SCAN_JOB_ID,
+        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(ScanJob.getPeriodicScanJobId(context),
                                                                  new ComponentName(context, ScanJob.class))
                 .setPersisted(true) // This makes it restart after reboot
                 .setRequiresDeviceIdle(false)
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 956dc1e0..a1c9a191 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -444,11 +444,6 @@ private void finishScanCycle() {
                     }
                 }
                 mNextScanCycleStartTime = getNextScanStartTime();
-                System.err.println(
-                        ">>>> CycledLeScanner.finishScanCycle() >> " + "mScanningEnabled = " + mScanningEnabled
-                        + " mBackgroundFlag = " + getBackgroundFlag());
-                System.err.println(">>>> CycledLeScanner.finishScanCycle() >> " + "BeaconManager.getBackgroundMode() = "
-                                   + BeaconManager.getInstanceForApplication(mContext).getBackgroundMode());
                 final boolean avoidExplicitBgStart =
                         Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && getBackgroundFlag();
                 if (mScanningEnabled && !avoidExplicitBgStart) {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index 52e5459d..f74d96bb 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -8,10 +8,12 @@
 import android.bluetooth.le.ScanResult;
 import android.bluetooth.le.ScanSettings;
 import android.content.Context;
+import android.content.Intent;
 import android.os.ParcelUuid;
 import android.os.SystemClock;
 import android.support.annotation.MainThread;
 import android.support.annotation.WorkerThread;
+import android.support.v4.content.LocalBroadcastManager;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -28,7 +30,7 @@
     private BluetoothLeScanner mScanner;
     private ScanCallback leScanCallback;
     private long mBackgroundLScanStartTime = 0l;
-    private long mBackgroundLScanFirstDetectionTime = 0l;
+    private long mBackgroundLScanFirstDetectionTime = 0;
     private boolean mMainScanCycleActive = false;
     private final BeaconManager mBeaconManager;
 
@@ -174,6 +176,12 @@ protected void startScan() {
         } else {
             LogManager.d(TAG, "starting non-filtered scan in SCAN_MODE_LOW_LATENCY");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)).build();
+            // We create wildcard scan filters that match any advertisement so that we can detect
+            // beacons in foreground mode even if the screen is off.  This is a necessary workaround
+            // for a change in Android 8.1 that blocks scan results when the screen is off unless
+            // there is a scan filter associatd with the scan.  Prior to 8.1, filters could just be
+            // left null.  The wildcard filter matches everything.
+            filters = new ScanFilterUtils().createWildcardScanFilters();
         }
 
         if (settings != null) {
@@ -316,6 +324,9 @@ public void onBatchScanResults(List<ScanResult> results) {
                 @MainThread
                 @Override
                 public void onScanFailed(int errorCode) {
+                    Intent intent = new Intent("onScanFailed");
+                    intent.putExtra("errorCode", errorCode);
+                    LocalBroadcastManager.getInstance(CycledLeScannerForLollipop.this.mContext).sendBroadcast(intent);
                     switch (errorCode) {
                         case SCAN_FAILED_ALREADY_STARTED:
                             LogManager.e(
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java b/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
index dc4ee965..dab1925f 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
@@ -26,6 +26,13 @@
         public byte[] mask;
     }
 
+    public List<ScanFilter> createWildcardScanFilters() {
+        List<ScanFilter> scanFilters = new ArrayList<ScanFilter>();
+        ScanFilter.Builder builder = new ScanFilter.Builder();
+        scanFilters.add(builder.build());
+        return scanFilters;
+    }
+
     public List<ScanFilterData> createScanFilterDataForBeaconParser(BeaconParser beaconParser) {
         ArrayList<ScanFilterData> scanFilters = new ArrayList<ScanFilterData>();
         for (int manufacturer : beaconParser.getHardwareAssistManufacturers()) {
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java b/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
new file mode 100644
index 00000000..96425e52
--- /dev/null
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
@@ -0,0 +1,457 @@
+package org.altbeacon.bluetooth;
+
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.TaskStackBuilder;
+import android.app.job.JobScheduler;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.AdvertiseCallback;
+import android.bluetooth.le.AdvertiseData;
+import android.bluetooth.le.AdvertiseSettings;
+import android.bluetooth.le.BluetoothLeAdvertiser;
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanResult;
+import android.bluetooth.le.AdvertiseSettings.Builder;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Handler;
+import android.os.PersistableBundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.support.v4.app.NotificationCompat;
+import android.support.v4.content.LocalBroadcastManager;
+import java.util.List;
+
+import org.altbeacon.beacon.logging.LogManager;
+
+/**
+ *
+ * Utility class for checking the health of the bluetooth stack on the device by running two kinds
+ * of tests: scanning and transmitting.  The class looks for specific failure codes from these
+ * tests to determine if the bluetooth stack is in a bad state and if so, optionally cycle power to
+ * bluetooth to try and fix the problem.  This is known to work well on some Android devices.
+ *
+ * The tests may be called directly, or set up to run automatically approximately every 15 minutes.
+ * To set up in an automated way:
+ *
+ * <code>
+ *   BluetoothMedic medic = BluetoothMedic.getInstance();
+ *   medic.enablePowerCycleOnFailures(context);
+ *   medic.enablePeriodicTests(context, BluetoothMedic.SCAN_TEST | BluetoothMedic.TRANSMIT_TEST);
+ * </code>
+ *
+ * To set up in a manual way:
+ *
+ * <code>
+ *   BluetoothMedic medic = BluetoothMedic.getInstance();
+ *   medic.enablePowerCycleOnFailures(context);
+ *   if (!medic.runScanTest(context)) {
+ *     // Bluetooth stack is in a bad state
+ *   }
+ *   if (!medic.runTransmitterTest(context)) {
+ *     // Bluetooth stack is in a bad state
+ *   }
+ *
+ */
+
+@SuppressWarnings("javadoc")
+public class BluetoothMedic {
+
+    /**
+     * Indicates that no test should be run by the BluetoothTestJob
+     */
+    @SuppressWarnings("WeakerAccess")
+    public static final int NO_TEST = 0;
+    /**
+     * Indicates that the transmitter test should be run by the BluetoothTestJob
+     */
+    @SuppressWarnings("WeakerAccess")
+    public static final int TRANSMIT_TEST = 2;
+    /**
+     * Indicates that the bluetooth scan test should be run by the BluetoothTestJob
+     */
+    @SuppressWarnings("WeakerAccess")
+    public static final int SCAN_TEST = 1;
+    private static final String TAG = BluetoothMedic.class.getSimpleName();
+    @Nullable
+    private BluetoothAdapter mAdapter;
+    @Nullable
+    private LocalBroadcastManager mLocalBroadcastManager;
+    @NonNull
+    private Handler mHandler = new Handler();
+    private int mTestType = 0;
+    @Nullable
+    private Boolean mTransmitterTestResult = null;
+    @Nullable
+    private Boolean mScanTestResult = null;
+    private boolean mNotificationsEnabled = false;
+    private int mNotificationIcon = 0;
+    private long mLastBluetoothPowerCycleTime = 0L;
+    private static final long MIN_MILLIS_BETWEEN_BLUETOOTH_POWER_CYCLES = 60000L;
+    @Nullable
+    private static BluetoothMedic sInstance;
+    @RequiresApi(21)
+    private BroadcastReceiver mBluetoothEventReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            LogManager.d(BluetoothMedic.TAG, "Broadcast notification received.");
+            int errorCode;
+            String action = intent.getAction();
+            if (action != null) {
+                if(action.equalsIgnoreCase("onScanFailed")) {
+                    errorCode = intent.getIntExtra("errorCode", -1);
+                    if(errorCode == 2) {
+                        BluetoothMedic.this.sendNotification(context, "scan failed",
+                                "Power cycling bluetooth");
+                        LogManager.d(BluetoothMedic.TAG,
+                                "Detected a SCAN_FAILED_APPLICATION_REGISTRATION_FAILED.  We need to cycle bluetooth to recover");
+                        if(!BluetoothMedic.this.cycleBluetoothIfNotTooSoon()) {
+                            BluetoothMedic.this.sendNotification(context, "scan failed", "" +
+                                    "Cannot power cycle bluetooth again");
+                        }
+                    }
+                } else if(action.equalsIgnoreCase("onStartFailed")) {
+                    errorCode = intent.getIntExtra("errorCode", -1);
+                    if(errorCode == 4) {
+                        BluetoothMedic.this.sendNotification(context, "advertising failed",
+                                "Expected failure.  Power cycling.");
+                        if(!BluetoothMedic.this.cycleBluetoothIfNotTooSoon()) {
+                            BluetoothMedic.this.sendNotification(context, "advertising failed",
+                                    "Cannot power cycle bluetooth again");
+                        }
+                    }
+                } else {
+                    LogManager.d(BluetoothMedic.TAG, "Unknown event.");
+                }
+            }
+        }
+    };
+
+
+    /**
+     * Get a singleton instance of the BluetoothMedic
+     * @return
+     */
+    public static BluetoothMedic getInstance() {
+        if(sInstance == null) {
+            sInstance = new BluetoothMedic();
+        }
+        return sInstance;
+    }
+
+    private BluetoothMedic() {
+    }
+
+    @RequiresApi(21)
+    private void initializeWithContext(Context context) {
+        if (this.mAdapter == null || this.mLocalBroadcastManager == null) {
+            BluetoothManager manager = (BluetoothManager)context.getSystemService(Context.BLUETOOTH_SERVICE);
+            if(manager == null) {
+                throw new NullPointerException("Cannot get BluetoothManager");
+            } else {
+                this.mAdapter = manager.getAdapter();
+                this.mLocalBroadcastManager = LocalBroadcastManager.getInstance(context);
+            }
+        }
+    }
+
+    /**
+     * If set to true, bluetooth will be power cycled on any tests run that determine bluetooth is
+     * in a bad state.
+     *
+     * @param context
+     */
+    @SuppressWarnings("unused")
+    @RequiresApi(21)
+    public void enablePowerCycleOnFailures(Context context) {
+        initializeWithContext(context);
+        if (this.mLocalBroadcastManager != null) {
+            this.mLocalBroadcastManager.registerReceiver(this.mBluetoothEventReceiver,
+                    new IntentFilter("onScanFailed"));
+            this.mLocalBroadcastManager.registerReceiver(this.mBluetoothEventReceiver,
+                    new IntentFilter("onStartFailure"));
+            LogManager.d(TAG,
+                    "Medic monitoring for transmission and scan failure notifications with receiver: "
+                            + this.mBluetoothEventReceiver);
+        }
+    }
+
+    /**
+     * Calling this method starts a scheduled job that will run tests of the specified type to
+     * make sure bluetooth is OK and cycle power to bluetooth if needed and configured by
+     * enablePowerCycleOnFailures
+     *
+     * @param context
+     * @param testType e.g. BluetoothMedic.TRANSMIT_TEST | BluetoothMedic.SCAN_TEST
+     */
+    @SuppressWarnings("unused")
+    @RequiresApi(21)
+    public void enablePeriodicTests(Context context, int testType) {
+        initializeWithContext(context);
+        this.mTestType = testType;
+        LogManager.d(TAG, "Medic scheduling periodic tests of types " + testType);
+        this.scheduleRegularTests(context);
+    }
+
+    /**
+     * Starts up a brief blueooth scan with the intent of seeing if it results in an error condition
+     * indicating the bluetooth stack may be in a bad state.
+     *
+     * If the failure error code matches a pattern known to be associated with a bad bluetooth stack
+     * state, then the bluetooth stack is turned off and then back on after a short delay in order
+     * to try to recover.
+     *
+     * @return false if the test indicates a failure indicating a bad state of the bluetooth stack
+     */
+    @SuppressWarnings({"unused","WeakerAccess"})
+    @RequiresApi(21)
+    public boolean runScanTest(final Context context) {
+        initializeWithContext(context);
+        this.mScanTestResult = null;
+        LogManager.i(TAG, "Starting scan test");
+        final long testStartTime = System.currentTimeMillis();
+        if (this.mAdapter != null) {
+            final BluetoothLeScanner scanner = this.mAdapter.getBluetoothLeScanner();
+            final ScanCallback callback = new ScanCallback() {
+                public void onScanResult(int callbackType, ScanResult result) {
+                    super.onScanResult(callbackType, result);
+                    BluetoothMedic.this.mScanTestResult = true;
+                    LogManager.i(BluetoothMedic.TAG, "Scan test succeeded");
+                    try {
+                        scanner.stopScan(this);
+                    }
+                    catch (IllegalStateException e) { /* do nothing */ } // caught if bluetooth is off here
+                }
+
+                public void onBatchScanResults(List<ScanResult> results) {
+                    super.onBatchScanResults(results);
+                }
+
+                public void onScanFailed(int errorCode) {
+                    super.onScanFailed(errorCode);
+                    LogManager.d(BluetoothMedic.TAG, "Sending onScanFailed broadcast with " +
+                            BluetoothMedic.this.mLocalBroadcastManager);
+                    Intent intent = new Intent("onScanFailed");
+                    intent.putExtra("errorCode", errorCode);
+                    if (BluetoothMedic.this.mLocalBroadcastManager != null) {
+                        BluetoothMedic.this.mLocalBroadcastManager.sendBroadcast(intent);
+                    }
+                    LogManager.d(BluetoothMedic.TAG, "broadcast: " + intent +
+                            " should be received by " + BluetoothMedic.this.mBluetoothEventReceiver);
+                    if(errorCode == 2) {
+                        LogManager.w(BluetoothMedic.TAG,
+                                "Scan test failed in a way we consider a failure");
+                        BluetoothMedic.this.sendNotification(context,
+                                "scan failed", "bluetooth not ok");
+                        BluetoothMedic.this.mScanTestResult = false;
+                    } else {
+                        LogManager.i(BluetoothMedic.TAG,
+                                "Scan test failed in a way we do not consider a failure");
+                        BluetoothMedic.this.mScanTestResult = true;
+                    }
+
+                }
+            };
+            if(scanner != null) {
+                scanner.startScan(callback);
+                while (this.mScanTestResult == null) {
+                    LogManager.d(TAG, "Waiting for scan test to complete...");
+
+                    try {
+                        Thread.sleep(1000L);
+                    } catch (InterruptedException e) { /* do nothing */ }
+
+                    if (System.currentTimeMillis() - testStartTime > 5000L) {
+                        LogManager.d(TAG, "Timeout running scan test");
+                        break;
+                    }
+                }
+                try {
+                    scanner.stopScan(callback);
+                } catch (IllegalStateException e) { /* do nothing */ } // caught if bluetooth is off here
+            }
+            else {
+                LogManager.d(TAG, "Cannot get scanner");
+            }
+        }
+
+
+
+        LogManager.d(TAG, "scan test complete");
+        return this.mScanTestResult == null || this.mScanTestResult;
+    }
+
+    /**
+     * Starts up a beacon transmitter with the intent of seeing if it results in an error condition
+     * indicating the bluetooth stack may be in a bad state.
+     *
+     * If the failure error code matches a pattern known to be associated with a bad bluetooth stack
+     * state, then the bluetooth stack is turned off and then back on after a short delay in order
+     * to try to recover.
+     *
+     * @return false if the test indicates a failure indicating a bad state of the bluetooth stack
+     */
+    @SuppressWarnings({"unused","WeakerAccess"})
+    @RequiresApi(21)
+    public boolean runTransmitterTest(final Context context) {
+        initializeWithContext(context);
+        this.mTransmitterTestResult = null;
+        long testStartTime = System.currentTimeMillis();
+        if (this.mAdapter != null) {
+            final BluetoothLeAdvertiser advertiser = this.mAdapter.getBluetoothLeAdvertiser();
+            if(advertiser != null) {
+                AdvertiseSettings settings = (new Builder()).setAdvertiseMode(0).build();
+                AdvertiseData data = (new android.bluetooth.le.AdvertiseData.Builder())
+                        .addManufacturerData(0, new byte[]{0}).build();
+                LogManager.i(TAG, "Starting transmitter test");
+                advertiser.startAdvertising(settings, data, new AdvertiseCallback() {
+                    public void onStartSuccess(AdvertiseSettings settingsInEffect) {
+                        super.onStartSuccess(settingsInEffect);
+                        LogManager.i(BluetoothMedic.TAG, "Transmitter test succeeded");
+                        advertiser.stopAdvertising(this);
+                        BluetoothMedic.this.mTransmitterTestResult = true;
+                    }
+
+                    public void onStartFailure(int errorCode) {
+                        super.onStartFailure(errorCode);
+                        Intent intent = new Intent("onStartFailed");
+                        intent.putExtra("errorCode", errorCode);
+                        LogManager.d(BluetoothMedic.TAG, "Sending onStartFailure broadcast with "
+                                + BluetoothMedic.this.mLocalBroadcastManager);
+                        if (BluetoothMedic.this.mLocalBroadcastManager != null) {
+                            BluetoothMedic.this.mLocalBroadcastManager.sendBroadcast(intent);
+                        }
+                        if(errorCode == 4) {
+                            BluetoothMedic.this.mTransmitterTestResult = false;
+                            LogManager.w(BluetoothMedic.TAG,
+                                    "Transmitter test failed in a way we consider a test failure");
+                            BluetoothMedic.this.sendNotification(context, "transmitter failed",
+                                    "bluetooth not ok");
+                        } else {
+                            BluetoothMedic.this.mTransmitterTestResult = true;
+                            LogManager.i(BluetoothMedic.TAG,
+                                    "Transmitter test failed, but not in a way we consider a test failure");
+                        }
+
+                    }
+                });
+            } else {
+                LogManager.d(TAG, "Cannot get advertiser");
+            }
+            while(this.mTransmitterTestResult == null) {
+                LogManager.d(TAG, "Waiting for transmitter test to complete...");
+
+                try {
+                    Thread.sleep(1000L);
+                } catch (InterruptedException e) { /* do nothing */ }
+
+                if(System.currentTimeMillis() - testStartTime > 5000L) {
+                    LogManager.d(TAG, "Timeout running transmitter test");
+                    break;
+                }
+            }
+        }
+
+        LogManager.d(TAG, "transmitter test complete");
+        return this.mTransmitterTestResult != null && this.mTransmitterTestResult;
+    }
+
+    /**
+     *
+     * Configure whether to send user-visible notification warnings when bluetooth power is cycled.
+     *
+     * @param enabled if true, a user-visible notification is sent to tell the user when
+     * @param icon the icon drawable to use in notifications (e.g. R.drawable.notification_icon)
+     */
+    @SuppressWarnings("unused")
+    @RequiresApi(21)
+    public void setNotificationsEnabled(boolean enabled, int icon) {
+        this.mNotificationsEnabled = enabled;
+        this.mNotificationIcon = icon;
+    }
+
+    @RequiresApi(21)
+    private boolean cycleBluetoothIfNotTooSoon() {
+        long millisSinceLastCycle = System.currentTimeMillis() - this.mLastBluetoothPowerCycleTime;
+        if(millisSinceLastCycle < MIN_MILLIS_BETWEEN_BLUETOOTH_POWER_CYCLES) {
+            LogManager.d(TAG, "Not cycling bluetooth because we just did so " +
+                    millisSinceLastCycle + " milliseconds ago.");
+            return false;
+        } else {
+            this.mLastBluetoothPowerCycleTime = System.currentTimeMillis();
+            LogManager.d(TAG, "Power cycling bluetooth");
+            this.cycleBluetooth();
+            return true;
+        }
+    }
+
+    @RequiresApi(21)
+    private void cycleBluetooth() {
+        LogManager.d(TAG, "Power cycling bluetooth");
+        LogManager.d(TAG, "Turning Bluetooth off.");
+        if (mAdapter != null) {
+            this.mAdapter.disable();
+            this.mHandler.postDelayed(new Runnable() {
+                public void run() {
+                    LogManager.d(BluetoothMedic.TAG, "Turning Bluetooth back on.");
+                    if (BluetoothMedic.this.mAdapter != null) {
+                        BluetoothMedic.this.mAdapter.enable();
+                    }
+                }
+            }, 1000L);
+        }
+        else {
+            LogManager.w(TAG, "Cannot cycle bluetooth.  Manager is null.");
+        }
+    }
+
+    @RequiresApi(21)
+    private void sendNotification(Context context, String message, String detail) {
+        initializeWithContext(context);
+        if(this.mNotificationsEnabled) {
+            NotificationCompat.Builder builder =
+                    (new NotificationCompat.Builder(context, "err"))
+                            .setContentTitle("BluetoothMedic: " + message)
+                            .setSmallIcon(mNotificationIcon)
+                            .setVibrate(new long[]{200L, 100L, 200L}).setContentText(detail);
+            TaskStackBuilder stackBuilder = TaskStackBuilder.create(context);
+            stackBuilder.addNextIntent(new Intent("NoOperation"));
+
+            PendingIntent resultPendingIntent = stackBuilder.getPendingIntent(
+                    0,
+                    PendingIntent.FLAG_UPDATE_CURRENT
+            );
+            builder.setContentIntent(resultPendingIntent);
+            NotificationManager notificationManager =
+                    (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
+            if (notificationManager != null) {
+                notificationManager.notify(1, builder.build());
+            }
+        }
+    }
+
+    @RequiresApi(21)
+    private void scheduleRegularTests(Context context) {
+        initializeWithContext(context);
+        ComponentName serviceComponent = new ComponentName(context, BluetoothTestJob.class);
+        android.app.job.JobInfo.Builder builder =
+                new android.app.job.JobInfo.Builder(BluetoothTestJob.getJobId(context), serviceComponent);
+        builder.setRequiresCharging(false);
+        builder.setRequiresDeviceIdle(false);
+        builder.setPeriodic(900000L); // 900 secs is 15 minutes -- the minimum time on Android
+        builder.setPersisted(true);
+        PersistableBundle bundle = new PersistableBundle();
+        bundle.putInt("test_type", this.mTestType);
+        builder.setExtras(bundle);
+        JobScheduler jobScheduler = (JobScheduler)
+                context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        if (jobScheduler != null) {
+            jobScheduler.schedule(builder.build());
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java b/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java
new file mode 100644
index 00000000..8d70bd98
--- /dev/null
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java
@@ -0,0 +1,138 @@
+package org.altbeacon.bluetooth;
+
+import android.app.job.JobParameters;
+import android.app.job.JobService;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.BeaconService;
+
+/**
+ * @hide
+ * Internal library class.  Do not use directly.
+ */
+@SuppressWarnings("javadoc")
+@RequiresApi(21)
+public class BluetoothTestJob extends JobService {
+    private static final String TAG = BluetoothTestJob.class.getSimpleName();
+    @Nullable
+    private Handler mHandler = null;
+    @Nullable
+    private HandlerThread mHandlerThread = null;
+    private static int sOverrideJobId = -1;
+
+    /**
+     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
+     * will default to he value in the AndroidManifest.xml
+     *
+     * WARNING:  If using this library in a multi-process application, this method may not work.
+     * This is considered a private API and may be removed at any time.
+     *
+     * the preferred way of setting this is in the AndroidManifest.xml as so:
+     * <code>
+     * <service android:name="org.altbeacon.bluetooth.BluetoothTestJob">
+     *   <meta-data android:name="jobId" android:value="1001" tools:replace="android:value"/>
+     * </service>
+     * </code>
+     *
+     * @param id
+     */
+    public static void setOverrideJobId(int id) {
+        sOverrideJobId = id;
+    }
+
+    /**
+     * Returns the job id to be used to schedule this job.  This may be set in the
+     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     * @param context
+     * @return
+     */
+    public static int getJobId(Context context) {
+        if (sOverrideJobId >= 0) {
+            LogManager.i(TAG, "Using BluetoothTestJob JobId from static override: "+
+                    sOverrideJobId);
+            return sOverrideJobId;
+        }
+        PackageItemInfo info = null;
+        try {
+            info = context.getPackageManager().getServiceInfo(new ComponentName(context,
+                    BluetoothTestJob.class), PackageManager.GET_META_DATA);
+        } catch (PackageManager.NameNotFoundException e) { /* do nothing here */ }
+        if (info != null && info.metaData != null && info.metaData.get("jobId") != null) {
+            int jobId = info.metaData.getInt("jobId");
+            LogManager.i(TAG, "Using BluetoothTestJob JobId from manifest: "+jobId);
+            return jobId;
+        }
+        else {
+            throw new RuntimeException("Cannot get job id from manifest.  " +
+                    "Make sure that the BluetoothTestJob is configured in the manifest.");
+        }
+    }
+
+    public BluetoothTestJob() {
+    }
+
+    public boolean onStartJob(final JobParameters params) {
+        if(this.mHandlerThread == null) {
+            this.mHandlerThread = new HandlerThread("BluetoothTestThread");
+            this.mHandlerThread.start();
+        }
+
+        if(this.mHandler == null) {
+            this.mHandler = new Handler(this.mHandlerThread.getLooper());
+        }
+
+        this.mHandler.post(new Runnable() {
+            public void run() {
+                boolean found = false;
+                LogManager.i(BluetoothTestJob.TAG, "Bluetooth Test Job running");
+                int testType = params.getExtras().getInt("test_type");
+                if(testType == BluetoothMedic.NO_TEST) {
+                    found = true;
+                    LogManager.d(BluetoothTestJob.TAG, "No test specified.  Done with job.");
+                }
+
+                if((testType & BluetoothMedic.SCAN_TEST) == BluetoothMedic.SCAN_TEST) {
+                    LogManager.d(BluetoothTestJob.TAG, "Scan test specified.");
+                    found = true;
+                    if (!BluetoothMedic.getInstance().runScanTest(BluetoothTestJob.this)) {
+                        LogManager.d(TAG, "scan test failed");
+                    }
+                }
+
+                if((testType & BluetoothMedic.TRANSMIT_TEST) == BluetoothMedic.TRANSMIT_TEST) {
+                    if(found) {
+                        try {
+                            Thread.sleep(10000L);
+                        } catch (InterruptedException e) {
+                            /* do nothing */
+                        }
+                    }
+
+                    LogManager.d(BluetoothTestJob.TAG, "Transmit test specified.");
+                    found = true;
+                    if (!BluetoothMedic.getInstance().runTransmitterTest(BluetoothTestJob.this)) {
+                        LogManager.d(TAG, "transmit test failed");
+                    }
+                }
+
+                if(!found) {
+                    LogManager.w(BluetoothTestJob.TAG, "Unknown test type:" + testType + "  Exiting.");
+                }
+
+                BluetoothTestJob.this.jobFinished(params, false);
+            }
+        });
+        return true;
+    }
+
+    public boolean onStopJob(JobParameters params) {
+        return true;
+    }
+}
diff --git a/src/test/java/org/altbeacon/beacon/AltBeaconTest.java b/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
index 2519ad13..2d726781 100644
--- a/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
@@ -2,15 +2,20 @@
 
 import android.os.Parcel;
 
-import static org.junit.Assert.assertEquals;
-
-import org.altbeacon.beacon.logging.Loggers;
-import org.robolectric.RobolectricTestRunner;
-
-import org.junit.runner.RunWith;
+import org.junit.After;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+import java.util.Arrays;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.hasProperty;
+import static org.junit.Assert.assertEquals;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -26,36 +31,128 @@
 4. Expand the System.err section
  */
 public class AltBeaconTest {
+    private Parcel aParcel = null;
 
-  public static byte[] hexStringToByteArray(String s) {
-      int len = s.length();
-      byte[] data = new byte[len / 2];
-      for (int i = 0; i < len; i += 2) {
-          data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                               + Character.digit(s.charAt(i+1), 16));
-      }
-      return data;
-  }
-
-  @Test
-  public void testRecognizeBeacon() {
-    byte[] bytes = hexStringToByteArray("02011a1bff1801beac2f234454cf6d4a0fadf2f4911ba9ffa600010002c509");
-    AltBeaconParser parser = new AltBeaconParser();
-    Beacon beacon = parser.fromScanData(bytes, -55, null);
-    assertEquals("manData should be parsed", 9, ((AltBeacon) beacon).getMfgReserved() );
-  }
+    @After
+    public void after() {
+        // Clean up any obtained parcel
+        if (null != aParcel) {
+            aParcel.recycle();
+        }
+    }
+
+    public static byte[] hexStringToByteArray(String s) {
+        int len = s.length();
+        byte[] data = new byte[len / 2];
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
+                    + Character.digit(s.charAt(i+1), 16));
+        }
+        return data;
+    }
 
+    @Test
+    public void testRecognizeBeacon() {
+        byte[] bytes = hexStringToByteArray("02011a1bff1801beac2f234454cf6d4a0fadf2f4911ba9ffa600010002c509");
+        AltBeaconParser parser = new AltBeaconParser();
+        Beacon beacon = parser.fromScanData(bytes, -55, null);
+        assertEquals("manData should be parsed", 9, ((AltBeacon) beacon).getMfgReserved() );
+    }
 
     @Test
     public void testCanSerializeParcelable() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
-        Beacon beacon = new AltBeacon.Builder().setMfgReserved(7).setId1("1").setId2("2").setId3("3").setRssi(4)
-                .setBeaconTypeCode(5).setTxPower(6)
-                .setBluetoothAddress("1:2:3:4:5:6").build();
-        beacon.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Beacon beacon2 = new AltBeacon(parcel);
-        assertEquals("beaconMfgReserved is same after deserialization", ((AltBeacon)beacon).getMfgReserved(), ((AltBeacon)beacon2).getMfgReserved());
+        final Beacon original = new AltBeacon.Builder().setMfgReserved(2)
+                                                       .setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                                                       .setBluetoothName("Any Bluetooth")
+                                                       .setBeaconTypeCode(1)
+                                                       .setExtraDataFields(Arrays.asList(4L, 5L))
+                                                       .setId1("6")
+                                                       .setId2("7")
+                                                       .setId3("8")
+                                                       .setManufacturer(10)
+                                                       .setMultiFrameBeacon(true)
+                                                       .setParserIdentifier("Any Parser ID")
+                                                       .setRssi(-11)
+                                                       .setRunningAverageRssi(-12.3)
+                                                       .setServiceUuid(13)
+                                                       .setTxPower(14)
+                                                       .build();
+        original.setPacketCount(15);
+        original.setRssiMeasurementCount(16);
+
+        aParcel = Parcel.obtain();
+        original.writeToParcel(aParcel, 0);
+        aParcel.setDataPosition(0);
+        final AltBeacon parceled = AltBeacon.CREATOR.createFromParcel(aParcel);
+        assertThat(
+                parceled,
+                allOf(
+                        hasProperty("bluetoothAddress", equalTo("aa:bb:cc:dd:ee:ff")),
+                        hasProperty("bluetoothName", equalTo("Any Bluetooth")),
+                        hasProperty("beaconTypeCode", equalTo(1)),
+                        hasProperty("dataFields", equalTo(Arrays.asList(2L))),
+                        hasProperty("extraDataFields", equalTo(Arrays.asList(4L, 5L))),
+                        hasProperty("id1", equalTo(Identifier.fromInt(6))),
+                        hasProperty("id2", equalTo(Identifier.fromInt(7))),
+                        hasProperty("id3", equalTo(Identifier.fromInt(8))),
+                        hasProperty("manufacturer", equalTo(10)),
+                        hasProperty("multiFrameBeacon", equalTo(true)),
+                        hasProperty("parserIdentifier", equalTo("Any Parser ID")),
+                        hasProperty("rssi", equalTo(-11)),
+                        hasProperty("runningAverageRssi", equalTo(-12.3)),
+                        hasProperty("serviceUuid", equalTo(13)),
+                        hasProperty("txPower", equalTo(14)),
+                        hasProperty("mfgReserved", equalTo(2)),
+                        hasProperty("packetCount", equalTo(15)),
+                        hasProperty("measurementCount", equalTo(16))
+                )
+        );
+    }
+
+
+    @Test
+    public void copyingBeaconTransfersAllFields() {
+        final Beacon original = new AltBeacon.Builder().setMfgReserved(2)
+                                                       .setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                                                       .setBluetoothName("Any Bluetooth")
+                                                       .setBeaconTypeCode(1)
+                                                       .setExtraDataFields(Arrays.asList(4L, 5L))
+                                                       .setId1("6")
+                                                       .setId2("7")
+                                                       .setId3("8")
+                                                       .setManufacturer(10)
+                                                       .setMultiFrameBeacon(true)
+                                                       .setParserIdentifier("Any Parser ID")
+                                                       .setRssi(-11)
+                                                       .setRunningAverageRssi(-12.3)
+                                                       .setServiceUuid(13)
+                                                       .setTxPower(14)
+                                                       .build();
+        original.setPacketCount(15);
+        original.setRssiMeasurementCount(16);
+        final AltBeacon copied = new AltBeacon(original);
+        assertThat(
+                copied,
+                allOf(
+                        hasProperty("bluetoothAddress", equalTo("aa:bb:cc:dd:ee:ff")),
+                        hasProperty("bluetoothName", equalTo("Any Bluetooth")),
+                        hasProperty("beaconTypeCode", equalTo(1)),
+                        hasProperty("dataFields", equalTo(Arrays.asList(2L))),
+                        hasProperty("extraDataFields", equalTo(Arrays.asList(4L, 5L))),
+                        hasProperty("id1", equalTo(Identifier.fromInt(6))),
+                        hasProperty("id2", equalTo(Identifier.fromInt(7))),
+                        hasProperty("id3", equalTo(Identifier.fromInt(8))),
+                        hasProperty("manufacturer", equalTo(10)),
+                        hasProperty("multiFrameBeacon", equalTo(true)),
+                        hasProperty("parserIdentifier", equalTo("Any Parser ID")),
+                        hasProperty("rssi", equalTo(-11)),
+                        hasProperty("runningAverageRssi", equalTo(-12.3)),
+                        hasProperty("serviceUuid", equalTo(13)),
+                        hasProperty("txPower", equalTo(14)),
+                        hasProperty("packetCount", equalTo(15)),
+                        hasProperty("measurementCount", equalTo(16))
+                )
+        );
     }
 }
diff --git a/src/test/java/org/altbeacon/beacon/BeaconTest.java b/src/test/java/org/altbeacon/beacon/BeaconTest.java
index d95fb0e7..63d37ea8 100644
--- a/src/test/java/org/altbeacon/beacon/BeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/BeaconTest.java
@@ -1,11 +1,18 @@
 package org.altbeacon.beacon;
 
+import android.os.Parcel;
+
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.hasProperty;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -35,11 +42,21 @@
 4. Expand the System.err section
  */
 public class BeaconTest {
+    private Parcel aParcel = null;
 
     @Before
     public void before() {
         Beacon.setHardwareEqualityEnforced(false);
     }
+
+    @After
+    public void after() {
+        // Clean up any obtained parcel
+        if (null != aParcel) {
+            aParcel.recycle();
+        }
+    }
+
     @Test
     public void testAccessBeaconIdentifiers() {
         Beacon beacon = new AltBeacon.Builder().setMfgReserved(7).setId1("1").setId2("2").setId3("3").setRssi(4)
@@ -206,6 +223,102 @@ public void testHashCodeWithNullIdentifier() {
                 .build();
         assertTrue("hashCode() should not throw exception", beacon.hashCode() >= Integer.MIN_VALUE);
     }
+
+    @Test
+    public void parcelingBeaconContainsAllFields() {
+        final Beacon original = new Beacon.Builder().setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                                                    .setBluetoothName("Any Bluetooth")
+                                                    .setBeaconTypeCode(1)
+                                                    .setDataFields(Arrays.asList(2L, 3L))
+                                                    .setExtraDataFields(Arrays.asList(4L, 5L))
+                                                    .setId1("6")
+                                                    .setId2("7")
+                                                    .setId3("8")
+                                                    .setManufacturer(10)
+                                                    .setMultiFrameBeacon(true)
+                                                    .setParserIdentifier("Any Parser ID")
+                                                    .setRssi(-11)
+                                                    .setRunningAverageRssi(-12.3)
+                                                    .setServiceUuid(13)
+                                                    .setTxPower(14)
+                                                    .build();
+        original.setPacketCount(15);
+        original.setRssiMeasurementCount(16);
+
+        aParcel = Parcel.obtain();
+        original.writeToParcel(aParcel, 0);
+        aParcel.setDataPosition(0);
+        final Beacon parceled = Beacon.CREATOR.createFromParcel(aParcel);
+        assertThat(
+                parceled,
+                allOf(
+                        hasProperty("bluetoothAddress", equalTo("aa:bb:cc:dd:ee:ff")),
+                        hasProperty("bluetoothName", equalTo("Any Bluetooth")),
+                        hasProperty("beaconTypeCode", equalTo(1)),
+                        hasProperty("dataFields", equalTo(Arrays.asList(2L, 3L))),
+                        hasProperty("extraDataFields", equalTo(Arrays.asList(4L, 5L))),
+                        hasProperty("id1", equalTo(Identifier.fromInt(6))),
+                        hasProperty("id2", equalTo(Identifier.fromInt(7))),
+                        hasProperty("id3", equalTo(Identifier.fromInt(8))),
+                        hasProperty("manufacturer", equalTo(10)),
+                        hasProperty("multiFrameBeacon", equalTo(true)),
+                        hasProperty("parserIdentifier", equalTo("Any Parser ID")),
+                        hasProperty("rssi", equalTo(-11)),
+                        hasProperty("runningAverageRssi", equalTo(-12.3)),
+                        hasProperty("serviceUuid", equalTo(13)),
+                        hasProperty("txPower", equalTo(14)),
+                        hasProperty("packetCount", equalTo(15)),
+                        hasProperty("measurementCount", equalTo(16))
+                )
+        );
+    }
+
+    @Test
+    public void copyingBeaconContainsAllFields() {
+        final Beacon original = new Beacon.Builder().setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                                                    .setBluetoothName("Any Bluetooth")
+                                                    .setBeaconTypeCode(1)
+                                                    .setDataFields(Arrays.asList(2L, 3L))
+                                                    .setExtraDataFields(Arrays.asList(4L, 5L))
+                                                    .setId1("6")
+                                                    .setId2("7")
+                                                    .setId3("8")
+                                                    .setManufacturer(10)
+                                                    .setMultiFrameBeacon(true)
+                                                    .setParserIdentifier("Any Parser ID")
+                                                    .setRssi(-11)
+                                                    .setRunningAverageRssi(-12.3)
+                                                    .setServiceUuid(13)
+                                                    .setTxPower(14)
+                                                    .build();
+        original.setPacketCount(15);
+        original.setRssiMeasurementCount(16);
+
+        final Beacon copied = new Beacon(original);
+        assertThat(
+                copied,
+                allOf(
+                        hasProperty("bluetoothAddress", equalTo("aa:bb:cc:dd:ee:ff")),
+                        hasProperty("bluetoothName", equalTo("Any Bluetooth")),
+                        hasProperty("beaconTypeCode", equalTo(1)),
+                        hasProperty("dataFields", equalTo(Arrays.asList(2L, 3L))),
+                        hasProperty("extraDataFields", equalTo(Arrays.asList(4L, 5L))),
+                        hasProperty("id1", equalTo(Identifier.fromInt(6))),
+                        hasProperty("id2", equalTo(Identifier.fromInt(7))),
+                        hasProperty("id3", equalTo(Identifier.fromInt(8))),
+                        hasProperty("manufacturer", equalTo(10)),
+                        hasProperty("multiFrameBeacon", equalTo(true)),
+                        hasProperty("parserIdentifier", equalTo("Any Parser ID")),
+                        hasProperty("rssi", equalTo(-11)),
+                        hasProperty("runningAverageRssi", equalTo(-12.3)),
+                        hasProperty("serviceUuid", equalTo(13)),
+                        hasProperty("txPower", equalTo(14)),
+                        hasProperty("packetCount", equalTo(15)),
+                        hasProperty("measurementCount", equalTo(16))
+                )
+        );
+    }
+
     // utilty methods for testing serialization
 
     private byte[] convertToBytes(Object object) throws IOException {
diff --git a/src/test/java/org/altbeacon/beacon/service/ExtraDataBeaconTrackerTest.java b/src/test/java/org/altbeacon/beacon/service/ExtraDataBeaconTrackerTest.java
index cc7dcd99..24927ac5 100644
--- a/src/test/java/org/altbeacon/beacon/service/ExtraDataBeaconTrackerTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/ExtraDataBeaconTrackerTest.java
@@ -10,11 +10,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import dalvik.annotation.TestTargetClass;
-
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(sdk = 18)
@@ -59,6 +57,7 @@ Beacon getGattBeaconExtraData() {
         return new Beacon.Builder()
                 .setBluetoothAddress("01:02:03:04:05:06")
                 .setServiceUuid(1234)
+                .setRssi(-25)
                 .setDataFields(getDataFields())
                 .build();
     }
@@ -67,6 +66,7 @@ Beacon getGattBeaconExtraData2() {
         return new Beacon.Builder()
                 .setBluetoothAddress("01:02:03:04:05:06")
                 .setServiceUuid(1234)
+                .setRssi(-50)
                 .setDataFields(getDataFields2())
                 .build();
     }
@@ -119,32 +119,44 @@ public void gattBeaconExtraDataGetUpdated() {
         ExtraDataBeaconTracker tracker = new ExtraDataBeaconTracker();
         tracker.track(beacon);
         tracker.track(extraDataBeacon);
-        tracker.track(extraDataBeacon2);
         Beacon trackedBeacon = tracker.track(beacon);
+        assertEquals("rssi should be updated", extraDataBeacon.getRssi(), trackedBeacon.getRssi());
+        assertEquals("extra data is updated", extraDataBeacon.getDataFields(), trackedBeacon.getExtraDataFields());
+
+        tracker.track(extraDataBeacon2);
+        trackedBeacon = tracker.track(beacon);
+        assertEquals("rssi should be updated", extraDataBeacon2.getRssi(), trackedBeacon.getRssi());
         assertEquals("extra data is updated", extraDataBeacon2.getDataFields(), trackedBeacon.getExtraDataFields());
     }
 
     @Test
-    public void gattBeaconExtraDataAreNotOverwritten() {
+    public void gattBeaconFieldsAreNotUpdated() {
         Beacon beacon = getGattBeacon();
-        Beacon extraDataBeacon = getGattBeaconExtraData();
+        final int originalRssi = beacon.getRssi();
+        final List<Long> originalData = beacon.getDataFields();
+        final List<Long> originalExtra = beacon.getExtraDataFields();
+        Beacon beaconUpdate = getGattBeaconUpdate();
         ExtraDataBeaconTracker tracker = new ExtraDataBeaconTracker();
         tracker.track(beacon);
-        tracker.track(extraDataBeacon);
+        tracker.track(beaconUpdate);
         Beacon trackedBeacon = tracker.track(beacon);
-        assertEquals("extra data should not be overwritten", extraDataBeacon.getDataFields(), trackedBeacon.getExtraDataFields());
+        assertEquals("rssi should NOT be updated", originalRssi, trackedBeacon.getRssi());
+        assertEquals("data should NOT be updated", originalData, trackedBeacon.getDataFields());
+        assertEquals("extra data should NOT be updated", originalExtra, trackedBeacon.getExtraDataFields());
     }
 
     @Test
     public void gattBeaconFieldsGetUpdated() {
         Beacon beacon = getGattBeacon();
-        Beacon beaconUpdate = getGattBeaconUpdate();
         Beacon extraDataBeacon = getGattBeaconExtraData();
+        Beacon repeatBeacon = getGattBeacon();
+        repeatBeacon.setRssi(-100);
         ExtraDataBeaconTracker tracker = new ExtraDataBeaconTracker();
         tracker.track(beacon);
-        Beacon trackedBeacon = tracker.track(beaconUpdate);
-        assertEquals("rssi should be updated", beaconUpdate.getRssi(), trackedBeacon.getRssi());
-        assertEquals("data fields should be updated", beaconUpdate.getDataFields(), trackedBeacon.getDataFields());
+        tracker.track(extraDataBeacon);
+        Beacon trackedBeacon = tracker.track(repeatBeacon);
+        assertEquals("rssi should NOT be updated", -100, trackedBeacon.getRssi());
+        assertEquals("extra data fields should be updated", extraDataBeacon.getDataFields(), trackedBeacon.getExtraDataFields());
     }
 
     @Test
diff --git a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
index 403cd955..90f92dbf 100644
--- a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
@@ -41,7 +41,14 @@ public void testSerialization() throws Exception {
         identifiers.add(Identifier.parse("2"));
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
-        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers)
+                                            .setRssi(-1)
+                                            .setRunningAverageRssi(-2)
+                                            .setTxPower(-50)
+                                            .setBluetoothAddress("01:02:03:04:05:06")
+                                            .build();
+        beacon.setRssiMeasurementCount(1);
+        beacon.setPacketCount(2);
         for (int i=0; i < 10; i++) {
             beacons.add(beacon);
         }
@@ -49,8 +56,14 @@ public void testSerialization() throws Exception {
         Bundle bundle = data.toBundle();
         RangingData data2 = RangingData.fromBundle(bundle);
         assertEquals("beacon count shouild be restored", 10, data2.getBeacons().size());
-        assertEquals("beacon identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getBeacons().iterator().next().getId1().toString());
         assertEquals("region identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getRegion().getId1().toString());
+        Beacon restoredBeacon = data2.getBeacons().iterator().next();
+        assertEquals("beacon identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", restoredBeacon.getId1().toString());
+        assertEquals("RSSI is restored", -1, restoredBeacon.getRssi());
+        assertEquals("Average RSSI is restored", -2.0, restoredBeacon.getRunningAverageRssi(), 0.0);
+        assertEquals("TXPower is restored", -50, restoredBeacon.getTxPower());
+        assertEquals("Measurement count is restored", 1, restoredBeacon.getMeasurementCount());
+        assertEquals("Packet count is restored", 2, restoredBeacon.getPacketCount());
     }
 
     @Test
diff --git a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
index e79c8ee9..8eb7cc08 100644
--- a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
@@ -28,6 +28,21 @@ public void rangedBeaconDoesNotOverrideSampleExpirationMillisecondsText() {
         assertEquals("RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by constructing RangedBeacon", 33l, RunningAverageRssiFilter.getSampleExpirationMilliseconds());
     }
 
+    @Test
+    public void regressionCheckRangedBeaconCommitDoesNotOverrideSampleExpirationMilliseconds() {
+        RangedBeacon.setSampleExpirationMilliseconds(20000);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(20000);
+        Beacon beacon = new Beacon.Builder().setId1("1").build();
+        RangedBeacon rb = new RangedBeacon(beacon);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(33l);
+        rb.commitMeasurements();
+        assertEquals(
+                "RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by committing RangedBeacon",
+                33l,
+                RunningAverageRssiFilter.getSampleExpirationMilliseconds()
+        );
+    }
+
     @Test
     public void legacySetSampleExpirationMillisecondsWorksText() {
         RangedBeacon.setSampleExpirationMilliseconds(20000);
