diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index b21c3a64..e4b8cad8 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -114,8 +114,7 @@
     private Messenger serviceMessenger = null;
     protected final Set<RangeNotifier> rangeNotifiers = new CopyOnWriteArraySet<>();
     protected RangeNotifier dataRequestNotifier = null;
-    protected Set<MonitorNotifier> monitorNotifiers = new CopyOnWriteArraySet<>();
-    private final ArrayList<Region> monitoredRegions = new ArrayList<Region>();
+    protected final Set<MonitorNotifier> monitorNotifiers = new CopyOnWriteArraySet<>();
     private final ArrayList<Region> rangedRegions = new ArrayList<Region>();
     private final List<BeaconParser> beaconParsers = new CopyOnWriteArrayList<>();
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
@@ -423,7 +422,7 @@ public boolean isBackgroundModeUninitialized() {
      * activities or services set different RangeNotifier instances, the last one set will receive
      * all the notifications.
      *
-     * @param notifier
+     * @param notifier The {@link RangeNotifier} to register.
      * @see RangeNotifier
      * @deprecated replaced by (@link #addRangeNotifier)
      */
@@ -441,14 +440,14 @@ public void setRangeNotifier(RangeNotifier notifier) {
      * <p/>
      * Permits to register several <code>RangeNotifier</code> objects.
      * <p/>
-     *The notifier must be unregistered using (@link #removeRangeNotifier)
+     * The notifier must be unregistered using (@link #removeRangeNotifier)
      *
-     * @param notifier
+     * @param notifier The {@link RangeNotifier} to register.
      * @see RangeNotifier
      */
-    public void addRangeNotifier(RangeNotifier notifier){
-        if(notifier != null){
-            synchronized (rangeNotifiers){
+    public void addRangeNotifier(RangeNotifier notifier) {
+        if (notifier != null) {
+            synchronized (rangeNotifiers) {
                 rangeNotifiers.add(notifier);
             }
         }
@@ -457,20 +456,20 @@ public void addRangeNotifier(RangeNotifier notifier){
     /**
      * Specifies a class to remove from the array of <code>RangeNotifier</code>
      *
-     * @param notifier
+     * @param notifier The {@link RangeNotifier} to unregister.
      * @see RangeNotifier
      */
-    public boolean removeRangeNotifier(RangeNotifier notifier){
-        synchronized (rangeNotifiers){
+    public boolean removeRangeNotifier(RangeNotifier notifier) {
+        synchronized (rangeNotifiers) {
             return rangeNotifiers.remove(notifier);
         }
     }
 
     /**
-     * Remove all the Range Notifiers
+     * Remove all the Range Notifiers.
      */
-    public void removeAllRangeNotifiers(){
-        synchronized (rangeNotifiers){
+    public void removeAllRangeNotifiers() {
+        synchronized (rangeNotifiers) {
             rangeNotifiers.clear();
         }
     }
@@ -483,11 +482,11 @@ public void removeAllRangeNotifiers(){
      * activities or services set different MonitorNotifier instances, the last one set will receive
      * all the notifications.
      *
-     * @param notifier
+     * @param notifier The {@link MonitorNotifier} to register.
      * @see MonitorNotifier
-     * @see #startMonitoringBeaconsInRegion(Region region)
+     * @see #startMonitoringBeaconsInRegion(Region)
      * @see Region
-     * @deprecated replaced by (@link #addMonitorNotifier)
+     * @deprecated replaced by {@link #addMonitorNotifier}
      */
     @Deprecated
     public void setMonitorNotifier(MonitorNotifier notifier) {
@@ -498,63 +497,80 @@ public void setMonitorNotifier(MonitorNotifier notifier) {
     }
 
     /**
-     * Specifies a class that should be called each time the <code>BeaconService</code> sees
-     * or stops seeing a Region of beacons.
+     * Specifies a class that should be called each time the <code>BeaconService</code> sees or
+     * stops seeing a Region of beacons.
+     * <p/>
+     * Permits to register several <code>MonitorNotifier</code> objects.
      * <p/>
-     * Permits to register severals <code>MonitorNotifier</code> objects.
-     *<p/>
-     * Unregister the notifier using (@link #removeMonitoreNotifier)
+     * Unregister the notifier using {@link #removeMonitoreNotifier}
      *
-     * @param notifier
+     * @param notifier The {@link MonitorNotifier} to register.
      * @see MonitorNotifier
-     * @see #startMonitoringBeaconsInRegion(Region region)
+     * @see #startMonitoringBeaconsInRegion(Region)
      * @see Region
      */
-    public void addMonitorNotifier(MonitorNotifier notifier){
-        if(notifier != null){
+    public void addMonitorNotifier(MonitorNotifier notifier) {
+        if (notifier != null) {
             synchronized (monitorNotifiers) {
                 monitorNotifiers.add(notifier);
             }
         }
     }
 
+    /**
+     * @see #removeMonitorNotifier
+     * @deprecated Misspelled. Replaced by {@link #removeMonitorNotifier}
+     */
+    @Deprecated
+    public boolean removeMonitoreNotifier(MonitorNotifier notifier) {
+        return removeMonitorNotifier(notifier);
+    }
+
     /**
      * Specifies a class to remove from the array of <code>MonitorNotifier</code>.
      *
-     * @param notifier
+     * @param notifier The {@link MonitorNotifier} to unregister.
      * @see MonitorNotifier
-     * @see #startMonitoringBeaconsInRegion(Region region)
+     * @see #startMonitoringBeaconsInRegion(Region)
      * @see Region
      */
-    public boolean removeMonitoreNotifier(MonitorNotifier notifier){
-        synchronized (monitorNotifiers){
+    public boolean removeMonitorNotifier(MonitorNotifier notifier) {
+        synchronized (monitorNotifiers) {
             return monitorNotifiers.remove(notifier);
         }
     }
 
     /**
-     * Remove all the Monitor Notifers
+     * Remove all the Monitor Notifiers.
      */
-    public void removeAllMonitorNotifiers(){
-        synchronized (monitorNotifiers){
+    public void removeAllMonitorNotifiers() {
+        synchronized (monitorNotifiers) {
             monitorNotifiers.clear();
         }
     }
 
     /**
-     * Turns off saving the state of monitored regions to persistent storage so it is retained
-     * over app restarts.  Defaults to enabled.  When enabled, there will not be an "extra" region
-     * entry event when the app starts up and a beacon for a monitored region was previously visible
+     * @see #setRegionStatePersistenceEnabled
+     * @deprecated Misspelled. Replaced by {@link #setRegionStatePersistenceEnabled}
+     */
+    @Deprecated
+    public void setRegionStatePeristenceEnabled(boolean enabled) {
+        setRegionStatePersistenceEnabled(enabled);
+    }
+
+    /**
+     * Turns off saving the state of monitored regions to persistent storage so it is retained over
+     * app restarts.  Defaults to enabled.  When enabled, there will not be an "extra" region entry
+     * event when the app starts up and a beacon for a monitored region was previously visible
      * within the past 15 minutes.  Note that there is a limit to 50 monitored regions that may be
-     * perisisted.  If more than 50 regions are monitored, state is not persisted for any.
+     * persisted.  If more than 50 regions are monitored, state is not persisted for any.
      *
-     * @param enabled
+     * @param enabled true to enable the region state persistence, false to disable it.
      */
-    public void setRegionStatePeristenceEnabled(boolean enabled) {
+    public void setRegionStatePersistenceEnabled(boolean enabled) {
         if (enabled) {
             MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
-        }
-        else {
+        } else {
             MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
         }
     }
@@ -668,11 +684,7 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
         StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
         msg.obj = obj;
         serviceMessenger.send(msg);
-        synchronized (monitoredRegions) {
-            // If we are already tracking the state of this region, send a callback about it
-            this.requestStateForRegion(region);
-            monitoredRegions.add(region);
-        }
+        this.requestStateForRegion(region);
     }
 
     /**
@@ -699,15 +711,6 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
         StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
         msg.obj = obj;
         serviceMessenger.send(msg);
-        synchronized (monitoredRegions) {
-            Region regionToRemove = null;
-            for (Region monitoredRegion : monitoredRegions) {
-                if (region.getUniqueId().equals(monitoredRegion.getUniqueId())) {
-                    regionToRemove = monitoredRegion;
-                }
-            }
-            monitoredRegions.remove(regionToRemove);
-        }
     }
 
 
@@ -778,7 +781,7 @@ public RangeNotifier getRangingNotifier() {
     /**
      * @return the list of registered rangeNotifier
      */
-    public Set<RangeNotifier> getRangingNotifiers(){
+    public Set<RangeNotifier> getRangingNotifiers() {
         return rangeNotifiers;
     }
 
@@ -786,9 +789,7 @@ public RangeNotifier getRangingNotifier() {
      * @return the list of regions currently being monitored
      */
     public Collection<Region> getMonitoredRegions() {
-        synchronized(this.monitoredRegions) {
-            return new ArrayList<Region>(this.monitoredRegions);
-        }
+        return MonitoringStatus.getInstanceForApplication(mContext).regions();
     }
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 29ba031d..5738a50f 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -325,7 +325,7 @@ public void stopRangingBeaconsInRegion(Region region) {
 
     public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
         LogManager.d(TAG, "startMonitoring called");
-        monitoringStatus.addRegion(region);
+        monitoringStatus.addRegion(region, callback);
         LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
         mCycledScanner.start();
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index 1c5005a4..aa0ddb6a 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -63,6 +63,9 @@ public Intent getIntent() {
      * @return false if it callback cannot be made
      */
     public boolean call(Context context, String dataName, Parcelable data) {
+        if(intent == null){
+            initializeIntent();
+        }
         if (intent != null) {
             LogManager.d(TAG, "attempting callback via intent: %s", intent.getComponent());
             intent.putExtra(dataName, data);
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index 5faa1fbf..fdf5644d 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -50,7 +50,7 @@ public MonitoringStatus(Context context) {
         this.mContext = context;
     }
 
-    public synchronized void addRegion(Region region) {
+    public synchronized void addRegion(Region region, Callback callback) {
         if (getRegionsStateMap().containsKey(region)) {
             // if the region definition hasn't changed, becasue if it has, we need to clear state
             // otherwise a region with the same uniqueId can never be changed
@@ -70,7 +70,7 @@ public synchronized void addRegion(Region region) {
                 }
             }
         }
-        getRegionsStateMap().put(region, new RegionMonitoringState(new Callback(mContext.getPackageName())));
+        getRegionsStateMap().put(region, new RegionMonitoringState(callback));
         saveMonitoringStatusIfOn();
     }
 
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 57fc004e..4d370d55 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -177,63 +177,68 @@ public void destroy() {
 
     @SuppressLint("NewApi")
     protected void scanLeDevice(final Boolean enable) {
-        mScanCyclerStarted = true;
-        if (getBluetoothAdapter() == null) {
-            LogManager.e(TAG, "No Bluetooth adapter.  beaconService cannot scan.");
-        }
-        if (enable) {
-            if (deferScanIfNeeded()) {
-                return;
+        try {
+            mScanCyclerStarted = true;
+            if (getBluetoothAdapter() == null) {
+                LogManager.e(TAG, "No Bluetooth adapter.  beaconService cannot scan.");
             }
-            LogManager.d(TAG, "starting a new scan cycle");
-            if (!mScanning || mScanningPaused || mRestartNeeded) {
-                mScanning = true;
-                mScanningPaused = false;
-                try {
-                    if (getBluetoothAdapter() != null) {
-                        if (getBluetoothAdapter().isEnabled()) {
-                            if (mBluetoothCrashResolver != null && mBluetoothCrashResolver.isRecoveryInProgress()) {
-                                LogManager.w(TAG, "Skipping scan because crash recovery is in progress.");
-                            } else {
-                                if (mScanningEnabled) {
-                                    if (mRestartNeeded) {
-                                        mRestartNeeded = false;
-                                        LogManager.d(TAG, "restarting a bluetooth le scan");
-                                    } else {
-                                        LogManager.d(TAG, "starting a new bluetooth le scan");
-                                    }
-                                    try {
-                                        if (android.os.Build.VERSION.SDK_INT < 23 || checkLocationPermission()) {
-                                            startScan();
+            if (enable) {
+                if (deferScanIfNeeded()) {
+                    return;
+                }
+                LogManager.d(TAG, "starting a new scan cycle");
+                if (!mScanning || mScanningPaused || mRestartNeeded) {
+                    mScanning = true;
+                    mScanningPaused = false;
+                    try {
+                        if (getBluetoothAdapter() != null) {
+                            if (getBluetoothAdapter().isEnabled()) {
+                                if (mBluetoothCrashResolver != null && mBluetoothCrashResolver.isRecoveryInProgress()) {
+                                    LogManager.w(TAG, "Skipping scan because crash recovery is in progress.");
+                                } else {
+                                    if (mScanningEnabled) {
+                                        if (mRestartNeeded) {
+                                            mRestartNeeded = false;
+                                            LogManager.d(TAG, "restarting a bluetooth le scan");
+                                        } else {
+                                            LogManager.d(TAG, "starting a new bluetooth le scan");
+                                        }
+                                        try {
+                                            if (android.os.Build.VERSION.SDK_INT < 23 || checkLocationPermission()) {
+                                                startScan();
+                                            }
+                                        } catch (Exception e) {
+                                            LogManager.e(e, TAG, "Internal Android exception scanning for beacons");
                                         }
-                                    } catch (Exception e) {
-                                        LogManager.e(e, TAG, "Internal Android exception scanning for beacons");
+                                    } else {
+                                        LogManager.d(TAG, "Scanning unnecessary - no monitoring or ranging active.");
                                     }
-                                } else {
-                                    LogManager.d(TAG, "Scanning unnecessary - no monitoring or ranging active.");
                                 }
+                                mLastScanCycleStartTime = SystemClock.elapsedRealtime();
+                            } else {
+                                LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
                             }
-                            mLastScanCycleStartTime = SystemClock.elapsedRealtime();
-                        } else {
-                            LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
                         }
+                    } catch (Exception e) {
+                        LogManager.e(e, TAG, "Exception starting Bluetooth scan.  Perhaps Bluetooth is disabled or unavailable?");
                     }
-                } catch (Exception e) {
-                    LogManager.e(e, TAG, "Exception starting Bluetooth scan.  Perhaps Bluetooth is disabled or unavailable?");
+                } else {
+                    LogManager.d(TAG, "We are already scanning");
                 }
+                mScanCycleStopTime = (SystemClock.elapsedRealtime() + mScanPeriod);
+                scheduleScanCycleStop();
+
+                LogManager.d(TAG, "Scan started");
             } else {
-                LogManager.d(TAG, "We are already scanning");
+                LogManager.d(TAG, "disabling scan");
+                mScanning = false;
+                mScanCyclerStarted = false;
+                stopScan();
+                mLastScanCycleEndTime = SystemClock.elapsedRealtime();
             }
-            mScanCycleStopTime = (SystemClock.elapsedRealtime() + mScanPeriod);
-            scheduleScanCycleStop();
-
-            LogManager.d(TAG, "Scan started");
-        } else {
-            LogManager.d(TAG, "disabling scan");
-            mScanning = false;
-            mScanCyclerStarted = false;
-            stopScan();
-            mLastScanCycleEndTime = SystemClock.elapsedRealtime();
+        }
+        catch (SecurityException e) {
+            LogManager.w(TAG, "SecurityException working accessing bluetooth.");
         }
     }
 
@@ -261,59 +266,70 @@ public void run() {
 
     private void finishScanCycle() {
         LogManager.d(TAG, "Done with scan cycle");
-        mCycledLeScanCallback.onCycleEnd();
-        if (mScanning) {
-            if (getBluetoothAdapter() != null) {
-                if (getBluetoothAdapter().isEnabled()) {
-                    long now = System.currentTimeMillis();
-                    if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
-                            mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
-                            now-mLastScanStopTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
-                        // As of Android N, only 5 scans may be started in a 30 second period (6
-                        // seconds per cycle)  otherwise they are blocked.  So we check here to see
-                        // if the scan period is 6 seconds or less, and if we last stopped scanning
-                        // fewer than 6 seconds ag and if so, we simply do not stop scanning
-                        LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
-                                " keep scanning for a minimum of 6 seconds at a time. "+
-                                 "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanStopTime))+" millisconds.");
-                    }
-                    else {
-                        try {
-                            LogManager.d(TAG, "stopping bluetooth le scan");
-                            finishScan();
-                            mLastScanStopTime = now;
-                        } catch (Exception e) {
-                            LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
+        try {
+            mCycledLeScanCallback.onCycleEnd();
+            if (mScanning) {
+                if (getBluetoothAdapter() != null) {
+                    if (getBluetoothAdapter().isEnabled()) {
+                        long now = System.currentTimeMillis();
+                        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
+                                mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
+                                now-mLastScanStopTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
+                            // As of Android N, only 5 scans may be started in a 30 second period (6
+                            // seconds per cycle)  otherwise they are blocked.  So we check here to see
+                            // if the scan period is 6 seconds or less, and if we last stopped scanning
+                            // fewer than 6 seconds ag and if so, we simply do not stop scanning
+                            LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
+                                    " keep scanning for a minimum of 6 seconds at a time. "+
+                                    "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanStopTime))+" millisconds.");
+                        }
+                        else {
+                            try {
+                                LogManager.d(TAG, "stopping bluetooth le scan");
+                                finishScan();
+                                mLastScanStopTime = now;
+                            } catch (Exception e) {
+                                LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
+                            }
                         }
-                    }
 
-                    mLastScanCycleEndTime = SystemClock.elapsedRealtime();
-                } else {
-                    LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
+                        mLastScanCycleEndTime = SystemClock.elapsedRealtime();
+                    } else {
+                        LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
+                    }
+                }
+                mNextScanCycleStartTime = getNextScanStartTime();
+                if (mScanningEnabled) {
+                    scanLeDevice(true);
                 }
             }
-            mNextScanCycleStartTime = getNextScanStartTime();
-            if (mScanningEnabled) {
-                scanLeDevice(true);
+            if (!mScanningEnabled) {
+                LogManager.d(TAG, "Scanning disabled.  No ranging or monitoring regions are active.");
+                mScanCyclerStarted = false;
+                cancelWakeUpAlarm();
             }
         }
-        if (!mScanningEnabled) {
-            LogManager.d(TAG, "Scanning disabled.  No ranging or monitoring regions are active.");
-            mScanCyclerStarted = false;
-            cancelWakeUpAlarm();
+        catch (SecurityException e) {
+            LogManager.w(TAG, "SecurityException working accessing bluetooth.");
         }
     }
 
     protected BluetoothAdapter getBluetoothAdapter() {
-        if (mBluetoothAdapter == null) {
-            // Initializes Bluetooth adapter.
-            final BluetoothManager bluetoothManager =
-                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
-            mBluetoothAdapter = bluetoothManager.getAdapter();
+        try {
             if (mBluetoothAdapter == null) {
-                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+                // Initializes Bluetooth adapter.
+                final BluetoothManager bluetoothManager =
+                        (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+                mBluetoothAdapter = bluetoothManager.getAdapter();
+                if (mBluetoothAdapter == null) {
+                    LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+                }
             }
         }
+        catch (SecurityException e) {
+            // Thrown by Samsung Knox devices if bluetooth access denied for an app
+            LogManager.e(TAG, "Cannot consruct bluetooth adapter.  Security Exception");
+        }
         return mBluetoothAdapter;
     }
 
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index e5ac14d6..82251314 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -16,6 +16,7 @@
 import org.altbeacon.beacon.service.DetectionTracker;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
+import java.security.Security;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -154,6 +155,10 @@ public void run() {
 
     @Override
     protected void startScan() {
+        if (!isBluetoothOn()) {
+            LogManager.d(TAG, "Not starting scan because bluetooth is off");
+            return;
+        }
         List<ScanFilter> filters = new ArrayList<ScanFilter>();
         ScanSettings settings;
 
@@ -194,12 +199,20 @@ public void run() {
                 } catch (NullPointerException npe) {
                     // Necessary because of https://code.google.com/p/android/issues/detail?id=160503
                     LogManager.e(TAG, "Cannot start scan. Unexpected NPE.", npe);
+                } catch (SecurityException e) {
+                    // Thrown by Samsung Knox devices if bluetooth access denied for an app
+                    LogManager.e(TAG, "Cannot start scan.  Security Exception");
                 }
+
             }
         });
     }
 
     private void postStopLeScan() {
+        if (!isBluetoothOn()){
+            LogManager.d(TAG, "Not stopping scan because bluetooth is off");
+            return;
+        }
         final BluetoothLeScanner scanner = getScanner();
         if (scanner == null) {
             return;
@@ -216,22 +229,45 @@ public void run() {
                 } catch (NullPointerException npe) {
                     // Necessary because of https://code.google.com/p/android/issues/detail?id=160503
                     LogManager.e(TAG, "Cannot stop scan. Unexpected NPE.", npe);
+                } catch (SecurityException e) {
+                    // Thrown by Samsung Knox devices if bluetooth access denied for an app
+                    LogManager.e(TAG, "Cannot stop scan.  Security Exception");
                 }
+
             }
         });
     }
 
-    private BluetoothLeScanner getScanner() {
-        if (mScanner == null) {
-            LogManager.d(TAG, "Making new Android L scanner");
+    private boolean isBluetoothOn() {
+        try {
             BluetoothAdapter bluetoothAdapter = getBluetoothAdapter();
             if (bluetoothAdapter != null) {
-                mScanner = getBluetoothAdapter().getBluetoothLeScanner();
+                return (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON);
             }
+            LogManager.w(TAG, "Cannot get bluetooth adapter");
+        }
+        catch (SecurityException e) {
+            LogManager.w(TAG, "SecurityException checking if bluetooth is on");
+        }
+        return false;
+    }
+
+    private BluetoothLeScanner getScanner() {
+        try {
             if (mScanner == null) {
-                LogManager.w(TAG, "Failed to make new Android L scanner");
+                LogManager.d(TAG, "Making new Android L scanner");
+                BluetoothAdapter bluetoothAdapter = getBluetoothAdapter();
+                if (bluetoothAdapter != null) {
+                    mScanner = getBluetoothAdapter().getBluetoothLeScanner();
+                }
+                if (mScanner == null) {
+                    LogManager.w(TAG, "Failed to make new Android L scanner");
+                }
             }
         }
+        catch (SecurityException e) {
+            LogManager.w(TAG, "SecurityException making new Android L scanner");
+        }
         return mScanner;
     }
 
diff --git a/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java b/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
index 585a718e..ec8fef85 100644
--- a/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
@@ -19,6 +19,7 @@
 import org.robolectric.shadows.ShadowApplication;
 import org.robolectric.util.ServiceController;
 
+import java.util.Collection;
 import java.util.concurrent.ThreadPoolExecutor;
 
 import static org.junit.Assert.assertEquals;
@@ -44,7 +45,7 @@ public void savesStatusOfUpTo50RegionsTest() throws Exception {
         MonitoringStatus monitoringStatus = new MonitoringStatus(context);
         for (int i = 0; i < 50; i++) {
             Region region = new Region(""+i, null, null, null);
-            monitoringStatus.addRegion(region);
+            monitoringStatus.addRegion(region, null);
         }
         monitoringStatus.saveMonitoringStatusIfOn();
         MonitoringStatus monitoringStatus2 = new MonitoringStatus(context);
@@ -58,7 +59,7 @@ public void clearsStatusOfOver50RegionsTest() throws Exception {
         MonitoringStatus monitoringStatus = new MonitoringStatus(context);
         for (int i = 0; i < 51; i++) {
             Region region = new Region(""+i, null, null, null);
-            monitoringStatus.addRegion(region);
+            monitoringStatus.addRegion(region, null);
         }
         monitoringStatus.saveMonitoringStatusIfOn();
         MonitoringStatus monitoringStatus2 = new MonitoringStatus(context);
@@ -72,7 +73,7 @@ public void refusesToRestoreRegionsIfTooMuchTimeHasPassedSinceSavingTest() throw
         MonitoringStatus monitoringStatus = new MonitoringStatus(context);
         for (int i = 0; i < 50; i++) {
             Region region = new Region(""+i, null, null, null);
-            monitoringStatus.addRegion(region);
+            monitoringStatus.addRegion(region, null);
         }
         monitoringStatus.saveMonitoringStatusIfOn();
         // Set update time to one hour ago
@@ -81,4 +82,20 @@ public void refusesToRestoreRegionsIfTooMuchTimeHasPassedSinceSavingTest() throw
         assertEquals("restored regions should be none", 0, monitoringStatus2.regions().size());
     }
 
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void allowsAccessToRegionsAfterRestore() throws Exception {
+        Context context = ShadowApplication.getInstance().getApplicationContext();
+        MonitoringStatus monitoringStatus = new MonitoringStatus(context);
+        for (int i = 0; i < 50; i++) {
+            Region region = new Region(""+i, null, null, null);
+            monitoringStatus.addRegion(region, null);
+        }
+        monitoringStatus.saveMonitoringStatusIfOn();
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context);
+        Collection<Region> regions = beaconManager.getMonitoredRegions();
+        assertEquals("beaconManager should return restored regions", 50, regions.size());
+    }
+
+
 }
