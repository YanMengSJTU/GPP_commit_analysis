diff --git a/CHANGELOG.md b/CHANGELOG.md
index e41f4100..cc4b7e3c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,11 @@
 ### Development
 
-Bug Fixes:
- - Stop running scheduled jobs to do sscans after last consumer unbound. (#702, David G. Young)
+### 2.15.1 / 2018-09-01
+
+ - Prevent crash caused by internal Android exception when stopping scanning (#724, David G. Young)
+ - Fix Android 8 crashing apps on background monitoring/ranging data delivery (#720, David G. Young)
+ - Fix intermittent NPE on ranging beacons (#716, Federico Bertoli, David G. Young)
+ - Stop running scheduled jobs to do scans after last consumer unbound. (#702, David G. Young)
 
 ### 2.15 / 2018-07-04
 
diff --git a/README.md b/README.md
index 5a48df65..2c827a66 100644
--- a/README.md
+++ b/README.md
@@ -48,7 +48,7 @@ to use the JCenter Repository
 ```groovy
 dependencies {
     ...
-    compile 'org.altbeacon:android-beacon-library:${altbeacon.version}'
+    implementation 'org.altbeacon:android-beacon-library:${altbeacon.version}'
     ...
 }
 ```
diff --git a/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
index 8794252c..b2fe9039 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
@@ -40,10 +40,10 @@
  * This is used with ScanJob and supports delivering intents even under Android O background
  * restrictions preventing starting a new IntentService.
  *
- * It is not used with the BeaconService, as local broadcast intents cannot be deliverd across
- * different processes which the BeaconService supports.
+ * It is not used with the BeaconService, if running in a separate process, as local broadcast
+ * intents cannot be deliverd across different processes which the BeaconService supports.
  *
- * @see BeaconIntentProcessor for the equivalent use with BeaconService.
+ * @see BeaconIntentProcessor for the equivalent use with BeaconService in a separate process.
  **
  * Internal library class.  Do not use directly from outside the library
  *
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index f0d330ce..0d93c85f 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -45,6 +45,7 @@
 import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.BeaconParser;
 import org.altbeacon.beacon.BuildConfig;
@@ -74,6 +75,8 @@
     private final Handler handler = new Handler();
     private BluetoothCrashResolver bluetoothCrashResolver;
     private ScanHelper mScanHelper;
+    private BeaconLocalBroadcastProcessor mBeaconNotificationProcessor;
+
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -209,6 +212,8 @@ public void onCreate() {
         beaconManager.setScannerInSameProcess(true);
         if (beaconManager.isMainProcess()) {
             LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+            // if we are on the main process, we use local broadcast notifications to deliver results.
+            ensureNotificationProcessorSetup();
         } else {
             LogManager.i(TAG, "beaconService version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
             ProcessUtils processUtils = new ProcessUtils(this);
@@ -239,6 +244,15 @@ public void onCreate() {
         this.startForegroundIfConfigured();
     }
 
+
+    private void ensureNotificationProcessorSetup() {
+        if (mBeaconNotificationProcessor == null) {
+            mBeaconNotificationProcessor = new BeaconLocalBroadcastProcessor(this);
+            mBeaconNotificationProcessor.register();
+        }
+    }
+
+
     /*
      * This starts the scanning service as a foreground service if it is so configured in the
      * manifest
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index a8c9ad92..512f031d 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -52,7 +52,7 @@ public Callback(String intentPackageName) {
      * @return false if it callback cannot be made
      */
     public boolean call(Context context, String dataName, Bundle data) {
-        boolean useLocalBroadcast = BeaconManager.getInstanceForApplication(context).getScheduledScanJobsEnabled();
+        boolean useLocalBroadcast = BeaconManager.getInstanceForApplication(context).isMainProcess();
         boolean success = false;
 
         if(useLocalBroadcast) {
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index 680449f4..19783f2f 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -35,7 +35,7 @@
 public class RangeState implements Serializable {
     private static final String TAG = "RangeState";
     private Callback mCallback;
-    private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
+    private Map<Beacon, RangedBeacon> mRangedBeacons = new HashMap<Beacon, RangedBeacon>();
     private static boolean sUseTrackingCache = false;
 
     public RangeState(Callback c) {
@@ -47,14 +47,13 @@ public Callback getCallback() {
     }
 
     public void addBeacon(Beacon beacon) {
-        if (mRangedBeacons.containsKey(beacon)) {
-            RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
+        RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
+        if (rangedBeacon != null) {
             if (LogManager.isVerboseLoggingEnabled()) {
                 LogManager.d(TAG, "adding %s to existing range for: %s", beacon, rangedBeacon);
             }
             rangedBeacon.updateBeacon(beacon);
-        }
-        else {
+        } else {
             if (LogManager.isVerboseLoggingEnabled()) {
                 LogManager.d(TAG, "adding %s to new rangedBeacon", beacon);
             }
@@ -65,30 +64,31 @@ public void addBeacon(Beacon beacon) {
     // returns a list of beacons that are tracked, and then removes any from the list that should not
     // be there for the next cycle
     public synchronized Collection<Beacon> finalizeBeacons() {
-        Map<Beacon,RangedBeacon> newRangedBeacons = new HashMap<Beacon,RangedBeacon>();
+        Map<Beacon, RangedBeacon> newRangedBeacons = new HashMap<Beacon, RangedBeacon>();
         ArrayList<Beacon> finalizedBeacons = new ArrayList<Beacon>();
 
         synchronized (mRangedBeacons) {
             for (Beacon beacon : mRangedBeacons.keySet()) {
                 RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
-                if (rangedBeacon.isTracked()) {
-                    rangedBeacon.commitMeasurements(); // calculates accuracy
-                    if (!rangedBeacon.noMeasurementsAvailable()) {
-                        rangedBeacon.getBeacon().updateExtraData();
-                        finalizedBeacons.add(rangedBeacon.getBeacon());
+                if (rangedBeacon != null) {
+                    if (rangedBeacon.isTracked()) {
+                        rangedBeacon.commitMeasurements(); // calculates accuracy
+                        if (!rangedBeacon.noMeasurementsAvailable()) {
+                            rangedBeacon.getBeacon().updateExtraData();
+                            finalizedBeacons.add(rangedBeacon.getBeacon());
+                        }
+                    }
+                    // If we still have useful measurements, keep it around but mark it as not
+                    // tracked anymore so we don't pass it on as visible unless it is seen again
+                    if (!rangedBeacon.noMeasurementsAvailable() == true) {
+                        //if TrackingCache is enabled, allow beacon to not receive
+                        //measurements for a certain amount of time
+                        if (!sUseTrackingCache || rangedBeacon.isExpired())
+                            rangedBeacon.setTracked(false);
+                        newRangedBeacons.put(beacon, rangedBeacon);
+                    } else {
+                        LogManager.d(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
                     }
-                }
-                // If we still have useful measurements, keep it around but mark it as not
-                // tracked anymore so we don't pass it on as visible unless it is seen again
-                if (!rangedBeacon.noMeasurementsAvailable() == true) {
-                    //if TrackingCache is enabled, allow beacon to not receive
-                    //measurements for a certain amount of time
-                    if (!sUseTrackingCache || rangedBeacon.isExpired())
-                        rangedBeacon.setTracked(false);
-                    newRangedBeacons.put(beacon, rangedBeacon);
-                }
-                else {
-                    LogManager.d(TAG, "Dumping beacon from RangeState because it has no recent measurements.");
                 }
             }
             mRangedBeacons = newRangedBeacons;
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
index 8821006e..23e5b23b 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -196,6 +196,9 @@ void stopAndroidOBackgroundScan() {
             }
         } catch (SecurityException e) {
             LogManager.e(TAG, "SecurityException stopping Android O background scanner");
+        } catch (RuntimeException e) {
+            // Needed to stop a crash caused by internal Android throw.  See issue #701
+            LogManager.e(TAG, "Unexpected runtime exception stopping Android O background scanner", e);
         }
     }
 
