diff --git a/CHANGELOG.md b/CHANGELOG.md
index c971fd1d..842786ad 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,9 @@
 ### Development
 
+Enhancements:
+ - Add ScanJob for using JobScheudler to do scans instead of BeaconService, set as 
+   default for Android O. (#484, David G. Young)
+
 Bug Fixes:
 
  - Correct accessor method for Beacon#getRunningAverageRssi()
@@ -20,6 +24,8 @@ Bug Fixes:
 
 - Fix Google Play submission errors by no longer using uses-permission-sdk-23 in
   Manifest (#527, David G. Young)
+- Fix inability to use `RunningAverageRssiFilter.setSampleExpirationMilliseconds(...)` (#523,
+  David G. Young)
 - Fix failure to restart scanning in some cases after bluetooth has been off but then is turned
   back on. (#519, David G. Young)
 - Fix failure to stop scanning when unbinding from service or when the between scan period
@@ -30,8 +36,6 @@ Bug Fixes:
   `BeaconManager#getMonitoringNotifier` and `BeaconManager#getRangingNotifier`
   where the notifier sets were modified external to `BeaconManager` by another
   thread (#516, Aaron Kromer)
-- Fix inability to use `RunningAverageRssiFilter.setSampleExpirationMilliseconds(...)` (#523,
-  David G. Young)
 
 ### 2.10 / 2017-04-21
 
diff --git a/build.gradle b/build.gradle
index e13eea5e..bfda4f3a 100644
--- a/build.gradle
+++ b/build.gradle
@@ -25,10 +25,16 @@ def getVersionName = {
 buildscript {
     repositories {
         jcenter()
+        maven {
+            url 'https://maven.google.com'
+        }
+        maven {
+            url 'https://dl.google.com/dl/android/maven2/'
+        }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.0'
+        classpath 'com.android.tools.build:gradle:3.0.0-alpha5'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3'
     }
@@ -44,24 +50,30 @@ allprojects {
 
     repositories {
         jcenter()
+        maven {
+            url 'https://maven.google.com'
+        }
+        maven {
+            url 'https://dl.google.com/dl/android/maven2/'
+        }
     }
 }
 
 android {
-    compileSdkVersion 24
-    buildToolsVersion "25.0.2"
+    compileSdkVersion 26
+    buildToolsVersion '26.0.0'
 
     defaultConfig {
-        minSdkVersion 7
-        targetSdkVersion 23
+        // Unfortunately 'com.android.support:appcompat-v7:26.0.0-beta1'
+        // requires minSdkVersion 14, forcing a bump verson minSdkVersion 7
+        // But since only 0.8% of Android devices have < SDK 14 as of Une 2017, this will become
+        // the new min version for this library in order to target Android O
+        minSdkVersion 14
+        targetSdkVersion 26
         versionCode 1
         versionName version
         consumerProguardFiles 'proguard-rules.pro'
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
-        testOptions {
-            // The test runner needs Espresso 2.2.2 which requires at least 8
-            minSdkVersion 8
-        }
     }
 
     compileOptions {
@@ -84,6 +96,7 @@ android {
 
 dependencies {
     compile fileTree ( dir: 'libs', include: ['*.jar'] )
+    compile 'com.android.support:appcompat-v7:26.0.0-beta2'
     compile 'com.android.support:support-annotations:25.3.1'
 
     testCompile('junit:junit:4.12') {
diff --git a/circle.yml b/circle.yml
index dc4aa38b..048d01a5 100644
--- a/circle.yml
+++ b/circle.yml
@@ -3,5 +3,7 @@ machine:
     version: openjdk8
 dependencies:
   pre:
-    - echo y | android update sdk --no-ui --all --filter "tools,android-24,build-tools-25.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
-
+    - echo y | android update sdk --no-ui --all --filter "tools,android-26,build-tools-26.0.0,platform-tools,extra-android-m2repository,extra-google-m2repository"
+general:
+  branches:
+    ignore:
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 388ee27b..338ddfc1 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,6 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-milestone-1-all.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-4.0-milestone-1-all.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index 0e9fb7ae..cc3f5ef6 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -28,6 +28,8 @@
             android:exported="false"
             />
 
+        <service android:name=".service.ScanJob"
+                android:permission="android.permission.BIND_JOB_SERVICE" />
     </application>
 
 </manifest>
diff --git a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index b2d11269..1f63462e 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -35,7 +35,19 @@
 
 /**
  * Converts internal intents to notifier callbacks
- * This IntentService may be running in a different process from the BeaconService.
+ *
+ * This is used with the BeaconService and supports scanning in a separate process.
+ * It is not used with the ScanJob, as an IntentService will not be able to be started in some cases
+ * where the app is in the background on Android O.
+ *
+ * @see BeaconLocalBroadcastProcessor for the equivalent use with ScanJob.
+ *
+ * This IntentService may be running in a different process from the BeaconService, which justifies
+ * its continued existence for multi-process service cases.
+ *
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
  */
 public class BeaconIntentProcessor extends IntentService {
     private static final String TAG = "BeaconIntentProcessor";
@@ -46,62 +58,6 @@ public BeaconIntentProcessor() {
 
     @Override
     protected void onHandleIntent(Intent intent) {
-        LogManager.d(TAG, "got an intent to process");
-
-        MonitoringData monitoringData = null;
-        RangingData rangingData = null;
-
-        if (intent != null && intent.getExtras() != null) {
-            if (intent.getExtras().getBundle("monitoringData") != null) {
-                monitoringData = MonitoringData.fromBundle(intent.getExtras().getBundle("monitoringData"));
-            }
-            if (intent.getExtras().getBundle("rangingData") != null) {
-                rangingData = RangingData.fromBundle(intent.getExtras().getBundle("rangingData"));
-            }
-        }
-
-        if (rangingData != null) {
-            LogManager.d(TAG, "got ranging data");
-            if (rangingData.getBeacons() == null) {
-                LogManager.w(TAG, "Ranging data has a null beacons collection");
-            }
-            Set<RangeNotifier> notifiers = BeaconManager.getInstanceForApplication(this).getRangingNotifiers();
-            java.util.Collection<Beacon> beacons = rangingData.getBeacons();
-            if (notifiers != null) {
-                for(RangeNotifier notifier : notifiers){
-                    notifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
-                }
-            }
-            else {
-                LogManager.d(TAG, "but ranging notifier is null, so we're dropping it.");
-            }
-            RangeNotifier dataNotifier = BeaconManager.getInstanceForApplication(this).getDataRequestNotifier();
-            if (dataNotifier != null) {
-                dataNotifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
-            }
-        }
-
-        if (monitoringData != null) {
-            LogManager.d(TAG, "got monitoring data");
-            Set<MonitorNotifier> notifiers = BeaconManager.getInstanceForApplication(this).getMonitoringNotifiers();
-            if (notifiers != null) {
-                for(MonitorNotifier notifier : notifiers) {
-                    LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
-                    Region region = monitoringData.getRegion();
-                    Integer state = monitoringData.isInside() ? MonitorNotifier.INSIDE :
-                            MonitorNotifier.OUTSIDE;
-                    notifier.didDetermineStateForRegion(state, region);
-                    // In case the beacon scanner is running in a separate process, the monitoring
-                    // status in this process  will not have been updated yet as a result of this
-                    // region state change.  We make a call here to keep it in sync.
-                    MonitoringStatus.getInstanceForApplication(this).updateLocalState(region, state);
-                    if (monitoringData.isInside()) {
-                        notifier.didEnterRegion(monitoringData.getRegion());
-                    } else {
-                        notifier.didExitRegion(monitoringData.getRegion());
-                    }
-                }
-            }
-        }
+        new IntentHandler().convertIntentsToCallbacks(this.getApplicationContext(), intent);
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
new file mode 100644
index 00000000..8794252c
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
@@ -0,0 +1,92 @@
+/**
+ * Radius Networks, Inc.
+ * http://www.radiusnetworks.com
+ *
+ * @author David G. Young
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.altbeacon.beacon;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.annotation.NonNull;
+import android.support.v4.content.LocalBroadcastManager;
+
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.Set;
+
+/**
+ * Converts internal intents to notifier callbacks
+ *
+ * This is used with ScanJob and supports delivering intents even under Android O background
+ * restrictions preventing starting a new IntentService.
+ *
+ * It is not used with the BeaconService, as local broadcast intents cannot be deliverd across
+ * different processes which the BeaconService supports.
+ *
+ * @see BeaconIntentProcessor for the equivalent use with BeaconService.
+ **
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
+ */
+public class BeaconLocalBroadcastProcessor {
+    private static final String TAG = "BeaconLocalBroadcastProcessor";
+
+    public static final String RANGE_NOTIFICATION = "org.altbeacon.beacon.range_notification";
+    public static final String MONITOR_NOTIFICATION = "org.altbeacon.beacon.monitor_notification";
+
+    @NonNull
+    private Context mContext;
+    private BeaconLocalBroadcastProcessor() {
+
+    }
+    public BeaconLocalBroadcastProcessor(Context context) {
+        mContext = context;
+
+    }
+
+    static int registerCallCount = 0;
+    int registerCallCountForInstnace = 0;
+    public void register() {
+        registerCallCount += 1;
+        registerCallCountForInstnace += 1;
+        LogManager.d(TAG, "Register calls: global="+registerCallCount+" instance="+registerCallCountForInstnace);
+        unregister();
+        LocalBroadcastManager.getInstance(mContext).registerReceiver(mLocalBroadcastReceiver,
+                new IntentFilter(RANGE_NOTIFICATION));
+        LocalBroadcastManager.getInstance(mContext).registerReceiver(mLocalBroadcastReceiver,
+                new IntentFilter(MONITOR_NOTIFICATION));
+    }
+
+    public void unregister() {
+        LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mLocalBroadcastReceiver);
+    }
+
+
+    private BroadcastReceiver mLocalBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            new IntentHandler().convertIntentsToCallbacks(context, intent);
+        }
+    };
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 44fb41a2..18f74e08 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -31,6 +31,7 @@
 import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
+import android.os.Build;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
@@ -41,11 +42,15 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
 import org.altbeacon.beacon.service.BeaconService;
+import org.altbeacon.beacon.service.Callback;
 import org.altbeacon.beacon.service.MonitoringStatus;
 import org.altbeacon.beacon.service.RangeState;
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanJobScheduler;
+import org.altbeacon.beacon.service.ScanState;
 import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
@@ -64,6 +69,9 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CopyOnWriteArraySet;
 
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanState;
+
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
@@ -149,10 +157,9 @@
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
     private boolean mMainProcess = false;
-
     @Nullable
     private Boolean mScannerInSameProcess = null;
-
+    private boolean mScheduledScanJobsEnabled = false;
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
 
@@ -314,6 +321,7 @@ protected BeaconManager(@NonNull Context context) {
            verifyServiceDeclaration();
          }
         this.beaconParsers.add(new AltBeaconParser());
+        mScheduledScanJobsEnabled = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O;
     }
 
     /***
@@ -397,6 +405,11 @@ public void bind(@NonNull BeaconConsumer consumer) {
             LogManager.w(TAG, "This device does not support bluetooth LE.  Will not start beacon scanning.");
             return;
         }
+        if (mScheduledScanJobsEnabled) {
+            LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
+            consumer.onBeaconServiceConnect();
+            return;
+        }
         synchronized (consumers) {
             ConsumerInfo newConsumerInfo = new ConsumerInfo();
             ConsumerInfo alreadyBoundConsumerInfo = consumers.putIfAbsent(consumer, newConsumerInfo);
@@ -509,6 +522,55 @@ public void setBackgroundMode(boolean backgroundMode) {
         }
     }
 
+    /**
+     * Configures using a `ScanJob` run with the `JobScheduler` to perform scans rather than using a
+     * long-running `BeaconService` to do so.
+     *
+     * Calling with true on devices older than Android L (5.0) will not apply the change
+     * as the JobScheduler is not available.
+     *
+     * This value defaults to true on Android O+ and false on devices with older OS versions.
+     * Accepting the default value of false is recommended on Android N and earlier because
+     * otherwise beacon scans may be run only once every 15 minutes in the background, and no low
+     * power scans may be performed between scanning cycles.
+     *
+     * This method may only be called if bind() has not yet been called, otherwise an
+     * `IllegalStateException` is thown.
+     *
+     * @param enabled
+     */
+    public void setEnableScheduledScanJobs(boolean enabled) {
+        if (isAnyConsumerBound()) {
+            LogManager.e(TAG, "ScanJob may not be configured because a consumer is" +
+                    " already bound.");
+            throw new IllegalStateException("Method must be called before calling bind()");
+        }
+        if (enabled && android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            LogManager.e(TAG, "ScanJob may not be configured because JobScheduler is not" +
+                    " availble prior to Android 5.0");
+            return;
+        }
+        mScheduledScanJobsEnabled = enabled;
+    }
+    public boolean getScheduledScanJobsEnabled() {
+        return mScheduledScanJobsEnabled;
+    }
+    public boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+    public long getBackgroundScanPeriod() {
+        return backgroundScanPeriod;
+    }
+    public long getBackgroundBetweenScanPeriod() {
+        return backgroundBetweenScanPeriod;
+    }
+    public long getForegroundScanPeriod() {
+        return foregroundScanPeriod;
+    }
+    public long getForegroundBetweenScanPeriod() {
+        return foregroundBetweenScanPeriod;
+    }
+
     /**
      * @return indicator of whether any calls have yet been made to set the
      * background mode
@@ -734,15 +796,10 @@ public void startRangingBeaconsInRegion(@NonNull Region region) throws RemoteExc
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
-        Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             rangedRegions.add(region);
         }
+        applyChangesToServices(BeaconService.MSG_START_RANGING, region);
     }
 
     /**
@@ -764,12 +821,6 @@ public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteExce
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             Region regionToRemove = null;
             for (Region rangedRegion : rangedRegions) {
@@ -779,6 +830,7 @@ public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteExce
             }
             rangedRegions.remove(regionToRemove);
         }
+        applyChangesToServices(BeaconService.MSG_STOP_RANGING, region);
     }
 
     /**
@@ -801,17 +853,14 @@ public void applySettings() {
     }
 
     protected void syncSettingsToService() {
-        if (serviceMessenger == null) {
-            LogManager.e(TAG, "The BeaconManager is not bound to the service.  Settings synchronization will fail.");
+        if (mScheduledScanJobsEnabled) {
+            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
             return;
         }
         try {
-            Message msg = Message.obtain(null, BeaconService.MSG_SYNC_SETTINGS, 0, 0);
-            msg.setData(new SettingsData().collect(mContext).toBundle());
-            serviceMessenger.send(msg);
-        }
-        catch (RemoteException e) {
-            LogManager.e(e, TAG, "Failed to sync settings to service");
+            applyChangesToServices(BeaconService.MSG_SYNC_SETTINGS, null);
+        } catch (RemoteException e) {
+            LogManager.e(TAG, "Failed to sync settings to service", e);
         }
     }
 
@@ -835,13 +884,11 @@ public void startMonitoringBeaconsInRegion(@NonNull Region region) throws Remote
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (mScheduledScanJobsEnabled) {
+            MonitoringStatus.getInstanceForApplication(mContext).addRegion(region, new Callback(callbackPackageName()));
         }
-        LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
-        Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
+        applyChangesToServices(BeaconService.MSG_START_MONITORING, region);
+
         if (isScannerInDifferentProcess()) {
             MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
         }
@@ -868,18 +915,15 @@ public void stopMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteE
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (mScheduledScanJobsEnabled) {
+            MonitoringStatus.getInstanceForApplication(mContext).removeRegion(region);
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
+        applyChangesToServices(BeaconService.MSG_STOP_MONITORING, region);
         if (isScannerInDifferentProcess()) {
             MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
         }
     }
 
-
     /**
      * Updates an already running scan with scanPeriod/betweenScanPeriod according to Background/Foreground state.
      * Change will take effect on the start of the next scan cycle.
@@ -895,13 +939,30 @@ public void updateScanPeriods() throws RemoteException {
         if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
+        LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
+        LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
+        applyChangesToServices(BeaconService.MSG_SET_SCAN_PERIODS, null);
+    }
+
+    @TargetApi(18)
+    private void applyChangesToServices(int type, Region region) throws RemoteException {
+        if (mScheduledScanJobsEnabled) {
+            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            return;
+        }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
-        LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
-        LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
-        msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+        Message msg = Message.obtain(null, type, 0, 0);
+        if (type == BeaconService.MSG_SET_SCAN_PERIODS) {
+            msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+        }
+        else if (type == BeaconService.MSG_SYNC_SETTINGS) {
+            msg.setData(new SettingsData().collect(mContext).toBundle());
+        }
+        else {
+            msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(), mBackgroundMode).toBundle());
+        }
         serviceMessenger.send(msg);
     }
 
@@ -1136,7 +1197,7 @@ private void verifyServiceDeclaration() {
         List<ResolveInfo> resolveInfo =
                 packageManager.queryIntentServices(intent,
                         PackageManager.MATCH_DEFAULT_ONLY);
-        if (resolveInfo != null && resolveInfo.size() == 0) {
+        if (resolveInfo != null && resolveInfo.isEmpty()) {
             throw new ServiceNotDeclaredException();
         }
     }
diff --git a/src/main/java/org/altbeacon/beacon/IntentHandler.java b/src/main/java/org/altbeacon/beacon/IntentHandler.java
new file mode 100644
index 00000000..6e6c84a7
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/IntentHandler.java
@@ -0,0 +1,85 @@
+package org.altbeacon.beacon;
+
+import android.content.Context;
+import android.content.Intent;
+
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.MonitoringData;
+import org.altbeacon.beacon.service.MonitoringStatus;
+import org.altbeacon.beacon.service.RangingData;
+
+import java.util.Set;
+
+/**
+ * Converts internal Intents for ranging/monitoring to notifier callbacks.
+ * These may be local broadcast intents from BeaconLocalBroadcastProcessor or
+ * global broadcast intents fro BeaconIntentProcessor
+ *
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
+ * Created by dyoung on 7/20/17.
+ */
+
+/* package private*/
+class IntentHandler {
+    private static final String TAG = IntentHandler.class.getSimpleName();
+    public void convertIntentsToCallbacks(Context context, Intent intent) {
+        MonitoringData monitoringData = null;
+        RangingData rangingData = null;
+
+        if (intent != null && intent.getExtras() != null) {
+            if (intent.getExtras().getBundle("monitoringData") != null) {
+                monitoringData = MonitoringData.fromBundle(intent.getExtras().getBundle("monitoringData"));
+            }
+            if (intent.getExtras().getBundle("rangingData") != null) {
+                rangingData = RangingData.fromBundle(intent.getExtras().getBundle("rangingData"));
+            }
+        }
+
+        if (rangingData != null) {
+            LogManager.d(TAG, "got ranging data");
+            if (rangingData.getBeacons() == null) {
+                LogManager.w(TAG, "Ranging data has a null beacons collection");
+            }
+            Set<RangeNotifier> notifiers = BeaconManager.getInstanceForApplication(context).getRangingNotifiers();
+            java.util.Collection<Beacon> beacons = rangingData.getBeacons();
+            if (notifiers != null) {
+                for(RangeNotifier notifier : notifiers){
+                    notifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
+                }
+            }
+            else {
+                LogManager.d(TAG, "but ranging notifier is null, so we're dropping it.");
+            }
+            RangeNotifier dataNotifier = BeaconManager.getInstanceForApplication(context).getDataRequestNotifier();
+            if (dataNotifier != null) {
+                dataNotifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
+            }
+        }
+
+        if (monitoringData != null) {
+            LogManager.d(TAG, "got monitoring data");
+            Set<MonitorNotifier> notifiers = BeaconManager.getInstanceForApplication(context).getMonitoringNotifiers();
+            if (notifiers != null) {
+                for(MonitorNotifier notifier : notifiers) {
+                    LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
+                    Region region = monitoringData.getRegion();
+                    Integer state = monitoringData.isInside() ? MonitorNotifier.INSIDE :
+                            MonitorNotifier.OUTSIDE;
+                    notifier.didDetermineStateForRegion(state, region);
+                    // In case the beacon scanner is running in a separate process, the monitoring
+                    // status in this process  will not have been updated yet as a result of this
+                    // region state change.  We make a call here to keep it in sync.
+                    MonitoringStatus.getInstanceForApplication(context).updateLocalState(region, state);
+                    if (monitoringData.isInside()) {
+                        notifier.didEnterRegion(monitoringData.getRegion());
+                    } else {
+                        notifier.didExitRegion(monitoringData.getRegion());
+                    }
+                }
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 621fd239..37ae6ff2 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -24,18 +24,14 @@
 package org.altbeacon.beacon.service;
 
 
-import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
 import android.app.Service;
-import android.bluetooth.BluetoothDevice;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.ApplicationInfo;
 import android.content.pm.PackageItemInfo;
 import android.content.pm.PackageManager;
-import android.os.AsyncTask;
 import android.os.Binder;
 import android.os.Build;
 import android.os.Handler;
@@ -44,8 +40,8 @@
 import android.os.Message;
 import android.os.Messenger;
 import android.support.annotation.MainThread;
-import android.support.annotation.NonNull;
-import android.support.annotation.WorkerThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -56,25 +52,15 @@
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
-import org.altbeacon.beacon.service.scanner.CycledLeScanner;
-import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
-import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.beacon.utils.ProcessUtils;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
 
 import static android.app.PendingIntent.FLAG_ONE_SHOT;
 import static android.app.PendingIntent.getBroadcast;
@@ -85,22 +71,9 @@
 
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
-
-    private final Map<Region, RangeState> rangedRegionState = new HashMap<Region, RangeState>();
-    private MonitoringStatus monitoringStatus;
-
-    int trackedBeaconsPacketCount;
     private final Handler handler = new Handler();
     private BluetoothCrashResolver bluetoothCrashResolver;
-    private DistanceCalculator defaultDistanceCalculator = null;
-    private BeaconManager beaconManager;
-    private Set<BeaconParser> beaconParsers  = new HashSet<BeaconParser>();
-    private CycledLeScanner mCycledScanner;
-    private boolean mBackgroundFlag = false;
-    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
-    private ExecutorService mExecutor;
-    private final DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
-
+    private ScanHelper mScanHelper;
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -123,8 +96,6 @@
      *
      */
 
-    private List<Beacon> simulatedScanData = null;
-
     /**
      * Class used for the client Binder.  Because we know this service always
      * runs in the same process as its clients, we don't need to deal with IPC.
@@ -225,14 +196,16 @@ public void onCreate() {
         bluetoothCrashResolver = new BluetoothCrashResolver(this);
         bluetoothCrashResolver.start();
 
-        // Create a private executor so we don't compete with threads used by AsyncTask
-        // This uses fewer threads than the default executor so it won't hog CPU
-        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
-
-        mCycledScanner = CycledLeScanner.createScanner(this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
-                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag, mCycledLeScanCallback, bluetoothCrashResolver);
+        mScanHelper = new ScanHelper(this);
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(false, bluetoothCrashResolver);
+        }
+        mScanHelper.setMonitoringStatus(MonitoringStatus.getInstanceForApplication(this));
+        mScanHelper.setRangedRegionState(new HashMap<Region, RangeState>());
+        mScanHelper.setBeaconParsers(new HashSet<BeaconParser>());
+        mScanHelper.setExtraDataBeaconTracker(new ExtraDataBeaconTracker());
 
-        beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
         beaconManager.setScannerInSameProcess(true);
         if (beaconManager.isMainProcess()) {
             LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
@@ -248,21 +221,20 @@ public void onCreate() {
             if (info != null && info.metaData != null && info.metaData.get("longScanForcingEnabled") != null &&
                     info.metaData.get("longScanForcingEnabled").toString().equals("true")) {
                 LogManager.i(TAG, "longScanForcingEnabled to keep scans going on Android N for > 30 minutes");
-                mCycledScanner.setLongScanForcingEnabled(true);
+                mScanHelper.getCycledScanner().setLongScanForcingEnabled(true);
             }
         } catch (PackageManager.NameNotFoundException e) {}
 
-        reloadParsers();
+        mScanHelper.reloadParsers();
 
-        defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
+        DistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
 
-        monitoringStatus = MonitoringStatus.getInstanceForApplication(getApplicationContext());
         // Look for simulated scan data
         try {
             Class klass = Class.forName("org.altbeacon.beacon.SimulatedScanData");
             java.lang.reflect.Field f = klass.getField("beacons");
-            this.simulatedScanData = (List<Beacon>) f.get(null);
+            mScanHelper.setSimulatedScanData((List<Beacon>) f.get(null));
         } catch (ClassNotFoundException e) {
             LogManager.d(TAG, "No org.altbeacon.beacon.SimulatedScanData class exists.");
         } catch (Exception e) {
@@ -270,25 +242,6 @@ public void onCreate() {
         }
     }
 
-    protected void reloadParsers() {
-        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
-        //flatMap all beacon parsers
-        boolean matchBeaconsByServiceUUID = true;
-        if (beaconManager.getBeaconParsers() != null) {
-            newBeaconParsers.addAll(beaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
-            }
-        }
-        beaconParsers = newBeaconParsers;
-        //initialize the extra data beacon tracker
-        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
-    }
-
-
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         LogManager.i(TAG,
@@ -327,9 +280,9 @@ public void onDestroy() {
         bluetoothCrashResolver.stop();
         LogManager.i(TAG, "onDestroy called.  stopping scanning");
         handler.removeCallbacksAndMessages(null);
-        mCycledScanner.stop();
-        mCycledScanner.destroy();
-        monitoringStatus.stopStatusPreservation();
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        mScanHelper.getMonitoringStatus().stopStatusPreservation();
     }
 
     @Override
@@ -355,246 +308,60 @@ private PendingIntent getRestartIntent() {
      */
     @MainThread
     public void startRangingBeaconsInRegion(Region region, Callback callback) {
-        synchronized (rangedRegionState) {
-            if (rangedRegionState.containsKey(region)) {
+        synchronized (mScanHelper.getRangedRegionState()) {
+            if (mScanHelper.getRangedRegionState().containsKey(region)) {
                 LogManager.i(TAG, "Already ranging that region -- will replace existing region.");
-                rangedRegionState.remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
+                mScanHelper.getRangedRegionState().remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
             }
-            rangedRegionState.put(region, new RangeState(callback));
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+            mScanHelper.getRangedRegionState().put(region, new RangeState(callback));
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
-        mCycledScanner.start();
+        mScanHelper.getCycledScanner().start();
     }
 
     @MainThread
     public void stopRangingBeaconsInRegion(Region region) {
         int rangedRegionCount;
-        synchronized (rangedRegionState) {
-            rangedRegionState.remove(region);
-            rangedRegionCount = rangedRegionState.size();
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+        synchronized (mScanHelper.getRangedRegionState()) {
+            mScanHelper.getRangedRegionState().remove(region);
+            rangedRegionCount = mScanHelper.getRangedRegionState().size();
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
 
-        if (rangedRegionCount == 0 && monitoringStatus.regionsCount() == 0) {
-            mCycledScanner.stop();
+        if (rangedRegionCount == 0 && mScanHelper.getMonitoringStatus().regionsCount() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
     @MainThread
     public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
         LogManager.d(TAG, "startMonitoring called");
-        monitoringStatus.addRegion(region, callback);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        mCycledScanner.start();
+        mScanHelper.getMonitoringStatus().addRegion(region, callback);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        mScanHelper.getCycledScanner().start();
     }
 
     @MainThread
     public void stopMonitoringBeaconsInRegion(Region region) {
         LogManager.d(TAG, "stopMonitoring called");
-        monitoringStatus.removeRegion(region);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        if (monitoringStatus.regionsCount() == 0 && rangedRegionState.size() == 0) {
-            mCycledScanner.stop();
+        mScanHelper.getMonitoringStatus().removeRegion(region);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        if (mScanHelper.getMonitoringStatus().regionsCount() == 0 && mScanHelper.getRangedRegionState().size() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
     @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        mCycledScanner.setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
-    }
-
-    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
-        @MainThread
-        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-        @Override
-        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
-
-            NonBeaconLeScanCallback nonBeaconLeScanCallback = beaconManager.getNonBeaconLeScanCallback();
-
-            try {
-                new ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
-                        new ScanData(device, rssi, scanRecord));
-            } catch (RejectedExecutionException e) {
-                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
-            }
-        }
-
-        @MainThread
-        @Override
-        public void onCycleEnd() {
-            mDistinctPacketDetector.clearDetections();
-            monitoringStatus.updateNewlyOutside();
-            processRangeData();
-            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
-            if (simulatedScanData != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
-
-                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                    for (Beacon beacon : simulatedScanData) {
-                        // This is an expensive call and we do not want to block the main thread.
-                        // But here we are in debug/test mode so we allow it on the main thread.
-                        //noinspection WrongThread
-                        processBeaconFromScan(beacon);
-                    }
-                } else {
-                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
-                }
-            }
-            if (BeaconManager.getBeaconSimulator() != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
-                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
-                            // This is an expensive call and we do not want to block the main thread.
-                            // But here we are in debug/test mode so we allow it on the main thread.
-                            //noinspection WrongThread
-                            processBeaconFromScan(beacon);
-                        }
-                    } else {
-                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
-                    }
-                } else {
-                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
-                }
-            }
-        }
-    };
-
-    private void processRangeData() {
-        synchronized (rangedRegionState) {
-            for (Region region : rangedRegionState.keySet()) {
-                RangeState rangeState = rangedRegionState.get(region);
-                LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
-            }
-        }
-    }
-
-    /**
-     * Helper for processing BLE beacons. This has been extracted from {@link ScanProcessor} to
-     * support simulated scan data for test and debug environments.
-     * <p>
-     * Processing beacons is a frequent and expensive operation. It should not be run on the main
-     * thread to avoid UI contention.
-     */
-    @WorkerThread
-    private void processBeaconFromScan(@NonNull Beacon beacon) {
-        if (Stats.getInstance().isEnabled()) {
-            Stats.getInstance().log(beacon);
-        }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG,
-                    "beacon detected : %s", beacon.toString());
-        }
-
-        beacon = mExtraDataBeaconTracker.track(beacon);
-        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
-        // the above
-        if (beacon == null) {
-            if (LogManager.isVerboseLoggingEnabled()) {
-                LogManager.d(TAG,
-                        "not processing detections for GATT extra data beacon");
-            }
-        } else {
-
-            monitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
-
-            List<Region> matchedRegions = null;
-            Iterator<Region> matchedRegionIterator;
-            LogManager.d(TAG, "looking for ranging region matches for this beacon");
-            synchronized (rangedRegionState) {
-                matchedRegions = matchingRegions(beacon, rangedRegionState.keySet());
-                matchedRegionIterator = matchedRegions.iterator();
-                while (matchedRegionIterator.hasNext()) {
-                    Region region = matchedRegionIterator.next();
-                    LogManager.d(TAG, "matches ranging region: %s", region);
-                    RangeState rangeState = rangedRegionState.get(region);
-                    if (rangeState != null) {
-                        rangeState.addBeacon(beacon);
-                    }
-                }
-            }
-        }
+        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
     }
 
-
-    /**
-     * <strong>This class is not thread safe.</strong>
-     */
-    private static class ScanData {
-        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
-            this.device = device;
-            this.rssi = rssi;
-            this.scanRecord = scanRecord;
-        }
-
-        final int rssi;
-
-        @NonNull
-        final BluetoothDevice device;
-
-        @NonNull
-        final byte[] scanRecord;
+    public void reloadParsers() {
+        mScanHelper.reloadParsers();
     }
 
-    private class ScanProcessor extends AsyncTask<ScanData, Void, Void> {
-        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
-
-        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-
-        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
-            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
-        }
-
-        @WorkerThread
-        @Override
-        protected Void doInBackground(ScanData... params) {
-            ScanData scanData = params[0];
-            Beacon beacon = null;
-
-            for (BeaconParser parser : beaconParsers) {
-                beacon = parser.fromScanData(scanData.scanRecord,
-                        scanData.rssi, scanData.device);
-
-                if (beacon != null) {
-                    break;
-                }
-            }
-            if (beacon != null) {
-                if (LogManager.isVerboseLoggingEnabled()) {
-                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
-                }
-                mDetectionTracker.recordDetection();
-                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
-                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
-                            scanData.scanRecord)) {
-                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unnecessary.");
-                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
-                    }
-                }
-                trackedBeaconsPacketCount++;
-                processBeaconFromScan(beacon);
-            } else {
-                if (mNonBeaconLeScanCallback != null) {
-                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
-                }
-            }
-            return null;
-        }
-    }
-
-    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<Region>();
-        for (Region region : regions) {
-            if (region.matchesBeacon(beacon)) {
-                matched.add(region);
-            } else {
-                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
-            }
-        }
-        return matched;
+    @RestrictTo(Scope.TESTS)
+    protected CycledLeScanCallback getCycledLeScanCallback() {
+        return mScanHelper.getCycledLeScanCallback();
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index 9d239c95..a8c9ad92 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -27,7 +27,10 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
 
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
+import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
 import java.io.IOException;
@@ -35,23 +38,9 @@
 
 public class Callback implements Serializable {
     private static final String TAG = "Callback";
-    private transient Intent mIntent;
-    private String mIntentPackageName;
 
+    //TODO: Remove this constructor in favor of an empty one, as the packae name is no longer needed
     public Callback(String intentPackageName) {
-        mIntentPackageName = intentPackageName;
-        initializeIntent();
-    }
-
-    private void initializeIntent() {
-        if (mIntentPackageName != null) {
-            mIntent = new Intent();
-            mIntent.setComponent(new ComponentName(mIntentPackageName, "org.altbeacon.beacon.BeaconIntentProcessor"));
-        }
-    }
-
-    public Intent getIntent() {
-        return mIntent;
     }
 
     /**
@@ -63,20 +52,34 @@ public Intent getIntent() {
      * @return false if it callback cannot be made
      */
     public boolean call(Context context, String dataName, Bundle data) {
-        if(mIntent == null){
-            initializeIntent();
-        }
+        boolean useLocalBroadcast = BeaconManager.getInstanceForApplication(context).getScheduledScanJobsEnabled();
         boolean success = false;
-        if (mIntent != null) {
-            LogManager.d(TAG, "attempting callback via intent: %s", mIntent.getComponent());
-            mIntent.putExtra(dataName, data);
+
+        if(useLocalBroadcast) {
+            String action = null;
+            if (dataName == "rangingData") {
+                action = BeaconLocalBroadcastProcessor.RANGE_NOTIFICATION;
+            }
+            else {
+                action = BeaconLocalBroadcastProcessor.MONITOR_NOTIFICATION;
+            }
+            Intent intent = new Intent(action);
+            intent.putExtra(dataName, data);
+            LogManager.d(TAG, "attempting callback via local broadcast intent: %s",action);
+            success = LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
+        }
+        else {
+            Intent intent = new Intent();
+            intent.setComponent(new ComponentName(context.getPackageName(), "org.altbeacon.beacon.BeaconIntentProcessor"));
+            intent.putExtra(dataName, data);
+            LogManager.d(TAG, "attempting callback via global broadcast intent: %s",intent.getComponent());
             try {
-                context.startService(mIntent);
+                context.startService(intent);
                 success = true;
             } catch (Exception e) {
                 LogManager.e(
                         TAG,
-                        "Failed attempting to start service: " + mIntent.getComponent().flattenToString(),
+                        "Failed attempting to start service: " + intent.getComponent().flattenToString(),
                         e
                 );
             }
@@ -88,6 +91,5 @@ public boolean call(Context context, String dataName, Bundle data) {
     private void readObject(java.io.ObjectInputStream in)
             throws IOException, ClassNotFoundException {
         in.defaultReadObject();
-        initializeIntent();
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
index a93e8fb2..303efdd4 100644
--- a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
@@ -2,6 +2,7 @@
 
 import org.altbeacon.beacon.Beacon;
 
+import java.io.Serializable;
 import java.util.HashMap;
 
 /**
@@ -9,7 +10,7 @@
  * merges them together depending on configured beacon parsers
  * Created by dyoung on 5/5/15.
  */
-public class ExtraDataBeaconTracker {
+public class ExtraDataBeaconTracker implements Serializable {
     private static final String TAG = "BeaconTracker";
     // This is a lookup table to find tracked beacons by the calculated beacon key
     private HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<String,HashMap<Integer,Beacon>>();
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index 0c1ad59e..fd9ed912 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -26,14 +26,15 @@
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
-public class RangeState {
+public class RangeState implements Serializable {
     private static final String TAG = "RangeState";
-    private final Callback mCallback;
+    private Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
     private static boolean sUseTrackingCache = false;
 
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index 83c658f2..905f6b0d 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -6,9 +6,10 @@
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
-public class RangedBeacon {
+public class RangedBeacon implements Serializable {
 
     private static final String TAG = "RangedBeacon";
     public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
@@ -19,16 +20,9 @@
     private boolean mTracked = true;
     protected long lastTrackedTimeMillis = 0;
     Beacon mBeacon;
-    protected RssiFilter filter = null;
+    protected transient RssiFilter mFilter = null;
 
     public RangedBeacon(Beacon beacon) {
-        //set RSSI filter
-        try {
-            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
-            filter = (RssiFilter)cons.newInstance();
-        } catch (Exception e) {
-            LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
-        }
         updateBeacon(beacon);
     }
 
@@ -51,10 +45,11 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-        if (!filter.noMeasurementsAvailable()) {
-            double runningAverage = filter.calculateRssi();
-            mBeacon.setRunningAverageRssi(runningAverage);
-            LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
+         if (!getFilter().noMeasurementsAvailable()) {
+             double runningAverage = getFilter().calculateRssi();
+             mBeacon.setRunningAverageRssi(runningAverage);
+             LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
         else {
             LogManager.d(TAG, "No measurements available to calculate running average");
@@ -67,7 +62,7 @@ public void addMeasurement(Integer rssi) {
         if (rssi != 127) {
             mTracked = true;
             lastTrackedTimeMillis = SystemClock.elapsedRealtime();
-            filter.addMeasurement(rssi);
+            getFilter().addMeasurement(rssi);
         }
     }
 
@@ -82,7 +77,7 @@ public static void setMaxTrackinAge(int maxTrackinAge) {
     }
 
     public boolean noMeasurementsAvailable() {
-        return filter.noMeasurementsAvailable();
+        return getFilter().noMeasurementsAvailable();
     }
 
     public long getTrackingAge() {
@@ -93,4 +88,17 @@ public boolean isExpired() {
         return getTrackingAge() > maxTrackingAge;
     }
 
+    private RssiFilter getFilter() {
+        if (mFilter == null) {
+            //set RSSI filter
+            try {
+            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
+                mFilter = (RssiFilter)cons.newInstance();
+            } catch (Exception e) {
+                LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
+            }
+        }
+        return mFilter;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
new file mode 100644
index 00000000..758f0995
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
@@ -0,0 +1,173 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.Service;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.le.ScanResult;
+import android.content.pm.ApplicationInfo;
+import android.os.Build;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Created by dyoung on 3/24/17.
+ * @hice
+ */
+
+public class ScanDataProcessor {
+    private static final String TAG = ScanDataProcessor.class.getSimpleName();
+    private Service mService;
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    // TODO: implement this
+    private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+    private DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+    int trackedBeaconsPacketCount;
+
+
+    public ScanDataProcessor(Service scanService, ScanState scanState) {
+        mService = scanService;
+        mMonitoringStatus = scanState.getMonitoringStatus();
+        mRangedRegionState = scanState.getRangedRegionState();
+        mMonitoringStatus = scanState.getMonitoringStatus();
+        mExtraDataBeaconTracker = scanState.getExtraBeaconDataTracker();
+        mBeaconParsers = scanState.getBeaconParsers();
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public void process(ScanResult scanResult) {
+        ScanData scanData= new ScanData(scanResult.getDevice(), scanResult.getRssi(), scanResult.getScanRecord().getBytes());
+        process(scanData);
+    }
+
+    public void process(ScanData scanData) {
+        Beacon beacon = null;
+
+        for (BeaconParser parser : mBeaconParsers) {
+            beacon = parser.fromScanData(scanData.scanRecord,
+                    scanData.rssi, scanData.device);
+
+            if (beacon != null) {
+                break;
+            }
+        }
+        if (beacon != null) {
+            mDetectionTracker.recordDetection();
+            trackedBeaconsPacketCount++;
+            processBeaconFromScan(beacon);
+        } else {
+            if (mNonBeaconLeScanCallback != null) {
+                mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+            }
+        }
+
+    }
+    private class ScanData {
+        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        int rssi;
+        BluetoothDevice device;
+        byte[] scanRecord;
+    }
+
+    private void processBeaconFromScan(Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions = null;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon out of "+mRangedRegionState.keySet().size()+" regions.");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<Region>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+
+    public void onCycleEnd() {
+        mMonitoringStatus.updateNewlyOutside();
+        processRangeData();
+        if (BeaconManager.getBeaconSimulator() != null) {
+            // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+            // it will not be used if we are not in debug mode
+            if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                if (0 != (mService.getApplicationContext().getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                }
+            } else {
+                LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+            }
+        }
+    }
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                Callback callback = new Callback(mService.getPackageName());
+                callback.call(mService, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
new file mode 100644
index 00000000..01aaef37
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -0,0 +1,402 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.ScanFilter;
+import android.bluetooth.le.ScanSettings;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.WorkerThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+import org.altbeacon.beacon.service.scanner.ScanFilterUtils;
+import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
+import org.altbeacon.bluetooth.BluetoothCrashResolver;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * Created by dyoung on 6/16/17.
+ *
+ * This is an internal utility class and should not be called directly by library users.
+ *
+ * This encapsulates shared data and methods used by both ScanJob and BeaconService
+ * that deal with the specifics of beacon scanning.
+ *
+ * @hide
+ */
+
+class ScanHelper {
+    private static final String TAG = ScanHelper.class.getSimpleName();
+    private ExecutorService mExecutor;
+    private BeaconManager mBeaconManager;
+    private CycledLeScanner mCycledScanner;
+    private MonitoringStatus mMonitoringStatus;
+    private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
+    private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<>();
+    private List<Beacon> mSimulatedScanData = null;
+    private Context mContext;
+
+    ScanHelper(Context context) {
+        mContext = context;
+        mBeaconManager = BeaconManager.getInstanceForApplication(context);
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
+    }
+
+    CycledLeScanner getCycledScanner() {
+        return mCycledScanner;
+    }
+
+    MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        synchronized (mRangedRegionState) {
+            mRangedRegionState.clear();
+            mRangedRegionState.putAll(rangedRegionState);
+        }
+    }
+
+    void setExtraDataBeaconTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraDataBeaconTracker = extraDataBeaconTracker;
+    }
+
+    void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    void setSimulatedScanData(List<Beacon> simulatedScanData) {
+        mSimulatedScanData = simulatedScanData;
+    }
+
+
+    void createCycledLeScanner(boolean backgroundMode, BluetoothCrashResolver crashResolver) {
+        mCycledScanner = CycledLeScanner.createScanner(mContext, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
+                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, backgroundMode,
+                mCycledLeScanCallback, crashResolver);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    void processScanResult(BluetoothDevice device, int rssi, byte[] scanRecord) {
+        NonBeaconLeScanCallback nonBeaconLeScanCallback = mBeaconManager.getNonBeaconLeScanCallback();
+
+        try {
+            new ScanHelper.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
+                    new ScanHelper.ScanData(device, rssi, scanRecord));
+        } catch (RejectedExecutionException e) {
+
+            LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+        }
+    }
+
+    void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<>();
+        //flatMap all beacon parsers
+        boolean matchBeaconsByServiceUUID = true;
+        newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
+        for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
+            if (beaconParser.getExtraDataParsers().size() > 0) {
+                matchBeaconsByServiceUUID = false;
+                newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
+            }
+        }
+        mBeaconParsers = newBeaconParsers;
+        //initialize the extra data beacon tracker
+        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    void startAndroidOBackgroundScan(Set<BeaconParser> beaconParsers) {
+        ScanSettings settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
+        List<ScanFilter> filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
+                new ArrayList<BeaconParser>(beaconParsers));
+        try {
+            final BluetoothManager bluetoothManager =
+                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();
+            if (bluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            }
+            else {
+                int result = bluetoothAdapter.getBluetoothLeScanner().startScan(filters, settings, getScanCallbackIntent());
+                if (result != 0) {
+                    LogManager.e(TAG, "Failed to start background scan on Android O.  Code: "+result);
+                }
+                else {
+                    LogManager.d(TAG, "Started passive beacon scan");
+                }
+            }
+        }
+        catch (SecurityException e) {
+            LogManager.e(TAG, "SecurityException making Android O background scanner");
+        }
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    void stopAndroidOBackgroundScan() {
+        try {
+            final BluetoothManager bluetoothManager =
+                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();
+            if (bluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            } else {
+                bluetoothAdapter.getBluetoothLeScanner().stopScan(getScanCallbackIntent());
+            }
+        } catch (SecurityException e) {
+            LogManager.e(TAG, "SecurityException stopping Android O background scanner");
+        }
+    }
+
+    // Low power scan results in the background will be delivered via Intent
+    PendingIntent getScanCallbackIntent() {
+        Intent intent = new Intent(mContext, StartupBroadcastReceiver.class);
+        intent.putExtra("o-scan", true);
+        return PendingIntent.getBroadcast(mContext,0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+    }
+
+    private final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+        @Override
+        @MainThread
+        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            processScanResult(device, rssi, scanRecord);
+        }
+
+        @Override
+        @MainThread
+        @SuppressLint("WrongThread")
+        public void onCycleEnd() {
+            mDistinctPacketDetector.clearDetections();
+            mMonitoringStatus.updateNewlyOutside();
+            processRangeData();
+            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
+            if (mSimulatedScanData != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
+
+                if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : mSimulatedScanData) {
+                        // This is an expensive call and we do not want to block the main thread.
+                        // But here we are in debug/test mode so we allow it on the main thread.
+                        //noinspection WrongThread
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
+                }
+            }
+            if (BeaconManager.getBeaconSimulator() != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                    if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                            // This is an expensive call and we do not want to block the main thread.
+                            // But here we are in debug/test mode so we allow it on the main thread.
+                            //noinspection WrongThread
+                            processBeaconFromScan(beacon);
+                        }
+                    } else {
+                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                    }
+                } else {
+                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+                }
+            }
+        }
+    };
+
+    @RestrictTo(Scope.TESTS)
+    CycledLeScanCallback getCycledLeScanCallback() {
+        return mCycledLeScanCallback;
+    }
+
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                rangeState.getCallback().call(mContext, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+    /**
+     * Helper for processing BLE beacons. This has been extracted from {@link ScanHelper.ScanProcessor} to
+     * support simulated scan data for test and debug environments.
+     * <p>
+     * Processing beacons is a frequent and expensive operation. It should not be run on the main
+     * thread to avoid UI contention.
+     */
+    @WorkerThread
+    private void processBeaconFromScan(@NonNull Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * <strong>This class is not thread safe.</strong>
+     */
+    private class ScanData {
+        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        final int rssi;
+
+        @NonNull
+        BluetoothDevice device;
+
+        @NonNull
+        byte[] scanRecord;
+    }
+
+    private class ScanProcessor extends AsyncTask<ScanHelper.ScanData, Void, Void> {
+        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+        ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
+            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
+        }
+
+        @WorkerThread
+        @Override
+        protected Void doInBackground(ScanHelper.ScanData... params) {
+            ScanHelper.ScanData scanData = params[0];
+            Beacon beacon = null;
+
+            for (BeaconParser parser : ScanHelper.this.mBeaconParsers) {
+                beacon = parser.fromScanData(scanData.scanRecord,
+                        scanData.rssi, scanData.device);
+
+                if (beacon != null) {
+                    break;
+                }
+            }
+            if (beacon != null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                }
+                mDetectionTracker.recordDetection();
+                if (mCycledScanner != null && !mCycledScanner.getDistinctPacketsDetectedPerScan()) {
+                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
+                            scanData.scanRecord)) {
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
+                    }
+                }
+                processBeaconFromScan(beacon);
+            } else {
+                if (mNonBeaconLeScanCallback != null) {
+                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+                }
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+        }
+
+        @Override
+        protected void onPreExecute() {
+        }
+
+        @Override
+        protected void onProgressUpdate(Void... values) {
+        }
+    }
+
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
new file mode 100644
index 00000000..57a41b8e
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -0,0 +1,192 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.job.JobParameters;
+import android.app.job.JobService;
+import android.bluetooth.le.ScanRecord;
+import android.bluetooth.le.ScanResult;
+import android.os.Build;
+import android.os.Handler;
+import android.support.annotation.NonNull;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
+import org.altbeacon.beacon.BuildConfig;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.utils.ProcessUtils;
+import java.util.List;
+
+
+/**
+ * Used to perform scans periodically using the JobScheduler
+ *
+ * Only one instance of this will be active, even with multiple jobIds.  If one job
+ * is already running when another is scheduled to start, onStartJob gets called again on the same
+ * instance.
+ *
+ * If the OS decides to create a new instance, it will call onStopJob() on the old instance
+ *
+ * Created by dyoung on 3/24/17.
+ * @hide
+ */
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+public class ScanJob extends JobService {
+    private static final String TAG = ScanJob.class.getSimpleName();
+    public static final int PERIODIC_SCAN_JOB_ID = 1;
+    /*
+        Periodic scan jobs are used in general, but they cannot be started immediately.  So we have
+        a second immediate scan job to kick off when scanning gets started or settings changed.
+        Once the periodic one gets run, the immediate is cancelled.
+     */
+    public static final int IMMMEDIATE_SCAN_JOB_ID = 2;
+
+    private ScanState mScanState;
+    private Handler mStopHandler = new Handler();
+    private ScanHelper mScanHelper;
+    private boolean mInitialized = false;
+
+    @Override
+    public boolean onStartJob(final JobParameters jobParameters) {
+        mScanHelper = new ScanHelper(this);
+        if (jobParameters.getJobId() == IMMMEDIATE_SCAN_JOB_ID) {
+            LogManager.i(TAG, "Running immdiate scan job: instance is "+this);
+        }
+        else {
+            LogManager.i(TAG, "Running periodic scan job: instance is "+this);
+        }
+
+        List<ScanResult> queuedScanResults = ScanJobScheduler.getInstance().dumpBackgroundScanResultQueue();
+        LogManager.d(TAG, "Processing %d queued scan resuilts", queuedScanResults.size());
+        for (ScanResult result : queuedScanResults) {
+            ScanRecord scanRecord = result.getScanRecord();
+            if (scanRecord != null) {
+                mScanHelper.processScanResult(result.getDevice(), result.getRssi(), scanRecord.getBytes());
+            }
+        }
+        LogManager.d(TAG, "Done processing queued scan resuilts");
+
+        boolean startedScan;
+        if (mInitialized) {
+            LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
+            startedScan = restartScanning();
+        }
+        else {
+            startedScan = startScanning();
+        }
+        mStopHandler.removeCallbacksAndMessages(null);
+
+        if (startedScan) {
+            LogManager.i(TAG, "Scan job running for "+mScanState.getScanJobRuntimeMillis()+" millis");
+            mStopHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    LogManager.i(TAG, "Scan job runtime expired");
+                    stopScanning();
+                    mScanState.save();
+
+                    startPassiveScanIfNeeded();
+
+                    ScanJob.this.jobFinished(jobParameters , false);
+                }
+            }, mScanState.getScanJobRuntimeMillis());
+        }
+        else {
+            LogManager.i(TAG, "No monitored or ranged regions. Scan job complete.");
+            ScanJob.this.jobFinished(jobParameters , false);
+        }
+        return true;
+    }
+
+    private void startPassiveScanIfNeeded() {
+        LogManager.d(TAG, "Checking to see if we need to start a passive scan");
+        boolean insideAnyRegion = false;
+        for (Region region : mScanState.getMonitoringStatus().regions()) {
+            RegionMonitoringState state = mScanState.getMonitoringStatus().stateOf(region);
+            if (state != null && state.getInside()) {
+                insideAnyRegion = true;
+            }
+        }
+        if (insideAnyRegion) {
+            // TODO: Set up a scan filter for not detecting a beacon pattern
+            LogManager.i(TAG, "We are inside a beacon region.  We will not scan between cycles.");
+        }
+        else {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                mScanHelper.startAndroidOBackgroundScan(mScanState.getBeaconParsers());
+            }
+            else {
+                LogManager.d(TAG, "This is not Android O.  No scanning between cycles when using ScanJob");
+            }
+        }
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters params) {
+        if (params.getJobId() == PERIODIC_SCAN_JOB_ID) {
+            LogManager.i(TAG, "onStopJob called for periodic scan");
+        }
+        else {
+            LogManager.i(TAG, "onStopJob called for immediate scan");
+        }
+        // Cancel the stop timer.  The OS is stopping prematurely
+        mStopHandler.removeCallbacksAndMessages(null);
+        stopScanning();
+        startPassiveScanIfNeeded();
+        return false;
+    }
+
+    private void stopScanning() {
+        mInitialized = false;
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        LogManager.d(TAG, "Scanning stopped");
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean restartScanning() {
+        mScanState = ScanState.restore(ScanJob.this);
+        mScanState.setLastScanStartTimeMillis(System.currentTimeMillis());
+        mScanHelper.setMonitoringStatus(mScanState.getMonitoringStatus());
+        mScanHelper.setRangedRegionState(mScanState.getRangedRegionState());
+        mScanHelper.setBeaconParsers(mScanState.getBeaconParsers());
+        mScanHelper.setExtraDataBeaconTracker(mScanState.getExtraBeaconDataTracker());
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
+        }
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            mScanHelper.stopAndroidOBackgroundScan();
+        }
+        mScanHelper.getCycledScanner().setScanPeriods(mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod(),
+                                      mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod(),
+                                      mScanState.getBackgroundMode());
+        mInitialized = true;
+        if (mScanHelper.getRangedRegionState().size() > 0 || mScanHelper.getMonitoringStatus().regions().size() > 0) {
+            mScanHelper.getCycledScanner().start();
+            return true;
+        }
+        else {
+            mScanHelper.getCycledScanner().stop();
+            return false;
+        }
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean startScanning() {
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        beaconManager.setScannerInSameProcess(true);
+        if (beaconManager.isMainProcess()) {
+            LogManager.i(TAG, "scanJob version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+        }
+        else {
+            LogManager.i(TAG, "beaconScanJob library version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(ScanJob.this);
+            LogManager.i(TAG, "beaconScanJob PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
+        }
+        ModelSpecificDistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(ScanJob.this, BeaconManager.getDistanceModelUpdateUrl());
+        Beacon.setDistanceCalculator(defaultDistanceCalculator);
+        return restartScanning();
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
new file mode 100644
index 00000000..43ed2699
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -0,0 +1,236 @@
+package org.altbeacon.beacon.service;
+
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.bluetooth.le.ScanResult;
+import android.content.ComponentName;
+import android.content.Context;
+import android.os.Build;
+import android.os.PersistableBundle;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Schedules two types of ScanJobs:
+ *  1. Periodic, which are set to go every scanPeriod+betweenScanPeriod
+ *  2. Immediate, which go right now.
+ *
+ *  Immediate ScanJobs are used when the app is in the foreground and wants to get immediate results
+ *  or when beacons have been detected with background scan filters and delivered via Intents and
+ *  a scan needs to run in a timely manner to collect data about those beacons known to be newly
+ *  in the vicinity despite the app being in the background.
+ *
+ * Created by dyoung on 6/7/17.
+ * @hide
+ */
+@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+public class ScanJobScheduler {
+    private static final String TAG = ScanJobScheduler.class.getSimpleName();
+    private static final Object SINGLETON_LOCK = new Object();
+    private static final long MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING = 10000L;
+    @Nullable
+    private static volatile ScanJobScheduler sInstance = null;
+    @NonNull
+    private Long mScanJobScheduleTime = 0L;
+    @NonNull
+    private List<ScanResult> mBackgroundScanResultQueue = new ArrayList<>();
+    @Nullable
+    private BeaconLocalBroadcastProcessor mBeaconNotificationProcessor;
+
+    @NonNull
+    public static ScanJobScheduler getInstance() {
+        ScanJobScheduler instance = sInstance;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = sInstance;
+                if (instance == null) {
+                    sInstance = instance = new ScanJobScheduler();
+                }
+            }
+        }
+        return instance;
+    }
+
+    private ScanJobScheduler() {
+    }
+
+    private void ensureNotificationProcessorSetup(Context context) {
+        if (mBeaconNotificationProcessor == null) {
+            mBeaconNotificationProcessor = new BeaconLocalBroadcastProcessor(context);
+            mBeaconNotificationProcessor.register();
+        }
+    }
+
+    /**
+     * @return previoulsy queued scan results delivered in the background
+     */
+    List<ScanResult> dumpBackgroundScanResultQueue() {
+        List<ScanResult> retval = mBackgroundScanResultQueue;
+        mBackgroundScanResultQueue = new ArrayList<>();
+        return retval;
+    }
+
+    private void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
+        scanState.applyChanges(beaconManager);
+        LogManager.d(TAG, "Applying scan job settings with background mode "+scanState.getBackgroundMode());
+        schedule(context, scanState, false);
+    }
+
+    public void applySettingsToScheduledJob(Context context, BeaconManager beaconManager) {
+        LogManager.d(TAG, "Applying settings to ScanJob");
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        ScanState scanState = ScanState.restore(context);
+        applySettingsToScheduledJob(context, beaconManager, scanState);
+    }
+
+    // This method appears to be never used, because it is only used by Android O APIs, which
+    // must exist on another branch until the SDKs are released.
+    public void scheduleAfterBackgroundWakeup(Context context, List<ScanResult> scanResults) {
+        if (scanResults != null) {
+            mBackgroundScanResultQueue.addAll(scanResults);
+        }
+        synchronized (this) {
+            // We typically get a bunch of calls in a row here, separated by a few millis.  Only do this once.
+            if (System.currentTimeMillis() - mScanJobScheduleTime > MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING) {
+                LogManager.d(TAG, "scheduling an immediate scan job because last did "+(System.currentTimeMillis() - mScanJobScheduleTime)+"seconds ago.");
+                mScanJobScheduleTime = System.currentTimeMillis();
+            }
+            else {
+                LogManager.d(TAG, "Not scheduling an immediate scan job because we just did recently.");
+                return;
+            }
+        }
+        ScanState scanState = ScanState.restore(context);
+        schedule(context, scanState, true);
+    }
+
+    private void schedule(Context context, ScanState scanState, boolean backgroundWakeup) {
+        ensureNotificationProcessorSetup(context);
+
+        long betweenScanPeriod = scanState.getScanJobIntervalMillis() - scanState.getScanJobRuntimeMillis();
+
+        long millisToNextJobStart;
+        if (backgroundWakeup) {
+            LogManager.d(TAG, "We just woke up in the background based on a new scan result.  Start scan job immediately.");
+            millisToNextJobStart = 0;
+        }
+        else {
+            if (betweenScanPeriod > 0) {
+                // If we pause between scans, then we need to start scanning on a normalized time
+                millisToNextJobStart = (SystemClock.elapsedRealtime() % scanState.getScanJobIntervalMillis());
+            }
+            else {
+                millisToNextJobStart = 0;
+            }
+
+            if (millisToNextJobStart < 50) {
+                // always wait a little bit to start scanning in case settings keep changing.
+                // by user restarting settings and scanning.  50ms should be fine
+                millisToNextJobStart = 50;
+            }
+        }
+
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+
+        if (backgroundWakeup || !scanState.getBackgroundMode()) {
+            // If we are in the foreground, and we want to start a scan soon, we will schedule an
+            // immediate job
+            if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
+                // If the next time we want to scan is less than 50ms from the periodic scan cycle, then]
+                // we schedule it for that specific time.
+                LogManager.d(TAG, "Scheduling immediate ScanJob to run in "+millisToNextJobStart+" millis");
+                JobInfo immediateJob = new JobInfo.Builder(ScanJob.IMMMEDIATE_SCAN_JOB_ID, new ComponentName(context, ScanJob.class))
+                        .setPersisted(true) // This makes it restart after reboot
+                        .setExtras(new PersistableBundle())
+                        .setMinimumLatency(millisToNextJobStart)
+                        .setOverrideDeadline(millisToNextJobStart).build();
+                int error = jobScheduler.schedule(immediateJob);
+                if (error < 0) {
+                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+                }
+            }
+        }
+        else {
+            LogManager.d(TAG, "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
+            jobScheduler.cancel(ScanJob.IMMMEDIATE_SCAN_JOB_ID);
+        }
+
+        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(ScanJob.PERIODIC_SCAN_JOB_ID, new ComponentName(context, ScanJob.class))
+                .setPersisted(true) // This makes it restart after reboot
+                .setExtras(new PersistableBundle());
+
+        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            // ON Android N+ we specify a tolerance of 0ms (capped at 5% by the OS) to ensure
+            // our scans happen within 5% of the schduled time.
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0L).build();
+        }
+        else {
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis()).build();
+        }
+        // On Android O I see this:
+        //
+        // 06-07 22:15:51.361 6455-6455/org.altbeacon.beaconreference W/JobInfo: Specified interval for 1 is +5m10s0ms. Clamped to +15m0s0ms
+        // 06-07 22:15:51.361 6455-6455/org.altbeacon.beaconreference W/JobInfo: Specified flex for 1 is 0. Clamped to +5m0s0ms
+        //
+        // This suggests logs are being clamped at a max of every 15 minutes +/- 5 minutes in the background
+        // This is the same way it worked on Android N per this post: https://stackoverflow.com/questions/38344220/job-scheduler-not-running-on-android-n
+        //
+        // In practice, I see the following runtimes on the Nexus Player with Android O
+        // This shows that the 15 minutes has some slop.
+        //
+        /*
+06-07 22:25:51.380 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@7188bc6
+06-07 22:41:01.227 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@382ed7b
+06-07 22:55:51.373 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@203c928
+06-07 23:10:59.083 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@dc96415
+06-07 23:25:51.371 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@68bed2e
+06-07 23:40:59.142 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c295843
+06-07 23:55:51.369 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@cd047e4
+06-08 00:10:59.082 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@8009a61
+06-08 00:25:51.368 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@f1fa2ca
+06-08 00:40:59.085 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@88dddef
+06-08 00:55:51.374 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@eb2b360
+06-08 01:10:51.670 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@9bca225
+06-08 01:25:51.383 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@871c8fe
+06-08 01:45:51.404 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@3bf42d3
+06-08 01:56:12.354 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c3d4e34
+06-08 02:21:51.771 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@1557571
+06-08 02:37:01.861 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@e2c879a
+06-08 02:52:11.943 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c9f0d7f
+06-08 03:07:22.041 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@4e0cab0
+06-08 03:23:12.696 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@1139a7d
+06-08 03:38:22.776 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@e06b8f6
+06-08 03:52:12.792 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@74147eb
+06-08 04:08:32.872 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@90d9fec
+06-08 04:21:12.856 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@a4abd49
+06-08 04:38:42.959 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@741d912
+06-08 04:50:12.923 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@15bfe17
+06-08 05:08:53.047 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@fa229e8
+06-08 05:19:13.050 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@b0e49d5
+06-08 05:39:03.142 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@18823ee
+06-08 05:54:13.212 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@a72fc03
+06-08 06:10:51.850 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@3fb84a4
+06-08 06:26:01.917 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@53d6c21
+06-08 06:41:11.994 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@848958a
+06-08 06:56:22.053 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@43cdaf
+06-08 07:06:32.119 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@5318c20
+06-08 07:29:12.356 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@34f102d
+06-08 07:44:22.431 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@4d2e9e6
+         */
+
+        LogManager.d(TAG, "Scheduling ScanJob to run every "+scanState.getScanJobIntervalMillis()+" millis");
+        int error = jobScheduler.schedule(periodicJobBuilder.build());
+        if (error < 0) {
+            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+        }
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanState.java b/src/main/java/org/altbeacon/beacon/service/ScanState.java
new file mode 100644
index 00000000..28d5f1dc
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanState.java
@@ -0,0 +1,291 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+import android.util.Log;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InvalidClassException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static android.content.Context.MODE_PRIVATE;
+
+/**
+ * Stores the full state of scanning for the libary, including all settings so it can be ressurrected easily
+ * for running from a scheduled job
+ *
+ * Created by dyoung on 3/26/17.
+ * @hide
+ */
+
+public class ScanState implements Serializable {
+    private static final String TAG = ScanState.class.getSimpleName();
+    private static final String STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state";
+    private static final String TEMP_STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state-temp";
+    public static int MIN_SCAN_JOB_INTERVAL_MILLIS = 300000; //  5 minutes
+
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private transient MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+    private long mForegroundBetweenScanPeriod;
+    private long mBackgroundBetweenScanPeriod;
+    private long mForegroundScanPeriod;
+    private long mBackgroundScanPeriod;
+    private boolean mBackgroundMode;
+    private long mLastScanStartTimeMillis = 0l;
+    private transient Context mContext;
+
+    public Boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+
+    public void setBackgroundMode(Boolean backgroundMode) {
+        mBackgroundMode = backgroundMode;
+    }
+
+    public Long getBackgroundBetweenScanPeriod() {
+        return mBackgroundBetweenScanPeriod;
+    }
+
+    public void setBackgroundBetweenScanPeriod(Long backgroundBetweenScanPeriod) {
+        mBackgroundBetweenScanPeriod = backgroundBetweenScanPeriod;
+    }
+
+    public Long getBackgroundScanPeriod() {
+        return mBackgroundScanPeriod;
+    }
+
+    public void setBackgroundScanPeriod(Long backgroundScanPeriod) {
+        mBackgroundScanPeriod = backgroundScanPeriod;
+    }
+
+    public Long getForegroundBetweenScanPeriod() {
+        return mForegroundBetweenScanPeriod;
+    }
+
+    public void setForegroundBetweenScanPeriod(Long foregroundBetweenScanPeriod) {
+        mForegroundBetweenScanPeriod = foregroundBetweenScanPeriod;
+    }
+
+    public Long getForegroundScanPeriod() {
+        return mForegroundScanPeriod;
+    }
+
+    public void setForegroundScanPeriod(Long foregroundScanPeriod) {
+        mForegroundScanPeriod = foregroundScanPeriod;
+    }
+
+    public ScanState(Context context) {
+        mContext = context;
+    }
+
+    public MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    public void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    public Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    public void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        mRangedRegionState = rangedRegionState;
+    }
+
+    public ExtraDataBeaconTracker getExtraBeaconDataTracker() {
+        return mExtraBeaconDataTracker;
+    }
+
+    public void setExtraBeaconDataTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraBeaconDataTracker = extraDataBeaconTracker;
+    }
+
+    public Set<BeaconParser> getBeaconParsers() {
+        return mBeaconParsers;
+    }
+
+    public void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    public long getLastScanStartTimeMillis() {
+        return mLastScanStartTimeMillis;
+    }
+    public void setLastScanStartTimeMillis(long time) {
+        mLastScanStartTimeMillis = time;
+    }
+
+    public static ScanState restore(Context context) {
+        ScanState scanState = null;
+        synchronized (ScanState.class) {
+            FileInputStream inputStream = null;
+            ObjectInputStream objectInputStream = null;
+            try {
+                inputStream = context.openFileInput(STATUS_PRESERVATION_FILE_NAME);
+                objectInputStream = new ObjectInputStream(inputStream);
+                scanState = (ScanState) objectInputStream.readObject();
+                scanState.mContext = context;
+                ;
+            } catch (IOException | ClassNotFoundException | ClassCastException e) {
+                if (e instanceof InvalidClassException) {
+                    LogManager.d(TAG, "Serialized ScanState has wrong class. Just ignoring saved state...");
+                }
+                else {
+                    LogManager.e(TAG, "Deserialization exception");
+                    Log.e(TAG, "error: ", e);
+                }
+
+            } finally {
+                if (null != inputStream) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectInputStream != null) {
+                    try {
+                        objectInputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            if (scanState == null) {
+                scanState = new ScanState(context);
+
+            }
+            if (scanState.mExtraBeaconDataTracker == null) {
+                scanState.mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+            }
+            scanState.mMonitoringStatus = MonitoringStatus.getInstanceForApplication(context);
+            LogManager.d(TAG, "Scan state restore regions: monitored="+scanState.getMonitoringStatus().regions().size()+" ranged="+scanState.getRangedRegionState().keySet().size());
+            return scanState;
+        }
+    }
+
+    public void save() {
+        synchronized (ScanState.class) {
+            // TODO: need to limit how big this object is somehow.
+            // Impose limits on ranged and monitored regions?
+            FileOutputStream outputStream = null;
+            ObjectOutputStream objectOutputStream = null;
+            try {
+                outputStream = mContext.openFileOutput(TEMP_STATUS_PRESERVATION_FILE_NAME, MODE_PRIVATE);
+                objectOutputStream = new ObjectOutputStream(outputStream);
+                objectOutputStream.writeObject(this);
+                File file = new File(mContext.getFilesDir(), STATUS_PRESERVATION_FILE_NAME);
+                File tempFile = new File(mContext.getFilesDir(), TEMP_STATUS_PRESERVATION_FILE_NAME);
+                LogManager.d(TAG, "Temp file is "+tempFile.getAbsolutePath());
+                LogManager.d(TAG, "Perm file is "+file.getAbsolutePath());
+
+                if (!file.delete()) {
+                    LogManager.e(TAG, "Error while saving scan status to file: Cannot delete existing file.");
+                }
+                if (!tempFile.renameTo(file)) {
+                    LogManager.e(TAG, "Error while saving scan status to file: Cannot rename temp file.");
+                }
+            } catch (IOException e) {
+                LogManager.e(TAG, "Error while saving scan status to file: ", e.getMessage());
+            } finally {
+                if (null != outputStream) {
+                    try {
+                        outputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectOutputStream != null) {
+                    try {
+                        objectOutputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            mMonitoringStatus.saveMonitoringStatusIfOn();
+        }
+    }
+
+    public int getScanJobIntervalMillis() {
+        long cyclePeriodMillis;
+        if (getBackgroundMode()) {
+            cyclePeriodMillis = getBackgroundScanPeriod()+getBackgroundBetweenScanPeriod();
+        }
+        else {
+            cyclePeriodMillis = getForegroundScanPeriod()+getForegroundBetweenScanPeriod();
+        }
+        int scanJobIntervalMillis = MIN_SCAN_JOB_INTERVAL_MILLIS;
+        if (cyclePeriodMillis > MIN_SCAN_JOB_INTERVAL_MILLIS) {
+            scanJobIntervalMillis = (int) cyclePeriodMillis;
+        }
+        return scanJobIntervalMillis;
+    }
+
+    public int getScanJobRuntimeMillis() {
+        long scanPeriodMillis;
+        LogManager.d(TAG, "ScanState says background mode for ScanJob is "+getBackgroundMode());
+        if (getBackgroundMode()) {
+            scanPeriodMillis = getBackgroundScanPeriod();
+        }
+        else {
+            scanPeriodMillis = getForegroundScanPeriod();
+        }
+        if (!getBackgroundMode()) {
+            // if we are in the foreground, we keep the scan job going for the minimum interval
+            if (scanPeriodMillis < MIN_SCAN_JOB_INTERVAL_MILLIS) {
+                return MIN_SCAN_JOB_INTERVAL_MILLIS;
+            }
+        }
+        return (int) scanPeriodMillis;
+    }
+
+
+
+    public void applyChanges(BeaconManager beaconManager) {
+        mBeaconParsers = new HashSet<>(beaconManager.getBeaconParsers());
+        mForegroundScanPeriod = beaconManager.getForegroundScanPeriod();
+        mForegroundBetweenScanPeriod = beaconManager.getForegroundBetweenScanPeriod();
+        mBackgroundScanPeriod = beaconManager.getBackgroundScanPeriod();
+        mBackgroundBetweenScanPeriod = beaconManager.getBackgroundBetweenScanPeriod();
+        mBackgroundMode = beaconManager.getBackgroundMode();
+
+        ArrayList<Region> existingMonitoredRegions = new ArrayList<>(mMonitoringStatus.regions());
+        ArrayList<Region> existingRangedRegions = new ArrayList<>(mRangedRegionState.keySet());
+        ArrayList<Region> newMonitoredRegions = new ArrayList<>(beaconManager.getMonitoredRegions());
+        ArrayList<Region> newRangedRegions = new ArrayList<>(beaconManager.getRangedRegions());
+        LogManager.d(TAG, "ranged regions: old="+existingRangedRegions.size()+" new="+newRangedRegions.size());
+        LogManager.d(TAG, "monitored regions: old="+existingMonitoredRegions.size()+" new="+newMonitoredRegions.size());
+
+        for (Region newRangedRegion: newRangedRegions) {
+            if (!existingRangedRegions.contains(newRangedRegion)) {
+                LogManager.d(TAG, "Starting ranging region: "+newRangedRegion);
+                mRangedRegionState.put(newRangedRegion, new RangeState(new Callback(mContext.getPackageName())));
+            }
+        }
+        for (Region existingRangedRegion: existingRangedRegions) {
+            if (!newRangedRegions.contains(existingRangedRegion)) {
+                LogManager.d(TAG, "Stopping ranging region: "+existingRangedRegion);
+                mRangedRegionState.remove(existingRangedRegion);
+            }
+        }
+        LogManager.d(TAG, "Updated state with "+newRangedRegions.size()+" ranging regions and "+newMonitoredRegions.size()+" monitoring regions.");
+
+        this.save();
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index a5ec4881..89351cc1 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -115,31 +115,40 @@ protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeri
     }
 
     public static CycledLeScanner createScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
-        boolean useAndroidLScanner;
+        boolean useAndroidLScanner = false;
+        boolean useAndroidOScanner = false;
         if (android.os.Build.VERSION.SDK_INT < 18) {
             LogManager.w(TAG, "Not supported prior to API 18.");
             return null;
         }
 
-        if (android.os.Build.VERSION.SDK_INT < 21) {
-            LogManager.i(TAG, "This is not Android 5.0.  We are using old scanning APIs");
+        if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            LogManager.i(TAG, "This is pre Android 5.0.  We are using old scanning APIs");
             useAndroidLScanner = false;
-        } else {
+
+        }
+        else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
             if (BeaconManager.isAndroidLScanningDisabled()) {
-                LogManager.i(TAG, "This Android 5.0, but L scanning is disabled. We are using old scanning APIs");
+                LogManager.i(TAG, "This is Android 5.0, but L scanning is disabled. We are using old scanning APIs");
                 useAndroidLScanner = false;
             } else {
-                LogManager.i(TAG, "This Android 5.0.  We are using new scanning APIs");
+                LogManager.i(TAG, "This is Android 5.0.  We are using new scanning APIs");
                 useAndroidLScanner = true;
             }
         }
+        else {
+            LogManager.i(TAG, "Using Android O scanner");
+            useAndroidOScanner = true;
+        }
 
-        if (useAndroidLScanner) {
+        if (useAndroidOScanner) {
+            return new CycledLeScannerForAndroidO(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
+        }
+        else if (useAndroidLScanner) {
             return new CycledLeScannerForLollipop(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         } else {
             return new CycledLeScannerForJellyBeanMr2(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         }
-
     }
 
     /**
@@ -322,7 +331,9 @@ protected void scanLeDevice(final Boolean enable) {
                 mCurrentScanStartTime = 0l;
                 mLastScanCycleEndTime = SystemClock.elapsedRealtime();
                 // Clear any queued schedule tasks as we're done scanning
-                mScanHandler.removeCallbacksAndMessages(null);
+                // This must be mHandler not mScanHandler.  mHandler is what does the scanning work.
+                // If this is set to mScanHandler, then this can prevent a scan stop.
+                mHandler.removeCallbacksAndMessages(null);
                 finishScanCycle();
             }
         }
@@ -412,7 +423,7 @@ private void finishScanCycle() {
                 }
             }
             if (!mScanningEnabled) {
-                LogManager.d(TAG, "Scanning disabled.  No ranging or monitoring regions are active.");
+                LogManager.d(TAG, "Scanning disabled. ");
                 mScanCyclerStarted = false;
                 cancelWakeUpAlarm();
             }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
new file mode 100644
index 00000000..fe095400
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
@@ -0,0 +1,28 @@
+package org.altbeacon.beacon.service.scanner;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import org.altbeacon.bluetooth.BluetoothCrashResolver;
+import java.util.Set;
+
+/**
+ * The scanner used for Android O is effectively the same as used for JellyBeaconMr2.  There is no
+ * point in using the low power scanning APIs introduced in Lollipop, because they only work when
+ * the app is running, effectively requiring a long running service, something newly disallowed
+ * by Android O.  The new strategy for Android O is to use a JobScheduler combined with background
+ * scans delivered by Intents.
+ *
+ * @see org.altbeacon.beacon.service.ScanJob
+ * @see org.altbeacon.beacon.service.ScanHelper#startAndroidOBackgroundScan(Set)
+ *
+ * Created by dyoung on 5/28/17.
+ */
+
+@TargetApi(26)
+class CycledLeScannerForAndroidO extends CycledLeScannerForLollipop {
+    private static final String TAG = CycledLeScannerForAndroidO.class.getSimpleName();
+
+    CycledLeScannerForAndroidO(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
+        super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
index 42c6d6cb..e9f51a74 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
@@ -112,7 +112,9 @@ public void onLeScan(final BluetoothDevice device, final int rssi,
                                              final byte[] scanRecord) {
                             LogManager.d(TAG, "got record");
                             mCycledLeScanCallback.onLeScan(device, rssi, scanRecord);
-                            mBluetoothCrashResolver.notifyScannedDevice(device, getLeScanCallback());
+                            if (mBluetoothCrashResolver != null) {
+                                mBluetoothCrashResolver.notifyScannedDevice(device, getLeScanCallback());
+                            }
                         }
                     };
         }
diff --git a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
index 8964e607..0a041fe0 100644
--- a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
+++ b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
@@ -1,11 +1,22 @@
 package org.altbeacon.beacon.startup;
 
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanResult;
+import android.bluetooth.le.ScanSettings;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanJobScheduler;
+
+import java.util.ArrayList;
 
 public class StartupBroadcastReceiver extends BroadcastReceiver
 {
@@ -19,8 +30,19 @@ public void onReceive(Context context, Intent intent) {
             return;
         }
         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context.getApplicationContext());
-        if (beaconManager.isAnyConsumerBound()) {
-            if (intent.getBooleanExtra("wakeup", false)) {
+        if (beaconManager.isAnyConsumerBound() || beaconManager.getScheduledScanJobsEnabled()) {
+            int bleCallbackType = intent.getIntExtra(BluetoothLeScanner.EXTRA_CALLBACK_TYPE, -1); // e.g. ScanSettings.CALLBACK_TYPE_FIRST_MATCH
+            if (bleCallbackType != -1) {
+                LogManager.d(TAG, "Passive background scan callback type: "+bleCallbackType);
+                LogManager.d(TAG, "got Android O background scan via intent");
+                int errorCode = intent.getIntExtra(BluetoothLeScanner.EXTRA_ERROR_CODE, -1); // e.g.  ScanCallback.SCAN_FAILED_INTERNAL_ERROR
+                if (errorCode != -1) {
+                    LogManager.w(TAG, "Passive background scan failed.  Code; "+errorCode);
+                }
+                ArrayList<ScanResult> scanResults = intent.getParcelableArrayListExtra(BluetoothLeScanner.EXTRA_LIST_SCAN_RESULT);
+                ScanJobScheduler.getInstance().scheduleAfterBackgroundWakeup(context, scanResults);
+            }
+            else if (intent.getBooleanExtra("wakeup", false)) {
                 LogManager.d(TAG, "got wake up intent");
             }
             else {
@@ -28,5 +50,8 @@ public void onReceive(Context context, Intent intent) {
                         intent.getStringExtra("wakeup"));
             }
         }
+        else {
+            LogManager.d(TAG, "No consumers are bound.  Ignoring broadcast receiver.");
+        }
      }
 }
diff --git a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
index 37be84e9..d77e7eab 100644
--- a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
@@ -48,7 +48,7 @@ public void beaconScanCallbackTest() throws Exception {
         beaconServiceServiceController.attach();
         BeaconService beaconService = beaconServiceServiceController.get();
         beaconService.onCreate();
-        CycledLeScanCallback callback = beaconService.mCycledLeScanCallback;
+        CycledLeScanCallback callback = beaconService.getCycledLeScanCallback();
 
         ThreadPoolExecutor executor = (ThreadPoolExecutor) AsyncTask.THREAD_POOL_EXECUTOR;
         int activeThreadCountBeforeScan = executor.getActiveCount();
diff --git a/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java b/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
new file mode 100644
index 00000000..ba4b95c0
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
@@ -0,0 +1,57 @@
+package org.altbeacon.beacon.service;
+
+/**
+ * Created by dyoung on 7/30/17.
+ */
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.AsyncTask;
+import android.os.Build;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.logging.Loggers;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+import org.robolectric.util.ServiceController;
+
+import java.util.concurrent.ThreadPoolExecutor;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Created by dyoung on 7/1/15.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class ScanStateTest {
+
+    @Before
+    public void before() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        LogManager.setLogger(Loggers.verboseLogger());
+        LogManager.setVerboseLoggingEnabled(true);
+        BeaconManager.setsManifestCheckingDisabled(true);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void serializationTest() throws Exception {
+        Context context = ShadowApplication.getInstance().getApplicationContext();
+        ScanState scanState = new ScanState(context);
+        MonitoringStatus monitoringStatus = new MonitoringStatus(context);
+        scanState.setMonitoringStatus(monitoringStatus);
+        scanState.setLastScanStartTimeMillis(1234);
+        scanState.save();
+        ScanState scanState2 = ScanState.restore(context);
+        assertEquals("Scan start time should be restored",
+                scanState.getLastScanStartTimeMillis(), scanState2.getLastScanStartTimeMillis());
+    }
+}
\ No newline at end of file
