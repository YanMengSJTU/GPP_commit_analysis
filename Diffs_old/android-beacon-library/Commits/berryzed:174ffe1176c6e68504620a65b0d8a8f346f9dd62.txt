diff --git a/CHANGELOG.md b/CHANGELOG.md
index 3347bcaf..4dcbcb1f 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,15 @@
+### 2.14 / 2018-05-17
+
+Enhancements:
+
+ - Add warnings about disabling scheduled scan jobs on Android 8+ (#674, David G. Young)
+ - Add warning about setting short scan periods on Android 8 (#677, David G. Young)
+ - BeaconTransmitter advertisements may be configured as connectable (#683, Michael Harper)
+
+Bug Fixes:
+ - Fix crashes of BluetoothMedic caused by Bluetooth being turned off (#675, David G. Young) 
+ - Fix flawed in BeaconManager.isBound method on Android 8 (#655, David G. Young)
+
 ### 2.13.1 / 2018-03-05
 
 [Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.13.1...2.13)
diff --git a/README.md b/README.md
index 29bc3bf9..5a48df65 100644
--- a/README.md
+++ b/README.md
@@ -65,7 +65,7 @@ Key Gradle build targets:
     ./gradlew test # run unit tests
     ./gradlew build # development build
     ./gradlew release -Prelease # release build
-    ./gradlew generatereleaseJavadoc -Prelease
+    ./gradlew generateJavadoc
 
 ## License
 
diff --git a/build.gradle b/build.gradle
index fe304af3..11451f85 100644
--- a/build.gradle
+++ b/build.gradle
@@ -94,6 +94,12 @@ android {
     }
 }
 
+configurations {
+    doclava
+}
+
+
+
 dependencies {
     implementation fileTree ( dir: 'libs', include: ['*.jar'] )
     implementation 'com.android.support:appcompat-v7:26.0.0'
@@ -116,7 +122,9 @@ dependencies {
         exclude group: 'com.android.support', module: 'support-annotations'
         exclude group: 'org.hamcrest'
     })
+
     androidTestImplementation 'org.apache.commons:commons-math3:3.6.1'
+    doclava 'com.google.doclava:doclava:1.0.6'
 }
 
 apply plugin: 'idea'
@@ -162,6 +170,18 @@ android.libraryVariants.all { variant ->
 
 }
 
+task generateJavadoc(type: Javadoc, dependsOn: project.configurations.doclava) {
+    failOnError = true
+    title = null
+    source = android.sourceSets.main.java.srcDirs
+    options.doclet = "com.google.doclava.Doclava"
+    options.docletpath = configurations.doclava.files.asType(List)
+    classpath +=
+            project.files(android.getBootClasspath().join(File.pathSeparator)) + configurations.compile
+
+    destinationDir = file("../javadocs/")
+}
+
 build.mustRunAfter clean
 
 apply from: 'gradle/credentials.gradle'
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index 988630ff..28513c74 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -275,8 +275,6 @@ protected Beacon(Parcel in) {
         mRunningAverageRssi = (Double) in.readValue(null);
         mRssiMeasurementCount = in.readInt();
         mPacketCount = in.readInt();
-//        mScanRecord = new byte[in.readInt()];
-//        in.readByteArray(mScanRecord);
         mBatteryLevel = in.readInt();
         mRealTxPower = in.readInt();
     }
@@ -714,9 +712,6 @@ public void writeToParcel(Parcel out, int flags) {
         out.writeValue(mRunningAverageRssi);
         out.writeInt(mRssiMeasurementCount);
         out.writeInt(mPacketCount);
-//        int length = mScanRecord.length;
-//        out.writeInt(length);
-//        out.writeByteArray(mScanRecord);
         out.writeInt(mBatteryLevel);
         out.writeInt(mRealTxPower);
     }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 42aec264..75678aaa 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -48,9 +48,7 @@
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
-import org.altbeacon.beacon.service.ScanJob;
 import org.altbeacon.beacon.service.ScanJobScheduler;
-import org.altbeacon.beacon.service.ScanState;
 import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
@@ -69,9 +67,6 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CopyOnWriteArraySet;
 
-import org.altbeacon.beacon.service.ScanJob;
-import org.altbeacon.beacon.service.ScanState;
-
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
@@ -259,6 +254,11 @@ public void setBackgroundScanPeriod(long p) {
      */
     public void setBackgroundBetweenScanPeriod(long p) {
         backgroundBetweenScanPeriod = p;
+        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
+                backgroundBetweenScanPeriod < 15 * 60 * 1000 /* 15 min */) {
+            LogManager.w(TAG, "Setting a short backgroundBetweenScanPeriod has no effect on " +
+                    "Android 8+, which is limited to scanning every ~15 minutes");
+        }
     }
 
     /**
@@ -548,6 +548,10 @@ public void setBackgroundMode(boolean backgroundMode) {
      * otherwise beacon scans may be run only once every 15 minutes in the background, and no low
      * power scans may be performed between scanning cycles.
      *
+     * Setting this value to false will disable ScanJobs when the app is run on Android 8+, which
+     * can prohibit delivery of callbacks when the app is in the background unless the scanning
+     * process is running in a foreground service.
+     *
      * This method may only be called if bind() has not yet been called, otherwise an
      * `IllegalStateException` is thown.
      *
@@ -564,8 +568,13 @@ public void setEnableScheduledScanJobs(boolean enabled) {
                     " availble prior to Android 5.0");
             return;
         }
+        if (enabled && android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            LogManager.w(TAG, "Disabling ScanJobs on Android 8+ may disable delivery of " +
+                    "beacon callbacks in the background unless a foreground service is active.");
+        }
         mScheduledScanJobsEnabled = enabled;
     }
+
     public boolean getScheduledScanJobsEnabled() {
         return mScheduledScanJobsEnabled;
     }
@@ -868,7 +877,9 @@ public void applySettings() {
 
     protected void syncSettingsToService() {
         if (mScheduledScanJobsEnabled) {
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            }
             return;
         }
         try {
@@ -961,7 +972,9 @@ public void updateScanPeriods() throws RemoteException {
     @TargetApi(18)
     private void applyChangesToServices(int type, Region region) throws RemoteException {
         if (mScheduledScanJobsEnabled) {
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+                ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            }
             return;
         }
         if (serviceMessenger == null) {
diff --git a/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java b/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
index 13625593..423fc480 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconTransmitter.java
@@ -1,22 +1,22 @@
 package org.altbeacon.beacon;
 
-import org.altbeacon.beacon.logging.LogManager;
-
 import android.annotation.TargetApi;
 import android.bluetooth.BluetoothAdapter;
 import android.bluetooth.BluetoothManager;
-import java.nio.ByteOrder;
-import java.nio.ByteBuffer;
-import java.util.UUID;
 import android.bluetooth.le.AdvertiseCallback;
-import android.bluetooth.le.AdvertiseSettings;
 import android.bluetooth.le.AdvertiseData;
+import android.bluetooth.le.AdvertiseSettings;
 import android.bluetooth.le.BluetoothLeAdvertiser;
 import android.content.Context;
 import android.content.pm.PackageManager;
-
 import android.os.ParcelUuid;
 
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.UUID;
+
 /**
  * Provides a mechanism for transmitting as a beacon.   Requires Android 5.0
  */
@@ -41,6 +41,7 @@
     private AdvertiseCallback mAdvertisingClientCallback;
     private boolean mStarted;
     private AdvertiseCallback mAdvertiseCallback;
+    private boolean mConnectable = false;
 
     /**
      * Creates a new beacon transmitter capable of transmitting beacons with the format
@@ -124,6 +125,23 @@ public void setAdvertiseTxPowerLevel(int mAdvertiseTxPowerLevel) {
         this.mAdvertiseTxPowerLevel = mAdvertiseTxPowerLevel;
     }
 
+    /**
+     * Whether the advertisement should indicate the device is connectable.
+     *
+     * @param connectable
+     */
+    public void setConnectable(boolean connectable) {
+        this.mConnectable = connectable;
+    }
+
+    /**
+     * @return connectable
+     * @see #setConnectable(boolean)
+     */
+    public boolean isConnectable() {
+        return mConnectable;
+    }
+
     /**
      * Starts advertising with fields from the passed beacon
      * @param beacon
@@ -191,7 +209,7 @@ public void startAdvertising() {
 
             settingsBuilder.setAdvertiseMode(mAdvertiseMode);
             settingsBuilder.setTxPowerLevel(mAdvertiseTxPowerLevel);
-            settingsBuilder.setConnectable(false);
+            settingsBuilder.setConnectable(mConnectable);
 
             mBluetoothLeAdvertiser.startAdvertising(settingsBuilder.build(), dataBuilder.build(), getAdvertiseCallback());
             LogManager.d(TAG, "Started advertisement with callback: %s", getAdvertiseCallback());
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java b/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
index 96425e52..cd100e2e 100644
--- a/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
@@ -9,16 +9,17 @@
 import android.bluetooth.le.AdvertiseCallback;
 import android.bluetooth.le.AdvertiseData;
 import android.bluetooth.le.AdvertiseSettings;
+import android.bluetooth.le.AdvertiseSettings.Builder;
 import android.bluetooth.le.BluetoothLeAdvertiser;
 import android.bluetooth.le.BluetoothLeScanner;
 import android.bluetooth.le.ScanCallback;
 import android.bluetooth.le.ScanResult;
-import android.bluetooth.le.AdvertiseSettings.Builder;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.os.Build;
 import android.os.Handler;
 import android.os.PersistableBundle;
 import android.support.annotation.NonNull;
@@ -26,10 +27,11 @@
 import android.support.annotation.RequiresApi;
 import android.support.v4.app.NotificationCompat;
 import android.support.v4.content.LocalBroadcastManager;
-import java.util.List;
 
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.util.List;
+
 /**
  *
  * Utility class for checking the health of the bluetooth stack on the device by running two kinds
@@ -258,30 +260,30 @@ public void onScanFailed(int errorCode) {
                 }
             };
             if(scanner != null) {
-                scanner.startScan(callback);
-                while (this.mScanTestResult == null) {
-                    LogManager.d(TAG, "Waiting for scan test to complete...");
+                try {
+                    scanner.startScan(callback);
+                    while (this.mScanTestResult == null) {
+                        LogManager.d(TAG, "Waiting for scan test to complete...");
 
-                    try {
-                        Thread.sleep(1000L);
-                    } catch (InterruptedException e) { /* do nothing */ }
+                        try {
+                            Thread.sleep(1000L);
+                        } catch (InterruptedException e) { /* do nothing */ }
 
-                    if (System.currentTimeMillis() - testStartTime > 5000L) {
-                        LogManager.d(TAG, "Timeout running scan test");
-                        break;
+                        if (System.currentTimeMillis() - testStartTime > 5000L) {
+                            LogManager.d(TAG, "Timeout running scan test");
+                            break;
+                        }
                     }
-                }
-                try {
                     scanner.stopScan(callback);
-                } catch (IllegalStateException e) { /* do nothing */ } // caught if bluetooth is off here
+                } catch (IllegalStateException e) {
+                    LogManager.d(TAG, "Bluetooth is off.  Cannot run scan test.");
+                }
             }
             else {
                 LogManager.d(TAG, "Cannot get scanner");
             }
         }
 
-
-
         LogManager.d(TAG, "scan test complete");
         return this.mScanTestResult == null || this.mScanTestResult;
     }
@@ -302,8 +304,8 @@ public boolean runTransmitterTest(final Context context) {
         initializeWithContext(context);
         this.mTransmitterTestResult = null;
         long testStartTime = System.currentTimeMillis();
-        if (this.mAdapter != null) {
-            final BluetoothLeAdvertiser advertiser = this.mAdapter.getBluetoothLeAdvertiser();
+        if (mAdapter != null) {
+            final BluetoothLeAdvertiser advertiser = getAdvertiserSafely(mAdapter);
             if(advertiser != null) {
                 AdvertiseSettings settings = (new Builder()).setAdvertiseMode(0).build();
                 AdvertiseData data = (new android.bluetooth.le.AdvertiseData.Builder())
@@ -454,4 +456,16 @@ private void scheduleRegularTests(Context context) {
             jobScheduler.schedule(builder.build());
         }
     }
+
+    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+    private BluetoothLeAdvertiser getAdvertiserSafely(BluetoothAdapter adapter) {
+        try {
+            // This can sometimes throw a NullPointerException as reported here:
+            // https://github.com/AltBeacon/android-beacon-library/issues/672
+            return adapter.getBluetoothLeAdvertiser();
+        } catch (Exception e) {
+            LogManager.w(TAG, "Cannot get bluetoothLeAdvertiser", e);
+        }
+        return null;
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java b/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
index 0ec70470..81ec65f6 100644
--- a/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
@@ -2,26 +2,20 @@
 
 import android.annotation.TargetApi;
 import android.content.Context;
-import android.os.AsyncTask;
 import android.os.Build;
-import android.util.Log;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
-import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowApplication;
-import org.robolectric.util.ServiceController;
 
 import java.util.Collection;
-import java.util.concurrent.ThreadPoolExecutor;
 
 import static org.junit.Assert.assertEquals;
 
@@ -88,13 +82,15 @@ public void refusesToRestoreRegionsIfTooMuchTimeHasPassedSinceSavingTest() throw
     @Test
     public void allowsAccessToRegionsAfterRestore() throws Exception {
         Context context = ShadowApplication.getInstance().getApplicationContext();
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context);
+        MonitoringStatus.getInstanceForApplication(context).clear();
         MonitoringStatus monitoringStatus = new MonitoringStatus(context);
         for (int i = 0; i < 50; i++) {
             Region region = new Region(""+i, null, null, null);
             monitoringStatus.addRegion(region, null);
         }
         monitoringStatus.saveMonitoringStatusIfOn();
-        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context);
+        MonitoringStatus.getInstanceForApplication(context).restoreMonitoringStatus();
         Collection<Region> regions = beaconManager.getMonitoredRegions();
         assertEquals("beaconManager should return restored regions", 50, regions.size());
     }
