diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
index 64e0fa26..0a6d926c 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -14,6 +14,7 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
 import org.altbeacon.beacon.BeaconManager;
@@ -21,22 +22,23 @@
 
 /**
  * Schedules two types of ScanJobs:
- *  1. Periodic, which are set to go every scanPeriod+betweenScanPeriod
- *  2. Immediate, which go right now.
- *
- *  Immediate ScanJobs are used when the app is in the foreground and wants to get immediate results
- *  or when beacons have been detected with background scan filters and delivered via Intents and
- *  a scan needs to run in a timely manner to collect data about those beacons known to be newly
- *  in the vicinity despite the app being in the background.
- *
+ * 1. Periodic, which are set to go every scanPeriod+betweenScanPeriod
+ * 2. Immediate, which go right now.
+ * <p>
+ * Immediate ScanJobs are used when the app is in the foreground and wants to get immediate results
+ * or when beacons have been detected with background scan filters and delivered via Intents and
+ * a scan needs to run in a timely manner to collect data about those beacons known to be newly
+ * in the vicinity despite the app being in the background.
+ * <p>
  * Created by dyoung on 6/7/17.
+ *
  * @hide
  */
 @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
 public class ScanJobScheduler {
     private static final String TAG = ScanJobScheduler.class.getSimpleName();
     private static final Object SINGLETON_LOCK = new Object();
-    private static final long MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING = 30000L;
+    private static final long MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING = TimeUnit.MINUTES.toMillis(5);
     @Nullable
     private static volatile ScanJobScheduler sInstance = null;
     @NonNull
@@ -81,7 +83,7 @@ private void ensureNotificationProcessorSetup(Context context) {
 
     private void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
         scanState.applyChanges(beaconManager);
-        LogManager.d(TAG, "Applying scan job settings with background mode "+scanState.getBackgroundMode());
+        LogManager.d(TAG, "Applying scan job settings with background mode " + scanState.getBackgroundMode());
         schedule(context, scanState, false);
     }
 
@@ -101,10 +103,11 @@ public void scheduleAfterBackgroundWakeup(Context context, List<ScanResult> scan
         synchronized (this) {
             // We typically get a bunch of calls in a row here, separated by a few millis.  Only do this once.
             if (System.currentTimeMillis() - mScanJobScheduleTime > MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING) {
-                LogManager.d(TAG, "scheduling an immediate scan job because last did "+(System.currentTimeMillis() - mScanJobScheduleTime)+"seconds ago.");
+                LogManager.d(TAG, "scheduling an immediate scan job because last did " + (System.currentTimeMillis()
+                                                                                          - mScanJobScheduleTime)
+                                  + "seconds ago.");
                 mScanJobScheduleTime = System.currentTimeMillis();
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "Not scheduling an immediate scan job because we just did recently.");
                 return;
             }
@@ -125,15 +128,14 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
 
         long millisToNextJobStart;
         if (backgroundWakeup) {
-            LogManager.d(TAG, "We just woke up in the background based on a new scan result.  Start scan job immediately.");
+            LogManager.d(TAG,
+                         "We just woke up in the background based on a new scan result.  Start scan job immediately.");
             millisToNextJobStart = 0;
-        }
-        else {
+        } else {
             if (betweenScanPeriod > 0) {
                 // If we pause between scans, then we need to start scanning on a normalized time
                 millisToNextJobStart = (SystemClock.elapsedRealtime() % scanState.getScanJobIntervalMillis());
-            }
-            else {
+            } else {
                 millisToNextJobStart = 0;
             }
 
@@ -146,32 +148,34 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
 
         JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
 
-        if (backgroundWakeup || ! scanState.getBackgroundMode()) {
+        if (backgroundWakeup || !scanState.getBackgroundMode()) {
             // If we are in the foreground, and we want to start a scan soon, we will schedule an
             // immediate job
             if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
                 // If the next time we want to scan is less than 50ms from the periodic scan cycle, then]
                 // we schedule it for that specific time.
-                LogManager.d(TAG, "Scheduling immediate ScanJob to run in "+millisToNextJobStart+" millis");
-                JobInfo immediateJob = new JobInfo.Builder(ScanJob.IMMEDIATE_SCAN_JOB_ID, new ComponentName(context, ScanJob.class))
+                LogManager.d(TAG, "Scheduling immediate ScanJob to run in " + millisToNextJobStart + " millis");
+                JobInfo immediateJob = new JobInfo.Builder(ScanJob.IMMEDIATE_SCAN_JOB_ID,
+                                                           new ComponentName(context, ScanJob.class))
                         .setPersisted(true) // This makes it restart after reboot
                         .setExtras(new PersistableBundle())
                         .setMinimumLatency(millisToNextJobStart)
                         .setOverrideDeadline(millisToNextJobStart).build();
                 int error = jobScheduler.schedule(immediateJob);
                 if (error < 0) {
-                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: " + error);
                 }
             } else {
                 LogManager.d(TAG, "Not scheduling immediate scan, assuming periodic is about to run");
             }
-        }
-        else {
-            LogManager.d(TAG, "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
+        } else {
+            LogManager.d(TAG,
+                         "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
             jobScheduler.cancel(ScanJob.IMMEDIATE_SCAN_JOB_ID);
         }
 
-        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(ScanJob.PERIODIC_SCAN_JOB_ID, new ComponentName(context, ScanJob.class))
+        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(ScanJob.PERIODIC_SCAN_JOB_ID,
+                                                                 new ComponentName(context, ScanJob.class))
                 .setPersisted(true) // This makes it restart after reboot
                 .setRequiresDeviceIdle(false)
                 .setRequiredNetworkType(JobInfo.NETWORK_TYPE_ANY)
@@ -181,8 +185,7 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
             // ON Android N+ we specify a tolerance of 0ms (capped at 5% by the OS) to ensure
             // our scans happen within 5% of the schduled time.
             periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0L).build();
-        }
-        else {
+        } else {
             periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis()).build();
         }
         // On Android O I see this:
@@ -237,10 +240,11 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
          */
 
         final JobInfo jobInfo = periodicJobBuilder.build();
-        LogManager.d(TAG, "Scheduling ScanJob " + jobInfo + " to run every "+scanState.getScanJobIntervalMillis()+" millis");
+        LogManager.d(TAG, "Scheduling ScanJob " + jobInfo + " to run every " + scanState.getScanJobIntervalMillis()
+                          + " millis");
         int error = jobScheduler.schedule(jobInfo);
         if (error < 0) {
-            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: " + error);
         }
     }
 }
