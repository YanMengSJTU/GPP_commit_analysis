diff --git a/build.gradle b/build.gradle
index 13645e73..1eacc358 100644
--- a/build.gradle
+++ b/build.gradle
@@ -54,7 +54,7 @@ android {
     buildToolsVersion "23"
 
     defaultConfig {
-        minSdkVersion 7
+        minSdkVersion 8
         targetSdkVersion 23
         versionCode 1
         versionName version
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index 2c31d988..0155b73f 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -5,6 +5,8 @@
     <uses-permission android:name="android.permission.BLUETOOTH"/>
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
+    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
+    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
     <uses-permission-sdk-23 android:name="android.permission.ACCESS_COARSE_LOCATION"/>
 
     <application>
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index 8a277734..3c567b01 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -30,10 +30,14 @@
 import org.altbeacon.beacon.client.NullBeaconDataFactory;
 import org.altbeacon.beacon.distance.DistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
+import org.json.JSONObject;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * The <code>Beacon</code> class represents a single hardware Beacon detected by
@@ -378,17 +382,22 @@ public void setExtraDataFields(List<Long> fields) {
      */
     public double getDistance() {
         if (mDistance == null) {
-            double bestRssiAvailable = mRssi;
-            if (mRunningAverageRssi != null) {
-                bestRssiAvailable = mRunningAverageRssi;
-            }
-            else {
-                LogManager.d(TAG, "Not using running average RSSI because it is null");
-            }
-            mDistance = calculateDistance(mTxPower, bestRssiAvailable);
+            mDistance = calculateDistance(mTxPower, getBestRssiAvailable());
         }
         return mDistance;
     }
+
+    public double getBestRssiAvailable() {
+        double bestRssiAvailable = mRssi;
+        if (mRunningAverageRssi != null) {
+            bestRssiAvailable = mRunningAverageRssi;
+        }
+        else {
+            LogManager.d(TAG, "Not using running average RSSI because it is null");
+        }
+        return bestRssiAvailable;
+    }
+
     /**
      * @see #mRssi
      * @return mRssi
@@ -529,6 +538,46 @@ public void writeToParcel(Parcel out, int flags) {
 
     }
 
+    /**
+     * JSONify beacon
+     */
+    public JSONObject toJSON() {
+        HashMap<String, Object> map = new HashMap<>();
+
+        ArrayList<String> identifiers = new ArrayList<>();
+        for (Identifier identifier: mIdentifiers) {
+            identifiers.add(identifier.toString());
+        }
+        map.put("identifiers", identifiers);
+
+        map.put("distance", getDistance());
+        map.put("rssi", getRssi());
+        map.put("best_rssi", getBestRssiAvailable());
+        LogManager.w(TAG,
+                "beacon saved with rssi : %d and best rssi: %f", getRssi(), getBestRssiAvailable());
+        map.put("tx_power", mTxPower);
+        map.put("bluetooth_address", mBluetoothAddress);
+        map.put("bluetooth_type_code", mBeaconTypeCode);
+        map.put("service_uuid", mServiceUuid);
+
+        ArrayList<Long> dataFields = new ArrayList<>();
+        for (Long dataField: mDataFields) {
+            dataFields.add(dataField);
+        }
+        map.put("data_fields", dataFields);
+
+        ArrayList<Long> extraDataFields = new ArrayList<>();
+        for (Long dataField: mExtraDataFields) {
+            extraDataFields.add(dataField);
+        }
+        map.put("extra_data_fields", extraDataFields);
+
+        map.put("manufacturer", mManufacturer);
+        map.put("bluetooth_name", mBluetoothName);
+
+        return new JSONObject(map);
+    }
+
     /**
      * Indicates whether this beacon is an "Extra data beacon," meaning one that has no identifiers
      * but has data fields.
diff --git a/src/main/java/org/altbeacon/beacon/logging/JSONDataLogger.java b/src/main/java/org/altbeacon/beacon/logging/JSONDataLogger.java
new file mode 100644
index 00000000..009bd6f8
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/JSONDataLogger.java
@@ -0,0 +1,156 @@
+package org.altbeacon.beacon.logging;
+
+import android.content.Context;
+import android.os.Environment;
+
+import org.altbeacon.beacon.Beacon;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.ObjectOutputStream;
+import java.io.PrintWriter;
+
+/**
+ * Created by sp911 on 10/11/15.
+ */
+public class JSONDataLogger {
+
+    private static final String TAG = "JSONDataLogger";
+    private static final String FILENAME = "BeaconData.json";
+
+    private static JSONDataLogger mInstance;
+    private boolean mEnabled;
+    private boolean mCrowded;
+    private int mRange;
+
+    private Context mContext;
+
+    public boolean isEnabled() {
+        return mEnabled;
+    }
+
+    public static void setEnabled(boolean mEnabled, Context context) {
+        getInstance().mEnabled = mEnabled;
+        getInstance().mContext = context;
+    }
+
+    public static void setCrowded(boolean crowded) {
+        getInstance().mCrowded = crowded;
+    }
+
+    public static void setRange(int range) {
+        getInstance().mRange = range;
+    }
+
+    public static JSONDataLogger getInstance() {
+        if(mInstance == null) {
+            mInstance = new JSONDataLogger();
+        }
+        return mInstance;
+    }
+
+    public void log(Beacon beacon, String component) {
+        if (!mEnabled) return;
+
+        JSONObject obj = beacon.toJSON();
+        log(obj, component);
+    }
+
+    public void log(String message, String component) {
+        if (!mEnabled) return;
+
+        JSONObject obj = new JSONObject();
+        try {
+            obj.put("message", message);
+        }
+        catch (JSONException e) {
+            LogManager.e(TAG, "Could not create JSON property");
+            e.printStackTrace();
+        }
+
+        log(obj, component);
+    }
+
+    public void log(JSONObject obj, String component) {
+        if (!mEnabled) return;
+
+        try {
+            obj.put("component", component);
+            obj.put("timestamp", System.currentTimeMillis());
+            obj.put("crowded", mCrowded);
+            obj.put("in_range", mRange);
+        }
+        catch (JSONException e) {
+            LogManager.e(TAG, "Could not create JSON property");
+            e.printStackTrace();
+        }
+
+        PrintWriter printer;
+        if (null != (printer = getPrinter())) {
+            printer.println(obj.toString());
+            printer.close();
+        }
+
+    }
+
+    private PrintWriter getPrinter() {
+        if (!(isExternalStorageWritable() & isExternalStorageReadable())) {
+            LogManager.e(TAG, "External storage is unavailable");
+            return null;
+        }
+
+        if (null == mContext) {
+            LogManager.e(TAG, "Context is not set");
+            return null;
+        }
+
+        // create file if it does not exist
+        File file = new File(mContext.getExternalFilesDir(""), FILENAME);
+        if (!file.exists()) {
+            try {
+                file.createNewFile();
+            } catch (IOException e) {
+                LogManager.e(TAG, "Could not create output file");
+                e.printStackTrace();
+            }
+        }
+
+        // get output stream
+        FileOutputStream fos = null;
+        try {
+            fos = new FileOutputStream(file, true);
+        } catch (FileNotFoundException e) {
+            LogManager.e(TAG, "Could not find output file");
+            e.printStackTrace();
+        }
+
+        PrintWriter printer = new PrintWriter(fos);
+
+        return printer;
+    }
+
+    /* Checks if external storage is available for read and write */
+    private boolean isExternalStorageWritable() {
+        String state = Environment.getExternalStorageState();
+        if (Environment.MEDIA_MOUNTED.equals(state)) {
+            return true;
+        }
+        return false;
+    }
+
+    /* Checks if external storage is available to at least read */
+    private boolean isExternalStorageReadable() {
+        String state = Environment.getExternalStorageState();
+        if (Environment.MEDIA_MOUNTED.equals(state) ||
+                Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {
+            return true;
+        }
+        return false;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 1ec4932b..be4a0cab 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -44,6 +44,7 @@
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.distance.DistanceCalculator;
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
+import org.altbeacon.beacon.logging.JSONDataLogger;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.altbeacon.beacon.service.scanner.CycledLeScanner;
@@ -53,7 +54,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -352,7 +352,11 @@ private void processRangeData() {
                 Region region = regionIterator.next();
                 RangeState rangeState = rangedRegionState.get(region);
                 LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region));
+                Collection<Beacon> finalizedBeacons = rangeState.finalizeBeacons();
+                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(finalizedBeacons, region));
+                for (Beacon beacon : finalizedBeacons) {
+                    JSONDataLogger.getInstance().log(beacon, "ProcessRangeData");
+                }
             }
         }
     }
@@ -375,6 +379,7 @@ private void processBeaconFromScan(Beacon beacon) {
         if (Stats.getInstance().isEnabled()) {
             Stats.getInstance().log(beacon);
         }
+        JSONDataLogger.getInstance().log(beacon, "ProcessBeaconFromScan");
         trackedBeaconsPacketCount++;
         if (LogManager.isVerboseLoggingEnabled()) {
             LogManager.d(TAG,
