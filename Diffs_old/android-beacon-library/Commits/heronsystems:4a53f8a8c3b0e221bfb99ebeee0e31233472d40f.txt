diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 00000000..49b4e00e
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,224 @@
+
+### Development
+
+Enhancements:
+
+- Add support for running the beacon scanning service in a separate process and working with
+  application setups that have more than one process. (#479, David G. Young)
+
+Bug Fixes:
+
+- Fix failure to stop scanning when unbinding from service or when the between scan period
+  is nonzero. (#507, David G. Young)
+
+### 2.10 / 2017-04-21
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9.2...2.10)
+
+Enhancements:
+
+- Don't restart BLE scanning periodically if the library confrims device can detect duplicate
+  advertisements in a single scan, leading to more reliable detections with short scan cycles
+  (#491, David G. Young)
+
+Bug Fixes:
+
+- Deprecate misspelled methods `removeMonitoreNotifier` and
+  `setRegionStatePeristenceEnabled` in favor of correctly spelled alternatives.
+  (#461, Marco Salis)
+- Fix bug causing brief scan dropouts after starting a scan after a long period
+  of inactivity (i.e. startup and background-foreground transitions) due to
+  Android N scan limits (#489, Aaron Kromer)
+- Ensure thread safety for singleton creation of `BeaconManager`,
+  `DetectionTracker`, `MonitoringStatus`, and `Stats`. (#494, Aaron Kromer)
+
+
+### 2.9.2 / 2016-11-22
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9.1...2.9.2)
+
+Bug Fixes:
+
+- Provide access to monitored regions after restoring state (#456, David G.
+  Young)
+- Don't start or stop scans if bluetooth state is off to prevent crashes on HTC
+  devices (#452, David G. Young)
+- Protect against SecurityException crashes caused by Samsung Knox (#444, David
+  G. Young)
+- No Monitoring information after killing an application built with the minify
+  mode (#432, ost-ct)
+- Start and stop BLE scans from a background thread to prevent blocking the UI
+  (#430, Marco Salis)
+- Prevent flapping (rapid exit then enter) of restored monitored regions (#426,
+  Elias Lecomte)
+- Don't implicitly require bluetooth in manifest (Commit b3ac622e2b, David G.
+  Young)
+
+
+### 2.9.1 / 2016-08-26
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9...2.9.1)
+
+Bug Fixes:
+
+- Fixes spurious entry/exit events on Android N caused by OS imposed limits of
+  5 scans every 30 seconds. (#419, David G. Young)
+
+
+### 2.9 / 2016-07-25
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.8.1...2.9)
+
+Enhancements:
+
+- Multiple ranging and monitoring notifiers are supported via
+  `BeaconManger#addRangeNotifier(RangeNotifier notifier)` and
+  `BeaconManger#addMonitorNotifier(MonitorNotifier notifier)` (#392, ost-ct)
+- App bootstrap regions by be dynamically changed with
+  new`RegionBootstrap#removeRegion(Region region)` and
+  `RegionBootstrap#addRegion(Region region)` methods. (#369, Aristide)
+- Improved region state behavior by adding
+  `BeaconManager#requestStateForRegion(Region)` and
+  `BeaconManager#setRegionStatePeristenceEnabled(boolean)` (#405, David G.
+  Young)
+- Added a guaranteed callback to
+  `MonitorNotifier#didDetermineStateForRegion(int state, Region region)` when
+  starting monitoring.  At app startup, this returns the previously known
+  persisted state. (#405, David G. Young)
+- Custom distance calculation for Moto X 2nd gen XT1092 (#386, Clément Garcia)
+- More flexible support for combining multi-frame beacons with
+  `Beacon#getExtraDataFields()` (#387, mfatiga)
+
+Bug Fixes:
+
+- Eddystone frame detection on Google's Android BeaconTools and Chrome fixed by
+  adding missing service UUID PDU. (#401, David G. Young)
+- Beacon data fields of over four bytes are now be parsed correctly. (#373,
+  Junsung Lim)
+- Region persistence app freezes resolved by limiting persisted regions to 50
+  (#405, David G. Young)
+- Fixed inability to starting monitoring for a different Region definition with
+  the same uniqueId (#405, David G. Young)
+- Fixes Eddystone-URL layout to support the full 17 bytes for URLs (uses 18
+  bytes total: 1 byte for schema and 17 bytes for URL) (#377, Mario Pucci)
+- Fix potential context leak in `BeaconManager` (#381, Ovidiu Latcu)
+
+
+### 2.8.1 / 2016-04-18
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.8...2.8.1)
+
+Bug Fixes:
+
+- As of the 2.8 release, scanning would never start on Android 4.x devices
+  unless the application manually added ACCESS_COARSE_LOCATION or
+  ACCESS_FINE_LOCATION permissions to the AndroidManifest.xml. This fix makes
+  it so this is not required for 4.x devices, as was the case prior to 2.8.
+  (#365, David G. Young)
+
+
+### 2.8 / 2016-03-28
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.7.1...2.8)
+
+Enhancements:
+
+- Retains monitored regions across service restarts, preventing apps from
+  getting multiple region entry callbacks each time the service restarts.
+  (#315, Mateusz Sarzyński)
+- Add string identifier to BeaconParser which can be referenced by decoded
+  Beacon object, allowing easy determination of beacon type. (#333, David G.
+  Young)
+- Switch to using ELAPSED_REALTIME clocks, so scanning doesn't stop on devices
+  without a battery-backed RTC (#339, Luca Niccoli)
+- Add ability to access raw EDDYSTONE_TLM data for sending info to Google
+  services. (#328, David G. Young)
+- New distance formula for Moto X Pro (#330, David G. Young)
+- Adjust the BackgroundPowerSaver so it accepts any context (#355, Kristof
+  Snyers)
+- Add support for pre-Eddystone UriBeacon layout (#358, David G. Young)
+
+Bug Fixes:
+
+- Multiple consumers of the BeaconService will now each get a
+  onBeaconServiceConnected() callback. (#340, Mateusz Sarzyński)
+- Don't scan for bluetooth devices if permission has not been granted in
+  Android 6. This prevents large number of exceptions in the log. (#327, Alex
+  Urzhumtcev)
+- Fix crash on beacon parsing comparison overrun (#324, David G. Young)
+
+
+### 2.7.1 / 2015-11-17
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.7...2.7.1)
+
+Bug Fixes:
+
+- Stopping and starting monitoring disables scans (#317, David G. Young)
+
+
+### 2.7 / 2015-11-12
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.6.1...2.7)
+
+Enhancements:
+
+- Adds hardware accelerated detection of Eddystone frames in the background on
+  Android 5+ (#314, David G. Young)
+- Provides ability to forward BLE scan callbacks for non-beacon advertisements
+  (#267, Paul Peavyhouse)
+
+Bug Fixes:
+
+- Fix rescheduling of alarms in the distant future so they don't inadvertently
+  go off right away (#312, Mateusz Sarzyński)
+- Only request `ACCESS_COARSE_LOCATION` permission on Android M (#296, Henning
+  Dodenhof)
+
+
+### 2.6.1 / 2015-09-30
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.6...2.6.1)
+
+Bug Fixes:
+
+- Allow Regions to match beacons with fewer identifiers if the extra region
+  identifiers are null. This allows matching Eddystone-UID and Eddystone-URL
+  beacon with the default Region with three null identifiers. This started
+  failing in version 2.6. (#295, David G. Young)
+- Declare the `ACCESS_COARSE_LOCATION` permission in the manifest since it is
+  required for Android 6.0. This is helpful to keep beacon detection working on
+  Android 6.0 for apps that don't explicitly declare this in their own
+  manifest. (#295, David G. Young)
+
+
+### 2.6 / 2015-09-29
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.5.1...2.6)
+
+Enhancements:
+
+- Make region exit period configuration with a default of ten seconds (#283,
+  Alex Urzhumtcev)
+- When scanning in Background on Android 5+, do a full scan without filters
+  during the main scan period (default for 10 seconds once every 5 minutes) in
+  case scan filters are unavailable (#293, David G. Young)
+- Common open-source BeaconParser layouts are defined as constants on
+  BeaconParser (Commit 0101970010, David G. Young)
+- Bluetooth address is now a field on Region, offering the option of monitoring
+  and ranging for all beacon transmissions from a known device's MAC Address
+  (#254, David G. Young)
+- Target SDK bumped to 23 for Android 6.0 (#293, David G. Young)
+
+Bug Fixes:
+
+- Fix potential `ConcurrentModificationException` with distance calculation
+  (#245, Dawid Drozd)
+- Fix potential `NullPointerException` in `Beacon#hashCode` (#249, Sam Yang)
+- Switch BeaconParsers list to be a `CopyOnWriteArrayList` to avoid
+  `UnsupportedOperationException` changing list after starting scanning. (#290,
+  Matthew Michihara)
+- Fix crash when region has more identifiers than beacon (#252, David G. Young)
+- Fix bugs with compressing Eddystone-URL to bytes and back (#263, Michael
+  Harper)
+
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 63114dce..a87a54f1 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1,30 +1,30 @@
-#How to Contribute to the Android Beacon Library
+# How to Contribute to the Android Beacon Library
 
-This project welcomes code contributions from the community.  Proposed code changes should be submitted as a pull request on Github.  Please follow the following guidelines when submitting a [pull request](https://github.com/altbeacon/android-beacon-library/pulls).
+This project welcomes code contributions from the communityProposed code changes should be submitted as a pull request on Github. Please follow the following guidelines when submitting a [pull request](https://github.com/altbeacon/android-beacon-library/pulls).
 
-##Style
+## Style
 
 Code style should generally follow the [Android coding style](https://source.android.com/source/code-style.html)
 
-##API Changes
+## API Changes
 
-Changes generally should not break the existing API and should be backward compatible with the current release version.   If the PR does represent a breaking change, the title or description must make this clear.  Breaking changes will be held for the next major version release of the library.
+Changes generally should not break the existing API and should be backward compatible with the current release version If the PR does represent a breaking change, the title or description must make this clear. Breaking changes will be held for the next major version release of the library.
 
-##Testing
+## Testing
 
-PRs must include testing information to ensure the changes are functional and do not adversely affect other library functions.  Testing information must include one or more of the following:
+PRs must include testing information to ensure the changes are functional and do not adversely affect other library functionsTesting information must include one or more of the following:
 
-###1. Automated Robolectric tests:
+### 1. Automated Robolectric tests:
 
-Robolectric tests are required for most changes, and should be submitted along with the PR.  Exceptions include Bluetooth or Android OS-level changes that cannot be tested with Robolectric.  Examples of Robolectric tests exist in the src/test folder.
+Robolectric tests are required for most changes, and should be submitted along with the PRExceptions include Bluetooth or Android OS-level changes that cannot be tested with Robolectric. Examples of Robolectric tests exist in the src/test folder.
 
-Robolectric test updates are absolutely required if existing Robolectric tests exists for the modified code. 
+Robolectric test updates are absolutely required if existing Robolectric tests exists for the modified code.
 
 Regardless of whether Robolectric tests are added or modified, all tests must be passing on the branch of the PR when running `./gradlew test `
 
-###2. Manual tests:
+### 2. Manual tests:
 
-Changes affecting Bluetooth scanning, addressing device-specific issues often cannot be adequately tested using Robolectric since it stubs out Bluetooth and Android OS system calls.  Changes of this nature must be manually tested on a physical device.  Manual tests should be performed with the library's reference application, if possible.
+Changes affecting Bluetooth scanning, addressing device-specific issues often cannot be adequately tested using Robolectric since it stubs out Bluetooth and Android OS system callsChanges of this nature must be manually tested on a physical device. Manual tests should be performed with the library's reference application, if possible.
 
 When submitting a PR, a description of any manual testing performed should include:
 
@@ -36,10 +36,10 @@ When submitting a PR, a description of any manual testing performed should inclu
 
 * A description of the conditions witnessed that verify the code works as designed and that other functions are not broken
 
-###3. Changes that cannot be tested manually or with Robolectric
+### 3. Changes that cannot be tested manually or with Robolectric
 
-In some rare cases where changes cannot be verified manually (e.g. some intermittent issues), a description may be included of why testing cannot be performed and describing why the change is low-risk and can be verified by code review.  For such changes to be considered low-risk they typically must be very small
+In some rare cases where changes cannot be verified manually (e.g. some intermittent issues), a description may be included of why testing cannot be performed and describing why the change is low-risk and can be verified by code reviewFor such changes to be considered low-risk they typically must be very small
 
-##License
+## License
 
-Any code submitted must be the work of the author, or if third party must be covered by the same Apache 2 license as this library or the Android Open Source Project.  Once submitted, the code is covered under the terms of the license of this library.
+Any code submitted must be the work of the author, or if third party must be covered by the same Apache 2 license as this library or the Android Open Source ProjectOnce submitted, the code is covered under the terms of the license of this library.
diff --git a/build.gradle b/build.gradle
index 5a675958..ac54f10a 100644
--- a/build.gradle
+++ b/build.gradle
@@ -28,8 +28,8 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:1.5.0'
-        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0'
+        classpath 'com.android.tools.build:gradle:2.3.0'
+        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3'
     }
 }
@@ -49,7 +49,7 @@ allprojects {
 
 android {
     compileSdkVersion 24
-    buildToolsVersion "24.0.2"
+    buildToolsVersion "25.0.2"
 
     defaultConfig {
         minSdkVersion 7
@@ -66,12 +66,6 @@ android {
         targetCompatibility JavaVersion.VERSION_1_7
     }
 
-    sourceSets {
-        androidTest {
-            setRoot('src/test')
-        }
-    }
-
     lintOptions {
         abortOnError false
     }
@@ -82,42 +76,25 @@ android {
         exclude 'META-INF/LICENSE.txt'
         exclude 'META-INF/NOTICE'
     }
-
 }
 
 dependencies {
     compile fileTree ( dir: 'libs', include: ['*.jar'] )
-    testCompile 'org.hamcrest:hamcrest-integration:1.3'
-    testCompile 'org.hamcrest:hamcrest-core:1.3'
-    testCompile 'org.hamcrest:hamcrest-library:1.3'
+    compile 'com.android.support:support-annotations:24.2.1'
 
     testCompile('junit:junit:4.12') {
-        exclude module: 'hamcrest-core'
+        exclude group: 'org.hamcrest'
     }
-    testCompile('com.squareup:fest-android:1.0.+@aar') {
-        exclude group: 'com.android.support', module: 'support-v4'
+    testCompile('org.hamcrest:hamcrest-junit:2.0.0.0') {
+        exclude group: 'junit'
     }
-
+    testCompile('com.squareup:fest-android:1.0.+@aar')
     testCompile('org.robolectric:robolectric:3.0') {
-        exclude module: 'classworlds'
-        exclude module: 'commons-logging'
-        exclude module: 'httpclient'
-        exclude module: 'maven-artifact'
-        exclude module: 'maven-artifact-manager'
-        exclude module: 'maven-error-diagnostics'
-        exclude module: 'maven-model'
-        exclude module: 'maven-project'
-        exclude module: 'maven-settings'
-        exclude module: 'plexus-container-default'
-        exclude module: 'plexus-interpolation'
-        exclude module: 'plexus-utils'
-        exclude module: 'wagon-file'
-        exclude module: 'wagon-http-lightweight'
-        exclude module: 'wagon-provider-api'
-        exclude group: 'com.android.support', module: 'support-v4'
-    }
-
-    testCompile 'org.mockito:mockito-core:1.10.19'
+        exclude group: 'junit'
+    }
+    testCompile('org.mockito:mockito-core:1.10.19') {
+        exclude group: 'org.hamcrest'
+    }
 }
 
 apply plugin: 'idea'
diff --git a/circle.yml b/circle.yml
index 50eb8479..dc4aa38b 100644
--- a/circle.yml
+++ b/circle.yml
@@ -3,5 +3,5 @@ machine:
     version: openjdk8
 dependencies:
   pre:
-    - echo y | android update sdk --no-ui --all --filter "tools,android-24,build-tools-24.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
+    - echo y | android update sdk --no-ui --all --filter "tools,android-24,build-tools-25.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
 
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 2944df68..388ee27b 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
-#Sat May 10 23:17:01 CDT 2014
+#Sat Apr 01 10:19:45 EDT 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/ibeacon-service-android.iml b/ibeacon-service-android.iml
deleted file mode 100644
index fd696913..00000000
--- a/ibeacon-service-android.iml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module external.system.id="GRADLE" type="JAVA_MODULE" version="4">
-  <component name="NewModuleRootManager" inherit-compiler-output="false">
-    <output url="file://$MODULE_DIR$/build/classes/main" />
-    <output-test url="file://$MODULE_DIR$/build/classes/test" />
-    <exclude-output />
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="1.6" jdkType="JavaSDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
-
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index e457e835..a27fcf75 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -29,7 +29,7 @@
             />
 
         <service android:name=".service.ScanJob"
-                 android:permission="android.permission.BIND_JOB_SERVICE" />
+                android:permission="android.permission.BIND_JOB_SERVICE" />
     </application>
 
 </manifest>
diff --git a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
index a0ace8a0..7e98d225 100644
--- a/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/AltBeaconParser.java
@@ -23,7 +23,6 @@
  */
 package org.altbeacon.beacon;
 
-import android.annotation.TargetApi;
 import android.bluetooth.BluetoothDevice;
 import android.util.Log;
 
@@ -63,7 +62,6 @@ public AltBeaconParser() {
      * @param device The Bluetooth device that was detected
      * @return An instance of an <code>Beacon</code>
      */
-    @TargetApi(5)
     @Override
     public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
         return fromScanData(scanData, rssi, device, new AltBeacon());
diff --git a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index 2520fc6f..b2d11269 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -23,20 +23,20 @@
  */
 package org.altbeacon.beacon;
 
-import android.annotation.TargetApi;
 import android.app.IntentService;
 import android.content.Intent;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.MonitoringData;
+import org.altbeacon.beacon.service.MonitoringStatus;
 import org.altbeacon.beacon.service.RangingData;
 
 import java.util.Set;
 
 /**
  * Converts internal intents to notifier callbacks
+ * This IntentService may be running in a different process from the BeaconService.
  */
-@TargetApi(3)
 public class BeaconIntentProcessor extends IntentService {
     private static final String TAG = "BeaconIntentProcessor";
 
@@ -87,7 +87,14 @@ protected void onHandleIntent(Intent intent) {
             if (notifiers != null) {
                 for(MonitorNotifier notifier : notifiers) {
                     LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
-                    notifier.didDetermineStateForRegion(monitoringData.isInside() ? MonitorNotifier.INSIDE : MonitorNotifier.OUTSIDE, monitoringData.getRegion());
+                    Region region = monitoringData.getRegion();
+                    Integer state = monitoringData.isInside() ? MonitorNotifier.INSIDE :
+                            MonitorNotifier.OUTSIDE;
+                    notifier.didDetermineStateForRegion(state, region);
+                    // In case the beacon scanner is running in a separate process, the monitoring
+                    // status in this process  will not have been updated yet as a result of this
+                    // region state change.  We make a call here to keep it in sync.
+                    MonitoringStatus.getInstanceForApplication(this).updateLocalState(region, state);
                     if (monitoringData.isInside()) {
                         notifier.didEnterRegion(monitoringData.getRegion());
                     } else {
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index aad80f91..12171e37 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -30,6 +30,7 @@
 import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
@@ -62,6 +63,9 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CopyOnWriteArraySet;
 
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanState;
+
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
@@ -109,11 +113,10 @@
  * @author David G. Young
  * @author Andrew Reitz <andrew@andrewreitz.com>
  */
-@TargetApi(4)
 public class BeaconManager {
     private static final String TAG = "BeaconManager";
     private Context mContext;
-    protected static BeaconManager sInstance = null;
+    protected static volatile BeaconManager sInstance = null;
     private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<BeaconConsumer,ConsumerInfo>();
     private Messenger serviceMessenger = null;
     protected final Set<RangeNotifier> rangeNotifiers = new CopyOnWriteArraySet<>();
@@ -122,14 +125,21 @@
     private final ArrayList<Region> rangedRegions = new ArrayList<Region>();
     private final List<BeaconParser> beaconParsers = new CopyOnWriteArrayList<>();
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+    private boolean mRegionStatePersistenceEnabled = true;
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
     private boolean mMainProcess = false;
     private Boolean mScannerInSameProcess = null;
+    private boolean mScheduledScanJobsEnabled = false;
 
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
 
+    /**
+     * Private lock object for singleton initialization protecting against denial-of-service attack.
+     */
+    private static final Object SINGLETON_LOCK = new Object();
+
     /**
      * Set to true if you want to show library debugging.
      *
@@ -230,6 +240,9 @@ public void setBackgroundBetweenScanPeriod(long p) {
      */
     public static void setRegionExitPeriod(long regionExitPeriod){
         sExitRegionPeriod = regionExitPeriod;
+        if (sInstance != null) {
+            sInstance.applySettings();
+        }
     }
     
     /**
@@ -246,11 +259,29 @@ public static long getRegionExitPeriod(){
      * or non-Service class, you can attach it to another singleton or a subclass of the Android Application class.
      */
     public static BeaconManager getInstanceForApplication(Context context) {
-        if (sInstance == null) {
-            LogManager.d(TAG, "BeaconManager instance creation");
-            sInstance = new BeaconManager(context);
+        /*
+         * Follow double check pattern from Effective Java v2 Item 71.
+         *
+         * Bloch recommends using the local variable for this for performance reasons:
+         *
+         * > What this variable does is ensure that `field` is read only once in the common case
+         * > where it's already initialized. While not strictly necessary, this may improve
+         * > performance and is more elegant by the standards applied to low-level concurrent
+         * > programming. On my machine, [this] is about 25 percent faster than the obvious
+         * > version without a local variable.
+         *
+         * Joshua Bloch. Effective Java, Second Edition. Addison-Wesley, 2008. pages 283-284
+         */
+        BeaconManager instance = sInstance;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = sInstance;
+                if (instance == null) {
+                    sInstance = instance = new BeaconManager(context);
+                }
+            }
         }
-        return sInstance;
+        return instance;
     }
 
     protected BeaconManager(Context context) {
@@ -262,6 +293,26 @@ protected BeaconManager(Context context) {
         this.beaconParsers.add(new AltBeaconParser());
     }
 
+
+    public void setEnableScheduledScanJobs(boolean enabled) {
+        this.mScheduledScanJobsEnabled = enabled;
+    }
+    public boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+    public long getBackgroundScanPeriod() {
+        return backgroundScanPeriod;
+    }
+    public long getBackgroundBetweenScanPeriod() {
+        return backgroundBetweenScanPeriod;
+    }
+    public long getForegroundScanPeriod() {
+        return foregroundScanPeriod;
+    }
+    public long getForegroundBetweenScanPeriod() {
+        return foregroundBetweenScanPeriod;
+    }
+
     /***
      * Determines if this BeaconManager instance is associated with the main application process that
      * hosts the user interface.  This is normally true unless the scanning service or another servide
@@ -273,17 +324,21 @@ public boolean isMainProcess() {
     }
 
     /**
-     * Determines if this BeaconManager instance is part of the process hosting the beacon scanning
-     * service.  This is normally true, except when scanning is hosted in a different service.
-     * This will return null until the scanning service starts up, at which time it will be known.
+     * 
+     * Determines if this BeaconManager instance is not part of the process hosting the beacon scanning
+     * service.  This is normally false, except when scanning is hosted in a different process.
+     * This will always return false until the scanning service starts up, at which time it will be
+     * known if it is in a different process.
+     *
      * @return
      */
-    public Boolean isScannerInSameProcess() {
-        return mScannerInSameProcess;
+    public boolean isScannerInDifferentProcess() {
+        // may be null if service not started yet, so explicitly check
+        return mScannerInSameProcess != null && !mScannerInSameProcess;
     }
 
     /**
-     * Reserved for internal by the library.
+     * Reserved for internal use by the library.
      * @hide
      */
     public void setScannerInSameProcess(boolean isScanner) {
@@ -316,17 +371,10 @@ protected void checkIfMainProcess() {
      */
     @TargetApi(18)
     public boolean checkAvailability() throws BleNotAvailableException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
+        if (!isBleAvailable()) {
             throw new BleNotAvailableException("Bluetooth LE not supported by this device");
         }
-        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
-            throw new BleNotAvailableException("Bluetooth LE not supported by this device");
-        } else {
-            if (((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled()) {
-                return true;
-            }
-        }
-        return false;
+        return ((BluetoothManager) mContext.getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter().isEnabled();
     }
 
     /**
@@ -337,8 +385,17 @@ public boolean checkAvailability() throws BleNotAvailableException {
      * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
      */
     public void bind(BeaconConsumer consumer) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
+        }
+        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            LogManager.w(TAG, "This device does not support bluetooth LE.  Will not start beacon scanning.");
+            return;
+        }
+        if (mScheduledScanJobsEnabled) {
+            LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
+            consumer.onBeaconServiceConnect();
             return;
         }
         if (mScheduledScanJobsEnabled) {
@@ -369,8 +426,8 @@ public void bind(BeaconConsumer consumer) {
      * @param consumer the <code>Activity</code> or <code>Service</code> that no longer needs to use the service.
      */
     public void unbind(BeaconConsumer consumer) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
         synchronized (consumers) {
@@ -442,8 +499,9 @@ public boolean isAnyConsumerBound() {
      * @see #setBackgroundBetweenScanPeriod(long p)
      */
     public void setBackgroundMode(boolean backgroundMode) {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
         }
         mBackgroundModeUninitialized = false;
         if (backgroundMode != mBackgroundMode) {
@@ -559,6 +617,9 @@ public void removeAllRangeNotifiers() {
      */
     @Deprecated
     public void setMonitorNotifier(MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         synchronized (monitorNotifiers) {
             monitorNotifiers.clear();
         }
@@ -579,6 +640,9 @@ public void setMonitorNotifier(MonitorNotifier notifier) {
      * @see Region
      */
     public void addMonitorNotifier(MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         if (notifier != null) {
             synchronized (monitorNotifiers) {
                 monitorNotifiers.add(notifier);
@@ -604,6 +668,9 @@ public boolean removeMonitoreNotifier(MonitorNotifier notifier) {
      * @see Region
      */
     public boolean removeMonitorNotifier(MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return false;
+        }
         synchronized (monitorNotifiers) {
             return monitorNotifiers.remove(notifier);
         }
@@ -613,6 +680,9 @@ public boolean removeMonitorNotifier(MonitorNotifier notifier) {
      * Remove all the Monitor Notifiers.
      */
     public void removeAllMonitorNotifiers() {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         synchronized (monitorNotifiers) {
             monitorNotifiers.clear();
         }
@@ -637,11 +707,15 @@ public void setRegionStatePeristenceEnabled(boolean enabled) {
      * @param enabled true to enable the region state persistence, false to disable it.
      */
     public void setRegionStatePersistenceEnabled(boolean enabled) {
-        if (enabled) {
-            MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
-        } else {
-            MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+        mRegionStatePersistenceEnabled = enabled;
+        if (!isScannerInDifferentProcess()) {
+            if (enabled) {
+                MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
+            } else {
+                MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+            }
         }
+        this.applySettings();
     }
 
     /**
@@ -649,7 +723,7 @@ public void setRegionStatePersistenceEnabled(boolean enabled) {
      * @return
      */
     public boolean isRegionStatePersistenceEnabled() {
-        return MonitoringStatus.getInstanceForApplication(mContext).isStatePreservationOn();
+        return mRegionStatePersistenceEnabled;
     }
 
     /**
@@ -659,6 +733,9 @@ public boolean isRegionStatePersistenceEnabled() {
      * @param region
      */
     public void requestStateForRegion(Region region) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         MonitoringStatus status = MonitoringStatus.getInstanceForApplication(mContext);
         RegionMonitoringState stateObj = status.stateOf(region);
         int state = MonitorNotifier.OUTSIDE;
@@ -686,10 +763,16 @@ public void requestStateForRegion(Region region) {
      */
     @TargetApi(18)
     public void startRangingBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
+        }
+        if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
+        synchronized (rangedRegions) {
+            rangedRegions.add(region);
+        }
         if (mScheduledScanJobsEnabled) {
             ScanJob.applySettingsToScheduledJob(mContext, this);
         }
@@ -701,9 +784,6 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
             msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
             serviceMessenger.send(msg);
         }
-        synchronized (rangedRegions) {
-            rangedRegions.add(region);
-        }
     }
 
     /**
@@ -718,17 +798,12 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
      */
     @TargetApi(18)
     public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (!mScheduledScanJobsEnabled) {
-            if (serviceMessenger == null) {
-                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-            }
-            Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-            serviceMessenger.send(msg);
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
         synchronized (rangedRegions) {
             Region regionToRemove = null;
@@ -740,22 +815,33 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             rangedRegions.remove(regionToRemove);
         }
         if (mScheduledScanJobsEnabled) {
-            ScanJob.startMonitoring(mContext, this, region);
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
+            msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
         }
     }
 
     /**
      * Call this method if you are running the scanner service in a different process in order to
      * synchronize any configuration settings, including BeaconParsers to the scanner
-     * @see #isScannerInSameProcess()
+     * @see #isScannerInDifferentProcess()
      */
     public void applySettings() {
-        if (isScannerInSameProcess() != null && isScannerInSameProcess() == false) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        if (isAnyConsumerBound() && !isScannerInDifferentProcess() == false) {
             LogManager.d(TAG, "Synchronizing settings to service");
             syncSettingsToService();
         }
         else {
-            if (isScannerInSameProcess() == null) {
+            if (isAnyConsumerBound() == false) {
                 LogManager.d(TAG, "Not synchronizing settings to service, as it has not started up yet");
 
             }
@@ -798,8 +884,11 @@ protected void syncSettingsToService() {
      */
     @TargetApi(18)
     public void startMonitoringBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
+        }
+        if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
         if (mScheduledScanJobsEnabled) {
@@ -814,6 +903,9 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
             msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
             serviceMessenger.send(msg);
         }
+        if (isScannerInDifferentProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
+        }
         this.requestStateForRegion(region);
     }
 
@@ -830,13 +922,15 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
      */
     @TargetApi(18)
     public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
+            return;
+        }
+        if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
         if (mScheduledScanJobsEnabled) {
             ScanJob.applySettingsToScheduledJob(mContext, this);
-            ScanJob.stopMonitoring(mContext, this, region);
         }
         else {
             if (serviceMessenger == null) {
@@ -846,6 +940,9 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
             msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
             serviceMessenger.send(msg);
         }
+        if (isScannerInDifferentProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
+        }
     }
 
 
@@ -857,22 +954,26 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
      */
     @TargetApi(18)
     public void updateScanPeriods() throws RemoteException {
-        if (android.os.Build.VERSION.SDK_INT < 18) {
-            LogManager.w(TAG, "Not supported prior to API 18.  Method invocation will be ignored");
+        if (!isBleAvailable()) {
+            LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (mScheduledScanJobsEnabled) {
-            ScanJob.applySettingsToScheduledJob(mContext, this);
+        if (determineIfCalledFromSeparateScannerProcess()) {
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
-        Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
         LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
         LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
-        msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        serviceMessenger.send(msg);
+        if (mScheduledScanJobsEnabled) {
+            ScanJob.applySettingsToScheduledJob(mContext, this);
+        }
+        else {
+            if (serviceMessenger == null) {
+                throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            }
+            Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
+            msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            serviceMessenger.send(msg);
+        }
     }
 
     private String callbackPackageName() {
@@ -976,6 +1077,7 @@ public static String getDistanceModelUpdateUrl() {
     }
 
     public static void setDistanceModelUpdateUrl(String url) {
+        warnIfScannerNotInSameProcess();
         distanceModelUpdateUrl = url;
     }
 
@@ -985,6 +1087,7 @@ public static void setDistanceModelUpdateUrl(String url) {
     protected static Class rssiFilterImplClass = RunningAverageRssiFilter.class;
 
     public static void setRssiFilterImplClass(Class c) {
+        warnIfScannerNotInSameProcess();
         rssiFilterImplClass = c;
     }
 
@@ -1013,6 +1116,7 @@ public void setMaxTrackingAge(int maxTrackingAge) {
     }
 
     public static void setBeaconSimulator(BeaconSimulator beaconSimulator) {
+        warnIfScannerNotInSameProcess();
         BeaconManager.beaconSimulator = beaconSimulator;
     }
 
@@ -1037,6 +1141,18 @@ public void setNonBeaconLeScanCallback(NonBeaconLeScanCallback callback) {
         mNonBeaconLeScanCallback = callback;
     }
 
+    private boolean isBleAvailable() {
+        boolean available = false;
+        if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            LogManager.w(TAG, "Bluetooth LE not supported prior to API 18.");
+        } else if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            LogManager.w(TAG, "This device does not support bluetooth LE.");
+        } else {
+            available = true;
+        }
+        return available;
+    }
+
     private long getScanPeriod() {
         if (mBackgroundMode) {
             return backgroundScanPeriod;
@@ -1056,10 +1172,10 @@ private long getBetweenScanPeriod() {
     private void verifyServiceDeclaration() {
         final PackageManager packageManager = mContext.getPackageManager();
         final Intent intent = new Intent(mContext, BeaconService.class);
-        List resolveInfo =
+        List<ResolveInfo> resolveInfo =
                 packageManager.queryIntentServices(intent,
                         PackageManager.MATCH_DEFAULT_ONLY);
-        if (resolveInfo.size() == 0) {
+        if (resolveInfo != null && resolveInfo.size() == 0) {
             throw new ServiceNotDeclaredException();
         }
     }
@@ -1164,4 +1280,21 @@ public static boolean getManifestCheckingDisabled() {
         return sManifestCheckingDisabled;
     }
 
+    private boolean determineIfCalledFromSeparateScannerProcess() {
+        if (isScannerInDifferentProcess() && !isMainProcess()) {
+            LogManager.w(TAG, "Ranging/Monitoring may not be controlled from a separate "+
+                    "BeaconScanner process.  To remove this warning, please wrap this call in:"+
+                    " if (beaconManager.isMainProcess())");
+            return true;
+        }
+        return false;
+    }
+
+    private static void warnIfScannerNotInSameProcess() {
+        if (sInstance != null && sInstance.isScannerInDifferentProcess()) {
+            LogManager.w(TAG,
+                    "Unsupported configuration change made for BeaconScanner in separate process");
+        }
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index 803b8dfb..8591db4e 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -414,12 +414,10 @@ public int getServiceUuidEndOffset() {
      * @param device The Bluetooth device that was detected
      * @return An instance of a <code>Beacon</code>
      */
-    @TargetApi(5)
     public Beacon fromScanData(byte[] scanData, int rssi, BluetoothDevice device) {
         return fromScanData(scanData, rssi, device, new Beacon());
     }
 
-    @TargetApi(5)
     protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice device, Beacon beacon) {
         BleAdvertisement advert = new BleAdvertisement(bytesToProcess);
         boolean parseFailed = false;
@@ -459,12 +457,12 @@ protected Beacon fromScanData(byte[] bytesToProcess, int rssi, BluetoothDevice d
             boolean patternFound = false;
 
             if (getServiceUuid() == null) {
-                if (byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
+                if (byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes)) {
                     patternFound = true;
                 }
             } else {
-                if (byteArraysMatch(bytesToProcess, startByte + mServiceUuidStartOffset, serviceUuidBytes, 0) &&
-                        byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes, 0)) {
+                if (byteArraysMatch(bytesToProcess, startByte + mServiceUuidStartOffset, serviceUuidBytes) &&
+                        byteArraysMatch(bytesToProcess, startByte + mMatchingBeaconTypeCodeStartOffset, typeCodeBytes)) {
                     patternFound = true;
                 }
             }
@@ -830,18 +828,19 @@ private int calculateLayoutSize() {
         return lastEndOffset+1;
     }
 
-    private boolean byteArraysMatch(byte[] array1, int offset1, byte[] array2, int offset2) {
-        int minSize = array1.length > array2.length ? array2.length : array1.length;
-        if (offset1+minSize > array1.length || offset2+minSize > array2.length) {
+    private boolean byteArraysMatch(byte[] source, int offset, byte[] expected) {
+        int length = expected.length;
+        if (source.length - offset < length) {
             return false;
         }
-        for (int i = 0; i <  minSize; i++) {
-            if (array1[i+offset1] != array2[i+offset2]) {
+        for (int i = 0; i <  length; i++) {
+            if (source[offset + i] != expected[i]) {
                 return false;
             }
         }
         return true;
     }
+
     private String byteArrayToString(byte[] bytes) {
         StringBuilder sb = new StringBuilder();
         for (int i = 0; i < bytes.length; i++) {
diff --git a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
index 5e7367a3..bebb7c91 100644
--- a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
+++ b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceUpdater.java
@@ -1,6 +1,5 @@
 package org.altbeacon.beacon.distance;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.os.AsyncTask;
@@ -14,7 +13,6 @@
 /**
  * Created by dyoung on 9/12/14.
  */
-@TargetApi(Build.VERSION_CODES.CUPCAKE)
 public class ModelSpecificDistanceUpdater extends AsyncTask<Void, Void, Void> {
 
     private static final String TAG = "ModelSpecificDistanceUpdater";
diff --git a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
index 4119c465..ff6186c9 100644
--- a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
+++ b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
@@ -44,8 +44,8 @@ public BackgroundPowerSaver(Context context) {
             LogManager.w(TAG, "BackgroundPowerSaver requires API 18 or higher.");
             return;
         }
-        ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
         beaconManager = BeaconManager.getInstanceForApplication(context);
+        ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
     }
 
     @Override
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 2edb68a6..63f38787 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -50,6 +50,7 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.beacon.utils.ProcessUtils;
@@ -75,7 +76,6 @@
  * @author dyoung
  */
 
-@TargetApi(5)
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
 
@@ -92,7 +92,8 @@
     private boolean mBackgroundFlag = false;
     private ExtraDataBeaconTracker mExtraDataBeaconTracker;
     private ExecutorService mExecutor;
-
+    private final DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
+    
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -390,6 +391,7 @@ public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
 
         @Override
         public void onCycleEnd() {
+            mDistinctPacketDetector.clearDetections();
             monitoringStatus.updateNewlyOutside();
             processRangeData();
             // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
@@ -509,7 +511,17 @@ protected Void doInBackground(ScanData... params) {
                 }
             }
             if (beacon != null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                }
                 mDetectionTracker.recordDetection();
+                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
+                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
+                            scanData.scanRecord)) {
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
+                    }
+                }
                 trackedBeaconsPacketCount++;
                 processBeaconFromScan(beacon);
             } else {
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index 193c1386..9d239c95 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -66,13 +66,22 @@ public boolean call(Context context, String dataName, Bundle data) {
         if(mIntent == null){
             initializeIntent();
         }
+        boolean success = false;
         if (mIntent != null) {
             LogManager.d(TAG, "attempting callback via intent: %s", mIntent.getComponent());
             mIntent.putExtra(dataName, data);
-            context.startService(mIntent);
-            return true;
+            try {
+                context.startService(mIntent);
+                success = true;
+            } catch (Exception e) {
+                LogManager.e(
+                        TAG,
+                        "Failed attempting to start service: " + mIntent.getComponent().flattenToString(),
+                        e
+                );
+            }
         }
-        return false;
+        return success;
     }
 
     @SuppressWarnings("unused")
diff --git a/src/main/java/org/altbeacon/beacon/service/DataSerializer.java b/src/main/java/org/altbeacon/beacon/service/DataSerializer.java
deleted file mode 100644
index b00bce35..00000000
--- a/src/main/java/org/altbeacon/beacon/service/DataSerializer.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.altbeacon.beacon.service;
-
-import org.altbeacon.beacon.Beacon;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collection;
-
-/**
- * Created by dyoung on 3/10/17.
- */
-
-public class DataSerializer {
-    /*
-    public Serializable getSerializableRegion(Region region) {
-        return new SerializableRegion(region);
-    }
-
-    public Serializable getSerializableBeacon(Beacon beacon) {
-        return new SerializableBeacon(beacon);
-    }
-    */
-
-    public Serializable getSerializableBeaconList(Collection<Beacon> beacons) {
-        ArrayList<Serializable> serializableBeacons = new ArrayList<Serializable>();
-        for (Beacon beacon : beacons) {
-            serializableBeacons.add(beacon);
-        }
-        return serializableBeacons;
-    }
-
-    /*
-    private class SerializableBeacon extends Beacon implements Serializable {
-        public SerializableBeacon(Beacon beacon)  {
-            super(beacon);
-        }
-    }
-
-    private class SerializableRegion extends Region implements Serializable {
-        public SerializableRegion(Region region)  {
-            super(region);
-        }
-    }
-    */
-
-}
diff --git a/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java b/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
index 2c5dc5c1..3797d241 100644
--- a/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/DetectionTracker.java
@@ -6,16 +6,14 @@
  * Created by dyoung on 1/10/15.
  */
 public class DetectionTracker {
-    private static DetectionTracker sDetectionTracker = null;
+    private static final DetectionTracker INSTANCE = new DetectionTracker();
+
     private long mLastDetectionTime = 0l;
     private DetectionTracker() {
 
     }
-    public static synchronized DetectionTracker getInstance() {
-        if (sDetectionTracker == null) {
-            sDetectionTracker  = new DetectionTracker();
-        }
-        return sDetectionTracker;
+    public static DetectionTracker getInstance() {
+        return INSTANCE;
     }
     public long getLastDetectionTime() {
         return mLastDetectionTime;
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index a311fba3..164cd3e6 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 
 import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.MonitorNotifier;
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -23,7 +24,7 @@
 import static android.content.Context.MODE_PRIVATE;
 
 public class MonitoringStatus {
-    private static MonitoringStatus sInstance;
+    private static volatile MonitoringStatus sInstance;
     private static final int MAX_REGIONS_FOR_STATUS_PRESERVATION = 50;
     private static final int MAX_STATUS_PRESERVATION_FILE_AGE_TO_RESTORE_SECS = 60 * 15;
     private static final String TAG = MonitoringStatus.class.getSimpleName();
@@ -35,15 +36,35 @@
 
     private boolean mStatePreservationIsOn = true;
 
+    /**
+     * Private lock object for singleton initialization protecting against denial-of-service attack.
+     */
+    private static final Object SINGLETON_LOCK = new Object();
+
     public static MonitoringStatus getInstanceForApplication(Context context) {
-        if (sInstance == null) {
-            synchronized (MonitoringStatus.class) {
-                if (sInstance == null) {
-                    sInstance = new MonitoringStatus(context.getApplicationContext());
+        /*
+         * Follow double check pattern from Effective Java v2 Item 71.
+         *
+         * Bloch recommends using the local variable for this for performance reasons:
+         *
+         * > What this variable does is ensure that `field` is read only once in the common case
+         * > where it's already initialized. While not strictly necessary, this may improve
+         * > performance and is more elegant by the standards applied to low-level concurrent
+         * > programming. On my machine, [this] is about 25 percent faster than the obvious
+         * > version without a local variable.
+         *
+         * Joshua Bloch. Effective Java, Second Edition. Addison-Wesley, 2008. pages 283-284
+         */
+        MonitoringStatus instance = sInstance;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = sInstance;
+                if (instance == null) {
+                    sInstance = instance = new MonitoringStatus(context.getApplicationContext());
                 }
             }
         }
-        return sInstance;
+        return instance;
     }
 
     public MonitoringStatus(Context context) {
@@ -51,31 +72,12 @@ public MonitoringStatus(Context context) {
     }
 
     public synchronized void addRegion(Region region, Callback callback) {
-        if (getRegionsStateMap().containsKey(region)) {
-            // if the region definition hasn't changed, becasue if it has, we need to clear state
-            // otherwise a region with the same uniqueId can never be changed
-            for (Region existingRegion : getRegionsStateMap().keySet()) {
-                if (existingRegion.equals(region)) {
-                    if (existingRegion.hasSameIdentifiers(region)) {
-                        return;
-                    }
-                    else {
-                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
-                        LogManager.d(TAG, "Old definition: "+existingRegion);
-                        LogManager.d(TAG, "New definition: "+region);
-                        LogManager.d(TAG, "clearing state");
-                        getRegionsStateMap().remove(region);
-                        break;
-                    }
-                }
-            }
-        }
-        getRegionsStateMap().put(region, new RegionMonitoringState(callback));
+        addLocalRegion(region, callback);
         saveMonitoringStatusIfOn();
     }
 
     public synchronized void removeRegion(Region region) {
-        getRegionsStateMap().remove(region);
+        removeLocalRegion(region);
         saveMonitoringStatusIfOn();
     }
 
@@ -279,4 +281,53 @@ public synchronized void clear() {
         mContext.deleteFile(STATUS_PRESERVATION_FILE_NAME);
         getRegionsStateMap().clear();
     }
+
+    public void updateLocalState(Region region, Integer state) {
+        RegionMonitoringState internalState = getRegionsStateMap().get(region);
+        if (internalState == null) {
+            internalState = addLocalRegion(region);
+        }
+        if (state != null) {
+            if (state == MonitorNotifier.OUTSIDE) {
+                internalState.markOutside();
+
+            }
+            if (state == MonitorNotifier.INSIDE) {
+                internalState.markInside();
+            }
+        }
+    }
+
+    public void removeLocalRegion(Region region) {
+        getRegionsStateMap().remove(region);
+    }
+    public RegionMonitoringState addLocalRegion(Region region){
+        Callback dummyCallback = new Callback(null);
+        return addLocalRegion(region, dummyCallback);
+    }
+
+    private RegionMonitoringState addLocalRegion(Region region, Callback callback){
+        if (getRegionsStateMap().containsKey(region)) {
+            // if the region definition hasn't changed, becasue if it has, we need to clear state
+            // otherwise a region with the same uniqueId can never be changed
+            for (Region existingRegion : getRegionsStateMap().keySet()) {
+                if (existingRegion.equals(region)) {
+                    if (existingRegion.hasSameIdentifiers(region)) {
+                        return getRegionsStateMap().get(existingRegion);
+                    }
+                    else {
+                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
+                        LogManager.d(TAG, "Old definition: "+existingRegion);
+                        LogManager.d(TAG, "New definition: "+region);
+                        LogManager.d(TAG, "clearing state");
+                        getRegionsStateMap().remove(region);
+                        break;
+                    }
+                }
+            }
+        }
+        RegionMonitoringState monitoringState = new RegionMonitoringState(callback);
+        getRegionsStateMap().put(region, monitoringState);
+        return monitoringState;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index 99bb25ce..b57f5faf 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -6,7 +6,6 @@
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
-import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
@@ -46,13 +45,11 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-
         RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
-
-        if (!getFilter().noMeasurementsAvailable()) {
-            double runningAverage = getFilter().calculateRssi();
-            mBeacon.setRunningAverageRssi(runningAverage);
-            LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
+         if (!getFilter().noMeasurementsAvailable()) {
+             double runningAverage = getFilter().calculateRssi();
+             mBeacon.setRunningAverageRssi(runningAverage);
+             LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
         else {
             LogManager.d(TAG, "No measurements available to calculate running average");
@@ -67,19 +64,6 @@ public void addMeasurement(Integer rssi) {
             lastTrackedTimeMillis = SystemClock.elapsedRealtime();
             getFilter().addMeasurement(rssi);
         }
-    }
-
-    private RssiFilter getFilter() {
-        if (mFilter == null) {
-            //set RSSI filter
-            try {
-                Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
-                mFilter = (RssiFilter)cons.newInstance();
-            } catch (Exception e) {
-                LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
-            }
-
-        }
         return mFilter;
     }
 
@@ -104,4 +88,17 @@ public boolean isExpired() {
         return getTrackingAge() > maxTrackingAge;
     }
 
+    private RssiFilter getFilter() {
+        if (mFilter == null) {
+            //set RSSI filter
+            try {
+            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
+                mFilter = (RssiFilter)cons.newInstance();
+            } catch (Exception e) {
+                LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
+            }
+        }
+        return mFilter;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangingData.java b/src/main/java/org/altbeacon/beacon/service/RangingData.java
index 79e47240..d7bb44ff 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -23,6 +23,8 @@
  */
 package org.altbeacon.beacon.service;
 
+import java.io.Serializable;
+import java.util.ArrayList;
 import java.util.Collection;
 
 import org.altbeacon.beacon.Beacon;
@@ -30,6 +32,10 @@
 
 import android.os.Bundle;
 
+/**
+ * Internal class used to transfer ranging data between the BeaconService and the client
+ * @hide
+ */
 public class RangingData {
     private static final String TAG = "RangingData";
     private final Collection<Beacon> mBeacons;
@@ -54,7 +60,11 @@ public Region getRegion() {
     public Bundle toBundle() {
         Bundle bundle = new Bundle();
         bundle.putSerializable(REGION_KEY, mRegion);
-        bundle.putSerializable(BEACONS_KEY, new DataSerializer().getSerializableBeaconList(mBeacons));
+        ArrayList<Serializable> serializableBeacons = new ArrayList<Serializable>();
+        for (Beacon beacon : mBeacons) {
+            serializableBeacons.add(beacon);
+        }
+        bundle.putSerializable(BEACONS_KEY, serializableBeacons);
 
         return bundle;
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java b/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
index 0f9cd1ee..d7b36fb3 100644
--- a/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
@@ -54,15 +54,19 @@ public boolean markInside() {
         return false;
     }
 
+    public void markOutside() {
+        inside = false;
+        lastSeenTime = 0l;
+    }
+
     public boolean markOutsideIfExpired() {
         if (inside) {
             if (lastSeenTime > 0 && SystemClock.elapsedRealtime() - lastSeenTime > BeaconManager.getRegionExitPeriod()) {
-                inside = false;
                 LogManager.d(TAG, "We are newly outside the region because the lastSeenTime of %s "
                                 + "was %s seconds ago, and that is over the expiration duration "
                                 + "of %s", lastSeenTime, SystemClock.elapsedRealtime() - lastSeenTime,
                         BeaconManager.getRegionExitPeriod());
-                lastSeenTime = 0l;
+                markOutside();
                 return true;
             }
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
index a36e1fe4..9aa95ea1 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJob.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -5,162 +5,195 @@
 import android.app.job.JobParameters;
 import android.app.job.JobScheduler;
 import android.app.job.JobService;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothManager;
-import android.bluetooth.le.BluetoothLeScanner;
-import android.bluetooth.le.ScanCallback;
-import android.bluetooth.le.ScanResult;
+import android.bluetooth.BluetoothDevice;
 import android.content.ComponentName;
 import android.content.Context;
+import android.content.pm.ApplicationInfo;
 import android.os.AsyncTask;
 import android.os.Build;
-import android.os.ParcelUuid;
+import android.os.Handler;
 import android.os.PersistableBundle;
+import android.os.SystemClock;
 
+import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.BuildConfig;
 import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
-
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+import org.altbeacon.beacon.utils.ProcessUtils;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
 
 /**
  * Created by dyoung on 3/24/17.
  */
 
+/**
+ * Only one instance of this will be active, even with multiple jobIds.  If one job
+ * is already running when another is scheduled to start, onStartJob gets called again on the same
+ * instance.
+ *
+ * If the OS decides to create a new instance, it will call onStopJob() on the old instance
+ */
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
 public class ScanJob extends JobService {
     private static final String TAG = ScanJob.class.getSimpleName();
-    private ScanDataProcessor mScanDataProcessor;
     private ScanState mScanState;
-    private ExecutorService mExecutor;
-    private BluetoothLeScanner mBluetoothLeScanner;
-    private BluetoothAdapter mBluetoothAdapter;
-    private BluetoothLeScanner mScanner;
-    private int mPacketsDetected;
-    private int mPacketsProcessed;
+    private Handler mStopHandler = new Handler();
 
+    // Fields to be refactord to a shared class with BeaconService
+    private ExecutorService mExecutor;
+    private BeaconManager mBeaconManager;
+    private CycledLeScanner mCycledScanner;
+    private MonitoringStatus mMonitoringStatus;
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
+    private List<Beacon> mSimulatedScanData = null;  // not supported for scan jobs
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private boolean mInitialized = false;
 
     @Override
-    public boolean onStartJob(JobParameters jobParameters) {
-        // TODO: deserializing and serializing scanState every 1 second is pretty heavy weight
-        // There should be a way of running this longer if in the foreground to cut down on this.
-        // Also consider using jobParameters instead of persisting to disk in ScanState, however
-        // Since the job state may be changed externally by a client app, we would need to
-        // update the schedule job each time this is done.
-        // TODO: this deserialization should not be on the main thread.
-        LogManager.i(TAG, "Running scan job");
+    public boolean onStartJob(final JobParameters jobParameters) {
+        JobScheduler jobScheduler = (JobScheduler) this.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        if (jobParameters.getJobId() == sPeriodicScanJobId) {
+            LogManager.i(TAG, "Running periodic scan job: instance is "+this);
+        }
+        else {
+            LogManager.i(TAG, "Running immediate scan job: instance is "+this);
+        }
         mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
-        new JobTask(this).executeOnExecutor(mExecutor, jobParameters);
+        boolean startedScan = false;
+        if (mInitialized) {
+            LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
+            startedScan = restartScanning();
+        }
+        else {
+            startedScan = startScanning();
+        }
+        mStopHandler.removeCallbacksAndMessages(null);
+
+        if (startedScan) {
+            LogManager.i(TAG, "Scan job running for "+mScanState.getScanJobRuntimeMillis()+" millis");
+            mStopHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    LogManager.i(TAG, "Scan job runtime expired");
+                    stopScanning();
+                    mScanState.save();
+                    ScanJob.this.jobFinished(jobParameters , false);
+                }
+            }, mScanState.getScanJobRuntimeMillis());
+        }
+        else {
+            LogManager.i(TAG, "No monitored or ranged regions. Scan job complete.");
+            ScanJob.this.jobFinished(jobParameters , false);
+        }
         return true;
     }
 
     @Override
     public boolean onStopJob(JobParameters params) {
+        if (params.getJobId() == sPeriodicScanJobId) {
+            LogManager.i(TAG, "onStopJob called for periodic scan");
+        }
+        else {
+            LogManager.i(TAG, "onStopJob called for immediate scan");
+        }
+        // Cancel the stop timer.  The OS is stopping prematurely
+        mStopHandler.removeCallbacksAndMessages(null);
+        stopScanning();
         return false;
     }
 
-
-    private class JobTask extends AsyncTask<JobParameters, Void, JobParameters> {
-        private JobService mJobService;
-
-        public JobTask(JobService jobService) {
-            this.mJobService = jobService;
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean restartScanning() {
+        mScanState = ScanState.restore(ScanJob.this);
+        mScanState.setLastScanStartTimeMillis(System.currentTimeMillis());
+        mMonitoringStatus = mScanState.getMonitoringStatus();
+        mRangedRegionState = mScanState.getRangedRegionState();
+        mBeaconParsers = mScanState.getBeaconParsers();
+        mExtraDataBeaconTracker = mScanState.getExtraBeaconDataTracker();
+        if (mCycledScanner == null) {
+            mCycledScanner = CycledLeScanner.createScanner(ScanJob.this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
+                    BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mScanState.getBackgroundMode(), mCycledLeScanCallback, null);
         }
-
-        @Override
-        protected JobParameters doInBackground(JobParameters... params) {
-            mScanState = ScanState.restore(ScanJob.this);
-            mScanDataProcessor = new ScanDataProcessor(ScanJob.this, mScanState);
-            // TODO: set up filters
-            mPacketsDetected = 0;
-            mPacketsProcessed = 0;
-            BluetoothLeScanner scanner = getScanner();
-            if (getScanner() != null) {
-                LogManager.d(TAG, "Starting scan cycle");
-                getScanner().startScan(mLeScanCallback);
-                try {
-                    Thread.sleep(mScanState.getBackgroundScanPeriod());
-                } catch (InterruptedException e) {
-                    e.printStackTrace();
-                }
-                if (mPacketsProcessed < mPacketsDetected) {
-                    LogManager.d(TAG, "Waiting to finish processing packets.  "+mPacketsProcessed+" of "+mPacketsDetected+" complete");
-                    try {
-                        Thread.sleep(20l);
-                    } catch (InterruptedException e) {
-                        e.printStackTrace();
-                    }
-                }
-                LogManager.d(TAG, "Stopping scan cycle");
-                scanner.stopScan(mLeScanCallback);
-                mScanState.save();
-                mScanDataProcessor.onCycleEnd();
-            }
-            else {
-                LogManager.d(TAG, "Cannot get scanner.");
-            }
-            // TODO: the saving here may conflict with changes made by the manager while the scan
-            // Remember the settings timestamp, and only save if the file is unchanged.  This would
-            // Discard the last scan results if  the scan settings changed while in this process.
-            // Alternately, figure out a way to merge the two copies.
-            return params[0];
+        mCycledScanner.setScanPeriods(mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod(),
+                                      mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod(),
+                                      mScanState.getBackgroundMode());
+        if (mRangedRegionState.size() > 0 || mMonitoringStatus.regions().size() > 0) {
+            mCycledScanner.start();
+            return true;
         }
-
-        @Override
-        protected void onPostExecute(JobParameters jobParameters) {
-            LogManager.i(TAG, "Finished scan job");
-            mJobService.jobFinished(jobParameters, false);
+        else {
+            mCycledScanner.stop();
+            return false;
         }
     }
 
-    private class ProcessScanResultTask extends AsyncTask<ScanResult, Void, Void> {
-
-        public ProcessScanResultTask() {
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean startScanning() {
+        // Create a private executor so we don't compete with threads used by AsyncTask
+        // This uses fewer threads than the default executor so it won't hog CPU
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
+        mBeaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        mBeaconManager.setScannerInSameProcess(true);
+        if (mBeaconManager.isMainProcess()) {
+            LogManager.i(TAG, "scanJob version %s is starting up on the main process", BuildConfig.VERSION_NAME);
         }
-
-        @Override
-        protected Void doInBackground(ScanResult... scanResult) {
-            mScanDataProcessor.process(scanResult[0]);
-            mPacketsProcessed += 1;
-            return null;
+        else {
+            LogManager.i(TAG, "beaconScanJob library version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(ScanJob.this);
+            LogManager.i(TAG, "beaconScanJob PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
         }
+        ModelSpecificDistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(ScanJob.this, BeaconManager.getDistanceModelUpdateUrl());
+        Beacon.setDistanceCalculator(defaultDistanceCalculator);
+        return restartScanning();
+    }
 
-        @Override
-        protected void onPostExecute(Void params) {
-        }
+    private void stopScanning() {
+        mCycledScanner.stop();
+        mCycledScanner.destroy();
+        mInitialized = false;
+        LogManager.d(TAG, "Scanning stopped");
     }
 
 
     //TODO: Move this and the static methods below to its own utility class
 
-    private static int sJobId = 9826351; // TODO: make this configurable
+    /*
+        Periodic scan jobs are used in general, but they cannot be started immediately.  So we have
+        a second immediate scan job to kick off when scanning gets started or settings changed.
+        Once the periodic one gets run, the immediate is cancelled.
+     */
+    private static int sImmediateScanJobId = 1; // TODO: make this configurable
+    private static int sPeriodicScanJobId = 2; // TODO: make this configurable
 
-    public static void startMonitoring(Context context, BeaconManager beaconManager, Region region) {
-        ScanState scanState = ScanState.restore(context);
-        scanState.getMonitoringStatus().addRegion(region, new Callback(context.getPackageName()));
-        applySettingsToScheduledJob(context, beaconManager, scanState);
-    }
-    public static void stopMonitoring(Context context, BeaconManager beaconManager, Region region) {
-        ScanState scanState = ScanState.restore(context);
-        scanState.getMonitoringStatus().removeRegion(region);
-        applySettingsToScheduledJob(context, beaconManager, scanState);
-    }
     public static void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
         scanState.applyChanges(beaconManager);
-
-        int periodMillis = (int) (beaconManager.getBackgroundMode() ?
-                beaconManager.getBackgroundScanPeriod()+beaconManager.getBackgroundBetweenScanPeriod() :
-                beaconManager.getForegroundScanPeriod()+beaconManager.getForegroundBetweenScanPeriod());
-
-        schedule(context, sJobId, new PersistableBundle(), periodMillis);
+        LogManager.d(TAG, "Applying scan job settings with background mode "+scanState.getBackgroundMode());
+        schedule(context, scanState);
     }
 
     public static void applySettingsToScheduledJob(Context context, BeaconManager beaconManager) {
         LogManager.d(TAG, "Applying settings to ScanJob");
         JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
-        jobScheduler.cancel(sJobId);
         ScanState scanState = ScanState.restore(context);
         applySettingsToScheduledJob(context, beaconManager, scanState);
     }
@@ -168,103 +201,269 @@ public static void applySettingsToScheduledJob(Context context, BeaconManager be
      *
      * @param context
      */
-    public static void schedule(Context context, Integer jobId, PersistableBundle scanJobSettings, int periodMillis) {
-        LogManager.d(TAG, "Scheduling ScanJob");
-        JobInfo job = new JobInfo.Builder(jobId, new ComponentName(context, ScanJob.class))
-                .setPersisted(true) // This makes it restart after reboot
-                .setExtras(scanJobSettings)
-                .setPeriodic(periodMillis)
-                .build();
+    public static void schedule(Context context, ScanState scanState) {
+        long betweenScanPeriod = scanState.getScanJobIntervalMillis() - scanState.getScanJobRuntimeMillis();
+
+        long millisToNextJobStart = scanState.getScanJobIntervalMillis();
+        if (betweenScanPeriod > 0) {
+            // If we pause between scans, then we need to start scanning on a normalized time
+            millisToNextJobStart = (SystemClock.elapsedRealtime() % scanState.getScanJobIntervalMillis());
+        }
+        else {
+            millisToNextJobStart = 0;
+        }
+
+        if (millisToNextJobStart < 50) {
+            // always wait a little bit to start scanning in case settings keep changing.
+            // by user restarting settings and scanning.  50ms should be fine
+            millisToNextJobStart = 50;
+        }
 
         JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
-        int error = jobScheduler.schedule(job);
+
+        if (scanState.getBackgroundMode()) {
+            LogManager.d(TAG, "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
+            jobScheduler.cancel(sImmediateScanJobId);
+        }
+        else {
+            // If we are in the foreground, and we want to start a scan soon, we will schedule an
+            // immediat job
+            if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
+                // If the next time we want to scan is less than 50ms from the periodic scan cycle, then]
+                // we schedule it for that specific time.
+                LogManager.d(TAG, "Scheduling immediate ScanJob to run in "+millisToNextJobStart+" millis");
+                JobInfo immediateJob = new JobInfo.Builder(sImmediateScanJobId, new ComponentName(context, ScanJob.class))
+                        .setPersisted(true) // This makes it restart after reboot
+                        .setExtras(new PersistableBundle())
+                        .setMinimumLatency(millisToNextJobStart)
+                        .setOverrideDeadline(millisToNextJobStart).build();
+                int error = jobScheduler.schedule(immediateJob);
+                if (error < 0) {
+                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+                }
+            }
+        }
+
+        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(sPeriodicScanJobId, new ComponentName(context, ScanJob.class))
+                .setPersisted(true) // This makes it restart after reboot
+                .setExtras(new PersistableBundle());
+
+        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            // ON Android N+ we specify a tolerance of 0ms (capped at 5% by the OS) to ensure
+            // our scans happen within 5% of the schduled time.
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0l).build();
+        }
+        else {
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis()).build();
+        }
+
+        LogManager.d(TAG, "Scheduling ScanJob to run every "+scanState.getScanJobIntervalMillis()+" millis");
+        int error = jobScheduler.schedule(periodicJobBuilder.build());
         if (error < 0) {
             LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
         }
     }
 
-    private boolean isBluetoothOn() {
-        try {
-            BluetoothAdapter bluetoothAdapter = getBluetoothAdapter();
-            if (bluetoothAdapter != null) {
-                return (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON);
+  // ***********************
+  // Code below here copied from BeaconService -- refactor to a common class
+
+
+    protected void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
+        //flatMap all beacon parsers
+        boolean matchBeaconsByServiceUUID = true;
+        if (mBeaconManager.getBeaconParsers() != null) {
+            newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
+            for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
+                if (beaconParser.getExtraDataParsers().size() > 0) {
+                    matchBeaconsByServiceUUID = false;
+                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
+                }
             }
-            LogManager.w(TAG, "Cannot get bluetooth adapter");
-        }
-        catch (SecurityException e) {
-            LogManager.w(TAG, "SecurityException checking if bluetooth is on");
         }
-        return false;
+        mBeaconParsers = newBeaconParsers;
+        //initialize the extra data beacon tracker
+        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
     }
+    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+        @Override
+        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
 
-    private BluetoothLeScanner getScanner() {
-        try {
-            if (mScanner == null) {
-                LogManager.d(TAG, "Making new Android L scanner");
-                BluetoothAdapter bluetoothAdapter = getBluetoothAdapter();
-                if (bluetoothAdapter != null) {
-                    mScanner = getBluetoothAdapter().getBluetoothLeScanner();
+            NonBeaconLeScanCallback nonBeaconLeScanCallback = mBeaconManager.getNonBeaconLeScanCallback();
+
+            try {
+                new ScanJob.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
+                        new ScanJob.ScanData(device, rssi, scanRecord));
+            } catch (RejectedExecutionException e) {
+                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+            }
+        }
+
+        @Override
+        public void onCycleEnd() {
+            mDistinctPacketDetector.clearDetections();
+            mMonitoringStatus.updateNewlyOutside();
+            processRangeData();
+            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
+            if (mSimulatedScanData != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
+
+                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : mSimulatedScanData) {
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
                 }
-                if (mScanner == null) {
-                    LogManager.w(TAG, "Failed to make new Android L scanner");
+            }
+            if (BeaconManager.getBeaconSimulator() != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                            processBeaconFromScan(beacon);
+                        }
+                    } else {
+                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                    }
+                } else {
+                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
                 }
             }
         }
-        catch (SecurityException e) {
-            LogManager.w(TAG, "SecurityException making new Android L scanner");
+    };
+
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                rangeState.getCallback().call(ScanJob.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
         }
-        return mScanner;
     }
 
-    ScanCallback mLeScanCallback = new ScanCallback() {
+    private void processBeaconFromScan(Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
 
-                @Override
-                public void onScanResult(int callbackType, ScanResult scanResult) {
-                    if (LogManager.isVerboseLoggingEnabled()) {
-                        LogManager.d(TAG, "got record");
-                        List<ParcelUuid> uuids = scanResult.getScanRecord().getServiceUuids();
-                        if (uuids != null) {
-                            for (ParcelUuid uuid : uuids) {
-                                LogManager.d(TAG, "with service uuid: "+uuid);
-                            }
-                        }
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions = null;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
                     }
-                    mPacketsDetected += 1;
-                    new ProcessScanResultTask().executeOnExecutor(mExecutor, scanResult);
                 }
+            }
+        }
+    }
 
-                @Override
-                public void onBatchScanResults(List<ScanResult> results) {
-                    LogManager.d(TAG, "got batch records");
-                    for (ScanResult scanResult : results) {
-                        mPacketsDetected += 1;
-                        new ProcessScanResultTask().executeOnExecutor(mExecutor, scanResult);
-                    }
-                }
 
-                @Override
-                public void onScanFailed(int i) {
-                    LogManager.e(TAG, "Scan Failed");
+    private class ScanData {
+        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        int rssi;
+        BluetoothDevice device;
+        byte[] scanRecord;
+    }
+
+    private class ScanProcessor extends AsyncTask<ScanJob.ScanData, Void, Void> {
+        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
+            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
+        }
+
+        @Override
+        protected Void doInBackground(ScanJob.ScanData... params) {
+            ScanJob.ScanData scanData = params[0];
+            Beacon beacon = null;
+
+            for (BeaconParser parser : ScanJob.this.mBeaconParsers) {
+                beacon = parser.fromScanData(scanData.scanRecord,
+                        scanData.rssi, scanData.device);
+
+                if (beacon != null) {
+                    break;
                 }
-            };
-
-
-    protected BluetoothAdapter getBluetoothAdapter() {
-        try {
-            if (mBluetoothAdapter == null) {
-                // Initializes Bluetooth adapter.
-                final BluetoothManager bluetoothManager =
-                        (BluetoothManager) ScanJob.this.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
-                mBluetoothAdapter = bluetoothManager.getAdapter();
-                if (mBluetoothAdapter == null) {
-                    LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            }
+            if (beacon != null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                }
+                mDetectionTracker.recordDetection();
+                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
+                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
+                            scanData.scanRecord)) {
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
+                    }
+                }
+                processBeaconFromScan(beacon);
+            } else {
+                if (mNonBeaconLeScanCallback != null) {
+                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
                 }
             }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+        }
+
+        @Override
+        protected void onPreExecute() {
+        }
+
+        @Override
+        protected void onProgressUpdate(Void... values) {
         }
-        catch (SecurityException e) {
-            // Thrown by Samsung Knox devices if bluetooth access denied for an app
-            LogManager.e(TAG, "Cannot consruct bluetooth adapter.  Security Exception");
+    }
+
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<Region>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
         }
-        return mBluetoothAdapter;
+        return matched;
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanState.java b/src/main/java/org/altbeacon/beacon/service/ScanState.java
index 3eaaf47c..25f8264a 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanState.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanState.java
@@ -24,12 +24,16 @@
 import static android.content.Context.MODE_PRIVATE;
 
 /**
+ * Stores the full state of scanning for the libary, including all settings so it can be ressurrected easily
+ * for running from a scheduled job
+ *
  * Created by dyoung on 3/26/17.
  */
 
 public class ScanState implements Serializable {
     private static final String TAG = ScanState.class.getSimpleName();
     private static final String STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state";
+    public static int MIN_SCAN_JOB_INTERVAL_MILLIS = 300000; //  5 minutes
 
     private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
     private transient MonitoringStatus mMonitoringStatus;
@@ -40,6 +44,7 @@
     private long mForegroundScanPeriod;
     private long mBackgroundScanPeriod;
     private boolean mBackgroundMode;
+    private long mLastScanStartTimeMillis = 0l;
     private transient Context mContext;
 
     public Boolean getBackgroundMode() {
@@ -118,6 +123,13 @@ public void setBeaconParsers(Set<BeaconParser> beaconParsers) {
         mBeaconParsers = beaconParsers;
     }
 
+    public long getLastScanStartTimeMillis() {
+        return mLastScanStartTimeMillis;
+    }
+    public void setLastScanStartTimeMillis(long time) {
+        mLastScanStartTimeMillis = time;
+    }
+
     public static ScanState restore(Context context) {
         ScanState scanState = null;
         synchronized (ScanState.class) {
@@ -156,7 +168,6 @@ public static ScanState restore(Context context) {
                 scanState = new ScanState(context);
 
             }
-            // TODO: this should not be necessary.
             if (scanState.mExtraBeaconDataTracker == null) {
                 scanState.mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
             }
@@ -198,6 +209,41 @@ public void save() {
         }
     }
 
+    public int getScanJobIntervalMillis() {
+        long cyclePeriodMillis;
+        if (getBackgroundMode()) {
+            cyclePeriodMillis = getBackgroundScanPeriod()+getBackgroundBetweenScanPeriod();
+        }
+        else {
+            cyclePeriodMillis = getForegroundScanPeriod()+getForegroundBetweenScanPeriod();
+        }
+        int scanJobIntervalMillis = MIN_SCAN_JOB_INTERVAL_MILLIS;
+        if (cyclePeriodMillis > MIN_SCAN_JOB_INTERVAL_MILLIS) {
+            scanJobIntervalMillis = (int) cyclePeriodMillis;
+        }
+        return scanJobIntervalMillis;
+    }
+
+    public int getScanJobRuntimeMillis() {
+        long scanPeriodMillis;
+        LogManager.d(TAG, "ScanState says background mode for ScanJob is "+getBackgroundMode());
+        if (getBackgroundMode()) {
+            scanPeriodMillis = getBackgroundScanPeriod();
+        }
+        else {
+            scanPeriodMillis = getForegroundScanPeriod();
+        }
+        if (!getBackgroundMode()) {
+            // if we are in the foreground, we keep the scan job going for the minimum interval
+            if (scanPeriodMillis < MIN_SCAN_JOB_INTERVAL_MILLIS) {
+                return MIN_SCAN_JOB_INTERVAL_MILLIS;
+            }
+        }
+        return (int) scanPeriodMillis;
+    }
+
+
+
     public void applyChanges(BeaconManager beaconManager) {
         mBeaconParsers = new HashSet<>(beaconManager.getBeaconParsers());
         mForegroundScanPeriod = beaconManager.getForegroundScanPeriod();
@@ -219,7 +265,6 @@ public void applyChanges(BeaconManager beaconManager) {
                 mRangedRegionState.put(newRangedRegion, new RangeState(new Callback(mContext.getPackageName())));
             }
         }
-
         for (Region existingRangedRegion: existingRangedRegions) {
             if (!newRangedRegions.contains(existingRangedRegion)) {
                 LogManager.d(TAG, "Stopping ranging region: "+existingRangedRegion);
@@ -231,5 +276,4 @@ public void applyChanges(BeaconManager beaconManager) {
         this.save();
     }
 
-}
-
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/beacon/service/SettingsData.java b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
index a5cd5e48..d1202336 100644
--- a/src/main/java/org/altbeacon/beacon/service/SettingsData.java
+++ b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
@@ -1,8 +1,8 @@
 package org.altbeacon.beacon.service;
 
-import android.app.Service;
 import android.content.Context;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -16,8 +16,11 @@
 
 /**
  * Created by dyoung on 3/10/17.
+ *
+ * Internal class used to transfer settings between the BeaconService and the client
+ *
+ * @hide
  */
-
 public class SettingsData implements Serializable {
     private static final String TAG = SettingsData.class.getSimpleName();
     private static final String SETTINGS_DATA_KEY = "SettingsData";
@@ -29,21 +32,18 @@
     Boolean mHardwareEqualityEnforced;
 
     // The following configuration settings are not implemented here, so they cannot be set when
-    // the scanning service is running in anothr process
-    //   beaconSimulator *
-    //   rssiFilterImplClass *
-    //   distanceCalculator *
-    //   logger *
-    //   verboseLoggingEnabled *
-    //   mNonBeaconLeScanCallback *
-    //   manifestCheckingDisabled (no point in synchronizing this one... only used at startup)
+    // the scanning service is running in another process
+    //        BeaconManager.setDistanceModelUpdateUrl(...)
+    //        BeaconManager.setRssiFilterImplClass(...)
+    //        BeaconManager.setBeaconSimulator(...)
+    //        beaconManager.setNonBeaconLeScanCallback(...)
 
     public Bundle toBundle() {
         Bundle bundle = new Bundle();
         bundle.putSerializable(SETTINGS_DATA_KEY, this);
         return bundle;
     }
-    public static SettingsData fromBundle(Bundle bundle) {
+    public static SettingsData fromBundle(@NonNull Bundle bundle) {
         bundle.setClassLoader(Region.class.getClassLoader());
         SettingsData settingsData = null;
         if (bundle.get(SETTINGS_DATA_KEY) != null) {
@@ -52,7 +52,7 @@ public static SettingsData fromBundle(Bundle bundle) {
         return settingsData;
     }
 
-    public void apply(BeaconService scanService) {
+    public void apply(@NonNull BeaconService scanService) {
         LogManager.d(TAG, "Applying settings changes to scanner in other process");
         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(scanService);
         List<BeaconParser> beaconParsers = beaconManager.getBeaconParsers();
@@ -79,14 +79,22 @@ public void apply(BeaconService scanService) {
         else {
             LogManager.d(TAG, "Beacon parsers unchanged.");
         }
-        beaconManager.setRegionStatePersistenceEnabled(mRegionStatePersistenceEnabled);
+        MonitoringStatus monitoringStatus = MonitoringStatus.getInstanceForApplication(scanService);
+        if (monitoringStatus.isStatePreservationOn() &&
+                !mRegionStatePersistenceEnabled) {
+            monitoringStatus.stopStatusPreservation();
+        }
+        else if (!monitoringStatus.isStatePreservationOn() &&
+                mRegionStatePersistenceEnabled) {
+            monitoringStatus.startStatusPreservation();
+        }
         beaconManager.setAndroidLScanningDisabled(mAndroidLScanningDisabled);
         BeaconManager.setRegionExitPeriod(mRegionExitPeriod);
         RangeState.setUseTrackingCache(mUseTrackingCache);
         Beacon.setHardwareEqualityEnforced(mHardwareEqualityEnforced);
     }
 
-    public SettingsData collect(Context context) {
+    public SettingsData collect(@NonNull Context context) {
         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context);
         mBeaconParsers = new ArrayList<>(beaconManager.getBeaconParsers());
         mRegionStatePersistenceEnabled = beaconManager.isRegionStatePersistenceEnabled();
diff --git a/src/main/java/org/altbeacon/beacon/service/StartRMData.java b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
index ab7a58f5..1fa8a6d6 100644
--- a/src/main/java/org/altbeacon/beacon/service/StartRMData.java
+++ b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
@@ -26,11 +26,18 @@
 import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.support.annotation.NonNull;
 
 import org.altbeacon.beacon.Region;
 
 import java.io.Serializable;
 
+/**
+ *
+ * Internal class used to transfer ranging and monitoring data between the BeaconService and client
+ *
+ * @hide
+ */
 public class StartRMData implements Serializable, Parcelable {
     private static final String SCAN_PERIOD_KEY = "scanPeriod";
     private static final String BETWEEN_SCAN_PERIOD_KEY = "betweenScanPeriod";
@@ -47,7 +54,7 @@
     private StartRMData() {
     }
 
-    public StartRMData(Region region, String callbackPackageName) {
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName) {
         this.mRegion = region;
         this.mCallbackPackageName = callbackPackageName;
     }
@@ -57,7 +64,7 @@ public StartRMData(long scanPeriod, long betweenScanPeriod, boolean backgroundFl
         this.mBackgroundFlag = backgroundFlag;
     }
 
-    public StartRMData(Region region, String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
         this.mScanPeriod = scanPeriod;
         this.mBetweenScanPeriod = betweenScanPeriod;
         this.mRegion = region;
@@ -118,7 +125,7 @@ public Bundle toBundle() {
         return bundle;
     }
 
-    public static StartRMData fromBundle(Bundle bundle) {
+    public static StartRMData fromBundle(@NonNull Bundle bundle) {
         bundle.setClassLoader(Region.class.getClassLoader());
         boolean valid = false;
         StartRMData data = new StartRMData();
diff --git a/src/main/java/org/altbeacon/beacon/service/Stats.java b/src/main/java/org/altbeacon/beacon/service/Stats.java
index 94f5266f..aaac630b 100644
--- a/src/main/java/org/altbeacon/beacon/service/Stats.java
+++ b/src/main/java/org/altbeacon/beacon/service/Stats.java
@@ -12,7 +12,12 @@
  * Created by dyoung on 10/16/14.
  */
 public class Stats {
+    private static final Stats INSTANCE = new Stats();
     private static final String TAG = "Stats";
+
+    /**
+     * Synchronize all usage as this is not a thread safe class.
+     */
     private static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat("HH:mm:ss.SSS");
 
     private ArrayList<Sample> mSamples;
@@ -21,14 +26,11 @@
     private boolean mEnableHistoricalLogging;
     private boolean mEnabled;
     private Sample mSample;
-    private static Stats mInstance;
 
     public static Stats getInstance() {
-        if(mInstance == null) {
-            mInstance = new Stats();
-        }
-        return mInstance;
+        return INSTANCE;
     }
+
     private Stats() {
         mSampleIntervalMillis = 0l;
         clearSamples();
@@ -105,7 +107,13 @@ private void logSample(Sample sample, boolean showHeader) {
     }
 
     private String formattedDate(Date d) {
-        return d == null ? "" : SIMPLE_DATE_FORMAT.format(d);
+        String formattedDate = "";
+        if (d != null) {
+            synchronized (SIMPLE_DATE_FORMAT) {
+                formattedDate = SIMPLE_DATE_FORMAT.format(d);
+            }
+        }
+        return formattedDate;
     }
 
     private void logSamples() {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 4d370d55..4b678233 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -20,7 +20,6 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
-
 import java.util.Date;
 
 @TargetApi(18)
@@ -32,7 +31,6 @@
     private long mLastScanCycleEndTime = 0l;
     protected long mNextScanCycleStartTime = 0l;
     private long mScanCycleStopTime = 0l;
-    private long mLastScanStopTime = 0l;
 
     private boolean mScanning;
     protected boolean mScanningPaused;
@@ -53,6 +51,7 @@
     protected boolean mBackgroundFlag = false;
     protected boolean mRestartNeeded = false;
 
+    private boolean mDistinctPacketsDetectedPerScan = false;
     private static final long ANDROID_N_MIN_SCAN_CYCLE_MILLIS = 6000l;
 
     protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
@@ -158,15 +157,34 @@ public void stop() {
         mScanningEnabled = false;
         if (mScanCyclerStarted) {
             scanLeDevice(false);
+        } else {
+            LogManager.d(TAG, "scanning already stopped");
         }
-        if (mBluetoothAdapter != null) {
-            stopScan();
-            mLastScanCycleEndTime = SystemClock.elapsedRealtime();
-        }
+    }
+
+    public boolean getDistinctPacketsDetectedPerScan() {
+        return mDistinctPacketsDetectedPerScan;
+    }
+
+    public void setDistinctPacketsDetectedPerScan(boolean detected) {
+        mDistinctPacketsDetectedPerScan = detected;
     }
 
     public void destroy() {
-        mScanThread.quit();
+        LogManager.d(TAG, "Destroying");
+        // We cannot quit the thread used by the handler until queued Runnables have been processed,
+        // because the handler is what stops scanning, and we do not want scanning left on.
+        // So we stop the thread using the handler, so we make sure it happens after all other
+        // waiting Runnables are finished.
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                LogManager.d(TAG, "Quitting scan thread");
+                // Remove any postDelayed Runnables queued for the next scan cycle
+                mHandler.removeCallbacksAndMessages(null);
+                mScanThread.quit();
+            }
+        });
     }
 
     protected abstract void stopScan();
@@ -271,26 +289,39 @@ private void finishScanCycle() {
             if (mScanning) {
                 if (getBluetoothAdapter() != null) {
                     if (getBluetoothAdapter().isEnabled()) {
-                        long now = System.currentTimeMillis();
-                        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
-                                mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
-                                now-mLastScanStopTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
-                            // As of Android N, only 5 scans may be started in a 30 second period (6
-                            // seconds per cycle)  otherwise they are blocked.  So we check here to see
-                            // if the scan period is 6 seconds or less, and if we last stopped scanning
-                            // fewer than 6 seconds ag and if so, we simply do not stop scanning
-                            LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
-                                    " keep scanning for a minimum of 6 seconds at a time. "+
-                                    "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanStopTime))+" millisconds.");
+                        // Determine if we need to restart scanning.  Restarting scanning is only
+                        // needed on devices incapable of detecting multiple distinct BLE advertising
+                        // packets in a single cycle, typically older Android devices (e.g. Nexus 4)
+                        // On such devices, it is necessary to stop scanning and restart to detect
+                        // multiple beacon packets in the same scan, allowing collection of multiple
+                        // rssi measurements.  Restarting however, causes brief detection dropouts
+                        // so it is best avoided.  If we know the device has detected to distinct
+                        // packets in the same cycle, we will not restart scanning and just keep it
+                        // going.
+                        if (!getDistinctPacketsDetectedPerScan() || mBetweenScanPeriod != 0) {
+                            long now = SystemClock.elapsedRealtime();
+                            if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
+                                    mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
+                                    now-mLastScanCycleStartTime < ANDROID_N_MIN_SCAN_CYCLE_MILLIS) {
+                                // As of Android N, only 5 scans may be started in a 30 second period (6
+                                // seconds per cycle)  otherwise they are blocked.  So we check here to see
+                                // if the scan period is 6 seconds or less, and if we last stopped scanning
+                                // fewer than 6 seconds ag and if so, we simply do not stop scanning
+                                LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
+                                        " keep scanning for a minimum of 6 seconds at a time. "+
+                                        "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanCycleStartTime))+" millisconds.");
+                            }
+                            else {
+                                try {
+                                    LogManager.d(TAG, "stopping bluetooth le scan");
+                                    finishScan();
+                                } catch (Exception e) {
+                                    LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
+                                }
+                            }
                         }
                         else {
-                            try {
-                                LogManager.d(TAG, "stopping bluetooth le scan");
-                                finishScan();
-                                mLastScanStopTime = now;
-                            } catch (Exception e) {
-                                LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
-                            }
+                            LogManager.d(TAG, "Not stopping scanning.  Device capable of multiple indistinct detections per scan.");
                         }
 
                         mLastScanCycleEndTime = SystemClock.elapsedRealtime();
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index 82251314..44a2fa9e 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -223,6 +223,7 @@ private void postStopLeScan() {
             @Override
             public void run() {
                 try {
+                    LogManager.d(TAG, "Stopping LE scan on scan handler");
                     scanner.stopScan(scanCallback);
                 } catch (IllegalStateException e) {
                     LogManager.w(TAG, "Cannot stop scan. Bluetooth may be turned off.");
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
new file mode 100644
index 00000000..42978d30
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
@@ -0,0 +1,43 @@
+package org.altbeacon.beacon.service.scanner;
+
+import android.util.Log;
+
+import java.nio.ByteBuffer;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Created by dyoung on 4/8/17.
+ *
+ * This class tracks whether multiple distinct BLE packets have been seen, with the purpose of
+ * determining if the Android device supports detecting multiple distinct packets in a single scan.
+ * Some older devices are not capable of this (e.g. Nexus 4, Moto G1), so detecting multiple packets
+ * requires stopping and restarting scanning on these devices.  This allows detecting if that is
+ * neessary
+ */
+public class DistinctPacketDetector {
+    // Sanity limit for the number of packets to track, so we don't use too much memory
+    private static final int MAX_PACKETS_TO_TRACK = 1000;
+    protected Set<ByteBuffer> mDistinctPacketsDetected = new HashSet<ByteBuffer>();
+
+    public void clearDetections() {
+        mDistinctPacketsDetected.clear();
+    }
+
+    public boolean isPacketDistinct(String originMacAddress, byte[] scanRecord) {
+        byte[] macBytes = originMacAddress.getBytes();
+        ByteBuffer buffer = ByteBuffer.allocate(macBytes.length+scanRecord.length);
+        buffer.put(macBytes);
+        buffer.put(scanRecord);
+        buffer.rewind(); // rewind puts position back to beginning so .equals and .hashCode work
+
+        boolean distinct = !mDistinctPacketsDetected.contains(buffer);
+        if (mDistinctPacketsDetected.size() == MAX_PACKETS_TO_TRACK) {
+            return mDistinctPacketsDetected.contains(buffer);
+        }
+        else {
+            return mDistinctPacketsDetected.add(buffer);
+        }
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
index 93eefda9..8964e607 100644
--- a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
+++ b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
@@ -1,6 +1,5 @@
 package org.altbeacon.beacon.startup;
 
-import android.annotation.TargetApi;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -8,7 +7,6 @@
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.BeaconManager;
 
-@TargetApi(4)
 public class StartupBroadcastReceiver extends BroadcastReceiver
 {
     private static final String TAG = "StartupBroadcastReceiver";
diff --git a/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
index 229b3d7d..f0ffb0d7 100644
--- a/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
+++ b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
@@ -2,15 +2,19 @@
 
 import android.app.ActivityManager;
 import android.content.Context;
+import android.support.annotation.NonNull;
 
 /**
  * Created by dyoung on 3/10/17.
+ *
+ * Internal class used to determine current process state in multi-process setups
+ * @hide
  */
 
 public class ProcessUtils {
     Context mContext;
 
-    public ProcessUtils(Context context) {
+    public ProcessUtils(@NonNull Context context) {
         mContext = context;
     }
 
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
index a1542932..195a770a 100644
--- a/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothCrashResolver.java
@@ -39,7 +39,6 @@
  *
  * Created by dyoung on 3/24/14.
  */
-@TargetApi(5)
 public class BluetoothCrashResolver {
     private static final String TAG = "BluetoothCrashResolver";
     private static final boolean PREEMPTIVE_ACTION_ENABLED = true;
diff --git a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
index b101143a..403cd955 100644
--- a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
@@ -1,9 +1,6 @@
 package org.altbeacon.beacon.service;
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.os.AsyncTask;
-import android.os.Build;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Identifier;
@@ -11,22 +8,16 @@
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
-import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowApplication;
-import org.robolectric.util.ServiceController;
 
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.concurrent.ThreadPoolExecutor;
 
 import android.os.Bundle;
-import org.altbeacon.beacon.service.RangingData;
 
 import static org.junit.Assert.assertEquals;
 
diff --git a/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java b/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
new file mode 100644
index 00000000..f82e152c
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetectorTest.java
@@ -0,0 +1,57 @@
+package org.altbeacon.beacon.service.scanner;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+@Config(sdk = 18)
+
+@RunWith(RobolectricTestRunner.class)
+public class DistinctPacketDetectorTest {
+    @BeforeClass
+    public static void testSetup() {
+    }
+
+    @AfterClass
+    public static void testCleanup() {
+
+    }
+
+    @Test
+    public void testSecondDuplicatePacketIsNotDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        assertFalse("second call with same packet should not be distinct", secondResult);
+    }
+
+    @Test
+    public void testSecondNonDuplicatePacketIsDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x03, 0x04});
+        assertTrue("second call with different packet should be distinct", secondResult);
+    }
+
+    @Test
+    public void testSamePacketForDifferentMacIsDistinct() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        boolean secondResult = dpd.isPacketDistinct("01:01:01:01:01:01", new byte[] {0x01, 0x02});
+        assertTrue("second packet with different mac should be distinct", secondResult);
+    }
+
+    @Test
+    public void clearingDetectionsPreventsDistinctDetection() throws Exception {
+        DistinctPacketDetector dpd = new DistinctPacketDetector();
+        dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        dpd.clearDetections();
+        boolean secondResult = dpd.isPacketDistinct("01:02:03:04:05:06", new byte[] {0x01, 0x02});
+        assertTrue("second call with same packet after clear should be distinct", secondResult);
+    }
+
+}
\ No newline at end of file
