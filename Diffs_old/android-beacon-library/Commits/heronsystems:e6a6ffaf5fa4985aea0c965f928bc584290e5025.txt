diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9e00ee1d..3347bcaf 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,4 +1,121 @@
-### Development
+### 2.13.1 / 2018-03-05
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.13.1...2.13)
+
+ Bug Fixes:
+ - Fix incorrect immediateScanJobId meta-data name in manifest causing crash  (#653, David G. Young)
+
+
+### 2.13 / 2018-03-05
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12.4...2.13)
+
+Enhancements:
+ - Add BluetoothMedic to fix crashing bluetooth stacks.  (#644, David G. Young)
+ - Allow configuring job ids (#645, David G. Young)
+
+ Bug Fixes:
+ - Allow scans with screen off on Android 8.1 (#637, David G. Young)
+
+### 2.12.4 / 2017-12-16
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12.3...2.12.4)
+
+Bug Fixes:
+ - Fix performance problems when using identifiers 3-15 bytes caused by
+   Identifier#toHexString(). (#615, David G. Young)
+ - Restore missing runningAverageRssi values  (#621, David G. Young)
+ - Fix NPE on ExtraBeaconDataTracker (#626, David G. Young)
+ - Fix regression with `RunningAverageRssiFilter.setSampleExpirationMilliseconds`
+   being overwritten when committing ranged beacon measurements. (#629, Aaron Kromer)
+ - Fix missing running average RSSI in callbacks when apps do not use the
+   scheduled scan job feature. (#630, Aaron Kromer)
+ - Fix copying of multi-frame beacon flag in `Beacon(Beacon)` constructor (#630, Aaron Kromer)
+ - Fix the `AltBeaon(Beacon)` copy constructor which omitted some data fields (#630, Aaron Kromer)
+
+### 2.12.3 / 2017-10-14
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12.2...2.12.3)
+
+Bug Fixes:
+ - Fix NullPointerException in ProcessUtils.  (#598, David G. Young)
+ - Fix ConcurrentModificationException crashing app on Android 8 when monitored regions are
+   changed at the same time the app shifts from active scanning to passive scanning.
+   (#578, David G. Young)
+ - Fix ConcurrentModifictionExceptions starting ScanJobs.  (#584, #588, David G. Young)
+ - Fix NullPointerException when BluetoothLeScanner cannot be obtained.
+   (#583, David G. Young)
+
+### 2.12.2 / 2017-08-31
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12.1...2.12.2)
+
+Bug Fixes:
+ - Fix stack overflow caused by scan period of zero seconds, caused by 2.12 upgrade of existing
+  apps.  (#572, David G. Young)
+ - Suppress error log on ScanState deserialization if file does not exist yet.
+   (#570, David G. Young)
+ - Turn off scanning after unbind, which was previously left on forever in some cases.
+  (#569, David G. Young)
+
+### 2.12.1 / 2017-08-16
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.12...2.12.1)
+
+
+Bug Fixes:
+ - Fix crash on Android 8.0 background scan when bluetooth is off.
+   (#562 Juliane Lehmann)
+ - Fix "Scanning too frequently" error with non-zero betweenScanPeriod
+   and scanPeriod+betweenScanPeriod < 6000, and full-power scanning
+   staying on for foreground scans with a non-zero betweenScanPeriod
+   (#555, David G. Young)
+
+
+### 2.12 / 2017-08-07
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.11...2.12)
+
+Enhancements:
+ - Add Android O support with ScanJob using  JobScheduler to do scans instead of BeaconService,
+   set as default for Android O. (#484, David G. Young)
+
+Bug Fixes:
+
+ - Correct accessor method for Beacon#getRunningAverageRssi()
+   (#536, Pietro De Caro)
+
+### 2.11 / 2017-06-28
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.10...2.11)
+
+Enhancements:
+
+- Add ability to circumvent prohibition against scans running for > 30 minutes on Android N.
+  (#529, David G. Young)
+- Add support for running the beacon scanning service in a separate process and working with
+  application setups that have more than one process. (#479, David G. Young)
+
+Bug Fixes:
+
+- Fix Google Play submission errors by no longer using uses-permission-sdk-23 in
+  Manifest (#527, David G. Young)
+- Fix inability to use `RunningAverageRssiFilter.setSampleExpirationMilliseconds(...)` (#523,
+  David G. Young)
+- Fix failure to restart scanning in some cases after bluetooth has been off but then is turned
+  back on. (#519, David G. Young)
+- Fix failure to stop scanning when unbinding from service or when the between scan period
+  is nonzero. (#507, David G. Young)
+- Fix possible `NullPointerException` with `BackgroundPowerSaver` on devices
+  prior to Android 4.3 Jelly Bean MR 2 (API 18) (#516, Aaron Kromer)
+- Fix rare edge case causing `NoSuchElementException` when using the legacy
+  `BeaconManager#getMonitoringNotifier` and `BeaconManager#getRangingNotifier`
+  where the notifier sets were modified external to `BeaconManager` by another
+  thread (#516, Aaron Kromer)
+
+### 2.10 / 2017-04-21
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9.2...2.10)
 
 Enhancements:
 
diff --git a/build.gradle b/build.gradle
index ac54f10a..8b3dc319 100644
--- a/build.gradle
+++ b/build.gradle
@@ -25,10 +25,16 @@ def getVersionName = {
 buildscript {
     repositories {
         jcenter()
+        maven {
+            url 'https://maven.google.com'
+        }
+        maven {
+            url 'https://dl.google.com/dl/android/maven2/'
+        }
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:2.3.0'
+        classpath 'com.android.tools.build:gradle:3.0.1'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3'
     }
@@ -44,20 +50,30 @@ allprojects {
 
     repositories {
         jcenter()
+        maven {
+            url 'https://maven.google.com'
+        }
+        maven {
+            url 'https://dl.google.com/dl/android/maven2/'
+        }
     }
 }
 
 android {
-    compileSdkVersion 24
-    buildToolsVersion "25.0.2"
+    compileSdkVersion 26
+    buildToolsVersion '26.0.2'
 
     defaultConfig {
-        minSdkVersion 7
-        targetSdkVersion 23
+        // Unfortunately 'com.android.support:appcompat-v7:26.0.0'
+        // requires minSdkVersion 14, forcing a bump verson minSdkVersion 7
+        // But since only 0.8% of Android devices have < SDK 14 as of Une 2017, this will become
+        // the new min version for this library in order to target Android O
+        minSdkVersion 14
+        targetSdkVersion 26
         versionCode 1
         versionName version
-        testInstrumentationRunner "com.google.android.apps.common.testing.testrunner.GoogleInstrumentationTestRunner"
         consumerProguardFiles 'proguard-rules.pro'
+        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
 
     compileOptions {
@@ -80,7 +96,8 @@ android {
 
 dependencies {
     compile fileTree ( dir: 'libs', include: ['*.jar'] )
-    compile 'com.android.support:support-annotations:24.2.1'
+    compile 'com.android.support:appcompat-v7:26.0.0'
+    compile 'com.android.support:support-annotations:26.0.0'
 
     testCompile('junit:junit:4.12') {
         exclude group: 'org.hamcrest'
@@ -95,6 +112,11 @@ dependencies {
     testCompile('org.mockito:mockito-core:1.10.19') {
         exclude group: 'org.hamcrest'
     }
+    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
+        exclude group: 'com.android.support', module: 'support-annotations'
+        exclude group: 'org.hamcrest'
+    })
+    androidTestCompile 'org.apache.commons:commons-math3:3.6.1'
 }
 
 apply plugin: 'idea'
diff --git a/circle.yml b/circle.yml
index dc4aa38b..74b551da 100644
--- a/circle.yml
+++ b/circle.yml
@@ -3,5 +3,7 @@ machine:
     version: openjdk8
 dependencies:
   pre:
-    - echo y | android update sdk --no-ui --all --filter "tools,android-24,build-tools-25.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
-
+    - echo y | android update sdk --no-ui --all --filter "tools,android-26,build-tools-26.0.2,platform-tools,extra-android-m2repository,extra-google-m2repository"
+general:
+  branches:
+    ignore:
diff --git a/gradle/publishing.gradle b/gradle/publishing.gradle
index 6b94dd81..72962328 100644
--- a/gradle/publishing.gradle
+++ b/gradle/publishing.gradle
@@ -14,10 +14,10 @@ publishing {
             version project.version
             artifact "${project.buildDir}/outputs/aar/${project.name}-release.aar"
             artifact androidJavadocsJar {
-                classifier 'source'
+                classifier 'javadoc'
             }
             artifact androidSourcesJar {
-                classifier 'javadoc'
+                classifier 'source'
             }
 
             pom.withXml {
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 388ee27b..9a16f53a 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -3,4 +3,7 @@ distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-milestone-1-all.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-4.0-milestone-1-all.zip
+#distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
diff --git a/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java b/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java
new file mode 100644
index 00000000..b93ede2e
--- /dev/null
+++ b/src/androidTest/java/org/altbeacon/beacon/NotifierSetCopyBenchmarksTest.java
@@ -0,0 +1,278 @@
+package org.altbeacon.beacon;
+
+import android.support.test.runner.AndroidJUnit4;
+import android.util.Log;
+
+import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+/*
+ * Set of benchmarks for copying various sized notifier sets.
+ *
+ * As with the current implementation the base sets use `CopyOnWriteArraySet`. In most cases
+ * these notifier sets will only have a single notifier in them. However, it's possible there are
+ * more so this also includes a set of three notifiers. While its very unlikely the notifiers
+ * will grow much larger two bigger sets are also included to help expose the affect of set size on
+ * the performance.
+ *
+ * Sample Test Runs
+ * ================
+ *
+ * All tests were performed with no apps running in the foreground and the devices in airplane
+ * mode. This was done to help minimize background system noise.
+ *
+ * Nexus 6 on Android 7.0
+ *
+ *   |      Type       | Size |   N   |   Min   |   Max   |  Mean   | Std. Dev |     Var     |
+ *   |-----------------|------|-------|---------|---------|---------|----------|-------------|
+ *   |         HashSet |    1 | 10000 |    4062 |   85157 |   11484 |   3429.7 | 1.17626e+07 |
+ *   | UnmodifiableSet |    1 | 10000 |    1718 |  342292 |    4864 |   4907.6 | 2.40841e+07 |
+ *   |         HashSet |    3 | 10000 |    6563 | 4019793 |   14402 |  41514.6 | 1.72346e+09 |
+ *   | UnmodifiableSet |    3 | 10000 |    1666 |  223281 |    5403 |   3091.0 | 9.55441e+06 |
+ *   |         HashSet |   10 | 10000 |    7500 | 1140937 |   16996 |  12741.5 | 1.62345e+08 |
+ *   | UnmodifiableSet |   10 | 10000 |    1666 |  313802 |    4765 |   4146.9 | 1.71966e+07 |
+ *   |         HashSet |   20 | 10000 |   11510 | 1677083 |   21395 |  18560.7 | 3.44500e+08 |
+ *   | UnmodifiableSet |   20 | 10000 |    1718 | 1690104 |    4187 |  17014.1 | 2.89478e+08 |
+ *
+ *
+ * Nexus 5 on Android 4.4.4
+ *
+ *   |      Type       | Size |   N   |   Min   |   Max   |  Mean   | Std. Dev |  Variance   |
+ *   |-----------------|------|-------|---------|---------|---------|----------|-------------|
+ *   |         HashSet |    1 | 10000 |    6354 | 7764219 |   12658 | 154235.5 | 2.37886e+10 |
+ *   | UnmodifiableSet |    1 | 10000 |    1250 |  178334 |    1360 |   1996.4 | 3.98546e+06 |
+ *   |         HashSet |    3 | 10000 |    9479 | 7745833 |   17389 | 171098.2 | 2.92746e+10 |
+ *   | UnmodifiableSet |    3 | 10000 |    1250 |  120001 |    1435 |   1320.4 | 1.74347e+06 |
+ *   |         HashSet |   10 | 10000 |   10000 | 7665208 |   30028 | 252827.8 | 6.39219e+10 |
+ *   | UnmodifiableSet |   10 | 10000 |    1302 |   97865 |    1435 |   1012.2 | 1.02459e+06 |
+ *   |         HashSet |   20 | 10000 |   16354 | 8842240 |   41301 | 333940.7 | 1.11516e+11 |
+ *   | UnmodifiableSet |   20 | 10000 |    1302 |   94479 |    1486 |   1049.3 | 1.10112e+06 |
+ *
+ *
+ * Samsung SM-G900V on Android 4.4.2
+ *
+ *   |      Type       | Size |   N   |   Min   |   Max    |  Mean   | Std. Dev |  Variance   |
+ *   |-----------------|------|-------|---------|----------|---------|----------|-------------|
+ *   |         HashSet |    1 | 10000 |    7084 |   306615 |    8703 |   9694.4 | 9.39809e+07 |
+ *   | UnmodifiableSet |    1 | 10000 |    1562 |    51615 |    1926 |    869.5 | 7.56085e+05 |
+ *   |         HashSet |    3 | 10000 |   10364 |   809427 |   12095 |   9418.6 | 8.87103e+07 |
+ *   | UnmodifiableSet |    3 | 10000 |    1562 |    82605 |    1967 |   1157.5 | 1.33973e+06 |
+ *   |         HashSet |   10 | 10000 |   11094 | 14970052 |   26345 | 155322.0 | 2.41249e+10 |
+ *   | UnmodifiableSet |   10 | 10000 |    1562 |    11563 |    1981 |    545.5 | 2.97536e+05 |
+ *   |         HashSet |   20 | 10000 |   17760 | 13884687 |   29915 | 215507.1 | 4.64433e+10 |
+ *   | UnmodifiableSet |   20 | 10000 |    1562 |   170781 |    1939 |   3229.1 | 1.04269e+07 |
+ *
+ *
+ * Summary
+ * =======
+ *
+ * In all cases usage of the `UnmodifiableSet` was fastest. This is not surprising because the
+ * current implementations are thin object wrappers around the provided set. This means they
+ * store the `CopyOnWriteArraySet` internally and delegate all non-mutation methods to it. So
+ * naturally this is faster than creating a new data structure and copying all elements into it.
+ */
+@RunWith(AndroidJUnit4.class)
+public class NotifierSetCopyBenchmarksTest {
+    private static final Set<RangeNotifier> LARGE_SET  = buildSet(20);
+
+    private static final Set<RangeNotifier> MEDIUM_SET = buildSet(10);
+
+    private static final Set<RangeNotifier> SINGLE_SET = buildSet(1);
+
+    private static final Set<RangeNotifier> SMALL_SET  = buildSet(3);
+
+    private static final String STAT_FORMAT =
+            "| %15s | %4d | %4d | %7d | %7d | %7d | %#8.1f | %.5e |";
+
+    private static final String STAT_HEADER =
+            "|      Type       | Size |   N   |   Min   |   Max   |  Mean   | Std. Dev |  Variance   |\n" +
+            "|-----------------|------|-------|---------|---------|---------|----------|-------------|";
+
+    private static final String TAG = "BenchmarkTests";
+
+    private static final int WARMUP_SIZE = 1_000;
+
+    private static final int SAMPLE_SIZE = 10_000;
+
+    @BeforeClass
+    public static void _displayStatsHeader() {
+        Log.i(TAG, "Benchmarks: NotifierSetCopyBenchmarksTest");
+        Log.i(TAG, STAT_HEADER);
+        // Let things finish loading / processing (such as package name for logging)
+        try {
+            Thread.sleep(2_000);
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static Set<RangeNotifier> buildSet(int size) {
+        final Set<RangeNotifier> set = new CopyOnWriteArraySet<>();
+        for (int i = 0; i < size; i++) {
+            set.add(
+                    new RangeNotifier() {
+                        @Override
+                        public void didRangeBeaconsInRegion(Collection<Beacon> beacons, Region region) {
+                        }
+                    }
+            );
+        }
+        return set;
+    }
+
+    @Test
+    public void copyHashSet_Size1() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(SINGLE_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = new HashSet<>(SINGLE_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyHashSet_Size10() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(MEDIUM_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = new HashSet<>(MEDIUM_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyHashSet_Size20() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(LARGE_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = new HashSet<>(LARGE_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyHashSet_Size3() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(SMALL_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = new HashSet<>(SMALL_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyUnmodifiableSet_Size1() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(SINGLE_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = Collections.unmodifiableSet(SINGLE_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyUnmodifiableSet_Size10() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(MEDIUM_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = Collections.unmodifiableSet(MEDIUM_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyUnmodifiableSet_Size20() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(LARGE_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = Collections.unmodifiableSet(LARGE_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    @Test
+    public void copyUnmodifiableSet_Size3() {
+        Set<RangeNotifier> copySet = null;
+        double[] raw = new double[SAMPLE_SIZE];
+        for (int i = 0; i < WARMUP_SIZE; i++) {
+            copySet = new HashSet<>(SMALL_SET);
+        }
+        System.gc();
+        for (int i = 0; i < raw.length; i++) {
+            long t0 = System.nanoTime();
+            copySet = Collections.unmodifiableSet(SMALL_SET);
+            raw[i] = System.nanoTime() - t0;
+        }
+        logStats(copySet, raw);
+    }
+
+    private void logStats(Set<?> set, double[] raw) {
+        DescriptiveStatistics descStats = new DescriptiveStatistics(raw);
+        Log.i(
+                TAG,
+                String.format(
+                        Locale.US,
+                        STAT_FORMAT,
+                        set.getClass().getSimpleName(),
+                        set.size(),
+                        descStats.getN(),
+                        Math.round(descStats.getMin()),
+                        Math.round(descStats.getMax()),
+                        Math.round(descStats.getMean()),
+                        descStats.getStandardDeviation(),
+                        descStats.getVariance()
+                )
+        );
+    }
+}
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index 2000a4d8..1da97bff 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.BLUETOOTH" android:required="false"/>
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:required="false"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
-    <uses-permission-sdk-23 android:name="android.permission.ACCESS_COARSE_LOCATION"/>
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
 
     <application>
         <receiver android:name="org.altbeacon.beacon.startup.StartupBroadcastReceiver">
@@ -28,6 +28,17 @@
             android:exported="false"
             />
 
+        <service android:name=".service.ScanJob"
+                android:permission="android.permission.BIND_JOB_SERVICE">
+            <meta-data android:name="immediateScanJobId" android:value="208352939" />
+            <meta-data android:name="periodicScanJobId" android:value="208352940" />
+        </service>
+  
+        <service android:name="org.altbeacon.bluetooth.BluetoothTestJob"
+            android:permission="android.permission.BIND_JOB_SERVICE" >
+            <meta-data android:name="jobId" android:value="1799803768"/>
+        </service>
+
     </application>
 
 </manifest>
diff --git a/src/main/java/org/altbeacon/beacon/AltBeacon.java b/src/main/java/org/altbeacon/beacon/AltBeacon.java
index 891829e8..ccfd2777 100644
--- a/src/main/java/org/altbeacon/beacon/AltBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/AltBeacon.java
@@ -64,20 +64,14 @@ public AltBeacon createFromParcel(Parcel in) {
      * @param beacon
      */
     protected AltBeacon(Beacon beacon) {
-        super();
-        this.mBluetoothAddress = beacon.mBluetoothAddress;
-        this.mIdentifiers = beacon.mIdentifiers;
-        this.mBeaconTypeCode = beacon.mBeaconTypeCode;
-        this.mDataFields = beacon.mDataFields;
-        this.mDistance = beacon.mDistance;
-        this.mRssi = beacon.mRssi;
-        this.mTxPower = beacon.mTxPower;
+        super(beacon);
     }
 
     /**
      * @see AltBeacon.Builder to make AltBeacon instances
      */
     protected AltBeacon() {
+        super();
     }
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index e49c232a..f46e9edc 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -31,8 +31,10 @@
 import org.altbeacon.beacon.distance.DistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
+
 import java.util.List;
 
 /**
@@ -54,7 +56,7 @@
  * @author  David G. Young
  * @see     Region#matchesBeacon(Beacon Beacon)
  */
-public class Beacon implements Parcelable {
+public class Beacon implements Parcelable, Serializable {
     private static final String TAG = "Beacon";
 
     private static final List<Long> UNMODIFIABLE_LIST_OF_LONG =
@@ -110,6 +112,16 @@
      */
     protected String mBluetoothAddress;
 
+    /**
+     * The number of rssi samples available, if known
+     */
+    private int mRssiMeasurementCount = 0;
+
+    /**
+     * The number of packets detected in the last cycle
+     */
+    private int mPacketCount = 0;
+
     /**
      * If multiple RSSI samples were available, this is the running average
      */
@@ -168,6 +180,7 @@
      * Required for making object Parcelable.  If you override this class, you must provide an
      * equivalent version of this method.
      */
+    @Deprecated
     public static final Parcelable.Creator<Beacon> CREATOR
             = new Parcelable.Creator<Beacon>() {
         public Beacon createFromParcel(Parcel in) {
@@ -205,10 +218,15 @@ public static void setHardwareEqualityEnforced(boolean e) {
         sHardwareEqualityEnforced = e;
     }
 
+    public static boolean getHardwareEqualityEnforced() {
+        return sHardwareEqualityEnforced;
+    }
+
     /**
      * Required for making Beacon parcelable
      * @param in parcel
      */
+    @Deprecated
     protected Beacon(Parcel in) {
         int size = in.readInt();
 
@@ -236,6 +254,9 @@ protected Beacon(Parcel in) {
         mBluetoothName = in.readString();
         mParserIdentifier = in.readString();
         mMultiFrameBeacon = in.readByte() != 0;
+        mRunningAverageRssi = (Double) in.readValue(null);
+        mRssiMeasurementCount = in.readInt();
+        mPacketCount = in.readInt();
     }
 
     /**
@@ -249,6 +270,8 @@ protected Beacon(Beacon otherBeacon) {
         mExtraDataFields = new ArrayList<>(otherBeacon.mExtraDataFields);
         this.mDistance = otherBeacon.mDistance;
         this.mRunningAverageRssi = otherBeacon.mRunningAverageRssi;
+        this.mPacketCount = otherBeacon.mPacketCount;
+        this.mRssiMeasurementCount = otherBeacon.mRssiMeasurementCount;
         this.mRssi = otherBeacon.mRssi;
         this.mTxPower = otherBeacon.mTxPower;
         this.mBluetoothAddress = otherBeacon.mBluetoothAddress;
@@ -256,6 +279,8 @@ protected Beacon(Beacon otherBeacon) {
         this.mServiceUuid = otherBeacon.getServiceUuid();
         this.mBluetoothName = otherBeacon.mBluetoothName;
         this.mParserIdentifier = otherBeacon.mParserIdentifier;
+        this.mMultiFrameBeacon = otherBeacon.mMultiFrameBeacon;
+        this.mManufacturer = otherBeacon.mManufacturer;
     }
 
     /**
@@ -267,6 +292,38 @@ protected Beacon() {
         mExtraDataFields = new ArrayList<Long>(1);
     }
 
+
+    /**
+     * Sets the measurement count that went into the rssi sample
+     * @param rssiMeasurementCount
+     */
+    public void setRssiMeasurementCount(int rssiMeasurementCount) {
+        mRssiMeasurementCount = rssiMeasurementCount;
+    }
+
+    /**
+     * Returns the number of packet detections in the last ranging cycle
+     */
+    public int getPacketCount() {
+        return mPacketCount;
+    }
+
+    /**
+     * Sets the packet detections in the last ranging cycle
+     * @param packetCount
+     */
+    public void setPacketCount(int packetCount) {
+        mPacketCount = packetCount;
+    }
+
+    /**
+     * Returns the number of packet detections that went in to the runningAverageRssi, if known.
+     * If not known or inapplicable for the rssi filter used, this is zero.
+     */
+    public int getMeasurementCount() {
+        return mRssiMeasurementCount;
+    }
+
     /**
      * Sets the running average rssi for use in distance calculations
      * @param rssi the running average rssi
@@ -276,6 +333,27 @@ public void setRunningAverageRssi(double rssi) {
         mDistance = null; // force calculation of accuracy and proximity next time they are requested
     }
 
+    /**
+     * @deprecated To be removed in a future release. Use
+     * {@link org.altbeacon.beacon.Beacon#getRunningAverageRssi()}
+     * instead.
+     */
+    @Deprecated
+    public double getRunningAverageRssi(double rssi) {
+        return mRunningAverageRssi = rssi;
+    }
+
+    /**
+     * Returns the running average rssi
+     * @return double
+     */
+    public double getRunningAverageRssi() {
+        if (mRunningAverageRssi != null){
+            return mRunningAverageRssi;
+        }
+        return mRssi;
+    }
+
     /**
      * Sets the most recently measured rssi for use in distance calculations if a running average is
      * not available
@@ -522,6 +600,7 @@ private StringBuilder toStringBuilder() {
     /**
      * Required for making object Parcelable
      */
+    @Deprecated
     public int describeContents() {
         return 0;
     }
@@ -530,6 +609,7 @@ public int describeContents() {
      * Required for making object Parcelable.  If you override this class, you must override this
      * method if you add any additional fields.
      */
+    @Deprecated
     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mIdentifiers.size());
         for (Identifier identifier: mIdentifiers) {
@@ -553,6 +633,9 @@ public void writeToParcel(Parcel out, int flags) {
         out.writeString(mBluetoothName);
         out.writeString(mParserIdentifier);
         out.writeByte((byte) (mMultiFrameBeacon ? 1: 0));
+        out.writeValue(mRunningAverageRssi);
+        out.writeInt(mRssiMeasurementCount);
+        out.writeInt(mPacketCount);
     }
 
     /**
@@ -700,6 +783,16 @@ public Builder setRssi(int rssi) {
             return this;
         }
 
+        /**
+         * @see Beacon#mRssi
+         * @param rssi
+         * @return builder
+         */
+        public Builder setRunningAverageRssi(double rssi) {
+            mBeacon.mRunningAverageRssi = rssi;
+            return this;
+        }
+
         /**
          * @see Beacon#mTxPower
          * @param txPower
@@ -799,6 +892,7 @@ public Builder setMultiFrameBeacon(boolean multiFrameBeacon) {
             mBeacon.mMultiFrameBeacon = multiFrameBeacon;
             return this;
         }
+
     }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index a3968df4..1f63462e 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -28,12 +28,26 @@
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.MonitoringData;
+import org.altbeacon.beacon.service.MonitoringStatus;
 import org.altbeacon.beacon.service.RangingData;
 
 import java.util.Set;
 
 /**
  * Converts internal intents to notifier callbacks
+ *
+ * This is used with the BeaconService and supports scanning in a separate process.
+ * It is not used with the ScanJob, as an IntentService will not be able to be started in some cases
+ * where the app is in the background on Android O.
+ *
+ * @see BeaconLocalBroadcastProcessor for the equivalent use with ScanJob.
+ *
+ * This IntentService may be running in a different process from the BeaconService, which justifies
+ * its continued existence for multi-process service cases.
+ *
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
  */
 public class BeaconIntentProcessor extends IntentService {
     private static final String TAG = "BeaconIntentProcessor";
@@ -44,51 +58,6 @@ public BeaconIntentProcessor() {
 
     @Override
     protected void onHandleIntent(Intent intent) {
-        LogManager.d(TAG, "got an intent to process");
-
-        MonitoringData monitoringData = null;
-        RangingData rangingData = null;
-
-        if (intent != null && intent.getExtras() != null) {
-            monitoringData = (MonitoringData) intent.getExtras().get("monitoringData");
-            rangingData = (RangingData) intent.getExtras().get("rangingData");
-        }
-
-        if (rangingData != null) {
-            LogManager.d(TAG, "got ranging data");
-            if (rangingData.getBeacons() == null) {
-                LogManager.w(TAG, "Ranging data has a null beacons collection");
-            }
-            Set<RangeNotifier> notifiers = BeaconManager.getInstanceForApplication(this).getRangingNotifiers();
-            java.util.Collection<Beacon> beacons = rangingData.getBeacons();
-            if (notifiers != null) {
-                for(RangeNotifier notifier : notifiers){
-                    notifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
-                }
-            }
-            else {
-                LogManager.d(TAG, "but ranging notifier is null, so we're dropping it.");
-            }
-            RangeNotifier dataNotifier = BeaconManager.getInstanceForApplication(this).getDataRequestNotifier();
-            if (dataNotifier != null) {
-                dataNotifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
-            }
-        }
-
-        if (monitoringData != null) {
-            LogManager.d(TAG, "got monitoring data");
-            Set<MonitorNotifier> notifiers = BeaconManager.getInstanceForApplication(this).getMonitoringNotifiers();
-            if (notifiers != null) {
-                for(MonitorNotifier notifier : notifiers) {
-                    LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
-                    notifier.didDetermineStateForRegion(monitoringData.isInside() ? MonitorNotifier.INSIDE : MonitorNotifier.OUTSIDE, monitoringData.getRegion());
-                    if (monitoringData.isInside()) {
-                        notifier.didEnterRegion(monitoringData.getRegion());
-                    } else {
-                        notifier.didExitRegion(monitoringData.getRegion());
-                    }
-                }
-            }
-        }
+        new IntentHandler().convertIntentsToCallbacks(this.getApplicationContext(), intent);
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
new file mode 100644
index 00000000..8794252c
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/BeaconLocalBroadcastProcessor.java
@@ -0,0 +1,92 @@
+/**
+ * Radius Networks, Inc.
+ * http://www.radiusnetworks.com
+ *
+ * @author David G. Young
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.altbeacon.beacon;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.support.annotation.NonNull;
+import android.support.v4.content.LocalBroadcastManager;
+
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.Set;
+
+/**
+ * Converts internal intents to notifier callbacks
+ *
+ * This is used with ScanJob and supports delivering intents even under Android O background
+ * restrictions preventing starting a new IntentService.
+ *
+ * It is not used with the BeaconService, as local broadcast intents cannot be deliverd across
+ * different processes which the BeaconService supports.
+ *
+ * @see BeaconIntentProcessor for the equivalent use with BeaconService.
+ **
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
+ */
+public class BeaconLocalBroadcastProcessor {
+    private static final String TAG = "BeaconLocalBroadcastProcessor";
+
+    public static final String RANGE_NOTIFICATION = "org.altbeacon.beacon.range_notification";
+    public static final String MONITOR_NOTIFICATION = "org.altbeacon.beacon.monitor_notification";
+
+    @NonNull
+    private Context mContext;
+    private BeaconLocalBroadcastProcessor() {
+
+    }
+    public BeaconLocalBroadcastProcessor(Context context) {
+        mContext = context;
+
+    }
+
+    static int registerCallCount = 0;
+    int registerCallCountForInstnace = 0;
+    public void register() {
+        registerCallCount += 1;
+        registerCallCountForInstnace += 1;
+        LogManager.d(TAG, "Register calls: global="+registerCallCount+" instance="+registerCallCountForInstnace);
+        unregister();
+        LocalBroadcastManager.getInstance(mContext).registerReceiver(mLocalBroadcastReceiver,
+                new IntentFilter(RANGE_NOTIFICATION));
+        LocalBroadcastManager.getInstance(mContext).registerReceiver(mLocalBroadcastReceiver,
+                new IntentFilter(MONITOR_NOTIFICATION));
+    }
+
+    public void unregister() {
+        LocalBroadcastManager.getInstance(mContext).unregisterReceiver(mLocalBroadcastReceiver);
+    }
+
+
+    private BroadcastReceiver mLocalBroadcastReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            new IntentHandler().convertIntentsToCallbacks(context, intent);
+        }
+    };
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 46028bf7..f1894bdf 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -30,25 +30,36 @@
 import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.os.Build;
 import android.os.IBinder;
 import android.os.Message;
 import android.os.Messenger;
 import android.os.RemoteException;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
 import org.altbeacon.beacon.service.BeaconService;
+import org.altbeacon.beacon.service.Callback;
 import org.altbeacon.beacon.service.MonitoringStatus;
 import org.altbeacon.beacon.service.RangeState;
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanJobScheduler;
+import org.altbeacon.beacon.service.ScanState;
+import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.simulator.BeaconSimulator;
+import org.altbeacon.beacon.utils.ProcessUtils;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -58,6 +69,9 @@
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CopyOnWriteArraySet;
 
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanState;
+
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
@@ -106,20 +120,46 @@
  * @author Andrew Reitz <andrew@andrewreitz.com>
  */
 public class BeaconManager {
+    @NonNull
     private static final String TAG = "BeaconManager";
-    private Context mContext;
-    protected static volatile BeaconManager client = null;
-    private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<BeaconConsumer,ConsumerInfo>();
+
+    @NonNull
+    private final Context mContext;
+
+    @Nullable
+    protected static volatile BeaconManager sInstance = null;
+
+    @NonNull
+    private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<>();
+
+    @Nullable
     private Messenger serviceMessenger = null;
+
+    @NonNull
     protected final Set<RangeNotifier> rangeNotifiers = new CopyOnWriteArraySet<>();
+
+    @Nullable
     protected RangeNotifier dataRequestNotifier = null;
+
+    @NonNull
     protected final Set<MonitorNotifier> monitorNotifiers = new CopyOnWriteArraySet<>();
-    private final ArrayList<Region> rangedRegions = new ArrayList<Region>();
+
+    @NonNull
+    private final ArrayList<Region> rangedRegions = new ArrayList<>();
+
+    @NonNull
     private final List<BeaconParser> beaconParsers = new CopyOnWriteArrayList<>();
+
+    @Nullable
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+    private boolean mRegionStatePersistenceEnabled = true;
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
-
+    private boolean mMainProcess = false;
+    @Nullable
+    private Boolean mScannerInSameProcess = null;
+    private boolean mScheduledScanJobsEnabled = false;
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
 
@@ -266,6 +306,10 @@ public void setForegroundBetweenRangeUpdatePeriod(long p) {
      */
     public static void setRegionExitPeriod(long regionExitPeriod){
         sExitRegionPeriod = regionExitPeriod;
+        BeaconManager instance = sInstance;
+        if (instance != null) {
+            instance.applySettings();
+        }
     }
     
     /**
@@ -281,7 +325,8 @@ public static long getRegionExitPeriod(){
      * An accessor for the singleton instance of this class.  A context must be provided, but if you need to use it from a non-Activity
      * or non-Service class, you can attach it to another singleton or a subclass of the Android Application class.
      */
-    public static BeaconManager getInstanceForApplication(Context context) {
+    @NonNull
+    public static BeaconManager getInstanceForApplication(@NonNull Context context) {
         /*
          * Follow double check pattern from Effective Java v2 Item 71.
          *
@@ -295,31 +340,75 @@ public static BeaconManager getInstanceForApplication(Context context) {
          *
          * Joshua Bloch. Effective Java, Second Edition. Addison-Wesley, 2008. pages 283-284
          */
-        BeaconManager instance = client;
+        BeaconManager instance = sInstance;
         if (instance == null) {
             synchronized (SINGLETON_LOCK) {
-                instance = client;
+                instance = sInstance;
                 if (instance == null) {
-                    client = instance = new BeaconManager(context);
+                    sInstance = instance = new BeaconManager(context);
                 }
             }
         }
         return instance;
     }
 
-   protected BeaconManager(Context context) {
-      mContext = context.getApplicationContext();
-      if (!sManifestCheckingDisabled) {
-         verifyServiceDeclaration();
-      }
-      this.beaconParsers.add(new AltBeaconParser());
-   }
+    protected BeaconManager(@NonNull Context context) {
+        mContext = context.getApplicationContext();
+        checkIfMainProcess();
+        if (!sManifestCheckingDisabled) {
+           verifyServiceDeclaration();
+         }
+        this.beaconParsers.add(new AltBeaconParser());
+        mScheduledScanJobsEnabled = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O;
+    }
+
+    /***
+     * Determines if this BeaconManager instance is associated with the main application process that
+     * hosts the user interface.  This is normally true unless the scanning service or another servide
+     * is running in a separate process.
+     * @return
+     */
+    public boolean isMainProcess() {
+        return mMainProcess;
+    }
+
+    /**
+     * 
+     * Determines if this BeaconManager instance is not part of the process hosting the beacon scanning
+     * service.  This is normally false, except when scanning is hosted in a different process.
+     * This will always return false until the scanning service starts up, at which time it will be
+     * known if it is in a different process.
+     *
+     * @return
+     */
+    public boolean isScannerInDifferentProcess() {
+        // may be null if service not started yet, so explicitly check
+        return mScannerInSameProcess != null && !mScannerInSameProcess;
+    }
+
+    /**
+     * Reserved for internal use by the library.
+     * @hide
+     */
+    public void setScannerInSameProcess(boolean isScanner) {
+        mScannerInSameProcess = isScanner;
+    }
+
+    protected void checkIfMainProcess() {
+        ProcessUtils processUtils = new ProcessUtils(mContext);
+        String processName = processUtils.getProcessName();
+        String packageName = processUtils.getPackageName();
+        int pid = processUtils.getPid();
+        mMainProcess = processUtils.isMainProcess();
+        LogManager.i(TAG, "BeaconManager started up on pid "+pid+" named '"+processName+"' for application package '"+packageName+"'.  isMainProcess="+mMainProcess);
+    }
 
    /**
      * Gets a list of the active beaconParsers.
      *
      * @return list of active BeaconParsers
      */
+   @NonNull
     public List<BeaconParser> getBeaconParsers() {
         return beaconParsers;
     }
@@ -345,7 +434,7 @@ public boolean checkAvailability() throws BleNotAvailableException {
      *
      * @param consumer the <code>Activity</code> or <code>Service</code> that will receive the callback when the service is ready.
      */
-    public void bind(BeaconConsumer consumer) {
+    public void bind(@NonNull BeaconConsumer consumer) {
         if (!isBleAvailable()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
@@ -361,9 +450,16 @@ public void bind(BeaconConsumer consumer) {
                 LogManager.d(TAG, "This consumer is already bound");
             }
             else {
-                LogManager.d(TAG, "This consumer is not bound.  binding: %s", consumer);
-                Intent intent = new Intent(consumer.getApplicationContext(), BeaconService.class);
-                consumer.bindService(intent, newConsumerInfo.beaconServiceConnection, Context.BIND_AUTO_CREATE);
+                LogManager.d(TAG, "This consumer is not bound.  Binding now: %s", consumer);
+                if (mScheduledScanJobsEnabled) {
+                    LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
+                    consumer.onBeaconServiceConnect();
+                }
+                else {
+                    LogManager.d(TAG, "Binding to service");
+                    Intent intent = new Intent(consumer.getApplicationContext(), BeaconService.class);
+                    consumer.bindService(intent, newConsumerInfo.beaconServiceConnection, Context.BIND_AUTO_CREATE);
+                }
                 LogManager.d(TAG, "consumer count is now: %s", consumers.size());
             }
         }
@@ -375,7 +471,7 @@ public void bind(BeaconConsumer consumer) {
      *
      * @param consumer the <code>Activity</code> or <code>Service</code> that no longer needs to use the service.
      */
-    public void unbind(BeaconConsumer consumer) {
+    public void unbind(@NonNull BeaconConsumer consumer) {
         if (!isBleAvailable()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
@@ -383,7 +479,12 @@ public void unbind(BeaconConsumer consumer) {
         synchronized (consumers) {
             if (consumers.containsKey(consumer)) {
                 LogManager.d(TAG, "Unbinding");
-                consumer.unbindService(consumers.get(consumer).beaconServiceConnection);
+                if (mScheduledScanJobsEnabled) {
+                    LogManager.d(TAG, "Not unbinding from scanning service as we are using scan jobs.");
+                }
+                else {
+                    consumer.unbindService(consumers.get(consumer).beaconServiceConnection);
+                }
                 consumers.remove(consumer);
                 if (consumers.size() == 0) {
                     // If this is the last consumer to disconnect, the service will exit
@@ -393,6 +494,11 @@ public void unbind(BeaconConsumer consumer) {
                     // This way when we restart ranging or monitoring it will always be in
                     // foreground mode
                     mBackgroundMode = false;
+                    // If we are using scan jobs, we cancel the active scan job
+                    if (mScheduledScanJobsEnabled) {
+                        // TODO: Cancel the active scan job.  Without this is keeps scanning as if
+                        // a consumer is bound.
+                    }
                 }
             }
             else {
@@ -412,9 +518,12 @@ public void unbind(BeaconConsumer consumer) {
      * @param consumer
      * @return
      */
-    public boolean isBound(BeaconConsumer consumer) {
+    public boolean isBound(@NonNull BeaconConsumer consumer) {
         synchronized(consumers) {
-            return consumer != null && consumers.get(consumer) != null && (serviceMessenger != null);
+            // Annotation doesn't guarantee we get a non-null, but raising an NPE here is excessive
+            //noinspection ConstantConditions
+            return consumer != null && consumers.get(consumer) != null &&
+                    (mScheduledScanJobsEnabled || serviceMessenger != null);
         }
     }
 
@@ -425,7 +534,8 @@ public boolean isBound(BeaconConsumer consumer) {
      */
     public boolean isAnyConsumerBound() {
         synchronized(consumers) {
-            return consumers.size() > 0 && (serviceMessenger != null);
+            return !consumers.isEmpty() &&
+                    (mScheduledScanJobsEnabled || serviceMessenger != null);
         }
     }
 
@@ -464,6 +574,55 @@ public void setBackgroundMode(boolean backgroundMode) {
         }
     }
 
+    /**
+     * Configures using a `ScanJob` run with the `JobScheduler` to perform scans rather than using a
+     * long-running `BeaconService` to do so.
+     *
+     * Calling with true on devices older than Android L (5.0) will not apply the change
+     * as the JobScheduler is not available.
+     *
+     * This value defaults to true on Android O+ and false on devices with older OS versions.
+     * Accepting the default value of false is recommended on Android N and earlier because
+     * otherwise beacon scans may be run only once every 15 minutes in the background, and no low
+     * power scans may be performed between scanning cycles.
+     *
+     * This method may only be called if bind() has not yet been called, otherwise an
+     * `IllegalStateException` is thown.
+     *
+     * @param enabled
+     */
+    public void setEnableScheduledScanJobs(boolean enabled) {
+        if (isAnyConsumerBound()) {
+            LogManager.e(TAG, "ScanJob may not be configured because a consumer is" +
+                    " already bound.");
+            throw new IllegalStateException("Method must be called before calling bind()");
+        }
+        if (enabled && android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            LogManager.e(TAG, "ScanJob may not be configured because JobScheduler is not" +
+                    " availble prior to Android 5.0");
+            return;
+        }
+        mScheduledScanJobsEnabled = enabled;
+    }
+    public boolean getScheduledScanJobsEnabled() {
+        return mScheduledScanJobsEnabled;
+    }
+    public boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+    public long getBackgroundScanPeriod() {
+        return backgroundScanPeriod;
+    }
+    public long getBackgroundBetweenScanPeriod() {
+        return backgroundBetweenScanPeriod;
+    }
+    public long getForegroundScanPeriod() {
+        return foregroundScanPeriod;
+    }
+    public long getForegroundBetweenScanPeriod() {
+        return foregroundBetweenScanPeriod;
+    }
+
     /**
      * @return indicator of whether any calls have yet been made to set the
      * background mode
@@ -485,11 +644,11 @@ public boolean isBackgroundModeUninitialized() {
      * @deprecated replaced by (@link #addRangeNotifier)
      */
     @Deprecated
-    public void setRangeNotifier(RangeNotifier notifier) {
-        synchronized (rangeNotifiers) {
-            rangeNotifiers.clear();
+    public void setRangeNotifier(@Nullable RangeNotifier notifier) {
+        rangeNotifiers.clear();
+        if (null != notifier) {
+            addRangeNotifier(notifier);
         }
-        addRangeNotifier(notifier);
     }
 
     /**
@@ -503,11 +662,10 @@ public void setRangeNotifier(RangeNotifier notifier) {
      * @param notifier The {@link RangeNotifier} to register.
      * @see RangeNotifier
      */
-    public void addRangeNotifier(RangeNotifier notifier) {
+    public void addRangeNotifier(@NonNull RangeNotifier notifier) {
+        //noinspection ConstantConditions
         if (notifier != null) {
-            synchronized (rangeNotifiers) {
-                rangeNotifiers.add(notifier);
-            }
+            rangeNotifiers.add(notifier);
         }
     }
 
@@ -517,19 +675,15 @@ public void addRangeNotifier(RangeNotifier notifier) {
      * @param notifier The {@link RangeNotifier} to unregister.
      * @see RangeNotifier
      */
-    public boolean removeRangeNotifier(RangeNotifier notifier) {
-        synchronized (rangeNotifiers) {
-            return rangeNotifiers.remove(notifier);
-        }
+    public boolean removeRangeNotifier(@NonNull RangeNotifier notifier) {
+        return rangeNotifiers.remove(notifier);
     }
 
     /**
      * Remove all the Range Notifiers.
      */
     public void removeAllRangeNotifiers() {
-        synchronized (rangeNotifiers) {
-            rangeNotifiers.clear();
-        }
+        rangeNotifiers.clear();
     }
 
     /**
@@ -547,11 +701,14 @@ public void removeAllRangeNotifiers() {
      * @deprecated replaced by {@link #addMonitorNotifier}
      */
     @Deprecated
-    public void setMonitorNotifier(MonitorNotifier notifier) {
-        synchronized (monitorNotifiers) {
-            monitorNotifiers.clear();
+    public void setMonitorNotifier(@Nullable MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        monitorNotifiers.clear();
+        if (null != notifier) {
+            addMonitorNotifier(notifier);
         }
-        addMonitorNotifier(notifier);
     }
 
     /**
@@ -567,11 +724,13 @@ public void setMonitorNotifier(MonitorNotifier notifier) {
      * @see #startMonitoringBeaconsInRegion(Region)
      * @see Region
      */
-    public void addMonitorNotifier(MonitorNotifier notifier) {
+    public void addMonitorNotifier(@NonNull MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        //noinspection ConstantConditions
         if (notifier != null) {
-            synchronized (monitorNotifiers) {
-                monitorNotifiers.add(notifier);
-            }
+            monitorNotifiers.add(notifier);
         }
     }
 
@@ -580,7 +739,7 @@ public void addMonitorNotifier(MonitorNotifier notifier) {
      * @deprecated Misspelled. Replaced by {@link #removeMonitorNotifier}
      */
     @Deprecated
-    public boolean removeMonitoreNotifier(MonitorNotifier notifier) {
+    public boolean removeMonitoreNotifier(@NonNull MonitorNotifier notifier) {
         return removeMonitorNotifier(notifier);
     }
 
@@ -592,19 +751,21 @@ public boolean removeMonitoreNotifier(MonitorNotifier notifier) {
      * @see #startMonitoringBeaconsInRegion(Region)
      * @see Region
      */
-    public boolean removeMonitorNotifier(MonitorNotifier notifier) {
-        synchronized (monitorNotifiers) {
-            return monitorNotifiers.remove(notifier);
+    public boolean removeMonitorNotifier(@NonNull MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return false;
         }
+        return monitorNotifiers.remove(notifier);
     }
 
     /**
      * Remove all the Monitor Notifiers.
      */
     public void removeAllMonitorNotifiers() {
-        synchronized (monitorNotifiers) {
-            monitorNotifiers.clear();
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
+        monitorNotifiers.clear();
     }
 
     /**
@@ -626,11 +787,23 @@ public void setRegionStatePeristenceEnabled(boolean enabled) {
      * @param enabled true to enable the region state persistence, false to disable it.
      */
     public void setRegionStatePersistenceEnabled(boolean enabled) {
-        if (enabled) {
-            MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
-        } else {
-            MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+        mRegionStatePersistenceEnabled = enabled;
+        if (!isScannerInDifferentProcess()) {
+            if (enabled) {
+                MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
+            } else {
+                MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+            }
         }
+        this.applySettings();
+    }
+
+    /**
+     * Indicates whether region state preservation is enabled
+     * @return
+     */
+    public boolean isRegionStatePersistenceEnabled() {
+        return mRegionStatePersistenceEnabled;
     }
 
     /**
@@ -639,17 +812,18 @@ public void setRegionStatePersistenceEnabled(boolean enabled) {
      * method.  If it is not a monitored region, it will be ignored.
      * @param region
      */
-    public void requestStateForRegion(Region region) {
+    public void requestStateForRegion(@NonNull Region region) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         MonitoringStatus status = MonitoringStatus.getInstanceForApplication(mContext);
         RegionMonitoringState stateObj = status.stateOf(region);
         int state = MonitorNotifier.OUTSIDE;
         if (stateObj != null && stateObj.getInside()) {
             state = MonitorNotifier.INSIDE;
         }
-        synchronized (monitorNotifiers) {
-            for (MonitorNotifier notifier: monitorNotifiers) {
-                notifier.didDetermineStateForRegion(state, region);
-            }
+        for (MonitorNotifier notifier : monitorNotifiers) {
+            notifier.didDetermineStateForRegion(state, region);
         }
     }
 
@@ -666,27 +840,31 @@ public void requestStateForRegion(Region region) {
      * @see Region
      */
     @TargetApi(18)
-    public void startRangingBeaconsInRegion(Region region) throws RemoteException {
+    public void startRangingBeaconsInRegion(@NonNull Region region) throws RemoteException {
         if (!isBleAvailable()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
-        Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-        StartRMData obj;
-        if (this.isRangeUpdateMidCycle()) {
-            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
-        }
-        else {
-            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
-        msg.obj = obj;
-        serviceMessenger.send(msg);
+//<<<<<<< HEAD
+//        Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
+//        StartRMData obj;
+//        if (this.isRangeUpdateMidCycle()) {
+//            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
+//        }
+//        else {
+//            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+//        }
+//        msg.obj = obj;
+//        serviceMessenger.send(msg);
+//=======
+//>>>>>>> f350af4e40d96d8538ccefae5f24a9029f6ad5ed
         synchronized (rangedRegions) {
             rangedRegions.add(region);
         }
+        applyChangesToServices(BeaconService.MSG_START_RANGING, region);
     }
 
     /**
@@ -700,24 +878,27 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
      * @see Region
      */
     @TargetApi(18)
-    public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
+    public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteException {
         if (!isBleAvailable()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
-        }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-        StartRMData obj;
-        if (this.isRangeUpdateMidCycle()) {
-            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
-        }
-        else {
-            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
-        msg.obj = obj;
-        serviceMessenger.send(msg);
+//<<<<<<< HEAD
+//        Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
+//        StartRMData obj;
+//        if (this.isRangeUpdateMidCycle()) {
+//            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
+//        }
+//        else {
+//            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+//        }
+//        msg.obj = obj;
+//        serviceMessenger.send(msg);
+//=======
+//>>>>>>> f350af4e40d96d8538ccefae5f24a9029f6ad5ed
         synchronized (rangedRegions) {
             Region regionToRemove = null;
             for (Region rangedRegion : rangedRegions) {
@@ -727,6 +908,38 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             }
             rangedRegions.remove(regionToRemove);
         }
+        applyChangesToServices(BeaconService.MSG_STOP_RANGING, region);
+    }
+
+    /**
+     * Call this method if you are running the scanner service in a different process in order to
+     * synchronize any configuration settings, including BeaconParsers to the scanner
+     * @see #isScannerInDifferentProcess()
+     */
+    public void applySettings() {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        if (!isAnyConsumerBound()) {
+            LogManager.d(TAG, "Not synchronizing settings to service, as it has not started up yet");
+        } else if (isScannerInDifferentProcess()) {
+            LogManager.d(TAG, "Synchronizing settings to service");
+            syncSettingsToService();
+        } else {
+            LogManager.d(TAG, "Not synchronizing settings to service, as it is in the same process");
+        }
+    }
+
+    protected void syncSettingsToService() {
+        if (mScheduledScanJobsEnabled) {
+            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            return;
+        }
+        try {
+            applyChangesToServices(BeaconService.MSG_SYNC_SETTINGS, null);
+        } catch (RemoteException e) {
+            LogManager.e(TAG, "Failed to sync settings to service", e);
+        }
     }
 
     /**
@@ -741,25 +954,36 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
      * @see Region
      */
     @TargetApi(18)
-    public void startMonitoringBeaconsInRegion(Region region) throws RemoteException {
+    public void startMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteException {
         if (!isBleAvailable()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
-        LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
-        Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-        StartRMData obj = null;
-        if (this.isRangeUpdateMidCycle()) {
-            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
+        if (mScheduledScanJobsEnabled) {
+            MonitoringStatus.getInstanceForApplication(mContext).addRegion(region, new Callback(callbackPackageName()));
         }
-        else {
-            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        applyChangesToServices(BeaconService.MSG_START_MONITORING, region);
+
+        if (isScannerInDifferentProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
         }
-        msg.obj = obj;
-        serviceMessenger.send(msg);
+//<<<<<<< HEAD
+        LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
+//        Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
+//        StartRMData obj = null;
+//        if (this.isRangeUpdateMidCycle()) {
+//            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
+//        }
+//        else {
+//            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+//        }
+//        msg.obj = obj;
+//        serviceMessenger.send(msg);
+//=======
+//>>>>>>> f350af4e40d96d8538ccefae5f24a9029f6ad5ed
         this.requestStateForRegion(region);
     }
 
@@ -775,27 +999,36 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
      * @see Region
      */
     @TargetApi(18)
-    public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException {
+    public void stopMonitoringBeaconsInRegion(@NonNull Region region) throws RemoteException {
         if (!isBleAvailable()) {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-        StartRMData obj;
-        if (this.isRangeUpdateMidCycle()) {
-            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
+        if (mScheduledScanJobsEnabled) {
+            MonitoringStatus.getInstanceForApplication(mContext).removeRegion(region);
         }
-        else {
-            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        applyChangesToServices(BeaconService.MSG_STOP_MONITORING, region);
+        if (isScannerInDifferentProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
         }
-        msg.obj = obj;
-        serviceMessenger.send(msg);
+//<<<<<<< HEAD
+//        Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
+//        StartRMData obj;
+//        if (this.isRangeUpdateMidCycle()) {
+//            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
+//        }
+//        else {
+//            obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+//        }
+//        msg.obj = obj;
+//        serviceMessenger.send(msg);
+//=======
+//>>>>>>> f350af4e40d96d8538ccefae5f24a9029f6ad5ed
     }
 
-
     /**
      * Updates an already running scan with scanPeriod/betweenScanPeriod according to Background/Foreground state.
      * Change will take effect on the start of the next scan cycle.
@@ -808,21 +1041,56 @@ public void updateScanPeriods() throws RemoteException {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
-        if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
         }
-        Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
         LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
         LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
-        StartRMData obj;
-        if (this.isRangeUpdateMidCycle()) {
-            obj = new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
+//<<<<<<< HEAD
+//        StartRMData obj;
+//        if (this.isRangeUpdateMidCycle()) {
+//            obj = new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod());
+//        }
+//        else
+//        {
+//            obj = new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+//        }
+//        msg.obj = obj;
+//=======
+        applyChangesToServices(BeaconService.MSG_SET_SCAN_PERIODS, null);
+    }
+
+    @TargetApi(18)
+    private void applyChangesToServices(int type, Region region) throws RemoteException {
+        if (mScheduledScanJobsEnabled) {
+            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            return;
+        }
+        if (serviceMessenger == null) {
+            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+        }
+        Message msg = Message.obtain(null, type, 0, 0);
+
+        if (type == BeaconService.MSG_SET_SCAN_PERIODS) {
+            if (this.isRangeUpdateMidCycle()) {
+                msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod()).toBundle());
+            }
+            else {
+                msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
+            }
+        }
+        else if (type == BeaconService.MSG_SYNC_SETTINGS) {
+            msg.setData(new SettingsData().collect(mContext).toBundle());
         }
-        else
-        {
-            obj = new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
+        else {
+            if (this.isRangeUpdateMidCycle()) {
+                msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(), mBackgroundMode, this.getRangeUpdatePeriod(), this.getBetweenRangeUpdatePeriod()).toBundle());
+            }
+            else {
+                msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(), mBackgroundMode).toBundle());
+            }
         }
-        msg.obj = obj;
+//>>>>>>> f350af4e40d96d8538ccefae5f24a9029f6ad5ed
         serviceMessenger.send(msg);
     }
 
@@ -837,20 +1105,33 @@ private String callbackPackageName() {
      * @deprecated replaced by (@link #getMonitorNotifiers)
      */
     @Deprecated
+    @Nullable
     public MonitorNotifier getMonitoringNotifier() {
-        synchronized (monitorNotifiers) {
-            if (monitorNotifiers.size() > 0) {
-                return monitorNotifiers.iterator().next();
-            }
-            return null;
+        Iterator<MonitorNotifier> iterator = monitorNotifiers.iterator();
+        if (iterator.hasNext()) {
+            return iterator.next();
         }
+        return null;
     }
 
     /**
-     * @return the list of registered monitorNotifier
+     * Read-only access to the registered {@link MonitorNotifier} instances
+     * <p>
+     * This provides a thread-safe "read-only" view of the {@link Set} of registered monitor
+     * notifiers. Attempts to modify the returned set, or its iterator, will throw an
+     * {@link UnsupportedOperationException}. Modifications to the underlying set should be made
+     * through {@link #addMonitorNotifier(MonitorNotifier)} and
+     * {@link #removeMonitorNotifier(MonitorNotifier)}.
+     *
+     * @return a thread-safe {@linkplain Collections#unmodifiableSet(Set) unmodifiable view}
+     * providing "read-only" access to the registered {@link MonitorNotifier} instances
+     * @see #addMonitorNotifier(MonitorNotifier)
+     * @see #removeMonitorNotifier(MonitorNotifier)
+     * @see Collections#unmodifiableSet(Set)
      */
+    @NonNull
     public Set<MonitorNotifier> getMonitoringNotifiers(){
-        return monitorNotifiers;
+        return Collections.unmodifiableSet(monitorNotifiers);
     }
 
     /**
@@ -858,25 +1139,39 @@ public MonitorNotifier getMonitoringNotifier() {
      * @deprecated replaced by (@link #getRangeNotifiers)
      */
     @Deprecated
+    @Nullable
     public RangeNotifier getRangingNotifier() {
-        synchronized (rangeNotifiers) {
-            if (rangeNotifiers.size() > 0) {
-                return rangeNotifiers.iterator().next();
-            }
-            return null;
+        Iterator<RangeNotifier> iterator = rangeNotifiers.iterator();
+        if (iterator.hasNext()) {
+            return iterator.next();
         }
+        return null;
     }
 
     /**
-     * @return the list of registered rangeNotifier
+     * Read-only access to the registered {@link RangeNotifier} instances
+     * <p>
+     * This provides a thread-safe "read-only" view of the {@link Set} of registered range
+     * notifiers. Attempts to modify the returned set, or its iterator, will throw an
+     * {@link UnsupportedOperationException}. Modifications to the underlying set should be made
+     * through {@link #addRangeNotifier(RangeNotifier)} and
+     * {@link #removeRangeNotifier(RangeNotifier)}.
+     *
+     * @return a thread-safe {@linkplain Collections#unmodifiableSet(Set) unmodifiable view}
+     * providing "read-only" access to the registered {@link RangeNotifier} instances
+     * @see #addRangeNotifier(RangeNotifier)
+     * @see #removeRangeNotifier(RangeNotifier)
+     * @see Collections#unmodifiableSet(Set)
      */
+    @NonNull
     public Set<RangeNotifier> getRangingNotifiers() {
-        return rangeNotifiers;
+        return Collections.unmodifiableSet(rangeNotifiers);
     }
 
     /**
      * @return the list of regions currently being monitored
      */
+    @NonNull
     public Collection<Region> getMonitoredRegions() {
         return MonitoringStatus.getInstanceForApplication(mContext).regions();
     }
@@ -884,9 +1179,10 @@ public RangeNotifier getRangingNotifier() {
     /**
      * @return the list of regions currently being ranged
      */
+    @NonNull
     public Collection<Region> getRangedRegions() {
         synchronized(this.rangedRegions) {
-            return new ArrayList<Region>(this.rangedRegions);
+            return new ArrayList<>(this.rangedRegions);
         }
     }
 
@@ -918,6 +1214,7 @@ public static void logDebug(String tag, String message, Throwable t) {
         LogManager.d(t, tag, message);
     }
 
+    @Nullable
     protected static BeaconSimulator beaconSimulator;
 
     protected static String distanceModelUpdateUrl = "http://data.altbeacon.org/android-distance.json";
@@ -926,7 +1223,8 @@ public static String getDistanceModelUpdateUrl() {
         return distanceModelUpdateUrl;
     }
 
-    public static void setDistanceModelUpdateUrl(String url) {
+    public static void setDistanceModelUpdateUrl(@NonNull String url) {
+        warnIfScannerNotInSameProcess();
         distanceModelUpdateUrl = url;
     }
 
@@ -935,7 +1233,8 @@ public static void setDistanceModelUpdateUrl(String url) {
      */
     protected static Class rssiFilterImplClass = RunningAverageRssiFilter.class;
 
-    public static void setRssiFilterImplClass(Class c) {
+    public static void setRssiFilterImplClass(@NonNull Class c) {
+        warnIfScannerNotInSameProcess();
         rssiFilterImplClass = c;
     }
 
@@ -949,6 +1248,9 @@ public static Class getRssiFilterImplClass() {
      */
     public static void setUseTrackingCache(boolean useTrackingCache) {
         RangeState.setUseTrackingCache(useTrackingCache);
+        if (sInstance != null) {
+            sInstance.applySettings();
+        }
     }
 
     /**
@@ -961,27 +1263,31 @@ public void setMaxTrackingAge(int maxTrackingAge) {
     }
 
     public static void setBeaconSimulator(BeaconSimulator beaconSimulator) {
+        warnIfScannerNotInSameProcess();
         BeaconManager.beaconSimulator = beaconSimulator;
     }
 
+    @Nullable
     public static BeaconSimulator getBeaconSimulator() {
         return BeaconManager.beaconSimulator;
     }
 
 
-    protected void setDataRequestNotifier(RangeNotifier notifier) {
+    protected void setDataRequestNotifier(@Nullable RangeNotifier notifier) {
         this.dataRequestNotifier = notifier;
     }
 
+    @Nullable
     protected RangeNotifier getDataRequestNotifier() {
         return this.dataRequestNotifier;
     }
 
+    @Nullable
     public NonBeaconLeScanCallback getNonBeaconLeScanCallback() {
         return mNonBeaconLeScanCallback;
     }
 
-    public void setNonBeaconLeScanCallback(NonBeaconLeScanCallback callback) {
+    public void setNonBeaconLeScanCallback(@Nullable NonBeaconLeScanCallback callback) {
         mNonBeaconLeScanCallback = callback;
     }
 
@@ -1043,16 +1349,18 @@ private long getBetweenRangeUpdatePeriod() {
     private void verifyServiceDeclaration() {
         final PackageManager packageManager = mContext.getPackageManager();
         final Intent intent = new Intent(mContext, BeaconService.class);
-        List resolveInfo =
+        List<ResolveInfo> resolveInfo =
                 packageManager.queryIntentServices(intent,
                         PackageManager.MATCH_DEFAULT_ONLY);
-        if (resolveInfo.size() == 0) {
+        if (resolveInfo != null && resolveInfo.isEmpty()) {
             throw new ServiceNotDeclaredException();
         }
     }
 
     private class ConsumerInfo {
         public boolean isConnected = false;
+
+        @NonNull
         public BeaconServiceConnection beaconServiceConnection;
 
         public ConsumerInfo() {
@@ -1068,7 +1376,12 @@ private BeaconServiceConnection() {
         // Called when the connection with the service is established
         public void onServiceConnected(ComponentName className, IBinder service) {
             LogManager.d(TAG, "we have a connection to the service now");
+            if (mScannerInSameProcess == null) {
+                mScannerInSameProcess = false;
+            }
             serviceMessenger = new Messenger(service);
+            // This will sync settings to the scanning service if it is in a different process
+            applySettings();
             synchronized(consumers) {
                 Iterator<Map.Entry<BeaconConsumer, ConsumerInfo>> iter = consumers.entrySet().iterator();
                 while (iter.hasNext()) {
@@ -1114,6 +1427,20 @@ public static boolean isAndroidLScanningDisabled() {
      */
     public static void setAndroidLScanningDisabled(boolean disabled) {
         sAndroidLScanningDisabled = disabled;
+        BeaconManager instance = sInstance;
+        if (instance != null) {
+            instance.applySettings();
+        }
+    }
+
+    /**
+     * Deprecated misspelled method
+     * @see #setManifestCheckingDisabled(boolean)
+     * @param disabled
+     */
+    @Deprecated
+    public static void setsManifestCheckingDisabled(boolean disabled) {
+        sManifestCheckingDisabled = disabled;
     }
 
     /**
@@ -1122,7 +1449,33 @@ public static void setAndroidLScanningDisabled(boolean disabled) {
      *
      * @param disabled
      */
-    public static void setsManifestCheckingDisabled(boolean disabled) {
+    public static void setManifestCheckingDisabled(boolean disabled) {
         sManifestCheckingDisabled = disabled;
     }
+
+    /**
+     * Returns whether manifest checking is disabled
+     */
+    public static boolean getManifestCheckingDisabled() {
+        return sManifestCheckingDisabled;
+    }
+
+    private boolean determineIfCalledFromSeparateScannerProcess() {
+        if (isScannerInDifferentProcess() && !isMainProcess()) {
+            LogManager.w(TAG, "Ranging/Monitoring may not be controlled from a separate "+
+                    "BeaconScanner process.  To remove this warning, please wrap this call in:"+
+                    " if (beaconManager.isMainProcess())");
+            return true;
+        }
+        return false;
+    }
+
+    private static void warnIfScannerNotInSameProcess() {
+        BeaconManager instance = sInstance;
+        if (instance != null && instance.isScannerInDifferentProcess()) {
+            LogManager.w(TAG,
+                    "Unsupported configuration change made for BeaconScanner in separate process");
+        }
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index c049b994..8591db4e 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -9,6 +9,7 @@
 import org.altbeacon.bluetooth.BleAdvertisement;
 import org.altbeacon.bluetooth.Pdu;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -36,7 +37,7 @@
  * </p>
  *
  */
-public class BeaconParser {
+public class BeaconParser implements Serializable {
     private static final String TAG = "BeaconParser";
     public static final String ALTBEACON_LAYOUT = "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25";
     public static final String EDDYSTONE_TLM_LAYOUT = "x,s:0-1=feaa,m:2-2=20,d:3-3,d:4-5,d:6-7,d:8-11,d:12-15";
@@ -53,6 +54,7 @@
     private static final String LITTLE_ENDIAN_SUFFIX = "l";
     private static final String VARIABLE_LENGTH_SUFFIX = "v";
 
+    protected String mBeaconLayout;
     private Long mMatchingBeaconTypeCode;
     protected final List<Integer> mIdentifierStartOffsets = new ArrayList<Integer>();
     protected final List<Integer> mIdentifierEndOffsets = new ArrayList<Integer>();
@@ -165,7 +167,7 @@ public BeaconParser(String identifier) {
      * @return the BeaconParser instance
      */
     public BeaconParser setBeaconLayout(String beaconLayout) {
-
+        mBeaconLayout = beaconLayout;
         Log.d(TAG, "Parsing beacon layout: "+beaconLayout);
 
         String[] terms =  beaconLayout.split(",");
@@ -756,6 +758,13 @@ public int getDataFieldCount() {
         return mDataStartOffsets.size();
     }
 
+    /**
+     * @return the layout string for the parser
+     */
+    public String getLayout() {
+        return mBeaconLayout;
+    }
+
     /**
      * @return the correction value in dBm to apply to the calibrated txPower to get a 1m calibrated value.
      * Some formats like Eddystone use a 0m calibrated value, which requires this correction
@@ -924,4 +933,20 @@ public int hashCode() {
             }
         );
     }
+
+    @Override
+    public boolean equals(Object o) {
+        BeaconParser that = null;
+        try {
+            that = (BeaconParser) o;
+            if (that.mBeaconLayout != null && that.mBeaconLayout.equals(this.mBeaconLayout)) {
+                if (that.mIdentifier != null && that.mIdentifier.equals(this.mIdentifier)) {
+                    return true;
+                }
+            }
+        }
+        catch (ClassCastException e ) { }
+        return false;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/Identifier.java b/src/main/java/org/altbeacon/beacon/Identifier.java
index 8112cc4f..d96e567a 100644
--- a/src/main/java/org/altbeacon/beacon/Identifier.java
+++ b/src/main/java/org/altbeacon/beacon/Identifier.java
@@ -3,6 +3,8 @@
 import android.annotation.TargetApi;
 import android.os.Build;
 
+import org.altbeacon.beacon.logging.LogManager;
+
 import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.LongBuffer;
@@ -315,17 +317,23 @@ public boolean equals(Object that) {
         return Arrays.equals(mValue, thatIdentifier.mValue);
     }
 
+    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+
     /**
      * Represents the value as a hexadecimal String. The String is prefixed with <code>0x</code>. For example 0x0034ab
      * @return value as hexadecimal String
      */
     public String toHexString() {
-        StringBuilder sb = new StringBuilder(2 + 2 * mValue.length);
-        sb.append("0x");
-        for (byte item : mValue) {
-            sb.append(String.format("%02x", item));
+        final int l = mValue.length;
+        final char[] out = new char[l*2+2];
+        out[0] = '0';
+        out[1] = 'x';
+        for( int i=0,j=2; i<l; i++ ){
+            out[j++] = HEX_DIGITS[(0xF0 & mValue[i]) >>> 4];
+            out[j++] = HEX_DIGITS[0x0F & mValue[i]];
         }
-        return sb.toString();
+        String s = new String(out);
+        return s;
     }
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/IntentHandler.java b/src/main/java/org/altbeacon/beacon/IntentHandler.java
new file mode 100644
index 00000000..6e6c84a7
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/IntentHandler.java
@@ -0,0 +1,85 @@
+package org.altbeacon.beacon;
+
+import android.content.Context;
+import android.content.Intent;
+
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.MonitoringData;
+import org.altbeacon.beacon.service.MonitoringStatus;
+import org.altbeacon.beacon.service.RangingData;
+
+import java.util.Set;
+
+/**
+ * Converts internal Intents for ranging/monitoring to notifier callbacks.
+ * These may be local broadcast intents from BeaconLocalBroadcastProcessor or
+ * global broadcast intents fro BeaconIntentProcessor
+ *
+ * Internal library class.  Do not use directly from outside the library
+ *
+ * @hide
+ * Created by dyoung on 7/20/17.
+ */
+
+/* package private*/
+class IntentHandler {
+    private static final String TAG = IntentHandler.class.getSimpleName();
+    public void convertIntentsToCallbacks(Context context, Intent intent) {
+        MonitoringData monitoringData = null;
+        RangingData rangingData = null;
+
+        if (intent != null && intent.getExtras() != null) {
+            if (intent.getExtras().getBundle("monitoringData") != null) {
+                monitoringData = MonitoringData.fromBundle(intent.getExtras().getBundle("monitoringData"));
+            }
+            if (intent.getExtras().getBundle("rangingData") != null) {
+                rangingData = RangingData.fromBundle(intent.getExtras().getBundle("rangingData"));
+            }
+        }
+
+        if (rangingData != null) {
+            LogManager.d(TAG, "got ranging data");
+            if (rangingData.getBeacons() == null) {
+                LogManager.w(TAG, "Ranging data has a null beacons collection");
+            }
+            Set<RangeNotifier> notifiers = BeaconManager.getInstanceForApplication(context).getRangingNotifiers();
+            java.util.Collection<Beacon> beacons = rangingData.getBeacons();
+            if (notifiers != null) {
+                for(RangeNotifier notifier : notifiers){
+                    notifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
+                }
+            }
+            else {
+                LogManager.d(TAG, "but ranging notifier is null, so we're dropping it.");
+            }
+            RangeNotifier dataNotifier = BeaconManager.getInstanceForApplication(context).getDataRequestNotifier();
+            if (dataNotifier != null) {
+                dataNotifier.didRangeBeaconsInRegion(beacons, rangingData.getRegion());
+            }
+        }
+
+        if (monitoringData != null) {
+            LogManager.d(TAG, "got monitoring data");
+            Set<MonitorNotifier> notifiers = BeaconManager.getInstanceForApplication(context).getMonitoringNotifiers();
+            if (notifiers != null) {
+                for(MonitorNotifier notifier : notifiers) {
+                    LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
+                    Region region = monitoringData.getRegion();
+                    Integer state = monitoringData.isInside() ? MonitorNotifier.INSIDE :
+                            MonitorNotifier.OUTSIDE;
+                    notifier.didDetermineStateForRegion(state, region);
+                    // In case the beacon scanner is running in a separate process, the monitoring
+                    // status in this process  will not have been updated yet as a result of this
+                    // region state change.  We make a call here to keep it in sync.
+                    MonitoringStatus.getInstanceForApplication(context).updateLocalState(region, state);
+                    if (monitoringData.isInside()) {
+                        notifier.didEnterRegion(monitoringData.getRegion());
+                    } else {
+                        notifier.didExitRegion(monitoringData.getRegion());
+                    }
+                }
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/Region.java b/src/main/java/org/altbeacon/beacon/Region.java
index db5886da..24b0ad62 100644
--- a/src/main/java/org/altbeacon/beacon/Region.java
+++ b/src/main/java/org/altbeacon/beacon/Region.java
@@ -51,7 +51,6 @@
 public class Region implements Parcelable, Serializable {
     private static final String TAG = "Region";
     private static final Pattern MAC_PATTERN = Pattern.compile("^[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}$");
-
     /**
      * Required to make class Parcelable
      */
@@ -309,4 +308,5 @@ private void validateMac(String mac) throws IllegalArgumentException {
     public Region clone() {
         return new Region(mUniqueId, mIdentifiers, mBluetoothAddress);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
index 42f7db77..ad4bfe73 100644
--- a/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
+++ b/src/main/java/org/altbeacon/beacon/distance/ModelSpecificDistanceCalculator.java
@@ -189,8 +189,12 @@ private boolean loadModelMapFromFile() {
             buildModelMapWithLock(sb.toString());
             return true;
         } catch (JSONException e) {
-            LogManager.e(TAG, "Cannot update distance models from online database at %s with JSON",
-                    e, mRemoteUpdateUrlString, sb.toString());
+            LogManager.e(
+                    e,
+                    TAG,
+                    "Cannot update distance models from online database at %s with JSON: %s",
+                    mRemoteUpdateUrlString, sb.toString()
+            );
             return false;
         }
     }
@@ -265,7 +269,7 @@ void buildModelMapWithLock(String jsonString) throws JSONException {
     }
 
     private void buildModelMap(String jsonString) throws JSONException {
-        mModelMap = new HashMap<AndroidModel, DistanceCalculator>();
+        HashMap<AndroidModel, DistanceCalculator> map = new HashMap<AndroidModel, DistanceCalculator>();
         JSONObject jsonObject = new JSONObject(jsonString);
         JSONArray array = jsonObject.getJSONArray("models");
         for (int i = 0; i < array.length(); i++) {
@@ -286,19 +290,20 @@ private void buildModelMap(String jsonString) throws JSONException {
                     new CurveFittedDistanceCalculator(coefficient1,coefficient2,coefficient3);
 
             AndroidModel androidModel = new AndroidModel(version, buildNumber, model, manufacturer);
-            mModelMap.put(androidModel, distanceCalculator);
+            map.put(androidModel, distanceCalculator);
             if (defaultFlag) {
                 mDefaultModel = androidModel;
             }
         }
+        mModelMap = map;
     }
 
     private void loadDefaultModelMap() {
-        mModelMap = new HashMap<AndroidModel, DistanceCalculator>();
         try {
             buildModelMap(stringFromFilePath(CONFIG_FILE));
         }
         catch (Exception e) {
+            mModelMap = new HashMap<AndroidModel, DistanceCalculator>();
             LogManager.e(e, TAG, "Cannot build model distance calculations");
         }
     }
diff --git a/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java b/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
new file mode 100644
index 00000000..2b9baec5
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import android.util.Log;
+
+/**
+ * Android logger that only logs out warning and above to the {@link android.util.Log}.
+ *
+ * @since 2.2
+ * @author Andrew Reitz
+ */
+final class InfoAndroidLogger extends AbstractAndroidLogger {
+    @Override
+    public void v(String tag, String message, Object... args) { }
+
+    @Override
+    public void v(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void d(String tag, String message, Object... args) { }
+
+    @Override
+    public void d(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void i(String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args));
+    }
+
+    @Override
+    public void i(Throwable t, String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void w(String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args));
+    }
+
+    @Override
+    public void w(Throwable t, String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void e(String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args));
+    }
+
+    @Override
+    public void e(Throwable t, String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args), t);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/LogManager.java b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
index 4500699e..8420d7a6 100644
--- a/src/main/java/org/altbeacon/beacon/logging/LogManager.java
+++ b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
@@ -24,7 +24,7 @@
  * @since 2.2
  */
 public final class LogManager {
-    private static Logger sLogger = Loggers.warningLogger();
+    private static Logger sLogger = Loggers.infoLogger();
     private static boolean sVerboseLoggingEnabled = false;
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/logging/Loggers.java b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
index 44144026..c243f62c 100644
--- a/src/main/java/org/altbeacon/beacon/logging/Loggers.java
+++ b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
@@ -30,6 +30,9 @@
     /** Debug Logger Singleton. */
     private static final Logger VERBOSE_ANDROID_LOGGER = new VerboseAndroidLogger();
 
+    /** Info Logger Singleton. */
+    private static final Logger INFO_ANDROID_LOGGER = new InfoAndroidLogger();
+
     /** Warning Logger Singleton. */
     private static final Logger WARNING_ANDROID_LOGGER = new WarningAndroidLogger();
 
@@ -48,6 +51,14 @@ public static Logger verboseLogger() {
         return VERBOSE_ANDROID_LOGGER;
     }
 
+    /**
+     * @return Get a logger that logs messages of info and greater.
+     * @see android.util.Log
+     */
+    public static Logger infoLogger() {
+        return INFO_ANDROID_LOGGER;
+    }
+
     /**
      * @return Get a logger that logs messages of warning and greater.
      * @see android.util.Log
diff --git a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
index ff6186c9..1349ad49 100644
--- a/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
+++ b/src/main/java/org/altbeacon/beacon/powersave/BackgroundPowerSaver.java
@@ -5,36 +5,37 @@
 import android.app.Application;
 import android.content.Context;
 import android.os.Bundle;
+import android.support.annotation.NonNull;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
 /**
- *
  * Simply creating an instance of this class and holding a reference to it in your Application can
  * improve battery life by 60% by slowing down scans when your app is in the background.
- *
  */
 @TargetApi(18)
 public class BackgroundPowerSaver implements Application.ActivityLifecycleCallbacks {
+    @NonNull
     private static final String TAG = "BackgroundPowerSaver";
-    private BeaconManager beaconManager;
+
+    @NonNull
+    private final BeaconManager beaconManager;
+
     private int activeActivityCount = 0;
 
     /**
-     *
      * Constructs a new BackgroundPowerSaver
      *
-     * @param context
-     * @deprecated the countActiveActivityStrategy flag is no longer used.
-     *
+     * @deprecated the {@code countActiveActivityStrategy} flag is no longer used. Use
+     * {@link #BackgroundPowerSaver(Context)}
      */
+    @Deprecated
     public BackgroundPowerSaver(Context context, boolean countActiveActivityStrategy) {
         this(context);
     }
 
     /**
-     *
      * Constructs a new BackgroundPowerSaver using the default background determination strategy
      *
      * @param context
@@ -42,7 +43,6 @@ public BackgroundPowerSaver(Context context, boolean countActiveActivityStrategy
     public BackgroundPowerSaver(Context context) {
         if (android.os.Build.VERSION.SDK_INT < 18) {
             LogManager.w(TAG, "BackgroundPowerSaver requires API 18 or higher.");
-            return;
         }
         beaconManager = BeaconManager.getInstanceForApplication(context);
         ((Application)context.getApplicationContext()).registerActivityLifecycleCallbacks(this);
@@ -70,7 +70,12 @@ public void onActivityResumed(Activity activity) {
     @Override
     public void onActivityPaused(Activity activity) {
         activeActivityCount--;
-        LogManager.d(TAG, "activity paused: %s active activities: %s", activity, activeActivityCount);
+        LogManager.d(
+                TAG,
+                "activity paused: %s active activities: %s",
+                activity,
+                activeActivityCount
+        );
         if (activeActivityCount < 1) {
             LogManager.d(TAG, "setting background mode");
             beaconManager.setBackgroundMode(true);
diff --git a/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
index 20858087..78c8eea6 100644
--- a/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/ArmaRssiFilter.java
@@ -40,6 +40,9 @@ public void addMeasurement(Integer rssi) {
         LogManager.d(TAG, "armaMeasurement: %s", armaMeasurement);
     }
 
+    @Override
+    public int getMeasurementCount() { return 0; }
+
     public boolean noMeasurementsAvailable() {
         return false;
     }
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 6a617fbc..390bcdfc 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -24,21 +24,24 @@
 package org.altbeacon.beacon.service;
 
 
-import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
 import android.app.Service;
-import android.bluetooth.BluetoothDevice;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.ApplicationInfo;
-import android.os.AsyncTask;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
 import android.os.Binder;
 import android.os.Build;
 import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
 import android.os.Message;
 import android.os.Messenger;
+import android.support.annotation.MainThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -49,24 +52,15 @@
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
-import org.altbeacon.beacon.service.scanner.CycledLeScanner;
-import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
-import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
+import org.altbeacon.beacon.utils.ProcessUtils;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
 
 import static android.app.PendingIntent.FLAG_ONE_SHOT;
 import static android.app.PendingIntent.getBroadcast;
@@ -77,22 +71,9 @@
 
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
-
-    private final Map<Region, RangeState> rangedRegionState = new HashMap<Region, RangeState>();
-    private MonitoringStatus monitoringStatus;
-
-    int trackedBeaconsPacketCount;
     private final Handler handler = new Handler();
     private BluetoothCrashResolver bluetoothCrashResolver;
-    private DistanceCalculator defaultDistanceCalculator = null;
-    private BeaconManager beaconManager;
-    private Set<BeaconParser> beaconParsers  = new HashSet<BeaconParser>();
-    private CycledLeScanner mCycledScanner;
-    private boolean mBackgroundFlag = false;
-    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
-    private ExecutorService mExecutor;
-    private final DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
-    
+    private ScanHelper mScanHelper;
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -115,8 +96,6 @@
      *
      */
 
-    private List<Beacon> simulatedScanData = null;
-
     /**
      * Class used for the client Binder.  Because we know this service always
      * runs in the same process as its clients, we don't need to deal with IPC.
@@ -137,63 +116,86 @@ public BeaconService getService() {
     public static final int MSG_START_MONITORING = 4;
     public static final int MSG_STOP_MONITORING = 5;
     public static final int MSG_SET_SCAN_PERIODS = 6;
+    public static final int MSG_SYNC_SETTINGS = 7;
 
     static class IncomingHandler extends Handler {
         private final WeakReference<BeaconService> mService;
 
         IncomingHandler(BeaconService service) {
+            /*
+             * Explicitly state this uses the main thread. Without this we defer to where the
+             * service instance is initialized/created; which is usually the main thread anyways.
+             * But by being explicit we document our code design expectations for where things run.
+             */
+            super(Looper.getMainLooper());
             mService = new WeakReference<BeaconService>(service);
         }
 
+        @MainThread
         @Override
         public void handleMessage(Message msg) {
             BeaconService service = mService.get();
-            StartRMData startRMData = (StartRMData) msg.obj;
-
             if (service != null) {
-                switch (msg.what) {
-                    case MSG_START_RANGING:
-                        LogManager.i(TAG, "start ranging received");
-                        service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        if(startRMData.hasMidCycleRangeUpdates()) {
-                            service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
-                        }
-                        break;
-                    case MSG_STOP_RANGING:
-                        LogManager.i(TAG, "stop ranging received");
-                        service.stopRangingBeaconsInRegion(startRMData.getRegionData());
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        if(startRMData.hasMidCycleRangeUpdates()) {
-                            service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
-                        }
-                        break;
-                    case MSG_START_MONITORING:
-                        LogManager.i(TAG, "start monitoring received");
-                        service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        if(startRMData.hasMidCycleRangeUpdates()) {
-                            service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
-                        }
-                        break;
-                    case MSG_STOP_MONITORING:
-                        LogManager.i(TAG, "stop monitoring received");
-                        service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        if(startRMData.hasMidCycleRangeUpdates()) {
-                            service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
-                        }
-                        break;
-                    case MSG_SET_SCAN_PERIODS:
-                        LogManager.i(TAG, "set scan intervals received");
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        if(startRMData.hasMidCycleRangeUpdates()) {
-                            service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
-                        }
-                        break;
-                    default:
-                        super.handleMessage(msg);
+                StartRMData startRMData = StartRMData.fromBundle(msg.getData());
+                if (startRMData != null) {
+                    switch (msg.what) {
+                        case MSG_START_RANGING:
+                            LogManager.i(TAG, "start ranging received");
+                            service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            if(startRMData.hasMidCycleRangeUpdates()) {
+                                service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
+                            }
+                            break;
+                        case MSG_STOP_RANGING:
+                            LogManager.i(TAG, "stop ranging received");
+                            service.stopRangingBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            if(startRMData.hasMidCycleRangeUpdates()) {
+                                service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
+                            }
+                            break;
+                        case MSG_START_MONITORING:
+                            LogManager.i(TAG, "start monitoring received");
+                            service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            if(startRMData.hasMidCycleRangeUpdates()) {
+                                service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
+                            }
+                            break;
+                        case MSG_STOP_MONITORING:
+                            LogManager.i(TAG, "stop monitoring received");
+                            service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            if(startRMData.hasMidCycleRangeUpdates()) {
+                                service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
+                            }
+                            break;
+                        case MSG_SET_SCAN_PERIODS:
+                            LogManager.i(TAG, "set scan intervals received");
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            if(startRMData.hasMidCycleRangeUpdates()) {
+                                service.setRangeUpdatePeriods(startRMData.getRangeUpdatePeriod(), startRMData.getBetweenRangeUpdatePeriod());
+                            }
+                            break;
+                        default:
+                            super.handleMessage(msg);
+                    }
                 }
+                else if (msg.what == MSG_SYNC_SETTINGS) {
+                    LogManager.i(TAG, "Received settings update from other process");
+                    SettingsData settingsData = SettingsData.fromBundle(msg.getData());
+                    if (settingsData != null) {
+                        settingsData.apply(service);
+                    }
+                    else {
+                        LogManager.w(TAG, "Settings data missing");
+                    }
+                }
+                else {
+                    LogManager.i(TAG, "Received unknown message from other process : "+msg.what);
+                }
+
             }
         }
     }
@@ -203,46 +205,51 @@ public void handleMessage(Message msg) {
      */
     final Messenger mMessenger = new Messenger(new IncomingHandler(this));
 
-
+    @MainThread
     @Override
     public void onCreate() {
-        LogManager.i(TAG, "beaconService version %s is starting up", BuildConfig.VERSION_NAME);
         bluetoothCrashResolver = new BluetoothCrashResolver(this);
         bluetoothCrashResolver.start();
 
-        // Create a private executor so we don't compete with threads used by AsyncTask
-        // This uses fewer threads than the default executor so it won't hog CPU
-        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
-
-        mCycledScanner = CycledLeScanner.createScanner(this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
-                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag, mCycledLeScanCallback, bluetoothCrashResolver);
-
-        beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        mScanHelper = new ScanHelper(this);
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(false, bluetoothCrashResolver);
+        }
+        mScanHelper.setMonitoringStatus(MonitoringStatus.getInstanceForApplication(this));
+        mScanHelper.setRangedRegionState(new HashMap<Region, RangeState>());
+        mScanHelper.setBeaconParsers(new HashSet<BeaconParser>());
+        mScanHelper.setExtraDataBeaconTracker(new ExtraDataBeaconTracker());
+
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        beaconManager.setScannerInSameProcess(true);
+        if (beaconManager.isMainProcess()) {
+            LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+        }
+        else {
+            LogManager.i(TAG, "beaconService version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(this);
+            LogManager.i(TAG, "beaconService PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
+        }
 
-        //flatMap all beacon parsers
-        boolean matchBeaconsByServiceUUID = true;
-        if (beaconManager.getBeaconParsers() != null) {
-            beaconParsers.addAll(beaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    beaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
+        try {
+            PackageItemInfo info = this.getPackageManager().getServiceInfo(new ComponentName(this, BeaconService.class), PackageManager.GET_META_DATA);
+            if (info != null && info.metaData != null && info.metaData.get("longScanForcingEnabled") != null &&
+                    info.metaData.get("longScanForcingEnabled").toString().equals("true")) {
+                LogManager.i(TAG, "longScanForcingEnabled to keep scans going on Android N for > 30 minutes");
+                mScanHelper.getCycledScanner().setLongScanForcingEnabled(true);
             }
-        }
+        } catch (PackageManager.NameNotFoundException e) {}
 
-        //initialize the extra data beacon tracker
-        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+        mScanHelper.reloadParsers();
 
-        defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
+        DistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
 
-        monitoringStatus = MonitoringStatus.getInstanceForApplication(getApplicationContext());
         // Look for simulated scan data
         try {
             Class klass = Class.forName("org.altbeacon.beacon.SimulatedScanData");
             java.lang.reflect.Field f = klass.getField("beacons");
-            this.simulatedScanData = (List<Beacon>) f.get(null);
+            mScanHelper.setSimulatedScanData((List<Beacon>) f.get(null));
         } catch (ClassNotFoundException e) {
             LogManager.d(TAG, "No org.altbeacon.beacon.SimulatedScanData class exists.");
         } catch (Exception e) {
@@ -250,7 +257,6 @@ public void onCreate() {
         }
     }
 
-
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         LogManager.i(TAG,
@@ -278,6 +284,7 @@ public boolean onUnbind(Intent intent) {
         return false;
     }
 
+    @MainThread
     @Override
     public void onDestroy() {
         LogManager.e(TAG, "onDestroy()");
@@ -288,9 +295,9 @@ public void onDestroy() {
         bluetoothCrashResolver.stop();
         LogManager.i(TAG, "onDestroy called.  stopping scanning");
         handler.removeCallbacksAndMessages(null);
-        mCycledScanner.stop();
-        mCycledScanner.destroy();
-        monitoringStatus.stopStatusPreservation();
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        mScanHelper.getMonitoringStatus().stopStatusPreservation();
     }
 
     @Override
@@ -314,237 +321,177 @@ private PendingIntent getRestartIntent() {
     /**
      * methods for clients
      */
+    @MainThread
     public void startRangingBeaconsInRegion(Region region, Callback callback) {
-        synchronized (rangedRegionState) {
-            if (rangedRegionState.containsKey(region)) {
+        synchronized (mScanHelper.getRangedRegionState()) {
+            if (mScanHelper.getRangedRegionState().containsKey(region)) {
                 LogManager.i(TAG, "Already ranging that region -- will replace existing region.");
-                rangedRegionState.remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
+                mScanHelper.getRangedRegionState().remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
             }
-            rangedRegionState.put(region, new RangeState(callback));
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+            mScanHelper.getRangedRegionState().put(region, new RangeState(callback));
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
-        mCycledScanner.start();
+        mScanHelper.getCycledScanner().start();
     }
 
+    @MainThread
     public void stopRangingBeaconsInRegion(Region region) {
         int rangedRegionCount;
-        synchronized (rangedRegionState) {
-            rangedRegionState.remove(region);
-            rangedRegionCount = rangedRegionState.size();
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+        synchronized (mScanHelper.getRangedRegionState()) {
+            mScanHelper.getRangedRegionState().remove(region);
+            rangedRegionCount = mScanHelper.getRangedRegionState().size();
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
 
-        if (rangedRegionCount == 0 && monitoringStatus.regionsCount() == 0) {
-            mCycledScanner.stop();
+        if (rangedRegionCount == 0 && mScanHelper.getMonitoringStatus().regionsCount() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
+    @MainThread
     public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
         LogManager.d(TAG, "startMonitoring called");
-        monitoringStatus.addRegion(region, callback);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        mCycledScanner.start();
+        mScanHelper.getMonitoringStatus().addRegion(region, callback);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        mScanHelper.getCycledScanner().start();
     }
 
+    @MainThread
     public void stopMonitoringBeaconsInRegion(Region region) {
         LogManager.d(TAG, "stopMonitoring called");
-        monitoringStatus.removeRegion(region);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        if (monitoringStatus.regionsCount() == 0 && rangedRegionState.size() == 0) {
-            mCycledScanner.stop();
+        mScanHelper.getMonitoringStatus().removeRegion(region);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        if (mScanHelper.getMonitoringStatus().regionsCount() == 0 && mScanHelper.getRangedRegionState().size() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
+    @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        mCycledScanner.setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
+//<<<<<<< HEAD
+        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
+//        mCycledScanner.setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
     }
 
     public void setRangeUpdatePeriods(long rangeUpdatePeriod, long betweenRangeUpdatePeriod) {
-        mCycledScanner.setRangeUpdatePeriods(rangeUpdatePeriod, betweenRangeUpdatePeriod);
+        mScanHelper.getCycledScanner().setRangeUpdatePeriods(rangeUpdatePeriod, betweenRangeUpdatePeriod);
     }
 
-    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
-        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-        @Override
-        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
-
-            NonBeaconLeScanCallback nonBeaconLeScanCallback = beaconManager.getNonBeaconLeScanCallback();
-
-            try {
-                new ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
-                        new ScanData(device, rssi, scanRecord));
-            } catch (RejectedExecutionException e) {
-                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
-            }
-        }
-
-        @Override
-        public void onMidScanRange() {
-            processRangeData();
-        }
-
-        @Override
-        public void onCycleEnd() {
-            mDistinctPacketDetector.clearDetections();
-            monitoringStatus.updateNewlyOutside();
-            processRangeData();
-            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
-            if (simulatedScanData != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
-
-                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                    for (Beacon beacon : simulatedScanData) {
-                        processBeaconFromScan(beacon);
-                    }
-                } else {
-                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
-                }
-            }
-            if (BeaconManager.getBeaconSimulator() != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
-                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
-                            processBeaconFromScan(beacon);
-                        }
-                    } else {
-                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
-                    }
-                } else {
-                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
-                }
-            }
-        }
-    };
-
-    private void processRangeData() {
-        synchronized (rangedRegionState) {
-            for (Region region : rangedRegionState.keySet()) {
-                RangeState rangeState = rangedRegionState.get(region);
-                LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region));
-            }
-        }
+//    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+//        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+//        @Override
+//        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+//
+//            NonBeaconLeScanCallback nonBeaconLeScanCallback = beaconManager.getNonBeaconLeScanCallback();
+//
+//            try {
+//                new ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
+//                        new ScanData(device, rssi, scanRecord));
+//            } catch (RejectedExecutionException e) {
+//                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+//            }
+//        }
+//
+//        @Override
+//        public void onMidScanRange() {
+//            processRangeData();
+//        }
+//
+//        @Override
+//        public void onCycleEnd() {
+//            mDistinctPacketDetector.clearDetections();
+//            monitoringStatus.updateNewlyOutside();
+//            processRangeData();
+//            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
+//            if (simulatedScanData != null) {
+//                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+//                // it will not be used if we are not in debug mode
+//                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
+//
+//                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+//                    for (Beacon beacon : simulatedScanData) {
+//                        processBeaconFromScan(beacon);
+//                    }
+//                } else {
+//                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
+//                }
+//            }
+//            if (BeaconManager.getBeaconSimulator() != null) {
+//                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+//                // it will not be used if we are not in debug mode
+//                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+//                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+//                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+//                            processBeaconFromScan(beacon);
+//                        }
+//                    } else {
+//                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+//                    }
+//                } else {
+//                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+//                }
+//            }
+//        }
+//    };
+
+//    private void processRangeData() {
+//        synchronized (rangedRegionState) {
+//            for (Region region : rangedRegionState.keySet()) {
+//                RangeState rangeState = rangedRegionState.get(region);
+//                LogManager.d(TAG, "Calling ranging callback");
+//                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region));
+//            }
+//        }
+//    }
+
+//    private void processBeaconFromScan(Beacon beacon) {
+//        if (Stats.getInstance().isEnabled()) {
+//            Stats.getInstance().log(beacon);
+//        }
+//        if (LogManager.isVerboseLoggingEnabled()) {
+//            LogManager.d(TAG,
+//                    "beacon detected : %s", beacon.toString());
+//        }
+//
+//        beacon = mExtraDataBeaconTracker.track(beacon);
+//        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+//        // the above
+//        if (beacon == null) {
+//            if (LogManager.isVerboseLoggingEnabled()) {
+//                LogManager.d(TAG,
+//                        "not processing detections for GATT extra data beacon");
+//            }
+//        } else {
+//
+//            monitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+//
+//            List<Region> matchedRegions = null;
+//            Iterator<Region> matchedRegionIterator;
+//            LogManager.d(TAG, "looking for ranging region matches for this beacon");
+//            synchronized (rangedRegionState) {
+//                matchedRegions = matchingRegions(beacon, rangedRegionState.keySet());
+//                matchedRegionIterator = matchedRegions.iterator();
+//                while (matchedRegionIterator.hasNext()) {
+//                    Region region = matchedRegionIterator.next();
+//                    LogManager.d(TAG, "matches ranging region: %s", region);
+//                    RangeState rangeState = rangedRegionState.get(region);
+//                    if (rangeState != null) {
+//                        rangeState.addBeacon(beacon);
+//                    }
+//                }
+//            }
+//        }
+//=======
+//        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
+//>>>>>>> f350af4e40d96d8538ccefae5f24a9029f6ad5ed
+//    }
+
+    public void reloadParsers() {
+        mScanHelper.reloadParsers();
     }
 
-    private void processBeaconFromScan(Beacon beacon) {
-        if (Stats.getInstance().isEnabled()) {
-            Stats.getInstance().log(beacon);
-        }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG,
-                    "beacon detected : %s", beacon.toString());
-        }
-
-        beacon = mExtraDataBeaconTracker.track(beacon);
-        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
-        // the above
-        if (beacon == null) {
-            if (LogManager.isVerboseLoggingEnabled()) {
-                LogManager.d(TAG,
-                        "not processing detections for GATT extra data beacon");
-            }
-        } else {
-
-            monitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
-
-            List<Region> matchedRegions = null;
-            Iterator<Region> matchedRegionIterator;
-            LogManager.d(TAG, "looking for ranging region matches for this beacon");
-            synchronized (rangedRegionState) {
-                matchedRegions = matchingRegions(beacon, rangedRegionState.keySet());
-                matchedRegionIterator = matchedRegions.iterator();
-                while (matchedRegionIterator.hasNext()) {
-                    Region region = matchedRegionIterator.next();
-                    LogManager.d(TAG, "matches ranging region: %s", region);
-                    RangeState rangeState = rangedRegionState.get(region);
-                    if (rangeState != null) {
-                        rangeState.addBeacon(beacon);
-                    }
-                }
-            }
-        }
-    }
-
-
-    private class ScanData {
-        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
-            this.device = device;
-            this.rssi = rssi;
-            this.scanRecord = scanRecord;
-        }
-
-        int rssi;
-        BluetoothDevice device;
-        byte[] scanRecord;
-    }
-
-    private class ScanProcessor extends AsyncTask<ScanData, Void, Void> {
-        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
-
-        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-
-        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
-            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
-        }
-
-        @Override
-        protected Void doInBackground(ScanData... params) {
-            ScanData scanData = params[0];
-            Beacon beacon = null;
-
-            for (BeaconParser parser : BeaconService.this.beaconParsers) {
-                beacon = parser.fromScanData(scanData.scanRecord,
-                        scanData.rssi, scanData.device);
-
-                if (beacon != null) {
-                    break;
-                }
-            }
-            if (beacon != null) {
-                mDetectionTracker.recordDetection();
-                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
-                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
-                            scanData.scanRecord)) {
-                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
-                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
-                    }
-                }
-                trackedBeaconsPacketCount++;
-                processBeaconFromScan(beacon);
-            } else {
-                if (mNonBeaconLeScanCallback != null) {
-                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
-                }
-            }
-            return null;
-        }
-
-        @Override
-        protected void onPostExecute(Void result) {
-        }
-
-        @Override
-        protected void onPreExecute() {
-        }
-
-        @Override
-        protected void onProgressUpdate(Void... values) {
-        }
-    }
-
-    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<Region>();
-        for (Region region : regions) {
-            if (region.matchesBeacon(beacon)) {
-                matched.add(region);
-            } else {
-                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
-            }
-        }
-        return matched;
+    @RestrictTo(Scope.TESTS)
+    protected CycledLeScanCallback getCycledLeScanCallback() {
+        return mScanHelper.getCycledLeScanCallback();
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index 419b47f7..a8c9ad92 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -26,8 +26,11 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Parcelable;
+import android.os.Bundle;
+import android.support.v4.content.LocalBroadcastManager;
 
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
+import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
 import java.io.IOException;
@@ -35,23 +38,9 @@
 
 public class Callback implements Serializable {
     private static final String TAG = "Callback";
-    private transient Intent intent;
-    private String intentPackageName;
 
+    //TODO: Remove this constructor in favor of an empty one, as the packae name is no longer needed
     public Callback(String intentPackageName) {
-        this.intentPackageName = intentPackageName;
-        initializeIntent();
-    }
-
-    private void initializeIntent() {
-        if (intentPackageName != null) {
-            intent = new Intent();
-            intent.setComponent(new ComponentName(intentPackageName, "org.altbeacon.beacon.BeaconIntentProcessor"));
-        }
-    }
-
-    public Intent getIntent() {
-        return intent;
     }
 
     /**
@@ -62,14 +51,28 @@ public Intent getIntent() {
      * @param data
      * @return false if it callback cannot be made
      */
-    public boolean call(Context context, String dataName, Parcelable data) {
-        if(intent == null){
-            initializeIntent();
-        }
+    public boolean call(Context context, String dataName, Bundle data) {
+        boolean useLocalBroadcast = BeaconManager.getInstanceForApplication(context).getScheduledScanJobsEnabled();
         boolean success = false;
-        if (intent != null) {
-            LogManager.d(TAG, "attempting callback via intent: %s", intent.getComponent());
+
+        if(useLocalBroadcast) {
+            String action = null;
+            if (dataName == "rangingData") {
+                action = BeaconLocalBroadcastProcessor.RANGE_NOTIFICATION;
+            }
+            else {
+                action = BeaconLocalBroadcastProcessor.MONITOR_NOTIFICATION;
+            }
+            Intent intent = new Intent(action);
+            intent.putExtra(dataName, data);
+            LogManager.d(TAG, "attempting callback via local broadcast intent: %s",action);
+            success = LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
+        }
+        else {
+            Intent intent = new Intent();
+            intent.setComponent(new ComponentName(context.getPackageName(), "org.altbeacon.beacon.BeaconIntentProcessor"));
             intent.putExtra(dataName, data);
+            LogManager.d(TAG, "attempting callback via global broadcast intent: %s",intent.getComponent());
             try {
                 context.startService(intent);
                 success = true;
@@ -88,6 +91,5 @@ public boolean call(Context context, String dataName, Parcelable data) {
     private void readObject(java.io.ObjectInputStream in)
             throws IOException, ClassNotFoundException {
         in.defaultReadObject();
-        initializeIntent();
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
index a93e8fb2..ae1bbbb1 100644
--- a/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
+++ b/src/main/java/org/altbeacon/beacon/service/ExtraDataBeaconTracker.java
@@ -1,7 +1,11 @@
 package org.altbeacon.beacon.service;
 
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+
 import org.altbeacon.beacon.Beacon;
 
+import java.io.Serializable;
 import java.util.HashMap;
 
 /**
@@ -9,13 +13,19 @@
  * merges them together depending on configured beacon parsers
  * Created by dyoung on 5/5/15.
  */
-public class ExtraDataBeaconTracker {
+public class ExtraDataBeaconTracker implements Serializable {
     private static final String TAG = "BeaconTracker";
-    // This is a lookup table to find tracked beacons by the calculated beacon key
-    private HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<String,HashMap<Integer,Beacon>>();
 
-    private boolean matchBeaconsByServiceUUID = true;
+    /**
+     * This is a lookup table to find tracked beacons by the calculated beacon key
+     */
+    @NonNull
+    private final HashMap<String,HashMap<Integer,Beacon>> mBeaconsByKey = new HashMap<>();
+
+    private final boolean matchBeaconsByServiceUUID;
+
     public ExtraDataBeaconTracker() {
+        this(true);
     }
 
     public ExtraDataBeaconTracker(boolean matchBeaconsByServiceUUID) {
@@ -24,12 +34,10 @@ public ExtraDataBeaconTracker(boolean matchBeaconsByServiceUUID) {
 
     /**
      * Tracks a beacon. For Gatt-based beacons, returns a merged copy of fields from multiple
-     * frames.  Returns null when passed a Gatt-based beacon that has is only extra beacon data.
-     *
-     * @param beacon
-     * @return
+     * frames. Returns null when passed a Gatt-based beacon that has is only extra beacon data.
      */
-    public synchronized Beacon track(Beacon beacon) {
+    @Nullable
+    public synchronized Beacon track(@NonNull Beacon beacon) {
         Beacon trackedBeacon = null;
         if (beacon.isMultiFrameBeacon() || beacon.getServiceUuid() != -1) {
             trackedBeacon = trackGattBeacon(beacon);
@@ -40,42 +48,42 @@ public synchronized Beacon track(Beacon beacon) {
         return trackedBeacon;
     }
 
-    // The following code is for dealing with merging data fields in beacons
-    private Beacon trackGattBeacon(Beacon beacon) {
-        Beacon trackedBeacon = null;
-        HashMap<Integer,Beacon> matchingTrackedBeacons = mBeaconsByKey.get(getBeaconKey(beacon));
-        if (matchingTrackedBeacons != null) {
-            for (Beacon matchingTrackedBeacon: matchingTrackedBeacons.values()) {
-                if (beacon.isExtraBeaconData()) {
-                    matchingTrackedBeacon.setRssi(beacon.getRssi());
-                    matchingTrackedBeacon.setExtraDataFields(beacon.getDataFields());
-                }
-                else {
-                    beacon.setExtraDataFields(matchingTrackedBeacon.getExtraDataFields());
-                    // replace the tracked beacon instance with this one so it has updated values
-                    trackedBeacon = beacon;
-                }
-            }
-        }
-        if (!beacon.isExtraBeaconData()) {
-            updateTrackingHashes(beacon, matchingTrackedBeacons);
+    /**
+     * The following code is for dealing with merging data fields in beacons
+     */
+    @Nullable
+    private Beacon trackGattBeacon(@NonNull Beacon beacon) {
+        if (beacon.isExtraBeaconData()) {
+            updateTrackedBeacons(beacon);
+            return null;
         }
 
-        if (trackedBeacon == null && !beacon.isExtraBeaconData()) {
-            trackedBeacon = beacon;
+        String key = getBeaconKey(beacon);
+        HashMap<Integer,Beacon> matchingTrackedBeacons = mBeaconsByKey.get(key);
+        if (null == matchingTrackedBeacons) {
+            matchingTrackedBeacons = new HashMap<>();
         }
-        return trackedBeacon;
+        else {
+            Beacon trackedBeacon = matchingTrackedBeacons.values().iterator().next();
+            beacon.setExtraDataFields(trackedBeacon.getExtraDataFields());
+        }
+        matchingTrackedBeacons.put(beacon.hashCode(), beacon);
+        mBeaconsByKey.put(key, matchingTrackedBeacons);
+
+        return beacon;
     }
 
-    private void updateTrackingHashes(Beacon trackedBeacon, HashMap<Integer,Beacon> matchingTrackedBeacons) {
-        if (matchingTrackedBeacons == null) {
-            matchingTrackedBeacons = new HashMap<Integer,Beacon>();
+    private void updateTrackedBeacons(@NonNull Beacon beacon) {
+        HashMap<Integer,Beacon> matchingTrackedBeacons = mBeaconsByKey.get(getBeaconKey(beacon));
+        if (null != matchingTrackedBeacons) {
+            for (Beacon matchingTrackedBeacon : matchingTrackedBeacons.values()) {
+                matchingTrackedBeacon.setRssi(beacon.getRssi());
+                matchingTrackedBeacon.setExtraDataFields(beacon.getDataFields());
+            }
         }
-        matchingTrackedBeacons.put(trackedBeacon.hashCode(), trackedBeacon);
-        mBeaconsByKey.put(getBeaconKey(trackedBeacon), matchingTrackedBeacons);
     }
 
-    private String getBeaconKey(Beacon beacon) {
+    private String getBeaconKey(@NonNull Beacon beacon) {
         if (matchBeaconsByServiceUUID) {
             return beacon.getBluetoothAddress() + beacon.getServiceUuid();
         } else {
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
index e9523536..74356914 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
@@ -25,49 +25,42 @@
 
 import org.altbeacon.beacon.Region;
 
-import android.os.Parcel;
-import android.os.Parcelable;
+import android.os.Bundle;
 
-public class MonitoringData implements Parcelable {
+public class MonitoringData {
     @SuppressWarnings("unused")
     private static final String TAG = "MonitoringData";
-    private final boolean inside;
-    private final Region region;
+    private final boolean mInside;
+    private final Region mRegion;
+    private static final String REGION_KEY = "region";
+    private static final String INSIDE_KEY = "inside";
 
     public MonitoringData (boolean inside, Region region) {
-        this.inside = inside;
-        this.region = region;
+        this.mInside = inside;
+        this.mRegion = region;
     }
     public boolean isInside() {
-        return inside;
+        return mInside;
     }
     public Region getRegion() {
-        return region;
+        return mRegion;
     }
 
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeByte((byte) (inside ? 1 : 0));
-        out.writeParcelable(region, flags);
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(REGION_KEY, mRegion);
+        bundle.putBoolean(INSIDE_KEY, mInside);
 
+        return bundle;
     }
-
-    public static final Parcelable.Creator<MonitoringData> CREATOR
-            = new Parcelable.Creator<MonitoringData>() {
-        public MonitoringData createFromParcel(Parcel in) {
-            return new MonitoringData(in);
-        }
-
-        public MonitoringData[] newArray(int size) {
-            return new MonitoringData[size];
+    public static MonitoringData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
         }
-    };
-
-    private MonitoringData(Parcel in) {
-        inside = in.readByte() == 1;
-        region = in.readParcelable(this.getClass().getClassLoader());
+        Boolean inside = bundle.getBoolean(INSIDE_KEY);
+        return new MonitoringData(inside, region);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index 3185fdc6..ea8573e7 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 
 import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.MonitorNotifier;
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -19,6 +20,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 import static android.content.Context.MODE_PRIVATE;
 
@@ -71,31 +73,12 @@ public MonitoringStatus(Context context) {
     }
 
     public synchronized void addRegion(Region region, Callback callback) {
-        if (getRegionsStateMap().containsKey(region)) {
-            // if the region definition hasn't changed, becasue if it has, we need to clear state
-            // otherwise a region with the same uniqueId can never be changed
-            for (Region existingRegion : getRegionsStateMap().keySet()) {
-                if (existingRegion.equals(region)) {
-                    if (existingRegion.hasSameIdentifiers(region)) {
-                        return;
-                    }
-                    else {
-                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
-                        LogManager.d(TAG, "Old definition: "+existingRegion);
-                        LogManager.d(TAG, "New definition: "+region);
-                        LogManager.d(TAG, "clearing state");
-                        getRegionsStateMap().remove(region);
-                        break;
-                    }
-                }
-            }
-        }
-        getRegionsStateMap().put(region, new RegionMonitoringState(callback));
+        addLocalRegion(region, callback);
         saveMonitoringStatusIfOn();
     }
 
     public synchronized void removeRegion(Region region) {
-        getRegionsStateMap().remove(region);
+        removeLocalRegion(region);
         saveMonitoringStatusIfOn();
     }
 
@@ -120,7 +103,7 @@ public synchronized void updateNewlyOutside() {
             if (state.markOutsideIfExpired()) {
                 needsMonitoringStateSaving = true;
                 LogManager.d(TAG, "found a monitor that expired: %s", region);
-                state.getCallback().call(mContext, "monitoringData", new MonitoringData(state.getInside(), region));
+                state.getCallback().call(mContext, "monitoringData", new MonitoringData(state.getInside(), region).toBundle());
             }
         }
         if (needsMonitoringStateSaving) {
@@ -139,7 +122,7 @@ public synchronized void updateNewlyInsideInRegionsContaining(Beacon beacon) {
             if (state != null && state.markInside()) {
                 needsMonitoringStateSaving = true;
                 state.getCallback().call(mContext, "monitoringData",
-                        new MonitoringData(state.getInside(), region));
+                        new MonitoringData(state.getInside(), region).toBundle());
             }
         }
         if (needsMonitoringStateSaving) {
@@ -159,7 +142,7 @@ public synchronized void updateNewlyInsideInRegionsContaining(Beacon beacon) {
 
     private void restoreOrInitializeMonitoringStatus() {
         long millisSinceLastMonitor = System.currentTimeMillis() - getLastMonitoringStatusUpdateTime();
-        mRegionsStatesMap = new HashMap<Region, RegionMonitoringState>();
+        mRegionsStatesMap = new ConcurrentHashMap<Region, RegionMonitoringState>();
         if (!mStatePreservationIsOn) {
             LogManager.d(TAG, "Not restoring monitoring state because persistence is disabled");
         }
@@ -197,10 +180,17 @@ protected void saveMonitoringStatusIfOn() {
             try {
                 outputStream = mContext.openFileOutput(STATUS_PRESERVATION_FILE_NAME, MODE_PRIVATE);
                 objectOutputStream = new ObjectOutputStream(outputStream);
-                objectOutputStream.writeObject(getRegionsStateMap());
-
+                Map<Region,RegionMonitoringState> map = getRegionsStateMap();
+                // Must convert ConcurrentHashMap to HashMap becasue attempting to serialize
+                // ConcurrentHashMap throws a java.io.NotSerializableException
+                HashMap<Region,RegionMonitoringState> serializableMap = new HashMap<Region,RegionMonitoringState>();
+                for (Region region : map.keySet()) {
+                    serializableMap.put(region, map.get(region));
+                }
+                objectOutputStream.writeObject(serializableMap);
             } catch (IOException e) {
-                LogManager.e(TAG, "Error while saving monitored region states to file. %s ", e.getMessage());
+                LogManager.e(TAG, "Error while saving monitored region states to file ", e);
+                e.printStackTrace(System.err);
             } finally {
                 if (null != outputStream) {
                     try {
@@ -291,8 +281,61 @@ public synchronized void startStatusPreservation() {
         }
     }
 
+    public boolean isStatePreservationOn() {
+        return mStatePreservationIsOn;
+    }
+
     public synchronized void clear() {
         mContext.deleteFile(STATUS_PRESERVATION_FILE_NAME);
         getRegionsStateMap().clear();
     }
+
+    public void updateLocalState(Region region, Integer state) {
+        RegionMonitoringState internalState = getRegionsStateMap().get(region);
+        if (internalState == null) {
+            internalState = addLocalRegion(region);
+        }
+        if (state != null) {
+            if (state == MonitorNotifier.OUTSIDE) {
+                internalState.markOutside();
+
+            }
+            if (state == MonitorNotifier.INSIDE) {
+                internalState.markInside();
+            }
+        }
+    }
+
+    public void removeLocalRegion(Region region) {
+        getRegionsStateMap().remove(region);
+    }
+    public RegionMonitoringState addLocalRegion(Region region){
+        Callback dummyCallback = new Callback(null);
+        return addLocalRegion(region, dummyCallback);
+    }
+
+    private RegionMonitoringState addLocalRegion(Region region, Callback callback){
+        if (getRegionsStateMap().containsKey(region)) {
+            // if the region definition hasn't changed, becasue if it has, we need to clear state
+            // otherwise a region with the same uniqueId can never be changed
+            for (Region existingRegion : getRegionsStateMap().keySet()) {
+                if (existingRegion.equals(region)) {
+                    if (existingRegion.hasSameIdentifiers(region)) {
+                        return getRegionsStateMap().get(existingRegion);
+                    }
+                    else {
+                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
+                        LogManager.d(TAG, "Old definition: "+existingRegion);
+                        LogManager.d(TAG, "New definition: "+region);
+                        LogManager.d(TAG, "clearing state");
+                        getRegionsStateMap().remove(region);
+                        break;
+                    }
+                }
+            }
+        }
+        RegionMonitoringState monitoringState = new RegionMonitoringState(callback);
+        getRegionsStateMap().put(region, monitoringState);
+        return monitoringState;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index a8c1e8d4..bba10079 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -26,16 +26,17 @@
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
-public class RangeState {
+public class RangeState implements Serializable {
     private static final String TAG = "RangeState";
-    private final Callback mCallback;
+    private Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
-    private static boolean UseTrackingCache = false;
+    private static boolean sUseTrackingCache = false;
 
     public RangeState(Callback c) {
         mCallback = c;
@@ -48,11 +49,15 @@ public Callback getCallback() {
     public void addBeacon(Beacon beacon) {
         if (mRangedBeacons.containsKey(beacon)) {
             RangedBeacon rangedBeacon = mRangedBeacons.get(beacon);
-            LogManager.d(TAG, "adding %s to existing range for: %s", beacon, rangedBeacon);
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG, "adding %s to existing range for: %s", beacon, rangedBeacon);
+            }
             rangedBeacon.updateBeacon(beacon);
         }
         else {
-            LogManager.d(TAG, "adding %s to new rangedBeacon", beacon);
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG, "adding %s to new rangedBeacon", beacon);
+            }
             mRangedBeacons.put(beacon, new RangedBeacon(beacon));
         }
     }
@@ -77,7 +82,7 @@ public void addBeacon(Beacon beacon) {
                 if (!rangedBeacon.noMeasurementsAvailable() == true) {
                     //if TrackingCache is enabled, allow beacon to not receive
                     //measurements for a certain amount of time
-                    if (!UseTrackingCache || rangedBeacon.isExpired())
+                    if (!sUseTrackingCache || rangedBeacon.isExpired())
                         rangedBeacon.setTracked(false);
                     newRangedBeacons.put(beacon, rangedBeacon);
                 }
@@ -92,8 +97,11 @@ public void addBeacon(Beacon beacon) {
     }
 
     public static void setUseTrackingCache(boolean useTrackingCache) {
-        RangeState.UseTrackingCache = useTrackingCache;
+        RangeState.sUseTrackingCache = useTrackingCache;
     }
 
+    public static boolean getUseTrackingCache() {
+        return sUseTrackingCache;
+    }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index a5b321cb..d02bef83 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -6,9 +6,10 @@
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
-public class RangedBeacon {
+public class RangedBeacon implements Serializable {
 
     private static final String TAG = "RangedBeacon";
     public static final long DEFAULT_MAX_TRACKING_AGE = 5000; /* 5 Seconds */
@@ -19,22 +20,15 @@
     private boolean mTracked = true;
     protected long lastTrackedTimeMillis = 0;
     Beacon mBeacon;
-    protected RssiFilter filter = null;
+    protected transient RssiFilter mFilter = null;
+    private int packetCount = 0;
 
     public RangedBeacon(Beacon beacon) {
-        //set RSSI filter
-        try {
-            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
-            filter = (RssiFilter)cons.newInstance();
-        } catch (Exception e) {
-            LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
-        }
-
-        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
         updateBeacon(beacon);
     }
 
     public void updateBeacon(Beacon beacon) {
+        packetCount += 1;
         mBeacon = beacon;
         addMeasurement(mBeacon.getRssi());
     }
@@ -53,14 +47,17 @@ public Beacon getBeacon() {
 
     // Done at the end of each cycle before data are sent to the client
     public void commitMeasurements() {
-        if (!filter.noMeasurementsAvailable()) {
-            double runningAverage = filter.calculateRssi();
-            mBeacon.setRunningAverageRssi(runningAverage);
-            LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
+         if (!getFilter().noMeasurementsAvailable()) {
+             double runningAverage = getFilter().calculateRssi();
+             mBeacon.setRunningAverageRssi(runningAverage);
+             mBeacon.setRssiMeasurementCount(getFilter().getMeasurementCount());
+             LogManager.d(TAG, "calculated new runningAverageRssi: %s", runningAverage);
         }
         else {
             LogManager.d(TAG, "No measurements available to calculate running average");
         }
+        mBeacon.setPacketCount(packetCount);
+        packetCount = 0;
     }
 
     public void addMeasurement(Integer rssi) {
@@ -69,13 +66,14 @@ public void addMeasurement(Integer rssi) {
         if (rssi != 127) {
             mTracked = true;
             lastTrackedTimeMillis = SystemClock.elapsedRealtime();
-            filter.addMeasurement(rssi);
+            getFilter().addMeasurement(rssi);
         }
     }
 
     //kept here for backward compatibility
     public static void setSampleExpirationMilliseconds(long milliseconds) {
         sampleExpirationMilliseconds = milliseconds;
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
     }
 
     public static void setMaxTrackinAge(int maxTrackinAge) {
@@ -83,7 +81,7 @@ public static void setMaxTrackinAge(int maxTrackinAge) {
     }
 
     public boolean noMeasurementsAvailable() {
-        return filter.noMeasurementsAvailable();
+        return getFilter().noMeasurementsAvailable();
     }
 
     public long getTrackingAge() {
@@ -94,4 +92,17 @@ public boolean isExpired() {
         return getTrackingAge() > maxTrackingAge;
     }
 
+    private RssiFilter getFilter() {
+        if (mFilter == null) {
+            //set RSSI filter
+            try {
+            Constructor cons = BeaconManager.getRssiFilterImplClass().getConstructors()[0];
+                mFilter = (RssiFilter)cons.newInstance();
+            } catch (Exception e) {
+                LogManager.e(TAG, "Could not construct RssiFilterImplClass %s", BeaconManager.getRssiFilterImplClass().getName());
+            }
+        }
+        return mFilter;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangingData.java b/src/main/java/org/altbeacon/beacon/service/RangingData.java
index 2d400787..d7bb44ff 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -23,62 +23,63 @@
  */
 package org.altbeacon.beacon.service;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 
 import org.altbeacon.beacon.Beacon;
-import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Region;
-import org.altbeacon.beacon.logging.LogManager;
 
-import android.os.Parcel;
-import android.os.Parcelable;
+import android.os.Bundle;
 
-public class RangingData implements Parcelable {
+/**
+ * Internal class used to transfer ranging data between the BeaconService and the client
+ * @hide
+ */
+public class RangingData {
     private static final String TAG = "RangingData";
-    private final Collection<Beacon> beacons;
-    private final Region region;
+    private final Collection<Beacon> mBeacons;
+    private final Region mRegion;
+    private static final String REGION_KEY = "region";
+    private static final String BEACONS_KEY = "beacons";
 
     public RangingData (Collection<Beacon> beacons, Region region) {
         synchronized (beacons) {
-            this.beacons =  beacons;
+            this.mBeacons =  beacons;
         }
-        this.region = region;
+        this.mRegion = region;
     }
 
     public Collection<Beacon> getBeacons() {
-        return beacons;
+        return mBeacons;
     }
     public Region getRegion() {
-        return region;
-    }
-
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeParcelableArray(beacons.toArray(new Parcelable[0]), flags);
-        out.writeParcelable(region, flags);
+        return mRegion;
     }
 
-    public static final Parcelable.Creator<RangingData> CREATOR
-            = new Parcelable.Creator<RangingData>() {
-        public RangingData createFromParcel(Parcel in) {
-            return new RangingData(in);
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(REGION_KEY, mRegion);
+        ArrayList<Serializable> serializableBeacons = new ArrayList<Serializable>();
+        for (Beacon beacon : mBeacons) {
+            serializableBeacons.add(beacon);
         }
+        bundle.putSerializable(BEACONS_KEY, serializableBeacons);
 
-        public RangingData[] newArray(int size) {
-            return new RangingData[size];
+        return bundle;
+    }
+    public static RangingData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        Collection<Beacon> beacons = null;
+        if (bundle.get(BEACONS_KEY) != null) {
+            beacons = (Collection<Beacon>) bundle.getSerializable(BEACONS_KEY);
         }
-    };
-
-    protected RangingData(Parcel in) {
-        Parcelable[] parcelables  = in.readParcelableArray(this.getClass().getClassLoader());
-        beacons = new ArrayList<Beacon>(parcelables.length);
-        for (int i = 0; i < parcelables.length; i++) {
-            beacons.add((Beacon)parcelables[i]);
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
         }
-        region = in.readParcelable(this.getClass().getClassLoader());
+
+        return new RangingData(beacons, region);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java b/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
index 0f9cd1ee..d7b36fb3 100644
--- a/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
@@ -54,15 +54,19 @@ public boolean markInside() {
         return false;
     }
 
+    public void markOutside() {
+        inside = false;
+        lastSeenTime = 0l;
+    }
+
     public boolean markOutsideIfExpired() {
         if (inside) {
             if (lastSeenTime > 0 && SystemClock.elapsedRealtime() - lastSeenTime > BeaconManager.getRegionExitPeriod()) {
-                inside = false;
                 LogManager.d(TAG, "We are newly outside the region because the lastSeenTime of %s "
                                 + "was %s seconds ago, and that is over the expiration duration "
                                 + "of %s", lastSeenTime, SystemClock.elapsedRealtime() - lastSeenTime,
                         BeaconManager.getRegionExitPeriod());
-                lastSeenTime = 0l;
+                markOutside();
                 return true;
             }
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/RssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
index 57a587e8..d092c6ac 100644
--- a/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/RssiFilter.java
@@ -9,5 +9,6 @@
     public void addMeasurement(Integer rssi);
     public boolean noMeasurementsAvailable();
     public double calculateRssi();
+    public int getMeasurementCount();
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
index c5ba36ca..7672f3b1 100644
--- a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
@@ -1,6 +1,8 @@
 package org.altbeacon.beacon.service;
 
 import android.os.SystemClock;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -33,6 +35,10 @@ public boolean noMeasurementsAvailable() {
         return mMeasurements.size() == 0;
     }
 
+
+    @Override
+    public int getMeasurementCount() { return mMeasurements.size(); }
+
     @Override
     public double calculateRssi() {
         refreshMeasurements();
@@ -81,4 +87,8 @@ public static void setSampleExpirationMilliseconds(long newSampleExpirationMilli
         sampleExpirationMilliseconds = newSampleExpirationMilliseconds;
     }
 
+    @RestrictTo(Scope.TESTS)
+    static long getSampleExpirationMilliseconds() {
+        return sampleExpirationMilliseconds;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
new file mode 100644
index 00000000..758f0995
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanDataProcessor.java
@@ -0,0 +1,173 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.Service;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.le.ScanResult;
+import android.content.pm.ApplicationInfo;
+import android.os.Build;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Created by dyoung on 3/24/17.
+ * @hice
+ */
+
+public class ScanDataProcessor {
+    private static final String TAG = ScanDataProcessor.class.getSimpleName();
+    private Service mService;
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    // TODO: implement this
+    private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+    private DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+    int trackedBeaconsPacketCount;
+
+
+    public ScanDataProcessor(Service scanService, ScanState scanState) {
+        mService = scanService;
+        mMonitoringStatus = scanState.getMonitoringStatus();
+        mRangedRegionState = scanState.getRangedRegionState();
+        mMonitoringStatus = scanState.getMonitoringStatus();
+        mExtraDataBeaconTracker = scanState.getExtraBeaconDataTracker();
+        mBeaconParsers = scanState.getBeaconParsers();
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public void process(ScanResult scanResult) {
+        ScanData scanData= new ScanData(scanResult.getDevice(), scanResult.getRssi(), scanResult.getScanRecord().getBytes());
+        process(scanData);
+    }
+
+    public void process(ScanData scanData) {
+        Beacon beacon = null;
+
+        for (BeaconParser parser : mBeaconParsers) {
+            beacon = parser.fromScanData(scanData.scanRecord,
+                    scanData.rssi, scanData.device);
+
+            if (beacon != null) {
+                break;
+            }
+        }
+        if (beacon != null) {
+            mDetectionTracker.recordDetection();
+            trackedBeaconsPacketCount++;
+            processBeaconFromScan(beacon);
+        } else {
+            if (mNonBeaconLeScanCallback != null) {
+                mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+            }
+        }
+
+    }
+    private class ScanData {
+        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        int rssi;
+        BluetoothDevice device;
+        byte[] scanRecord;
+    }
+
+    private void processBeaconFromScan(Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions = null;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon out of "+mRangedRegionState.keySet().size()+" regions.");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<Region>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+
+    public void onCycleEnd() {
+        mMonitoringStatus.updateNewlyOutside();
+        processRangeData();
+        if (BeaconManager.getBeaconSimulator() != null) {
+            // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+            // it will not be used if we are not in debug mode
+            if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                if (0 != (mService.getApplicationContext().getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                }
+            } else {
+                LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+            }
+        }
+    }
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                Callback callback = new Callback(mService.getPackageName());
+                callback.call(mService, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
new file mode 100644
index 00000000..a4fb597d
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -0,0 +1,418 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.app.PendingIntent;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanFilter;
+import android.bluetooth.le.ScanSettings;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ApplicationInfo;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.RequiresApi;
+import android.support.annotation.WorkerThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+import org.altbeacon.beacon.service.scanner.ScanFilterUtils;
+import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
+import org.altbeacon.bluetooth.BluetoothCrashResolver;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * Created by dyoung on 6/16/17.
+ *
+ * This is an internal utility class and should not be called directly by library users.
+ *
+ * This encapsulates shared data and methods used by both ScanJob and BeaconService
+ * that deal with the specifics of beacon scanning.
+ *
+ * @hide
+ */
+
+class ScanHelper {
+    private static final String TAG = ScanHelper.class.getSimpleName();
+    private ExecutorService mExecutor;
+    private BeaconManager mBeaconManager;
+    private CycledLeScanner mCycledScanner;
+    private MonitoringStatus mMonitoringStatus;
+    private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
+    private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
+
+    @NonNull
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker = new ExtraDataBeaconTracker();
+
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<>();
+    private List<Beacon> mSimulatedScanData = null;
+    private Context mContext;
+
+    ScanHelper(Context context) {
+        mContext = context;
+        mBeaconManager = BeaconManager.getInstanceForApplication(context);
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
+    }
+
+    CycledLeScanner getCycledScanner() {
+        return mCycledScanner;
+    }
+
+    MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        synchronized (mRangedRegionState) {
+            mRangedRegionState.clear();
+            mRangedRegionState.putAll(rangedRegionState);
+        }
+    }
+
+    void setExtraDataBeaconTracker(@NonNull ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraDataBeaconTracker = extraDataBeaconTracker;
+    }
+
+    void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    void setSimulatedScanData(List<Beacon> simulatedScanData) {
+        mSimulatedScanData = simulatedScanData;
+    }
+
+
+    void createCycledLeScanner(boolean backgroundMode, BluetoothCrashResolver crashResolver) {
+        mCycledScanner = CycledLeScanner.createScanner(mContext, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
+                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, backgroundMode,
+                mCycledLeScanCallback, crashResolver);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    void processScanResult(BluetoothDevice device, int rssi, byte[] scanRecord) {
+        NonBeaconLeScanCallback nonBeaconLeScanCallback = mBeaconManager.getNonBeaconLeScanCallback();
+
+        try {
+            new ScanHelper.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
+                    new ScanHelper.ScanData(device, rssi, scanRecord));
+        } catch (RejectedExecutionException e) {
+
+            LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+        }
+    }
+
+    void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<>();
+        //flatMap all beacon parsers
+        boolean matchBeaconsByServiceUUID = true;
+        newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
+        for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
+            if (beaconParser.getExtraDataParsers().size() > 0) {
+                matchBeaconsByServiceUUID = false;
+                newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
+            }
+        }
+        mBeaconParsers = newBeaconParsers;
+        //initialize the extra data beacon tracker
+        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    void startAndroidOBackgroundScan(Set<BeaconParser> beaconParsers) {
+        ScanSettings settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
+        List<ScanFilter> filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
+                new ArrayList<BeaconParser>(beaconParsers));
+        try {
+            final BluetoothManager bluetoothManager =
+                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();
+            if (bluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            } else if (!bluetoothAdapter.isEnabled()) {
+                LogManager.w(TAG, "Failed to start background scan on Android O: BluetoothAdapter is not enabled");
+            } else {
+                int result = bluetoothAdapter.getBluetoothLeScanner().startScan(filters, settings, getScanCallbackIntent());
+                if (result != 0) {
+                    LogManager.e(TAG, "Failed to start background scan on Android O.  Code: "+result);
+                }
+                else {
+                    LogManager.d(TAG, "Started passive beacon scan");
+                }
+            }
+        }
+        catch (SecurityException e) {
+            LogManager.e(TAG, "SecurityException making Android O background scanner");
+        }
+    }
+
+    @RequiresApi(api = Build.VERSION_CODES.O)
+    void stopAndroidOBackgroundScan() {
+        try {
+            final BluetoothManager bluetoothManager =
+                    (BluetoothManager) mContext.getApplicationContext().getSystemService(Context.BLUETOOTH_SERVICE);
+            BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();
+            if (bluetoothAdapter == null) {
+                LogManager.w(TAG, "Failed to construct a BluetoothAdapter");
+            } else if (!bluetoothAdapter.isEnabled()) {
+                LogManager.w(TAG, "BluetoothAdapter is not enabled");
+            } else {
+               BluetoothLeScanner scanner =  bluetoothAdapter.getBluetoothLeScanner();
+               if (scanner != null) {
+                   scanner.stopScan(getScanCallbackIntent());
+               }
+            }
+        } catch (SecurityException e) {
+            LogManager.e(TAG, "SecurityException stopping Android O background scanner");
+        }
+    }
+
+    // Low power scan results in the background will be delivered via Intent
+    PendingIntent getScanCallbackIntent() {
+        Intent intent = new Intent(mContext, StartupBroadcastReceiver.class);
+        intent.putExtra("o-scan", true);
+        return PendingIntent.getBroadcast(mContext,0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+    }
+
+    private final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+        @Override
+        @MainThread
+        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            processScanResult(device, rssi, scanRecord);
+        }
+
+        @Override
+        @MainThread
+        @SuppressLint("WrongThread")
+        public void onCycleEnd() {
+            mDistinctPacketDetector.clearDetections();
+            mMonitoringStatus.updateNewlyOutside();
+            processRangeData();
+            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
+            if (mSimulatedScanData != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
+
+                if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : mSimulatedScanData) {
+                        // This is an expensive call and we do not want to block the main thread.
+                        // But here we are in debug/test mode so we allow it on the main thread.
+                        //noinspection WrongThread
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
+                }
+            }
+            if (BeaconManager.getBeaconSimulator() != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                    if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                            // This is an expensive call and we do not want to block the main thread.
+                            // But here we are in debug/test mode so we allow it on the main thread.
+                            //noinspection WrongThread
+                            processBeaconFromScan(beacon);
+                        }
+                    } else {
+                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                    }
+                } else {
+                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+                }
+            }
+        }
+
+        @Override
+        @MainThread
+        public void onMidScanRange() {
+            processRangeData();
+        }
+    };
+
+    @RestrictTo(Scope.TESTS)
+    CycledLeScanCallback getCycledLeScanCallback() {
+        return mCycledLeScanCallback;
+    }
+
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                rangeState.getCallback().call(mContext, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+    /**
+     * Helper for processing BLE beacons. This has been extracted from {@link ScanHelper.ScanProcessor} to
+     * support simulated scan data for test and debug environments.
+     * <p>
+     * Processing beacons is a frequent and expensive operation. It should not be run on the main
+     * thread to avoid UI contention.
+     */
+    @WorkerThread
+    private void processBeaconFromScan(@NonNull Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * <strong>This class is not thread safe.</strong>
+     */
+    private class ScanData {
+        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        final int rssi;
+
+        @NonNull
+        BluetoothDevice device;
+
+        @NonNull
+        byte[] scanRecord;
+    }
+
+    private class ScanProcessor extends AsyncTask<ScanHelper.ScanData, Void, Void> {
+        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+        ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
+            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
+        }
+
+        @WorkerThread
+        @Override
+        protected Void doInBackground(ScanHelper.ScanData... params) {
+            ScanHelper.ScanData scanData = params[0];
+            Beacon beacon = null;
+
+            for (BeaconParser parser : ScanHelper.this.mBeaconParsers) {
+                beacon = parser.fromScanData(scanData.scanRecord,
+                        scanData.rssi, scanData.device);
+
+                if (beacon != null) {
+                    break;
+                }
+            }
+            if (beacon != null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                }
+                mDetectionTracker.recordDetection();
+                if (mCycledScanner != null && !mCycledScanner.getDistinctPacketsDetectedPerScan()) {
+                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
+                            scanData.scanRecord)) {
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
+                    }
+                }
+                processBeaconFromScan(beacon);
+            } else {
+                if (mNonBeaconLeScanCallback != null) {
+                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+                }
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+        }
+
+        @Override
+        protected void onPreExecute() {
+        }
+
+        @Override
+        protected void onProgressUpdate(Void... values) {
+        }
+    }
+
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
new file mode 100644
index 00000000..9e580d9b
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -0,0 +1,316 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.TargetApi;
+import android.app.job.JobParameters;
+import android.app.job.JobService;
+import android.bluetooth.le.ScanRecord;
+import android.bluetooth.le.ScanResult;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
+import android.os.Build;
+import android.os.Handler;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BuildConfig;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.utils.ProcessUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Used to perform scans periodically using the JobScheduler
+ *
+ * Only one instance of this will be active, even with multiple jobIds.  If one job
+ * is already running when another is scheduled to start, onStartJob gets called again on the same
+ * instance.
+ *
+ * If the OS decides to create a new instance, it will call onStopJob() on the old instance
+ *
+ * Created by dyoung on 3/24/17.
+ * @hide
+ */
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+public class ScanJob extends JobService {
+    private static final String TAG = ScanJob.class.getSimpleName();
+    /*
+        Periodic scan jobs are used in general, but they cannot be started immediately.  So we have
+        a second immediate scan job to kick off when scanning gets started or settings changed.
+        Once the periodic one gets run, the immediate is cancelled.
+     */
+    private static int sOverrideImmediateScanJobId = -1;
+    private static int sOverridePeriodicScanJobId = -1;
+
+    private ScanState mScanState;
+    private Handler mStopHandler = new Handler();
+    private ScanHelper mScanHelper;
+    private boolean mInitialized = false;
+
+    @Override
+    public boolean onStartJob(final JobParameters jobParameters) {
+        initialzeScanHelper();
+        if (jobParameters.getJobId() == getImmediateScanJobId(this)) {
+            LogManager.i(TAG, "Running immediate scan job: instance is "+this);
+        }
+        else {
+            LogManager.i(TAG, "Running periodic scan job: instance is "+this);
+        }
+
+        List<ScanResult> queuedScanResults = ScanJobScheduler.getInstance().dumpBackgroundScanResultQueue();
+        LogManager.d(TAG, "Processing %d queued scan resuilts", queuedScanResults.size());
+        for (ScanResult result : queuedScanResults) {
+            ScanRecord scanRecord = result.getScanRecord();
+            if (scanRecord != null) {
+                mScanHelper.processScanResult(result.getDevice(), result.getRssi(), scanRecord.getBytes());
+            }
+        }
+        LogManager.d(TAG, "Done processing queued scan resuilts");
+
+        boolean startedScan;
+        if (mInitialized) {
+            LogManager.d(TAG, "Scanning already started.  Resetting for current parameters");
+            startedScan = restartScanning();
+        }
+        else {
+            startedScan = startScanning();
+        }
+        mStopHandler.removeCallbacksAndMessages(null);
+
+        if (startedScan) {
+            LogManager.i(TAG, "Scan job running for "+mScanState.getScanJobRuntimeMillis()+" millis");
+            mStopHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    LogManager.i(TAG, "Scan job runtime expired: " + ScanJob.this);
+                    stopScanning();
+                    mScanState.save();
+                    ScanJob.this.jobFinished(jobParameters , false);
+
+                    // need to execute this after the current block or Android stops this job prematurely
+                    mStopHandler.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            scheduleNextScan();
+                        }
+                    });
+
+                }
+            }, mScanState.getScanJobRuntimeMillis());
+        }
+        else {
+            LogManager.i(TAG, "Scanning not started so Scan job is complete.");
+            ScanJob.this.jobFinished(jobParameters , false);
+        }
+        return true;
+    }
+
+    private void scheduleNextScan(){
+        if(!mScanState.getBackgroundMode()){
+            // immediately reschedule scan if running in foreground
+            LogManager.d(TAG, "In foreground mode, schedule next scan");
+            ScanJobScheduler.getInstance().forceScheduleNextScan(ScanJob.this);
+        } else {
+            startPassiveScanIfNeeded();
+        }
+    }
+
+    private void startPassiveScanIfNeeded() {
+        LogManager.d(TAG, "Checking to see if we need to start a passive scan");
+        boolean insideAnyRegion = false;
+        // Clone the collection before iterating to prevent ConcurrentModificationException per #577
+        List<Region> regions = new ArrayList<>(mScanState.getMonitoringStatus().regions());
+        for (Region region : regions) {
+            RegionMonitoringState state = mScanState.getMonitoringStatus().stateOf(region);
+            if (state != null && state.getInside()) {
+                insideAnyRegion = true;
+            }
+        }
+        if (insideAnyRegion) {
+            // TODO: Set up a scan filter for not detecting a beacon pattern
+            LogManager.i(TAG, "We are inside a beacon region.  We will not scan between cycles.");
+        }
+        else {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                mScanHelper.startAndroidOBackgroundScan(mScanState.getBeaconParsers());
+            }
+            else {
+                LogManager.d(TAG, "This is not Android O.  No scanning between cycles when using ScanJob");
+            }
+        }
+    }
+
+    @Override
+    public boolean onStopJob(JobParameters params) {
+        if (params.getJobId() == getPeriodicScanJobId(this)) {
+            LogManager.i(TAG, "onStopJob called for periodic scan " + this);
+        }
+        else {
+            LogManager.i(TAG, "onStopJob called for immediate scan " + this);
+        }
+        // Cancel the stop timer.  The OS is stopping prematurely
+        mStopHandler.removeCallbacksAndMessages(null);
+        stopScanning();
+        startPassiveScanIfNeeded();
+
+        return false;
+    }
+
+    private void stopScanning() {
+        mInitialized = false;
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        LogManager.d(TAG, "Scanning stopped");
+    }
+
+    private void initialzeScanHelper() {
+        mScanHelper = new ScanHelper(this);
+        mScanState = ScanState.restore(ScanJob.this);
+        mScanState.setLastScanStartTimeMillis(System.currentTimeMillis());
+        mScanHelper.setMonitoringStatus(mScanState.getMonitoringStatus());
+        mScanHelper.setRangedRegionState(mScanState.getRangedRegionState());
+        mScanHelper.setBeaconParsers(mScanState.getBeaconParsers());
+        mScanHelper.setExtraDataBeaconTracker(mScanState.getExtraBeaconDataTracker());
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
+        }
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean restartScanning() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            mScanHelper.stopAndroidOBackgroundScan();
+        }
+        long scanPeriod = mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod();
+        long betweenScanPeriod = mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod();
+        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod,
+                                                      betweenScanPeriod,
+                                                      mScanState.getBackgroundMode());
+        mInitialized = true;
+        if (scanPeriod <= 0) {
+            LogManager.w(TAG, "Starting scan with scan period of zero.  Exiting ScanJob.");
+            mScanHelper.getCycledScanner().stop();
+            return false;
+        }
+
+        if (mScanHelper.getRangedRegionState().size() > 0 || mScanHelper.getMonitoringStatus().regions().size() > 0) {
+            mScanHelper.getCycledScanner().start();
+            return true;
+        }
+        else {
+            mScanHelper.getCycledScanner().stop();
+            return false;
+        }
+    }
+
+    // Returns true of scanning actually was started, false if it did not need to be
+    private boolean startScanning() {
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        beaconManager.setScannerInSameProcess(true);
+        if (beaconManager.isMainProcess()) {
+            LogManager.i(TAG, "scanJob version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+        }
+        else {
+            LogManager.i(TAG, "beaconScanJob library version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(ScanJob.this);
+            LogManager.i(TAG, "beaconScanJob PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
+        }
+        ModelSpecificDistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(ScanJob.this, BeaconManager.getDistanceModelUpdateUrl());
+        Beacon.setDistanceCalculator(defaultDistanceCalculator);
+        return restartScanning();
+    }
+
+    /**
+     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
+     * will default to the value in the AndroidManifest.xml
+     *
+     * WARNING:  If using this library in a multi-process application, this method may not work.
+     * This is considered a private API and may be removed at any time.
+     *
+     * the preferred way of setting this is in the AndroidManifest.xml as so:
+     * <code>
+     * <service android:name="org.altbeacon.beacon.service.ScanJob">
+     * </service>
+     * </code>
+     *
+     * @param id identifier to give the job
+     */
+    @SuppressWarnings("unused")
+    public static void setOverrideImmediateScanJobId(int id) {
+        sOverrideImmediateScanJobId = id;
+    }
+
+    /**
+     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
+     * will default to the value in the AndroidManifest.xml
+     *
+     * WARNING:  If using this library in a multi-process application, this method may not work.
+     * This is considered a private API and may be removed at any time.
+     *
+     * the preferred way of setting this is in the AndroidManifest.xml as so:
+     * <code>
+     * <service android:name="org.altbeacon.beacon.service.ScanJob">
+     *   <meta-data android:name="immmediateScanJobId" android:value="1001" tools:replace="android:value"/>
+     *   <meta-data android:name="periodicScanJobId" android:value="1002" tools:replace="android:value"/>
+     * </service>
+     * </code>
+     *
+     * @param id identifier to give the job
+     */
+    @SuppressWarnings("unused")
+    public static void setOverridePeriodicScanJobId(int id) {
+        sOverridePeriodicScanJobId = id;
+    }
+
+    /**
+     * Returns the job id to be used to schedule this job.  This may be set in the
+     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     * @param context the application context
+     * @return the job id
+     */
+    public static int getImmediateScanJobId(Context context) {
+        if (sOverrideImmediateScanJobId >= 0) {
+            LogManager.i(TAG, "Using ImmediateScanJobId from static override: "+
+                    sOverrideImmediateScanJobId);
+            return sOverrideImmediateScanJobId;
+        }
+        return getJobIdFromManifest(context, "immediateScanJobId");
+    }
+
+    /**
+     * Returns the job id to be used to schedule this job.  This may be set in the
+     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     * @param context the application context
+     * @return the job id
+     */
+    public static int getPeriodicScanJobId(Context context) {
+        if (sOverrideImmediateScanJobId >= 0) {
+            LogManager.i(TAG, "Using PeriodicScanJobId from static override: "+
+                    sOverridePeriodicScanJobId);
+            return sOverridePeriodicScanJobId;
+        }
+        return getJobIdFromManifest(context, "periodicScanJobId");
+    }
+
+    private static int getJobIdFromManifest(Context context, String name) {
+        PackageItemInfo info = null;
+        try {
+            info = context.getPackageManager().getServiceInfo(new ComponentName(context,
+                    ScanJob.class), PackageManager.GET_META_DATA);
+        } catch (PackageManager.NameNotFoundException e) { /* do nothing here */ }
+        if (info != null && info.metaData != null && info.metaData.get(name) != null) {
+            int jobId = info.metaData.getInt(name);
+            LogManager.i(TAG, "Using "+name+" from manifest: "+jobId);
+            return jobId;
+        }
+        else {
+            throw new RuntimeException("Cannot get job id from manifest.  " +
+                    "Make sure that the "+name+" is configured in the manifest for the ScanJob.");
+        }
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
new file mode 100644
index 00000000..30709d4c
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -0,0 +1,244 @@
+package org.altbeacon.beacon.service;
+
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.bluetooth.le.ScanResult;
+import android.content.ComponentName;
+import android.content.Context;
+import android.os.Build;
+import android.os.PersistableBundle;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+
+import org.altbeacon.beacon.BeaconLocalBroadcastProcessor;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Schedules two types of ScanJobs:
+ *  1. Periodic, which are set to go every scanPeriod+betweenScanPeriod
+ *  2. Immediate, which go right now.
+ *
+ *  Immediate ScanJobs are used when the app is in the foreground and wants to get immediate results
+ *  or when beacons have been detected with background scan filters and delivered via Intents and
+ *  a scan needs to run in a timely manner to collect data about those beacons known to be newly
+ *  in the vicinity despite the app being in the background.
+ *
+ * Created by dyoung on 6/7/17.
+ * @hide
+ */
+@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
+public class ScanJobScheduler {
+    private static final String TAG = ScanJobScheduler.class.getSimpleName();
+    private static final Object SINGLETON_LOCK = new Object();
+    private static final long MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING = 10000L;
+    @Nullable
+    private static volatile ScanJobScheduler sInstance = null;
+    @NonNull
+    private Long mScanJobScheduleTime = 0L;
+    @NonNull
+    private List<ScanResult> mBackgroundScanResultQueue = new ArrayList<>();
+    @Nullable
+    private BeaconLocalBroadcastProcessor mBeaconNotificationProcessor;
+
+    @NonNull
+    public static ScanJobScheduler getInstance() {
+        ScanJobScheduler instance = sInstance;
+        if (instance == null) {
+            synchronized (SINGLETON_LOCK) {
+                instance = sInstance;
+                if (instance == null) {
+                    sInstance = instance = new ScanJobScheduler();
+                }
+            }
+        }
+        return instance;
+    }
+
+    private ScanJobScheduler() {
+    }
+
+    private void ensureNotificationProcessorSetup(Context context) {
+        if (mBeaconNotificationProcessor == null) {
+            mBeaconNotificationProcessor = new BeaconLocalBroadcastProcessor(context);
+            mBeaconNotificationProcessor.register();
+        }
+    }
+
+    /**
+     * @return previoulsy queued scan results delivered in the background
+     */
+    List<ScanResult> dumpBackgroundScanResultQueue() {
+        List<ScanResult> retval = mBackgroundScanResultQueue;
+        mBackgroundScanResultQueue = new ArrayList<>();
+        return retval;
+    }
+
+    private void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
+        scanState.applyChanges(beaconManager);
+        LogManager.d(TAG, "Applying scan job settings with background mode "+scanState.getBackgroundMode());
+        schedule(context, scanState, false);
+    }
+
+    public void applySettingsToScheduledJob(Context context, BeaconManager beaconManager) {
+        LogManager.d(TAG, "Applying settings to ScanJob");
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        ScanState scanState = ScanState.restore(context);
+        applySettingsToScheduledJob(context, beaconManager, scanState);
+    }
+
+    // This method appears to be never used, because it is only used by Android O APIs, which
+    // must exist on another branch until the SDKs are released.
+    public void scheduleAfterBackgroundWakeup(Context context, List<ScanResult> scanResults) {
+        if (scanResults != null) {
+            mBackgroundScanResultQueue.addAll(scanResults);
+        }
+        synchronized (this) {
+            // We typically get a bunch of calls in a row here, separated by a few millis.  Only do this once.
+            if (System.currentTimeMillis() - mScanJobScheduleTime > MIN_MILLIS_BETWEEN_SCAN_JOB_SCHEDULING) {
+                LogManager.d(TAG, "scheduling an immediate scan job because last did "+(System.currentTimeMillis() - mScanJobScheduleTime)+"seconds ago.");
+                mScanJobScheduleTime = System.currentTimeMillis();
+            }
+            else {
+                LogManager.d(TAG, "Not scheduling an immediate scan job because we just did recently.");
+                return;
+            }
+        }
+        ScanState scanState = ScanState.restore(context);
+        schedule(context, scanState, true);
+    }
+
+    public void forceScheduleNextScan(Context context) {
+        ScanState scanState = ScanState.restore(context);
+        schedule(context, scanState, false);
+    }
+
+    private void schedule(Context context, ScanState scanState, boolean backgroundWakeup) {
+        ensureNotificationProcessorSetup(context);
+
+        long betweenScanPeriod = scanState.getScanJobIntervalMillis() - scanState.getScanJobRuntimeMillis();
+
+        long millisToNextJobStart;
+        if (backgroundWakeup) {
+            LogManager.d(TAG, "We just woke up in the background based on a new scan result.  Start scan job immediately.");
+            millisToNextJobStart = 0;
+        }
+        else {
+            if (betweenScanPeriod > 0) {
+                // If we pause between scans, then we need to start scanning on a normalized time
+                millisToNextJobStart = (SystemClock.elapsedRealtime() % scanState.getScanJobIntervalMillis());
+            }
+            else {
+                millisToNextJobStart = 0;
+            }
+
+            if (millisToNextJobStart < 50) {
+                // always wait a little bit to start scanning in case settings keep changing.
+                // by user restarting settings and scanning.  50ms should be fine
+                millisToNextJobStart = 50;
+            }
+        }
+
+        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+
+        if (backgroundWakeup || !scanState.getBackgroundMode()) {
+            // If we are in the foreground, and we want to start a scan soon, we will schedule an
+            // immediate job
+            if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
+                // If the next time we want to scan is less than 50ms from the periodic scan cycle, then]
+                // we schedule it for that specific time.
+                LogManager.d(TAG, "Scheduling immediate ScanJob to run in "+millisToNextJobStart+" millis");
+                JobInfo immediateJob = new JobInfo.Builder(ScanJob.getImmediateScanJobId(context), new ComponentName(context, ScanJob.class))
+                        .setPersisted(true) // This makes it restart after reboot
+                        .setExtras(new PersistableBundle())
+                        .setMinimumLatency(millisToNextJobStart)
+                        .setOverrideDeadline(millisToNextJobStart).build();
+                int error = jobScheduler.schedule(immediateJob);
+                if (error < 0) {
+                    LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+                }
+            } else {
+                LogManager.d(TAG, "Not scheduling immediate scan, assuming periodic is about to run");
+            }
+        }
+        else {
+            LogManager.d(TAG, "Not scheduling an immediate scan because we are in background mode.   Cancelling existing immediate scan.");
+            jobScheduler.cancel(ScanJob.getImmediateScanJobId(context));
+        }
+
+        JobInfo.Builder periodicJobBuilder = new JobInfo.Builder(ScanJob.getPeriodicScanJobId(context), new ComponentName(context, ScanJob.class))
+                .setPersisted(true) // This makes it restart after reboot
+                .setExtras(new PersistableBundle());
+
+        if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+            // ON Android N+ we specify a tolerance of 0ms (capped at 5% by the OS) to ensure
+            // our scans happen within 5% of the schduled time.
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis(), 0L).build();
+        }
+        else {
+            periodicJobBuilder.setPeriodic(scanState.getScanJobIntervalMillis()).build();
+        }
+        // On Android O I see this:
+        //
+        // 06-07 22:15:51.361 6455-6455/org.altbeacon.beaconreference W/JobInfo: Specified interval for 1 is +5m10s0ms. Clamped to +15m0s0ms
+        // 06-07 22:15:51.361 6455-6455/org.altbeacon.beaconreference W/JobInfo: Specified flex for 1 is 0. Clamped to +5m0s0ms
+        //
+        // This suggests logs are being clamped at a max of every 15 minutes +/- 5 minutes in the background
+        // This is the same way it worked on Android N per this post: https://stackoverflow.com/questions/38344220/job-scheduler-not-running-on-android-n
+        //
+        // In practice, I see the following runtimes on the Nexus Player with Android O
+        // This shows that the 15 minutes has some slop.
+        //
+        /*
+06-07 22:25:51.380 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@7188bc6
+06-07 22:41:01.227 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@382ed7b
+06-07 22:55:51.373 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@203c928
+06-07 23:10:59.083 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@dc96415
+06-07 23:25:51.371 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@68bed2e
+06-07 23:40:59.142 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c295843
+06-07 23:55:51.369 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@cd047e4
+06-08 00:10:59.082 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@8009a61
+06-08 00:25:51.368 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@f1fa2ca
+06-08 00:40:59.085 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@88dddef
+06-08 00:55:51.374 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@eb2b360
+06-08 01:10:51.670 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@9bca225
+06-08 01:25:51.383 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@871c8fe
+06-08 01:45:51.404 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@3bf42d3
+06-08 01:56:12.354 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c3d4e34
+06-08 02:21:51.771 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@1557571
+06-08 02:37:01.861 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@e2c879a
+06-08 02:52:11.943 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@c9f0d7f
+06-08 03:07:22.041 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@4e0cab0
+06-08 03:23:12.696 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@1139a7d
+06-08 03:38:22.776 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@e06b8f6
+06-08 03:52:12.792 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@74147eb
+06-08 04:08:32.872 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@90d9fec
+06-08 04:21:12.856 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@a4abd49
+06-08 04:38:42.959 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@741d912
+06-08 04:50:12.923 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@15bfe17
+06-08 05:08:53.047 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@fa229e8
+06-08 05:19:13.050 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@b0e49d5
+06-08 05:39:03.142 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@18823ee
+06-08 05:54:13.212 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@a72fc03
+06-08 06:10:51.850 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@3fb84a4
+06-08 06:26:01.917 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@53d6c21
+06-08 06:41:11.994 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@848958a
+06-08 06:56:22.053 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@43cdaf
+06-08 07:06:32.119 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@5318c20
+06-08 07:29:12.356 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@34f102d
+06-08 07:44:22.431 6455-6455/org.altbeacon.beaconreference I/ScanJob: Running periodic scan job: instance is org.altbeacon.beacon.service.ScanJob@4d2e9e6
+         */
+
+        final JobInfo jobInfo = periodicJobBuilder.build();
+        LogManager.d(TAG, "Scheduling ScanJob " + jobInfo + " to run every "+scanState.getScanJobIntervalMillis()+" millis");
+        int error = jobScheduler.schedule(jobInfo);
+        if (error < 0) {
+            LogManager.e(TAG, "Failed to schedule scan job.  Beacons will not be detected. Error: "+error);
+        }
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanState.java b/src/main/java/org/altbeacon/beacon/service/ScanState.java
new file mode 100644
index 00000000..3e3fbddd
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanState.java
@@ -0,0 +1,294 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+import android.util.Log;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InvalidClassException;
+import java.io.FileNotFoundException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static android.content.Context.MODE_PRIVATE;
+
+/**
+ * Stores the full state of scanning for the libary, including all settings so it can be ressurrected easily
+ * for running from a scheduled job
+ *
+ * Created by dyoung on 3/26/17.
+ * @hide
+ */
+
+public class ScanState implements Serializable {
+    private static final String TAG = ScanState.class.getSimpleName();
+    private static final String STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state";
+    private static final String TEMP_STATUS_PRESERVATION_FILE_NAME = "android-beacon-library-scan-state-temp";
+    public static int MIN_SCAN_JOB_INTERVAL_MILLIS = 300000; //  5 minutes
+
+    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
+    private transient MonitoringStatus mMonitoringStatus;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ExtraDataBeaconTracker mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+    private long mForegroundBetweenScanPeriod;
+    private long mBackgroundBetweenScanPeriod;
+    private long mForegroundScanPeriod;
+    private long mBackgroundScanPeriod;
+    private boolean mBackgroundMode;
+    private long mLastScanStartTimeMillis = 0l;
+    private transient Context mContext;
+
+    public Boolean getBackgroundMode() {
+        return mBackgroundMode;
+    }
+
+    public void setBackgroundMode(Boolean backgroundMode) {
+        mBackgroundMode = backgroundMode;
+    }
+
+    public Long getBackgroundBetweenScanPeriod() {
+        return mBackgroundBetweenScanPeriod;
+    }
+
+    public void setBackgroundBetweenScanPeriod(Long backgroundBetweenScanPeriod) {
+        mBackgroundBetweenScanPeriod = backgroundBetweenScanPeriod;
+    }
+
+    public Long getBackgroundScanPeriod() {
+        return mBackgroundScanPeriod;
+    }
+
+    public void setBackgroundScanPeriod(Long backgroundScanPeriod) {
+        mBackgroundScanPeriod = backgroundScanPeriod;
+    }
+
+    public Long getForegroundBetweenScanPeriod() {
+        return mForegroundBetweenScanPeriod;
+    }
+
+    public void setForegroundBetweenScanPeriod(Long foregroundBetweenScanPeriod) {
+        mForegroundBetweenScanPeriod = foregroundBetweenScanPeriod;
+    }
+
+    public Long getForegroundScanPeriod() {
+        return mForegroundScanPeriod;
+    }
+
+    public void setForegroundScanPeriod(Long foregroundScanPeriod) {
+        mForegroundScanPeriod = foregroundScanPeriod;
+    }
+
+    public ScanState(Context context) {
+        mContext = context;
+    }
+
+    public MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    public void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    public Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    public void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        mRangedRegionState = rangedRegionState;
+    }
+
+    public ExtraDataBeaconTracker getExtraBeaconDataTracker() {
+        return mExtraBeaconDataTracker;
+    }
+
+    public void setExtraBeaconDataTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraBeaconDataTracker = extraDataBeaconTracker;
+    }
+
+    public Set<BeaconParser> getBeaconParsers() {
+        return mBeaconParsers;
+    }
+
+    public void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    public long getLastScanStartTimeMillis() {
+        return mLastScanStartTimeMillis;
+    }
+    public void setLastScanStartTimeMillis(long time) {
+        mLastScanStartTimeMillis = time;
+    }
+
+    public static ScanState restore(Context context) {
+        ScanState scanState = null;
+        synchronized (ScanState.class) {
+            FileInputStream inputStream = null;
+            ObjectInputStream objectInputStream = null;
+            try {
+                inputStream = context.openFileInput(STATUS_PRESERVATION_FILE_NAME);
+                objectInputStream = new ObjectInputStream(inputStream);
+                scanState = (ScanState) objectInputStream.readObject();
+                scanState.mContext = context;
+            } catch (FileNotFoundException fnfe) {
+                LogManager.w(TAG, "Serialized ScanState does not exist.  This may be normal on first run.");
+            }
+            catch (IOException | ClassNotFoundException | ClassCastException e) {
+                if (e instanceof InvalidClassException) {
+                    LogManager.d(TAG, "Serialized ScanState has wrong class. Just ignoring saved state...");
+                }
+                else {
+                    LogManager.e(TAG, "Deserialization exception");
+                    Log.e(TAG, "error: ", e);
+                }
+
+            } finally {
+                if (null != inputStream) {
+                    try {
+                        inputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectInputStream != null) {
+                    try {
+                        objectInputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            if (scanState == null) {
+                scanState = new ScanState(context);
+
+            }
+            if (scanState.mExtraBeaconDataTracker == null) {
+                scanState.mExtraBeaconDataTracker = new ExtraDataBeaconTracker();
+            }
+            scanState.mMonitoringStatus = MonitoringStatus.getInstanceForApplication(context);
+            LogManager.d(TAG, "Scan state restore regions: monitored="+scanState.getMonitoringStatus().regions().size()+" ranged="+scanState.getRangedRegionState().keySet().size());
+            return scanState;
+        }
+    }
+
+    public void save() {
+        synchronized (ScanState.class) {
+            // TODO: need to limit how big this object is somehow.
+            // Impose limits on ranged and monitored regions?
+            FileOutputStream outputStream = null;
+            ObjectOutputStream objectOutputStream = null;
+            try {
+                outputStream = mContext.openFileOutput(TEMP_STATUS_PRESERVATION_FILE_NAME, MODE_PRIVATE);
+                objectOutputStream = new ObjectOutputStream(outputStream);
+                objectOutputStream.writeObject(this);
+                File file = new File(mContext.getFilesDir(), STATUS_PRESERVATION_FILE_NAME);
+                File tempFile = new File(mContext.getFilesDir(), TEMP_STATUS_PRESERVATION_FILE_NAME);
+                LogManager.d(TAG, "Temp file is "+tempFile.getAbsolutePath());
+                LogManager.d(TAG, "Perm file is "+file.getAbsolutePath());
+
+                if (!file.delete()) {
+                    LogManager.e(TAG, "Error while saving scan status to file: Cannot delete existing file.");
+                }
+                if (!tempFile.renameTo(file)) {
+                    LogManager.e(TAG, "Error while saving scan status to file: Cannot rename temp file.");
+                }
+            } catch (IOException e) {
+                LogManager.e(TAG, "Error while saving scan status to file: ", e.getMessage());
+            } finally {
+                if (null != outputStream) {
+                    try {
+                        outputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+                if (objectOutputStream != null) {
+                    try {
+                        objectOutputStream.close();
+                    } catch (IOException ignored) {
+                    }
+                }
+            }
+            mMonitoringStatus.saveMonitoringStatusIfOn();
+        }
+    }
+
+    public int getScanJobIntervalMillis() {
+        long cyclePeriodMillis;
+        if (getBackgroundMode()) {
+            cyclePeriodMillis = getBackgroundScanPeriod()+getBackgroundBetweenScanPeriod();
+        }
+        else {
+            cyclePeriodMillis = getForegroundScanPeriod()+getForegroundBetweenScanPeriod();
+        }
+        int scanJobIntervalMillis = MIN_SCAN_JOB_INTERVAL_MILLIS;
+        if (cyclePeriodMillis > MIN_SCAN_JOB_INTERVAL_MILLIS) {
+            scanJobIntervalMillis = (int) cyclePeriodMillis;
+        }
+        return scanJobIntervalMillis;
+    }
+
+    public int getScanJobRuntimeMillis() {
+        long scanPeriodMillis;
+        LogManager.d(TAG, "ScanState says background mode for ScanJob is "+getBackgroundMode());
+        if (getBackgroundMode()) {
+            scanPeriodMillis = getBackgroundScanPeriod();
+        }
+        else {
+            scanPeriodMillis = getForegroundScanPeriod();
+        }
+        if (!getBackgroundMode()) {
+            // if we are in the foreground, we keep the scan job going for the minimum interval
+            if (scanPeriodMillis < MIN_SCAN_JOB_INTERVAL_MILLIS) {
+                return MIN_SCAN_JOB_INTERVAL_MILLIS;
+            }
+        }
+        return (int) scanPeriodMillis;
+    }
+
+
+
+    public void applyChanges(BeaconManager beaconManager) {
+        mBeaconParsers = new HashSet<>(beaconManager.getBeaconParsers());
+        mForegroundScanPeriod = beaconManager.getForegroundScanPeriod();
+        mForegroundBetweenScanPeriod = beaconManager.getForegroundBetweenScanPeriod();
+        mBackgroundScanPeriod = beaconManager.getBackgroundScanPeriod();
+        mBackgroundBetweenScanPeriod = beaconManager.getBackgroundBetweenScanPeriod();
+        mBackgroundMode = beaconManager.getBackgroundMode();
+
+        ArrayList<Region> existingMonitoredRegions = new ArrayList<>(mMonitoringStatus.regions());
+        ArrayList<Region> existingRangedRegions = new ArrayList<>(mRangedRegionState.keySet());
+        ArrayList<Region> newMonitoredRegions = new ArrayList<>(beaconManager.getMonitoredRegions());
+        ArrayList<Region> newRangedRegions = new ArrayList<>(beaconManager.getRangedRegions());
+        LogManager.d(TAG, "ranged regions: old="+existingRangedRegions.size()+" new="+newRangedRegions.size());
+        LogManager.d(TAG, "monitored regions: old="+existingMonitoredRegions.size()+" new="+newMonitoredRegions.size());
+
+        for (Region newRangedRegion: newRangedRegions) {
+            if (!existingRangedRegions.contains(newRangedRegion)) {
+                LogManager.d(TAG, "Starting ranging region: "+newRangedRegion);
+                mRangedRegionState.put(newRangedRegion, new RangeState(new Callback(mContext.getPackageName())));
+            }
+        }
+        for (Region existingRangedRegion: existingRangedRegions) {
+            if (!newRangedRegions.contains(existingRangedRegion)) {
+                LogManager.d(TAG, "Stopping ranging region: "+existingRangedRegion);
+                mRangedRegionState.remove(existingRangedRegion);
+            }
+        }
+        LogManager.d(TAG, "Updated state with "+newRangedRegions.size()+" ranging regions and "+newMonitoredRegions.size()+" monitoring regions.");
+
+        this.save();
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/beacon/service/SettingsData.java b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
new file mode 100644
index 00000000..d1202336
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
@@ -0,0 +1,108 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by dyoung on 3/10/17.
+ *
+ * Internal class used to transfer settings between the BeaconService and the client
+ *
+ * @hide
+ */
+public class SettingsData implements Serializable {
+    private static final String TAG = SettingsData.class.getSimpleName();
+    private static final String SETTINGS_DATA_KEY = "SettingsData";
+    ArrayList<BeaconParser> mBeaconParsers;
+    Boolean mRegionStatePersistenceEnabled;
+    Boolean mAndroidLScanningDisabled;
+    Long mRegionExitPeriod;
+    Boolean mUseTrackingCache;
+    Boolean mHardwareEqualityEnforced;
+
+    // The following configuration settings are not implemented here, so they cannot be set when
+    // the scanning service is running in another process
+    //        BeaconManager.setDistanceModelUpdateUrl(...)
+    //        BeaconManager.setRssiFilterImplClass(...)
+    //        BeaconManager.setBeaconSimulator(...)
+    //        beaconManager.setNonBeaconLeScanCallback(...)
+
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(SETTINGS_DATA_KEY, this);
+        return bundle;
+    }
+    public static SettingsData fromBundle(@NonNull Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        SettingsData settingsData = null;
+        if (bundle.get(SETTINGS_DATA_KEY) != null) {
+            settingsData = (SettingsData) bundle.getSerializable(SETTINGS_DATA_KEY);
+        }
+        return settingsData;
+    }
+
+    public void apply(@NonNull BeaconService scanService) {
+        LogManager.d(TAG, "Applying settings changes to scanner in other process");
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(scanService);
+        List<BeaconParser> beaconParsers = beaconManager.getBeaconParsers();
+        boolean beaconParsersChanged = false;
+        if (beaconParsers.size() == mBeaconParsers.size()) {
+            for (int i = 0; i < beaconParsers.size(); i++) {
+                if (!beaconParsers.get(i).equals(mBeaconParsers.get(i))) {
+                    LogManager.d(TAG, "Beacon parsers have changed to: "+mBeaconParsers.get(i).getLayout());
+                    beaconParsersChanged = true;
+                    break;
+                }
+            }
+        }
+        else {
+            beaconParsersChanged = true;
+            LogManager.d(TAG, "Beacon parsers have been added or removed.");
+        }
+        if (beaconParsersChanged) {
+            LogManager.d(TAG, "Updating beacon parsers");
+            beaconManager.getBeaconParsers().clear();
+            beaconManager.getBeaconParsers().addAll(mBeaconParsers);
+            scanService.reloadParsers();
+        }
+        else {
+            LogManager.d(TAG, "Beacon parsers unchanged.");
+        }
+        MonitoringStatus monitoringStatus = MonitoringStatus.getInstanceForApplication(scanService);
+        if (monitoringStatus.isStatePreservationOn() &&
+                !mRegionStatePersistenceEnabled) {
+            monitoringStatus.stopStatusPreservation();
+        }
+        else if (!monitoringStatus.isStatePreservationOn() &&
+                mRegionStatePersistenceEnabled) {
+            monitoringStatus.startStatusPreservation();
+        }
+        beaconManager.setAndroidLScanningDisabled(mAndroidLScanningDisabled);
+        BeaconManager.setRegionExitPeriod(mRegionExitPeriod);
+        RangeState.setUseTrackingCache(mUseTrackingCache);
+        Beacon.setHardwareEqualityEnforced(mHardwareEqualityEnforced);
+    }
+
+    public SettingsData collect(@NonNull Context context) {
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context);
+        mBeaconParsers = new ArrayList<>(beaconManager.getBeaconParsers());
+        mRegionStatePersistenceEnabled = beaconManager.isRegionStatePersistenceEnabled();
+        mAndroidLScanningDisabled = beaconManager.isAndroidLScanningDisabled();
+        mRegionExitPeriod = BeaconManager.getRegionExitPeriod();
+        mUseTrackingCache = RangeState.getUseTrackingCache();
+        mHardwareEqualityEnforced = Beacon.getHardwareEqualityEnforced();
+        return this;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/StartRMData.java b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
index 89b37d15..cbd30c58 100644
--- a/src/main/java/org/altbeacon/beacon/service/StartRMData.java
+++ b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
@@ -23,63 +23,83 @@
  */
 package org.altbeacon.beacon.service;
 
+import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.support.annotation.NonNull;
 
 import org.altbeacon.beacon.Region;
 
 import java.io.Serializable;
 
+/**
+ *
+ * Internal class used to transfer ranging and monitoring data between the BeaconService and client
+ *
+ * @hide
+ */
 public class StartRMData implements Serializable, Parcelable {
-    private Region region;
-    private long scanPeriod;
-    private long betweenScanPeriod;
+    private static final String SCAN_PERIOD_KEY = "scanPeriod";
+    private static final String BETWEEN_SCAN_PERIOD_KEY = "betweenScanPeriod";
+    private static final String BACKGROUND_FLAG_KEY = "backgroundFlag";
+    private static final String CALLBACK_PACKAGE_NAME_KEY = "callbackPackageName";
+    private static final String REGION_KEY = "region";
+    private static final String HAS_MIDCYCLE_RANG_UPDATE_KEY = "hasMidCycleRangUpdate";
+    private static final String RANGE_UPDATE_PERIOD_KEY = "rangeUpdatePeriod";
+    private static final String BETWEEN_RANGE_UPDATE_PERIOD_KEY = "betweenRangeUpdatePeriod";
+
+    private Region mRegion;
+    private long mScanPeriod;
+    private long mBetweenScanPeriod;
     private boolean hasMidCycleRangUpdate;
     private long rangeUpdatePeriod;
     private long betweenRangeUpdatePeriod;
-    private boolean backgroundFlag;
-    private String callbackPackageName;
+    private boolean mBackgroundFlag;
+    private String mCallbackPackageName;
+
+    private StartRMData() {
+    }
 
-    public StartRMData(Region region, String callbackPackageName) {
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName) {
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
 
         this.hasMidCycleRangUpdate = false;
     }
     public StartRMData(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.backgroundFlag = backgroundFlag;
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mBackgroundFlag = backgroundFlag;
 
         this.hasMidCycleRangUpdate = false;
     }
 
     public StartRMData(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, long rangeUpdatePeriod, long betweenRangeUpdatePeriod) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.backgroundFlag = backgroundFlag;
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mBackgroundFlag = backgroundFlag;
 
         this.hasMidCycleRangUpdate = true;
         this.rangeUpdatePeriod = rangeUpdatePeriod;
         this.betweenRangeUpdatePeriod = betweenRangeUpdatePeriod;
     }
 
-    public StartRMData(Region region, String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
-        this.backgroundFlag = backgroundFlag;
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
+        this.mBackgroundFlag = backgroundFlag;
 
         this.hasMidCycleRangUpdate = false;
     }
 
-    public StartRMData(Region region, String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, long rangeUpdatePeriod, long betweenRangeUpdatePeriod) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
-        this.backgroundFlag = backgroundFlag;
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, long rangeUpdatePeriod, long betweenRangeUpdatePeriod) {
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
+        this.mBackgroundFlag = backgroundFlag;
 
         this.hasMidCycleRangUpdate = true;
         this.rangeUpdatePeriod = rangeUpdatePeriod;
@@ -87,29 +107,26 @@ public StartRMData(Region region, String callbackPackageName, long scanPeriod, l
     }
 
 
-
-    public long getScanPeriod() { return scanPeriod; }
-    public long getBetweenScanPeriod() { return betweenScanPeriod; }
+    public long getScanPeriod() { return mScanPeriod; }
+    public long getBetweenScanPeriod() { return mBetweenScanPeriod; }
     public boolean hasMidCycleRangeUpdates() { return hasMidCycleRangUpdate; }
     public long getRangeUpdatePeriod() { return rangeUpdatePeriod; }
     public long getBetweenRangeUpdatePeriod() {return betweenRangeUpdatePeriod;}
-    public Region getRegionData() {
-        return region;
-    }
     public String getCallbackPackageName() {
-        return callbackPackageName;
+        return mCallbackPackageName;
     }
-    public boolean getBackgroundFlag() { return backgroundFlag; }
+    public boolean getBackgroundFlag() { return mBackgroundFlag; }
     public int describeContents() {
         return 0;
     }
+    public Region getRegionData() { return mRegion; }
 
     public void writeToParcel(Parcel out, int flags) {
-        out.writeParcelable(region, flags);
-        out.writeString(callbackPackageName);
-        out.writeLong(scanPeriod);
-        out.writeLong(betweenScanPeriod);
-        out.writeByte((byte) (backgroundFlag ? 1 : 0));
+        out.writeParcelable(mRegion, flags);
+        out.writeString(mCallbackPackageName);
+        out.writeLong(mScanPeriod);
+        out.writeLong(mBetweenScanPeriod);
+        out.writeByte((byte) (mBackgroundFlag ? 1 : 0));
         out.writeByte((byte) (hasMidCycleRangUpdate ? 1 : 0));
         out.writeLong(rangeUpdatePeriod);
         out.writeLong(betweenRangeUpdatePeriod);
@@ -127,14 +144,63 @@ public StartRMData createFromParcel(Parcel in) {
     };
 
     private StartRMData(Parcel in) {
-        region = in.readParcelable(StartRMData.class.getClassLoader());
-        callbackPackageName = in.readString();
-        scanPeriod = in.readLong();
-        betweenScanPeriod = in.readLong();
-        backgroundFlag = in.readByte() != 0;
+        mRegion = in.readParcelable(StartRMData.class.getClassLoader());
+        mCallbackPackageName = in.readString();
+        mScanPeriod = in.readLong();
+        mBetweenScanPeriod = in.readLong();
+        mBackgroundFlag = in.readByte() != 0;
         hasMidCycleRangUpdate = in.readByte() != 0;
         rangeUpdatePeriod = in.readLong();
         betweenRangeUpdatePeriod = in.readLong();
     }
 
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putLong(SCAN_PERIOD_KEY, this.mScanPeriod);
+        bundle.putLong(BETWEEN_SCAN_PERIOD_KEY, this.mBetweenScanPeriod);
+        bundle.putBoolean(BACKGROUND_FLAG_KEY, this.mBackgroundFlag);
+        bundle.putString(CALLBACK_PACKAGE_NAME_KEY, this.mCallbackPackageName);
+        if (mRegion != null) {
+            bundle.putSerializable(REGION_KEY, mRegion);
+        }
+        return bundle;
+    }
+
+    public static StartRMData fromBundle(@NonNull Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        boolean valid = false;
+        StartRMData data = new StartRMData();
+        if (bundle.containsKey(REGION_KEY)) {
+            data.mRegion = (Region)bundle.getSerializable(REGION_KEY);
+            valid = true;
+        }
+        if (bundle.containsKey(SCAN_PERIOD_KEY)) {
+            data.mScanPeriod = (Long) bundle.get(SCAN_PERIOD_KEY);
+            valid = true;
+        }
+        if (bundle.containsKey(BETWEEN_SCAN_PERIOD_KEY)) {
+            data.mBetweenScanPeriod = (Long) bundle.get(BETWEEN_SCAN_PERIOD_KEY);
+        }
+        if (bundle.containsKey(BACKGROUND_FLAG_KEY)) {
+            data.mBackgroundFlag = (Boolean) bundle.get(BACKGROUND_FLAG_KEY);
+        }
+        if (bundle.containsKey(CALLBACK_PACKAGE_NAME_KEY)) {
+            data.mCallbackPackageName = (String) bundle.get(CALLBACK_PACKAGE_NAME_KEY);
+        }
+        if (bundle.containsKey(HAS_MIDCYCLE_RANG_UPDATE_KEY)) {
+            data.hasMidCycleRangUpdate = (Boolean) bundle.get(HAS_MIDCYCLE_RANG_UPDATE_KEY);
+        }
+        if (bundle.containsKey(RANGE_UPDATE_PERIOD_KEY)) {
+            data.rangeUpdatePeriod = (Long) bundle.get(RANGE_UPDATE_PERIOD_KEY);
+        }
+        if (bundle.containsKey(BETWEEN_RANGE_UPDATE_PERIOD_KEY)) {
+            data.betweenRangeUpdatePeriod = (Long) bundle.get(BETWEEN_RANGE_UPDATE_PERIOD_KEY);
+        }
+        if (valid) {
+            return data;
+        }
+        else {
+            return null;
+        }
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
index 8d96e37c..d2bf7592 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
@@ -1,12 +1,19 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.bluetooth.BluetoothDevice;
+import android.support.annotation.MainThread;
 
 /**
+ * Android API agnostic Bluetooth scan callback wrapper.
+ * <p>
+ * Since Android bluetooth scan callbacks occur on the main thread it is expected that these
+ * callbacks will also occur on the main thread.
+ *
  * Created by dyoung on 10/6/14.
  */
+@MainThread
 public interface CycledLeScanCallback {
-    public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);
-    public void onCycleEnd();
-    public void onMidScanRange();
+    void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);
+    void onCycleEnd();
+    void onMidScanRange();
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index 06d80594..40c24f0e 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -1,7 +1,6 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.Manifest;
-import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
@@ -15,15 +14,21 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.AnyThread;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
+
 import java.util.Date;
 
 @TargetApi(18)
 public abstract class CycledLeScanner {
+    public static final long ANDROID_N_MAX_SCAN_DURATION_MILLIS = 30 * 60 * 1000l; // 30 minutes
     private static final String TAG = "CycledLeScanner";
     private BluetoothAdapter mBluetoothAdapter;
 
@@ -36,6 +41,12 @@
     private long mRangeCycleUpdateTime = 0l;
     private Runnable mMidRangeRunnable = null;
 
+    // This is the last time this class actually commanded the OS
+    // to start scanning.
+    private long mCurrentScanStartTime = 0l;
+    // True if the app has explicitly requested long running scans that
+    // may go beyond what is normally allowed on Android N.
+    private boolean mLongScanForcingEnabled = false;
     private boolean mScanning;
     protected boolean mScanningPaused;
     private boolean mScanCyclerStarted = false;
@@ -43,11 +54,37 @@
     protected final Context mContext;
     private long mScanPeriod;
     private long mMidScanRangeUpdatePeriod;
+    // indicates that we decided not to turn scanning off at the end of a scan cycle (e.g. to
+    // avoid doing too many scans in a limited time on Android 7.0 or because we are capable of
+    // multiple detections.  If true, it indicates scanning needs to be stopped when we finish.
+    private boolean mScanningLeftOn = false;
 
     protected long mBetweenScanPeriod;
 
+    /**
+     * Main thread handle for scheduling scan cycle tasks.
+     * <p>
+     * Use this to schedule deferred tasks such as the following:
+     * <ul>
+     *     <li>{@link #scheduleScanCycleStop()}</li>
+     *     <li>{@link #scanLeDevice(Boolean) scanLeDevice(true)} from {@link #deferScanIfNeeded()}</li>
+     * </ul>
+     */
+    @NonNull
     protected final Handler mHandler = new Handler(Looper.getMainLooper());
+
+    /**
+     * Handler to background thread for interacting with the low-level Android BLE scanner.
+     * <p>
+     * Use this to queue any potentially long running BLE scanner actions such as starts and stops.
+     */
+    @NonNull
     protected final Handler mScanHandler;
+
+    /**
+     * Worker thread hosting the internal scanner message queue.
+     */
+    @NonNull
     private final HandlerThread mScanThread;
 
     protected final BluetoothCrashResolver mBluetoothCrashResolver;
@@ -56,7 +93,22 @@
     protected boolean mBackgroundFlag = false;
     protected boolean mRestartNeeded = false;
 
-    private boolean mDistinctPacketsDetectedPerScan = false;
+    /**
+     * Flag indicating device hardware supports detecting multiple identical packets per scan.
+     * <p>
+     * Restarting scanning (stopping and immediately restarting) is necessary on many older Android
+     * devices like the Nexus 4 and Moto G because once they detect a distinct BLE packet in a scan,
+     * subsequent detections do not get a scan callback. Stopping scanning and restarting clears
+     * this out, allowing subsequent detection of identical advertisements. On most newer device,
+     * this is not necessary, and multiple callbacks are given for identical packets detected in
+     * a single scan.
+     * <p>
+     * This is declared {@code volatile} because it may be set by a background scan thread while
+     * we are in a method on the main thread which will end up checking it. Using this modifier
+     * ensures that when we read the flag we'll always see the most recently written value. This is
+     * also true for background scan threads which may be running concurrently.
+     */
+    private volatile boolean mDistinctPacketsDetectedPerScan = false;
     private static final long ANDROID_N_MIN_SCAN_CYCLE_MILLIS = 6000l;
 
     protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
@@ -80,31 +132,49 @@ public void run() {
     }
 
     public static CycledLeScanner createScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
-        boolean useAndroidLScanner;
+        boolean useAndroidLScanner = false;
+        boolean useAndroidOScanner = false;
         if (android.os.Build.VERSION.SDK_INT < 18) {
             LogManager.w(TAG, "Not supported prior to API 18.");
             return null;
         }
 
-        if (android.os.Build.VERSION.SDK_INT < 21) {
-            LogManager.i(TAG, "This is not Android 5.0.  We are using old scanning APIs");
+        if (android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
+            LogManager.i(TAG, "This is pre Android 5.0.  We are using old scanning APIs");
             useAndroidLScanner = false;
-        } else {
+
+        }
+        else if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
             if (BeaconManager.isAndroidLScanningDisabled()) {
-                LogManager.i(TAG, "This Android 5.0, but L scanning is disabled. We are using old scanning APIs");
+                LogManager.i(TAG, "This is Android 5.0, but L scanning is disabled. We are using old scanning APIs");
                 useAndroidLScanner = false;
             } else {
-                LogManager.i(TAG, "This Android 5.0.  We are using new scanning APIs");
+                LogManager.i(TAG, "This is Android 5.0.  We are using new scanning APIs");
                 useAndroidLScanner = true;
             }
         }
+        else {
+            LogManager.i(TAG, "Using Android O scanner");
+            useAndroidOScanner = true;
+        }
 
-        if (useAndroidLScanner) {
+        if (useAndroidOScanner) {
+            return new CycledLeScannerForAndroidO(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
+        }
+        else if (useAndroidLScanner) {
             return new CycledLeScannerForLollipop(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         } else {
             return new CycledLeScannerForJellyBeanMr2(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         }
+    }
 
+    /**
+     * Enables the scanner to go to extra lengths to keep scans going for longer than would
+     * otherwise be allowed.  Useful only for Android N and higher.
+     * @param enabled
+     */
+    public void setLongScanForcingEnabled(boolean enabled) {
+        mLongScanForcingEnabled = enabled;
     }
 
     public void setRangeUpdatePeriods(long rangeUpdatePeriod, long betweenRangeUpdate) {
@@ -118,6 +188,7 @@ public void setRangeUpdatePeriods(long rangeUpdatePeriod, long betweenRangeUpdat
      * between LOW_POWER_MODE vs. LOW_LATENCY_MODE
      * @param backgroundFlag
      */
+    @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
         LogManager.d(TAG, "Set scan periods called with %s, %s Background mode must have changed.",
                 scanPeriod, betweenScanPeriod);
@@ -158,6 +229,7 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
         }
     }
 
+    @MainThread
     public void start() {
         LogManager.d(TAG, "start called");
         mScanningEnabled = true;
@@ -168,27 +240,57 @@ public void start() {
         }
     }
 
-    @SuppressLint("NewApi")
+    @MainThread
     public void stop() {
         LogManager.d(TAG, "stop called");
         mScanningEnabled = false;
         if (mScanCyclerStarted) {
             scanLeDevice(false);
+            // If we have left scanning on between scan periods, now is the time to shut it off.
+            if (mScanningLeftOn) {
+                LogManager.d(TAG, "Stopping scanning previously left on.");
+                mScanningLeftOn = false;
+                try {
+                    LogManager.d(TAG, "stopping bluetooth le scan");
+                    finishScan();
+                } catch (Exception e) {
+                    LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
+                }
+            }
         } else {
             LogManager.d(TAG, "scanning already stopped");
         }
     }
 
+    @AnyThread
     public boolean getDistinctPacketsDetectedPerScan() {
         return mDistinctPacketsDetectedPerScan;
     }
 
+    @AnyThread
     public void setDistinctPacketsDetectedPerScan(boolean detected) {
         mDistinctPacketsDetectedPerScan = detected;
     }
 
+    @MainThread
     public void destroy() {
-        mScanThread.quit();
+        LogManager.d(TAG, "Destroying");
+
+        // Remove any postDelayed Runnables queued for the next scan cycle
+        mHandler.removeCallbacksAndMessages(null);
+
+        // We cannot quit the thread used by the handler until queued Runnables have been processed,
+        // because the handler is what stops scanning, and we do not want scanning left on.
+        // So we stop the thread using the handler, so we make sure it happens after all other
+        // waiting Runnables are finished.
+        mScanHandler.post(new Runnable() {
+            @WorkerThread
+            @Override
+            public void run() {
+                LogManager.d(TAG, "Quitting scan thread");
+                mScanThread.quit();
+            }
+        });
     }
 
     protected abstract void stopScan();
@@ -197,14 +299,14 @@ public void destroy() {
 
     protected abstract void startScan();
 
-    @SuppressLint("NewApi")
+    @MainThread
     protected void scanLeDevice(final Boolean enable) {
         try {
             mScanCyclerStarted = true;
             if (getBluetoothAdapter() == null) {
                 LogManager.e(TAG, "No Bluetooth adapter.  beaconService cannot scan.");
             }
-            if (enable) {
+            if (mScanningEnabled && enable) {
                 if (deferScanIfNeeded()) {
                     return;
                 }
@@ -227,6 +329,7 @@ protected void scanLeDevice(final Boolean enable) {
                                         }
                                         try {
                                             if (android.os.Build.VERSION.SDK_INT < 23 || checkLocationPermission()) {
+                                                mCurrentScanStartTime = SystemClock.elapsedRealtime();
                                                 startScan();
                                             }
                                         } catch (Exception e) {
@@ -245,7 +348,9 @@ protected void scanLeDevice(final Boolean enable) {
                         LogManager.e(e, TAG, "Exception starting Bluetooth scan.  Perhaps Bluetooth is disabled or unavailable?");
                     }
                 } else {
-                    LogManager.d(TAG, "We are already scanning");
+                    LogManager.d(TAG, "We are already scanning and have been for "+(
+                            SystemClock.elapsedRealtime() - mCurrentScanStartTime
+                            )+" millis");
                 }
                 mScanCycleStopTime = (SystemClock.elapsedRealtime() + mScanPeriod);
                 mRangeCycleUpdateTime = (SystemClock.elapsedRealtime() + mMidScanRangeUpdatePeriod);
@@ -260,7 +365,13 @@ protected void scanLeDevice(final Boolean enable) {
                 mScanning = false;
                 mScanCyclerStarted = false;
                 stopScan();
+                mCurrentScanStartTime = 0l;
                 mLastScanCycleEndTime = SystemClock.elapsedRealtime();
+                // Clear any queued schedule tasks as we're done scanning
+                // This must be mHandler not mScanHandler.  mHandler is what does the scanning work.
+                // If this is set to mScanHandler, then this can prevent a scan stop.
+                mHandler.removeCallbacksAndMessages(null);
+                finishScanCycle();
             }
         }
         catch (SecurityException e) {
@@ -281,17 +392,19 @@ protected  void scheduleCycleRangeUpdate() {
         }
     }
 
+    @MainThread
     protected void scheduleScanCycleStop() {
 
         // Stops scanning after a pre-defined scan period.
         long millisecondsUntilStop = mScanCycleStopTime - SystemClock.elapsedRealtime();
-        if (millisecondsUntilStop > 0) {
+        if (mScanningEnabled && millisecondsUntilStop > 0) {
             LogManager.d(TAG, "Waiting to stop scan cycle for another %s milliseconds",
                     millisecondsUntilStop);
             if (mBackgroundFlag) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scheduleScanCycleStop();
@@ -305,6 +418,7 @@ public void run() {
 
     protected abstract void finishScan();
 
+    @MainThread
     private void finishScanCycle() {
         LogManager.d(TAG, "Done with scan cycle");
         try {
@@ -321,7 +435,9 @@ private void finishScanCycle() {
                         // so it is best avoided.  If we know the device has detected to distinct
                         // packets in the same cycle, we will not restart scanning and just keep it
                         // going.
-                        if (!getDistinctPacketsDetectedPerScan()) {
+                        if (!mDistinctPacketsDetectedPerScan ||
+                                mBetweenScanPeriod != 0 ||
+                                mustStopScanToPreventAndroidNScanTimeout()) {
                             long now = SystemClock.elapsedRealtime();
                             if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
                                     mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
@@ -333,11 +449,13 @@ private void finishScanCycle() {
                                 LogManager.d(TAG, "Not stopping scan because this is Android N and we" +
                                         " keep scanning for a minimum of 6 seconds at a time. "+
                                         "We will stop in "+(ANDROID_N_MIN_SCAN_CYCLE_MILLIS-(now-mLastScanCycleStartTime))+" millisconds.");
+                                mScanningLeftOn = true;
                             }
                             else {
                                 try {
                                     LogManager.d(TAG, "stopping bluetooth le scan");
                                     finishScan();
+                                    mScanningLeftOn = false;
                                 } catch (Exception e) {
                                     LogManager.w(e, TAG, "Internal Android exception scanning for beacons");
                                 }
@@ -345,11 +463,13 @@ private void finishScanCycle() {
                         }
                         else {
                             LogManager.d(TAG, "Not stopping scanning.  Device capable of multiple indistinct detections per scan.");
+                            mScanningLeftOn = true;
                         }
 
                         mLastScanCycleEndTime = SystemClock.elapsedRealtime();
                     } else {
                         LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
+                        mRestartNeeded = true;
                     }
                 }
                 mNextScanCycleStartTime = getNextScanStartTime();
@@ -358,7 +478,7 @@ private void finishScanCycle() {
                 }
             }
             if (!mScanningEnabled) {
-                LogManager.d(TAG, "Scanning disabled.  No ranging or monitoring regions are active.");
+                LogManager.d(TAG, "Scanning disabled. ");
                 mScanCyclerStarted = false;
                 cancelWakeUpAlarm();
             }
@@ -455,4 +575,35 @@ private boolean checkLocationPermission() {
     private boolean checkPermission(final String permission) {
         return mContext.checkPermission(permission, android.os.Process.myPid(), android.os.Process.myUid()) == PackageManager.PERMISSION_GRANTED;
     }
+
+    /**
+     * On Android N and later, a scan that runs for more than 30 minutes will be automatically
+     * stopped by the OS and converted to an "opportunistic" scan, meaning that they will only yield
+     * detections if another app is scanning.  This is inteneded to save battery.  This can be
+     * prevented by stopping scanning and restarting.  This method returns true if:
+     *   * this is Android N or later
+     *   * we are close to the 30 minute boundary since the last scan started
+     *   * The app developer has explicitly enabled long-running scans
+     * @return true if we must stop scanning to prevent
+     */
+    private boolean mustStopScanToPreventAndroidNScanTimeout() {
+        long timeOfNextScanCycleEnd = SystemClock.elapsedRealtime() +  mBetweenScanPeriod +
+                mScanPeriod;
+        boolean timeoutAtRisk = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
+                mCurrentScanStartTime > 0 &&
+                (timeOfNextScanCycleEnd - mCurrentScanStartTime > ANDROID_N_MAX_SCAN_DURATION_MILLIS);
+
+        if (timeoutAtRisk) {
+            LogManager.d(TAG, "The next scan cycle would go over the Android N max duration.");
+            if  (mLongScanForcingEnabled) {
+                LogManager.d(TAG, "Stopping scan to prevent Android N scan timeout.");
+                return true;
+            }
+            else {
+                LogManager.w(TAG, "Allowing a long running scan to be stopped by the OS.  To " +
+                        "prevent this, set longScanForcingEnabled in the AndroidBeaconLibrary.");
+            }
+        }
+        return false;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
new file mode 100644
index 00000000..fe095400
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForAndroidO.java
@@ -0,0 +1,28 @@
+package org.altbeacon.beacon.service.scanner;
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import org.altbeacon.bluetooth.BluetoothCrashResolver;
+import java.util.Set;
+
+/**
+ * The scanner used for Android O is effectively the same as used for JellyBeaconMr2.  There is no
+ * point in using the low power scanning APIs introduced in Lollipop, because they only work when
+ * the app is running, effectively requiring a long running service, something newly disallowed
+ * by Android O.  The new strategy for Android O is to use a JobScheduler combined with background
+ * scans delivered by Intents.
+ *
+ * @see org.altbeacon.beacon.service.ScanJob
+ * @see org.altbeacon.beacon.service.ScanHelper#startAndroidOBackgroundScan(Set)
+ *
+ * Created by dyoung on 5/28/17.
+ */
+
+@TargetApi(26)
+class CycledLeScannerForAndroidO extends CycledLeScannerForLollipop {
+    private static final String TAG = CycledLeScannerForAndroidO.class.getSimpleName();
+
+    CycledLeScannerForAndroidO(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
+        super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
index b38f7281..e9f51a74 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
@@ -5,6 +5,8 @@
 import android.bluetooth.BluetoothDevice;
 import android.content.Context;
 import android.os.SystemClock;
+import android.support.annotation.MainThread;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
@@ -36,6 +38,7 @@ protected boolean deferScanIfNeeded() {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scanLeDevice(true);
@@ -65,6 +68,7 @@ private void postStartLeScan() {
         final BluetoothAdapter.LeScanCallback leScanCallback = getLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -85,6 +89,7 @@ private void postStopLeScan() {
         final BluetoothAdapter.LeScanCallback leScanCallback = getLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -107,7 +112,9 @@ public void onLeScan(final BluetoothDevice device, final int rssi,
                                              final byte[] scanRecord) {
                             LogManager.d(TAG, "got record");
                             mCycledLeScanCallback.onLeScan(device, rssi, scanRecord);
-                            mBluetoothCrashResolver.notifyScannedDevice(device, getLeScanCallback());
+                            if (mBluetoothCrashResolver != null) {
+                                mBluetoothCrashResolver.notifyScannedDevice(device, getLeScanCallback());
+                            }
                         }
                     };
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index 82251314..011c890d 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -8,8 +8,12 @@
 import android.bluetooth.le.ScanResult;
 import android.bluetooth.le.ScanSettings;
 import android.content.Context;
+import android.content.Intent;
 import android.os.ParcelUuid;
 import android.os.SystemClock;
+import android.support.annotation.MainThread;
+import android.support.annotation.WorkerThread;
+import android.support.v4.content.LocalBroadcastManager;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
@@ -27,8 +31,7 @@
     private BluetoothLeScanner mScanner;
     private ScanCallback leScanCallback;
     private long mBackgroundLScanStartTime = 0l;
-    private long mBackgroundLScanFirstDetectionTime = 0l;
-    private boolean mScanDeferredBefore = false;
+    private long mBackgroundLScanFirstDetectionTime = 0;
     private boolean mMainScanCycleActive = false;
     private final BeaconManager mBeaconManager;
 
@@ -77,51 +80,60 @@ then no beacons will be detected until the next scan cycle starts (5 minutes max
     protected boolean deferScanIfNeeded() {
         // This method is called to see if it is time to start a scan
         long millisecondsUntilStart = mNextScanCycleStartTime - SystemClock.elapsedRealtime();
-        if (millisecondsUntilStart > 0) {
-            mMainScanCycleActive = false;
-            if (true) {
-                long secsSinceLastDetection = SystemClock.elapsedRealtime() -
-                        DetectionTracker.getInstance().getLastDetectionTime();
-                // If we have seen a device recently
-                // devices should behave like pre-Android L devices, because we don't want to drain battery
-                // by continuously delivering packets for beacons visible in the background
-                if (mScanDeferredBefore == false) {
-                    if (secsSinceLastDetection > BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
-                        mBackgroundLScanStartTime = SystemClock.elapsedRealtime();
-                        mBackgroundLScanFirstDetectionTime = 0l;
-                        LogManager.d(TAG, "This is Android L. Doing a filtered scan for the background.");
-
-                        // On Android L, between scan cycles do a scan with a filter looking for any beacon
-                        // if we see one of those beacons, we need to deliver the results
+        final boolean deferScan = millisecondsUntilStart > 0;
+        final boolean scanActiveBefore = mMainScanCycleActive;
+        mMainScanCycleActive = !deferScan;
+        if (deferScan) {
+            long secsSinceLastDetection = SystemClock.elapsedRealtime() -
+                    DetectionTracker.getInstance().getLastDetectionTime();
+            // If we have seen a device recently
+            // devices should behave like pre-Android L devices, because we don't want to drain battery
+            // by continuously delivering packets for beacons visible in the background
+            if (scanActiveBefore) {
+                if (secsSinceLastDetection > BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
+                    mBackgroundLScanStartTime = SystemClock.elapsedRealtime();
+                    mBackgroundLScanFirstDetectionTime = 0l;
+                    LogManager.d(TAG, "This is Android L. Preparing to do a filtered scan for the background.");
+                    // On Android L, between scan cycles do a scan with a filter looking for any beacon
+                    // if we see one of those beacons, we need to deliver the results
+                    // Only scan between cycles if the between can cycle time > 6 seconds.  A shorter low
+                    // power scan is unlikely to be useful, and might trigger a "scanning too frequently"
+                    // error on Android N.
+                    if (mBetweenScanPeriod > 6000l) {
                         startScan();
-                    } else {
-                        // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
-                        // This API is now available in Android M
-                        LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
-                                + "ago, so we will not keep scanning in background.",
-                                secsSinceLastDetection);
                     }
+                    else {
+                        LogManager.d(TAG, "Suppressing scan between cycles because the between scan cycle is too short.");
+                    }
+
+
+                } else {
+                    // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
+                    // This API is now available in Android M
+                    LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
+                            + "ago, so we will not keep scanning in background.",
+                            secsSinceLastDetection);
                 }
-                if (mBackgroundLScanStartTime > 0l) {
-                    // if we are in here, we have detected beacons recently in a background L scan
-                    if (DetectionTracker.getInstance().getLastDetectionTime() > mBackgroundLScanStartTime) {
-                        if (mBackgroundLScanFirstDetectionTime == 0l) {
-                            mBackgroundLScanFirstDetectionTime = DetectionTracker.getInstance().getLastDetectionTime();
-                        }
-                        if (SystemClock.elapsedRealtime() - mBackgroundLScanFirstDetectionTime
-                                >= BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
-                            // if we are in here, it has been more than 10 seconds since we detected
-                            // a beacon in background L scanning mode.  We need to stop scanning
-                            // so we do not drain battery
-                            LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
-                            stopScan();
-                            mBackgroundLScanStartTime = 0l;
-                        }
-                        else {
-                            // report the results up the chain
-                            LogManager.d(TAG, "Delivering Android L background scanning results");
-                            mCycledLeScanCallback.onCycleEnd();
-                        }
+            }
+            if (mBackgroundLScanStartTime > 0l) {
+                // if we are in here, we have detected beacons recently in a background L scan
+                if (DetectionTracker.getInstance().getLastDetectionTime() > mBackgroundLScanStartTime) {
+                    if (mBackgroundLScanFirstDetectionTime == 0l) {
+                        mBackgroundLScanFirstDetectionTime = DetectionTracker.getInstance().getLastDetectionTime();
+                    }
+                    if (SystemClock.elapsedRealtime() - mBackgroundLScanFirstDetectionTime
+                            >= BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
+                        // if we are in here, it has been more than 10 seconds since we detected
+                        // a beacon in background L scanning mode.  We need to stop scanning
+                        // so we do not drain battery
+                        LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
+                        stopScan();
+                        mBackgroundLScanStartTime = 0l;
+                    }
+                    else {
+                        // report the results up the chain
+                        LogManager.d(TAG, "Delivering Android L background scanning results");
+                        mCycledLeScanCallback.onCycleEnd();
                     }
                 }
             }
@@ -130,27 +142,23 @@ protected boolean deferScanIfNeeded() {
             // Don't actually wait until the next scan time -- only wait up to 1 second.  This
             // allows us to start scanning sooner if a consumer enters the foreground and expects
             // results more quickly.
-            if (mScanDeferredBefore == false && mBackgroundFlag) {
+            if (scanActiveBefore && mBackgroundFlag) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scanLeDevice(true);
                 }
             }, millisecondsUntilStart > 1000 ? 1000 : millisecondsUntilStart);
-            mScanDeferredBefore = true;
-            return true;
-        }
-        else {
+        } else {
             if (mBackgroundLScanStartTime > 0l) {
                 stopScan();
                 mBackgroundLScanStartTime = 0;
             }
-            mScanDeferredBefore = false;
-            mMainScanCycleActive = true;
         }
-        return false;
+        return deferScan;
     }
 
     @Override
@@ -160,19 +168,27 @@ protected void startScan() {
             return;
         }
         List<ScanFilter> filters = new ArrayList<ScanFilter>();
-        ScanSettings settings;
+        ScanSettings settings = null;
 
-        if (mBackgroundFlag && !mMainScanCycleActive) {
+        if (!mMainScanCycleActive) {
             LogManager.d(TAG, "starting filtered scan in SCAN_MODE_LOW_POWER");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
             filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
-                    mBeaconManager.getBeaconParsers());
+                          mBeaconManager.getBeaconParsers());
         } else {
             LogManager.d(TAG, "starting non-filtered scan in SCAN_MODE_LOW_LATENCY");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)).build();
+            // We create wildcard scan filters that match any advertisement so that we can detect
+            // beacons in foreground mode even if the screen is off.  This is a necessary workaround
+            // for a change in Android 8.1 that blocks scan results when the screen is off unless
+            // there is a scan filter associatd with the scan.  Prior to 8.1, filters could just be
+            // left null.  The wildcard filter matches everything.
+            filters = new ScanFilterUtils().createWildcardScanFilters();
         }
 
-        postStartLeScan(filters, settings);
+        if (settings != null) {
+            postStartLeScan(filters, settings);
+        }
     }
 
     @Override
@@ -190,6 +206,7 @@ private void postStartLeScan(final List<ScanFilter> filters, final ScanSettings
         final ScanCallback scanCallback = getNewLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -198,7 +215,7 @@ public void run() {
                     LogManager.w(TAG, "Cannot start scan. Bluetooth may be turned off.");
                 } catch (NullPointerException npe) {
                     // Necessary because of https://code.google.com/p/android/issues/detail?id=160503
-                    LogManager.e(TAG, "Cannot start scan. Unexpected NPE.", npe);
+                    LogManager.e(npe, TAG, "Cannot start scan. Unexpected NPE.");
                 } catch (SecurityException e) {
                     // Thrown by Samsung Knox devices if bluetooth access denied for an app
                     LogManager.e(TAG, "Cannot start scan.  Security Exception");
@@ -220,15 +237,17 @@ private void postStopLeScan() {
         final ScanCallback scanCallback = getNewLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
+                    LogManager.d(TAG, "Stopping LE scan on scan handler");
                     scanner.stopScan(scanCallback);
                 } catch (IllegalStateException e) {
                     LogManager.w(TAG, "Cannot stop scan. Bluetooth may be turned off.");
                 } catch (NullPointerException npe) {
                     // Necessary because of https://code.google.com/p/android/issues/detail?id=160503
-                    LogManager.e(TAG, "Cannot stop scan. Unexpected NPE.", npe);
+                    LogManager.e(npe, TAG, "Cannot stop scan. Unexpected NPE.");
                 } catch (SecurityException e) {
                     // Thrown by Samsung Knox devices if bluetooth access denied for an app
                     LogManager.e(TAG, "Cannot stop scan.  Security Exception");
@@ -274,7 +293,7 @@ private BluetoothLeScanner getScanner() {
     private ScanCallback getNewLeScanCallback() {
         if (leScanCallback == null) {
             leScanCallback = new ScanCallback() {
-
+                @MainThread
                 @Override
                 public void onScanResult(int callbackType, ScanResult scanResult) {
                     if (LogManager.isVerboseLoggingEnabled()) {
@@ -293,6 +312,7 @@ public void onScanResult(int callbackType, ScanResult scanResult) {
                     }
                 }
 
+                @MainThread
                 @Override
                 public void onBatchScanResults(List<ScanResult> results) {
                     LogManager.d(TAG, "got batch records");
@@ -305,9 +325,44 @@ public void onBatchScanResults(List<ScanResult> results) {
                     }
                 }
 
+                @MainThread
                 @Override
-                public void onScanFailed(int i) {
-                    LogManager.e(TAG, "Scan Failed");
+                public void onScanFailed(int errorCode) {
+                    Intent intent = new Intent("onScanFailed");
+                    intent.putExtra("errorCode", errorCode);
+                    LocalBroadcastManager.getInstance(CycledLeScannerForLollipop.this.mContext).sendBroadcast(intent);
+                    switch (errorCode) {
+                        case SCAN_FAILED_ALREADY_STARTED:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed: a BLE scan with the same settings is already started by the app"
+                            );
+                            break;
+                        case SCAN_FAILED_APPLICATION_REGISTRATION_FAILED:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed: app cannot be registered"
+                            );
+                            break;
+                        case SCAN_FAILED_FEATURE_UNSUPPORTED:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed: power optimized scan feature is not supported"
+                            );
+                            break;
+                        case SCAN_FAILED_INTERNAL_ERROR:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed: internal error"
+                            );
+                            break;
+                        default:
+                            LogManager.e(
+                                    TAG,
+                                    "Scan failed with unknown error (errorCode=" + errorCode + ")"
+                            );
+                            break;
+                    }
                 }
             };
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
index 42978d30..daff6763 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/DistinctPacketDetector.java
@@ -1,6 +1,6 @@
 package org.altbeacon.beacon.service.scanner;
 
-import android.util.Log;
+import android.support.annotation.NonNull;
 
 import java.nio.ByteBuffer;
 import java.util.HashSet;
@@ -8,30 +8,33 @@
 
 /**
  * Created by dyoung on 4/8/17.
- *
+ * <p>
  * This class tracks whether multiple distinct BLE packets have been seen, with the purpose of
  * determining if the Android device supports detecting multiple distinct packets in a single scan.
  * Some older devices are not capable of this (e.g. Nexus 4, Moto G1), so detecting multiple packets
  * requires stopping and restarting scanning on these devices.  This allows detecting if that is
- * neessary
+ * necessary.
+ * <p>
+ * <strong>This class is not thread safe.</strong>
  */
 public class DistinctPacketDetector {
     // Sanity limit for the number of packets to track, so we don't use too much memory
     private static final int MAX_PACKETS_TO_TRACK = 1000;
-    protected Set<ByteBuffer> mDistinctPacketsDetected = new HashSet<ByteBuffer>();
+
+    @NonNull
+    private final Set<ByteBuffer> mDistinctPacketsDetected = new HashSet<>();
 
     public void clearDetections() {
         mDistinctPacketsDetected.clear();
     }
 
-    public boolean isPacketDistinct(String originMacAddress, byte[] scanRecord) {
+    public boolean isPacketDistinct(@NonNull String originMacAddress, @NonNull byte[] scanRecord) {
         byte[] macBytes = originMacAddress.getBytes();
         ByteBuffer buffer = ByteBuffer.allocate(macBytes.length+scanRecord.length);
         buffer.put(macBytes);
         buffer.put(scanRecord);
         buffer.rewind(); // rewind puts position back to beginning so .equals and .hashCode work
 
-        boolean distinct = !mDistinctPacketsDetected.contains(buffer);
         if (mDistinctPacketsDetected.size() == MAX_PACKETS_TO_TRACK) {
             return mDistinctPacketsDetected.contains(buffer);
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java b/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
index f85139cb..15aeda1e 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
@@ -1,6 +1,7 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.bluetooth.BluetoothDevice;
+import android.support.annotation.WorkerThread;
 
 /**
  * Allows an implementation to see non-Beacon BLE devices as they are scanned.
@@ -23,6 +24,7 @@
  *  }
  * </code></pre>
  */
+@WorkerThread
 public interface NonBeaconLeScanCallback {
     /**
      * NOTE: This method is NOT called on the main UI thread.
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java b/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
index dc4ee965..dab1925f 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/ScanFilterUtils.java
@@ -26,6 +26,13 @@
         public byte[] mask;
     }
 
+    public List<ScanFilter> createWildcardScanFilters() {
+        List<ScanFilter> scanFilters = new ArrayList<ScanFilter>();
+        ScanFilter.Builder builder = new ScanFilter.Builder();
+        scanFilters.add(builder.build());
+        return scanFilters;
+    }
+
     public List<ScanFilterData> createScanFilterDataForBeaconParser(BeaconParser beaconParser) {
         ArrayList<ScanFilterData> scanFilters = new ArrayList<ScanFilterData>();
         for (int manufacturer : beaconParser.getHardwareAssistManufacturers()) {
diff --git a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
index 8964e607..0a041fe0 100644
--- a/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
+++ b/src/main/java/org/altbeacon/beacon/startup/StartupBroadcastReceiver.java
@@ -1,11 +1,22 @@
 package org.altbeacon.beacon.startup;
 
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanResult;
+import android.bluetooth.le.ScanSettings;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.service.ScanJob;
+import org.altbeacon.beacon.service.ScanJobScheduler;
+
+import java.util.ArrayList;
 
 public class StartupBroadcastReceiver extends BroadcastReceiver
 {
@@ -19,8 +30,19 @@ public void onReceive(Context context, Intent intent) {
             return;
         }
         BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context.getApplicationContext());
-        if (beaconManager.isAnyConsumerBound()) {
-            if (intent.getBooleanExtra("wakeup", false)) {
+        if (beaconManager.isAnyConsumerBound() || beaconManager.getScheduledScanJobsEnabled()) {
+            int bleCallbackType = intent.getIntExtra(BluetoothLeScanner.EXTRA_CALLBACK_TYPE, -1); // e.g. ScanSettings.CALLBACK_TYPE_FIRST_MATCH
+            if (bleCallbackType != -1) {
+                LogManager.d(TAG, "Passive background scan callback type: "+bleCallbackType);
+                LogManager.d(TAG, "got Android O background scan via intent");
+                int errorCode = intent.getIntExtra(BluetoothLeScanner.EXTRA_ERROR_CODE, -1); // e.g.  ScanCallback.SCAN_FAILED_INTERNAL_ERROR
+                if (errorCode != -1) {
+                    LogManager.w(TAG, "Passive background scan failed.  Code; "+errorCode);
+                }
+                ArrayList<ScanResult> scanResults = intent.getParcelableArrayListExtra(BluetoothLeScanner.EXTRA_LIST_SCAN_RESULT);
+                ScanJobScheduler.getInstance().scheduleAfterBackgroundWakeup(context, scanResults);
+            }
+            else if (intent.getBooleanExtra("wakeup", false)) {
                 LogManager.d(TAG, "got wake up intent");
             }
             else {
@@ -28,5 +50,8 @@ public void onReceive(Context context, Intent intent) {
                         intent.getStringExtra("wakeup"));
             }
         }
+        else {
+            LogManager.d(TAG, "No consumers are bound.  Ignoring broadcast receiver.");
+        }
      }
 }
diff --git a/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
new file mode 100644
index 00000000..7cf0959c
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
@@ -0,0 +1,47 @@
+package org.altbeacon.beacon.utils;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+import java.util.List;
+
+/**
+ * Created by dyoung on 3/10/17.
+ *
+ * Internal class used to determine current process state in multi-process setups
+ * @hide
+ */
+
+public class ProcessUtils {
+    Context mContext;
+
+    public ProcessUtils(@NonNull Context context) {
+        mContext = context;
+    }
+
+    public String getProcessName() {
+        ActivityManager manager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningAppProcessInfo> processes = manager.getRunningAppProcesses();
+        if (processes != null) {
+            for (ActivityManager.RunningAppProcessInfo processInfo : processes) {
+                if (processInfo.pid == getPid()) {
+                    return  processInfo.processName;
+                }
+            }
+        }
+        return null;
+    }
+
+    public String getPackageName() {
+        return mContext.getApplicationContext().getPackageName();
+    }
+
+    public int getPid() {
+        return android.os.Process.myPid();
+    }
+
+    public boolean isMainProcess() {
+        return (getPackageName().equals(getProcessName()));
+    }
+}
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java b/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
new file mode 100644
index 00000000..96425e52
--- /dev/null
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothMedic.java
@@ -0,0 +1,457 @@
+package org.altbeacon.bluetooth;
+
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.TaskStackBuilder;
+import android.app.job.JobScheduler;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.AdvertiseCallback;
+import android.bluetooth.le.AdvertiseData;
+import android.bluetooth.le.AdvertiseSettings;
+import android.bluetooth.le.BluetoothLeAdvertiser;
+import android.bluetooth.le.BluetoothLeScanner;
+import android.bluetooth.le.ScanCallback;
+import android.bluetooth.le.ScanResult;
+import android.bluetooth.le.AdvertiseSettings.Builder;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Handler;
+import android.os.PersistableBundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import android.support.v4.app.NotificationCompat;
+import android.support.v4.content.LocalBroadcastManager;
+import java.util.List;
+
+import org.altbeacon.beacon.logging.LogManager;
+
+/**
+ *
+ * Utility class for checking the health of the bluetooth stack on the device by running two kinds
+ * of tests: scanning and transmitting.  The class looks for specific failure codes from these
+ * tests to determine if the bluetooth stack is in a bad state and if so, optionally cycle power to
+ * bluetooth to try and fix the problem.  This is known to work well on some Android devices.
+ *
+ * The tests may be called directly, or set up to run automatically approximately every 15 minutes.
+ * To set up in an automated way:
+ *
+ * <code>
+ *   BluetoothMedic medic = BluetoothMedic.getInstance();
+ *   medic.enablePowerCycleOnFailures(context);
+ *   medic.enablePeriodicTests(context, BluetoothMedic.SCAN_TEST | BluetoothMedic.TRANSMIT_TEST);
+ * </code>
+ *
+ * To set up in a manual way:
+ *
+ * <code>
+ *   BluetoothMedic medic = BluetoothMedic.getInstance();
+ *   medic.enablePowerCycleOnFailures(context);
+ *   if (!medic.runScanTest(context)) {
+ *     // Bluetooth stack is in a bad state
+ *   }
+ *   if (!medic.runTransmitterTest(context)) {
+ *     // Bluetooth stack is in a bad state
+ *   }
+ *
+ */
+
+@SuppressWarnings("javadoc")
+public class BluetoothMedic {
+
+    /**
+     * Indicates that no test should be run by the BluetoothTestJob
+     */
+    @SuppressWarnings("WeakerAccess")
+    public static final int NO_TEST = 0;
+    /**
+     * Indicates that the transmitter test should be run by the BluetoothTestJob
+     */
+    @SuppressWarnings("WeakerAccess")
+    public static final int TRANSMIT_TEST = 2;
+    /**
+     * Indicates that the bluetooth scan test should be run by the BluetoothTestJob
+     */
+    @SuppressWarnings("WeakerAccess")
+    public static final int SCAN_TEST = 1;
+    private static final String TAG = BluetoothMedic.class.getSimpleName();
+    @Nullable
+    private BluetoothAdapter mAdapter;
+    @Nullable
+    private LocalBroadcastManager mLocalBroadcastManager;
+    @NonNull
+    private Handler mHandler = new Handler();
+    private int mTestType = 0;
+    @Nullable
+    private Boolean mTransmitterTestResult = null;
+    @Nullable
+    private Boolean mScanTestResult = null;
+    private boolean mNotificationsEnabled = false;
+    private int mNotificationIcon = 0;
+    private long mLastBluetoothPowerCycleTime = 0L;
+    private static final long MIN_MILLIS_BETWEEN_BLUETOOTH_POWER_CYCLES = 60000L;
+    @Nullable
+    private static BluetoothMedic sInstance;
+    @RequiresApi(21)
+    private BroadcastReceiver mBluetoothEventReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            LogManager.d(BluetoothMedic.TAG, "Broadcast notification received.");
+            int errorCode;
+            String action = intent.getAction();
+            if (action != null) {
+                if(action.equalsIgnoreCase("onScanFailed")) {
+                    errorCode = intent.getIntExtra("errorCode", -1);
+                    if(errorCode == 2) {
+                        BluetoothMedic.this.sendNotification(context, "scan failed",
+                                "Power cycling bluetooth");
+                        LogManager.d(BluetoothMedic.TAG,
+                                "Detected a SCAN_FAILED_APPLICATION_REGISTRATION_FAILED.  We need to cycle bluetooth to recover");
+                        if(!BluetoothMedic.this.cycleBluetoothIfNotTooSoon()) {
+                            BluetoothMedic.this.sendNotification(context, "scan failed", "" +
+                                    "Cannot power cycle bluetooth again");
+                        }
+                    }
+                } else if(action.equalsIgnoreCase("onStartFailed")) {
+                    errorCode = intent.getIntExtra("errorCode", -1);
+                    if(errorCode == 4) {
+                        BluetoothMedic.this.sendNotification(context, "advertising failed",
+                                "Expected failure.  Power cycling.");
+                        if(!BluetoothMedic.this.cycleBluetoothIfNotTooSoon()) {
+                            BluetoothMedic.this.sendNotification(context, "advertising failed",
+                                    "Cannot power cycle bluetooth again");
+                        }
+                    }
+                } else {
+                    LogManager.d(BluetoothMedic.TAG, "Unknown event.");
+                }
+            }
+        }
+    };
+
+
+    /**
+     * Get a singleton instance of the BluetoothMedic
+     * @return
+     */
+    public static BluetoothMedic getInstance() {
+        if(sInstance == null) {
+            sInstance = new BluetoothMedic();
+        }
+        return sInstance;
+    }
+
+    private BluetoothMedic() {
+    }
+
+    @RequiresApi(21)
+    private void initializeWithContext(Context context) {
+        if (this.mAdapter == null || this.mLocalBroadcastManager == null) {
+            BluetoothManager manager = (BluetoothManager)context.getSystemService(Context.BLUETOOTH_SERVICE);
+            if(manager == null) {
+                throw new NullPointerException("Cannot get BluetoothManager");
+            } else {
+                this.mAdapter = manager.getAdapter();
+                this.mLocalBroadcastManager = LocalBroadcastManager.getInstance(context);
+            }
+        }
+    }
+
+    /**
+     * If set to true, bluetooth will be power cycled on any tests run that determine bluetooth is
+     * in a bad state.
+     *
+     * @param context
+     */
+    @SuppressWarnings("unused")
+    @RequiresApi(21)
+    public void enablePowerCycleOnFailures(Context context) {
+        initializeWithContext(context);
+        if (this.mLocalBroadcastManager != null) {
+            this.mLocalBroadcastManager.registerReceiver(this.mBluetoothEventReceiver,
+                    new IntentFilter("onScanFailed"));
+            this.mLocalBroadcastManager.registerReceiver(this.mBluetoothEventReceiver,
+                    new IntentFilter("onStartFailure"));
+            LogManager.d(TAG,
+                    "Medic monitoring for transmission and scan failure notifications with receiver: "
+                            + this.mBluetoothEventReceiver);
+        }
+    }
+
+    /**
+     * Calling this method starts a scheduled job that will run tests of the specified type to
+     * make sure bluetooth is OK and cycle power to bluetooth if needed and configured by
+     * enablePowerCycleOnFailures
+     *
+     * @param context
+     * @param testType e.g. BluetoothMedic.TRANSMIT_TEST | BluetoothMedic.SCAN_TEST
+     */
+    @SuppressWarnings("unused")
+    @RequiresApi(21)
+    public void enablePeriodicTests(Context context, int testType) {
+        initializeWithContext(context);
+        this.mTestType = testType;
+        LogManager.d(TAG, "Medic scheduling periodic tests of types " + testType);
+        this.scheduleRegularTests(context);
+    }
+
+    /**
+     * Starts up a brief blueooth scan with the intent of seeing if it results in an error condition
+     * indicating the bluetooth stack may be in a bad state.
+     *
+     * If the failure error code matches a pattern known to be associated with a bad bluetooth stack
+     * state, then the bluetooth stack is turned off and then back on after a short delay in order
+     * to try to recover.
+     *
+     * @return false if the test indicates a failure indicating a bad state of the bluetooth stack
+     */
+    @SuppressWarnings({"unused","WeakerAccess"})
+    @RequiresApi(21)
+    public boolean runScanTest(final Context context) {
+        initializeWithContext(context);
+        this.mScanTestResult = null;
+        LogManager.i(TAG, "Starting scan test");
+        final long testStartTime = System.currentTimeMillis();
+        if (this.mAdapter != null) {
+            final BluetoothLeScanner scanner = this.mAdapter.getBluetoothLeScanner();
+            final ScanCallback callback = new ScanCallback() {
+                public void onScanResult(int callbackType, ScanResult result) {
+                    super.onScanResult(callbackType, result);
+                    BluetoothMedic.this.mScanTestResult = true;
+                    LogManager.i(BluetoothMedic.TAG, "Scan test succeeded");
+                    try {
+                        scanner.stopScan(this);
+                    }
+                    catch (IllegalStateException e) { /* do nothing */ } // caught if bluetooth is off here
+                }
+
+                public void onBatchScanResults(List<ScanResult> results) {
+                    super.onBatchScanResults(results);
+                }
+
+                public void onScanFailed(int errorCode) {
+                    super.onScanFailed(errorCode);
+                    LogManager.d(BluetoothMedic.TAG, "Sending onScanFailed broadcast with " +
+                            BluetoothMedic.this.mLocalBroadcastManager);
+                    Intent intent = new Intent("onScanFailed");
+                    intent.putExtra("errorCode", errorCode);
+                    if (BluetoothMedic.this.mLocalBroadcastManager != null) {
+                        BluetoothMedic.this.mLocalBroadcastManager.sendBroadcast(intent);
+                    }
+                    LogManager.d(BluetoothMedic.TAG, "broadcast: " + intent +
+                            " should be received by " + BluetoothMedic.this.mBluetoothEventReceiver);
+                    if(errorCode == 2) {
+                        LogManager.w(BluetoothMedic.TAG,
+                                "Scan test failed in a way we consider a failure");
+                        BluetoothMedic.this.sendNotification(context,
+                                "scan failed", "bluetooth not ok");
+                        BluetoothMedic.this.mScanTestResult = false;
+                    } else {
+                        LogManager.i(BluetoothMedic.TAG,
+                                "Scan test failed in a way we do not consider a failure");
+                        BluetoothMedic.this.mScanTestResult = true;
+                    }
+
+                }
+            };
+            if(scanner != null) {
+                scanner.startScan(callback);
+                while (this.mScanTestResult == null) {
+                    LogManager.d(TAG, "Waiting for scan test to complete...");
+
+                    try {
+                        Thread.sleep(1000L);
+                    } catch (InterruptedException e) { /* do nothing */ }
+
+                    if (System.currentTimeMillis() - testStartTime > 5000L) {
+                        LogManager.d(TAG, "Timeout running scan test");
+                        break;
+                    }
+                }
+                try {
+                    scanner.stopScan(callback);
+                } catch (IllegalStateException e) { /* do nothing */ } // caught if bluetooth is off here
+            }
+            else {
+                LogManager.d(TAG, "Cannot get scanner");
+            }
+        }
+
+
+
+        LogManager.d(TAG, "scan test complete");
+        return this.mScanTestResult == null || this.mScanTestResult;
+    }
+
+    /**
+     * Starts up a beacon transmitter with the intent of seeing if it results in an error condition
+     * indicating the bluetooth stack may be in a bad state.
+     *
+     * If the failure error code matches a pattern known to be associated with a bad bluetooth stack
+     * state, then the bluetooth stack is turned off and then back on after a short delay in order
+     * to try to recover.
+     *
+     * @return false if the test indicates a failure indicating a bad state of the bluetooth stack
+     */
+    @SuppressWarnings({"unused","WeakerAccess"})
+    @RequiresApi(21)
+    public boolean runTransmitterTest(final Context context) {
+        initializeWithContext(context);
+        this.mTransmitterTestResult = null;
+        long testStartTime = System.currentTimeMillis();
+        if (this.mAdapter != null) {
+            final BluetoothLeAdvertiser advertiser = this.mAdapter.getBluetoothLeAdvertiser();
+            if(advertiser != null) {
+                AdvertiseSettings settings = (new Builder()).setAdvertiseMode(0).build();
+                AdvertiseData data = (new android.bluetooth.le.AdvertiseData.Builder())
+                        .addManufacturerData(0, new byte[]{0}).build();
+                LogManager.i(TAG, "Starting transmitter test");
+                advertiser.startAdvertising(settings, data, new AdvertiseCallback() {
+                    public void onStartSuccess(AdvertiseSettings settingsInEffect) {
+                        super.onStartSuccess(settingsInEffect);
+                        LogManager.i(BluetoothMedic.TAG, "Transmitter test succeeded");
+                        advertiser.stopAdvertising(this);
+                        BluetoothMedic.this.mTransmitterTestResult = true;
+                    }
+
+                    public void onStartFailure(int errorCode) {
+                        super.onStartFailure(errorCode);
+                        Intent intent = new Intent("onStartFailed");
+                        intent.putExtra("errorCode", errorCode);
+                        LogManager.d(BluetoothMedic.TAG, "Sending onStartFailure broadcast with "
+                                + BluetoothMedic.this.mLocalBroadcastManager);
+                        if (BluetoothMedic.this.mLocalBroadcastManager != null) {
+                            BluetoothMedic.this.mLocalBroadcastManager.sendBroadcast(intent);
+                        }
+                        if(errorCode == 4) {
+                            BluetoothMedic.this.mTransmitterTestResult = false;
+                            LogManager.w(BluetoothMedic.TAG,
+                                    "Transmitter test failed in a way we consider a test failure");
+                            BluetoothMedic.this.sendNotification(context, "transmitter failed",
+                                    "bluetooth not ok");
+                        } else {
+                            BluetoothMedic.this.mTransmitterTestResult = true;
+                            LogManager.i(BluetoothMedic.TAG,
+                                    "Transmitter test failed, but not in a way we consider a test failure");
+                        }
+
+                    }
+                });
+            } else {
+                LogManager.d(TAG, "Cannot get advertiser");
+            }
+            while(this.mTransmitterTestResult == null) {
+                LogManager.d(TAG, "Waiting for transmitter test to complete...");
+
+                try {
+                    Thread.sleep(1000L);
+                } catch (InterruptedException e) { /* do nothing */ }
+
+                if(System.currentTimeMillis() - testStartTime > 5000L) {
+                    LogManager.d(TAG, "Timeout running transmitter test");
+                    break;
+                }
+            }
+        }
+
+        LogManager.d(TAG, "transmitter test complete");
+        return this.mTransmitterTestResult != null && this.mTransmitterTestResult;
+    }
+
+    /**
+     *
+     * Configure whether to send user-visible notification warnings when bluetooth power is cycled.
+     *
+     * @param enabled if true, a user-visible notification is sent to tell the user when
+     * @param icon the icon drawable to use in notifications (e.g. R.drawable.notification_icon)
+     */
+    @SuppressWarnings("unused")
+    @RequiresApi(21)
+    public void setNotificationsEnabled(boolean enabled, int icon) {
+        this.mNotificationsEnabled = enabled;
+        this.mNotificationIcon = icon;
+    }
+
+    @RequiresApi(21)
+    private boolean cycleBluetoothIfNotTooSoon() {
+        long millisSinceLastCycle = System.currentTimeMillis() - this.mLastBluetoothPowerCycleTime;
+        if(millisSinceLastCycle < MIN_MILLIS_BETWEEN_BLUETOOTH_POWER_CYCLES) {
+            LogManager.d(TAG, "Not cycling bluetooth because we just did so " +
+                    millisSinceLastCycle + " milliseconds ago.");
+            return false;
+        } else {
+            this.mLastBluetoothPowerCycleTime = System.currentTimeMillis();
+            LogManager.d(TAG, "Power cycling bluetooth");
+            this.cycleBluetooth();
+            return true;
+        }
+    }
+
+    @RequiresApi(21)
+    private void cycleBluetooth() {
+        LogManager.d(TAG, "Power cycling bluetooth");
+        LogManager.d(TAG, "Turning Bluetooth off.");
+        if (mAdapter != null) {
+            this.mAdapter.disable();
+            this.mHandler.postDelayed(new Runnable() {
+                public void run() {
+                    LogManager.d(BluetoothMedic.TAG, "Turning Bluetooth back on.");
+                    if (BluetoothMedic.this.mAdapter != null) {
+                        BluetoothMedic.this.mAdapter.enable();
+                    }
+                }
+            }, 1000L);
+        }
+        else {
+            LogManager.w(TAG, "Cannot cycle bluetooth.  Manager is null.");
+        }
+    }
+
+    @RequiresApi(21)
+    private void sendNotification(Context context, String message, String detail) {
+        initializeWithContext(context);
+        if(this.mNotificationsEnabled) {
+            NotificationCompat.Builder builder =
+                    (new NotificationCompat.Builder(context, "err"))
+                            .setContentTitle("BluetoothMedic: " + message)
+                            .setSmallIcon(mNotificationIcon)
+                            .setVibrate(new long[]{200L, 100L, 200L}).setContentText(detail);
+            TaskStackBuilder stackBuilder = TaskStackBuilder.create(context);
+            stackBuilder.addNextIntent(new Intent("NoOperation"));
+
+            PendingIntent resultPendingIntent = stackBuilder.getPendingIntent(
+                    0,
+                    PendingIntent.FLAG_UPDATE_CURRENT
+            );
+            builder.setContentIntent(resultPendingIntent);
+            NotificationManager notificationManager =
+                    (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
+            if (notificationManager != null) {
+                notificationManager.notify(1, builder.build());
+            }
+        }
+    }
+
+    @RequiresApi(21)
+    private void scheduleRegularTests(Context context) {
+        initializeWithContext(context);
+        ComponentName serviceComponent = new ComponentName(context, BluetoothTestJob.class);
+        android.app.job.JobInfo.Builder builder =
+                new android.app.job.JobInfo.Builder(BluetoothTestJob.getJobId(context), serviceComponent);
+        builder.setRequiresCharging(false);
+        builder.setRequiresDeviceIdle(false);
+        builder.setPeriodic(900000L); // 900 secs is 15 minutes -- the minimum time on Android
+        builder.setPersisted(true);
+        PersistableBundle bundle = new PersistableBundle();
+        bundle.putInt("test_type", this.mTestType);
+        builder.setExtras(bundle);
+        JobScheduler jobScheduler = (JobScheduler)
+                context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
+        if (jobScheduler != null) {
+            jobScheduler.schedule(builder.build());
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java b/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java
new file mode 100644
index 00000000..8d70bd98
--- /dev/null
+++ b/src/main/java/org/altbeacon/bluetooth/BluetoothTestJob.java
@@ -0,0 +1,138 @@
+package org.altbeacon.bluetooth;
+
+import android.app.job.JobParameters;
+import android.app.job.JobService;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.support.annotation.Nullable;
+import android.support.annotation.RequiresApi;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.BeaconService;
+
+/**
+ * @hide
+ * Internal library class.  Do not use directly.
+ */
+@SuppressWarnings("javadoc")
+@RequiresApi(21)
+public class BluetoothTestJob extends JobService {
+    private static final String TAG = BluetoothTestJob.class.getSimpleName();
+    @Nullable
+    private Handler mHandler = null;
+    @Nullable
+    private HandlerThread mHandlerThread = null;
+    private static int sOverrideJobId = -1;
+
+    /**
+     * Allows configuration of the job id for the Android Job Scheduler.  If not configured, this
+     * will default to he value in the AndroidManifest.xml
+     *
+     * WARNING:  If using this library in a multi-process application, this method may not work.
+     * This is considered a private API and may be removed at any time.
+     *
+     * the preferred way of setting this is in the AndroidManifest.xml as so:
+     * <code>
+     * <service android:name="org.altbeacon.bluetooth.BluetoothTestJob">
+     *   <meta-data android:name="jobId" android:value="1001" tools:replace="android:value"/>
+     * </service>
+     * </code>
+     *
+     * @param id
+     */
+    public static void setOverrideJobId(int id) {
+        sOverrideJobId = id;
+    }
+
+    /**
+     * Returns the job id to be used to schedule this job.  This may be set in the
+     * AndroidManifest.xml or in single process applications by using #setOverrideJobId
+     * @param context
+     * @return
+     */
+    public static int getJobId(Context context) {
+        if (sOverrideJobId >= 0) {
+            LogManager.i(TAG, "Using BluetoothTestJob JobId from static override: "+
+                    sOverrideJobId);
+            return sOverrideJobId;
+        }
+        PackageItemInfo info = null;
+        try {
+            info = context.getPackageManager().getServiceInfo(new ComponentName(context,
+                    BluetoothTestJob.class), PackageManager.GET_META_DATA);
+        } catch (PackageManager.NameNotFoundException e) { /* do nothing here */ }
+        if (info != null && info.metaData != null && info.metaData.get("jobId") != null) {
+            int jobId = info.metaData.getInt("jobId");
+            LogManager.i(TAG, "Using BluetoothTestJob JobId from manifest: "+jobId);
+            return jobId;
+        }
+        else {
+            throw new RuntimeException("Cannot get job id from manifest.  " +
+                    "Make sure that the BluetoothTestJob is configured in the manifest.");
+        }
+    }
+
+    public BluetoothTestJob() {
+    }
+
+    public boolean onStartJob(final JobParameters params) {
+        if(this.mHandlerThread == null) {
+            this.mHandlerThread = new HandlerThread("BluetoothTestThread");
+            this.mHandlerThread.start();
+        }
+
+        if(this.mHandler == null) {
+            this.mHandler = new Handler(this.mHandlerThread.getLooper());
+        }
+
+        this.mHandler.post(new Runnable() {
+            public void run() {
+                boolean found = false;
+                LogManager.i(BluetoothTestJob.TAG, "Bluetooth Test Job running");
+                int testType = params.getExtras().getInt("test_type");
+                if(testType == BluetoothMedic.NO_TEST) {
+                    found = true;
+                    LogManager.d(BluetoothTestJob.TAG, "No test specified.  Done with job.");
+                }
+
+                if((testType & BluetoothMedic.SCAN_TEST) == BluetoothMedic.SCAN_TEST) {
+                    LogManager.d(BluetoothTestJob.TAG, "Scan test specified.");
+                    found = true;
+                    if (!BluetoothMedic.getInstance().runScanTest(BluetoothTestJob.this)) {
+                        LogManager.d(TAG, "scan test failed");
+                    }
+                }
+
+                if((testType & BluetoothMedic.TRANSMIT_TEST) == BluetoothMedic.TRANSMIT_TEST) {
+                    if(found) {
+                        try {
+                            Thread.sleep(10000L);
+                        } catch (InterruptedException e) {
+                            /* do nothing */
+                        }
+                    }
+
+                    LogManager.d(BluetoothTestJob.TAG, "Transmit test specified.");
+                    found = true;
+                    if (!BluetoothMedic.getInstance().runTransmitterTest(BluetoothTestJob.this)) {
+                        LogManager.d(TAG, "transmit test failed");
+                    }
+                }
+
+                if(!found) {
+                    LogManager.w(BluetoothTestJob.TAG, "Unknown test type:" + testType + "  Exiting.");
+                }
+
+                BluetoothTestJob.this.jobFinished(params, false);
+            }
+        });
+        return true;
+    }
+
+    public boolean onStopJob(JobParameters params) {
+        return true;
+    }
+}
diff --git a/src/test/java/org/altbeacon/beacon/AltBeaconTest.java b/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
index 2519ad13..2d726781 100644
--- a/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/AltBeaconTest.java
@@ -2,15 +2,20 @@
 
 import android.os.Parcel;
 
-import static org.junit.Assert.assertEquals;
-
-import org.altbeacon.beacon.logging.Loggers;
-import org.robolectric.RobolectricTestRunner;
-
-import org.junit.runner.RunWith;
+import org.junit.After;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 
+import java.util.Arrays;
+
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.hasProperty;
+import static org.junit.Assert.assertEquals;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -26,36 +31,128 @@
 4. Expand the System.err section
  */
 public class AltBeaconTest {
+    private Parcel aParcel = null;
 
-  public static byte[] hexStringToByteArray(String s) {
-      int len = s.length();
-      byte[] data = new byte[len / 2];
-      for (int i = 0; i < len; i += 2) {
-          data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
-                               + Character.digit(s.charAt(i+1), 16));
-      }
-      return data;
-  }
-
-  @Test
-  public void testRecognizeBeacon() {
-    byte[] bytes = hexStringToByteArray("02011a1bff1801beac2f234454cf6d4a0fadf2f4911ba9ffa600010002c509");
-    AltBeaconParser parser = new AltBeaconParser();
-    Beacon beacon = parser.fromScanData(bytes, -55, null);
-    assertEquals("manData should be parsed", 9, ((AltBeacon) beacon).getMfgReserved() );
-  }
+    @After
+    public void after() {
+        // Clean up any obtained parcel
+        if (null != aParcel) {
+            aParcel.recycle();
+        }
+    }
+
+    public static byte[] hexStringToByteArray(String s) {
+        int len = s.length();
+        byte[] data = new byte[len / 2];
+        for (int i = 0; i < len; i += 2) {
+            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
+                    + Character.digit(s.charAt(i+1), 16));
+        }
+        return data;
+    }
 
+    @Test
+    public void testRecognizeBeacon() {
+        byte[] bytes = hexStringToByteArray("02011a1bff1801beac2f234454cf6d4a0fadf2f4911ba9ffa600010002c509");
+        AltBeaconParser parser = new AltBeaconParser();
+        Beacon beacon = parser.fromScanData(bytes, -55, null);
+        assertEquals("manData should be parsed", 9, ((AltBeacon) beacon).getMfgReserved() );
+    }
 
     @Test
     public void testCanSerializeParcelable() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
-        Beacon beacon = new AltBeacon.Builder().setMfgReserved(7).setId1("1").setId2("2").setId3("3").setRssi(4)
-                .setBeaconTypeCode(5).setTxPower(6)
-                .setBluetoothAddress("1:2:3:4:5:6").build();
-        beacon.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Beacon beacon2 = new AltBeacon(parcel);
-        assertEquals("beaconMfgReserved is same after deserialization", ((AltBeacon)beacon).getMfgReserved(), ((AltBeacon)beacon2).getMfgReserved());
+        final Beacon original = new AltBeacon.Builder().setMfgReserved(2)
+                                                       .setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                                                       .setBluetoothName("Any Bluetooth")
+                                                       .setBeaconTypeCode(1)
+                                                       .setExtraDataFields(Arrays.asList(4L, 5L))
+                                                       .setId1("6")
+                                                       .setId2("7")
+                                                       .setId3("8")
+                                                       .setManufacturer(10)
+                                                       .setMultiFrameBeacon(true)
+                                                       .setParserIdentifier("Any Parser ID")
+                                                       .setRssi(-11)
+                                                       .setRunningAverageRssi(-12.3)
+                                                       .setServiceUuid(13)
+                                                       .setTxPower(14)
+                                                       .build();
+        original.setPacketCount(15);
+        original.setRssiMeasurementCount(16);
+
+        aParcel = Parcel.obtain();
+        original.writeToParcel(aParcel, 0);
+        aParcel.setDataPosition(0);
+        final AltBeacon parceled = AltBeacon.CREATOR.createFromParcel(aParcel);
+        assertThat(
+                parceled,
+                allOf(
+                        hasProperty("bluetoothAddress", equalTo("aa:bb:cc:dd:ee:ff")),
+                        hasProperty("bluetoothName", equalTo("Any Bluetooth")),
+                        hasProperty("beaconTypeCode", equalTo(1)),
+                        hasProperty("dataFields", equalTo(Arrays.asList(2L))),
+                        hasProperty("extraDataFields", equalTo(Arrays.asList(4L, 5L))),
+                        hasProperty("id1", equalTo(Identifier.fromInt(6))),
+                        hasProperty("id2", equalTo(Identifier.fromInt(7))),
+                        hasProperty("id3", equalTo(Identifier.fromInt(8))),
+                        hasProperty("manufacturer", equalTo(10)),
+                        hasProperty("multiFrameBeacon", equalTo(true)),
+                        hasProperty("parserIdentifier", equalTo("Any Parser ID")),
+                        hasProperty("rssi", equalTo(-11)),
+                        hasProperty("runningAverageRssi", equalTo(-12.3)),
+                        hasProperty("serviceUuid", equalTo(13)),
+                        hasProperty("txPower", equalTo(14)),
+                        hasProperty("mfgReserved", equalTo(2)),
+                        hasProperty("packetCount", equalTo(15)),
+                        hasProperty("measurementCount", equalTo(16))
+                )
+        );
+    }
+
+
+    @Test
+    public void copyingBeaconTransfersAllFields() {
+        final Beacon original = new AltBeacon.Builder().setMfgReserved(2)
+                                                       .setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                                                       .setBluetoothName("Any Bluetooth")
+                                                       .setBeaconTypeCode(1)
+                                                       .setExtraDataFields(Arrays.asList(4L, 5L))
+                                                       .setId1("6")
+                                                       .setId2("7")
+                                                       .setId3("8")
+                                                       .setManufacturer(10)
+                                                       .setMultiFrameBeacon(true)
+                                                       .setParserIdentifier("Any Parser ID")
+                                                       .setRssi(-11)
+                                                       .setRunningAverageRssi(-12.3)
+                                                       .setServiceUuid(13)
+                                                       .setTxPower(14)
+                                                       .build();
+        original.setPacketCount(15);
+        original.setRssiMeasurementCount(16);
+        final AltBeacon copied = new AltBeacon(original);
+        assertThat(
+                copied,
+                allOf(
+                        hasProperty("bluetoothAddress", equalTo("aa:bb:cc:dd:ee:ff")),
+                        hasProperty("bluetoothName", equalTo("Any Bluetooth")),
+                        hasProperty("beaconTypeCode", equalTo(1)),
+                        hasProperty("dataFields", equalTo(Arrays.asList(2L))),
+                        hasProperty("extraDataFields", equalTo(Arrays.asList(4L, 5L))),
+                        hasProperty("id1", equalTo(Identifier.fromInt(6))),
+                        hasProperty("id2", equalTo(Identifier.fromInt(7))),
+                        hasProperty("id3", equalTo(Identifier.fromInt(8))),
+                        hasProperty("manufacturer", equalTo(10)),
+                        hasProperty("multiFrameBeacon", equalTo(true)),
+                        hasProperty("parserIdentifier", equalTo("Any Parser ID")),
+                        hasProperty("rssi", equalTo(-11)),
+                        hasProperty("runningAverageRssi", equalTo(-12.3)),
+                        hasProperty("serviceUuid", equalTo(13)),
+                        hasProperty("txPower", equalTo(14)),
+                        hasProperty("packetCount", equalTo(15)),
+                        hasProperty("measurementCount", equalTo(16))
+                )
+        );
     }
 }
diff --git a/src/test/java/org/altbeacon/beacon/BeaconTest.java b/src/test/java/org/altbeacon/beacon/BeaconTest.java
index e31e6f54..63d37ea8 100644
--- a/src/test/java/org/altbeacon/beacon/BeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/BeaconTest.java
@@ -3,11 +3,16 @@
 import android.os.Parcel;
 
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
+import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
 
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.hasProperty;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -16,6 +21,12 @@
 import java.util.Arrays;
 import java.util.List;
 
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -31,11 +42,21 @@
 4. Expand the System.err section
  */
 public class BeaconTest {
+    private Parcel aParcel = null;
 
     @Before
     public void before() {
         Beacon.setHardwareEqualityEnforced(false);
     }
+
+    @After
+    public void after() {
+        // Clean up any obtained parcel
+        if (null != aParcel) {
+            aParcel.recycle();
+        }
+    }
+
     @Test
     public void testAccessBeaconIdentifiers() {
         Beacon beacon = new AltBeacon.Builder().setMfgReserved(7).setId1("1").setId2("2").setId3("3").setRssi(4)
@@ -160,15 +181,13 @@ public void testCalculateAccuracyWithRssiEqualsPowerOnInternalPropertiesAndRunni
 
 
     @Test
-    public void testCanSerializeParcelable() {
+    public void testCanSerialize() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
                 .setBeaconTypeCode(5).setTxPower(6).setBluetoothName("xx")
                 .setBluetoothAddress("1:2:3:4:5:6").setDataFields(Arrays.asList(100l)).build();
-        beacon.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Beacon beacon2 = new Beacon(parcel);
+        byte[] serializedBeacon = convertToBytes(beacon);
+        Beacon beacon2 = (Beacon) convertFromBytes(serializedBeacon);
         assertEquals("Right number of identifiers after deserialization", 3, beacon2.mIdentifiers.size());
         assertEquals("id1 is same after deserialization", beacon.getIdentifier(0), beacon2.getIdentifier(0));
         assertEquals("id2 is same after deserialization", beacon.getIdentifier(1), beacon2.getIdentifier(1));
@@ -204,4 +223,116 @@ public void testHashCodeWithNullIdentifier() {
                 .build();
         assertTrue("hashCode() should not throw exception", beacon.hashCode() >= Integer.MIN_VALUE);
     }
+
+    @Test
+    public void parcelingBeaconContainsAllFields() {
+        final Beacon original = new Beacon.Builder().setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                                                    .setBluetoothName("Any Bluetooth")
+                                                    .setBeaconTypeCode(1)
+                                                    .setDataFields(Arrays.asList(2L, 3L))
+                                                    .setExtraDataFields(Arrays.asList(4L, 5L))
+                                                    .setId1("6")
+                                                    .setId2("7")
+                                                    .setId3("8")
+                                                    .setManufacturer(10)
+                                                    .setMultiFrameBeacon(true)
+                                                    .setParserIdentifier("Any Parser ID")
+                                                    .setRssi(-11)
+                                                    .setRunningAverageRssi(-12.3)
+                                                    .setServiceUuid(13)
+                                                    .setTxPower(14)
+                                                    .build();
+        original.setPacketCount(15);
+        original.setRssiMeasurementCount(16);
+
+        aParcel = Parcel.obtain();
+        original.writeToParcel(aParcel, 0);
+        aParcel.setDataPosition(0);
+        final Beacon parceled = Beacon.CREATOR.createFromParcel(aParcel);
+        assertThat(
+                parceled,
+                allOf(
+                        hasProperty("bluetoothAddress", equalTo("aa:bb:cc:dd:ee:ff")),
+                        hasProperty("bluetoothName", equalTo("Any Bluetooth")),
+                        hasProperty("beaconTypeCode", equalTo(1)),
+                        hasProperty("dataFields", equalTo(Arrays.asList(2L, 3L))),
+                        hasProperty("extraDataFields", equalTo(Arrays.asList(4L, 5L))),
+                        hasProperty("id1", equalTo(Identifier.fromInt(6))),
+                        hasProperty("id2", equalTo(Identifier.fromInt(7))),
+                        hasProperty("id3", equalTo(Identifier.fromInt(8))),
+                        hasProperty("manufacturer", equalTo(10)),
+                        hasProperty("multiFrameBeacon", equalTo(true)),
+                        hasProperty("parserIdentifier", equalTo("Any Parser ID")),
+                        hasProperty("rssi", equalTo(-11)),
+                        hasProperty("runningAverageRssi", equalTo(-12.3)),
+                        hasProperty("serviceUuid", equalTo(13)),
+                        hasProperty("txPower", equalTo(14)),
+                        hasProperty("packetCount", equalTo(15)),
+                        hasProperty("measurementCount", equalTo(16))
+                )
+        );
+    }
+
+    @Test
+    public void copyingBeaconContainsAllFields() {
+        final Beacon original = new Beacon.Builder().setBluetoothAddress("aa:bb:cc:dd:ee:ff")
+                                                    .setBluetoothName("Any Bluetooth")
+                                                    .setBeaconTypeCode(1)
+                                                    .setDataFields(Arrays.asList(2L, 3L))
+                                                    .setExtraDataFields(Arrays.asList(4L, 5L))
+                                                    .setId1("6")
+                                                    .setId2("7")
+                                                    .setId3("8")
+                                                    .setManufacturer(10)
+                                                    .setMultiFrameBeacon(true)
+                                                    .setParserIdentifier("Any Parser ID")
+                                                    .setRssi(-11)
+                                                    .setRunningAverageRssi(-12.3)
+                                                    .setServiceUuid(13)
+                                                    .setTxPower(14)
+                                                    .build();
+        original.setPacketCount(15);
+        original.setRssiMeasurementCount(16);
+
+        final Beacon copied = new Beacon(original);
+        assertThat(
+                copied,
+                allOf(
+                        hasProperty("bluetoothAddress", equalTo("aa:bb:cc:dd:ee:ff")),
+                        hasProperty("bluetoothName", equalTo("Any Bluetooth")),
+                        hasProperty("beaconTypeCode", equalTo(1)),
+                        hasProperty("dataFields", equalTo(Arrays.asList(2L, 3L))),
+                        hasProperty("extraDataFields", equalTo(Arrays.asList(4L, 5L))),
+                        hasProperty("id1", equalTo(Identifier.fromInt(6))),
+                        hasProperty("id2", equalTo(Identifier.fromInt(7))),
+                        hasProperty("id3", equalTo(Identifier.fromInt(8))),
+                        hasProperty("manufacturer", equalTo(10)),
+                        hasProperty("multiFrameBeacon", equalTo(true)),
+                        hasProperty("parserIdentifier", equalTo("Any Parser ID")),
+                        hasProperty("rssi", equalTo(-11)),
+                        hasProperty("runningAverageRssi", equalTo(-12.3)),
+                        hasProperty("serviceUuid", equalTo(13)),
+                        hasProperty("txPower", equalTo(14)),
+                        hasProperty("packetCount", equalTo(15)),
+                        hasProperty("measurementCount", equalTo(16))
+                )
+        );
+    }
+
+    // utilty methods for testing serialization
+
+    private byte[] convertToBytes(Object object) throws IOException {
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(object);
+            return bos.toByteArray();
+        }
+    }
+    private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+             ObjectInputStream in = new ObjectInputStream(bis)) {
+            return in.readObject();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/org/altbeacon/beacon/RegionTest.java b/src/test/java/org/altbeacon/beacon/RegionTest.java
index b57d3503..05ba5952 100644
--- a/src/test/java/org/altbeacon/beacon/RegionTest.java
+++ b/src/test/java/org/altbeacon/beacon/RegionTest.java
@@ -1,7 +1,5 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
 import static android.test.MoreAsserts.assertNotEqual;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -17,6 +15,12 @@
 import java.util.ArrayList;
 import java.util.Collections;
 
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -128,14 +132,11 @@ public void testBeaconMatchesRegionWithSameBluetoothMacAndIdentifiers() {
 
 
     @Test
-    public void testCanSerializeParcelable() {
+    public void testCanSerialize() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Region region = new Region("myRegion", Identifier.parse("1"), Identifier.parse("2"), null);
-        region.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Region region2 = new Region(parcel);
-        parcel.recycle();
+        byte[] serializedRegion = convertToBytes(region);
+        Region region2 = (Region) convertFromBytes(serializedRegion);
         assertEquals("Right number of identifiers after deserialization", 3, region2.mIdentifiers.size());
         assertEquals("uniqueId is same after deserialization", region.getUniqueId(), region2.getUniqueId());
         assertEquals("id1 is same after deserialization", region.getIdentifier(0), region2.getIdentifier(0));
@@ -145,14 +146,11 @@ public void testCanSerializeParcelable() {
     }
 
     @Test
-    public void testCanSerializeParcelableWithMac() {
+    public void testCanSerializeWithMac() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Region region = new Region("myRegion", "1B:2a:03:4C:6E:9F");
-        region.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Region region2 = new Region(parcel);
-        parcel.recycle();
+        byte[] serializedRegion = convertToBytes(region);
+        Region region2 = (Region) convertFromBytes(serializedRegion);
         assertEquals("Right number of identifiers after deserialization", 0, region2.mIdentifiers.size());
         assertEquals("ac is same after deserialization", region.getBluetoothAddress(), region2.getBluetoothAddress());
     }
@@ -186,5 +184,21 @@ public void testConvenienceIdentifierAccessors() {
         assertEquals("3", region.getId3().toString());
     }
 
+    // utilty methods for testing serialization
+
+    private byte[] convertToBytes(Object object) throws IOException {
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(object);
+            return bos.toByteArray();
+        }
+    }
+    private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+             ObjectInputStream in = new ObjectInputStream(bis)) {
+            return in.readObject();
+        }
+    }
+
 
 }
diff --git a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
index 37be84e9..d77e7eab 100644
--- a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
@@ -48,7 +48,7 @@ public void beaconScanCallbackTest() throws Exception {
         beaconServiceServiceController.attach();
         BeaconService beaconService = beaconServiceServiceController.get();
         beaconService.onCreate();
-        CycledLeScanCallback callback = beaconService.mCycledLeScanCallback;
+        CycledLeScanCallback callback = beaconService.getCycledLeScanCallback();
 
         ThreadPoolExecutor executor = (ThreadPoolExecutor) AsyncTask.THREAD_POOL_EXECUTOR;
         int activeThreadCountBeforeScan = executor.getActiveCount();
diff --git a/src/test/java/org/altbeacon/beacon/service/ExtraDataBeaconTrackerTest.java b/src/test/java/org/altbeacon/beacon/service/ExtraDataBeaconTrackerTest.java
index cc7dcd99..24927ac5 100644
--- a/src/test/java/org/altbeacon/beacon/service/ExtraDataBeaconTrackerTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/ExtraDataBeaconTrackerTest.java
@@ -10,11 +10,9 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import dalvik.annotation.TestTargetClass;
-
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNull;
 
 @RunWith(RobolectricTestRunner.class)
 @Config(sdk = 18)
@@ -59,6 +57,7 @@ Beacon getGattBeaconExtraData() {
         return new Beacon.Builder()
                 .setBluetoothAddress("01:02:03:04:05:06")
                 .setServiceUuid(1234)
+                .setRssi(-25)
                 .setDataFields(getDataFields())
                 .build();
     }
@@ -67,6 +66,7 @@ Beacon getGattBeaconExtraData2() {
         return new Beacon.Builder()
                 .setBluetoothAddress("01:02:03:04:05:06")
                 .setServiceUuid(1234)
+                .setRssi(-50)
                 .setDataFields(getDataFields2())
                 .build();
     }
@@ -119,32 +119,44 @@ public void gattBeaconExtraDataGetUpdated() {
         ExtraDataBeaconTracker tracker = new ExtraDataBeaconTracker();
         tracker.track(beacon);
         tracker.track(extraDataBeacon);
-        tracker.track(extraDataBeacon2);
         Beacon trackedBeacon = tracker.track(beacon);
+        assertEquals("rssi should be updated", extraDataBeacon.getRssi(), trackedBeacon.getRssi());
+        assertEquals("extra data is updated", extraDataBeacon.getDataFields(), trackedBeacon.getExtraDataFields());
+
+        tracker.track(extraDataBeacon2);
+        trackedBeacon = tracker.track(beacon);
+        assertEquals("rssi should be updated", extraDataBeacon2.getRssi(), trackedBeacon.getRssi());
         assertEquals("extra data is updated", extraDataBeacon2.getDataFields(), trackedBeacon.getExtraDataFields());
     }
 
     @Test
-    public void gattBeaconExtraDataAreNotOverwritten() {
+    public void gattBeaconFieldsAreNotUpdated() {
         Beacon beacon = getGattBeacon();
-        Beacon extraDataBeacon = getGattBeaconExtraData();
+        final int originalRssi = beacon.getRssi();
+        final List<Long> originalData = beacon.getDataFields();
+        final List<Long> originalExtra = beacon.getExtraDataFields();
+        Beacon beaconUpdate = getGattBeaconUpdate();
         ExtraDataBeaconTracker tracker = new ExtraDataBeaconTracker();
         tracker.track(beacon);
-        tracker.track(extraDataBeacon);
+        tracker.track(beaconUpdate);
         Beacon trackedBeacon = tracker.track(beacon);
-        assertEquals("extra data should not be overwritten", extraDataBeacon.getDataFields(), trackedBeacon.getExtraDataFields());
+        assertEquals("rssi should NOT be updated", originalRssi, trackedBeacon.getRssi());
+        assertEquals("data should NOT be updated", originalData, trackedBeacon.getDataFields());
+        assertEquals("extra data should NOT be updated", originalExtra, trackedBeacon.getExtraDataFields());
     }
 
     @Test
     public void gattBeaconFieldsGetUpdated() {
         Beacon beacon = getGattBeacon();
-        Beacon beaconUpdate = getGattBeaconUpdate();
         Beacon extraDataBeacon = getGattBeaconExtraData();
+        Beacon repeatBeacon = getGattBeacon();
+        repeatBeacon.setRssi(-100);
         ExtraDataBeaconTracker tracker = new ExtraDataBeaconTracker();
         tracker.track(beacon);
-        Beacon trackedBeacon = tracker.track(beaconUpdate);
-        assertEquals("rssi should be updated", beaconUpdate.getRssi(), trackedBeacon.getRssi());
-        assertEquals("data fields should be updated", beaconUpdate.getDataFields(), trackedBeacon.getDataFields());
+        tracker.track(extraDataBeacon);
+        Beacon trackedBeacon = tracker.track(repeatBeacon);
+        assertEquals("rssi should NOT be updated", -100, trackedBeacon.getRssi());
+        assertEquals("extra data fields should be updated", extraDataBeacon.getDataFields(), trackedBeacon.getExtraDataFields());
     }
 
     @Test
diff --git a/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java b/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
index ec8fef85..0ec70470 100644
--- a/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/MonitoringStatusTest.java
@@ -4,6 +4,7 @@
 import android.content.Context;
 import android.os.AsyncTask;
 import android.os.Build;
+import android.util.Log;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Region;
@@ -30,6 +31,7 @@
 @RunWith(RobolectricTestRunner.class)
 @Config(sdk = 18)
 public class MonitoringStatusTest {
+    private static final String TAG = MonitoringStatusTest.class.getSimpleName();
     @Before
     public void before() {
         org.robolectric.shadows.ShadowLog.stream = System.err;
diff --git a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
index 3042a904..90f92dbf 100644
--- a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
@@ -1,9 +1,6 @@
 package org.altbeacon.beacon.service;
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.os.AsyncTask;
-import android.os.Build;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Identifier;
@@ -11,23 +8,16 @@
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
-import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowApplication;
-import org.robolectric.util.ServiceController;
 
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.concurrent.ThreadPoolExecutor;
 
-import android.os.Parcel;
 import android.os.Bundle;
-import org.altbeacon.beacon.service.RangingData;
 
 import static org.junit.Assert.assertEquals;
 
@@ -51,18 +41,29 @@ public void testSerialization() throws Exception {
         identifiers.add(Identifier.parse("2"));
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
-        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers)
+                                            .setRssi(-1)
+                                            .setRunningAverageRssi(-2)
+                                            .setTxPower(-50)
+                                            .setBluetoothAddress("01:02:03:04:05:06")
+                                            .build();
+        beacon.setRssiMeasurementCount(1);
+        beacon.setPacketCount(2);
         for (int i=0; i < 10; i++) {
             beacons.add(beacon);
         }
         RangingData data = new RangingData(beacons, region);
-        Parcel parcel = Parcel.obtain();
-        data.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        RangingData data2 = new RangingData(parcel);
+        Bundle bundle = data.toBundle();
+        RangingData data2 = RangingData.fromBundle(bundle);
         assertEquals("beacon count shouild be restored", 10, data2.getBeacons().size());
-        assertEquals("beacon identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getBeacons().iterator().next().getId1().toString());
         assertEquals("region identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getRegion().getId1().toString());
+        Beacon restoredBeacon = data2.getBeacons().iterator().next();
+        assertEquals("beacon identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", restoredBeacon.getId1().toString());
+        assertEquals("RSSI is restored", -1, restoredBeacon.getRssi());
+        assertEquals("Average RSSI is restored", -2.0, restoredBeacon.getRunningAverageRssi(), 0.0);
+        assertEquals("TXPower is restored", -50, restoredBeacon.getTxPower());
+        assertEquals("Measurement count is restored", 1, restoredBeacon.getMeasurementCount());
+        assertEquals("Packet count is restored", 2, restoredBeacon.getPacketCount());
     }
 
     @Test
@@ -75,20 +76,18 @@ public void testSerializationBenchmark() throws Exception {
         identifiers.add(Identifier.parse("2"));
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
-        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
         for (int i=0; i < 10; i++) {
             beacons.add(beacon);
         }
         RangingData data = new RangingData(beacons, region);
         long time1 = System.currentTimeMillis();
         for (int i=0; i< 10000; i++) {
-            Parcel parcel = Parcel.obtain();
-            data.writeToParcel(parcel, 0);
-            parcel.setDataPosition(0);
-            RangingData data2 = new RangingData(parcel);
+            Bundle bundle = data.toBundle();
+            RangingData data2 = RangingData.fromBundle(bundle);
         }
         long time2 = System.currentTimeMillis();
         System.out.println("*** Ranging Data Serialization benchmark: "+(time2-time1));
     }
 
-}
\ No newline at end of file
+}
diff --git a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
index 562de095..8eb7cc08 100644
--- a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
@@ -1,5 +1,6 @@
 package org.altbeacon.beacon.service;
 
+import org.altbeacon.beacon.Beacon;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -17,4 +18,39 @@ public void initTest1() {
         filter.addMeasurement(-50);
         assertEquals("First measurement should be -50", String.valueOf(filter.calculateRssi()), "-50.0");
     }
+    @Test
+    public void rangedBeaconDoesNotOverrideSampleExpirationMillisecondsText() {
+        RangedBeacon.setSampleExpirationMilliseconds(20000);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(20000);
+        Beacon beacon = new Beacon.Builder().setId1("1").build();
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(33l);
+        RangedBeacon rb = new RangedBeacon(beacon);
+        assertEquals("RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by constructing RangedBeacon", 33l, RunningAverageRssiFilter.getSampleExpirationMilliseconds());
+    }
+
+    @Test
+    public void regressionCheckRangedBeaconCommitDoesNotOverrideSampleExpirationMilliseconds() {
+        RangedBeacon.setSampleExpirationMilliseconds(20000);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(20000);
+        Beacon beacon = new Beacon.Builder().setId1("1").build();
+        RangedBeacon rb = new RangedBeacon(beacon);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(33l);
+        rb.commitMeasurements();
+        assertEquals(
+                "RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by committing RangedBeacon",
+                33l,
+                RunningAverageRssiFilter.getSampleExpirationMilliseconds()
+        );
+    }
+
+    @Test
+    public void legacySetSampleExpirationMillisecondsWorksText() {
+        RangedBeacon.setSampleExpirationMilliseconds(20000);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(20000);
+        Beacon beacon = new Beacon.Builder().setId1("1").build();
+        RangedBeacon.setSampleExpirationMilliseconds(33l);
+        RangedBeacon rb = new RangedBeacon(beacon);
+        assertEquals("RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by constructing RangedBeacon", 33l, RunningAverageRssiFilter.getSampleExpirationMilliseconds());
+    }
+
 }
diff --git a/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java b/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
new file mode 100644
index 00000000..ba4b95c0
--- /dev/null
+++ b/src/test/java/org/altbeacon/beacon/service/ScanStateTest.java
@@ -0,0 +1,57 @@
+package org.altbeacon.beacon.service;
+
+/**
+ * Created by dyoung on 7/30/17.
+ */
+
+import android.annotation.TargetApi;
+import android.content.Context;
+import android.os.AsyncTask;
+import android.os.Build;
+
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.logging.Loggers;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+import org.robolectric.util.ServiceController;
+
+import java.util.concurrent.ThreadPoolExecutor;
+
+import static org.junit.Assert.assertEquals;
+
+/**
+ * Created by dyoung on 7/1/15.
+ */
+@RunWith(RobolectricTestRunner.class)
+@Config(sdk = 18)
+public class ScanStateTest {
+
+    @Before
+    public void before() {
+        org.robolectric.shadows.ShadowLog.stream = System.err;
+        LogManager.setLogger(Loggers.verboseLogger());
+        LogManager.setVerboseLoggingEnabled(true);
+        BeaconManager.setsManifestCheckingDisabled(true);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    @Test
+    public void serializationTest() throws Exception {
+        Context context = ShadowApplication.getInstance().getApplicationContext();
+        ScanState scanState = new ScanState(context);
+        MonitoringStatus monitoringStatus = new MonitoringStatus(context);
+        scanState.setMonitoringStatus(monitoringStatus);
+        scanState.setLastScanStartTimeMillis(1234);
+        scanState.save();
+        ScanState scanState2 = ScanState.restore(context);
+        assertEquals("Scan start time should be restored",
+                scanState.getLastScanStartTimeMillis(), scanState2.getLastScanStartTimeMillis());
+    }
+}
\ No newline at end of file
