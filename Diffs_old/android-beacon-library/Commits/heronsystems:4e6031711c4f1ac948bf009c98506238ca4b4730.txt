diff --git a/CHANGELOG.md b/CHANGELOG.md
index bb174008..f70765f1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,11 +3,19 @@
 
 Enhancements:
 
+- Add ability to circumvent prohibition against scans running for > 30 minutes on Android N.
+  (#529, David G. Young)
 - Add support for running the beacon scanning service in a separate process and working with
   application setups that have more than one process. (#479, David G. Young)
 
 Bug Fixes:
 
+- Fix Google Play submission errors by no longer using uses-permission-sdk-23 in
+  Manifest (#527, David G. Young)
+- Fix inability to use `RunningAverageRssiFilter.setSampleExpirationMilliseconds(...)` (#523,
+  David G. Young)
+- Fix failure to restart scanning in some cases after bluetooth has been off but then is turned
+  back on. (#519, David G. Young)
 - Fix failure to stop scanning when unbinding from service or when the between scan period
   is nonzero. (#507, David G. Young)
 - Fix possible `NullPointerException` with `BackgroundPowerSaver` on devices
diff --git a/build.gradle b/build.gradle
index eb1fae59..64bc60ab 100644
--- a/build.gradle
+++ b/build.gradle
@@ -31,7 +31,7 @@ buildscript {
     }
 
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.0-alpha2'
+        classpath 'com.android.tools.build:gradle:2.3.0'
         classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
         classpath 'org.jfrog.buildinfo:build-info-extractor-gradle:3.0.3'
     }
@@ -102,7 +102,7 @@ dependencies {
     // For Android O Docs say to use com.android.support:appcompat-v7:26.0.0-beta1, but that is not available
     //compile 'com.android.support:appcompat-v7:26.0.0-alpha1'
     compile 'com.android.support:support-v4:24.1.0'
-    compile 'com.android.support:support-annotations:24.2.1'
+    compile 'com.android.support:support-annotations:25.3.1'
 
     testCompile('junit:junit:4.12') {
         exclude group: 'org.hamcrest'
@@ -117,12 +117,6 @@ dependencies {
     testCompile('org.mockito:mockito-core:1.10.19') {
         exclude group: 'org.hamcrest'
     }
-    androidTestCompile('junit:junit:4.12') {
-        exclude group: 'org.hamcrest'
-    }
-    androidTestCompile('org.hamcrest:hamcrest-junit:2.0.0.0') {
-        exclude group: 'junit'
-    }
     androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
         exclude group: 'com.android.support', module: 'support-annotations'
         exclude group: 'org.hamcrest'
diff --git a/src/main/AndroidManifest.xml b/src/main/AndroidManifest.xml
index a27fcf75..cc3f5ef6 100644
--- a/src/main/AndroidManifest.xml
+++ b/src/main/AndroidManifest.xml
@@ -5,7 +5,7 @@
     <uses-permission android:name="android.permission.BLUETOOTH" android:required="false"/>
     <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:required="false"/>
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
-    <uses-permission-sdk-23 android:name="android.permission.ACCESS_COARSE_LOCATION"/>
+    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
 
     <application>
         <receiver android:name="org.altbeacon.beacon.startup.StartupBroadcastReceiver">
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 3a50855a..37ae6ff2 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -24,22 +24,24 @@
 package org.altbeacon.beacon.service;
 
 
-import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
 import android.app.Service;
-import android.bluetooth.BluetoothDevice;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.content.pm.ApplicationInfo;
-import android.os.AsyncTask;
+import android.content.pm.PackageItemInfo;
+import android.content.pm.PackageManager;
 import android.os.Binder;
 import android.os.Build;
 import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
 import android.os.Message;
 import android.os.Messenger;
-import android.support.annotation.NonNull;
+import android.support.annotation.MainThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
@@ -50,25 +52,15 @@
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
-import org.altbeacon.beacon.service.scanner.CycledLeScanner;
-import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
-import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.beacon.utils.ProcessUtils;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
 
 import static android.app.PendingIntent.FLAG_ONE_SHOT;
 import static android.app.PendingIntent.getBroadcast;
@@ -79,22 +71,9 @@
 
 public class BeaconService extends Service {
     public static final String TAG = "BeaconService";
-
-    private final Map<Region, RangeState> rangedRegionState = new HashMap<Region, RangeState>();
-    private MonitoringStatus monitoringStatus;
-
-    int trackedBeaconsPacketCount;
     private final Handler handler = new Handler();
     private BluetoothCrashResolver bluetoothCrashResolver;
-    private DistanceCalculator defaultDistanceCalculator = null;
-    private BeaconManager beaconManager;
-    private Set<BeaconParser> beaconParsers  = new HashSet<BeaconParser>();
-    private CycledLeScanner mCycledScanner;
-    private boolean mBackgroundFlag = false;
-    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
-    private ExecutorService mExecutor;
-    private final DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
-
+    private ScanHelper mScanHelper;
     /*
      * The scan period is how long we wait between restarting the BLE advertisement scans
      * Each time we restart we only see the unique advertisements once (e.g. unique beacons)
@@ -117,8 +96,6 @@
      *
      */
 
-    private List<Beacon> simulatedScanData = null;
-
     /**
      * Class used for the client Binder.  Because we know this service always
      * runs in the same process as its clients, we don't need to deal with IPC.
@@ -145,9 +122,16 @@ public BeaconService getService() {
         private final WeakReference<BeaconService> mService;
 
         IncomingHandler(BeaconService service) {
+            /*
+             * Explicitly state this uses the main thread. Without this we defer to where the
+             * service instance is initialized/created; which is usually the main thread anyways.
+             * But by being explicit we document our code design expectations for where things run.
+             */
+            super(Looper.getMainLooper());
             mService = new WeakReference<BeaconService>(service);
         }
 
+        @MainThread
         @Override
         public void handleMessage(Message msg) {
             BeaconService service = mService.get();
@@ -206,20 +190,22 @@ else if (msg.what == MSG_SYNC_SETTINGS) {
      */
     final Messenger mMessenger = new Messenger(new IncomingHandler(this));
 
-
+    @MainThread
     @Override
     public void onCreate() {
         bluetoothCrashResolver = new BluetoothCrashResolver(this);
         bluetoothCrashResolver.start();
 
-        // Create a private executor so we don't compete with threads used by AsyncTask
-        // This uses fewer threads than the default executor so it won't hog CPU
-        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
-
-        mCycledScanner = CycledLeScanner.createScanner(this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
-                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag, mCycledLeScanCallback, bluetoothCrashResolver);
+        mScanHelper = new ScanHelper(this);
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(false, bluetoothCrashResolver);
+        }
+        mScanHelper.setMonitoringStatus(MonitoringStatus.getInstanceForApplication(this));
+        mScanHelper.setRangedRegionState(new HashMap<Region, RangeState>());
+        mScanHelper.setBeaconParsers(new HashSet<BeaconParser>());
+        mScanHelper.setExtraDataBeaconTracker(new ExtraDataBeaconTracker());
 
-        beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
         beaconManager.setScannerInSameProcess(true);
         if (beaconManager.isMainProcess()) {
             LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
@@ -230,17 +216,25 @@ public void onCreate() {
             LogManager.i(TAG, "beaconService PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
         }
 
-        reloadParsers();
+        try {
+            PackageItemInfo info = this.getPackageManager().getServiceInfo(new ComponentName(this, BeaconService.class), PackageManager.GET_META_DATA);
+            if (info != null && info.metaData != null && info.metaData.get("longScanForcingEnabled") != null &&
+                    info.metaData.get("longScanForcingEnabled").toString().equals("true")) {
+                LogManager.i(TAG, "longScanForcingEnabled to keep scans going on Android N for > 30 minutes");
+                mScanHelper.getCycledScanner().setLongScanForcingEnabled(true);
+            }
+        } catch (PackageManager.NameNotFoundException e) {}
+
+        mScanHelper.reloadParsers();
 
-        defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
+        DistanceCalculator defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
 
-        monitoringStatus = MonitoringStatus.getInstanceForApplication(getApplicationContext());
         // Look for simulated scan data
         try {
             Class klass = Class.forName("org.altbeacon.beacon.SimulatedScanData");
             java.lang.reflect.Field f = klass.getField("beacons");
-            this.simulatedScanData = (List<Beacon>) f.get(null);
+            mScanHelper.setSimulatedScanData((List<Beacon>) f.get(null));
         } catch (ClassNotFoundException e) {
             LogManager.d(TAG, "No org.altbeacon.beacon.SimulatedScanData class exists.");
         } catch (Exception e) {
@@ -248,25 +242,6 @@ public void onCreate() {
         }
     }
 
-    protected void reloadParsers() {
-        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
-        //flatMap all beacon parsers
-        boolean matchBeaconsByServiceUUID = true;
-        if (beaconManager.getBeaconParsers() != null) {
-            newBeaconParsers.addAll(beaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
-            }
-        }
-        beaconParsers = newBeaconParsers;
-        //initialize the extra data beacon tracker
-        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
-    }
-
-
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         LogManager.i(TAG,
@@ -294,6 +269,7 @@ public boolean onUnbind(Intent intent) {
         return false;
     }
 
+    @MainThread
     @Override
     public void onDestroy() {
         LogManager.e(TAG, "onDestroy()");
@@ -304,9 +280,9 @@ public void onDestroy() {
         bluetoothCrashResolver.stop();
         LogManager.i(TAG, "onDestroy called.  stopping scanning");
         handler.removeCallbacksAndMessages(null);
-        mCycledScanner.stop();
-        mCycledScanner.destroy();
-        monitoringStatus.stopStatusPreservation();
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        mScanHelper.getMonitoringStatus().stopStatusPreservation();
     }
 
     @Override
@@ -330,238 +306,62 @@ private PendingIntent getRestartIntent() {
     /**
      * methods for clients
      */
+    @MainThread
     public void startRangingBeaconsInRegion(Region region, Callback callback) {
-        synchronized (rangedRegionState) {
-            if (rangedRegionState.containsKey(region)) {
+        synchronized (mScanHelper.getRangedRegionState()) {
+            if (mScanHelper.getRangedRegionState().containsKey(region)) {
                 LogManager.i(TAG, "Already ranging that region -- will replace existing region.");
-                rangedRegionState.remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
+                mScanHelper.getRangedRegionState().remove(region); // need to remove it, otherwise the old object will be retained because they are .equal //FIXME That is not true
             }
-            rangedRegionState.put(region, new RangeState(callback));
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+            mScanHelper.getRangedRegionState().put(region, new RangeState(callback));
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
-        mCycledScanner.start();
+        mScanHelper.getCycledScanner().start();
     }
 
+    @MainThread
     public void stopRangingBeaconsInRegion(Region region) {
         int rangedRegionCount;
-        synchronized (rangedRegionState) {
-            rangedRegionState.remove(region);
-            rangedRegionCount = rangedRegionState.size();
-            LogManager.d(TAG, "Currently ranging %s regions.", rangedRegionState.size());
+        synchronized (mScanHelper.getRangedRegionState()) {
+            mScanHelper.getRangedRegionState().remove(region);
+            rangedRegionCount = mScanHelper.getRangedRegionState().size();
+            LogManager.d(TAG, "Currently ranging %s regions.", mScanHelper.getRangedRegionState().size());
         }
 
-        if (rangedRegionCount == 0 && monitoringStatus.regionsCount() == 0) {
-            mCycledScanner.stop();
+        if (rangedRegionCount == 0 && mScanHelper.getMonitoringStatus().regionsCount() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
+    @MainThread
     public void startMonitoringBeaconsInRegion(Region region, Callback callback) {
         LogManager.d(TAG, "startMonitoring called");
-        monitoringStatus.addRegion(region, callback);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        mCycledScanner.start();
+        mScanHelper.getMonitoringStatus().addRegion(region, callback);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        mScanHelper.getCycledScanner().start();
     }
 
+    @MainThread
     public void stopMonitoringBeaconsInRegion(Region region) {
         LogManager.d(TAG, "stopMonitoring called");
-        monitoringStatus.removeRegion(region);
-        LogManager.d(TAG, "Currently monitoring %s regions.", monitoringStatus.regionsCount());
-        if (monitoringStatus.regionsCount() == 0 && rangedRegionState.size() == 0) {
-            mCycledScanner.stop();
+        mScanHelper.getMonitoringStatus().removeRegion(region);
+        LogManager.d(TAG, "Currently monitoring %s regions.", mScanHelper.getMonitoringStatus().regionsCount());
+        if (mScanHelper.getMonitoringStatus().regionsCount() == 0 && mScanHelper.getRangedRegionState().size() == 0) {
+            mScanHelper.getCycledScanner().stop();
         }
     }
 
+    @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        mCycledScanner.setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
+        mScanHelper.getCycledScanner().setScanPeriods(scanPeriod, betweenScanPeriod, backgroundFlag);
     }
 
-    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
-        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-        @Override
-        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
-
-            NonBeaconLeScanCallback nonBeaconLeScanCallback = beaconManager.getNonBeaconLeScanCallback();
-
-            try {
-                new ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
-                        new ScanData(device, rssi, scanRecord));
-            } catch (RejectedExecutionException e) {
-                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
-            }
-        }
-
-        @Override
-        public void onCycleEnd() {
-            mDistinctPacketDetector.clearDetections();
-            monitoringStatus.updateNewlyOutside();
-            processRangeData();
-            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
-            if (simulatedScanData != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
-
-                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                    for (Beacon beacon : simulatedScanData) {
-                        processBeaconFromScan(beacon);
-                    }
-                } else {
-                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
-                }
-            }
-            if (BeaconManager.getBeaconSimulator() != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
-                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
-                            processBeaconFromScan(beacon);
-                        }
-                    } else {
-                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
-                    }
-                } else {
-                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
-                }
-            }
-        }
-    };
-
-    private void processRangeData() {
-        synchronized (rangedRegionState) {
-            for (Region region : rangedRegionState.keySet()) {
-                RangeState rangeState = rangedRegionState.get(region);
-                LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
-            }
-        }
+    public void reloadParsers() {
+        mScanHelper.reloadParsers();
     }
 
-    private void processBeaconFromScan(Beacon beacon) {
-        if (Stats.getInstance().isEnabled()) {
-            Stats.getInstance().log(beacon);
-        }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG,
-                    "beacon detected : %s", beacon.toString());
-        }
-
-        beacon = mExtraDataBeaconTracker.track(beacon);
-        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
-        // the above
-        if (beacon == null) {
-            if (LogManager.isVerboseLoggingEnabled()) {
-                LogManager.d(TAG,
-                        "not processing detections for GATT extra data beacon");
-            }
-        } else {
-
-            monitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
-
-            List<Region> matchedRegions = null;
-            Iterator<Region> matchedRegionIterator;
-            LogManager.d(TAG, "looking for ranging region matches for this beacon");
-            synchronized (rangedRegionState) {
-                matchedRegions = matchingRegions(beacon, rangedRegionState.keySet());
-                matchedRegionIterator = matchedRegions.iterator();
-                while (matchedRegionIterator.hasNext()) {
-                    Region region = matchedRegionIterator.next();
-                    LogManager.d(TAG, "matches ranging region: %s", region);
-                    RangeState rangeState = rangedRegionState.get(region);
-                    if (rangeState != null) {
-                        rangeState.addBeacon(beacon);
-                    }
-                }
-            }
-        }
-    }
-
-
-    /**
-     * <strong>This class is not thread safe.</strong>
-     */
-    private static class ScanData {
-        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
-            this.device = device;
-            this.rssi = rssi;
-            this.scanRecord = scanRecord;
-        }
-
-        final int rssi;
-
-        @NonNull
-        final BluetoothDevice device;
-
-        @NonNull
-        final byte[] scanRecord;
-    }
-
-    private class ScanProcessor extends AsyncTask<ScanData, Void, Void> {
-        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
-
-        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-
-        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
-            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
-        }
-
-        @Override
-        protected Void doInBackground(ScanData... params) {
-            ScanData scanData = params[0];
-            Beacon beacon = null;
-
-            for (BeaconParser parser : beaconParsers) {
-                beacon = parser.fromScanData(scanData.scanRecord,
-                        scanData.rssi, scanData.device);
-
-                if (beacon != null) {
-                    break;
-                }
-            }
-            if (beacon != null) {
-                if (LogManager.isVerboseLoggingEnabled()) {
-                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
-                }
-                mDetectionTracker.recordDetection();
-                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
-                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
-                            scanData.scanRecord)) {
-                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unnecessary.");
-                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
-                    }
-                }
-                trackedBeaconsPacketCount++;
-                processBeaconFromScan(beacon);
-            } else {
-                if (mNonBeaconLeScanCallback != null) {
-                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
-                }
-            }
-            return null;
-        }
-
-        @Override
-        protected void onPostExecute(Void result) {
-        }
-
-        @Override
-        protected void onPreExecute() {
-        }
-
-        @Override
-        protected void onProgressUpdate(Void... values) {
-        }
-    }
-
-    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<Region>();
-        for (Region region : regions) {
-            if (region.matchesBeacon(beacon)) {
-                matched.add(region);
-            } else {
-                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
-            }
-        }
-        return matched;
+    @RestrictTo(Scope.TESTS)
+    protected CycledLeScanCallback getCycledLeScanCallback() {
+        return mScanHelper.getCycledLeScanCallback();
     }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
index e19e92cf..905f6b0d 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangedBeacon.java
@@ -69,6 +69,7 @@ public void addMeasurement(Integer rssi) {
     //kept here for backward compatibility
     public static void setSampleExpirationMilliseconds(long milliseconds) {
         sampleExpirationMilliseconds = milliseconds;
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(sampleExpirationMilliseconds);
     }
 
     public static void setMaxTrackinAge(int maxTrackinAge) {
diff --git a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
index c5ba36ca..3f45f7df 100644
--- a/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
+++ b/src/main/java/org/altbeacon/beacon/service/RunningAverageRssiFilter.java
@@ -1,6 +1,8 @@
 package org.altbeacon.beacon.service;
 
 import android.os.SystemClock;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
 
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -81,4 +83,8 @@ public static void setSampleExpirationMilliseconds(long newSampleExpirationMilli
         sampleExpirationMilliseconds = newSampleExpirationMilliseconds;
     }
 
+    @RestrictTo(Scope.TESTS)
+    static long getSampleExpirationMilliseconds() {
+        return sampleExpirationMilliseconds;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanHelper.java b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
new file mode 100644
index 00000000..3ac5fbdc
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/ScanHelper.java
@@ -0,0 +1,342 @@
+package org.altbeacon.beacon.service;
+
+import android.annotation.SuppressLint;
+import android.annotation.TargetApi;
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.os.AsyncTask;
+import android.os.Build;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.WorkerThread;
+import android.support.annotation.RestrictTo;
+import android.support.annotation.RestrictTo.Scope;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
+import org.altbeacon.beacon.service.scanner.CycledLeScanner;
+import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
+import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
+import org.altbeacon.bluetooth.BluetoothCrashResolver;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+
+/**
+ * Created by dyoung on 6/16/17.
+ *
+ * This is an internal utilty class and should not be called directly by library users.
+ *
+ * This encapsulates shared data and methods used by both ScanJob and BeaconService
+ * that deal with the specifics of beacon scanning.
+ *
+ * @hide
+ */
+
+class ScanHelper {
+    private static final String TAG = ScanHelper.class.getSimpleName();
+    private ExecutorService mExecutor;
+    private BeaconManager mBeaconManager;
+    private CycledLeScanner mCycledScanner;
+    private MonitoringStatus mMonitoringStatus;
+    private final Map<Region, RangeState> mRangedRegionState = new HashMap<>();
+    private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
+    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
+    private Set<BeaconParser> mBeaconParsers  = new HashSet<>();
+    private List<Beacon> mSimulatedScanData = null;
+    private Context mContext;
+
+    ScanHelper(Context context) {
+        mContext = context;
+        mBeaconManager = BeaconManager.getInstanceForApplication(context);
+        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
+    }
+
+    CycledLeScanner getCycledScanner() {
+        return mCycledScanner;
+    }
+
+    MonitoringStatus getMonitoringStatus() {
+        return mMonitoringStatus;
+    }
+
+    void setMonitoringStatus(MonitoringStatus monitoringStatus) {
+        mMonitoringStatus = monitoringStatus;
+    }
+
+    Map<Region, RangeState> getRangedRegionState() {
+        return mRangedRegionState;
+    }
+
+    void setRangedRegionState(Map<Region, RangeState> rangedRegionState) {
+        synchronized (mRangedRegionState) {
+            mRangedRegionState.clear();
+            mRangedRegionState.putAll(rangedRegionState);
+        }
+    }
+
+    void setExtraDataBeaconTracker(ExtraDataBeaconTracker extraDataBeaconTracker) {
+        mExtraDataBeaconTracker = extraDataBeaconTracker;
+    }
+
+    void setBeaconParsers(Set<BeaconParser> beaconParsers) {
+        mBeaconParsers = beaconParsers;
+    }
+
+    void setSimulatedScanData(List<Beacon> simulatedScanData) {
+        mSimulatedScanData = simulatedScanData;
+    }
+
+
+    void createCycledLeScanner(boolean backgroundMode, BluetoothCrashResolver crashResolver) {
+        mCycledScanner = CycledLeScanner.createScanner(mContext, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
+                BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, backgroundMode,
+                mCycledLeScanCallback, crashResolver);
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    void processScanResult(BluetoothDevice device, int rssi, byte[] scanRecord) {
+        NonBeaconLeScanCallback nonBeaconLeScanCallback = mBeaconManager.getNonBeaconLeScanCallback();
+
+        try {
+            new ScanHelper.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
+                    new ScanHelper.ScanData(device, rssi, scanRecord));
+        } catch (RejectedExecutionException e) {
+
+            LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
+        }
+    }
+
+    void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<>();
+        //flatMap all beacon parsers
+        boolean matchBeaconsByServiceUUID = true;
+        newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
+        for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
+            if (beaconParser.getExtraDataParsers().size() > 0) {
+                matchBeaconsByServiceUUID = false;
+                newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
+            }
+        }
+        mBeaconParsers = newBeaconParsers;
+        //initialize the extra data beacon tracker
+        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+    }
+
+    private final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+        @Override
+        @MainThread
+        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
+            processScanResult(device, rssi, scanRecord);
+        }
+
+        @Override
+        @MainThread
+        @SuppressLint("WrongThread")
+        public void onCycleEnd() {
+            mDistinctPacketDetector.clearDetections();
+            mMonitoringStatus.updateNewlyOutside();
+            processRangeData();
+            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
+            if (mSimulatedScanData != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
+
+                if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                    for (Beacon beacon : mSimulatedScanData) {
+                        // This is an expensive call and we do not want to block the main thread.
+                        // But here we are in debug/test mode so we allow it on the main thread.
+                        //noinspection WrongThread
+                        processBeaconFromScan(beacon);
+                    }
+                } else {
+                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
+                }
+            }
+            if (BeaconManager.getBeaconSimulator() != null) {
+                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
+                // it will not be used if we are not in debug mode
+                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
+                    if (0 != (mContext.getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
+                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
+                            // This is an expensive call and we do not want to block the main thread.
+                            // But here we are in debug/test mode so we allow it on the main thread.
+                            //noinspection WrongThread
+                            processBeaconFromScan(beacon);
+                        }
+                    } else {
+                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
+                    }
+                } else {
+                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
+                }
+            }
+        }
+    };
+
+    @RestrictTo(Scope.TESTS)
+    CycledLeScanCallback getCycledLeScanCallback() {
+        return mCycledLeScanCallback;
+    }
+
+    private void processRangeData() {
+        synchronized (mRangedRegionState) {
+            for (Region region : mRangedRegionState.keySet()) {
+                RangeState rangeState = mRangedRegionState.get(region);
+                LogManager.d(TAG, "Calling ranging callback");
+                rangeState.getCallback().call(mContext, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
+            }
+        }
+    }
+
+    /**
+     * Helper for processing BLE beacons. This has been extracted from {@link ScanHelper.ScanProcessor} to
+     * support simulated scan data for test and debug environments.
+     * <p>
+     * Processing beacons is a frequent and expensive operation. It should not be run on the main
+     * thread to avoid UI contention.
+     */
+    @WorkerThread
+    private void processBeaconFromScan(@NonNull Beacon beacon) {
+        if (Stats.getInstance().isEnabled()) {
+            Stats.getInstance().log(beacon);
+        }
+        if (LogManager.isVerboseLoggingEnabled()) {
+            LogManager.d(TAG,
+                    "beacon detected : %s", beacon.toString());
+        }
+
+        beacon = mExtraDataBeaconTracker.track(beacon);
+        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
+        // the above
+        if (beacon == null) {
+            if (LogManager.isVerboseLoggingEnabled()) {
+                LogManager.d(TAG,
+                        "not processing detections for GATT extra data beacon");
+            }
+        } else {
+
+            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
+
+            List<Region> matchedRegions;
+            Iterator<Region> matchedRegionIterator;
+            LogManager.d(TAG, "looking for ranging region matches for this beacon");
+            synchronized (mRangedRegionState) {
+                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
+                matchedRegionIterator = matchedRegions.iterator();
+                while (matchedRegionIterator.hasNext()) {
+                    Region region = matchedRegionIterator.next();
+                    LogManager.d(TAG, "matches ranging region: %s", region);
+                    RangeState rangeState = mRangedRegionState.get(region);
+                    if (rangeState != null) {
+                        rangeState.addBeacon(beacon);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * <strong>This class is not thread safe.</strong>
+     */
+    private class ScanData {
+        ScanData(@NonNull BluetoothDevice device, int rssi, @NonNull byte[] scanRecord) {
+            this.device = device;
+            this.rssi = rssi;
+            this.scanRecord = scanRecord;
+        }
+
+        final int rssi;
+
+        @NonNull
+        BluetoothDevice device;
+
+        @NonNull
+        byte[] scanRecord;
+    }
+
+    private class ScanProcessor extends AsyncTask<ScanHelper.ScanData, Void, Void> {
+        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
+
+        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+
+        ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
+            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
+        }
+
+        @WorkerThread
+        @Override
+        protected Void doInBackground(ScanHelper.ScanData... params) {
+            ScanHelper.ScanData scanData = params[0];
+            Beacon beacon = null;
+
+            for (BeaconParser parser : ScanHelper.this.mBeaconParsers) {
+                beacon = parser.fromScanData(scanData.scanRecord,
+                        scanData.rssi, scanData.device);
+
+                if (beacon != null) {
+                    break;
+                }
+            }
+            if (beacon != null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                }
+                mDetectionTracker.recordDetection();
+                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
+                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
+                            scanData.scanRecord)) {
+                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
+                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
+                    }
+                }
+                processBeaconFromScan(beacon);
+            } else {
+                if (mNonBeaconLeScanCallback != null) {
+                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
+                }
+            }
+            return null;
+        }
+
+        @Override
+        protected void onPostExecute(Void result) {
+        }
+
+        @Override
+        protected void onPreExecute() {
+        }
+
+        @Override
+        protected void onProgressUpdate(Void... values) {
+        }
+    }
+
+    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
+        List<Region> matched = new ArrayList<>();
+        for (Region region : regions) {
+            if (region.matchesBeacon(beacon)) {
+                matched.add(region);
+            } else {
+                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
+            }
+        }
+        return matched;
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJob.java b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
index 3c98fe92..8842ac3c 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJob.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJob.java
@@ -1,49 +1,23 @@
 package org.altbeacon.beacon.service;
 
 import android.annotation.TargetApi;
-import android.app.job.JobInfo;
 import android.app.job.JobParameters;
 import android.app.job.JobScheduler;
 import android.app.job.JobService;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.le.ScanFilter;
 import android.bluetooth.le.ScanResult;
-import android.bluetooth.le.ScanSettings;
-import android.content.ComponentName;
 import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.os.AsyncTask;
 import android.os.Build;
 import android.os.Handler;
-import android.os.PersistableBundle;
-import android.os.SystemClock;
-
 import org.altbeacon.beacon.Beacon;
 import org.altbeacon.beacon.BeaconManager;
-import org.altbeacon.beacon.BeaconParser;
 import org.altbeacon.beacon.BuildConfig;
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
-import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
-import org.altbeacon.beacon.service.scanner.CycledLeScanner;
 import org.altbeacon.beacon.service.scanner.CycledLeScannerForAndroidO;
-import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
-import org.altbeacon.beacon.service.scanner.ScanFilterUtils;
 import org.altbeacon.beacon.utils.ProcessUtils;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
 
 /**
  * Created by dyoung on 3/24/17.
@@ -69,21 +43,13 @@
 
     private ScanState mScanState;
     private Handler mStopHandler = new Handler();
-
-    // Fields to be refactord to a shared class with BeaconService
-    private ExecutorService mExecutor;
     private BeaconManager mBeaconManager;
-    private CycledLeScanner mCycledScanner;
-    private MonitoringStatus mMonitoringStatus;
-    private Map<Region, RangeState> mRangedRegionState = new HashMap<Region, RangeState>();
-    private DistinctPacketDetector mDistinctPacketDetector = new DistinctPacketDetector();
-    private List<Beacon> mSimulatedScanData = null;  // not supported for scan jobs
-    private ExtraDataBeaconTracker mExtraDataBeaconTracker;
-    private Set<BeaconParser> mBeaconParsers  = new HashSet<BeaconParser>();
+    private ScanHelper mScanHelper;
     private boolean mInitialized = false;
 
     @Override
     public boolean onStartJob(final JobParameters jobParameters) {
+        mScanHelper = new ScanHelper(this);
         JobScheduler jobScheduler = (JobScheduler) this.getSystemService(Context.JOB_SCHEDULER_SERVICE);
         if (jobParameters.getJobId() == IMMMEDIATE_SCAN_JOB_ID) {
             LogManager.i(TAG, "Running immdiate scan job: instance is "+this);
@@ -91,18 +57,12 @@ public boolean onStartJob(final JobParameters jobParameters) {
         else {
             LogManager.i(TAG, "Running periodic scan job: instance is "+this);
         }
-        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
         NonBeaconLeScanCallback nonBeaconLeScanCallback = BeaconManager.getInstanceForApplication(this).getNonBeaconLeScanCallback();
 
         List<ScanResult> queuedScanResults = ScanJobScheduler.getInstance().dumpBackgroundScanResultQueue();
         LogManager.d(TAG, "Processing %d queued scan resuilts", queuedScanResults.size());
         for (ScanResult result : queuedScanResults) {
-            try {
-                new ScanJob.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
-                        new ScanJob.ScanData(result.getDevice(), result.getRssi(), result.getScanRecord().getBytes()));
-            } catch (RejectedExecutionException e) {
-                LogManager.w(TAG, "Ignoring queued scan result because we cannot keep up.");
-            }
+            mScanHelper.processScanResult(result.getDevice(), result.getRssi(), result.getScanRecord().getBytes());
         }
         LogManager.d(TAG, "Done processing queued scan resuilts");
 
@@ -154,12 +114,12 @@ private void startPassiveScanIfNeeded() {
         else {
             LogManager.i(TAG, "We are outside all beacon regions.  We will scan between cycles.");
             // TODO:  Ew. figure out a better way to know to call this
-            if (mCycledScanner instanceof CycledLeScannerForAndroidO) {
+            if (mScanHelper.getCycledScanner() instanceof CycledLeScannerForAndroidO) {
                 // We are in backround mode for Anrdoid O and the background scan cycle
                 // has ended.  Now we kick off a background scan with a lower power
                 // mode and set it to deliver an intent if it sees anything that will
                 // wake us up and start this craziness all over again
-                ((CycledLeScannerForAndroidO)mCycledScanner).startAndroidOBackgroundScan(mScanState.getBeaconParsers());
+                ((CycledLeScannerForAndroidO)mScanHelper.getCycledScanner()).startAndroidOBackgroundScan(mScanState.getBeaconParsers());
             }
             else {
                 LogManager.d(TAG, "This is not an Android O scanner.  No scanning between cycles.");
@@ -182,36 +142,40 @@ public boolean onStopJob(JobParameters params) {
         return false;
     }
 
+    private void stopScanning() {
+        mInitialized = false;
+        mScanHelper.getCycledScanner().stop();
+        mScanHelper.getCycledScanner().destroy();
+        LogManager.d(TAG, "Scanning stopped");
+    }
+
     // Returns true of scanning actually was started, false if it did not need to be
     private boolean restartScanning() {
         mScanState = ScanState.restore(ScanJob.this);
         mScanState.setLastScanStartTimeMillis(System.currentTimeMillis());
-        mMonitoringStatus = mScanState.getMonitoringStatus();
-        mRangedRegionState = mScanState.getRangedRegionState();
-        mBeaconParsers = mScanState.getBeaconParsers();
-        mExtraDataBeaconTracker = mScanState.getExtraBeaconDataTracker();
-        if (mCycledScanner == null) {
-            mCycledScanner = CycledLeScanner.createScanner(ScanJob.this, BeaconManager.DEFAULT_FOREGROUND_SCAN_PERIOD,
-                    BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mScanState.getBackgroundMode(), mCycledLeScanCallback, null);
-        }
-        mCycledScanner.setScanPeriods(mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod(),
+        mScanHelper.setMonitoringStatus(mScanState.getMonitoringStatus());
+        mScanHelper.setRangedRegionState(mScanState.getRangedRegionState());
+        mScanHelper.setBeaconParsers(mScanState.getBeaconParsers());
+        mScanHelper.setExtraDataBeaconTracker(mScanState.getExtraBeaconDataTracker());
+        if (mScanHelper.getCycledScanner() == null) {
+            mScanHelper.createCycledLeScanner(mScanState.getBackgroundMode(), null);
+        }
+        mScanHelper.getCycledScanner().setScanPeriods(mScanState.getBackgroundMode() ? mScanState.getBackgroundScanPeriod() : mScanState.getForegroundScanPeriod(),
                                       mScanState.getBackgroundMode() ? mScanState.getBackgroundBetweenScanPeriod() : mScanState.getForegroundBetweenScanPeriod(),
                                       mScanState.getBackgroundMode());
-        if (mRangedRegionState.size() > 0 || mMonitoringStatus.regions().size() > 0) {
-            mCycledScanner.start();
+        mInitialized = true;
+        if (mScanHelper.getRangedRegionState().size() > 0 || mScanHelper.getMonitoringStatus().regions().size() > 0) {
+            mScanHelper.getCycledScanner().start();
             return true;
         }
         else {
-            mCycledScanner.stop();
+            mScanHelper.getCycledScanner().stop();
             return false;
         }
     }
 
     // Returns true of scanning actually was started, false if it did not need to be
     private boolean startScanning() {
-        // Create a private executor so we don't compete with threads used by AsyncTask
-        // This uses fewer threads than the default executor so it won't hog CPU
-        mExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() + 1);
         mBeaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
         mBeaconManager.setScannerInSameProcess(true);
         if (mBeaconManager.isMainProcess()) {
@@ -226,218 +190,4 @@ private boolean startScanning() {
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
         return restartScanning();
     }
-
-    private void stopScanning() {
-        mCycledScanner.stop();
-        mCycledScanner.destroy();
-        mInitialized = false;
-        LogManager.d(TAG, "Scanning stopped");
-    }
-
-
-
-
-
-  // ***********************
-  // Code below here copied from BeaconService -- refactor to a common class
-
-
-    protected void reloadParsers() {
-        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
-        //flatMap all beacon parsers
-        boolean matchBeaconsByServiceUUID = true;
-        if (mBeaconManager.getBeaconParsers() != null) {
-            newBeaconParsers.addAll(mBeaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : mBeaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
-            }
-        }
-        mBeaconParsers = newBeaconParsers;
-        //initialize the extra data beacon tracker
-        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
-    }
-    protected final CycledLeScanCallback mCycledLeScanCallback = new CycledLeScanCallback() {
-        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-        @Override
-        public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {
-
-            NonBeaconLeScanCallback nonBeaconLeScanCallback = mBeaconManager.getNonBeaconLeScanCallback();
-
-            try {
-                new ScanJob.ScanProcessor(nonBeaconLeScanCallback).executeOnExecutor(mExecutor,
-                        new ScanJob.ScanData(device, rssi, scanRecord));
-            } catch (RejectedExecutionException e) {
-                LogManager.w(TAG, "Ignoring scan result because we cannot keep up.");
-            }
-        }
-
-        @Override
-        public void onCycleEnd() {
-            mDistinctPacketDetector.clearDetections();
-            mMonitoringStatus.updateNewlyOutside();
-            processRangeData();
-            // If we want to use simulated scanning data, do it here.  This is used for testing in an emulator
-            if (mSimulatedScanData != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                LogManager.w(TAG, "Simulated scan data is deprecated and will be removed in a future release. Please use the new BeaconSimulator interface instead.");
-
-                if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                    for (Beacon beacon : mSimulatedScanData) {
-                        processBeaconFromScan(beacon);
-                    }
-                } else {
-                    LogManager.w(TAG, "Simulated scan data provided, but ignored because we are not running in debug mode.  Please remove simulated scan data for production.");
-                }
-            }
-            if (BeaconManager.getBeaconSimulator() != null) {
-                // if simulatedScanData is provided, it will be seen every scan cycle.  *in addition* to anything actually seen in the air
-                // it will not be used if we are not in debug mode
-                if (BeaconManager.getBeaconSimulator().getBeacons() != null) {
-                    if (0 != (getApplicationInfo().flags &= ApplicationInfo.FLAG_DEBUGGABLE)) {
-                        for (Beacon beacon : BeaconManager.getBeaconSimulator().getBeacons()) {
-                            processBeaconFromScan(beacon);
-                        }
-                    } else {
-                        LogManager.w(TAG, "Beacon simulations provided, but ignored because we are not running in debug mode.  Please remove beacon simulations for production.");
-                    }
-                } else {
-                    LogManager.w(TAG, "getBeacons is returning null. No simulated beacons to report.");
-                }
-            }
-        }
-    };
-
-    private void processRangeData() {
-        synchronized (mRangedRegionState) {
-            for (Region region : mRangedRegionState.keySet()) {
-                RangeState rangeState = mRangedRegionState.get(region);
-                LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(ScanJob.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
-            }
-        }
-    }
-
-    private void processBeaconFromScan(Beacon beacon) {
-        if (Stats.getInstance().isEnabled()) {
-            Stats.getInstance().log(beacon);
-        }
-        if (LogManager.isVerboseLoggingEnabled()) {
-            LogManager.d(TAG,
-                    "beacon detected : %s", beacon.toString());
-        }
-
-        beacon = mExtraDataBeaconTracker.track(beacon);
-        // If this is a Gatt beacon that should be ignored, it will be set to null as a result of
-        // the above
-        if (beacon == null) {
-            if (LogManager.isVerboseLoggingEnabled()) {
-                LogManager.d(TAG,
-                        "not processing detections for GATT extra data beacon");
-            }
-        } else {
-
-            mMonitoringStatus.updateNewlyInsideInRegionsContaining(beacon);
-
-            List<Region> matchedRegions = null;
-            Iterator<Region> matchedRegionIterator;
-            LogManager.d(TAG, "looking for ranging region matches for this beacon");
-            synchronized (mRangedRegionState) {
-                matchedRegions = matchingRegions(beacon, mRangedRegionState.keySet());
-                matchedRegionIterator = matchedRegions.iterator();
-                while (matchedRegionIterator.hasNext()) {
-                    Region region = matchedRegionIterator.next();
-                    LogManager.d(TAG, "matches ranging region: %s", region);
-                    RangeState rangeState = mRangedRegionState.get(region);
-                    if (rangeState != null) {
-                        rangeState.addBeacon(beacon);
-                    }
-                }
-            }
-        }
-    }
-
-
-    private class ScanData {
-        public ScanData(BluetoothDevice device, int rssi, byte[] scanRecord) {
-            this.device = device;
-            this.rssi = rssi;
-            this.scanRecord = scanRecord;
-        }
-
-        int rssi;
-        BluetoothDevice device;
-        byte[] scanRecord;
-    }
-
-    private class ScanProcessor extends AsyncTask<ScanJob.ScanData, Void, Void> {
-        final DetectionTracker mDetectionTracker = DetectionTracker.getInstance();
-
-        private final NonBeaconLeScanCallback mNonBeaconLeScanCallback;
-
-        public ScanProcessor(NonBeaconLeScanCallback nonBeaconLeScanCallback) {
-            mNonBeaconLeScanCallback = nonBeaconLeScanCallback;
-        }
-
-        @Override
-        protected Void doInBackground(ScanJob.ScanData... params) {
-            ScanJob.ScanData scanData = params[0];
-            Beacon beacon = null;
-
-            for (BeaconParser parser : ScanJob.this.mBeaconParsers) {
-                beacon = parser.fromScanData(scanData.scanRecord,
-                        scanData.rssi, scanData.device);
-
-                if (beacon != null) {
-                    break;
-                }
-            }
-            if (beacon != null) {
-                if (LogManager.isVerboseLoggingEnabled()) {
-                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
-                }
-                mDetectionTracker.recordDetection();
-                if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
-                    if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
-                            scanData.scanRecord)) {
-                        LogManager.i(TAG, "Non-distinct packets detected in a single scan.  Restarting scans unecessary.");
-                        mCycledScanner.setDistinctPacketsDetectedPerScan(true);
-                    }
-                }
-                processBeaconFromScan(beacon);
-            } else {
-                if (mNonBeaconLeScanCallback != null) {
-                    mNonBeaconLeScanCallback.onNonBeaconLeScan(scanData.device, scanData.rssi, scanData.scanRecord);
-                }
-            }
-            return null;
-        }
-
-        @Override
-        protected void onPostExecute(Void result) {
-        }
-
-        @Override
-        protected void onPreExecute() {
-        }
-
-        @Override
-        protected void onProgressUpdate(Void... values) {
-        }
-    }
-
-    private List<Region> matchingRegions(Beacon beacon, Collection<Region> regions) {
-        List<Region> matched = new ArrayList<Region>();
-        for (Region region : regions) {
-            if (region.matchesBeacon(beacon)) {
-                matched.add(region);
-            } else {
-                LogManager.d(TAG, "This region (%s) does not match beacon: %s", region, beacon);
-            }
-        }
-        return matched;
-    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
index 3fe8904c..f8066130 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanCallback.java
@@ -1,11 +1,18 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.bluetooth.BluetoothDevice;
+import android.support.annotation.MainThread;
 
 /**
+ * Android API agnostic Bluetooth scan callback wrapper.
+ * <p>
+ * Since Android bluetooth scan callbacks occur on the main thread it is expected that these
+ * callbacks will also occur on the main thread.
+ *
  * Created by dyoung on 10/6/14.
  */
+@MainThread
 public interface CycledLeScanCallback {
-    public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);
-    public void onCycleEnd();
+    void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord);
+    void onCycleEnd();
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index d98f0887..e2ee6ed1 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -1,7 +1,6 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.Manifest;
-import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.AlarmManager;
 import android.app.PendingIntent;
@@ -15,15 +14,21 @@
 import android.os.HandlerThread;
 import android.os.Looper;
 import android.os.SystemClock;
+import android.support.annotation.AnyThread;
+import android.support.annotation.MainThread;
+import android.support.annotation.NonNull;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
+
 import java.util.Date;
 
 @TargetApi(18)
 public abstract class CycledLeScanner {
+    public static final long ANDROID_N_MAX_SCAN_DURATION_MILLIS = 30 * 60 * 1000l; // 30 minutes
     private static final String TAG = "CycledLeScanner";
     private BluetoothAdapter mBluetoothAdapter;
 
@@ -31,7 +36,12 @@
     private long mLastScanCycleEndTime = 0l;
     protected long mNextScanCycleStartTime = 0l;
     private long mScanCycleStopTime = 0l;
-
+    // This is the last time this class actually commanded the OS
+    // to start scanning.
+    private long mCurrentScanStartTime = 0l;
+    // True if the app has explicitly requested long running scans that
+    // may go beyond what is normally allowed on Android N.
+    private boolean mLongScanForcingEnabled = false;
     private boolean mScanning;
     protected boolean mScanningPaused;
     private boolean mScanCyclerStarted = false;
@@ -41,8 +51,30 @@
 
     protected long mBetweenScanPeriod;
 
+    /**
+     * Main thread handle for scheduling scan cycle tasks.
+     * <p>
+     * Use this to schedule deferred tasks such as the following:
+     * <ul>
+     *     <li>{@link #scheduleScanCycleStop()}</li>
+     *     <li>{@link #scanLeDevice(Boolean) scanLeDevice(true)} from {@link #deferScanIfNeeded()}</li>
+     * </ul>
+     */
+    @NonNull
     protected final Handler mHandler = new Handler(Looper.getMainLooper());
+
+    /**
+     * Handler to background thread for interacting with the low-level Android BLE scanner.
+     * <p>
+     * Use this to queue any potentially long running BLE scanner actions such as starts and stops.
+     */
+    @NonNull
     protected final Handler mScanHandler;
+
+    /**
+     * Worker thread hosting the internal scanner message queue.
+     */
+    @NonNull
     private final HandlerThread mScanThread;
 
     protected final BluetoothCrashResolver mBluetoothCrashResolver;
@@ -51,7 +83,22 @@
     protected boolean mBackgroundFlag = false;
     protected boolean mRestartNeeded = false;
 
-    private boolean mDistinctPacketsDetectedPerScan = false;
+    /**
+     * Flag indicating device hardware supports detecting multiple identical packets per scan.
+     * <p>
+     * Restarting scanning (stopping and immediately restarting) is necessary on many older Android
+     * devices like the Nexus 4 and Moto G because once they detect a distinct BLE packet in a scan,
+     * subsequent detections do not get a scan callback. Stopping scanning and restarting clears
+     * this out, allowing subsequent detection of identical advertisements. On most newer device,
+     * this is not necessary, and multiple callbacks are given for identical packets detected in
+     * a single scan.
+     * <p>
+     * This is declared {@code volatile} because it may be set by a background scan thread while
+     * we are in a method on the main thread which will end up checking it. Using this modifier
+     * ensures that when we read the flag we'll always see the most recently written value. This is
+     * also true for background scan threads which may be running concurrently.
+     */
+    private volatile boolean mDistinctPacketsDetectedPerScan = false;
     private static final long ANDROID_N_MIN_SCAN_CYCLE_MILLIS = 6000l;
 
     protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
@@ -102,12 +149,22 @@ else if (useAndroidLScanner) {
         }
     }
 
+    /**
+     * Enables the scanner to go to extra lengths to keep scans going for longer than would
+     * otherwise be allowed.  Useful only for Android N and higher.
+     * @param enabled
+     */
+    public void setLongScanForcingEnabled(boolean enabled) {
+        mLongScanForcingEnabled = enabled;
+    }
+
     /**
      * Tells the cycler the scan rate and whether it is in operating in background mode.
      * Background mode flag  is used only with the Android 5.0 scanning implementations to switch
      * between LOW_POWER_MODE vs. LOW_LATENCY_MODE
      * @param backgroundFlag
      */
+    @MainThread
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
         LogManager.d(TAG, "Set scan periods called with %s, %s Background mode must have changed.",
                 scanPeriod, betweenScanPeriod);
@@ -148,6 +205,7 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
         }
     }
 
+    @MainThread
     public void start() {
         LogManager.d(TAG, "start called");
         mScanningEnabled = true;
@@ -158,7 +216,7 @@ public void start() {
         }
     }
 
-    @SuppressLint("NewApi")
+    @MainThread
     public void stop() {
         LogManager.d(TAG, "stop called");
         mScanningEnabled = false;
@@ -169,26 +227,32 @@ public void stop() {
         }
     }
 
+    @AnyThread
     public boolean getDistinctPacketsDetectedPerScan() {
         return mDistinctPacketsDetectedPerScan;
     }
 
+    @AnyThread
     public void setDistinctPacketsDetectedPerScan(boolean detected) {
         mDistinctPacketsDetectedPerScan = detected;
     }
 
+    @MainThread
     public void destroy() {
         LogManager.d(TAG, "Destroying");
+
+        // Remove any postDelayed Runnables queued for the next scan cycle
+        mHandler.removeCallbacksAndMessages(null);
+
         // We cannot quit the thread used by the handler until queued Runnables have been processed,
         // because the handler is what stops scanning, and we do not want scanning left on.
         // So we stop the thread using the handler, so we make sure it happens after all other
         // waiting Runnables are finished.
-        mHandler.post(new Runnable() {
+        mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 LogManager.d(TAG, "Quitting scan thread");
-                // Remove any postDelayed Runnables queued for the next scan cycle
-                mHandler.removeCallbacksAndMessages(null);
                 mScanThread.quit();
             }
         });
@@ -200,14 +264,14 @@ public void run() {
 
     protected abstract void startScan();
 
-    @SuppressLint("NewApi")
+    @MainThread
     protected void scanLeDevice(final Boolean enable) {
         try {
             mScanCyclerStarted = true;
             if (getBluetoothAdapter() == null) {
                 LogManager.e(TAG, "No Bluetooth adapter.  beaconService cannot scan.");
             }
-            if (enable) {
+            if (mScanningEnabled && enable) {
                 if (deferScanIfNeeded()) {
                     return;
                 }
@@ -230,6 +294,7 @@ protected void scanLeDevice(final Boolean enable) {
                                         }
                                         try {
                                             if (android.os.Build.VERSION.SDK_INT < 23 || checkLocationPermission()) {
+                                                mCurrentScanStartTime = SystemClock.elapsedRealtime();
                                                 startScan();
                                             }
                                         } catch (Exception e) {
@@ -248,7 +313,9 @@ protected void scanLeDevice(final Boolean enable) {
                         LogManager.e(e, TAG, "Exception starting Bluetooth scan.  Perhaps Bluetooth is disabled or unavailable?");
                     }
                 } else {
-                    LogManager.d(TAG, "We are already scanning");
+                    LogManager.d(TAG, "We are already scanning and have been for "+(
+                            SystemClock.elapsedRealtime() - mCurrentScanStartTime
+                            )+" millis");
                 }
                 mScanCycleStopTime = (SystemClock.elapsedRealtime() + mScanPeriod);
                 scheduleScanCycleStop();
@@ -259,7 +326,11 @@ protected void scanLeDevice(final Boolean enable) {
                 mScanning = false;
                 mScanCyclerStarted = false;
                 stopScan();
+                mCurrentScanStartTime = 0l;
                 mLastScanCycleEndTime = SystemClock.elapsedRealtime();
+                // Clear any queued schedule tasks as we're done scanning
+                mScanHandler.removeCallbacksAndMessages(null);
+                finishScanCycle();
             }
         }
         catch (SecurityException e) {
@@ -267,16 +338,18 @@ protected void scanLeDevice(final Boolean enable) {
         }
     }
 
+    @MainThread
     protected void scheduleScanCycleStop() {
         // Stops scanning after a pre-defined scan period.
         long millisecondsUntilStop = mScanCycleStopTime - SystemClock.elapsedRealtime();
-        if (millisecondsUntilStop > 0) {
+        if (mScanningEnabled && millisecondsUntilStop > 0) {
             LogManager.d(TAG, "Waiting to stop scan cycle for another %s milliseconds",
                     millisecondsUntilStop);
             if (mBackgroundFlag) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scheduleScanCycleStop();
@@ -289,6 +362,7 @@ public void run() {
 
     protected abstract void finishScan();
 
+    @MainThread
     private void finishScanCycle() {
         LogManager.d(TAG, "Done with scan cycle");
         try {
@@ -305,7 +379,9 @@ private void finishScanCycle() {
                         // so it is best avoided.  If we know the device has detected to distinct
                         // packets in the same cycle, we will not restart scanning and just keep it
                         // going.
-                        if (!getDistinctPacketsDetectedPerScan() || mBetweenScanPeriod != 0) {
+                        if (!mDistinctPacketsDetectedPerScan ||
+                                mBetweenScanPeriod != 0 ||
+                                mustStopScanToPreventAndroidNScanTimeout()) {
                             long now = SystemClock.elapsedRealtime();
                             if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
                                     mBetweenScanPeriod+mScanPeriod < ANDROID_N_MIN_SCAN_CYCLE_MILLIS &&
@@ -334,6 +410,7 @@ private void finishScanCycle() {
                         mLastScanCycleEndTime = SystemClock.elapsedRealtime();
                     } else {
                         LogManager.d(TAG, "Bluetooth is disabled.  Cannot scan for beacons.");
+                        mRestartNeeded = true;
                     }
                 }
                 mNextScanCycleStartTime = getNextScanStartTime();
@@ -439,4 +516,35 @@ private boolean checkLocationPermission() {
     private boolean checkPermission(final String permission) {
         return mContext.checkPermission(permission, android.os.Process.myPid(), android.os.Process.myUid()) == PackageManager.PERMISSION_GRANTED;
     }
+
+    /**
+     * On Android N and later, a scan that runs for more than 30 minutes will be automatically
+     * stopped by the OS and converted to an "opportunistic" scan, meaning that they will only yield
+     * detections if another app is scanning.  This is inteneded to save battery.  This can be
+     * prevented by stopping scanning and restarting.  This method returns true if:
+     *   * this is Android N or later
+     *   * we are close to the 30 minute boundary since the last scan started
+     *   * The app developer has explicitly enabled long-running scans
+     * @return true if we must stop scanning to prevent
+     */
+    private boolean mustStopScanToPreventAndroidNScanTimeout() {
+        long timeOfNextScanCycleEnd = SystemClock.elapsedRealtime() +  mBetweenScanPeriod +
+                mScanPeriod;
+        boolean timeoutAtRisk = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.N &&
+                mCurrentScanStartTime > 0 &&
+                (timeOfNextScanCycleEnd - mCurrentScanStartTime > ANDROID_N_MAX_SCAN_DURATION_MILLIS);
+
+        if (timeoutAtRisk) {
+            LogManager.d(TAG, "The next scan cycle would go over the Android N max duration.");
+            if  (mLongScanForcingEnabled) {
+                LogManager.d(TAG, "Stopping scan to prevent Android N scan timeout.");
+                return true;
+            }
+            else {
+                LogManager.w(TAG, "Allowing a long running scan to be stopped by the OS.  To " +
+                        "prevent this, set longScanForcingEnabled in the AndroidBeaconLibrary.");
+            }
+        }
+        return false;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
index dde46dfc..e9f51a74 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
@@ -5,6 +5,8 @@
 import android.bluetooth.BluetoothDevice;
 import android.content.Context;
 import android.os.SystemClock;
+import android.support.annotation.MainThread;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
@@ -36,6 +38,7 @@ protected boolean deferScanIfNeeded() {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scanLeDevice(true);
@@ -65,6 +68,7 @@ private void postStartLeScan() {
         final BluetoothAdapter.LeScanCallback leScanCallback = getLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -85,6 +89,7 @@ private void postStopLeScan() {
         final BluetoothAdapter.LeScanCallback leScanCallback = getLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index b08c0640..673aeb8c 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -10,6 +10,8 @@
 import android.content.Context;
 import android.os.ParcelUuid;
 import android.os.SystemClock;
+import android.support.annotation.MainThread;
+import android.support.annotation.WorkerThread;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
@@ -134,6 +136,7 @@ protected boolean deferScanIfNeeded() {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
+                @MainThread
                 @Override
                 public void run() {
                     scanLeDevice(true);
@@ -190,6 +193,7 @@ private void postStartLeScan(final List<ScanFilter> filters, final ScanSettings
         final ScanCallback scanCallback = getNewLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -220,6 +224,7 @@ private void postStopLeScan() {
         final ScanCallback scanCallback = getNewLeScanCallback();
         mScanHandler.removeCallbacksAndMessages(null);
         mScanHandler.post(new Runnable() {
+            @WorkerThread
             @Override
             public void run() {
                 try {
@@ -275,7 +280,7 @@ private BluetoothLeScanner getScanner() {
     private ScanCallback getNewLeScanCallback() {
         if (leScanCallback == null) {
             leScanCallback = new ScanCallback() {
-
+                @MainThread
                 @Override
                 public void onScanResult(int callbackType, ScanResult scanResult) {
                     if (LogManager.isVerboseLoggingEnabled()) {
@@ -294,6 +299,7 @@ public void onScanResult(int callbackType, ScanResult scanResult) {
                     }
                 }
 
+                @MainThread
                 @Override
                 public void onBatchScanResults(List<ScanResult> results) {
                     LogManager.d(TAG, "got batch records");
@@ -306,6 +312,7 @@ public void onBatchScanResults(List<ScanResult> results) {
                     }
                 }
 
+                @MainThread
                 @Override
                 public void onScanFailed(int errorCode) {
                     switch (errorCode) {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java b/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
index f85139cb..15aeda1e 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/NonBeaconLeScanCallback.java
@@ -1,6 +1,7 @@
 package org.altbeacon.beacon.service.scanner;
 
 import android.bluetooth.BluetoothDevice;
+import android.support.annotation.WorkerThread;
 
 /**
  * Allows an implementation to see non-Beacon BLE devices as they are scanned.
@@ -23,6 +24,7 @@
  *  }
  * </code></pre>
  */
+@WorkerThread
 public interface NonBeaconLeScanCallback {
     /**
      * NOTE: This method is NOT called on the main UI thread.
diff --git a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
index 37be84e9..d77e7eab 100644
--- a/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/BeaconServiceTest.java
@@ -48,7 +48,7 @@ public void beaconScanCallbackTest() throws Exception {
         beaconServiceServiceController.attach();
         BeaconService beaconService = beaconServiceServiceController.get();
         beaconService.onCreate();
-        CycledLeScanCallback callback = beaconService.mCycledLeScanCallback;
+        CycledLeScanCallback callback = beaconService.getCycledLeScanCallback();
 
         ThreadPoolExecutor executor = (ThreadPoolExecutor) AsyncTask.THREAD_POOL_EXECUTOR;
         int activeThreadCountBeforeScan = executor.getActiveCount();
diff --git a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
index 562de095..e79c8ee9 100644
--- a/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RunningAverageRssiFilterTest.java
@@ -1,5 +1,6 @@
 package org.altbeacon.beacon.service;
 
+import org.altbeacon.beacon.Beacon;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.RobolectricTestRunner;
@@ -17,4 +18,24 @@ public void initTest1() {
         filter.addMeasurement(-50);
         assertEquals("First measurement should be -50", String.valueOf(filter.calculateRssi()), "-50.0");
     }
+    @Test
+    public void rangedBeaconDoesNotOverrideSampleExpirationMillisecondsText() {
+        RangedBeacon.setSampleExpirationMilliseconds(20000);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(20000);
+        Beacon beacon = new Beacon.Builder().setId1("1").build();
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(33l);
+        RangedBeacon rb = new RangedBeacon(beacon);
+        assertEquals("RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by constructing RangedBeacon", 33l, RunningAverageRssiFilter.getSampleExpirationMilliseconds());
+    }
+
+    @Test
+    public void legacySetSampleExpirationMillisecondsWorksText() {
+        RangedBeacon.setSampleExpirationMilliseconds(20000);
+        RunningAverageRssiFilter.setSampleExpirationMilliseconds(20000);
+        Beacon beacon = new Beacon.Builder().setId1("1").build();
+        RangedBeacon.setSampleExpirationMilliseconds(33l);
+        RangedBeacon rb = new RangedBeacon(beacon);
+        assertEquals("RunningAverageRssiFilter sampleExprirationMilliseconds should not be altered by constructing RangedBeacon", 33l, RunningAverageRssiFilter.getSampleExpirationMilliseconds());
+    }
+
 }
