diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9e00ee1d..e60f54f8 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,7 +1,21 @@
+
 ### Development
 
 Enhancements:
 
+- Add support for running the beacon scanning service in a separate process and working with
+  application setups that have more than one process. (#479, David G. Young)
+
+Bug Fixes:
+
+- TODO
+
+### 2.10 / 2017-04-21
+
+[Full Changelog](https://github.com/AltBeacon/android-beacon-library/compare/2.9.2...2.10)
+
+Enhancements:
+
 - Don't restart BLE scanning periodically if the library confrims device can detect duplicate
   advertisements in a single scan, leading to more reliable detections with short scan cycles
   (#491, David G. Young)
diff --git a/src/main/java/org/altbeacon/beacon/Beacon.java b/src/main/java/org/altbeacon/beacon/Beacon.java
index e49c232a..dab588bc 100644
--- a/src/main/java/org/altbeacon/beacon/Beacon.java
+++ b/src/main/java/org/altbeacon/beacon/Beacon.java
@@ -31,8 +31,10 @@
 import org.altbeacon.beacon.distance.DistanceCalculator;
 import org.altbeacon.beacon.logging.LogManager;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
+
 import java.util.List;
 
 /**
@@ -54,7 +56,7 @@
  * @author  David G. Young
  * @see     Region#matchesBeacon(Beacon Beacon)
  */
-public class Beacon implements Parcelable {
+public class Beacon implements Parcelable, Serializable {
     private static final String TAG = "Beacon";
 
     private static final List<Long> UNMODIFIABLE_LIST_OF_LONG =
@@ -168,6 +170,7 @@
      * Required for making object Parcelable.  If you override this class, you must provide an
      * equivalent version of this method.
      */
+    @Deprecated
     public static final Parcelable.Creator<Beacon> CREATOR
             = new Parcelable.Creator<Beacon>() {
         public Beacon createFromParcel(Parcel in) {
@@ -205,10 +208,15 @@ public static void setHardwareEqualityEnforced(boolean e) {
         sHardwareEqualityEnforced = e;
     }
 
+    public static boolean getHardwareEqualityEnforced() {
+        return sHardwareEqualityEnforced;
+    }
+
     /**
      * Required for making Beacon parcelable
      * @param in parcel
      */
+    @Deprecated
     protected Beacon(Parcel in) {
         int size = in.readInt();
 
@@ -276,6 +284,16 @@ public void setRunningAverageRssi(double rssi) {
         mDistance = null; // force calculation of accuracy and proximity next time they are requested
     }
 
+    /**
+     * Returns the running average rssi
+     * @param rssi
+     * @return
+     */
+    public double getRunningAverageRssi(double rssi) {
+        return mRunningAverageRssi = rssi;
+    }
+
+
     /**
      * Sets the most recently measured rssi for use in distance calculations if a running average is
      * not available
@@ -522,6 +540,7 @@ private StringBuilder toStringBuilder() {
     /**
      * Required for making object Parcelable
      */
+    @Deprecated
     public int describeContents() {
         return 0;
     }
@@ -530,6 +549,7 @@ public int describeContents() {
      * Required for making object Parcelable.  If you override this class, you must override this
      * method if you add any additional fields.
      */
+    @Deprecated
     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mIdentifiers.size());
         for (Identifier identifier: mIdentifiers) {
@@ -700,6 +720,16 @@ public Builder setRssi(int rssi) {
             return this;
         }
 
+        /**
+         * @see Beacon#mRssi
+         * @param rssi
+         * @return builder
+         */
+        public Builder setRunningAverageRssi(double rssi) {
+            mBeacon.mRunningAverageRssi = rssi;
+            return this;
+        }
+
         /**
          * @see Beacon#mTxPower
          * @param txPower
@@ -799,6 +829,7 @@ public Builder setMultiFrameBeacon(boolean multiFrameBeacon) {
             mBeacon.mMultiFrameBeacon = multiFrameBeacon;
             return this;
         }
+
     }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
index a3968df4..b2d11269 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconIntentProcessor.java
@@ -28,12 +28,14 @@
 
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.MonitoringData;
+import org.altbeacon.beacon.service.MonitoringStatus;
 import org.altbeacon.beacon.service.RangingData;
 
 import java.util.Set;
 
 /**
  * Converts internal intents to notifier callbacks
+ * This IntentService may be running in a different process from the BeaconService.
  */
 public class BeaconIntentProcessor extends IntentService {
     private static final String TAG = "BeaconIntentProcessor";
@@ -50,8 +52,12 @@ protected void onHandleIntent(Intent intent) {
         RangingData rangingData = null;
 
         if (intent != null && intent.getExtras() != null) {
-            monitoringData = (MonitoringData) intent.getExtras().get("monitoringData");
-            rangingData = (RangingData) intent.getExtras().get("rangingData");
+            if (intent.getExtras().getBundle("monitoringData") != null) {
+                monitoringData = MonitoringData.fromBundle(intent.getExtras().getBundle("monitoringData"));
+            }
+            if (intent.getExtras().getBundle("rangingData") != null) {
+                rangingData = RangingData.fromBundle(intent.getExtras().getBundle("rangingData"));
+            }
         }
 
         if (rangingData != null) {
@@ -81,7 +87,14 @@ protected void onHandleIntent(Intent intent) {
             if (notifiers != null) {
                 for(MonitorNotifier notifier : notifiers) {
                     LogManager.d(TAG, "Calling monitoring notifier: %s", notifier);
-                    notifier.didDetermineStateForRegion(monitoringData.isInside() ? MonitorNotifier.INSIDE : MonitorNotifier.OUTSIDE, monitoringData.getRegion());
+                    Region region = monitoringData.getRegion();
+                    Integer state = monitoringData.isInside() ? MonitorNotifier.INSIDE :
+                            MonitorNotifier.OUTSIDE;
+                    notifier.didDetermineStateForRegion(state, region);
+                    // In case the beacon scanner is running in a separate process, the monitoring
+                    // status in this process  will not have been updated yet as a result of this
+                    // region state change.  We make a call here to keep it in sync.
+                    MonitoringStatus.getInstanceForApplication(this).updateLocalState(region, state);
                     if (monitoringData.isInside()) {
                         notifier.didEnterRegion(monitoringData.getRegion());
                     } else {
diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index adadbdb8..410ade1f 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -43,9 +43,11 @@
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
+import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.simulator.BeaconSimulator;
+import org.altbeacon.beacon.utils.ProcessUtils;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -108,7 +110,7 @@
 public class BeaconManager {
     private static final String TAG = "BeaconManager";
     private Context mContext;
-    protected static volatile BeaconManager client = null;
+    protected static volatile BeaconManager sInstance = null;
     private final ConcurrentMap<BeaconConsumer, ConsumerInfo> consumers = new ConcurrentHashMap<BeaconConsumer,ConsumerInfo>();
     private Messenger serviceMessenger = null;
     protected final Set<RangeNotifier> rangeNotifiers = new CopyOnWriteArraySet<>();
@@ -117,8 +119,12 @@
     private final ArrayList<Region> rangedRegions = new ArrayList<Region>();
     private final List<BeaconParser> beaconParsers = new CopyOnWriteArrayList<>();
     private NonBeaconLeScanCallback mNonBeaconLeScanCallback;
+    private boolean mRegionStatePersistenceEnabled = true;
     private boolean mBackgroundMode = false;
     private boolean mBackgroundModeUninitialized = true;
+    private boolean mMainProcess = false;
+    private Boolean mScannerInSameProcess = null;
+
 
     private static boolean sAndroidLScanningDisabled = false;
     private static boolean sManifestCheckingDisabled = false;
@@ -228,6 +234,9 @@ public void setBackgroundBetweenScanPeriod(long p) {
      */
     public static void setRegionExitPeriod(long regionExitPeriod){
         sExitRegionPeriod = regionExitPeriod;
+        if (sInstance != null) {
+            sInstance.applySettings();
+        }
     }
     
     /**
@@ -257,25 +266,67 @@ public static BeaconManager getInstanceForApplication(Context context) {
          *
          * Joshua Bloch. Effective Java, Second Edition. Addison-Wesley, 2008. pages 283-284
          */
-        BeaconManager instance = client;
+        BeaconManager instance = sInstance;
         if (instance == null) {
             synchronized (SINGLETON_LOCK) {
-                instance = client;
+                instance = sInstance;
                 if (instance == null) {
-                    client = instance = new BeaconManager(context);
+                    sInstance = instance = new BeaconManager(context);
                 }
             }
         }
         return instance;
     }
 
-   protected BeaconManager(Context context) {
-      mContext = context.getApplicationContext();
-      if (!sManifestCheckingDisabled) {
-         verifyServiceDeclaration();
-      }
-      this.beaconParsers.add(new AltBeaconParser());
-   }
+    protected BeaconManager(Context context) {
+        mContext = context.getApplicationContext();
+        checkIfMainProcess();
+        if (!sManifestCheckingDisabled) {
+           verifyServiceDeclaration();
+         }
+        this.beaconParsers.add(new AltBeaconParser());
+    }
+
+    /***
+     * Determines if this BeaconManager instance is associated with the main application process that
+     * hosts the user interface.  This is normally true unless the scanning service or another servide
+     * is running in a separate process.
+     * @return
+     */
+    public boolean isMainProcess() {
+        return mMainProcess;
+    }
+
+    /**
+     * 
+     * Determines if this BeaconManager instance is not part of the process hosting the beacon scanning
+     * service.  This is normally false, except when scanning is hosted in a different process.
+     * This will always return false until the scanning service starts up, at which time it will be
+     * known if it is in a different process.
+     *
+     * @return
+     */
+    public boolean isScannerInDifferentProcess() {
+        // may be null if service not started yet, so explicitly check
+        return mScannerInSameProcess != null && !mScannerInSameProcess;
+    }
+
+    /**
+     * Reserved for internal use by the library.
+     * @hide
+     */
+    public void setScannerInSameProcess(boolean isScanner) {
+        mScannerInSameProcess = isScanner;
+    }
+
+    protected void checkIfMainProcess() {
+        ProcessUtils processUtils = new ProcessUtils(mContext);
+        String processName = processUtils.getProcessName();
+        String packageName = processUtils.getPackageName();
+        int pid = processUtils.getPid();
+        mMainProcess = processUtils.isMainProcess();
+        LogManager.i(TAG, "BeaconManager started up on pid "+pid+" named '"+processName+"' for application package '"+packageName+"'.  isMainProcess="+mMainProcess);
+    }
 
    /**
      * Gets a list of the active beaconParsers.
@@ -510,6 +561,9 @@ public void removeAllRangeNotifiers() {
      */
     @Deprecated
     public void setMonitorNotifier(MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         synchronized (monitorNotifiers) {
             monitorNotifiers.clear();
         }
@@ -530,6 +584,9 @@ public void setMonitorNotifier(MonitorNotifier notifier) {
      * @see Region
      */
     public void addMonitorNotifier(MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         if (notifier != null) {
             synchronized (monitorNotifiers) {
                 monitorNotifiers.add(notifier);
@@ -555,6 +612,9 @@ public boolean removeMonitoreNotifier(MonitorNotifier notifier) {
      * @see Region
      */
     public boolean removeMonitorNotifier(MonitorNotifier notifier) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return false;
+        }
         synchronized (monitorNotifiers) {
             return monitorNotifiers.remove(notifier);
         }
@@ -564,6 +624,9 @@ public boolean removeMonitorNotifier(MonitorNotifier notifier) {
      * Remove all the Monitor Notifiers.
      */
     public void removeAllMonitorNotifiers() {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         synchronized (monitorNotifiers) {
             monitorNotifiers.clear();
         }
@@ -588,11 +651,23 @@ public void setRegionStatePeristenceEnabled(boolean enabled) {
      * @param enabled true to enable the region state persistence, false to disable it.
      */
     public void setRegionStatePersistenceEnabled(boolean enabled) {
-        if (enabled) {
-            MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
-        } else {
-            MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+        mRegionStatePersistenceEnabled = enabled;
+        if (!isScannerInDifferentProcess()) {
+            if (enabled) {
+                MonitoringStatus.getInstanceForApplication(mContext).startStatusPreservation();
+            } else {
+                MonitoringStatus.getInstanceForApplication(mContext).stopStatusPreservation();
+            }
         }
+        this.applySettings();
+    }
+
+    /**
+     * Indicates whether region state preservation is enabled
+     * @return
+     */
+    public boolean isRegionStatePersistenceEnabled() {
+        return mRegionStatePersistenceEnabled;
     }
 
     /**
@@ -602,6 +677,9 @@ public void setRegionStatePersistenceEnabled(boolean enabled) {
      * @param region
      */
     public void requestStateForRegion(Region region) {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         MonitoringStatus status = MonitoringStatus.getInstanceForApplication(mContext);
         RegionMonitoringState stateObj = status.stateOf(region);
         int state = MonitorNotifier.OUTSIDE;
@@ -633,12 +711,14 @@ public void startRangingBeaconsInRegion(Region region) throws RemoteException {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, BeaconService.MSG_START_RANGING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             rangedRegions.add(region);
@@ -661,12 +741,14 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, BeaconService.MSG_STOP_RANGING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
         synchronized (rangedRegions) {
             Region regionToRemove = null;
@@ -679,6 +761,45 @@ public void stopRangingBeaconsInRegion(Region region) throws RemoteException {
         }
     }
 
+    /**
+     * Call this method if you are running the scanner service in a different process in order to
+     * synchronize any configuration settings, including BeaconParsers to the scanner
+     * @see #isScannerInDifferentProcess()
+     */
+    public void applySettings() {
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
+        if (isAnyConsumerBound() && !isScannerInDifferentProcess() == false) {
+            LogManager.d(TAG, "Synchronizing settings to service");
+            syncSettingsToService();
+        }
+        else {
+            if (isAnyConsumerBound() == false) {
+                LogManager.d(TAG, "Not synchronizing settings to service, as it has not started up yet");
+
+            }
+            else {
+                LogManager.d(TAG, "Not synchronizing settings to service, as it is in the same process");
+            }
+        }
+    }
+
+    protected void syncSettingsToService() {
+        if (serviceMessenger == null) {
+            LogManager.e(TAG, "The BeaconManager is not bound to the service.  Settings synchronization will fail.");
+            return;
+        }
+        try {
+            Message msg = Message.obtain(null, BeaconService.MSG_SYNC_SETTINGS, 0, 0);
+            msg.setData(new SettingsData().collect(mContext).toBundle());
+            serviceMessenger.send(msg);
+        }
+        catch (RemoteException e) {
+            LogManager.e(TAG, "Failed to sync settings to service", e);
+        }
+    }
+
     /**
      * Tells the <code>BeaconService</code> to start looking for beacons that match the passed
      * <code>Region</code> object.  Note that the Region's unique identifier must be retained to
@@ -696,14 +817,19 @@ public void startMonitoringBeaconsInRegion(Region region) throws RemoteException
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         LogManager.d(TAG, "Starting monitoring region "+region+" with uniqueID: "+region.getUniqueId());
         Message msg = Message.obtain(null, BeaconService.MSG_START_MONITORING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
+        if (isScannerInDifferentProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).addLocalRegion(region);
+        }
         this.requestStateForRegion(region);
     }
 
@@ -724,13 +850,18 @@ public void stopMonitoringBeaconsInRegion(Region region) throws RemoteException
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, BeaconService.MSG_STOP_MONITORING, 0, 0);
-        StartRMData obj = new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(region, callbackPackageName(), this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
+        if (isScannerInDifferentProcess()) {
+            MonitoringStatus.getInstanceForApplication(mContext).removeLocalRegion(region);
+        }
     }
 
 
@@ -746,14 +877,16 @@ public void updateScanPeriods() throws RemoteException {
             LogManager.w(TAG, "Method invocation will be ignored.");
             return;
         }
+        if (determineIfCalledFromSeparateScannerProcess()) {
+            return;
+        }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, BeaconService.MSG_SET_SCAN_PERIODS, 0, 0);
         LogManager.d(TAG, "updating background flag to %s", mBackgroundMode);
         LogManager.d(TAG, "updating scan period to %s, %s", this.getScanPeriod(), this.getBetweenScanPeriod());
-        StartRMData obj = new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode);
-        msg.obj = obj;
+        msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
         serviceMessenger.send(msg);
     }
 
@@ -858,6 +991,7 @@ public static String getDistanceModelUpdateUrl() {
     }
 
     public static void setDistanceModelUpdateUrl(String url) {
+        warnIfScannerNotInSameProcess();
         distanceModelUpdateUrl = url;
     }
 
@@ -867,6 +1001,7 @@ public static void setDistanceModelUpdateUrl(String url) {
     protected static Class rssiFilterImplClass = RunningAverageRssiFilter.class;
 
     public static void setRssiFilterImplClass(Class c) {
+        warnIfScannerNotInSameProcess();
         rssiFilterImplClass = c;
     }
 
@@ -880,6 +1015,9 @@ public static Class getRssiFilterImplClass() {
      */
     public static void setUseTrackingCache(boolean useTrackingCache) {
         RangeState.setUseTrackingCache(useTrackingCache);
+        if (sInstance != null) {
+            sInstance.applySettings();
+        }
     }
 
     /**
@@ -892,6 +1030,7 @@ public void setMaxTrackingAge(int maxTrackingAge) {
     }
 
     public static void setBeaconSimulator(BeaconSimulator beaconSimulator) {
+        warnIfScannerNotInSameProcess();
         BeaconManager.beaconSimulator = beaconSimulator;
     }
 
@@ -972,7 +1111,12 @@ private BeaconServiceConnection() {
         // Called when the connection with the service is established
         public void onServiceConnected(ComponentName className, IBinder service) {
             LogManager.d(TAG, "we have a connection to the service now");
+            if (mScannerInSameProcess == null) {
+                mScannerInSameProcess = false;
+            }
             serviceMessenger = new Messenger(service);
+            // This will sync settings to the scanning service if it is in a different process
+            applySettings();
             synchronized(consumers) {
                 Iterator<Map.Entry<BeaconConsumer, ConsumerInfo>> iter = consumers.entrySet().iterator();
                 while (iter.hasNext()) {
@@ -1018,6 +1162,19 @@ public static boolean isAndroidLScanningDisabled() {
      */
     public static void setAndroidLScanningDisabled(boolean disabled) {
         sAndroidLScanningDisabled = disabled;
+        if (sInstance != null) {
+            sInstance.applySettings();
+        }
+    }
+
+    /**
+     * Deprecated misspelled method
+     * @see #setManifestCheckingDisabled(boolean)
+     * @param disabled
+     */
+    @Deprecated
+    public static void setsManifestCheckingDisabled(boolean disabled) {
+        sManifestCheckingDisabled = disabled;
     }
 
     /**
@@ -1026,7 +1183,32 @@ public static void setAndroidLScanningDisabled(boolean disabled) {
      *
      * @param disabled
      */
-    public static void setsManifestCheckingDisabled(boolean disabled) {
+    public static void setManifestCheckingDisabled(boolean disabled) {
         sManifestCheckingDisabled = disabled;
     }
+
+    /**
+     * Returns whether manifest checking is disabled
+     */
+    public static boolean getManifestCheckingDisabled() {
+        return sManifestCheckingDisabled;
+    }
+
+    private boolean determineIfCalledFromSeparateScannerProcess() {
+        if (isScannerInDifferentProcess() && !isMainProcess()) {
+            LogManager.w(TAG, "Ranging/Monitoring may not be controlled from a separate "+
+                    "BeaconScanner process.  To remove this warning, please wrap this call in:"+
+                    " if (beaconManager.isMainProcess())");
+            return true;
+        }
+        return false;
+    }
+
+    private static void warnIfScannerNotInSameProcess() {
+        if (sInstance != null && sInstance.isScannerInDifferentProcess()) {
+            LogManager.w(TAG,
+                    "Unsupported configuration change made for BeaconScanner in separate process");
+        }
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/BeaconParser.java b/src/main/java/org/altbeacon/beacon/BeaconParser.java
index c049b994..8591db4e 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconParser.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconParser.java
@@ -9,6 +9,7 @@
 import org.altbeacon.bluetooth.BleAdvertisement;
 import org.altbeacon.bluetooth.Pdu;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -36,7 +37,7 @@
  * </p>
  *
  */
-public class BeaconParser {
+public class BeaconParser implements Serializable {
     private static final String TAG = "BeaconParser";
     public static final String ALTBEACON_LAYOUT = "m:2-3=beac,i:4-19,i:20-21,i:22-23,p:24-24,d:25-25";
     public static final String EDDYSTONE_TLM_LAYOUT = "x,s:0-1=feaa,m:2-2=20,d:3-3,d:4-5,d:6-7,d:8-11,d:12-15";
@@ -53,6 +54,7 @@
     private static final String LITTLE_ENDIAN_SUFFIX = "l";
     private static final String VARIABLE_LENGTH_SUFFIX = "v";
 
+    protected String mBeaconLayout;
     private Long mMatchingBeaconTypeCode;
     protected final List<Integer> mIdentifierStartOffsets = new ArrayList<Integer>();
     protected final List<Integer> mIdentifierEndOffsets = new ArrayList<Integer>();
@@ -165,7 +167,7 @@ public BeaconParser(String identifier) {
      * @return the BeaconParser instance
      */
     public BeaconParser setBeaconLayout(String beaconLayout) {
-
+        mBeaconLayout = beaconLayout;
         Log.d(TAG, "Parsing beacon layout: "+beaconLayout);
 
         String[] terms =  beaconLayout.split(",");
@@ -756,6 +758,13 @@ public int getDataFieldCount() {
         return mDataStartOffsets.size();
     }
 
+    /**
+     * @return the layout string for the parser
+     */
+    public String getLayout() {
+        return mBeaconLayout;
+    }
+
     /**
      * @return the correction value in dBm to apply to the calibrated txPower to get a 1m calibrated value.
      * Some formats like Eddystone use a 0m calibrated value, which requires this correction
@@ -924,4 +933,20 @@ public int hashCode() {
             }
         );
     }
+
+    @Override
+    public boolean equals(Object o) {
+        BeaconParser that = null;
+        try {
+            that = (BeaconParser) o;
+            if (that.mBeaconLayout != null && that.mBeaconLayout.equals(this.mBeaconLayout)) {
+                if (that.mIdentifier != null && that.mIdentifier.equals(this.mIdentifier)) {
+                    return true;
+                }
+            }
+        }
+        catch (ClassCastException e ) { }
+        return false;
+    }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/Region.java b/src/main/java/org/altbeacon/beacon/Region.java
index db5886da..24b0ad62 100644
--- a/src/main/java/org/altbeacon/beacon/Region.java
+++ b/src/main/java/org/altbeacon/beacon/Region.java
@@ -51,7 +51,6 @@
 public class Region implements Parcelable, Serializable {
     private static final String TAG = "Region";
     private static final Pattern MAC_PATTERN = Pattern.compile("^[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}\\:[0-9A-Fa-f]{2}$");
-
     /**
      * Required to make class Parcelable
      */
@@ -309,4 +308,5 @@ private void validateMac(String mac) throws IllegalArgumentException {
     public Region clone() {
         return new Region(mUniqueId, mIdentifiers, mBluetoothAddress);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java b/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
new file mode 100644
index 00000000..2b9baec5
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/logging/InfoAndroidLogger.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2015 Radius Networks, Inc.
+ * Copyright 2015 Andrew Reitz
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.altbeacon.beacon.logging;
+
+import android.util.Log;
+
+/**
+ * Android logger that only logs out warning and above to the {@link android.util.Log}.
+ *
+ * @since 2.2
+ * @author Andrew Reitz
+ */
+final class InfoAndroidLogger extends AbstractAndroidLogger {
+    @Override
+    public void v(String tag, String message, Object... args) { }
+
+    @Override
+    public void v(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void d(String tag, String message, Object... args) { }
+
+    @Override
+    public void d(Throwable t, String tag, String message, Object... args) { }
+
+    @Override
+    public void i(String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args));
+    }
+
+    @Override
+    public void i(Throwable t, String tag, String message, Object... args) {
+        Log.i(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void w(String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args));
+    }
+
+    @Override
+    public void w(Throwable t, String tag, String message, Object... args) {
+        Log.w(tag, formatString(message, args), t);
+    }
+
+    @Override
+    public void e(String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args));
+    }
+
+    @Override
+    public void e(Throwable t, String tag, String message, Object... args) {
+        Log.e(tag, formatString(message, args), t);
+    }
+}
diff --git a/src/main/java/org/altbeacon/beacon/logging/LogManager.java b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
index 4500699e..8420d7a6 100644
--- a/src/main/java/org/altbeacon/beacon/logging/LogManager.java
+++ b/src/main/java/org/altbeacon/beacon/logging/LogManager.java
@@ -24,7 +24,7 @@
  * @since 2.2
  */
 public final class LogManager {
-    private static Logger sLogger = Loggers.warningLogger();
+    private static Logger sLogger = Loggers.infoLogger();
     private static boolean sVerboseLoggingEnabled = false;
 
     /**
diff --git a/src/main/java/org/altbeacon/beacon/logging/Loggers.java b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
index 44144026..c243f62c 100644
--- a/src/main/java/org/altbeacon/beacon/logging/Loggers.java
+++ b/src/main/java/org/altbeacon/beacon/logging/Loggers.java
@@ -30,6 +30,9 @@
     /** Debug Logger Singleton. */
     private static final Logger VERBOSE_ANDROID_LOGGER = new VerboseAndroidLogger();
 
+    /** Info Logger Singleton. */
+    private static final Logger INFO_ANDROID_LOGGER = new InfoAndroidLogger();
+
     /** Warning Logger Singleton. */
     private static final Logger WARNING_ANDROID_LOGGER = new WarningAndroidLogger();
 
@@ -48,6 +51,14 @@ public static Logger verboseLogger() {
         return VERBOSE_ANDROID_LOGGER;
     }
 
+    /**
+     * @return Get a logger that logs messages of info and greater.
+     * @see android.util.Log
+     */
+    public static Logger infoLogger() {
+        return INFO_ANDROID_LOGGER;
+    }
+
     /**
      * @return Get a logger that logs messages of warning and greater.
      * @see android.util.Log
diff --git a/src/main/java/org/altbeacon/beacon/service/BeaconService.java b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
index 0e8aecf2..63f38787 100644
--- a/src/main/java/org/altbeacon/beacon/service/BeaconService.java
+++ b/src/main/java/org/altbeacon/beacon/service/BeaconService.java
@@ -53,6 +53,7 @@
 import org.altbeacon.beacon.service.scanner.DistinctPacketDetector;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.startup.StartupBroadcastReceiver;
+import org.altbeacon.beacon.utils.ProcessUtils;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
 import java.lang.ref.WeakReference;
@@ -137,6 +138,7 @@ public BeaconService getService() {
     public static final int MSG_START_MONITORING = 4;
     public static final int MSG_STOP_MONITORING = 5;
     public static final int MSG_SET_SCAN_PERIODS = 6;
+    public static final int MSG_SYNC_SETTINGS = 7;
 
     static class IncomingHandler extends Handler {
         private final WeakReference<BeaconService> mService;
@@ -148,37 +150,52 @@ public BeaconService getService() {
         @Override
         public void handleMessage(Message msg) {
             BeaconService service = mService.get();
-            StartRMData startRMData = (StartRMData) msg.obj;
-
             if (service != null) {
-                switch (msg.what) {
-                    case MSG_START_RANGING:
-                        LogManager.i(TAG, "start ranging received");
-                        service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_STOP_RANGING:
-                        LogManager.i(TAG, "stop ranging received");
-                        service.stopRangingBeaconsInRegion(startRMData.getRegionData());
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_START_MONITORING:
-                        LogManager.i(TAG, "start monitoring received");
-                        service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_STOP_MONITORING:
-                        LogManager.i(TAG, "stop monitoring received");
-                        service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    case MSG_SET_SCAN_PERIODS:
-                        LogManager.i(TAG, "set scan intervals received");
-                        service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
-                        break;
-                    default:
-                        super.handleMessage(msg);
+                StartRMData startRMData = StartRMData.fromBundle(msg.getData());
+                if (startRMData != null) {
+                    switch (msg.what) {
+                        case MSG_START_RANGING:
+                            LogManager.i(TAG, "start ranging received");
+                            service.startRangingBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_STOP_RANGING:
+                            LogManager.i(TAG, "stop ranging received");
+                            service.stopRangingBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_START_MONITORING:
+                            LogManager.i(TAG, "start monitoring received");
+                            service.startMonitoringBeaconsInRegion(startRMData.getRegionData(), new org.altbeacon.beacon.service.Callback(startRMData.getCallbackPackageName()));
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_STOP_MONITORING:
+                            LogManager.i(TAG, "stop monitoring received");
+                            service.stopMonitoringBeaconsInRegion(startRMData.getRegionData());
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        case MSG_SET_SCAN_PERIODS:
+                            LogManager.i(TAG, "set scan intervals received");
+                            service.setScanPeriods(startRMData.getScanPeriod(), startRMData.getBetweenScanPeriod(), startRMData.getBackgroundFlag());
+                            break;
+                        default:
+                            super.handleMessage(msg);
+                    }
+                }
+                else if (msg.what == MSG_SYNC_SETTINGS) {
+                    LogManager.i(TAG, "Received settings update from other process");
+                    SettingsData settingsData = SettingsData.fromBundle(msg.getData());
+                    if (settingsData != null) {
+                        settingsData.apply(service);
+                    }
+                    else {
+                        LogManager.w(TAG, "Settings data missing");
+                    }
                 }
+                else {
+                    LogManager.i(TAG, "Received unknown message from other process : "+msg.what);
+                }
+
             }
         }
     }
@@ -191,7 +208,6 @@ public void handleMessage(Message msg) {
 
     @Override
     public void onCreate() {
-        LogManager.i(TAG, "beaconService version %s is starting up", BuildConfig.VERSION_NAME);
         bluetoothCrashResolver = new BluetoothCrashResolver(this);
         bluetoothCrashResolver.start();
 
@@ -203,21 +219,17 @@ public void onCreate() {
                 BeaconManager.DEFAULT_FOREGROUND_BETWEEN_SCAN_PERIOD, mBackgroundFlag, mCycledLeScanCallback, bluetoothCrashResolver);
 
         beaconManager = BeaconManager.getInstanceForApplication(getApplicationContext());
-
-        //flatMap all beacon parsers
-        boolean matchBeaconsByServiceUUID = true;
-        if (beaconManager.getBeaconParsers() != null) {
-            beaconParsers.addAll(beaconManager.getBeaconParsers());
-            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
-                if (beaconParser.getExtraDataParsers().size() > 0) {
-                    matchBeaconsByServiceUUID = false;
-                    beaconParsers.addAll(beaconParser.getExtraDataParsers());
-                }
-            }
+        beaconManager.setScannerInSameProcess(true);
+        if (beaconManager.isMainProcess()) {
+            LogManager.i(TAG, "beaconService version %s is starting up on the main process", BuildConfig.VERSION_NAME);
+        }
+        else {
+            LogManager.i(TAG, "beaconService version %s is starting up on a separate process", BuildConfig.VERSION_NAME);
+            ProcessUtils processUtils = new ProcessUtils(this);
+            LogManager.i(TAG, "beaconService PID is "+processUtils.getPid()+" with process name "+processUtils.getProcessName());
         }
 
-        //initialize the extra data beacon tracker
-        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+        reloadParsers();
 
         defaultDistanceCalculator =  new ModelSpecificDistanceCalculator(this, BeaconManager.getDistanceModelUpdateUrl());
         Beacon.setDistanceCalculator(defaultDistanceCalculator);
@@ -235,6 +247,24 @@ public void onCreate() {
         }
     }
 
+    protected void reloadParsers() {
+        HashSet<BeaconParser> newBeaconParsers = new HashSet<BeaconParser>();
+        //flatMap all beacon parsers
+        boolean matchBeaconsByServiceUUID = true;
+        if (beaconManager.getBeaconParsers() != null) {
+            newBeaconParsers.addAll(beaconManager.getBeaconParsers());
+            for (BeaconParser beaconParser : beaconManager.getBeaconParsers()) {
+                if (beaconParser.getExtraDataParsers().size() > 0) {
+                    matchBeaconsByServiceUUID = false;
+                    newBeaconParsers.addAll(beaconParser.getExtraDataParsers());
+                }
+            }
+        }
+        beaconParsers = newBeaconParsers;
+        //initialize the extra data beacon tracker
+        mExtraDataBeaconTracker = new ExtraDataBeaconTracker(matchBeaconsByServiceUUID);
+    }
+
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
@@ -401,7 +431,7 @@ private void processRangeData() {
             for (Region region : rangedRegionState.keySet()) {
                 RangeState rangeState = rangedRegionState.get(region);
                 LogManager.d(TAG, "Calling ranging callback");
-                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region));
+                rangeState.getCallback().call(BeaconService.this, "rangingData", new RangingData(rangeState.finalizeBeacons(), region).toBundle());
             }
         }
     }
@@ -481,6 +511,9 @@ protected Void doInBackground(ScanData... params) {
                 }
             }
             if (beacon != null) {
+                if (LogManager.isVerboseLoggingEnabled()) {
+                    LogManager.d(TAG, "Beacon packet detected for: "+beacon+" with rssi "+beacon.getRssi());
+                }
                 mDetectionTracker.recordDetection();
                 if (!mCycledScanner.getDistinctPacketsDetectedPerScan()) {
                     if (!mDistinctPacketDetector.isPacketDistinct(scanData.device.getAddress(),
diff --git a/src/main/java/org/altbeacon/beacon/service/Callback.java b/src/main/java/org/altbeacon/beacon/service/Callback.java
index 419b47f7..9d239c95 100644
--- a/src/main/java/org/altbeacon/beacon/service/Callback.java
+++ b/src/main/java/org/altbeacon/beacon/service/Callback.java
@@ -26,7 +26,7 @@
 import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
-import android.os.Parcelable;
+import android.os.Bundle;
 
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -35,23 +35,23 @@
 
 public class Callback implements Serializable {
     private static final String TAG = "Callback";
-    private transient Intent intent;
-    private String intentPackageName;
+    private transient Intent mIntent;
+    private String mIntentPackageName;
 
     public Callback(String intentPackageName) {
-        this.intentPackageName = intentPackageName;
+        mIntentPackageName = intentPackageName;
         initializeIntent();
     }
 
     private void initializeIntent() {
-        if (intentPackageName != null) {
-            intent = new Intent();
-            intent.setComponent(new ComponentName(intentPackageName, "org.altbeacon.beacon.BeaconIntentProcessor"));
+        if (mIntentPackageName != null) {
+            mIntent = new Intent();
+            mIntent.setComponent(new ComponentName(mIntentPackageName, "org.altbeacon.beacon.BeaconIntentProcessor"));
         }
     }
 
     public Intent getIntent() {
-        return intent;
+        return mIntent;
     }
 
     /**
@@ -62,21 +62,21 @@ public Intent getIntent() {
      * @param data
      * @return false if it callback cannot be made
      */
-    public boolean call(Context context, String dataName, Parcelable data) {
-        if(intent == null){
+    public boolean call(Context context, String dataName, Bundle data) {
+        if(mIntent == null){
             initializeIntent();
         }
         boolean success = false;
-        if (intent != null) {
-            LogManager.d(TAG, "attempting callback via intent: %s", intent.getComponent());
-            intent.putExtra(dataName, data);
+        if (mIntent != null) {
+            LogManager.d(TAG, "attempting callback via intent: %s", mIntent.getComponent());
+            mIntent.putExtra(dataName, data);
             try {
-                context.startService(intent);
+                context.startService(mIntent);
                 success = true;
             } catch (Exception e) {
                 LogManager.e(
                         TAG,
-                        "Failed attempting to start service: " + intent.getComponent().flattenToString(),
+                        "Failed attempting to start service: " + mIntent.getComponent().flattenToString(),
                         e
                 );
             }
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
index e9523536..74356914 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringData.java
@@ -25,49 +25,42 @@
 
 import org.altbeacon.beacon.Region;
 
-import android.os.Parcel;
-import android.os.Parcelable;
+import android.os.Bundle;
 
-public class MonitoringData implements Parcelable {
+public class MonitoringData {
     @SuppressWarnings("unused")
     private static final String TAG = "MonitoringData";
-    private final boolean inside;
-    private final Region region;
+    private final boolean mInside;
+    private final Region mRegion;
+    private static final String REGION_KEY = "region";
+    private static final String INSIDE_KEY = "inside";
 
     public MonitoringData (boolean inside, Region region) {
-        this.inside = inside;
-        this.region = region;
+        this.mInside = inside;
+        this.mRegion = region;
     }
     public boolean isInside() {
-        return inside;
+        return mInside;
     }
     public Region getRegion() {
-        return region;
+        return mRegion;
     }
 
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeByte((byte) (inside ? 1 : 0));
-        out.writeParcelable(region, flags);
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(REGION_KEY, mRegion);
+        bundle.putBoolean(INSIDE_KEY, mInside);
 
+        return bundle;
     }
-
-    public static final Parcelable.Creator<MonitoringData> CREATOR
-            = new Parcelable.Creator<MonitoringData>() {
-        public MonitoringData createFromParcel(Parcel in) {
-            return new MonitoringData(in);
-        }
-
-        public MonitoringData[] newArray(int size) {
-            return new MonitoringData[size];
+    public static MonitoringData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
         }
-    };
-
-    private MonitoringData(Parcel in) {
-        inside = in.readByte() == 1;
-        region = in.readParcelable(this.getClass().getClassLoader());
+        Boolean inside = bundle.getBoolean(INSIDE_KEY);
+        return new MonitoringData(inside, region);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
index 3185fdc6..164cd3e6 100644
--- a/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
+++ b/src/main/java/org/altbeacon/beacon/service/MonitoringStatus.java
@@ -3,6 +3,7 @@
 import android.content.Context;
 
 import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.MonitorNotifier;
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 
@@ -71,31 +72,12 @@ public MonitoringStatus(Context context) {
     }
 
     public synchronized void addRegion(Region region, Callback callback) {
-        if (getRegionsStateMap().containsKey(region)) {
-            // if the region definition hasn't changed, becasue if it has, we need to clear state
-            // otherwise a region with the same uniqueId can never be changed
-            for (Region existingRegion : getRegionsStateMap().keySet()) {
-                if (existingRegion.equals(region)) {
-                    if (existingRegion.hasSameIdentifiers(region)) {
-                        return;
-                    }
-                    else {
-                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
-                        LogManager.d(TAG, "Old definition: "+existingRegion);
-                        LogManager.d(TAG, "New definition: "+region);
-                        LogManager.d(TAG, "clearing state");
-                        getRegionsStateMap().remove(region);
-                        break;
-                    }
-                }
-            }
-        }
-        getRegionsStateMap().put(region, new RegionMonitoringState(callback));
+        addLocalRegion(region, callback);
         saveMonitoringStatusIfOn();
     }
 
     public synchronized void removeRegion(Region region) {
-        getRegionsStateMap().remove(region);
+        removeLocalRegion(region);
         saveMonitoringStatusIfOn();
     }
 
@@ -120,7 +102,7 @@ public synchronized void updateNewlyOutside() {
             if (state.markOutsideIfExpired()) {
                 needsMonitoringStateSaving = true;
                 LogManager.d(TAG, "found a monitor that expired: %s", region);
-                state.getCallback().call(mContext, "monitoringData", new MonitoringData(state.getInside(), region));
+                state.getCallback().call(mContext, "monitoringData", new MonitoringData(state.getInside(), region).toBundle());
             }
         }
         if (needsMonitoringStateSaving) {
@@ -139,7 +121,7 @@ public synchronized void updateNewlyInsideInRegionsContaining(Beacon beacon) {
             if (state != null && state.markInside()) {
                 needsMonitoringStateSaving = true;
                 state.getCallback().call(mContext, "monitoringData",
-                        new MonitoringData(state.getInside(), region));
+                        new MonitoringData(state.getInside(), region).toBundle());
             }
         }
         if (needsMonitoringStateSaving) {
@@ -291,8 +273,61 @@ public synchronized void startStatusPreservation() {
         }
     }
 
+    public boolean isStatePreservationOn() {
+        return mStatePreservationIsOn;
+    }
+
     public synchronized void clear() {
         mContext.deleteFile(STATUS_PRESERVATION_FILE_NAME);
         getRegionsStateMap().clear();
     }
+
+    public void updateLocalState(Region region, Integer state) {
+        RegionMonitoringState internalState = getRegionsStateMap().get(region);
+        if (internalState == null) {
+            internalState = addLocalRegion(region);
+        }
+        if (state != null) {
+            if (state == MonitorNotifier.OUTSIDE) {
+                internalState.markOutside();
+
+            }
+            if (state == MonitorNotifier.INSIDE) {
+                internalState.markInside();
+            }
+        }
+    }
+
+    public void removeLocalRegion(Region region) {
+        getRegionsStateMap().remove(region);
+    }
+    public RegionMonitoringState addLocalRegion(Region region){
+        Callback dummyCallback = new Callback(null);
+        return addLocalRegion(region, dummyCallback);
+    }
+
+    private RegionMonitoringState addLocalRegion(Region region, Callback callback){
+        if (getRegionsStateMap().containsKey(region)) {
+            // if the region definition hasn't changed, becasue if it has, we need to clear state
+            // otherwise a region with the same uniqueId can never be changed
+            for (Region existingRegion : getRegionsStateMap().keySet()) {
+                if (existingRegion.equals(region)) {
+                    if (existingRegion.hasSameIdentifiers(region)) {
+                        return getRegionsStateMap().get(existingRegion);
+                    }
+                    else {
+                        LogManager.d(TAG, "Replacing region with unique identifier "+region.getUniqueId());
+                        LogManager.d(TAG, "Old definition: "+existingRegion);
+                        LogManager.d(TAG, "New definition: "+region);
+                        LogManager.d(TAG, "clearing state");
+                        getRegionsStateMap().remove(region);
+                        break;
+                    }
+                }
+            }
+        }
+        RegionMonitoringState monitoringState = new RegionMonitoringState(callback);
+        getRegionsStateMap().put(region, monitoringState);
+        return monitoringState;
+    }
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangeState.java b/src/main/java/org/altbeacon/beacon/service/RangeState.java
index a8c1e8d4..0c1ad59e 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangeState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangeState.java
@@ -35,7 +35,7 @@
     private static final String TAG = "RangeState";
     private final Callback mCallback;
     private Map<Beacon,RangedBeacon> mRangedBeacons = new HashMap<Beacon,RangedBeacon>();
-    private static boolean UseTrackingCache = false;
+    private static boolean sUseTrackingCache = false;
 
     public RangeState(Callback c) {
         mCallback = c;
@@ -77,7 +77,7 @@ public void addBeacon(Beacon beacon) {
                 if (!rangedBeacon.noMeasurementsAvailable() == true) {
                     //if TrackingCache is enabled, allow beacon to not receive
                     //measurements for a certain amount of time
-                    if (!UseTrackingCache || rangedBeacon.isExpired())
+                    if (!sUseTrackingCache || rangedBeacon.isExpired())
                         rangedBeacon.setTracked(false);
                     newRangedBeacons.put(beacon, rangedBeacon);
                 }
@@ -92,8 +92,11 @@ public void addBeacon(Beacon beacon) {
     }
 
     public static void setUseTrackingCache(boolean useTrackingCache) {
-        RangeState.UseTrackingCache = useTrackingCache;
+        RangeState.sUseTrackingCache = useTrackingCache;
     }
 
+    public static boolean getUseTrackingCache() {
+        return sUseTrackingCache;
+    }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RangingData.java b/src/main/java/org/altbeacon/beacon/service/RangingData.java
index 2d400787..d7bb44ff 100644
--- a/src/main/java/org/altbeacon/beacon/service/RangingData.java
+++ b/src/main/java/org/altbeacon/beacon/service/RangingData.java
@@ -23,62 +23,63 @@
  */
 package org.altbeacon.beacon.service;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collection;
 
 import org.altbeacon.beacon.Beacon;
-import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Region;
-import org.altbeacon.beacon.logging.LogManager;
 
-import android.os.Parcel;
-import android.os.Parcelable;
+import android.os.Bundle;
 
-public class RangingData implements Parcelable {
+/**
+ * Internal class used to transfer ranging data between the BeaconService and the client
+ * @hide
+ */
+public class RangingData {
     private static final String TAG = "RangingData";
-    private final Collection<Beacon> beacons;
-    private final Region region;
+    private final Collection<Beacon> mBeacons;
+    private final Region mRegion;
+    private static final String REGION_KEY = "region";
+    private static final String BEACONS_KEY = "beacons";
 
     public RangingData (Collection<Beacon> beacons, Region region) {
         synchronized (beacons) {
-            this.beacons =  beacons;
+            this.mBeacons =  beacons;
         }
-        this.region = region;
+        this.mRegion = region;
     }
 
     public Collection<Beacon> getBeacons() {
-        return beacons;
+        return mBeacons;
     }
     public Region getRegion() {
-        return region;
-    }
-
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-    public void writeToParcel(Parcel out, int flags) {
-        out.writeParcelableArray(beacons.toArray(new Parcelable[0]), flags);
-        out.writeParcelable(region, flags);
+        return mRegion;
     }
 
-    public static final Parcelable.Creator<RangingData> CREATOR
-            = new Parcelable.Creator<RangingData>() {
-        public RangingData createFromParcel(Parcel in) {
-            return new RangingData(in);
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(REGION_KEY, mRegion);
+        ArrayList<Serializable> serializableBeacons = new ArrayList<Serializable>();
+        for (Beacon beacon : mBeacons) {
+            serializableBeacons.add(beacon);
         }
+        bundle.putSerializable(BEACONS_KEY, serializableBeacons);
 
-        public RangingData[] newArray(int size) {
-            return new RangingData[size];
+        return bundle;
+    }
+    public static RangingData fromBundle(Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        Region region = null;
+        Collection<Beacon> beacons = null;
+        if (bundle.get(BEACONS_KEY) != null) {
+            beacons = (Collection<Beacon>) bundle.getSerializable(BEACONS_KEY);
         }
-    };
-
-    protected RangingData(Parcel in) {
-        Parcelable[] parcelables  = in.readParcelableArray(this.getClass().getClassLoader());
-        beacons = new ArrayList<Beacon>(parcelables.length);
-        for (int i = 0; i < parcelables.length; i++) {
-            beacons.add((Beacon)parcelables[i]);
+        if (bundle.get(REGION_KEY) != null) {
+            region = (Region) bundle.getSerializable(REGION_KEY);
         }
-        region = in.readParcelable(this.getClass().getClassLoader());
+
+        return new RangingData(beacons, region);
     }
+
 }
diff --git a/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java b/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
index 0f9cd1ee..d7b36fb3 100644
--- a/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
+++ b/src/main/java/org/altbeacon/beacon/service/RegionMonitoringState.java
@@ -54,15 +54,19 @@ public boolean markInside() {
         return false;
     }
 
+    public void markOutside() {
+        inside = false;
+        lastSeenTime = 0l;
+    }
+
     public boolean markOutsideIfExpired() {
         if (inside) {
             if (lastSeenTime > 0 && SystemClock.elapsedRealtime() - lastSeenTime > BeaconManager.getRegionExitPeriod()) {
-                inside = false;
                 LogManager.d(TAG, "We are newly outside the region because the lastSeenTime of %s "
                                 + "was %s seconds ago, and that is over the expiration duration "
                                 + "of %s", lastSeenTime, SystemClock.elapsedRealtime() - lastSeenTime,
                         BeaconManager.getRegionExitPeriod());
-                lastSeenTime = 0l;
+                markOutside();
                 return true;
             }
         }
diff --git a/src/main/java/org/altbeacon/beacon/service/SettingsData.java b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
new file mode 100644
index 00000000..d1202336
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/service/SettingsData.java
@@ -0,0 +1,108 @@
+package org.altbeacon.beacon.service;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+
+import org.altbeacon.beacon.Beacon;
+import org.altbeacon.beacon.BeaconManager;
+import org.altbeacon.beacon.BeaconParser;
+import org.altbeacon.beacon.Region;
+import org.altbeacon.beacon.logging.LogManager;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Created by dyoung on 3/10/17.
+ *
+ * Internal class used to transfer settings between the BeaconService and the client
+ *
+ * @hide
+ */
+public class SettingsData implements Serializable {
+    private static final String TAG = SettingsData.class.getSimpleName();
+    private static final String SETTINGS_DATA_KEY = "SettingsData";
+    ArrayList<BeaconParser> mBeaconParsers;
+    Boolean mRegionStatePersistenceEnabled;
+    Boolean mAndroidLScanningDisabled;
+    Long mRegionExitPeriod;
+    Boolean mUseTrackingCache;
+    Boolean mHardwareEqualityEnforced;
+
+    // The following configuration settings are not implemented here, so they cannot be set when
+    // the scanning service is running in another process
+    //        BeaconManager.setDistanceModelUpdateUrl(...)
+    //        BeaconManager.setRssiFilterImplClass(...)
+    //        BeaconManager.setBeaconSimulator(...)
+    //        beaconManager.setNonBeaconLeScanCallback(...)
+
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putSerializable(SETTINGS_DATA_KEY, this);
+        return bundle;
+    }
+    public static SettingsData fromBundle(@NonNull Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        SettingsData settingsData = null;
+        if (bundle.get(SETTINGS_DATA_KEY) != null) {
+            settingsData = (SettingsData) bundle.getSerializable(SETTINGS_DATA_KEY);
+        }
+        return settingsData;
+    }
+
+    public void apply(@NonNull BeaconService scanService) {
+        LogManager.d(TAG, "Applying settings changes to scanner in other process");
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(scanService);
+        List<BeaconParser> beaconParsers = beaconManager.getBeaconParsers();
+        boolean beaconParsersChanged = false;
+        if (beaconParsers.size() == mBeaconParsers.size()) {
+            for (int i = 0; i < beaconParsers.size(); i++) {
+                if (!beaconParsers.get(i).equals(mBeaconParsers.get(i))) {
+                    LogManager.d(TAG, "Beacon parsers have changed to: "+mBeaconParsers.get(i).getLayout());
+                    beaconParsersChanged = true;
+                    break;
+                }
+            }
+        }
+        else {
+            beaconParsersChanged = true;
+            LogManager.d(TAG, "Beacon parsers have been added or removed.");
+        }
+        if (beaconParsersChanged) {
+            LogManager.d(TAG, "Updating beacon parsers");
+            beaconManager.getBeaconParsers().clear();
+            beaconManager.getBeaconParsers().addAll(mBeaconParsers);
+            scanService.reloadParsers();
+        }
+        else {
+            LogManager.d(TAG, "Beacon parsers unchanged.");
+        }
+        MonitoringStatus monitoringStatus = MonitoringStatus.getInstanceForApplication(scanService);
+        if (monitoringStatus.isStatePreservationOn() &&
+                !mRegionStatePersistenceEnabled) {
+            monitoringStatus.stopStatusPreservation();
+        }
+        else if (!monitoringStatus.isStatePreservationOn() &&
+                mRegionStatePersistenceEnabled) {
+            monitoringStatus.startStatusPreservation();
+        }
+        beaconManager.setAndroidLScanningDisabled(mAndroidLScanningDisabled);
+        BeaconManager.setRegionExitPeriod(mRegionExitPeriod);
+        RangeState.setUseTrackingCache(mUseTrackingCache);
+        Beacon.setHardwareEqualityEnforced(mHardwareEqualityEnforced);
+    }
+
+    public SettingsData collect(@NonNull Context context) {
+        BeaconManager beaconManager = BeaconManager.getInstanceForApplication(context);
+        mBeaconParsers = new ArrayList<>(beaconManager.getBeaconParsers());
+        mRegionStatePersistenceEnabled = beaconManager.isRegionStatePersistenceEnabled();
+        mAndroidLScanningDisabled = beaconManager.isAndroidLScanningDisabled();
+        mRegionExitPeriod = BeaconManager.getRegionExitPeriod();
+        mUseTrackingCache = RangeState.getUseTrackingCache();
+        mHardwareEqualityEnforced = Beacon.getHardwareEqualityEnforced();
+        return this;
+    }
+
+}
diff --git a/src/main/java/org/altbeacon/beacon/service/StartRMData.java b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
index c91e4070..1fa8a6d6 100644
--- a/src/main/java/org/altbeacon/beacon/service/StartRMData.java
+++ b/src/main/java/org/altbeacon/beacon/service/StartRMData.java
@@ -23,58 +23,75 @@
  */
 package org.altbeacon.beacon.service;
 
+import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.support.annotation.NonNull;
 
 import org.altbeacon.beacon.Region;
 
 import java.io.Serializable;
 
+/**
+ *
+ * Internal class used to transfer ranging and monitoring data between the BeaconService and client
+ *
+ * @hide
+ */
 public class StartRMData implements Serializable, Parcelable {
-    private Region region;
-    private long scanPeriod;
-    private long betweenScanPeriod;
-    private boolean backgroundFlag;
-    private String callbackPackageName;
-
-    public StartRMData(Region region, String callbackPackageName) {
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
+    private static final String SCAN_PERIOD_KEY = "scanPeriod";
+    private static final String BETWEEN_SCAN_PERIOD_KEY = "betweenScanPeriod";
+    private static final String BACKGROUND_FLAG_KEY = "backgroundFlag";
+    private static final String CALLBACK_PACKAGE_NAME_KEY = "callbackPackageName";
+    private static final String REGION_KEY = "region";
+
+    private Region mRegion;
+    private long mScanPeriod;
+    private long mBetweenScanPeriod;
+    private boolean mBackgroundFlag;
+    private String mCallbackPackageName;
+
+    private StartRMData() {
+    }
+
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName) {
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
     }
     public StartRMData(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.backgroundFlag = backgroundFlag;
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mBackgroundFlag = backgroundFlag;
     }
 
-    public StartRMData(Region region, String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
-        this.scanPeriod = scanPeriod;
-        this.betweenScanPeriod = betweenScanPeriod;
-        this.region = region;
-        this.callbackPackageName = callbackPackageName;
-        this.backgroundFlag = backgroundFlag;
+    public StartRMData(@NonNull Region region, @NonNull String callbackPackageName, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
+        this.mScanPeriod = scanPeriod;
+        this.mBetweenScanPeriod = betweenScanPeriod;
+        this.mRegion = region;
+        this.mCallbackPackageName = callbackPackageName;
+        this.mBackgroundFlag = backgroundFlag;
     }
 
 
-    public long getScanPeriod() { return scanPeriod; }
-    public long getBetweenScanPeriod() { return betweenScanPeriod; }
+    public long getScanPeriod() { return mScanPeriod; }
+    public long getBetweenScanPeriod() { return mBetweenScanPeriod; }
     public Region getRegionData() {
-        return region;
+        return mRegion;
     }
     public String getCallbackPackageName() {
-        return callbackPackageName;
+        return mCallbackPackageName;
     }
-    public boolean getBackgroundFlag() { return backgroundFlag; }
+    public boolean getBackgroundFlag() { return mBackgroundFlag; }
     public int describeContents() {
         return 0;
     }
 
     public void writeToParcel(Parcel out, int flags) {
-        out.writeParcelable(region, flags);
-        out.writeString(callbackPackageName);
-        out.writeLong(scanPeriod);
-        out.writeLong(betweenScanPeriod);
-        out.writeByte((byte) (backgroundFlag ? 1 : 0));
+        out.writeParcelable(mRegion, flags);
+        out.writeString(mCallbackPackageName);
+        out.writeLong(mScanPeriod);
+        out.writeLong(mBetweenScanPeriod);
+        out.writeByte((byte) (mBackgroundFlag ? 1 : 0));
     }
 
     public static final Parcelable.Creator<StartRMData> CREATOR
@@ -89,11 +106,52 @@ public StartRMData createFromParcel(Parcel in) {
     };
 
     private StartRMData(Parcel in) {
-        region = in.readParcelable(StartRMData.class.getClassLoader());
-        callbackPackageName = in.readString();
-        scanPeriod = in.readLong();
-        betweenScanPeriod = in.readLong();
-        backgroundFlag = in.readByte() != 0;
+        mRegion = in.readParcelable(StartRMData.class.getClassLoader());
+        mCallbackPackageName = in.readString();
+        mScanPeriod = in.readLong();
+        mBetweenScanPeriod = in.readLong();
+        mBackgroundFlag = in.readByte() != 0;
+    }
+
+    public Bundle toBundle() {
+        Bundle bundle = new Bundle();
+        bundle.putLong(SCAN_PERIOD_KEY, this.mScanPeriod);
+        bundle.putLong(BETWEEN_SCAN_PERIOD_KEY, this.mBetweenScanPeriod);
+        bundle.putBoolean(BACKGROUND_FLAG_KEY, this.mBackgroundFlag);
+        bundle.putString(CALLBACK_PACKAGE_NAME_KEY, this.mCallbackPackageName);
+        if (mRegion != null) {
+            bundle.putSerializable(REGION_KEY, mRegion);
+        }
+        return bundle;
+    }
+
+    public static StartRMData fromBundle(@NonNull Bundle bundle) {
+        bundle.setClassLoader(Region.class.getClassLoader());
+        boolean valid = false;
+        StartRMData data = new StartRMData();
+        if (bundle.containsKey(REGION_KEY)) {
+            data.mRegion = (Region)bundle.getSerializable(REGION_KEY);
+            valid = true;
+        }
+        if (bundle.containsKey(SCAN_PERIOD_KEY)) {
+            data.mScanPeriod = (Long) bundle.get(SCAN_PERIOD_KEY);
+            valid = true;
+        }
+        if (bundle.containsKey(BETWEEN_SCAN_PERIOD_KEY)) {
+            data.mBetweenScanPeriod = (Long) bundle.get(BETWEEN_SCAN_PERIOD_KEY);
+        }
+        if (bundle.containsKey(BACKGROUND_FLAG_KEY)) {
+            data.mBackgroundFlag = (Boolean) bundle.get(BACKGROUND_FLAG_KEY);
+        }
+        if (bundle.containsKey(CALLBACK_PACKAGE_NAME_KEY)) {
+            data.mCallbackPackageName = (String) bundle.get(CALLBACK_PACKAGE_NAME_KEY);
+        }
+        if (valid) {
+            return data;
+        }
+        else {
+            return null;
+        }
     }
 
 }
diff --git a/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
new file mode 100644
index 00000000..f0ffb0d7
--- /dev/null
+++ b/src/main/java/org/altbeacon/beacon/utils/ProcessUtils.java
@@ -0,0 +1,42 @@
+package org.altbeacon.beacon.utils;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.support.annotation.NonNull;
+
+/**
+ * Created by dyoung on 3/10/17.
+ *
+ * Internal class used to determine current process state in multi-process setups
+ * @hide
+ */
+
+public class ProcessUtils {
+    Context mContext;
+
+    public ProcessUtils(@NonNull Context context) {
+        mContext = context;
+    }
+
+    public String getProcessName() {
+        ActivityManager manager = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        for (ActivityManager.RunningAppProcessInfo processInfo : manager.getRunningAppProcesses()) {
+            if (processInfo.pid == getPid()) {
+                return  processInfo.processName;
+            }
+        }
+        return null;
+    }
+
+    public String getPackageName() {
+        return mContext.getApplicationContext().getPackageName();
+    }
+
+    public int getPid() {
+        return android.os.Process.myPid();
+    }
+
+    public boolean isMainProcess() {
+        return (getPackageName().equals(getProcessName()));
+    }
+}
diff --git a/src/test/java/org/altbeacon/beacon/BeaconTest.java b/src/test/java/org/altbeacon/beacon/BeaconTest.java
index e31e6f54..d95fb0e7 100644
--- a/src/test/java/org/altbeacon/beacon/BeaconTest.java
+++ b/src/test/java/org/altbeacon/beacon/BeaconTest.java
@@ -1,7 +1,5 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
 import org.altbeacon.beacon.distance.ModelSpecificDistanceCalculator;
 import org.junit.Before;
 import org.junit.Test;
@@ -16,6 +14,12 @@
 import java.util.Arrays;
 import java.util.List;
 
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -160,15 +164,13 @@ public void testCalculateAccuracyWithRssiEqualsPowerOnInternalPropertiesAndRunni
 
 
     @Test
-    public void testCanSerializeParcelable() {
+    public void testCanSerialize() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Beacon beacon = new AltBeacon.Builder().setId1("1").setId2("2").setId3("3").setRssi(4)
                 .setBeaconTypeCode(5).setTxPower(6).setBluetoothName("xx")
                 .setBluetoothAddress("1:2:3:4:5:6").setDataFields(Arrays.asList(100l)).build();
-        beacon.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Beacon beacon2 = new Beacon(parcel);
+        byte[] serializedBeacon = convertToBytes(beacon);
+        Beacon beacon2 = (Beacon) convertFromBytes(serializedBeacon);
         assertEquals("Right number of identifiers after deserialization", 3, beacon2.mIdentifiers.size());
         assertEquals("id1 is same after deserialization", beacon.getIdentifier(0), beacon2.getIdentifier(0));
         assertEquals("id2 is same after deserialization", beacon.getIdentifier(1), beacon2.getIdentifier(1));
@@ -204,4 +206,20 @@ public void testHashCodeWithNullIdentifier() {
                 .build();
         assertTrue("hashCode() should not throw exception", beacon.hashCode() >= Integer.MIN_VALUE);
     }
+    // utilty methods for testing serialization
+
+    private byte[] convertToBytes(Object object) throws IOException {
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(object);
+            return bos.toByteArray();
+        }
+    }
+    private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+             ObjectInputStream in = new ObjectInputStream(bis)) {
+            return in.readObject();
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/java/org/altbeacon/beacon/RegionTest.java b/src/test/java/org/altbeacon/beacon/RegionTest.java
index b57d3503..05ba5952 100644
--- a/src/test/java/org/altbeacon/beacon/RegionTest.java
+++ b/src/test/java/org/altbeacon/beacon/RegionTest.java
@@ -1,7 +1,5 @@
 package org.altbeacon.beacon;
 
-import android.os.Parcel;
-
 import static android.test.MoreAsserts.assertNotEqual;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -17,6 +15,12 @@
 import java.util.ArrayList;
 import java.util.Collections;
 
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+
 @Config(sdk = 18)
 
 @RunWith(RobolectricTestRunner.class)
@@ -128,14 +132,11 @@ public void testBeaconMatchesRegionWithSameBluetoothMacAndIdentifiers() {
 
 
     @Test
-    public void testCanSerializeParcelable() {
+    public void testCanSerialize() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Region region = new Region("myRegion", Identifier.parse("1"), Identifier.parse("2"), null);
-        region.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Region region2 = new Region(parcel);
-        parcel.recycle();
+        byte[] serializedRegion = convertToBytes(region);
+        Region region2 = (Region) convertFromBytes(serializedRegion);
         assertEquals("Right number of identifiers after deserialization", 3, region2.mIdentifiers.size());
         assertEquals("uniqueId is same after deserialization", region.getUniqueId(), region2.getUniqueId());
         assertEquals("id1 is same after deserialization", region.getIdentifier(0), region2.getIdentifier(0));
@@ -145,14 +146,11 @@ public void testCanSerializeParcelable() {
     }
 
     @Test
-    public void testCanSerializeParcelableWithMac() {
+    public void testCanSerializeWithMac() throws Exception {
         org.robolectric.shadows.ShadowLog.stream = System.err;
-        Parcel parcel = Parcel.obtain();
         Region region = new Region("myRegion", "1B:2a:03:4C:6E:9F");
-        region.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        Region region2 = new Region(parcel);
-        parcel.recycle();
+        byte[] serializedRegion = convertToBytes(region);
+        Region region2 = (Region) convertFromBytes(serializedRegion);
         assertEquals("Right number of identifiers after deserialization", 0, region2.mIdentifiers.size());
         assertEquals("ac is same after deserialization", region.getBluetoothAddress(), region2.getBluetoothAddress());
     }
@@ -186,5 +184,21 @@ public void testConvenienceIdentifierAccessors() {
         assertEquals("3", region.getId3().toString());
     }
 
+    // utilty methods for testing serialization
+
+    private byte[] convertToBytes(Object object) throws IOException {
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+             ObjectOutputStream out = new ObjectOutputStream(bos)) {
+            out.writeObject(object);
+            return bos.toByteArray();
+        }
+    }
+    private Object convertFromBytes(byte[] bytes) throws IOException, ClassNotFoundException {
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+             ObjectInputStream in = new ObjectInputStream(bis)) {
+            return in.readObject();
+        }
+    }
+
 
 }
diff --git a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
index 3042a904..403cd955 100644
--- a/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
+++ b/src/test/java/org/altbeacon/beacon/service/RangingDataTest.java
@@ -1,9 +1,6 @@
 package org.altbeacon.beacon.service;
 
-import android.annotation.TargetApi;
 import android.content.Context;
-import android.os.AsyncTask;
-import android.os.Build;
 
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.Identifier;
@@ -11,23 +8,16 @@
 import org.altbeacon.beacon.Region;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
-import org.altbeacon.beacon.service.scanner.CycledLeScanCallback;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
-import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
 import org.robolectric.annotation.Config;
 import org.robolectric.shadows.ShadowApplication;
-import org.robolectric.util.ServiceController;
 
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.concurrent.ThreadPoolExecutor;
 
-import android.os.Parcel;
 import android.os.Bundle;
-import org.altbeacon.beacon.service.RangingData;
 
 import static org.junit.Assert.assertEquals;
 
@@ -51,15 +41,13 @@ public void testSerialization() throws Exception {
         identifiers.add(Identifier.parse("2"));
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
-        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
         for (int i=0; i < 10; i++) {
             beacons.add(beacon);
         }
         RangingData data = new RangingData(beacons, region);
-        Parcel parcel = Parcel.obtain();
-        data.writeToParcel(parcel, 0);
-        parcel.setDataPosition(0);
-        RangingData data2 = new RangingData(parcel);
+        Bundle bundle = data.toBundle();
+        RangingData data2 = RangingData.fromBundle(bundle);
         assertEquals("beacon count shouild be restored", 10, data2.getBeacons().size());
         assertEquals("beacon identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getBeacons().iterator().next().getId1().toString());
         assertEquals("region identifier 1 shouild be restored", "2f234454-cf6d-4a0f-adf2-f4911ba9ffa6", data2.getRegion().getId1().toString());
@@ -75,20 +63,18 @@ public void testSerializationBenchmark() throws Exception {
         identifiers.add(Identifier.parse("2"));
         Region region = new Region("testRegion", identifiers);
         ArrayList<Beacon> beacons = new ArrayList<Beacon>();
-        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
+        Beacon beacon = new Beacon.Builder().setIdentifiers(identifiers).setRssi(-1).setRunningAverageRssi(-2).setTxPower(-50).setBluetoothAddress("01:02:03:04:05:06").build();
         for (int i=0; i < 10; i++) {
             beacons.add(beacon);
         }
         RangingData data = new RangingData(beacons, region);
         long time1 = System.currentTimeMillis();
         for (int i=0; i< 10000; i++) {
-            Parcel parcel = Parcel.obtain();
-            data.writeToParcel(parcel, 0);
-            parcel.setDataPosition(0);
-            RangingData data2 = new RangingData(parcel);
+            Bundle bundle = data.toBundle();
+            RangingData data2 = RangingData.fromBundle(bundle);
         }
         long time2 = System.currentTimeMillis();
         System.out.println("*** Ranging Data Serialization benchmark: "+(time2-time1));
     }
 
-}
\ No newline at end of file
+}
