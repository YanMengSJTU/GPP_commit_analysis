diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index 8becf432..f4f6654d 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -3,7 +3,7 @@
  * http://www.radiusnetworks.com
  *
  * @author David G. Young
- *
+ * <p>
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -11,9 +11,9 @@
  * to you under the Apache License, Version 2.0 (the
  * "License"); you may not use this file except in compliance
  * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p>
  * Unless required by applicable law or agreed to in writing,
  * software distributed under the License is distributed on an
  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@@ -39,6 +39,18 @@
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
+
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.logging.Loggers;
 import org.altbeacon.beacon.service.BeaconService;
@@ -48,39 +60,22 @@
 import org.altbeacon.beacon.service.RangedBeacon;
 import org.altbeacon.beacon.service.RegionMonitoringState;
 import org.altbeacon.beacon.service.RunningAverageRssiFilter;
-import org.altbeacon.beacon.service.ScanJob;
 import org.altbeacon.beacon.service.ScanJobScheduler;
-import org.altbeacon.beacon.service.ScanState;
 import org.altbeacon.beacon.service.SettingsData;
 import org.altbeacon.beacon.service.StartRMData;
 import org.altbeacon.beacon.service.scanner.NonBeaconLeScanCallback;
 import org.altbeacon.beacon.simulator.BeaconSimulator;
 import org.altbeacon.beacon.utils.ProcessUtils;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.CopyOnWriteArraySet;
-
-import org.altbeacon.beacon.service.ScanJob;
-import org.altbeacon.beacon.service.ScanState;
-
 /**
  * A class used to set up interaction with beacons from an <code>Activity</code> or <code>Service</code>.
  * This class is used in conjunction with <code>BeaconConsumer</code> interface, which provides a callback
  * when the <code>BeaconService</code> is ready to use.  Until this callback is made, ranging and monitoring
  * of beacons is not possible.
- *
+ * <p>
  * In the example below, an Activity implements the <code>BeaconConsumer</code> interface, binds
  * to the service, then when it gets the callback saying the service is ready, it starts ranging.
- *
+ * <p>
  * <pre><code>
  *  public class RangingActivity extends Activity implements BeaconConsumer {
  *      protected static final String TAG = "RangingActivity";
@@ -266,20 +261,20 @@ public void setBackgroundBetweenScanPeriod(long p) {
      *
      * @param regionExitPeriod
      */
-    public static void setRegionExitPeriod(long regionExitPeriod){
+    public static void setRegionExitPeriod(long regionExitPeriod) {
         sExitRegionPeriod = regionExitPeriod;
         BeaconManager instance = sInstance;
         if (instance != null) {
             instance.applySettings();
         }
     }
-    
+
     /**
      * Get region exit milliseconds
      *
      * @return exit region period in milliseconds
      */
-    public static long getRegionExitPeriod(){
+    public static long getRegionExitPeriod() {
         return sExitRegionPeriod;
     }
 
@@ -318,8 +313,8 @@ protected BeaconManager(@NonNull Context context) {
         mContext = context.getApplicationContext();
         checkIfMainProcess();
         if (!sManifestCheckingDisabled) {
-           verifyServiceDeclaration();
-         }
+            verifyServiceDeclaration();
+        }
         this.beaconParsers.add(new AltBeaconParser());
         mScheduledScanJobsEnabled = android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.O;
     }
@@ -335,7 +330,6 @@ public boolean isMainProcess() {
     }
 
     /**
-     * 
      * Determines if this BeaconManager instance is not part of the process hosting the beacon scanning
      * service.  This is normally false, except when scanning is hosted in a different process.
      * This will always return false until the scanning service starts up, at which time it will be
@@ -350,6 +344,7 @@ public boolean isScannerInDifferentProcess() {
 
     /**
      * Reserved for internal use by the library.
+     *
      * @hide
      */
     public void setScannerInSameProcess(boolean isScanner) {
@@ -362,15 +357,17 @@ protected void checkIfMainProcess() {
         String packageName = processUtils.getPackageName();
         int pid = processUtils.getPid();
         mMainProcess = processUtils.isMainProcess();
-        LogManager.i(TAG, "BeaconManager started up on pid "+pid+" named '"+processName+"' for application package '"+packageName+"'.  isMainProcess="+mMainProcess);
+        LogManager.i(TAG,
+                     "BeaconManager started up on pid " + pid + " named '" + processName + "' for application package '"
+                     + packageName + "'.  isMainProcess=" + mMainProcess);
     }
 
-   /**
+    /**
      * Gets a list of the active beaconParsers.
      *
      * @return list of active BeaconParsers
      */
-   @NonNull
+    @NonNull
     public List<BeaconParser> getBeaconParsers() {
         return beaconParsers;
     }
@@ -410,14 +407,12 @@ public void bind(@NonNull BeaconConsumer consumer) {
             ConsumerInfo alreadyBoundConsumerInfo = consumers.putIfAbsent(consumer, newConsumerInfo);
             if (alreadyBoundConsumerInfo != null) {
                 LogManager.d(TAG, "This consumer is already bound");
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "This consumer is not bound.  Binding now: %s", consumer);
                 if (mScheduledScanJobsEnabled) {
                     LogManager.d(TAG, "Not starting beacon scanning service. Using scheduled jobs");
                     consumer.onBeaconServiceConnect();
-                }
-                else {
+                } else {
                     LogManager.d(TAG, "Binding to service");
                     Intent intent = new Intent(consumer.getApplicationContext(), BeaconService.class);
                     consumer.bindService(intent, newConsumerInfo.beaconServiceConnection, Context.BIND_AUTO_CREATE);
@@ -443,8 +438,7 @@ public void unbind(@NonNull BeaconConsumer consumer) {
                 LogManager.d(TAG, "Unbinding");
                 if (mScheduledScanJobsEnabled) {
                     LogManager.d(TAG, "Not unbinding from scanning service as we are using scan jobs.");
-                }
-                else {
+                } else {
                     consumer.unbindService(consumers.get(consumer).beaconServiceConnection);
                 }
                 consumers.remove(consumer);
@@ -462,8 +456,7 @@ public void unbind(@NonNull BeaconConsumer consumer) {
                         // a consumer is bound.
                     }
                 }
-            }
-            else {
+            } else {
                 LogManager.d(TAG, "This consumer is not bound to: %s", consumer);
                 LogManager.d(TAG, "Bound consumers: ");
                 Set<Map.Entry<BeaconConsumer, ConsumerInfo>> consumers = this.consumers.entrySet();
@@ -481,7 +474,7 @@ public void unbind(@NonNull BeaconConsumer consumer) {
      * @return
      */
     public boolean isBound(@NonNull BeaconConsumer consumer) {
-        synchronized(consumers) {
+        synchronized (consumers) {
             // Annotation doesn't guarantee we get a non-null, but raising an NPE here is excessive
             //noinspection ConstantConditions
             return consumer != null && consumers.get(consumer) != null && (serviceMessenger != null);
@@ -494,7 +487,7 @@ public boolean isBound(@NonNull BeaconConsumer consumer) {
      * @return
      */
     public boolean isAnyConsumerBound() {
-        synchronized(consumers) {
+        synchronized (consumers) {
             return consumers.isEmpty() && (serviceMessenger != null);
         }
     }
@@ -537,15 +530,15 @@ public void setBackgroundMode(boolean backgroundMode) {
     /**
      * Configures using a `ScanJob` run with the `JobScheduler` to perform scans rather than using a
      * long-running `BeaconService` to do so.
-     *
+     * <p>
      * Calling with true on devices older than Android L (5.0) will not apply the change
      * as the JobScheduler is not available.
-     *
+     * <p>
      * This value defaults to true on Android O+ and false on devices with older OS versions.
      * Accepting the default value of false is recommended on Android N and earlier because
      * otherwise beacon scans may be run only once every 15 minutes in the background, and no low
      * power scans may be performed between scanning cycles.
-     *
+     * <p>
      * This method may only be called if bind() has not yet been called, otherwise an
      * `IllegalStateException` is thown.
      *
@@ -554,31 +547,37 @@ public void setBackgroundMode(boolean backgroundMode) {
     public void setEnableScheduledScanJobs(boolean enabled) {
         if (isAnyConsumerBound()) {
             LogManager.e(TAG, "ScanJob may not be configured because a consumer is" +
-                    " already bound.");
+                              " already bound.");
             throw new IllegalStateException("Method must be called before calling bind()");
         }
         if (enabled && android.os.Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
             LogManager.e(TAG, "ScanJob may not be configured because JobScheduler is not" +
-                    " availble prior to Android 5.0");
+                              " availble prior to Android 5.0");
             return;
         }
         mScheduledScanJobsEnabled = enabled;
     }
+
     public boolean getScheduledScanJobsEnabled() {
         return mScheduledScanJobsEnabled;
     }
+
     public boolean getBackgroundMode() {
         return mBackgroundMode;
     }
+
     public long getBackgroundScanPeriod() {
         return backgroundScanPeriod;
     }
+
     public long getBackgroundBetweenScanPeriod() {
         return backgroundBetweenScanPeriod;
     }
+
     public long getForegroundScanPeriod() {
         return foregroundScanPeriod;
     }
+
     public long getForegroundBetweenScanPeriod() {
         return foregroundBetweenScanPeriod;
     }
@@ -760,6 +759,7 @@ public void setRegionStatePersistenceEnabled(boolean enabled) {
 
     /**
      * Indicates whether region state preservation is enabled
+     *
      * @return
      */
     public boolean isRegionStatePersistenceEnabled() {
@@ -770,6 +770,7 @@ public boolean isRegionStatePersistenceEnabled() {
      * Requests the current in/out state on the specified region. If the region is being monitored,
      * this will cause an asynchronous callback on the `MonitorNotifier`'s `didDetermineStateForRegion`
      * method.  If it is not a monitored region, it will be ignored.
+     *
      * @param region
      */
     public void requestStateForRegion(@NonNull Region region) {
@@ -848,6 +849,7 @@ public void stopRangingBeaconsInRegion(@NonNull Region region) throws RemoteExce
     /**
      * Call this method if you are running the scanner service in a different process in order to
      * synchronize any configuration settings, including BeaconParsers to the scanner
+     *
      * @see #isScannerInDifferentProcess()
      */
     public void applySettings() {
@@ -866,7 +868,7 @@ public void applySettings() {
 
     protected void syncSettingsToService() {
         if (mScheduledScanJobsEnabled) {
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this, false);
             return;
         }
         try {
@@ -959,21 +961,23 @@ public void updateScanPeriods() throws RemoteException {
     @TargetApi(18)
     private void applyChangesToServices(int type, Region region) throws RemoteException {
         if (mScheduledScanJobsEnabled) {
-            ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
+            ScanJobScheduler.getInstance()
+                    .applySettingsToScheduledJob(mContext, this, type == BeaconService.MSG_STOP_RANGING);
             // return;
         }
         if (serviceMessenger == null) {
-            throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
+            throw new RemoteException(
+                    "The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
         }
         Message msg = Message.obtain(null, type, 0, 0);
         if (type == BeaconService.MSG_SET_SCAN_PERIODS) {
-            msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode).toBundle());
-        }
-        else if (type == BeaconService.MSG_SYNC_SETTINGS) {
+            msg.setData(new StartRMData(this.getScanPeriod(), this.getBetweenScanPeriod(), this.mBackgroundMode)
+                                .toBundle());
+        } else if (type == BeaconService.MSG_SYNC_SETTINGS) {
             msg.setData(new SettingsData().collect(mContext).toBundle());
-        }
-        else {
-            msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(), mBackgroundMode).toBundle());
+        } else {
+            msg.setData(new StartRMData(region, callbackPackageName(), getScanPeriod(), getBetweenScanPeriod(),
+                                        mBackgroundMode).toBundle());
         }
         serviceMessenger.send(msg);
     }
@@ -1014,7 +1018,7 @@ public MonitorNotifier getMonitoringNotifier() {
      * @see Collections#unmodifiableSet(Set)
      */
     @NonNull
-    public Set<MonitorNotifier> getMonitoringNotifiers(){
+    public Set<MonitorNotifier> getMonitoringNotifiers() {
         return Collections.unmodifiableSet(monitorNotifiers);
     }
 
@@ -1065,7 +1069,7 @@ public RangeNotifier getRangingNotifier() {
      */
     @NonNull
     public Collection<Region> getRangedRegions() {
-        synchronized(this.rangedRegions) {
+        synchronized (this.rangedRegions) {
             return new ArrayList<>(this.rangedRegions);
         }
     }
@@ -1128,6 +1132,7 @@ public static Class getRssiFilterImplClass() {
 
     /**
      * Allow the library to use a tracking cache
+     *
      * @param useTrackingCache
      */
     public static void setUseTrackingCache(boolean useTrackingCache) {
@@ -1140,6 +1145,7 @@ public static void setUseTrackingCache(boolean useTrackingCache) {
     /**
      * Set the period of time, in which a beacon did not receive new
      * measurements
+     *
      * @param maxTrackingAge in milliseconds
      */
     public void setMaxTrackingAge(int maxTrackingAge) {
@@ -1156,7 +1162,6 @@ public static BeaconSimulator getBeaconSimulator() {
         return BeaconManager.beaconSimulator;
     }
 
-
     protected void setDataRequestNotifier(@Nullable RangeNotifier notifier) {
         this.dataRequestNotifier = notifier;
     }
@@ -1208,7 +1213,7 @@ private void verifyServiceDeclaration() {
         final Intent intent = new Intent(mContext, BeaconService.class);
         List<ResolveInfo> resolveInfo =
                 packageManager.queryIntentServices(intent,
-                        PackageManager.MATCH_DEFAULT_ONLY);
+                                                   PackageManager.MATCH_DEFAULT_ONLY);
         if (resolveInfo != null && resolveInfo.isEmpty()) {
             throw new ServiceNotDeclaredException();
         }
@@ -1222,7 +1227,7 @@ private void verifyServiceDeclaration() {
 
         public ConsumerInfo() {
             this.isConnected = false;
-            this.beaconServiceConnection= new BeaconServiceConnection();
+            this.beaconServiceConnection = new BeaconServiceConnection();
         }
     }
 
@@ -1239,7 +1244,7 @@ public void onServiceConnected(ComponentName className, IBinder service) {
             serviceMessenger = new Messenger(service);
             // This will sync settings to the scanning service if it is in a different process
             applySettings();
-            synchronized(consumers) {
+            synchronized (consumers) {
                 Iterator<Map.Entry<BeaconConsumer, ConsumerInfo>> iter = consumers.entrySet().iterator();
                 while (iter.hasNext()) {
                     Map.Entry<BeaconConsumer, ConsumerInfo> entry = iter.next();
@@ -1262,7 +1267,7 @@ public void onServiceDisconnected(ComponentName className) {
     public class ServiceNotDeclaredException extends RuntimeException {
         public ServiceNotDeclaredException() {
             super("The BeaconService is not properly declared in AndroidManifest.xml.  If using Eclipse," +
-                    " please verify that your project.properties has manifestmerger.enabled=true");
+                  " please verify that your project.properties has manifestmerger.enabled=true");
         }
     }
 
@@ -1292,8 +1297,9 @@ public static void setAndroidLScanningDisabled(boolean disabled) {
 
     /**
      * Deprecated misspelled method
-     * @see #setManifestCheckingDisabled(boolean)
+     *
      * @param disabled
+     * @see #setManifestCheckingDisabled(boolean)
      */
     @Deprecated
     public static void setsManifestCheckingDisabled(boolean disabled) {
@@ -1319,9 +1325,9 @@ public static boolean getManifestCheckingDisabled() {
 
     private boolean determineIfCalledFromSeparateScannerProcess() {
         if (isScannerInDifferentProcess() && !isMainProcess()) {
-            LogManager.w(TAG, "Ranging/Monitoring may not be controlled from a separate "+
-                    "BeaconScanner process.  To remove this warning, please wrap this call in:"+
-                    " if (beaconManager.isMainProcess())");
+            LogManager.w(TAG, "Ranging/Monitoring may not be controlled from a separate " +
+                              "BeaconScanner process.  To remove this warning, please wrap this call in:" +
+                              " if (beaconManager.isMainProcess())");
             return true;
         }
         return false;
@@ -1331,7 +1337,7 @@ private static void warnIfScannerNotInSameProcess() {
         BeaconManager instance = sInstance;
         if (instance != null && instance.isScannerInDifferentProcess()) {
             LogManager.w(TAG,
-                    "Unsupported configuration change made for BeaconScanner in separate process");
+                         "Unsupported configuration change made for BeaconScanner in separate process");
         }
     }
 
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
index 0a6d926c..2b051d3e 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -81,17 +81,17 @@ private void ensureNotificationProcessorSetup(Context context) {
         return retval;
     }
 
-    private void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, ScanState scanState) {
+    private void applySettingsToScheduledJob(Context context, BeaconManager beaconManager,
+                                             ScanState scanState, boolean stopScanning) {
         scanState.applyChanges(beaconManager);
         LogManager.d(TAG, "Applying scan job settings with background mode " + scanState.getBackgroundMode());
-        schedule(context, scanState, false);
+        schedule(context, scanState, false, stopScanning);
     }
 
-    public void applySettingsToScheduledJob(Context context, BeaconManager beaconManager) {
+    public void applySettingsToScheduledJob(Context context, BeaconManager beaconManager, boolean stopScanning) {
         LogManager.d(TAG, "Applying settings to ScanJob");
-        JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
         ScanState scanState = ScanState.restore(context);
-        applySettingsToScheduledJob(context, beaconManager, scanState);
+        applySettingsToScheduledJob(context, beaconManager, scanState, stopScanning);
     }
 
     // This method appears to be never used, because it is only used by Android O APIs, which
@@ -122,6 +122,10 @@ public void forceScheduleNextScan(Context context) {
     }
 
     private void schedule(Context context, ScanState scanState, boolean backgroundWakeup) {
+        schedule(context, scanState, backgroundWakeup, false);
+    }
+
+    private void schedule(Context context, ScanState scanState, boolean backgroundWakeup, boolean stopScanning) {
         ensureNotificationProcessorSetup(context);
 
         long betweenScanPeriod = scanState.getScanJobIntervalMillis() - scanState.getScanJobRuntimeMillis();
@@ -148,7 +152,7 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
 
         JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
 
-        if (backgroundWakeup || !scanState.getBackgroundMode()) {
+        if (backgroundWakeup || !scanState.getBackgroundMode() && !stopScanning) {
             // If we are in the foreground, and we want to start a scan soon, we will schedule an
             // immediate job
             if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
