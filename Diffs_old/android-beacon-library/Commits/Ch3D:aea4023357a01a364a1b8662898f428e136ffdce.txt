diff --git a/src/main/java/org/altbeacon/beacon/BeaconManager.java b/src/main/java/org/altbeacon/beacon/BeaconManager.java
index ea265428..8becf432 100644
--- a/src/main/java/org/altbeacon/beacon/BeaconManager.java
+++ b/src/main/java/org/altbeacon/beacon/BeaconManager.java
@@ -960,7 +960,7 @@ public void updateScanPeriods() throws RemoteException {
     private void applyChangesToServices(int type, Region region) throws RemoteException {
         if (mScheduledScanJobsEnabled) {
             ScanJobScheduler.getInstance().applySettingsToScheduledJob(mContext, this);
-            return;
+            // return;
         }
         if (serviceMessenger == null) {
             throw new RemoteException("The BeaconManager is not bound to the service.  Call beaconManager.bind(BeaconConsumer consumer) and wait for a callback to onBeaconServiceConnect()");
diff --git a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
index 285dacbf..64e0fa26 100644
--- a/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
+++ b/src/main/java/org/altbeacon/beacon/service/ScanJobScheduler.java
@@ -146,7 +146,7 @@ private void schedule(Context context, ScanState scanState, boolean backgroundWa
 
         JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);
 
-        if (backgroundWakeup || !scanState.getBackgroundMode()) {
+        if (backgroundWakeup || ! scanState.getBackgroundMode()) {
             // If we are in the foreground, and we want to start a scan soon, we will schedule an
             // immediate job
             if (millisToNextJobStart < scanState.getScanJobIntervalMillis() - 50) {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
index a949f709..12977c87 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScanner.java
@@ -84,7 +84,6 @@
     protected final BluetoothCrashResolver mBluetoothCrashResolver;
     protected final CycledLeScanCallback mCycledLeScanCallback;
 
-    protected boolean mBackgroundFlag = true;
     protected boolean mRestartNeeded = false;
 
     /**
@@ -112,7 +111,6 @@ protected CycledLeScanner(Context context, long scanPeriod, long betweenScanPeri
         mContext = context;
         mCycledLeScanCallback = cycledLeScanCallback;
         mBluetoothCrashResolver = crashResolver;
-        mBackgroundFlag = backgroundFlag;
 
         mScanThread = new HandlerThread("CycledLeScannerThread");
         mScanThread.start();
@@ -179,13 +177,12 @@ public void setLongScanForcingEnabled(boolean enabled) {
     public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean backgroundFlag) {
         LogManager.d(TAG, "Set scan periods called with %s, %s Background mode must have changed.",
                      scanPeriod, betweenScanPeriod);
-        if (mBackgroundFlag != backgroundFlag) {
+        if (getBackgroundFlag() != backgroundFlag) {
             mRestartNeeded = true;
         }
-        mBackgroundFlag = backgroundFlag;
         mScanPeriod = scanPeriod;
         mBetweenScanPeriod = betweenScanPeriod;
-        if (mBackgroundFlag) {
+        if (getBackgroundFlag()) {
             LogManager.d(TAG, "We are in the background.  Setting wakeup alarm");
             setWakeUpAlarm();
         } else {
@@ -217,6 +214,10 @@ public void setScanPeriods(long scanPeriod, long betweenScanPeriod, boolean back
         }
     }
 
+    protected boolean getBackgroundFlag() {
+        return BeaconManager.getInstanceForApplication(mContext).getBackgroundMode();
+    }
+
     @MainThread
     public void start() {
         LogManager.d(TAG, "start called");
@@ -370,7 +371,7 @@ protected void scheduleScanCycleStop() {
         if (mScanningEnabled && millisecondsUntilStop > 0) {
             LogManager.d(TAG, "Waiting to stop scan cycle for another %s milliseconds",
                          millisecondsUntilStop);
-            if (mBackgroundFlag) {
+            if (getBackgroundFlag()) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
@@ -443,7 +444,12 @@ private void finishScanCycle() {
                     }
                 }
                 mNextScanCycleStartTime = getNextScanStartTime();
-                if (mScanningEnabled && !mBackgroundFlag) {
+                System.err.println(
+                        ">>>> CycledLeScanner.finishScanCycle() >> " + "mScanningEnabled = " + mScanningEnabled
+                        + " mBackgroundFlag = " + getBackgroundFlag());
+                System.err.println(">>>> CycledLeScanner.finishScanCycle() >> " + "BeaconManager.getBackgroundMode() = "
+                                   + BeaconManager.getInstanceForApplication(mContext).getBackgroundMode());
+                if (mScanningEnabled && !getBackgroundFlag()) {
                     scanLeDevice(true);
                 }
             }
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
index e9f51a74..f4a1f999 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForJellyBeanMr2.java
@@ -16,7 +16,9 @@
     private static final String TAG = "CycledLeScannerForJellyBeanMr2";
     private BluetoothAdapter.LeScanCallback leScanCallback;
 
-    public CycledLeScannerForJellyBeanMr2(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
+    public CycledLeScannerForJellyBeanMr2(Context context, long scanPeriod, long betweenScanPeriod,
+                                          boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback,
+                                          BluetoothCrashResolver crashResolver) {
         super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
     }
 
@@ -30,11 +32,11 @@ protected boolean deferScanIfNeeded() {
         long millisecondsUntilStart = mNextScanCycleStartTime - SystemClock.elapsedRealtime();
         if (millisecondsUntilStart > 0) {
             LogManager.d(TAG, "Waiting to start next Bluetooth scan for another %s milliseconds",
-                    millisecondsUntilStart);
+                         millisecondsUntilStart);
             // Don't actually wait until the next scan time -- only wait up to 1 second.  This
             // allows us to start scanning sooner if a consumer enters the foreground and expects
             // results more quickly.
-            if (mBackgroundFlag) {
+            if (getBackgroundFlag()) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
diff --git a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
index d35031b2..52e5459d 100644
--- a/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
+++ b/src/main/java/org/altbeacon/beacon/service/scanner/CycledLeScannerForLollipop.java
@@ -13,15 +13,14 @@
 import android.support.annotation.MainThread;
 import android.support.annotation.WorkerThread;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.altbeacon.beacon.BeaconManager;
 import org.altbeacon.beacon.logging.LogManager;
 import org.altbeacon.beacon.service.DetectionTracker;
 import org.altbeacon.bluetooth.BluetoothCrashResolver;
 
-import java.security.Security;
-import java.util.ArrayList;
-import java.util.List;
-
 @TargetApi(21)
 public class CycledLeScannerForLollipop extends CycledLeScanner {
     private static final String TAG = "CycledLeScannerForLollipop";
@@ -33,7 +32,8 @@
     private boolean mMainScanCycleActive = false;
     private final BeaconManager mBeaconManager;
 
-    public CycledLeScannerForLollipop(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag, CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
+    public CycledLeScannerForLollipop(Context context, long scanPeriod, long betweenScanPeriod, boolean backgroundFlag,
+                                      CycledLeScanCallback cycledLeScanCallback, BluetoothCrashResolver crashResolver) {
         super(context, scanPeriod, betweenScanPeriod, backgroundFlag, cycledLeScanCallback, crashResolver);
         mBeaconManager = BeaconManager.getInstanceForApplication(mContext);
     }
@@ -83,7 +83,7 @@ protected boolean deferScanIfNeeded() {
         mMainScanCycleActive = !deferScan;
         if (deferScan) {
             long secsSinceLastDetection = SystemClock.elapsedRealtime() -
-                    DetectionTracker.getInstance().getLastDetectionTime();
+                                          DetectionTracker.getInstance().getLastDetectionTime();
             // If we have seen a device recently
             // devices should behave like pre-Android L devices, because we don't want to drain battery
             // by continuously delivering packets for beacons visible in the background
@@ -99,18 +99,17 @@ protected boolean deferScanIfNeeded() {
                     // error on Android N.
                     if (mBetweenScanPeriod > 6000l) {
                         startScan();
+                    } else {
+                        LogManager
+                                .d(TAG, "Suppressing scan between cycles because the between scan cycle is too short.");
                     }
-                    else {
-                        LogManager.d(TAG, "Suppressing scan between cycles because the between scan cycle is too short.");
-                    }
-
 
                 } else {
                     // TODO: Consider starting a scan with delivery based on the filters *NOT* being seen
                     // This API is now available in Android M
                     LogManager.d(TAG, "This is Android L, but we last saw a beacon only %s "
-                            + "ago, so we will not keep scanning in background.",
-                            secsSinceLastDetection);
+                                      + "ago, so we will not keep scanning in background.",
+                                 secsSinceLastDetection);
                 }
             }
             if (mBackgroundLScanStartTime > 0l) {
@@ -120,15 +119,14 @@ protected boolean deferScanIfNeeded() {
                         mBackgroundLScanFirstDetectionTime = DetectionTracker.getInstance().getLastDetectionTime();
                     }
                     if (SystemClock.elapsedRealtime() - mBackgroundLScanFirstDetectionTime
-                            >= BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
+                        >= BACKGROUND_L_SCAN_DETECTION_PERIOD_MILLIS) {
                         // if we are in here, it has been more than 10 seconds since we detected
                         // a beacon in background L scanning mode.  We need to stop scanning
                         // so we do not drain battery
                         LogManager.d(TAG, "We've been detecting for a bit.  Stopping Android L background scanning");
                         stopScan();
                         mBackgroundLScanStartTime = 0l;
-                    }
-                    else {
+                    } else {
                         // report the results up the chain
                         LogManager.d(TAG, "Delivering Android L background scanning results");
                         mCycledLeScanCallback.onCycleEnd();
@@ -136,11 +134,11 @@ protected boolean deferScanIfNeeded() {
                 }
             }
             LogManager.d(TAG, "Waiting to start full Bluetooth scan for another %s milliseconds",
-                    millisecondsUntilStart);
+                         millisecondsUntilStart);
             // Don't actually wait until the next scan time -- only wait up to 1 second.  This
             // allows us to start scanning sooner if a consumer enters the foreground and expects
             // results more quickly.
-            if (scanActiveBefore && mBackgroundFlag) {
+            if (scanActiveBefore && getBackgroundFlag()) {
                 setWakeUpAlarm();
             }
             mHandler.postDelayed(new Runnable() {
@@ -172,7 +170,7 @@ protected void startScan() {
             LogManager.d(TAG, "starting filtered scan in SCAN_MODE_LOW_POWER");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_POWER)).build();
             filters = new ScanFilterUtils().createScanFiltersForBeaconParsers(
-                          mBeaconManager.getBeaconParsers());
+                    mBeaconManager.getBeaconParsers());
         } else {
             LogManager.d(TAG, "starting non-filtered scan in SCAN_MODE_LOW_LATENCY");
             settings = (new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)).build();
@@ -218,7 +216,7 @@ public void run() {
     }
 
     private void postStopLeScan() {
-        if (!isBluetoothOn()){
+        if (!isBluetoothOn()) {
             LogManager.d(TAG, "Not stopping scan because bluetooth is off");
             return;
         }
@@ -256,8 +254,7 @@ private boolean isBluetoothOn() {
                 return (bluetoothAdapter.getState() == BluetoothAdapter.STATE_ON);
             }
             LogManager.w(TAG, "Cannot get bluetooth adapter");
-        }
-        catch (SecurityException e) {
+        } catch (SecurityException e) {
             LogManager.w(TAG, "SecurityException checking if bluetooth is on");
         }
         return false;
@@ -275,8 +272,7 @@ private BluetoothLeScanner getScanner() {
                     LogManager.w(TAG, "Failed to make new Android L scanner");
                 }
             }
-        }
-        catch (SecurityException e) {
+        } catch (SecurityException e) {
             LogManager.w(TAG, "SecurityException making new Android L scanner");
         }
         return mScanner;
@@ -293,12 +289,12 @@ public void onScanResult(int callbackType, ScanResult scanResult) {
                         List<ParcelUuid> uuids = scanResult.getScanRecord().getServiceUuids();
                         if (uuids != null) {
                             for (ParcelUuid uuid : uuids) {
-                                LogManager.d(TAG, "with service uuid: "+uuid);
+                                LogManager.d(TAG, "with service uuid: " + uuid);
                             }
                         }
                     }
                     mCycledLeScanCallback.onLeScan(scanResult.getDevice(),
-                            scanResult.getRssi(), scanResult.getScanRecord().getBytes());
+                                                   scanResult.getRssi(), scanResult.getScanRecord().getBytes());
                     if (mBackgroundLScanStartTime > 0) {
                         LogManager.d(TAG, "got a filtered scan result in the background.");
                     }
@@ -310,7 +306,7 @@ public void onBatchScanResults(List<ScanResult> results) {
                     LogManager.d(TAG, "got batch records");
                     for (ScanResult scanResult : results) {
                         mCycledLeScanCallback.onLeScan(scanResult.getDevice(),
-                                scanResult.getRssi(), scanResult.getScanRecord().getBytes());
+                                                       scanResult.getRssi(), scanResult.getScanRecord().getBytes());
                     }
                     if (mBackgroundLScanStartTime > 0) {
                         LogManager.d(TAG, "got a filtered batch scan result in the background.");
@@ -325,31 +321,31 @@ public void onScanFailed(int errorCode) {
                             LogManager.e(
                                     TAG,
                                     "Scan failed: a BLE scan with the same settings is already started by the app"
-                            );
+                                        );
                             break;
                         case SCAN_FAILED_APPLICATION_REGISTRATION_FAILED:
                             LogManager.e(
                                     TAG,
                                     "Scan failed: app cannot be registered"
-                            );
+                                        );
                             break;
                         case SCAN_FAILED_FEATURE_UNSUPPORTED:
                             LogManager.e(
                                     TAG,
                                     "Scan failed: power optimized scan feature is not supported"
-                            );
+                                        );
                             break;
                         case SCAN_FAILED_INTERNAL_ERROR:
                             LogManager.e(
                                     TAG,
                                     "Scan failed: internal error"
-                            );
+                                        );
                             break;
                         default:
                             LogManager.e(
                                     TAG,
                                     "Scan failed with unknown error (errorCode=" + errorCode + ")"
-                            );
+                                        );
                             break;
                     }
                 }
