diff --git a/examples/pom.xml b/examples/pom.xml
index 4021626d..792680f1 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -5,27 +5,27 @@
 
     <artifactId>examples</artifactId>
     <name>ISO Parser Examples</name>
-    <version>1.9.35-SNAPSHOT</version>
+    <version>1.9.38-SNAPSHOT</version>
     <parent>
         <groupId>org.mp4parser</groupId>
         <artifactId>mp4parser-project</artifactId>
-        <version>1.9.35-SNAPSHOT</version>
+        <version>1.9.38-SNAPSHOT</version>
     </parent>
     <dependencies>
         <dependency>
             <groupId>org.mp4parser</groupId>
             <artifactId>isoparser</artifactId>
-            <version>1.9.35-SNAPSHOT</version>
+            <version>1.9.38-SNAPSHOT</version>
         </dependency>
         <dependency>
             <groupId>org.mp4parser</groupId>
             <artifactId>muxer</artifactId>
-            <version>1.9.35-SNAPSHOT</version>
+            <version>1.9.38-SNAPSHOT</version>
         </dependency>
         <dependency>
             <groupId>org.mp4parser</groupId>
             <artifactId>streaming</artifactId>
-            <version>1.9.35-SNAPSHOT</version>
+            <version>1.9.38-SNAPSHOT</version>
         </dependency>
         <dependency>
             <groupId>xom</groupId>
@@ -89,7 +89,7 @@
     <scm>
         <url>http://code.google.com/p/mp4parser/source/browse/</url>
         <connection>scm:svn:https://mp4parser.googlecode.com/svn/trunk/examples</connection>
-        <tag>mp4parser-project-1.9.5</tag>
+        <tag>mp4parser-project-1.9.35</tag>
   </scm>
     <repositories>
         <repository>
diff --git a/examples/src/main/java/org/mp4parser/examples/mux/filebased/MuxMe.java b/examples/src/main/java/org/mp4parser/examples/mux/filebased/MuxMe.java
index 57c11159..e3a8600b 100644
--- a/examples/src/main/java/org/mp4parser/examples/mux/filebased/MuxMe.java
+++ b/examples/src/main/java/org/mp4parser/examples/mux/filebased/MuxMe.java
@@ -3,7 +3,10 @@
 import org.mp4parser.Container;
 import org.mp4parser.muxer.FileDataSourceImpl;
 import org.mp4parser.muxer.Movie;
+import org.mp4parser.muxer.builder.DefaultFragmenterImpl;
 import org.mp4parser.muxer.builder.DefaultMp4Builder;
+import org.mp4parser.muxer.builder.FragmentedMp4Builder;
+import org.mp4parser.muxer.builder.Mp4Builder;
 import org.mp4parser.muxer.tracks.h264.H264TrackImpl;
 
 import java.io.FileOutputStream;
@@ -14,11 +17,12 @@
  */
 public class MuxMe {
     public static void main(String[] args) throws IOException {
-        H264TrackImpl h264Track = new H264TrackImpl(new FileDataSourceImpl("C:\\dev\\mp4parser\\streaming\\src\\test\\resources\\org\\mp4parser\\streaming\\input\\h264\\tos.h264"));
+        H264TrackImpl h264Track = new H264TrackImpl(new FileDataSourceImpl("/Users/sannies/dev/mp4parser/1532667754113.h264"));
         Movie m = new Movie();
         m.addTrack(h264Track);
-        DefaultMp4Builder builder = new DefaultMp4Builder();
+        Mp4Builder builder = new DefaultMp4Builder();
+
         Container c = builder.build(m);
-        c.writeContainer(new FileOutputStream("output-old.mp4").getChannel());
+        c.writeContainer(new FileOutputStream("/Users/sannies/dev/mp4parser/1532667754113-meins.mp4").getChannel());
     }
 }
diff --git a/examples/src/main/java/org/mp4parser/examples/mux/streaming/H264AACExample.java b/examples/src/main/java/org/mp4parser/examples/mux/streaming/H264AACExample.java
index 612b7803..0575f6f9 100644
--- a/examples/src/main/java/org/mp4parser/examples/mux/streaming/H264AACExample.java
+++ b/examples/src/main/java/org/mp4parser/examples/mux/streaming/H264AACExample.java
@@ -5,6 +5,7 @@
 import org.mp4parser.streaming.input.h264.H264AnnexBTrack;
 import org.mp4parser.streaming.output.mp4.FragmentedMp4Writer;
 
+import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.net.URI;
 import java.nio.channels.WritableByteChannel;
@@ -18,12 +19,11 @@
 public class H264AACExample {
     public static void main(String[] args) throws Exception {
         LogManager.getLogManager().readConfiguration(H264AACExample.class.getResourceAsStream("/log.properties"));
-        AdtsAacStreamingTrack aac = new AdtsAacStreamingTrack(
+        /*AdtsAacStreamingTrack aac = new AdtsAacStreamingTrack(
                 new URI("http://org.mp4parser.s3.amazonaws.com/examples/Cosmos%20Laundromat%20small.aac").
-                        toURL().openStream(), 48000, 64000); // How should I know avg bitrate in advance?
+                        toURL().openStream(), 48000, 64000); // How should I know avg bitrate in advance?*/
         H264AnnexBTrack h264 = new H264AnnexBTrack(
-                new URI("http://org.mp4parser.s3.amazonaws.com/examples/Cosmos%20Laundromat%20small.264").
-                        toURL().openStream());
+                new FileInputStream("/Users/sannies/dev/mp4parser/1532667754113.h264"));
         /*InputStream aacInputStream = new FileInputStream("c:\\dev\\mp4parser\\843D111F-E839-4597-B60C-3B8114E0AA72_AU01.aac");
         AdtsAacStreamingTrack aac = new AdtsAacStreamingTrack(
                 aacInputStream, 48000, 64000); // How should I know avg bitrate in advance?
@@ -34,16 +34,16 @@ public static void main(String[] args) throws Exception {
         CompletionService<Void> ecs
                 = new ExecutorCompletionService<>(es);
 
-        FileOutputStream fos = new FileOutputStream("c:\\dev\\mp4parser\\output.mp4");
+        FileOutputStream fos = new FileOutputStream("/Users/sannies/dev/mp4parser/1532667754113-meins2.mp4");
         WritableByteChannel wbc = fos.getChannel();
         //AsyncWritableByteChannel asyncWritableByteChannel = new AsyncWritableByteChannel(wbc);
         FragmentedMp4Writer multiTrackFragmentedMp4Writer =
-                new FragmentedMp4Writer(Arrays.<StreamingTrack>asList(aac, h264), wbc);
+                new FragmentedMp4Writer(Arrays.<StreamingTrack>asList( h264), wbc);
 
 
         final List<Future<Void>> allFutures = new ArrayList<>();
         List<Callable<Void>> allCallables = new ArrayList<>();
-        allCallables.add(aac);
+       // allCallables.add(aac);
         allCallables.add(h264);
 
         for (Callable<Void> callable : allCallables) {
diff --git a/isoparser/pom.xml b/isoparser/pom.xml
index b2c08951..095324fd 100644
--- a/isoparser/pom.xml
+++ b/isoparser/pom.xml
@@ -7,7 +7,7 @@
     <description>A generic parser and writer for all ISO 14496 based files (MP4, Quicktime, DCF, PDCF, ...)
     </description>
     <url>https://github.com/sannies/mp4parser</url>
-    <version>1.9.35-SNAPSHOT</version>
+    <version>1.9.38-SNAPSHOT</version>
 
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -38,7 +38,7 @@
                     <dependency>
                         <groupId>org.aspectj</groupId>
                         <artifactId>aspectjtools</artifactId>
-                        <version>1.8.13</version>
+                        <version>1.9.1</version>
                     </dependency>
 
                 </dependencies>
@@ -114,7 +114,7 @@
         <dependency>
             <groupId>org.aspectj</groupId>
             <artifactId>aspectjrt</artifactId>
-            <version>1.8.13</version>
+            <version>1.9.1</version>
         </dependency>
         <dependency>
         <groupId>org.slf4j</groupId>
@@ -220,7 +220,7 @@
 
     <scm>
         <url>https://github.com/sannies/mp4parser</url>
-        <tag>mp4parser-project-1.9.5</tag>
+        <tag>mp4parser-project-1.9.35</tag>
   </scm>
 
     <licenses>
diff --git a/isoparser/src/main/java/org/mp4parser/AbstractBoxParser.java b/isoparser/src/main/java/org/mp4parser/AbstractBoxParser.java
index 1b4e31c9..e0ac62f1 100644
--- a/isoparser/src/main/java/org/mp4parser/AbstractBoxParser.java
+++ b/isoparser/src/main/java/org/mp4parser/AbstractBoxParser.java
@@ -24,12 +24,16 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.ReadableByteChannel;
+import java.util.Arrays;
+import java.util.List;
 
 /**
  * This BoxParser handles the basic stuff like reading size and extracting box type.
  */
 public abstract class AbstractBoxParser implements BoxParser {
 
+    private List<String> skippedTypes;
+    
     private static Logger LOG = LoggerFactory.getLogger(AbstractBoxParser.class.getName());
     ThreadLocal<ByteBuffer> header = new ThreadLocal<ByteBuffer>() {
         @Override
@@ -95,8 +99,15 @@ public ParsableBox parseBox(ReadableByteChannel byteChannel, String parentType)
             }
             contentSize -= 16;
         }
-        LOG.trace("Creating box {} {}", type, usertype);
-        ParsableBox parsableBox = createBox(type, usertype, parentType);
+        ParsableBox parsableBox = null;
+        if( skippedTypes != null && skippedTypes.contains(type) ) {
+            LOG.trace("Skipping box {} {} {}", type, usertype, parentType);
+            parsableBox = new SkipBox(type, usertype, parentType);
+        }
+        else {
+            LOG.trace("Creating box {} {} {}", type, usertype, parentType);
+            parsableBox = createBox(type, usertype, parentType);
+        }
         //LOG.finest("Parsing " + box.getType());
         // System.out.println("parsing " + Mp4Arrays.toString(box.getType()) + " " + box.getClass().getName() + " size=" + size);
         header.get().rewind();
@@ -105,5 +116,8 @@ public ParsableBox parseBox(ReadableByteChannel byteChannel, String parentType)
         return parsableBox;
     }
 
-
+    public AbstractBoxParser skippingBoxes(String... types) {
+        skippedTypes = Arrays.asList(types);
+        return this;
+    }
 }
diff --git a/isoparser/src/main/java/org/mp4parser/RewindableReadableByteChannel.java b/isoparser/src/main/java/org/mp4parser/RewindableReadableByteChannel.java
new file mode 100644
index 00000000..a0b40c06
--- /dev/null
+++ b/isoparser/src/main/java/org/mp4parser/RewindableReadableByteChannel.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the License);
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an AS IS BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.mp4parser;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.ReadableByteChannel;
+
+/**
+ * Provides rewind() operation to ReadableByteChannel by buffering data up to specified capacity.
+ */
+public class RewindableReadableByteChannel implements ReadableByteChannel {
+
+    private final ReadableByteChannel readableByteChannel;
+    private final ByteBuffer buffer;
+    // If 'true', there are more bytes read from |readableByteChannel| than the allocated buffer size.
+    // The rewind is not possible in that case.
+    private boolean passedRewindPoint;
+    private int nextBufferWritePosition;
+    private int nextBufferReadPosition;
+
+    public RewindableReadableByteChannel(ReadableByteChannel readableByteChannel, int bufferCapacity) {
+        this.buffer = ByteBuffer.allocate(bufferCapacity);
+        this.readableByteChannel = readableByteChannel;
+    }
+
+    /**
+     * @see ReadableByteChannel#read(ByteBuffer)
+     */
+    public int read(ByteBuffer dst) throws IOException {
+        int initialDstPosition = dst.position();
+        // Read data from |readableByteChannel| into |buffer|.
+        buffer.limit(buffer.capacity());
+        buffer.position(nextBufferWritePosition);
+        if (buffer.capacity() > 0) {
+            readableByteChannel.read(buffer);
+            nextBufferWritePosition = buffer.position();
+        }
+
+        // Read data from |buffer| into |dst|.
+        buffer.position(nextBufferReadPosition);
+        buffer.limit(nextBufferWritePosition);
+        if (buffer.remaining() > dst.remaining()) {
+            buffer.limit(buffer.position() + dst.remaining());
+        }
+        dst.put(buffer);
+        nextBufferReadPosition = buffer.position();
+
+        // If |dst| still has capacity then read data from |readableByteChannel|.
+        int bytesRead = readableByteChannel.read(dst);
+        if (bytesRead > 0) {
+            // We passed the buffering capacity. It will not be possible to rewind
+            // |readableByteChannel| anymore.
+            passedRewindPoint = true;
+        } else if ((bytesRead == -1) && (dst.position() - initialDstPosition == 0)) {
+            return -1;
+        }
+        return dst.position() - initialDstPosition;
+    }
+
+    public void rewind() {
+        if (passedRewindPoint) {
+            throw new IllegalStateException("Passed the rewind point. Increase the buffer capacity.");
+        }
+        nextBufferReadPosition = 0;
+    }
+
+    /**
+     * @see ReadableByteChannel#isOpen()
+     */
+    public boolean isOpen() {
+        return readableByteChannel.isOpen();
+    }
+
+    /**
+     * @see ReadableByteChannel#close()
+     */
+    public void close() throws IOException {
+        readableByteChannel.close();
+    }
+}
diff --git a/isoparser/src/main/java/org/mp4parser/SkipBox.java b/isoparser/src/main/java/org/mp4parser/SkipBox.java
new file mode 100644
index 00000000..203262f2
--- /dev/null
+++ b/isoparser/src/main/java/org/mp4parser/SkipBox.java
@@ -0,0 +1,58 @@
+package org.mp4parser;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.WritableByteChannel;
+
+public class SkipBox implements ParsableBox {
+
+    private String type;
+    private long size;
+    private long sourcePosition = -1;
+    
+    public SkipBox(String type, byte[] usertype, String parentType) {
+        this.type = type;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public long getSize() {
+        return size;
+    }
+
+    public long getContentSize() {
+        return size-8;
+    }
+    
+    /**
+     * Get the seekable position of the content for this box within the source data.
+     * @return The data offset, or -1 if it is not known
+     */
+    public long getSourcePosition() {
+        return sourcePosition;
+    }
+    
+    public void getBox(WritableByteChannel writableByteChannel) throws IOException {
+        throw new RuntimeException("Cannot retrieve a skipped box - type "+type);
+    }
+
+    public void parse(ReadableByteChannel dataSource, ByteBuffer header, long contentSize, BoxParser boxParser)
+            throws IOException {
+        this.size = contentSize+8;
+        
+        if( dataSource instanceof FileChannel ) {
+            FileChannel seekable = (FileChannel) dataSource;
+            sourcePosition = seekable.position();
+            long newPosition = sourcePosition + contentSize;
+            seekable.position(newPosition);
+        }
+        else {
+            throw new RuntimeException("Cannot skip box "+type+" if data source is not seekable");
+        }
+    }
+
+}
diff --git a/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part12/MetaBox.java b/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part12/MetaBox.java
index 51072e8d..d8337199 100644
--- a/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part12/MetaBox.java
+++ b/isoparser/src/main/java/org/mp4parser/boxes/iso14496/part12/MetaBox.java
@@ -17,6 +17,7 @@
 package org.mp4parser.boxes.iso14496.part12;
 
 import org.mp4parser.BoxParser;
+import org.mp4parser.RewindableReadableByteChannel;
 import org.mp4parser.support.AbstractContainerBox;
 import org.mp4parser.tools.IsoTypeReader;
 import org.mp4parser.tools.IsoTypeWriter;
@@ -36,6 +37,7 @@
 
     private int version;
     private int flags;
+    private boolean quickTimeFormat;
 
     public MetaBox() {
         super(TYPE);
@@ -76,25 +78,49 @@ protected final void writeVersionAndFlags(ByteBuffer bb) {
 
     @Override
     public void parse(ReadableByteChannel dataSource, ByteBuffer header, long contentSize, BoxParser boxParser) throws IOException {
-        ByteBuffer bb = ByteBuffer.allocate(4);
-        dataSource.read(bb);
-        parseVersionAndFlags((ByteBuffer) bb.rewind());
-        initContainer(dataSource, contentSize - 4, boxParser);
+        // Read first 20 bytes to determine whether the file is formatted according to QuickTime File Format.
+        RewindableReadableByteChannel rewindableDataSource = new RewindableReadableByteChannel(dataSource, 20);
+        ByteBuffer bb = ByteBuffer.allocate(20);
+        int bytesRead = rewindableDataSource.read(bb);
+        if (bytesRead == 20) {
+            // If the second and the fifth 32-bit integers encode 'hdlr' and 'mdta' respectively then the MetaBox is
+            // formatted according to QuickTime File Format.
+            // See https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html
+            bb.position(4);
+            String second4cc = IsoTypeReader.read4cc(bb);
+            bb.position(16);
+            String fifth4cc = IsoTypeReader.read4cc(bb);
+            if ("hdlr".equals(second4cc) && "mdta".equals(fifth4cc)) {
+                quickTimeFormat = true;
+            }
+        }
+        rewindableDataSource.rewind();
+
+        if (!quickTimeFormat) {
+            bb = ByteBuffer.allocate(4);
+            rewindableDataSource.read(bb);
+            parseVersionAndFlags((ByteBuffer) bb.rewind());
+        }
+
+        int bytesUsed = quickTimeFormat ? 0 : 4;
+        initContainer(rewindableDataSource, contentSize - bytesUsed, boxParser);
     }
 
     @Override
     public void getBox(WritableByteChannel writableByteChannel) throws IOException {
         writableByteChannel.write(getHeader());
-        ByteBuffer bb = ByteBuffer.allocate(4);
-        writeVersionAndFlags(bb);
-        writableByteChannel.write((ByteBuffer) bb.rewind());
+        if (!quickTimeFormat) {
+            ByteBuffer bb = ByteBuffer.allocate(4);
+            writeVersionAndFlags(bb);
+            writableByteChannel.write((ByteBuffer) bb.rewind());
+        }
         writeContainer(writableByteChannel);
     }
 
     @Override
     public long getSize() {
         long s = getContainerSize();
-        long t = 4; // bytes to container start
+        long t = quickTimeFormat ? 0 : 4; // bytes to container start
         return s + t + ((largeBox || (s + t) >= (1L << 32)) ? 16 : 8);
 
     }
diff --git a/isoparser/src/test/java/com/coremedia/drm/packager/isoparser/RoundTripTest.java b/isoparser/src/test/java/com/coremedia/drm/packager/isoparser/RoundTripTest.java
index d232723e..c7feba21 100644
--- a/isoparser/src/test/java/com/coremedia/drm/packager/isoparser/RoundTripTest.java
+++ b/isoparser/src/test/java/com/coremedia/drm/packager/isoparser/RoundTripTest.java
@@ -78,6 +78,10 @@ public void testRoundTrip_1e() throws Exception {
         testRoundTrip_1(defaultTestFileDir + "/test-pod.m4a");
     }
 
+    public void testRoundTrip_QuickTimeFormat() throws Exception {
+        testRoundTrip_1(defaultTestFileDir + "/QuickTimeFormat.mp4");
+    }
+
 
     public void testRoundTrip_1(String originalFile) throws Exception {
 
diff --git a/isoparser/src/test/java/org/mp4parser/SkippingBoxTest.java b/isoparser/src/test/java/org/mp4parser/SkippingBoxTest.java
new file mode 100644
index 00000000..abbcdebc
--- /dev/null
+++ b/isoparser/src/test/java/org/mp4parser/SkippingBoxTest.java
@@ -0,0 +1,52 @@
+package org.mp4parser;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import java.io.FileInputStream;
+import java.io.IOException;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mp4parser.boxes.iso14496.part12.MovieBox;
+import org.mp4parser.boxes.iso14496.part12.TrackHeaderBox;
+import org.mp4parser.tools.Path;
+import org.mp4parser.tools.PathTest;
+
+public class SkippingBoxTest {
+    
+    private IsoFile isoFile;
+    
+    @Before
+    public void setup() throws IOException {
+        FileInputStream fis = new FileInputStream(PathTest.class.getProtectionDomain().getCodeSource().getLocation().getFile() + "/test.m4p");
+        isoFile = new IsoFile(fis.getChannel(), new PropertyBoxParserImpl().skippingBoxes("mdat", "mvhd"));
+        fis.close();
+    }
+
+
+    @Test
+    public void testBoxesHaveBeenSkipped() {
+        MovieBox movieBox = isoFile.getMovieBox();
+        assertNotNull(movieBox);
+        assertEquals(4, movieBox.getBoxes().size());
+        assertEquals("mvhd", movieBox.getBoxes().get(0).getType());
+        assertEquals("iods", movieBox.getBoxes().get(1).getType());
+        assertEquals("trak", movieBox.getBoxes().get(2).getType());
+        assertEquals("udta", movieBox.getBoxes().get(3).getType());
+        
+        Box box = Path.getPath(isoFile, "moov/trak/tkhd");
+        assertTrue( box instanceof TrackHeaderBox );
+        
+        TrackHeaderBox thb = (TrackHeaderBox)box;
+        assertTrue(thb.getDuration() == 102595);
+        
+        box = Path.getPath(isoFile, "mdat");
+        assertTrue(box instanceof SkipBox);
+        
+        box = Path.getPath(isoFile, "moov/mvhd");
+        assertTrue(box instanceof SkipBox);
+    }
+
+}
diff --git a/isoparser/src/test/resources/QuickTimeFormat.mp4 b/isoparser/src/test/resources/QuickTimeFormat.mp4
new file mode 100644
index 00000000..18298a63
Binary files /dev/null and b/isoparser/src/test/resources/QuickTimeFormat.mp4 differ
diff --git a/muxer/pom.xml b/muxer/pom.xml
index 8a5af612..1f841e9e 100644
--- a/muxer/pom.xml
+++ b/muxer/pom.xml
@@ -3,7 +3,7 @@
 
     <modelVersion>4.0.0</modelVersion>
     <groupId>org.mp4parser</groupId>
-    <version>1.9.35-SNAPSHOT</version>
+    <version>1.9.38-SNAPSHOT</version>
     <artifactId>muxer</artifactId>
     <name>File Muxer</name>
     <url>https://github.com/sannies/mp4parser</url>
@@ -16,7 +16,7 @@
         <dependency>
             <groupId>org.mp4parser</groupId>
             <artifactId>isoparser</artifactId>
-            <version>1.9.35-SNAPSHOT</version>
+            <version>1.9.38-SNAPSHOT</version>
         </dependency>
         <dependency>
             <groupId>junit</groupId>
@@ -121,6 +121,6 @@
     </developers>
     <scm>
         <url>https://github.com/sannies/mp4parser</url>
-        <tag>mp4parser-project-1.9.5</tag>
+        <tag>mp4parser-project-1.9.35</tag>
     </scm>
 </project>
\ No newline at end of file
diff --git a/muxer/src/main/java/org/mp4parser/muxer/container/mp4/FragmentedMp4SampleList.java b/muxer/src/main/java/org/mp4parser/muxer/container/mp4/FragmentedMp4SampleList.java
index 4df14ef3..53ab34da 100644
--- a/muxer/src/main/java/org/mp4parser/muxer/container/mp4/FragmentedMp4SampleList.java
+++ b/muxer/src/main/java/org/mp4parser/muxer/container/mp4/FragmentedMp4SampleList.java
@@ -204,7 +204,7 @@ public ByteBuffer asByteBuffer() {
 
                         @Override
                         public SampleEntry getSampleEntry() {
-                            return sampleEntries.size() == 1 ? sampleEntries.get(0) : sampleEntries.get(l2i(tfhd.getSampleDescriptionIndex() - 1));
+                            return sampleEntries.size() == 1 ? sampleEntries.get(0) : sampleEntries.get(l2i(Math.max(0, tfhd.getSampleDescriptionIndex()-1)));
                         }
                     };
                     sampleCache[index] = new SoftReference<>(sample);
diff --git a/muxer/src/main/java/org/mp4parser/muxer/tracks/h264/H264TrackImpl.java b/muxer/src/main/java/org/mp4parser/muxer/tracks/h264/H264TrackImpl.java
index 6fa5f4af..8f422e2b 100644
--- a/muxer/src/main/java/org/mp4parser/muxer/tracks/h264/H264TrackImpl.java
+++ b/muxer/src/main/java/org/mp4parser/muxer/tracks/h264/H264TrackImpl.java
@@ -123,16 +123,6 @@ public static H264NalUnitHeader getNalUnitHeader(ByteBuffer nal) {
 
     private void parse(LookAhead la) throws IOException {
 
-
-        samples = new ArrayList<Sample>();
-        if (!readSamples(la)) {
-            throw new IOException();
-        }
-
-        if (!readVariables()) {
-            throw new IOException();
-        }
-
         visualSampleEntry = new VisualSampleEntry("avc1");
         visualSampleEntry.setDataReferenceIndex(1);
         visualSampleEntry.setDepth(24);
@@ -143,6 +133,16 @@ private void parse(LookAhead la) throws IOException {
         visualSampleEntry.setHeight(height);
         visualSampleEntry.setCompressorname("AVC Coding");
 
+        samples = new ArrayList<>();
+        if (!readSamples(la)) {
+            throw new IOException();
+        }
+
+        if (!readVariables()) {
+            throw new IOException();
+        }
+
+
         AvcConfigurationBox avcConfigurationBox = new AvcConfigurationBox();
 
         avcConfigurationBox.setSequenceParameterSets(new ArrayList<ByteBuffer>(spsIdToSpsBytes.values()));
diff --git a/muxer/src/main/java/org/mp4parser/muxer/tracks/h265/SequenceParameterSetRbsp.java b/muxer/src/main/java/org/mp4parser/muxer/tracks/h265/SequenceParameterSetRbsp.java
index 5b8062ca..cfde1ccf 100644
--- a/muxer/src/main/java/org/mp4parser/muxer/tracks/h265/SequenceParameterSetRbsp.java
+++ b/muxer/src/main/java/org/mp4parser/muxer/tracks/h265/SequenceParameterSetRbsp.java
@@ -10,22 +10,34 @@
  */
 public class SequenceParameterSetRbsp {
     public VuiParameters vuiParameters;
-
+    public int pic_width_in_luma_samples;
+    public int pic_height_in_luma_samples;
+    public int general_profile_space;
+    public boolean general_tier_flag;
+    public int general_profile_idc;
+    public long general_profile_compatibility_flags;
+    public long general_constraint_indicator_flags;
+    public byte general_level_idc;
+    public int chroma_format_idc;
+    public int bit_depth_luma_minus8;
+    public int bit_depth_chroma_minus8;
+    public int sps_max_sub_layers_minus1;
+    public boolean sps_temporal_id_nesting_flag;
 
     public SequenceParameterSetRbsp(InputStream is) throws IOException {
         CAVLCReader bsr = new CAVLCReader(is);
 
         int sps_video_parameter_set_id = (int) bsr.readNBit(4, "sps_video_parameter_set_id");
-        int sps_max_sub_layers_minus1 = (int) bsr.readNBit(3, "sps_max_sub_layers_minus1");
+        sps_max_sub_layers_minus1 = (int) bsr.readNBit(3, "sps_max_sub_layers_minus1");
         boolean sps_temporal_id_nesting_flag = bsr.readBool("sps_temporal_id_nesting_flag");
         profile_tier_level(sps_max_sub_layers_minus1, bsr);
         int sps_seq_parameter_set_id = bsr.readUE("sps_seq_parameter_set_id");
-        int chroma_format_idc = bsr.readUE("chroma_format_idc");
+        chroma_format_idc = bsr.readUE("chroma_format_idc");
         if (chroma_format_idc == 3) {
             int separate_colour_plane_flag = bsr.read1Bit();
         }
-        int pic_width_in_luma_samples = bsr.readUE("pic_width_in_luma_samples");
-        int pic_height_in_luma_samples = bsr.readUE("pic_width_in_luma_samples");
+        pic_width_in_luma_samples = bsr.readUE("pic_width_in_luma_samples");
+        pic_height_in_luma_samples = bsr.readUE("pic_width_in_luma_samples");
         boolean conformance_window_flag = bsr.readBool("conformance_window_flag");
         if (conformance_window_flag) {
             int conf_win_left_offset = bsr.readUE("conf_win_left_offset");
@@ -34,8 +46,8 @@ public SequenceParameterSetRbsp(InputStream is) throws IOException {
             int conf_win_bottom_offset = bsr.readUE("conf_win_bottom_offset");
         }
 
-        int bit_depth_luma_minus8 = bsr.readUE("bit_depth_luma_minus8");
-        int bit_depth_chroma_minus8 = bsr.readUE("bit_depth_chroma_minus8");
+        bit_depth_luma_minus8 = bsr.readUE("bit_depth_luma_minus8");
+        bit_depth_chroma_minus8 = bsr.readUE("bit_depth_chroma_minus8");
         int log2_max_pic_order_cnt_lsb_minus4 = bsr.readUE("log2_max_pic_order_cnt_lsb_minus4");
         boolean sps_sub_layer_ordering_info_present_flag = bsr.readBool("sps_sub_layer_ordering_info_present_flag");
 
@@ -61,7 +73,7 @@ public SequenceParameterSetRbsp(InputStream is) throws IOException {
         if (scaling_list_enabled_flag) {
             boolean sps_scaling_list_data_present_flag = bsr.readBool("sps_scaling_list_data_present_flag");
             if (sps_scaling_list_data_present_flag) {
-                scaling_list_data(bsr);
+            	skip_scaling_list_data(bsr);
             }
         }
         boolean amp_enabled_flag = bsr.readBool("amp_enabled_flag");
@@ -76,9 +88,9 @@ public SequenceParameterSetRbsp(InputStream is) throws IOException {
             boolean pcm_loop_filter_disabled_flag = bsr.readBool("pcm_loop_filter_disabled_flag");
         }
         int num_short_term_ref_pic_sets = bsr.readUE("num_short_term_ref_pic_sets");
-        for (int i = 0; i < num_short_term_ref_pic_sets; i++) {
-            short_term_ref_pic_set(i, num_short_term_ref_pic_sets, bsr);
-        }
+        
+        parse_short_term_ref_pic_sets(num_short_term_ref_pic_sets, bsr);
+        
         boolean long_term_ref_pics_present_flag = bsr.readBool("long_term_ref_pics_present_flag");
         if (long_term_ref_pics_present_flag) {
             int num_long_term_ref_pics_sps = bsr.readUE("num_long_term_ref_pics_sps");
@@ -96,92 +108,73 @@ public SequenceParameterSetRbsp(InputStream is) throws IOException {
             vuiParameters = new VuiParameters(sps_max_sub_layers_minus1, bsr);
         }
     }
-
-
-
-    private static void short_term_ref_pic_set(int stRpsIdx, int num_short_term_ref_pic_sets, CAVLCReader bsr) throws IOException {
-      /*  boolean inter_ref_pic_set_prediction_flag = false;
-        if (stRpsIdx != 0)
-            inter_ref_pic_set_prediction_flag = bsr.readBool("inter_ref_pic_set_prediction_flag");
-        if (inter_ref_pic_set_prediction_flag) {
-            if (stRpsIdx == num_short_term_ref_pic_sets) {
-                int delta_idx_minus1 = bsr.readUE("delta_idx_minus1");
-            }
-            int delta_rps_sign = bsr.read1Bit();
-            int abs_delta_rps_minus1 = bsr.readUE("abs_delta_rps_minus1");
-            boolean used_by_curr_pic_flag[] = new boolean[NumDeltaPocs[RefRpsIdx] + 1];
-            boolean use_delta_flag[] = new boolean[NumDeltaPocs[RefRpsIdx] + 1];
-            for (int j = 0; j <= NumDeltaPocs[RefRpsIdx]; j++) {
-                used_by_curr_pic_flag[j] =bsr.readBool("used_by_curr_pic_flag[" + j + "]");
-                if (!used_by_curr_pic_flag[j])
-                    use_delta_flag[j]=bsr.readBool("use_delta_flag[" + j + "]");
-            }
-        } else {
-            int num_negative_pics = bsr.readUE ("num_negative_pics");
-            int num_positive_pics = bsr.readUE ("num_positive_pics");
-            int delta_poc_s0_minus1[] = new int[num_negative_pics];
-            boolean used_by_curr_pic_s0_flag[] = new boolean[num_negative_pics];
-            for (int i = 0; i < num_negative_pics; i++) {
-                delta_poc_s0_minus1[i] = bsr.readUE("delta_poc_s0_minus1[" + i + "]");
-                used_by_curr_pic_s0_flag[i] = bsr.readBool("used_by_curr_pic_s0_flag[" + i +"]");
+    
+    private void parse_short_term_ref_pic_sets(int num_short_term_ref_pic_sets, CAVLCReader bsr) throws IOException
+    {
+      // Based on FFMPEG implementation -- see hevc.c "parse_rps"
+      long[] num_delta_pocs = new long[num_short_term_ref_pic_sets];
+      for (int rpsIdx = 0; rpsIdx < num_short_term_ref_pic_sets; rpsIdx++) {
+        if (rpsIdx != 0 && bsr.readBool()) {
+          bsr.readBool("delta_rps_sign");
+          bsr.readUE("abs_delta_rps_minus1");
+          num_delta_pocs[rpsIdx] = 0;
+          for (int i = 0; i <= num_delta_pocs[rpsIdx - 1]; i++) {
+            boolean use_delta_flag = false;
+            boolean used_by_curr_pic_flag = bsr.readBool();
+            if (!used_by_curr_pic_flag) {
+              use_delta_flag = bsr.readBool();
             }
-            int delta_poc_s1_minus1[] = new int[num_positive_pics];
-            boolean used_by_curr_pic_s1_flag[] = new boolean[num_positive_pics];
-            for (int i = 0; i < num_positive_pics; i++) {
-                delta_poc_s1_minus1[i] = bsr.readUE("delta_poc_s1_minus1[" + i + "]");
-                used_by_curr_pic_s1_flag[i] = bsr.readBool("used_by_curr_pic_s1_flag[" + i +"]");
+            if (used_by_curr_pic_flag || use_delta_flag) {
+              num_delta_pocs[rpsIdx]++;
             }
-        }*/
-        throw new RuntimeException("short_term_ref_pic_set not implemented");
+          }
+        }
+        else {
+          long delta_pocs = bsr.readUE("num_negative_pics") + bsr.readUE("num_positive_pics");
+          num_delta_pocs[rpsIdx] = delta_pocs;
+          for (long i = 0; i < delta_pocs; ++i) {
+            bsr.readUE("delta_poc_s0/1_minus1");
+            bsr.readBool("used_by_curr_pic_s0/1_flag");
+          }
+        }
+      }
     }
-
-    private static void scaling_list_data(CAVLCReader bsr) throws IOException {
-        boolean[][] scaling_list_pred_mode_flag = new boolean[4][];
-        int[][] scaling_list_pred_matrix_id_delta = new int[4][];
-        int[][] scaling_list_dc_coef_minus8 = new int[2][];
-        int[][][] ScalingList = new int[4][][];
-
-        for (int sizeId = 0; sizeId < 4; sizeId++) {
-            for (int matrixId = 0; matrixId < ((sizeId == 3) ? 2 : 6); matrixId++) {
-                scaling_list_pred_mode_flag[sizeId] = new boolean[((sizeId == 3) ? 2 : 6)];
-                scaling_list_pred_matrix_id_delta[sizeId] = new int[((sizeId == 3) ? 2 : 6)];
-                ScalingList[sizeId] = new int[(sizeId == 3) ? 2 : 6][];
-                scaling_list_pred_mode_flag[sizeId][matrixId] = bsr.readBool();
-                if (!scaling_list_pred_mode_flag[sizeId][matrixId]) {
-                    scaling_list_pred_matrix_id_delta[sizeId][matrixId] = bsr.readUE("scaling_list_pred_matrix_id_delta[" + sizeId + "][" + matrixId + "]");
-                } else {
-                    int nextCoef = 8;
-                    int coefNum = Math.min(64, (1 << (4 + (sizeId << 1))));
-                    if (sizeId > 1) {
-                        scaling_list_dc_coef_minus8[sizeId - 2][matrixId] = bsr.readSE("scaling_list_dc_coef_minus8[" + sizeId + "- 2][" + matrixId + "]");
-                        nextCoef = scaling_list_dc_coef_minus8[sizeId - 2][matrixId] + 8;
-                    }
-                    ScalingList[sizeId][matrixId] = new int[coefNum];
-                    for (int i = 0; i < coefNum; i++) {
-                        int scaling_list_delta_coef = bsr.readSE("scaling_list_delta_coef ");
-                        nextCoef = (nextCoef + scaling_list_delta_coef + 256) % 256;
-                        ScalingList[sizeId][matrixId][i] = nextCoef;
-                    }
-                }
+    
+    private static void skip_scaling_list_data(CAVLCReader bsr) throws IOException
+    {
+      // Based on FFMPEG implementation see hevc.c "skip_scaling_list_data"
+      for (int i = 0; i < 4; i++)
+      {
+        for (int j = 0; j < (i == 3 ? 2 : 6); j++)
+        {
+          if (bsr.readBool())
+          {
+            bsr.readUE("scaling_list_pred_matrix_id_delta");
+          }
+          else
+          {
+            int coef_num = Math.min(64, (1 << (4 + (i << 1))));
+            if (i > 1)
+            {
+              bsr.readUE("scaling_list_dc_coef_minus8");
+            }
+            for (int k = 0; k < coef_num; k++)
+            {
+              bsr.readUE("scaling_list_delta_coef");
             }
+          }
         }
+      }
     }
 
 
-    private static void profile_tier_level(int maxNumSubLayersMinus1, CAVLCReader bsr) throws IOException {
-        int general_profile_space = bsr.readU(2, "general_profile_space");
-        boolean general_tier_flag = bsr.readBool("general_tier_flag");
-        int general_profile_idc = bsr.readU(5, "general_profile_idc");
-        boolean general_profile_compatibility_flag[] = new boolean[32];
-        for (int j = 0; j < 32; j++) {
-            general_profile_compatibility_flag[j] = bsr.readBool();
-        }
-        boolean general_progressive_source_flag = bsr.readBool("general_progressive_source_flag");
-        boolean general_interlaced_source_flag = bsr.readBool("general_interlaced_source_flag");
-        boolean general_non_packed_constraint_flag = bsr.readBool("general_non_packed_constraint_flag");
-        boolean general_frame_only_constraint_flag = bsr.readBool("general_frame_only_constraint_flag");
-        long general_reserved_zero_44bits = bsr.readNBit(44, "general_reserved_zero_44bits");
-        int general_level_idc = bsr.readByte();
+    private void profile_tier_level(int maxNumSubLayersMinus1, CAVLCReader bsr) throws IOException {
+        general_profile_space = bsr.readU(2, "general_profile_space");
+        general_tier_flag = bsr.readBool("general_tier_flag");
+        general_profile_idc = bsr.readU(5, "general_profile_idc");
+        general_profile_compatibility_flags = bsr.readNBit(32);
+        general_constraint_indicator_flags = bsr.readNBit(48);
+        general_level_idc = (byte) bsr.readByte();
         boolean[] sub_layer_profile_present_flag = new boolean[maxNumSubLayersMinus1];
         boolean[] sub_layer_level_present_flag = new boolean[maxNumSubLayersMinus1];
         for (int i = 0; i < maxNumSubLayersMinus1; i++) {
diff --git a/muxer/src/main/java/org/mp4parser/muxer/tracks/h265/VuiParameters.java b/muxer/src/main/java/org/mp4parser/muxer/tracks/h265/VuiParameters.java
index a68582d7..7744ec39 100644
--- a/muxer/src/main/java/org/mp4parser/muxer/tracks/h265/VuiParameters.java
+++ b/muxer/src/main/java/org/mp4parser/muxer/tracks/h265/VuiParameters.java
@@ -5,12 +5,11 @@
 import java.io.IOException;
 
 public class VuiParameters {
-    private static int EXTENDED_SAR = 255;
+    private static final int EXTENDED_SAR = 255;
     public boolean aspect_ratio_info_present_flag;
     public int aspect_ratio_idc;
     public int sar_width;
     public int sar_height;
-
     public boolean video_signal_type_present_flag;
     public int video_format;
     public boolean video_full_range_flag;
@@ -18,6 +17,10 @@
     public int colour_primaries;
     public int transfer_characteristics;
     public int matrix_coeffs;
+    public boolean vui_timing_info_present_flag = false;
+    public long vui_num_units_in_tick;
+    public long vui_time_scale;
+    public int min_spatial_segmentation_idc;
 
 
     public VuiParameters(int sps_max_sub_layers_minus1, CAVLCReader bsr) throws IOException {
@@ -60,10 +63,10 @@ public VuiParameters(int sps_max_sub_layers_minus1, CAVLCReader bsr) throws IOEx
             int def_disp_win_top_offset = bsr.readUE("def_disp_win_top_offset");
             int def_disp_win_bottom_offset = bsr.readUE("def_disp_win_bottom_offset");
         }
-        boolean vui_timing_info_present_flag = bsr.readBool("vui_timing_info_present_flag");
+        vui_timing_info_present_flag = bsr.readBool("vui_timing_info_present_flag");
         if (vui_timing_info_present_flag) {
-            long vui_num_units_in_tick = bsr.readNBit(32, "vui_num_units_in_tick");
-            long vui_time_scale = bsr.readNBit(32, "vui_time_scale");
+            vui_num_units_in_tick = bsr.readNBit(32, "vui_num_units_in_tick");
+            vui_time_scale = bsr.readNBit(32, "vui_time_scale");
             boolean vui_poc_proportional_to_timing_flag = bsr.readBool("vui_poc_proportional_to_timing_flag");
             if (vui_poc_proportional_to_timing_flag) {
                 int vui_num_ticks_poc_diff_one_minus1 = bsr.readUE("vui_num_ticks_poc_diff_one_minus1");
@@ -78,7 +81,7 @@ public VuiParameters(int sps_max_sub_layers_minus1, CAVLCReader bsr) throws IOEx
             boolean tiles_fixed_structure_flag = bsr.readBool("tiles_fixed_structure_flag");
             boolean motion_vectors_over_pic_boundaries_flag = bsr.readBool("motion_vectors_over_pic_boundaries_flag");
             boolean restricted_ref_pic_lists_flag = bsr.readBool("restricted_ref_pic_lists_flag");
-            int min_spatial_segmentation_idc = bsr.readUE("min_spatial_segmentation_idc");
+            min_spatial_segmentation_idc = bsr.readUE("min_spatial_segmentation_idc");
             int max_bytes_per_pic_denom = bsr.readUE("max_bytes_per_pic_denom");
             int max_bits_per_min_cu_denom = bsr.readUE("max_bits_per_min_cu_denom");
             int log2_max_mv_length_horizontal = bsr.readUE("log2_max_mv_length_horizontal");
diff --git a/muxer/src/test/java/org/mp4parser/muxer/tracks/H264TrackImplTest.java b/muxer/src/test/java/org/mp4parser/muxer/tracks/H264TrackImplTest.java
index 0b828f7c..d7ff29b9 100644
--- a/muxer/src/test/java/org/mp4parser/muxer/tracks/H264TrackImplTest.java
+++ b/muxer/src/test/java/org/mp4parser/muxer/tracks/H264TrackImplTest.java
@@ -45,7 +45,7 @@ public void freeze() throws IOException {
         DefaultMp4Builder mp4Builder = new DefaultMp4Builder();
         Container c = mp4Builder.build(m);
 
-//        c.writeContainer(new FileOutputStream("C:\\dev\\mp4parser\\muxer\\src\\test\\resources\\org\\mp4parser\\muxer\\tracks\\h264-sample.mp4").getChannel());
+      // c.writeContainer(new FileOutputStream("/Users/sannies/dev/mp4parser/muxer/src/test/resources/org/mp4parser/muxer/tracks/h264-sample.mp4").getChannel());
 
 
         IsoFile isoFileReference = new IsoFile(getClass().getProtectionDomain().getCodeSource().getLocation().getFile() + "org/mp4parser/muxer/tracks/h264-sample.mp4");
diff --git a/muxer/src/test/resources/org/mp4parser/muxer/tracks/h264-sample.mp4 b/muxer/src/test/resources/org/mp4parser/muxer/tracks/h264-sample.mp4
index d67e20ad..91062a4f 100644
Binary files a/muxer/src/test/resources/org/mp4parser/muxer/tracks/h264-sample.mp4 and b/muxer/src/test/resources/org/mp4parser/muxer/tracks/h264-sample.mp4 differ
diff --git a/pom.xml b/pom.xml
index a25f1ca5..8637adc9 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,7 +3,7 @@
     <groupId>org.mp4parser</groupId>
     <artifactId>mp4parser-project</artifactId>
     <packaging>pom</packaging>
-    <version>1.9.35-SNAPSHOT</version>
+    <version>1.9.38-SNAPSHOT</version>
     <name>MP4 Parser Project</name>
     <url>https://github.com/sannies/mp4parser</url>
     <licenses>
@@ -85,6 +85,6 @@
     <scm>
         <url>https://github.com/sannies/mp4parser</url>
         <connection>scm:git:git@github.com:sannies/mp4parser.git</connection>
-        <tag>mp4parser-project-1.9.5</tag>
+        <tag>mp4parser-project-1.9.35</tag>
     </scm>
 </project>
diff --git a/streaming/pom.xml b/streaming/pom.xml
index c6dda8dd..4cb0e718 100644
--- a/streaming/pom.xml
+++ b/streaming/pom.xml
@@ -3,12 +3,12 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>org.mp4parser</groupId>
     <artifactId>streaming</artifactId>
-    <version>1.9.35-SNAPSHOT</version>
+    <version>1.9.38-SNAPSHOT</version>
     <dependencies>
         <dependency>
             <groupId>org.mp4parser</groupId>
             <artifactId>isoparser</artifactId>
-            <version>1.9.35-SNAPSHOT</version>
+            <version>1.9.38-SNAPSHOT</version>
         </dependency>
         <dependency>
             <groupId>junit</groupId>
@@ -19,7 +19,7 @@
         <dependency>
             <groupId>org.mp4parser</groupId>
             <artifactId>muxer</artifactId>
-            <version>1.9.35-SNAPSHOT</version>
+            <version>1.9.38-SNAPSHOT</version>
             <scope>test</scope>
         </dependency>
         <dependency>
@@ -124,6 +124,6 @@
     </developers>
     <scm>
         <url>https://github.com/sannies/mp4parser</url>
-        <tag>mp4parser-project-1.9.5</tag>
+        <tag>mp4parser-project-1.9.35</tag>
     </scm>
 </project>
\ No newline at end of file
