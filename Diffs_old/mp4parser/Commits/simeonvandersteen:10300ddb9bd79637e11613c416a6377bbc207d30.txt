diff --git a/examples/pom.xml b/examples/pom.xml
index e3fe13cc..b5ac542b 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -57,7 +57,11 @@
             <artifactId>commons-collections</artifactId>
             <version>3.2.2</version>
         </dependency>
-
+        <dependency>
+            <groupId>org.apache.httpcomponents</groupId>
+            <artifactId>httpclient</artifactId>
+            <version>4.5.3</version>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/examples/src/main/java/com/googlecode/mp4parser/muxformats/AacExample.java b/examples/src/main/java/com/googlecode/mp4parser/muxformats/AacExample.java
index 7a362af6..364f1ef0 100644
--- a/examples/src/main/java/com/googlecode/mp4parser/muxformats/AacExample.java
+++ b/examples/src/main/java/com/googlecode/mp4parser/muxformats/AacExample.java
@@ -3,9 +3,9 @@
 import org.mp4parser.Container;
 import org.mp4parser.muxer.FileDataSourceImpl;
 import org.mp4parser.muxer.Movie;
-import org.mp4parser.muxer.builder.DefaultMp4Builder;
+import org.mp4parser.muxer.builder.EmsgFragmentedMp4Builder;
+import org.mp4parser.muxer.builder.Mp4Builder;
 import org.mp4parser.muxer.tracks.AACTrackImpl;
-import org.mp4parser.muxer.tracks.h264.H264TrackImpl;
 
 import java.io.FileOutputStream;
 import java.io.IOException;
@@ -21,16 +21,20 @@
 public class AacExample {
     public static void main(String[] args) throws IOException {
 
-        AACTrackImpl aacTrack = new AACTrackImpl(new FileDataSourceImpl("C:\\content\\Cosmos Laundromat small.aac"));
-        H264TrackImpl h264Track = new H264TrackImpl(new FileDataSourceImpl("C:\\content\\Cosmos Laundromat small.264"));
+        System.out.println("Working Directory = " +
+                System.getProperty("user.dir"));
+
+        AACTrackImpl aacTrack = new AACTrackImpl(new FileDataSourceImpl("./test.aac"));
+        //H264TrackImpl h264Track = new H264TrackImpl(new FileDataSourceImpl("C:\\content\\Cosmos Laundromat small.264"));
         Movie m = new Movie();
         m.addTrack(aacTrack);
-        m.addTrack(h264Track);
-        DefaultMp4Builder mp4Builder = new DefaultMp4Builder();
+        //m.addTrack(h264Track);
+        Mp4Builder mp4Builder = new EmsgFragmentedMp4Builder();
+
         Container out = mp4Builder.build(m);
         FileOutputStream fos = new FileOutputStream("output.mp4");
-        FileChannel fc = fos.getChannel();
-        out.writeContainer(fc);
+        out.writeContainer(fos.getChannel());
+
 
         fos.close();
     }
diff --git a/examples/src/main/java/uk/co/bbc/packager/Main.java b/examples/src/main/java/uk/co/bbc/packager/Main.java
new file mode 100644
index 00000000..c5200743
--- /dev/null
+++ b/examples/src/main/java/uk/co/bbc/packager/Main.java
@@ -0,0 +1,116 @@
+package uk.co.bbc.packager;
+
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.FileEntity;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.mp4parser.Container;
+import org.mp4parser.muxer.MemoryDataSourceImpl;
+import org.mp4parser.muxer.Movie;
+import org.mp4parser.muxer.builder.EmsgFragmentedMp4Builder;
+import org.mp4parser.muxer.builder.Mp4Builder;
+import org.mp4parser.muxer.tracks.AACTrackImpl;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.channels.ByteChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+public class Main {
+
+    private static final String USP_URL = "";
+
+    private int previousChunk = 0;
+
+    private static final CloseableHttpClient httpClient = HttpClientBuilder.create().build();
+
+    private String getNextFilename() {
+        // TODO use actual timecodes, or whatever
+        return String.format("./somefile-%d.aac", ++previousChunk);
+    }
+
+    private ByteBuffer getFileOrWait(String fileName) throws InterruptedException, IOException {
+        Path path = Paths.get(fileName);
+
+        System.out.println(String.format("Waiting for %s", fileName));
+
+        while (!Files.exists(path)) {
+            Thread.sleep(10);
+        }
+
+        System.out.println(String.format("Found %s", fileName));
+
+        return ByteBuffer.wrap(Files.readAllBytes(path));
+    }
+
+    private void wrapInMp4(ByteBuffer buffer, ByteChannel channel) throws IOException {
+
+        AACTrackImpl aacTrack = new AACTrackImpl(new MemoryDataSourceImpl(buffer));
+
+        Movie m = new Movie();
+
+        m.addTrack(aacTrack);
+
+        Mp4Builder mp4Builder = new EmsgFragmentedMp4Builder();
+
+        Container out = mp4Builder.build(m);
+
+        out.writeContainer(channel);
+    }
+
+    private void sendPiffChunk() throws IOException {
+
+        HttpPost post = new HttpPost(USP_URL);
+
+        post.setEntity(new FileEntity(new File("./.tmp-box")));
+
+        try (CloseableHttpResponse response = httpClient.execute(post)) {
+            int code = response.getStatusLine().getStatusCode();
+
+            if (code != HttpStatus.SC_OK) {
+                System.err.println("Http POST returned non-200: " + code);
+            }
+
+        } catch (IOException e) {
+            e.printStackTrace();
+            System.err.println("Http POST failed");
+        }
+    }
+
+    private void run() throws IOException, InterruptedException {
+
+        String fileName = getNextFilename();
+
+        ByteBuffer inBuffer = getFileOrWait(fileName);
+
+        try (FileOutputStream fos = new FileOutputStream("./.tmp-box")) {
+
+            System.out.println("Wrapping aac in mp4");
+            wrapInMp4(inBuffer, fos.getChannel());
+
+            System.out.println("Start sending chunk to USP");
+            sendPiffChunk();
+        }
+    }
+
+    public static void main(String[] args) throws IOException {
+        try {
+            Main main = new Main();
+            while (true) {
+                main.run();
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            System.out.println("We're done here.");
+        } finally {
+            httpClient.close();
+        }
+    }
+}
diff --git a/isoparser/src/main/java/org/mp4parser/BasicContainer.java b/isoparser/src/main/java/org/mp4parser/BasicContainer.java
index 9151a14a..71104c5e 100644
--- a/isoparser/src/main/java/org/mp4parser/BasicContainer.java
+++ b/isoparser/src/main/java/org/mp4parser/BasicContainer.java
@@ -30,7 +30,7 @@ protected long getContainerSize() {
         long contentSize = 0;
         for (int i = 0; i < getBoxes().size(); i++) {
             // it's quicker to iterate an array list like that since no iterator
-            // needs to be instantiated
+            // needs to be instantiatedBasicContainer
             contentSize += boxes.get(i).getSize();
         }
         return contentSize;
diff --git a/isoparser/src/main/java/org/mp4parser/boxes/KindBox.java b/isoparser/src/main/java/org/mp4parser/boxes/KindBox.java
new file mode 100644
index 00000000..18307562
--- /dev/null
+++ b/isoparser/src/main/java/org/mp4parser/boxes/KindBox.java
@@ -0,0 +1,38 @@
+package org.mp4parser.boxes;
+
+import org.mp4parser.support.AbstractFullBox;
+import org.mp4parser.tools.IsoTypeReader;
+import org.mp4parser.tools.IsoTypeWriter;
+
+import java.nio.ByteBuffer;
+
+public class KindBox extends AbstractFullBox {
+	private String scheme_id_uri;
+	private String value;
+
+	public KindBox(String scheme_id_uri, String value) {
+		super("kind");
+		this.scheme_id_uri = scheme_id_uri;
+		this.value = value;
+	}
+
+	@Override
+	protected long getContentSize() {
+		ByteBuffer byteBuffer = ByteBuffer.allocate(4096);
+		getContent(byteBuffer);
+		return byteBuffer.position();
+	}
+
+	@Override
+	protected void getContent(ByteBuffer byteBuffer) {
+		writeVersionAndFlags(byteBuffer);
+		IsoTypeWriter.writeUtf8String(byteBuffer, this.scheme_id_uri);
+		IsoTypeWriter.writeUtf8String(byteBuffer, this.value);
+	}
+
+	@Override
+	protected void _parseDetails(ByteBuffer content) {
+		scheme_id_uri = IsoTypeReader.readString(content);
+		value = IsoTypeReader.readString(content);
+	}
+}
\ No newline at end of file
diff --git a/muxer/src/main/java/org/mp4parser/muxer/builder/EmsgFragmentedMp4Builder.java b/muxer/src/main/java/org/mp4parser/muxer/builder/EmsgFragmentedMp4Builder.java
new file mode 100644
index 00000000..f53cc9d5
--- /dev/null
+++ b/muxer/src/main/java/org/mp4parser/muxer/builder/EmsgFragmentedMp4Builder.java
@@ -0,0 +1,156 @@
+package org.mp4parser.muxer.builder;
+
+import org.mp4parser.Box;
+import org.mp4parser.Container;
+import org.mp4parser.ParsableBox;
+import org.mp4parser.boxes.KindBox;
+import org.mp4parser.boxes.iso14496.part12.*;
+import org.mp4parser.boxes.microsoft.TfxdBox;
+import org.mp4parser.boxes.samplegrouping.GroupEntry;
+import org.mp4parser.boxes.samplegrouping.SampleGroupDescriptionBox;
+import org.mp4parser.boxes.samplegrouping.SampleToGroupBox;
+import org.mp4parser.muxer.Movie;
+import org.mp4parser.muxer.Track;
+
+import java.util.*;
+
+import static org.mp4parser.tools.CastUtils.l2i;
+
+public class EmsgFragmentedMp4Builder extends FragmentedMp4Builder {
+    private long offset = 0L;
+
+    // Dumb down the original version and always just add an nmhd
+    protected ParsableBox createMinf(Track track, Movie movie) {
+        MediaInformationBox minf = new MediaInformationBox();
+        minf.addBox(new NullMediaHeaderBox());
+        minf.addBox(createDinf(movie, track));
+        minf.addBox(createStbl(movie, track));
+        return minf;
+    }
+
+    // Exten the original to add the user metadata
+    protected ParsableBox createTrak(Track track, Movie movie) {
+        TrackBox trackBox = new TrackBox();
+        trackBox.addBox(createTkhd(movie, track));
+
+        UserDataBox userDataBox = new UserDataBox();
+        KindBox kindBox = new KindBox("urn:mpeg:dash:event:2012", "1");
+        userDataBox = new UserDataBox();
+        userDataBox.addBox(kindBox);
+        trackBox.addBox(userDataBox);
+
+        Box edts = createEdts(track, movie);
+        if (edts != null) {
+            trackBox.addBox(edts);
+        }
+        trackBox.addBox(createMdia(track, movie));
+        return trackBox;
+    }
+
+    protected void createTfdt(long startSample, Track track, TrackFragmentBox parent) {
+        TrackFragmentBaseMediaDecodeTimeBox tfdt = new TrackFragmentBaseMediaDecodeTimeBox();
+        tfdt.setVersion(1);
+        tfdt.setBaseMediaDecodeTime(getBaseMediaDecodeTime(startSample, track));
+        parent.addBox(tfdt);
+    }
+
+    // The original version doesn't add a tfxd
+    @Override
+    protected void createTraf(long startSample, long endSample, Track track, int sequenceNumber, MovieFragmentBox parent) {
+        TrackFragmentBox traf = new TrackFragmentBox();
+        parent.addBox(traf);
+        createTfhd(startSample, endSample, track, sequenceNumber, traf);
+        createTfdt(startSample, track, traf);
+        createTrun(startSample, endSample, track, sequenceNumber, traf);
+
+        Map<String, List<GroupEntry>> groupEntryFamilies = new HashMap<String, List<GroupEntry>>();
+        for (Map.Entry<GroupEntry, long[]> sg : track.getSampleGroups().entrySet()) {
+            String type = sg.getKey().getType();
+            List<GroupEntry> groupEntries = groupEntryFamilies.get(type);
+            if (groupEntries == null) {
+                groupEntries = new ArrayList<GroupEntry>();
+                groupEntryFamilies.put(type, groupEntries);
+            }
+            groupEntries.add(sg.getKey());
+        }
+
+
+        for (Map.Entry<String, List<GroupEntry>> sg : groupEntryFamilies.entrySet()) {
+            SampleGroupDescriptionBox sgpd = new SampleGroupDescriptionBox();
+            String type = sg.getKey();
+            sgpd.setGroupEntries(sg.getValue());
+            sgpd.setGroupingType(type);
+            SampleToGroupBox sbgp = new SampleToGroupBox();
+            sbgp.setGroupingType(type);
+            SampleToGroupBox.Entry last = null;
+            for (int i = l2i(startSample - 1); i < l2i(endSample - 1); i++) {
+                int index = 0;
+                for (int j = 0; j < sg.getValue().size(); j++) {
+                    GroupEntry groupEntry = sg.getValue().get(j);
+                    long[] sampleNums = track.getSampleGroups().get(groupEntry);
+                    if (Arrays.binarySearch(sampleNums, i) >= 0) {
+                        index = j + 0x10001;
+                    }
+                }
+                if (last == null || last.getGroupDescriptionIndex() != index) {
+                    last = new SampleToGroupBox.Entry(1, index);
+                    sbgp.getEntries().add(last);
+                } else {
+                    last.setSampleCount(last.getSampleCount() + 1);
+                }
+            }
+            traf.addBox(sgpd);
+            traf.addBox(sbgp);
+        }
+
+        createTfxd(startSample, track, traf);
+    }
+
+    protected void createTfxd(long startSample, Track track, TrackFragmentBox parent) {
+        TfxdBox tfxd = new TfxdBox();
+        tfxd.fragmentAbsoluteTime = getBaseMediaDecodeTime(startSample, track);
+        tfxd.fragmentAbsoluteDuration = getSampleDuration(startSample, track);
+        tfxd.setVersion(1);
+        parent.addBox(tfxd);
+    }
+
+    protected ParsableBox createMoof(long startSample, long endSample, Track track, int sequenceNumber) {
+        MovieFragmentBox moof = new MovieFragmentBox();
+        createMfhd(startSample, endSample, track, sequenceNumber, moof);
+        createTraf(startSample, endSample, track, sequenceNumber, moof);
+
+        TrackRunBox firstTrun = moof.getTrackRunBoxes().get(0);
+        firstTrun.setDataOffset(1); // dummy to make size correct
+        firstTrun.setDataOffset((int) (8 + moof.getSize())); // mdat header + moof size
+
+        return moof;
+    }
+
+    // CodeShop require no Tfra boxes in the Mfra
+    @Override
+    protected ParsableBox createMfra(Movie movie, Container isoFile) {
+        MovieFragmentRandomAccessBox mfra = new MovieFragmentRandomAccessBox();
+        MovieFragmentRandomAccessOffsetBox mfro = new MovieFragmentRandomAccessOffsetBox();
+        mfra.addBox(mfro);
+        mfro.setMfraSize(mfra.getSize());
+        return mfra;
+    }
+
+    protected long getBaseMediaDecodeTime(long startSample, Track track) {
+        long startTime = offset;
+        long[] times = track.getSampleDurations();
+        for (int i = 1; i < startSample; i++) {
+            startTime += times[i - 1];
+        }
+        return startTime;
+    }
+
+    protected long getSampleDuration(long startSample, Track track) {
+        long times[] = track.getSampleDurations();
+        return times[(int) startSample - 1];
+    }
+
+    protected void setOffset(long offset) {
+        this.offset = offset;
+    }
+}
