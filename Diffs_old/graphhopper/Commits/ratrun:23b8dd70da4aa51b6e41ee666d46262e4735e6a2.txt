diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
index c43771be9b..225a335027 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
@@ -44,20 +44,18 @@
     private final List<SpatialRule> singleRules = new ArrayList<>();
 
     /**
-     * @param spatialRules     the spatial rules
-     * @param resolution of the array in decimal degrees, see: https://en.wikipedia.org/wiki/Decimal_degrees
-     *                   The downside of using decimal degrees is that this is not fixed to a certain m range as
-     * @param exact      if exact it will also perform a polygon contains for border tiles, might fail for small holes
-     *                   in the Polygon that are not represented in the tile array.
-     * @param bounds create the SpatialRuleLookup for the given BBox
+     * @param spatialRules the spatial rules
+     * @param resolution   of the array in decimal degrees, see: https://en.wikipedia.org/wiki/Decimal_degrees
+     *                     The downside of using decimal degrees is that this is not fixed to a certain m range as
+     * @param exact        if exact it will also perform a polygon contains for border tiles, might fail for small holes
+     *                     in the Polygon that are not represented in the tile array.
+     * @param bounds       create the SpatialRuleLookup for the given BBox
      */
     public SpatialRuleLookupArray(List<SpatialRule> spatialRules, double resolution, boolean exact, BBox bounds) {
-
-        if(!bounds.isValid())
-            throw new IllegalStateException("Bounds are not valid: "+bounds);
+        if (!bounds.isValid())
+            throw new IllegalStateException("Bounds are not valid: " + bounds);
 
         this.bounds = bounds;
-
         if (resolution < 1e-100)
             throw new IllegalArgumentException("resolution cannot be that high " + resolution);
 
@@ -106,9 +104,7 @@ public SpatialRule lookupRule(double lat, double lon) {
         int ruleIndex = getRuleContainerIndex(xIndex, yIndex);
         SpatialRuleContainer ruleContainer = ruleContainers.get(ruleIndex);
         if (ruleContainer.size() == 1) {
-            if (!exact)
-                return ruleContainer.first();
-            if (!isBorderTile(xIndex, yIndex, ruleIndex))
+            if (!exact || !isBorderTile(xIndex, yIndex, ruleIndex))
                 return ruleContainer.first();
         }
 
@@ -153,13 +149,13 @@ public SpatialRule lookupRule(GHPoint point) {
     }
 
     private int getXIndexForLon(double lon) {
-        if(lon < bounds.minLon)
+        if (lon < bounds.minLon)
             return 0;
         return (int) Math.floor(Math.abs(lon - bounds.minLon) / resolution);
     }
 
     private int getYIndexForLat(double lat) {
-        if(lat < bounds.minLat)
+        if (lat < bounds.minLat)
             return 0;
         return (int) Math.floor(Math.abs(lat - bounds.minLat) / resolution);
     }
@@ -174,13 +170,13 @@ private void addRuleInternal(SpatialRule rule) {
         addSingleRule(rule);
         int ruleContainerIndex = addRuleContainer(new SpatialRuleContainer().addRule(rule));
         for (Polygon polygon : rule.getBorders()) {
-            for (int i = getXIndexForLon(polygon.getMinLon()); i < getXIndexForLon(polygon.getMaxLon()) + 1; i++) {
-                for (int j = getYIndexForLat(polygon.getMinLat()); j < getYIndexForLat(polygon.getMaxLat()) + 1; j++) {
-                    if (i >= lookupArray.length || j >= lookupArray[0].length) {
+            for (int xIdx = getXIndexForLon(polygon.getMinLon()); xIdx < getXIndexForLon(polygon.getMaxLon()) + 1; xIdx++) {
+                for (int yIdx = getYIndexForLat(polygon.getMinLat()); yIdx < getYIndexForLat(polygon.getMaxLat()) + 1; yIdx++) {
+                    if (xIdx >= lookupArray.length || yIdx >= lookupArray[0].length) {
                         continue;
                     }
 
-                    GHPoint center = getCoordinatesForIndex(i, j);
+                    GHPoint center = getCoordinatesForIndex(xIdx, yIdx);
                     // TODO: Consider creating a new method in Polygon that does the 5 checks - p.partOfTile?
                     if (polygon.contains(center) ||
                             polygon.contains(center.getLat() - checkDiff, center.getLon() - checkDiff) ||
@@ -188,14 +184,14 @@ private void addRuleInternal(SpatialRule rule) {
                             polygon.contains(center.getLat() + checkDiff, center.getLon() - checkDiff) ||
                             polygon.contains(center.getLat() + checkDiff, center.getLon() + checkDiff)) {
 
-                        if (lookupArray[i][j] == EMPTY_RULE_INDEX) {
-                            lookupArray[i][j] = (byte) ruleContainerIndex;
+                        if (lookupArray[xIdx][yIdx] == EMPTY_RULE_INDEX) {
+                            lookupArray[xIdx][yIdx] = (byte) ruleContainerIndex;
                         } else {
                             // Merge Rules
-                            SpatialRuleContainer curContainer = getContainerFor2DIndex(i, j);
+                            SpatialRuleContainer curContainer = getContainerFor2DIndex(xIdx, yIdx);
                             SpatialRuleContainer newContainer = curContainer.copy().addRule(rule);
                             int newRuleContainerIndex = addRuleContainer(newContainer);
-                            lookupArray[i][j] = (byte) newRuleContainerIndex;
+                            lookupArray[xIdx][yIdx] = (byte) newRuleContainerIndex;
                         }
                     }
                 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
index 86fcb38564..f82f24ca74 100644
--- a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
@@ -33,8 +33,8 @@ public String getId() {
         }.addBorder(new Polygon(new double[]{5, 5, 6, 6}, new double[]{5, 6, 6, 5}));
         spatialRules.add(austria);
 
+        // create lookup with bbox just for DEU (for space reduction)
         SpatialRuleLookupArray lookup = new SpatialRuleLookupArray(spatialRules, 1, false, new BBox(1, 2, 1, 2));
-
         SpatialRule rule = lookup.lookupRule(1.5, 1.5);
         assertEquals(germany, rule);
         assertEquals("DEU", rule.getId());
@@ -149,7 +149,7 @@ private Polygon parsePolygonString(String polygonString) {
     }
 
     private SpatialRule getSpatialRule(Polygon p, final String name) {
-        AbstractSpatialRule rule = new AbstractSpatialRule() {
+        return new AbstractSpatialRule() {
             @Override
             public double getMaxSpeed(String highwayTag, double _default) {
                 return _default;
@@ -164,8 +164,6 @@ public AccessValue getAccessValue(String highwayTag, TransportationMode transpor
             public String getId() {
                 return name;
             }
-        };
-        rule.addBorder(p);
-        return rule;
+        }.addBorder(p);
     }
 }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
index e317a7f85d..76e8416748 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperModule.java
@@ -115,7 +115,7 @@ public String getId() {
             try {
                 final BBox maxBounds = BBox.parseBBoxString(args.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
                 final FileReader reader = new FileReader(spatialRuleLocation);
-                final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), maxBounds);
+                final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, maxBounds);
                 logger.info("Set spatial rule lookup with " + index.size() + " rules");
                 final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
                 graphHopper.setFlagEncoderFactory(new FlagEncoderFactory() {
diff --git a/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java b/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
index a0d387b164..c307f1f0ee 100644
--- a/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
+++ b/web/src/main/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilder.java
@@ -24,24 +24,25 @@
      * Builds a SpatialRuleLookup by passing the provided JSON features into the provided
      * SpatialRuleFactory and collecting all the SpatialRule instances that it returns,
      * ignoring when it returns SpatialRule.EMPTY.
-     *
+     * <p>
      * See {@link SpatialRuleLookup} and {@link SpatialRule}.
      *
      * @param jsonFeatureCollection a feature collection
-     * @param jsonIdField the name of a property in that feature collection which serves as an id
-     * @param spatialRuleFactory a factory which is called with all the (id, geometry) pairs.
-     *                           It should provide a SpatialRule for each id it knows about,
-     *                           and SpatialRule.EMPTY otherwise.
-     * @param maxBBox limit the maximum BBox of the SpatialRuleLookup to the given BBox
+     * @param jsonIdField           the name of a property in that feature collection which serves as an id
+     * @param spatialRuleFactory    a factory which is called with all the (id, geometry) pairs.
+     *                              It should provide a SpatialRule for each id it knows about,
+     *                              and SpatialRule.EMPTY otherwise.
+     * @param maxBBox               limit the maximum BBox of the SpatialRuleLookup to the given BBox
      * @return the fully constructed SpatialRuleLookup.
      */
-    public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureCollection, String jsonIdField, SpatialRuleFactory spatialRuleFactory, BBox maxBBox) {
+    public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureCollection, String jsonIdField,
+                                               SpatialRuleFactory spatialRuleFactory, double resolution, BBox maxBBox) {
         BBox polygonBounds = BBox.createInverse(false);
         List<SpatialRule> spatialRules = new ArrayList<>();
         for (JsonFeature jsonFeature : jsonFeatureCollection.getFeatures()) {
             String id = (String) jsonFeature.getProperty(jsonIdField);
             List<Polygon> borders = new ArrayList<>();
-            for (int i=0; i<jsonFeature.getGeometry().getNumGeometries(); i++) {
+            for (int i = 0; i < jsonFeature.getGeometry().getNumGeometries(); i++) {
                 borders.add(ghPolygonFromJTS((com.vividsolutions.jts.geom.Polygon) jsonFeature.getGeometry().getGeometryN(i)));
             }
             SpatialRule spatialRule = spatialRuleFactory.createSpatialRule(id, borders);
@@ -62,7 +63,7 @@ public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureColl
         if (calculatedBounds == null)
             return SpatialRuleLookup.EMPTY;
 
-        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 0.1, true, calculatedBounds);
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, resolution, true, calculatedBounds);
 
         logger.info("Created the SpatialRuleLookup with the following rules: " + Arrays.toString(spatialRules.toArray()));
 
@@ -70,17 +71,17 @@ public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureColl
     }
 
     /**
-     * Wrapper Method for {@link SpatialRuleLookupBuilder#buildIndex(JsonFeatureCollection, String, SpatialRuleFactory, BBox)}.
+     * Wrapper Method for {@link SpatialRuleLookupBuilder#buildIndex(JsonFeatureCollection, String, SpatialRuleFactory, double, BBox)}.
      * This method simply passes a world-wide BBox, this won't limit the SpatialRuleLookup.
      */
     public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureCollection, String jsonIdField, SpatialRuleFactory spatialRuleFactory) {
-        return buildIndex(jsonFeatureCollection, jsonIdField, spatialRuleFactory, new BBox(-180, 180, -90, 90));
+        return buildIndex(jsonFeatureCollection, jsonIdField, spatialRuleFactory, .1, new BBox(-180, 180, -90, 90));
     }
 
     private static Polygon ghPolygonFromJTS(com.vividsolutions.jts.geom.Polygon polygon) {
         double[] lats = new double[polygon.getNumPoints()];
         double[] lons = new double[polygon.getNumPoints()];
-        for (int i=0; i<polygon.getNumPoints(); i++) {
+        for (int i = 0; i < polygon.getNumPoints(); i++) {
             lats[i] = polygon.getCoordinates()[i].y;
             lons[i] = polygon.getCoordinates()[i].x;
         }
diff --git a/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java b/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
index 24f2fef903..39198d7361 100644
--- a/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
+++ b/web/src/test/java/com/graphhopper/spatialrules/SpatialRuleLookupBuilderTest.java
@@ -60,7 +60,7 @@ public void testIndex() {
     @Test
     public void testBounds() {
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, 180, -90, 90));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(-180, 180, -90, 90));
         BBox almostWorldWide = new BBox(-179, 179, -89, 89);
 
         // Might fail if a polygon is defined outside the above coordinates
@@ -74,14 +74,14 @@ public void testIntersection() {
              So the BBox should not contain a Point lying somewhere close in Germany.
           */
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(9, 10, 51, 52));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(9, 10, 51, 52));
         assertFalse("BBox seems to be incorrectly contracted", spatialRuleLookup.getBounds().contains(49.9, 8.9));
     }
 
     @Test
     public void testNoIntersection() {
         Reader reader = new InputStreamReader(SpatialRuleLookupBuilderTest.class.getResourceAsStream("countries.geo.json"));
-        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), new BBox(-180, -179, -90, -89));
+        SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(new GHJsonFactory().create().fromJson(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory(), .1, new BBox(-180, -179, -90, -89));
         assertEquals(SpatialRuleLookup.EMPTY, spatialRuleLookup);
     }
 
