diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/beans/RouteWayPoint.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/beans/RouteWayPoint.java
index 495bbbe301..6448509d55 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/beans/RouteWayPoint.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/beans/RouteWayPoint.java
@@ -10,7 +10,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperGPXParserRouteTest;
+import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperGPXParser;
 
 public class RouteWayPoint {
 
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXParser.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXParser.java
new file mode 100644
index 0000000000..d2792856e2
--- /dev/null
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXParser.java
@@ -0,0 +1,124 @@
+package uk.co.ordnancesurvey.gpx.graphhopper;
+
+import java.io.ByteArrayInputStream;
+import java.io.FileInputStream;
+import java.util.ArrayList;
+import java.util.HashSet;
+
+import org.alternativevision.gpx.GPXParser;
+import org.alternativevision.gpx.beans.GPX;
+import org.alternativevision.gpx.beans.Route;
+import org.alternativevision.gpx.beans.Track;
+import org.alternativevision.gpx.beans.Waypoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import uk.co.ordnancesurvey.gpx.extensions.RoutePointAzimuthParser;
+import uk.co.ordnancesurvey.gpx.extensions.RoutePointDirectionParser;
+import uk.co.ordnancesurvey.gpx.extensions.RoutePointDistanceParser;
+import uk.co.ordnancesurvey.gpx.extensions.RoutePointTimeParser;
+
+public class GraphHopperGPXParser {
+
+	private static final Logger LOG = LoggerFactory
+			.getLogger(GraphHopperGPXParser.class);
+
+	private GPXParser gpxParser;
+	private GPX gpx;
+
+	public GraphHopperGPXParser() {
+		init();
+	}
+
+	public static GraphHopperGPXParser getParserForgpxString(String gpxString) {
+
+		GraphHopperGPXParser instance = new GraphHopperGPXParser();
+		instance.parseGPXFromString(gpxString);
+
+		return instance;
+	}
+
+	private void init() {
+
+		gpxParser = new GPXParser();
+		RoutePointDistanceParser rPDEP = new RoutePointDistanceParser();
+		RoutePointTimeParser rPTEP = new RoutePointTimeParser();
+		RoutePointAzimuthParser rPAEP = new RoutePointAzimuthParser();
+		RoutePointDirectionParser rPDIEP = new RoutePointDirectionParser();
+		gpxParser.addExtensionParser(rPDEP);
+		gpxParser.addExtensionParser(rPTEP);
+		gpxParser.addExtensionParser(rPAEP);
+		gpxParser.addExtensionParser(rPDIEP);
+
+	}
+
+	public static GraphHopperGPXParser getParserForgpxFileName(
+			String gpxFileName) {
+		GraphHopperGPXParser instance = new GraphHopperGPXParser();
+		instance.parseGPXFromFile(gpxFileName);
+
+		return instance;
+	}
+
+	public void parseGPXFromString(String gpxString) {
+		if (gpxString != null && gpxString.length() > 0) {
+			try {
+				gpx = gpxParser.parseGPX(new ByteArrayInputStream(gpxString
+						.getBytes()));
+			} catch (Exception e) {
+				LOG.info("Invalid File supplied for parsing " + e.getMessage());
+			}
+		}
+	}
+
+	private void parseGPXFromFile(String gpxFileName) {
+		if (gpxFileName != null && gpxFileName.length() > 0) {
+			try {
+				gpx = gpxParser.parseGPX(new FileInputStream(gpxFileName));
+
+			} catch (Exception e) {
+				LOG.info("Invalid File supplied for parsing " + e.getMessage());
+			}
+		}
+	}
+
+	public HashSet<Route> getRoutes() {
+		return gpx.getRoutes();
+	}
+
+	public HashSet<Track> getTracks() {
+		return gpx.getTracks();
+	}
+
+	public long getTotalRouteTime() {
+
+		long totalTimeInSceonds = 0;
+		HashSet<Track> tracks = gpx.getTracks();
+		Track track = (Track) tracks.toArray()[0];
+		ArrayList<Waypoint> trackPoints = track.getTrackPoints();
+
+		if (trackPoints.size() > 0) {
+			Waypoint sttp = trackPoints.get(0);
+			Waypoint endtp = trackPoints.get(trackPoints.size() - 1);
+			LOG.info("Start Time is " + sttp.getTime().toString());
+			LOG.info("End Time is " + endtp.getTime().toString());
+			totalTimeInSceonds = endtp.getTime().getTime()
+					- sttp.getTime().getTime();
+		}
+
+		return totalTimeInSceonds;
+	}
+
+	public String getErrorMessage() {
+
+		return (String) gpx.getExtensionData("errorMessage");
+
+	}
+
+	public int getstatusCode() {
+
+		return (Integer.parseInt((String) gpx.getExtensionData("statusCode")));
+
+	}
+
+}
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXParserRouteTest.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXParserRouteTest.java
deleted file mode 100644
index 51c1277354..0000000000
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXParserRouteTest.java
+++ /dev/null
@@ -1,360 +0,0 @@
-package uk.co.ordnancesurvey.gpx.graphhopper;
-
-import java.io.ByteArrayInputStream;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Map.Entry;
-
-import org.alternativevision.gpx.GPXParser;
-import org.alternativevision.gpx.beans.GPX;
-import org.alternativevision.gpx.beans.Route;
-import org.alternativevision.gpx.beans.Track;
-import org.alternativevision.gpx.beans.Waypoint;
-import org.apache.commons.io.IOUtils;
-import org.apache.http.client.ClientProtocolException;
-import org.apache.http.client.methods.CloseableHttpResponse;
-import org.apache.http.client.methods.HttpGet;
-import org.apache.http.impl.client.CloseableHttpClient;
-import org.junit.Assert;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import uk.co.ordnancesurvey.gpx.beans.RouteWayPoint;
-import uk.co.ordnancesurvey.gpx.extensions.RoutePointAzimuthParser;
-import uk.co.ordnancesurvey.gpx.extensions.RoutePointDirectionParser;
-import uk.co.ordnancesurvey.gpx.extensions.RoutePointDistanceParser;
-import uk.co.ordnancesurvey.gpx.extensions.RoutePointTimeParser;
-
-public class GraphHopperGPXParserRouteTest {
-
-	private static final Logger LOG = LoggerFactory
-			.getLogger(GraphHopperGPXParserRouteTest.class);
-
-	private GPXParser gpxParser;
-	private GPX gpx;
-	private final Map<String, String> customHeaders = new HashMap<>();
-
-	public static GraphHopperGPXParserRouteTest getParserForgpxString(
-			String gpxString) {
-
-		GraphHopperGPXParserRouteTest instance = new GraphHopperGPXParserRouteTest();
-		instance.parseGPXFromString(gpxString);
-
-		return instance;
-	}
-
-	public static GraphHopperGPXParserRouteTest getParserForgpxFileName(
-			String gpxFileName) {
-		GraphHopperGPXParserRouteTest instance = new GraphHopperGPXParserRouteTest();
-		instance.parseGPXFromFile(gpxFileName);
-
-		return instance;
-	}
-
-	public GraphHopperGPXParserRouteTest() {
-		init();
-	}
-
-	private void parseGPXFromString(String gpxString) {
-		if (gpxString != null && gpxString.length() > 0) {
-			try {
-				gpx = gpxParser.parseGPX(new ByteArrayInputStream(gpxString
-						.getBytes()));
-			} catch (Exception e) {
-				LOG.info("Invalid File supplied for parsing " + e.getMessage());
-			}
-		}
-	}
-
-	private void parseGPXFromFile(String gpxFileName) {
-		if (gpxFileName != null && gpxFileName.length() > 0) {
-			try {
-				gpx = gpxParser.parseGPX(new FileInputStream(gpxFileName));
-
-			} catch (Exception e) {
-				LOG.info("Invalid File supplied for parsing " + e.getMessage());
-			}
-		}
-	}
-
-	private void addCustomHeaders(HttpGet httpget) {
-		for (Entry<String, String> header : customHeaders.entrySet()) {
-			httpget.addHeader(header.getKey(), header.getValue());
-		}
-	}
-
-	CloseableHttpResponse doSendAndGetResponse(String serviceUrl)
-			throws IOException, ClientProtocolException {
-		CloseableHttpClient httpClient = HttpClientUtils.createClient();
-		HttpGet httpget = new HttpGet(serviceUrl);
-		addCustomHeaders(httpget);
-
-		return httpClient.execute(httpget);
-	}
-
-	public String parseRoute(String routeType, String avoidances,
-			String routeOptions, String[] points) {
-		LOG.debug("Here we are");
-		// Set up the URL
-		String xmlResponse = "";
-		String coordinateString = "";
-		String graphHopperUrl;
-
-		String vehicle = "";
-		String routeOption = "";
-
-		if (routeOptions.split(",").length > 1) {
-			vehicle = routeOptions.split(",")[0];
-			routeOption = routeOptions.split(",")[1];
-		} else {
-			vehicle = routeOptions;
-		}
-
-		for (int i = 0; i < points.length; i++) {
-
-			coordinateString = coordinateString + "&point=" + points[i];
-
-		}
-
-		if (IntegrationTestProperties.getTestPropertyBool("viaApigee")) {
-			graphHopperUrl = IntegrationTestProperties
-					.getTestProperty("graphHopperWebUrlViaApigee");
-		} else {
-			graphHopperUrl = IntegrationTestProperties
-					.getTestProperty("graphHopperWebUrl");
-		}
-
-		String apikey = IntegrationTestProperties.getTestProperty("apiKey");
-
-		if (vehicle.equalsIgnoreCase("mountainbike")) {
-			vehicle = "mtb";
-		}
-		StringBuilder sb = new StringBuilder();
-		sb.append(graphHopperUrl);
-		sb.append("route?");
-		if (routeType != null) {
-			sb.append("type=");
-			sb.append(routeType);
-		}
-		sb.append("&vehicle=");
-		sb.append(vehicle);
-		sb.append("&weighting=");
-		sb.append(routeOption);
-		sb.append(coordinateString);
-		sb.append("&apikey=");
-		sb.append(apikey);
-		
-		if (!avoidances.equals("")) {
-			sb.append("&avoidances=" + avoidances);
-
-			if (routeOption.isEmpty()) {
-				routeOption = "fastavoid";
-			}
-		}
-
-		else {
-
-			if (routeOption.isEmpty()) {
-				routeOption = "fastest";
-			}
-
-		}
-		try {
-			CloseableHttpResponse httpResponse = sendAndGetResponse(sb
-					.toString());
-			xmlResponse = IOUtils.toString(httpResponse.getEntity()
-					.getContent(), "UTF-8");
-
-		} catch (IOException e) {
-			LOG.info("Exception raised whilst attempting to call graphhopper server "
-					+ e.getMessage());
-		}
-
-		if (xmlResponse != null && xmlResponse.length() > 0) {
-			parseGPXFromString(xmlResponse);
-		}
-
-		return xmlResponse;
-	}
-
-	public String parseRoute(StringBuffer sb) {
-		LOG.debug("Here we are");
-		// Set up the URL
-		String xmlResponse = "";
-
-		try {
-			CloseableHttpResponse httpResponse = sendAndGetResponse(sb
-					.toString());
-			xmlResponse = IOUtils.toString(httpResponse.getEntity()
-					.getContent(), "UTF-8");
-
-		} catch (IOException e) {
-			LOG.info("Exception raised whilst attempting to call graphhopper server "
-					+ e.getMessage());
-		}
-
-		if (xmlResponse != null && xmlResponse.length() > 0) {
-			parseGPXFromString(xmlResponse);
-		}
-
-		return xmlResponse;
-	}
-
-	public HashSet<Route> getRoutes() {
-		return gpx.getRoutes();
-	}
-
-	public HashSet<Track> getTracks() {
-		return gpx.getTracks();
-	}
-
-	public long getTotalRouteTime() {
-
-		long totalTimeInSceonds = 0;
-		HashSet<Track> tracks = gpx.getTracks();
-		Track track = (Track) tracks.toArray()[0];
-		ArrayList<Waypoint> trackPoints = track.getTrackPoints();
-
-		if (trackPoints.size() > 0) {
-			Waypoint sttp = trackPoints.get(0);
-			Waypoint endtp = trackPoints.get(trackPoints.size() - 1);
-			LOG.info("Start Time is " + sttp.getTime().toString());
-			LOG.info("End Time is " + endtp.getTime().toString());
-			totalTimeInSceonds = endtp.getTime().getTime()
-					- sttp.getTime().getTime();
-		}
-
-		return totalTimeInSceonds;
-	}
-
-	private void init() {
-
-		gpxParser = new GPXParser();
-		RoutePointDistanceParser rPDEP = new RoutePointDistanceParser();
-		RoutePointTimeParser rPTEP = new RoutePointTimeParser();
-		RoutePointAzimuthParser rPAEP = new RoutePointAzimuthParser();
-		RoutePointDirectionParser rPDIEP = new RoutePointDirectionParser();
-		// RouteExceptionParser rPException= new RouteExceptionParser();
-		gpxParser.addExtensionParser(rPDEP);
-		gpxParser.addExtensionParser(rPTEP);
-		gpxParser.addExtensionParser(rPAEP);
-		gpxParser.addExtensionParser(rPDIEP);
-		// gpxParser.addExtensionParser(rPException);
-	}
-
-	public boolean isWayPointOnRoute(Waypoint aWayPoint, Route aRoute) {
-		System.out.println(aWayPoint.getExtensionData().toString());
-		boolean isWayPointOnRoute = false;
-		System.out.println(aRoute.getRoutePoints());
-		for (Waypoint aWaypointInaRoute : aRoute.getRoutePoints()) {
-			if (new RouteWayPoint(aWaypointInaRoute).equals(new RouteWayPoint(
-					aWayPoint))) {
-				isWayPointOnRoute = true;
-				LOG.info("WayPoint " + aWayPoint + " Found In a Route" + aRoute);
-				break;
-			}
-		}
-
-		return isWayPointOnRoute;
-	}
-
-	public boolean isWayPointOnTrack(Waypoint aWayPoint, Track aTrack) {
-
-		boolean isWayPointOnTrack = false;
-		System.out.println(aTrack.getTrackPoints());
-		for (Waypoint aWaypointInaTrack : aTrack.getTrackPoints()) {
-			if (new RouteWayPoint(aWaypointInaTrack).equals(new RouteWayPoint(
-					aWayPoint))) {
-
-				isWayPointOnTrack = true;
-				LOG.info("WayPoint " + aWayPoint + " Found In a Track" + aTrack);
-				break;
-			}
-
-		}
-
-		return isWayPointOnTrack;
-	}
-
-	public boolean routeContainsTurn(String turnDescription, Route aRoute) {
-		System.out.println(aRoute);
-		boolean routeContainsTurn = false;
-		turnDescription = turnDescription.toUpperCase();
-
-		for (Waypoint aWaypointInaRoute : aRoute.getRoutePoints()) {
-			if (aWaypointInaRoute.getDescription() != null
-					&& aWaypointInaRoute.getDescription().toUpperCase()
-							.equals(turnDescription)) {
-				routeContainsTurn = true;
-
-				LOG.info("WayPoint " + aWaypointInaRoute
-						+ " contains route instruction" + turnDescription);
-				break;
-			}
-		}
-
-		return routeContainsTurn;
-	}
-
-	public CloseableHttpResponse sendAndGetResponse(String requestUrl)
-			throws IOException {
-		String serviceUrl = requestUrl;
-		if (IntegrationTestProperties.getTestPropertyBool("viaApigee")) {
-			serviceUrl += "&apikey="
-					+ IntegrationTestProperties.getTestProperty("apiKey");
-			LOG.debug("APPLYING KEY:");
-		}
-
-		return doSendAndGetResponse(serviceUrl);
-	}
-
-	public boolean isWayPointOnGPXRoutes(Waypoint wp) {
-
-		boolean isWayPointOnRoute = false;
-
-		for (Route route : getRoutes()) {
-			isWayPointOnRoute = isWayPointOnRoute(wp, route);
-
-			if (isWayPointOnRoute(wp, route)) {
-				break;
-			}
-
-		}
-		return isWayPointOnRoute;
-	}
-
-	public String getErrorMessage() {
-
-		return (String) gpx.getExtensionData("errorMessage");
-
-	}
-	
-	public int getstatusCode() {
-
-		return  (Integer.parseInt((String)gpx.getExtensionData("statusCode")));
-
-	}
-
-	public void verifyMessage(String responseMessage) {
-		String actualErrorMessage = getErrorMessage();
-		Assert.assertTrue("actual error message: " + actualErrorMessage
-				+ "does not match with: " + responseMessage,
-				responseMessage.equalsIgnoreCase(actualErrorMessage));
-
-	}
-
-	public void verifyStatusCode(int statusCode) {
-	
-		int actualstatusCode = getstatusCode();
-		Assert.assertTrue("actual error message: " + actualstatusCode
-				+ "does not match with: " + statusCode,
-				(statusCode==actualstatusCode));
-
-		
-	}
-
-}
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXUtil.java
new file mode 100644
index 0000000000..7b69bbb8ec
--- /dev/null
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperGPXUtil.java
@@ -0,0 +1,124 @@
+package uk.co.ordnancesurvey.gpx.graphhopper;
+
+import java.util.HashSet;
+
+import org.alternativevision.gpx.beans.Route;
+import org.alternativevision.gpx.beans.Track;
+import org.alternativevision.gpx.beans.Waypoint;
+import org.junit.Assert;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import uk.co.ordnancesurvey.gpx.beans.RouteWayPoint;
+
+public class GraphHopperGPXUtil {
+
+	private static final Logger LOG = LoggerFactory
+			.getLogger(GraphHopperGPXUtil.class);
+
+	private GraphHopperGPXParser parser = new GraphHopperGPXParser();
+
+	public void parseGPXFromString(String gpxString) {
+
+		parser.parseGPXFromString(gpxString);
+	}
+
+	public boolean isWayPointOnRoute(Waypoint aWayPoint, Route aRoute) {
+		System.out.println(aWayPoint.getExtensionData().toString());
+		boolean isWayPointOnRoute = false;
+		System.out.println(aRoute.getRoutePoints());
+		for (Waypoint aWaypointInaRoute : aRoute.getRoutePoints()) {
+			if (new RouteWayPoint(aWaypointInaRoute).equals(new RouteWayPoint(
+					aWayPoint))) {
+				isWayPointOnRoute = true;
+				LOG.info("WayPoint " + aWayPoint + " Found In a Route" + aRoute);
+				break;
+			}
+		}
+
+		return isWayPointOnRoute;
+	}
+
+	public boolean isWayPointOnTrack(Waypoint aWayPoint, Track aTrack) {
+
+		boolean isWayPointOnTrack = false;
+		System.out.println(aTrack.getTrackPoints());
+		for (Waypoint aWaypointInaTrack : aTrack.getTrackPoints()) {
+			if (new RouteWayPoint(aWaypointInaTrack).equals(new RouteWayPoint(
+					aWayPoint))) {
+
+				isWayPointOnTrack = true;
+				LOG.info("WayPoint " + aWayPoint + " Found In a Track" + aTrack);
+				break;
+			}
+
+		}
+
+		return isWayPointOnTrack;
+	}
+
+	public boolean routeContainsTurn(String turnDescription, Route aRoute) {
+		System.out.println(aRoute);
+		boolean routeContainsTurn = false;
+		turnDescription = turnDescription.toUpperCase();
+
+		for (Waypoint aWaypointInaRoute : aRoute.getRoutePoints()) {
+			if (aWaypointInaRoute.getDescription() != null
+					&& aWaypointInaRoute.getDescription().toUpperCase()
+							.equals(turnDescription)) {
+				routeContainsTurn = true;
+
+				LOG.info("WayPoint " + aWaypointInaRoute
+						+ " contains route instruction" + turnDescription);
+				break;
+			}
+		}
+
+		return routeContainsTurn;
+	}
+
+	public boolean isWayPointOnGPXRoutes(Waypoint wp) {
+
+		boolean isWayPointOnRoute = false;
+
+		for (Route route : getRoutes()) {
+			isWayPointOnRoute = isWayPointOnRoute(wp, route);
+
+			if (isWayPointOnRoute(wp, route)) {
+				break;
+			}
+
+		}
+		return isWayPointOnRoute;
+	}
+
+	public HashSet<Route> getRoutes() {
+		return parser.getRoutes();
+	}
+
+	public HashSet<Track> getTracks() {
+		return parser.getTracks();
+	}
+
+	public long getTotalRouteTime() {
+
+		return parser.getTotalRouteTime();
+	}
+
+	public void verifyMessage(String responseMessage) {
+		String actualErrorMessage = parser.getErrorMessage();
+		Assert.assertTrue("actual error message: " + actualErrorMessage
+				+ "does not match with: " + responseMessage,
+				responseMessage.equalsIgnoreCase(actualErrorMessage));
+
+	}
+
+	public void verifyStatusCode(int statusCode) {
+
+		int actualstatusCode = parser.getstatusCode();
+		Assert.assertTrue("actual error message: " + actualstatusCode
+				+ "does not match with: " + statusCode,
+				(statusCode == actualstatusCode));
+
+	}
+}
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperJSONParser.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperJSONParser.java
deleted file mode 100644
index fbef0c8f8a..0000000000
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperJSONParser.java
+++ /dev/null
@@ -1,306 +0,0 @@
-package uk.co.ordnancesurvey.gpx.graphhopper;
-
-import java.io.IOException;
-import java.util.HashSet;
-
-import org.alternativevision.gpx.beans.Waypoint;
-import org.apache.commons.io.IOUtils;
-import org.apache.http.client.methods.CloseableHttpResponse;
-import org.junit.Assert;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import uk.co.ordnancesurvey.gpx.beans.RouteWayPoint;
-import uk.co.ordnancesurvey.gpx.extensions.ExtensionConstants;
-
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParser;
-import com.google.gson.JsonPrimitive;
-
-public class GraphHopperJSONParser {
-
-	JSONWayPoints json = new JSONWayPoints();
-	private static final Logger LOG = LoggerFactory
-			.getLogger(GraphHopperJSONParser.class);
-	String jsonString;
-
-	public GraphHopperJSONParser(String responseString) {
-		jsonString = responseString;
-	}
-
-	public GraphHopperJSONParser() {
-		// TODO Auto-generated constructor stub
-	}
-
-	public JSONWayPoints parseJSONFromString(String jsonString) {
-		this.jsonString = jsonString;
-		JsonParser parser = new JsonParser();
-
-		try {
-			JsonElement je = parser.parse(jsonString);
-			JsonObject jo = je.getAsJsonObject();
-			JsonArray paths = jo.getAsJsonArray("paths");
-
-			JsonArray instructions = paths.get(0).getAsJsonObject()
-					.getAsJsonArray("instructions");
-
-			for (int i = 0; i < instructions.size(); i++) {
-				Waypoint w = new Waypoint();
-
-				JsonObject instruction = instructions.get(i).getAsJsonObject();
-
-				JsonPrimitive description = instruction
-						.getAsJsonPrimitive("text");
-				JsonPrimitive time = instruction.getAsJsonPrimitive("time");
-				JsonPrimitive distance = instruction
-						.getAsJsonPrimitive("distance");
-
-				double distance_rounding = Double.parseDouble(distance
-						.toString());
-
-				distance_rounding = Math.round(distance_rounding * 10) / 10.0;
-
-				JsonPrimitive azimuth = instruction
-						.getAsJsonPrimitive("azimuth");
-				JsonPrimitive annotation_text = instruction
-						.getAsJsonPrimitive("annotation_text");
-				JsonArray interval = instruction.getAsJsonArray("interval");
-				int coordinateIndex = Integer.parseInt(interval.get(0)
-						.toString());
-				JsonElement s = getJSONCoordinates(paths, coordinateIndex);
-				Double longitude = Double.parseDouble(s.getAsJsonArray().get(0)
-						.toString());
-				Double latitude = Double.parseDouble(s.getAsJsonArray().get(1)
-						.toString());
-				w.setLongitude(longitude);
-				w.setLatitude(latitude);
-				w.setDescription(description.toString());
-				w.addExtensionData(ExtensionConstants.DISTANCE,
-						String.valueOf(distance_rounding));
-				w.addExtensionData(ExtensionConstants.TIME, time.toString());
-
-				LOG.info("azimuth :" + azimuth);
-				LOG.info("descritption: " + description);
-				LOG.info("time :" + time);
-				LOG.info("distance :" + distance);
-				if (null != annotation_text) {
-					w.addExtensionData("Annotation_text", annotation_text
-							.getAsString().trim());
-					LOG.info("annotation_text: "
-							+ annotation_text.getAsString().trim());
-				}
-				LOG.info("Coordinates : " + w.getLatitude() + ","
-						+ w.getLongitude());
-
-				json.addWayPoint(w);
-			}
-		}
-
-		catch (Exception e) {
-			LOG.info(e.getMessage());
-		}
-		return json;
-
-	}
-
-	public JSONWayPoints parseCoordinatesFromJson(String jsonString) {
-		this.jsonString = jsonString;
-		JsonParser parser = new JsonParser();
-		JsonElement je = parser.parse(jsonString);
-		JsonObject jo = je.getAsJsonObject();
-		JsonArray paths = jo.getAsJsonArray("paths");
-		JsonObject points = paths.get(0).getAsJsonObject()
-				.getAsJsonObject("points");
-		JsonArray coordinates = points.getAsJsonObject().getAsJsonArray(
-				"coordinates");
-
-		for (JsonElement jsonElement : coordinates) {
-			Waypoint w = new Waypoint();
-			Double longitude = Double.parseDouble(jsonElement.getAsJsonArray()
-					.get(0).toString());
-			Double latitude = Double.parseDouble(jsonElement.getAsJsonArray()
-					.get(1).toString());
-			w.setLongitude(longitude);
-			w.setLatitude(latitude);
-			json.addWayPoint(w);
-
-		}
-
-		return json;
-
-	}
-
-	public String parseErrorMessagesFromJson(String jsonString) {
-		this.jsonString = jsonString;
-		JsonParser parser = new JsonParser();
-		JsonElement je = parser.parse(jsonString);
-		JsonObject jo = je.getAsJsonObject();
-		JsonObject info = jo.getAsJsonObject("info");
-
-		JsonArray errors = info.getAsJsonArray("errors");
-		JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
-				.getAsJsonPrimitive("message");
-		return errorMessage.getAsString();
-
-	}
-
-	public int parseStatusCodeFromJson(String jsonString) {
-		this.jsonString = jsonString;
-		JsonParser parser = new JsonParser();
-		JsonElement je = parser.parse(jsonString);
-		JsonObject jo = je.getAsJsonObject();
-		JsonObject info = jo.getAsJsonObject("info");
-
-		JsonArray errors = info.getAsJsonArray("errors");
-		JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
-				.getAsJsonPrimitive("statuscode");
-		return errorMessage.getAsInt();
-
-	}
-
-	public HashSet<Waypoint> getJsonCoordinatesAsHashSet() {
-
-		parseCoordinatesFromJson(jsonString);
-		return json.getInstructions();
-	}
-
-	public JsonElement getJSONCoordinates(JsonArray paths, int coordinateIndex) {
-
-		JsonObject points = paths.get(0).getAsJsonObject()
-				.getAsJsonObject("points");
-		JsonArray coordinates = points.getAsJsonObject().getAsJsonArray(
-				"coordinates");
-
-		return coordinates.get(coordinateIndex);
-	}
-
-	/**
-	 * verifies if the waypoint is present in the JSON string.
-	 * 
-	 * @param Waypoint
-	 * @return true if Waypoint is found in the JSON string and otherwise false
-	 *         is returned
-	 */
-	public boolean isWayPointinPath(Waypoint w) {
-		boolean iswaypointinPath = false;
-
-		for (Waypoint wp : json.getInstructions()) {
-
-			RouteWayPoint k = new RouteWayPoint(wp);
-			iswaypointinPath = k.equals(new RouteWayPoint(w));
-			if (iswaypointinPath) {
-				break;
-			}
-		}
-
-		return iswaypointinPath;
-
-	}
-
-	public boolean isWayPointinPath(Waypoint we, HashSet<Waypoint> wa) {
-		boolean iswaypointinPath = false;
-
-		for (Waypoint waypoint : wa) {
-
-			if (new RouteWayPoint(we).equals(new RouteWayPoint(waypoint))) {
-				iswaypointinPath = true;
-				LOG.info("WayPoint " + we + " Found In a Path");
-			}
-			if (iswaypointinPath) {
-				break;
-			}
-		}
-
-		return iswaypointinPath;
-	}
-
-	/**
-	 * Creates a Waypoint with below attributes
-	 * 
-	 * @param wayPointDescription
-	 * @param time
-	 * @param distance
-	 * @return Waypoint
-	 */
-	public Waypoint buildWayPointForJson(String wayPoint_Coordinates,
-			String wayPointDescription, String time, String distance,
-			String avoidance) {
-		Waypoint w = new Waypoint();
-		String waypoint[] = wayPoint_Coordinates.split(",");
-		w.setLatitude(new Double(waypoint[0]));
-		w.setLongitude(new Double(waypoint[1]));
-		w.setDescription(wayPointDescription);
-		w.addExtensionData(ExtensionConstants.DISTANCE, distance);
-		w.addExtensionData(ExtensionConstants.TIME, time);
-		w.addExtensionData("Annotation_text", avoidance.trim());
-		return w;
-
-	}
-
-	public String nearestPointJSONParser(String jsoString) {
-		this.jsonString = jsoString;
-
-		JsonParser jp = new JsonParser();
-		JsonElement je = jp.parse(jsonString);
-		JsonArray jo = je.getAsJsonObject().getAsJsonArray("coordinates");
-
-		return jo.get(1).getAsString() + "," + jo.get(0).getAsString();
-
-	}
-	
-	public String getJSONString()
-	{
-		return jsonString;
-	}
-
-	public void parse(StringBuffer sb) {
-
-		String jsonResponse = "";
-
-		GraphHopperGPXParserRouteTest GPHService = new GraphHopperGPXParserRouteTest();
-		try {
-			CloseableHttpResponse httpResponse = GPHService
-					.sendAndGetResponse(sb.toString());
-			jsonResponse = IOUtils.toString(httpResponse.getEntity()
-					.getContent(), "UTF-8");
-
-		} catch (IOException e) {
-			LOG.info("Exception raised whilst attempting to call graphhopper server "
-					+ e.getMessage());
-		}
-
-		if (jsonResponse != null && jsonResponse.length() > 0) {
-			parseJSONFromString(jsonResponse);
-		}
-
-	}
-
-	public long getTotalRouteTime() {
-		JsonParser parser = new JsonParser();
-		JsonElement je = parser.parse(jsonString);
-		JsonObject jo = je.getAsJsonObject();
-		JsonArray paths = jo.getAsJsonArray("paths");
-		JsonPrimitive totalTime = paths.get(0).getAsJsonObject()
-				.getAsJsonPrimitive("time");
-		return Long.parseLong(totalTime.toString());
-	}
-
-	public void verifyMessage(String responseMessage) {
-		String actualErrorMessage = parseErrorMessagesFromJson(jsonString);
-		Assert.assertTrue("actual error message:" + actualErrorMessage
-				+ " does not match with: " + responseMessage,
-				responseMessage.equalsIgnoreCase(actualErrorMessage));
-
-	}
-
-	public void verifyStatusCode(int statusCode) {
-		int actualStatusCode = parseStatusCodeFromJson(jsonString);
-		Assert.assertTrue("actual error message: " + actualStatusCode
-				+ " does not match with: " + statusCode,
-				(actualStatusCode == statusCode));
-
-	}
-
-}
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperJSONUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperJSONUtil.java
new file mode 100644
index 0000000000..3aa690534e
--- /dev/null
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperJSONUtil.java
@@ -0,0 +1,120 @@
+package uk.co.ordnancesurvey.gpx.graphhopper;
+
+import java.util.HashSet;
+
+import org.alternativevision.gpx.beans.Waypoint;
+import org.junit.Assert;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import uk.co.ordnancesurvey.gpx.beans.RouteWayPoint;
+import uk.co.ordnancesurvey.gpx.extensions.ExtensionConstants;
+
+public class GraphHopperJSONUtil {
+
+	JSONWayPoints wayPoints = new JSONWayPoints();
+	JSONParser parser = new JSONParser();
+	
+	
+	private static final Logger LOG = LoggerFactory
+			.getLogger(GraphHopperJSONUtil.class);
+
+	public boolean isWayPointinpath(Waypoint w) {
+
+		boolean iswaypointinPath = false;
+
+		for (Waypoint wp : parser.getJsonWayPoints()) {
+
+			RouteWayPoint k = new RouteWayPoint(wp);
+			iswaypointinPath = k.equals(new RouteWayPoint(w));
+			if (iswaypointinPath) {
+				break;
+			}
+
+		}
+
+		return iswaypointinPath;
+
+	}
+
+	public boolean isWayPointinPath(Waypoint we, HashSet<Waypoint> wa) {
+		boolean iswaypointinPath = false;
+
+		for (Waypoint waypoint : wa) {
+
+			if (new RouteWayPoint(we).equals(new RouteWayPoint(waypoint))) {
+				iswaypointinPath = true;
+				LOG.info("WayPoint " + we + " Found In a Path");
+			}
+			if (iswaypointinPath) {
+				break;
+			}
+		}
+
+		return iswaypointinPath;
+	}
+	public void parse(String jsonResponse) {
+
+		parser.parse(jsonResponse);
+	}
+
+	public Waypoint buildWayPointForJson(String wayPoint_Coordinates,
+			String wayPointDescription, String time, String distance,
+			String avoidance) {
+		Waypoint w = new Waypoint();
+		String waypoint[] = wayPoint_Coordinates.split(",");
+		w.setLatitude(new Double(waypoint[0]));
+		w.setLongitude(new Double(waypoint[1]));
+		w.setDescription(wayPointDescription);
+		w.addExtensionData(ExtensionConstants.DISTANCE, distance);
+		w.addExtensionData(ExtensionConstants.TIME, time);
+		w.addExtensionData("Annotation_text", avoidance.trim());
+		return w;
+
+	}
+
+	public String nearestPointJSONParser(String jsoString) {
+		
+		return parser.getNearestPoint();
+
+
+	}
+
+	public long getTotalRouteTime() {
+		return parser.getTotalRouteTime();
+	}
+
+	public void verifyMessage(String responseMessage) {
+		String actualErrorMessage = parser.getErrorMessage();
+		Assert.assertTrue("actual error message:" + actualErrorMessage
+				+ " does not match with: " + responseMessage,
+				responseMessage.equalsIgnoreCase(actualErrorMessage));
+
+	}
+
+	public void verifyStatusCode(int statusCode) {
+		int actualStatusCode = parser.getStatusCode();
+		Assert.assertTrue("actual error message: " + actualStatusCode
+				+ " does not match with: " + statusCode,
+				(actualStatusCode == statusCode));
+
+	}
+
+	public HashSet<Waypoint> getJsonCoordinatesAsHashSet() {
+
+		parser.parseCoordinatesFromJson();
+		return parser.getJsonWayPoints();
+	}
+
+	public String getNearestPoint() {
+		
+		return parser.getNearestPoint();
+		
+	}
+
+	public String getNearestPointDistance() {
+		// TODO Auto-generated method stub
+		return parser.getNearestPointDistance();
+	}
+
+}
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperRequestHandler.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperRequestHandler.java
deleted file mode 100644
index d117c69f64..0000000000
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/GraphHopperRequestHandler.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package uk.co.ordnancesurvey.gpx.graphhopper;
-
-import java.io.IOException;
-
-import org.apache.commons.io.IOUtils;
-import org.apache.http.client.methods.CloseableHttpResponse;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-public class GraphHopperRequestHandler {
-
-	private static final Logger LOG = LoggerFactory
-			.getLogger(GraphHopperRequestHandler.class);
-	private GraphHopperJSONParser parser = new GraphHopperJSONParser();
-
-	public void dispatchServiceRequest(String routeType, String avoidances, String routeOptions,
-			String[] string) {
-
-		String vehicle = "";
-		String routeOption = "";
-
-		if (routeOptions.split(",").length > 1) {
-			vehicle = routeOptions.split(",")[0];
-			routeOption = routeOptions.split(",")[1];
-		} else {
-			vehicle = routeOptions;
-		}
-		// Set up the URL
-		String jsonResponse = "";
-		String coordinateString = "";
-		String graphHopperUrl;
-
-		for (int i = 0; i < string.length; i++) {
-
-			coordinateString = coordinateString + "&point=" + string[i];
-
-		}
-
-		if (IntegrationTestProperties.getTestPropertyBool("viaApigee")) {
-			graphHopperUrl = IntegrationTestProperties
-					.getTestProperty("graphHopperWebUrlViaApigee");
-		} else {
-			graphHopperUrl = IntegrationTestProperties
-					.getTestProperty("graphHopperWebUrl");
-		}
-
-		String apikey = IntegrationTestProperties.getTestProperty("apiKey");
-		if (vehicle.equalsIgnoreCase("mountainbike")) {
-			vehicle = "mtb";
-		}
-		StringBuilder sb = new StringBuilder();
-		sb.append(graphHopperUrl);
-		sb.append("route?");
-		if (routeType != null) {
-			sb.append("type=");
-			sb.append(routeType);
-		}
-		sb.append("&vehicle=");
-		sb.append(vehicle);
-
-		sb.append(coordinateString);
-		sb.append("&apikey=");
-		sb.append(apikey);
-		sb.append("&points_encoded=false");
-
-		if (!avoidances.equals("")) {
-			sb.append("&avoidances=" + avoidances);
-
-			if (routeOption.isEmpty()) {
-				routeOption = "fastavoid";
-			}
-		}
-
-		else {
-
-			if (routeOption.isEmpty()) {
-				routeOption = "fastest";
-			}
-
-		}
-
-		sb.append("&weighting=");
-
-		sb.append(routeOption);
-		GraphHopperGPXParserRouteTest GPHService = new GraphHopperGPXParserRouteTest();
-		try {
-			CloseableHttpResponse httpResponse = GPHService
-					.sendAndGetResponse(sb.toString());
-			jsonResponse = IOUtils.toString(httpResponse.getEntity()
-					.getContent(), "UTF-8");
-
-		} catch (IOException e) {
-			LOG.info("Exception raised whilst attempting to call graphhopper server "
-					+ e.getMessage());
-		}
-
-		if (jsonResponse != null && jsonResponse.length() > 0) {
-			parser.parseJSONFromString(jsonResponse);
-		}
-
-	}
-}
\ No newline at end of file
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java
new file mode 100644
index 0000000000..9668e309b8
--- /dev/null
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONParser.java
@@ -0,0 +1,201 @@
+package uk.co.ordnancesurvey.gpx.graphhopper;
+
+import java.util.HashSet;
+
+import org.alternativevision.gpx.beans.Waypoint;
+import org.junit.Assert;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import uk.co.ordnancesurvey.gpx.beans.RouteWayPoint;
+import uk.co.ordnancesurvey.gpx.extensions.ExtensionConstants;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import com.google.gson.JsonPrimitive;
+
+public class JSONParser {
+
+	private JsonElement jElement;
+	private JsonObject jObject;
+	private JsonArray paths;
+	private JsonArray instructions;
+	private JsonObject info;
+
+	public JSONWayPoints jsonWayPoints = new JSONWayPoints();
+
+	private static final Logger LOG = LoggerFactory.getLogger(JSONParser.class);
+
+	public void parse(String jsonString) {
+
+		JsonParser parser = new JsonParser();
+
+		try {
+			jElement = parser.parse(jsonString);
+			jObject = jElement.getAsJsonObject();
+			paths = jObject.getAsJsonArray("paths");
+			info = jObject.getAsJsonObject("info");
+
+			instructions = paths.get(0).getAsJsonObject()
+					.getAsJsonArray("instructions");
+			extractWayPoints();
+
+		}
+
+		catch (Exception e) {
+			e.printStackTrace();
+		}
+
+	}
+
+	public JsonArray getPaths() {
+		return paths;
+	}
+
+	public JsonArray getInstructions() {
+		return instructions;
+	}
+
+	public HashSet<Waypoint> getJsonWayPoints() {
+		return jsonWayPoints.getInstructions();
+	}
+
+	public void extractWayPoints() {
+		for (int i = 0; i < instructions.size(); i++) {
+			Waypoint w = new Waypoint();
+
+			JsonObject instruction = instructions.get(i).getAsJsonObject();
+
+			JsonPrimitive description = instruction.getAsJsonPrimitive("text");
+			JsonPrimitive time = instruction.getAsJsonPrimitive("time");
+			JsonPrimitive distance = instruction.getAsJsonPrimitive("distance");
+
+			double distance_rounding = Double.parseDouble(distance.toString());
+
+			distance_rounding = Math.round(distance_rounding * 10) / 10.0;
+
+			JsonPrimitive azimuth = instruction.getAsJsonPrimitive("azimuth");
+			JsonPrimitive annotation_text = instruction
+					.getAsJsonPrimitive("annotation_text");
+			JsonArray interval = instruction.getAsJsonArray("interval");
+			int coordinateIndex = Integer.parseInt(interval.get(0).toString());
+			JsonElement s = getJSONCoordinates(coordinateIndex);
+			Double longitude = Double.parseDouble(s.getAsJsonArray().get(0)
+					.toString());
+			Double latitude = Double.parseDouble(s.getAsJsonArray().get(1)
+					.toString());
+			w.setLongitude(longitude);
+			w.setLatitude(latitude);
+			w.setDescription(description.toString());
+			w.addExtensionData(ExtensionConstants.DISTANCE,
+					String.valueOf(distance_rounding));
+			w.addExtensionData(ExtensionConstants.TIME, time.toString());
+
+			LOG.info("azimuth :" + azimuth);
+			LOG.info("descritption: " + description);
+			LOG.info("time :" + time);
+			LOG.info("distance :" + distance);
+			if (null != annotation_text) {
+				w.addExtensionData("Annotation_text", annotation_text
+						.getAsString().trim());
+				LOG.info("annotation_text: "
+						+ annotation_text.getAsString().trim());
+			}
+			LOG.info("Coordinates : " + w.getLatitude() + ","
+					+ w.getLongitude());
+
+			jsonWayPoints.addWayPoint(w);
+		}
+
+	}
+
+	public JsonElement getJSONCoordinates(int coordinateIndex) {
+
+		JsonObject points = paths.get(0).getAsJsonObject()
+				.getAsJsonObject("points");
+		JsonArray coordinates = points.getAsJsonObject().getAsJsonArray(
+				"coordinates");
+
+		return coordinates.get(coordinateIndex);
+	}
+
+	public boolean isWayPointinPath(Waypoint w) {
+		boolean iswaypointinPath = false;
+
+		for (Waypoint wp : jsonWayPoints.getInstructions()) {
+
+			RouteWayPoint k = new RouteWayPoint(wp);
+			iswaypointinPath = k.equals(new RouteWayPoint(w));
+			if (iswaypointinPath) {
+				break;
+			}
+		}
+
+		return iswaypointinPath;
+
+	}
+
+	public long getTotalRouteTime() {
+		JsonPrimitive totalTime = paths.get(0).getAsJsonObject()
+				.getAsJsonPrimitive("time");
+		return Long.parseLong(totalTime.toString());
+	}
+
+	public String getErrorMessage() {
+		JsonArray errors = info.getAsJsonArray("errors");
+		JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
+				.getAsJsonPrimitive("message");
+		return errorMessage.getAsString();
+
+	}
+
+	public int getStatusCode() {
+		JsonArray errors = info.getAsJsonArray("errors");
+		JsonPrimitive errorMessage = errors.get(0).getAsJsonObject()
+				.getAsJsonPrimitive("statuscode");
+		return errorMessage.getAsInt();
+
+	}
+
+	public String getNearestPoint() {
+
+		JsonArray nearestPoint = jElement.getAsJsonObject().getAsJsonArray(
+				"coordinates");
+
+		return nearestPoint.get(1).getAsString() + ","
+				+ nearestPoint.get(0).getAsString();
+
+	}
+
+	public String getNearestPointDistance() {
+
+		JsonPrimitive distance = jElement.getAsJsonObject().getAsJsonPrimitive(
+				"distance");
+		return distance.toString();
+	}
+
+	public JSONWayPoints parseCoordinatesFromJson() {
+
+		JsonObject points = paths.get(0).getAsJsonObject()
+				.getAsJsonObject("points");
+		JsonArray coordinates = points.getAsJsonObject().getAsJsonArray(
+				"coordinates");
+
+		for (JsonElement jsonElement : coordinates) {
+			Waypoint w = new Waypoint();
+			Double longitude = Double.parseDouble(jsonElement.getAsJsonArray()
+					.get(0).toString());
+			Double latitude = Double.parseDouble(jsonElement.getAsJsonArray()
+					.get(1).toString());
+			w.setLongitude(longitude);
+			w.setLatitude(latitude);
+			jsonWayPoints.addWayPoint(w);
+
+		}
+
+		return jsonWayPoints;
+
+	}
+}
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONWayPoints.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONWayPoints.java
index 6b9d603c24..540459ba1d 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONWayPoints.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/JSONWayPoints.java
@@ -1,6 +1,5 @@
 package uk.co.ordnancesurvey.gpx.graphhopper;
 
-import java.util.ArrayList;
 import java.util.HashSet;
 
 import org.alternativevision.gpx.beans.Waypoint;
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/NearestPointServiceUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/NearestPointServiceUtil.java
index 5ab895ace4..3eff543004 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/NearestPointServiceUtil.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/graphhopper/NearestPointServiceUtil.java
@@ -7,6 +7,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import uk.co.ordnancesurvey.routing.GraphHopperUIUtil;
+
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
 import com.google.gson.JsonPrimitive;
@@ -15,10 +17,11 @@
 
 	private static final Logger LOG = LoggerFactory
 			.getLogger(NearestPointServiceUtil.class);
-	
-	 String jsonString;
 
-	public  String getNearestPoint(String pointA) {
+	String jsonString;
+	GraphHopperUIUtil GPHopperUIUtil = new GraphHopperUIUtil();
+
+	public String getNearestPoint(String pointA) {
 
 		String nearestpoint = "";
 		StringBuffer sb = new StringBuffer();
@@ -32,32 +35,17 @@ public  String getNearestPoint(String pointA) {
 
 		sb.append("nearest?point=");
 		sb.append(pointA);
-		GraphHopperGPXParserRouteTest GPHService = new GraphHopperGPXParserRouteTest();
-
-		try {
-			CloseableHttpResponse httpResponse = GPHService
-					.sendAndGetResponse(sb.toString());
 
-			jsonString= IOUtils.toString(httpResponse.getEntity()
-					.getContent(), "UTF-8");
+		GPHopperUIUtil.getRouteFromServiceWithParameters(sb);
 
-			GraphHopperJSONParser jsonParser = new GraphHopperJSONParser();
-			nearestpoint = jsonParser.nearestPointJSONParser(jsonString);
+		nearestpoint = GPHopperUIUtil.getNearestPoint();
 
-		} catch (IOException e) {
-			LOG.info("Exception raised whilst attempting to call graphhopper server "
-					+ e.getMessage());
-		}
 		return nearestpoint;
 
 	}
-	
-	
+
 	public String getNearestPointDistance() {
-		JsonParser jp = new JsonParser();
-		JsonElement je = jp.parse(jsonString);
-		JsonPrimitive distance = je.getAsJsonObject().getAsJsonPrimitive(
-				"distance");
+String distance= GPHopperUIUtil.getNearestPointDistance();
 		return distance.toString();
 	}
 
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
index a10bd708c1..7bc129c934 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperHooks.java
@@ -31,7 +31,7 @@
 
 	NearestPointServiceUtil nearestPointUtil= new NearestPointServiceUtil();
 
-	@Before
+	@Before({"~@WebOnly","~@SampleScenario"})
 	public void init() {
 		
 		graphUiUtil = (IntegrationTestProperties
@@ -45,18 +45,31 @@ public void init() {
 	}
 
 	@Before("@WebOnly,@SampleScenario")
-	public void overrideTestONProperty() {
+	public void overrideTestONPropertyToWeb() {
 
 		testON = IntegrationTestProperties.getTestProperty("testON");
 		IntegrationTestProperties.setTestProperty("testON", "Web");
+		init();
+
 	}
 
-	@After("@WebOnly,@SampleScenario")
+	@After("@WebOnly,@SampleScenario,@ErrorMessages")
 	public void rollBackTestONProperty() {
 		IntegrationTestProperties.setTestProperty("testON", testON);
 
 	}
 
+	
+	
+	@Before("@ErrorMessages")
+	public void overrideTestONProperty() {
+
+		testON = IntegrationTestProperties.getTestProperty("testON");
+		IntegrationTestProperties.setTestProperty("testON", "Service");
+	}
+
+
+
 	@Given("^My routing point for nearestPoint API as \"([^\"]*)\"$")
 	public void I_have_route_point_for_Nearest_Point_API(String pointA) {
 		this.pointA = pointA;
@@ -64,21 +77,25 @@ public void I_have_route_point_for_Nearest_Point_API(String pointA) {
 
 	@When("^I request a nearest point from from Nearest Point API$")
 	public void I_request_a_nearest_point_from_from_Nearest_Point_API() {
+		if (IntegrationTestProperties.getTestProperty("testON").equalsIgnoreCase("json")){
 		nearestPoint=nearestPointUtil.getNearestPoint(pointA);
 		Distance = nearestPointUtil.getNearestPointDistance();
+		}
 
 	}
 
 	@Then("^I should be able to verify the nearest point to be \"([^\"]*)\" at a distance of \"([^\"]*)\"$")
 	public void I_should_be_able_to_verify_the_nearest_point_to_be(
 			String pointB, String distance) {
-
+		if (IntegrationTestProperties.getTestProperty("testON").equalsIgnoreCase("json")){
+		
 		Assert.assertTrue("******Expected nearest Point " + pointB
 				+ " is not matching with " + nearestPoint + "********",
 				pointB.equals(nearestPoint));
 		Assert.assertTrue("******Expected nearest Point distance " + distance
 				+ " is not matcching with " + Distance,
 				Distance.equals(distance));
+		}
 
 	}
 
@@ -190,7 +207,7 @@ public void I_request_for_route() {
 
 	}
 
-	@After("@Current")
+	@After("@SampleScenario")
 	public void I_should_be_able_to_capture_a_screenshot(Scenario sc)
 			throws ParseException {
 
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
index eb55538cc5..80f8249fc7 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperUIUtil.java
@@ -46,6 +46,11 @@
 
 import org.alternativevision.gpx.beans.Route;
 import org.alternativevision.gpx.beans.Waypoint;
+import org.apache.commons.io.IOUtils;
+import org.apache.http.client.ClientProtocolException;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.CloseableHttpClient;
 import org.junit.Assert;
 import org.openqa.selenium.By;
 import org.openqa.selenium.JavascriptExecutor;
@@ -54,8 +59,9 @@
 import org.slf4j.LoggerFactory;
 
 import uk.co.ordnancesurvey.gpx.extensions.ExtensionConstants;
-import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperGPXParserRouteTest;
-import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperJSONParser;
+import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperGPXUtil;
+import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperJSONUtil;
+import uk.co.ordnancesurvey.gpx.graphhopper.HttpClientUtils;
 import uk.co.ordnancesurvey.gpx.graphhopper.IntegrationTestProperties;
 import uk.co.ordnancesurvey.webtests.base.ComponentID;
 import uk.co.ordnancesurvey.webtests.base.ImageComparison;
@@ -68,9 +74,14 @@
 	private String baseUrl;
 	private String routeStepNumber;
 	String testOn = IntegrationTestProperties.getTestProperty("testON");
-	GraphHopperGPXParserRouteTest GPHService = new GraphHopperGPXParserRouteTest();
-	GraphHopperJSONParser GPHJsonService = new GraphHopperJSONParser();
+	//GraphHopperGPXParserRouteTest GPHServiceUtil = new GraphHopperGPXParserRouteTest();
+	GraphHopperGPXUtil GPHServiceUtil = new GraphHopperGPXUtil();
+	
+	private final Map<String, String> customHeaders = new HashMap<>();
+	// GraphHopperJSONParser GPHJsonService = new GraphHopperJSONParser();
+	// static JSONParser parser= new JSONParser();
 	private Map<String, ArrayList<String>> requestParameters = new HashMap<String, ArrayList<String>>();
+	GraphHopperJSONUtil GPHJSONUtil = new GraphHopperJSONUtil();
 
 	JavascriptExecutor js = (JavascriptExecutor) driver;
 	WebElement we;
@@ -91,6 +102,11 @@ public GraphHopperUIUtil(String url) {
 		}
 	}
 
+	public GraphHopperUIUtil() {
+
+		super(BrowserPlatformOptions.getEnabledOptionsArrayList().get(0)[0]);
+
+	}
 	private void init() throws InterruptedException {
 
 		if (!testOn.equalsIgnoreCase("SERVICE")) {
@@ -283,11 +299,11 @@ public boolean verifyInstructionThroughUI(String routeStepNumber,
 	}
 
 	public void verifyInstructionThroughService(String stepInstruction) {
-		HashSet<Route> routeInstruction = GPHService.getRoutes();
+		HashSet<Route> routeInstruction = GPHServiceUtil.getRoutes();
 
 		Assert.assertTrue(
 				"The Route instruction is not found in the gpx response",
-				GPHService.routeContainsTurn(stepInstruction.toUpperCase(),
+				GPHServiceUtil.routeContainsTurn(stepInstruction.toUpperCase(),
 						routeInstruction.iterator().next()));
 
 	}
@@ -322,12 +338,17 @@ public boolean isWayPointonRouteMap(String wayPointIndex,
 			if (requestParameters.get("type").get(0).equals("gpx")) {
 				wp = buildWayPoint(wayPoint_Coordinates, wayPointDescription,
 						azimuth, direction, time, distance);
-				isWayPointonRouteMap = GPHService.isWayPointOnGPXRoutes(wp);
+				isWayPointonRouteMap = GPHServiceUtil.isWayPointOnGPXRoutes(wp);
 
 			} else {
-				wp = GPHJsonService.buildWayPointForJson(wayPoint_Coordinates,
+
+				wp = GPHJSONUtil.buildWayPointForJson(wayPoint_Coordinates,
 						wayPointDescription, time, distance, avoidance);
-				isWayPointonRouteMap = GPHJsonService.isWayPointinPath(wp);
+				// wp =
+				// GPHJsonService.buildWayPointForJson(wayPoint_Coordinates,
+				// wayPointDescription, time, distance, avoidance);
+				isWayPointonRouteMap = GPHJSONUtil.isWayPointinpath(wp);
+				// isWayPointonRouteMap = GPHJsonService.isWayPointinPath(wp);
 
 			}
 
@@ -342,15 +363,24 @@ public boolean isWayPointonRouteMap(String wayPointIndex,
 				wp = buildWayPoint(wayPoint_Coordinates, wayPointDescription,
 						azimuth, direction, time, distance);
 
-				isWayPointonRouteMapService = GPHService
+				isWayPointonRouteMapService = GPHServiceUtil
 						.isWayPointOnGPXRoutes(wp);
 
 			} else {
 
-				wp = GPHJsonService.buildWayPointForJson(wayPoint_Coordinates,
+				// wp =
+				// GPHJsonService.buildWayPointForJson(wayPoint_Coordinates,
+				// wayPointDescription, time, distance, avoidance);
+				// isWayPointonRouteMapService = GPHJsonService
+				// .isWayPointinPath(wp);
+
+				wp = GPHJSONUtil.buildWayPointForJson(wayPoint_Coordinates,
 						wayPointDescription, time, distance, avoidance);
-				isWayPointonRouteMapService = GPHJsonService
-						.isWayPointinPath(wp);
+				// wp =
+				// GPHJsonService.buildWayPointForJson(wayPoint_Coordinates,
+				// wayPointDescription, time, distance, avoidance);
+				isWayPointonRouteMapService = GPHJSONUtil.isWayPointinpath(wp);
+				// isWayPointonRouteMap = GPHJsonService.isWayPointinPath(wp);
 			}
 			isWayPointonRouteMap = (isWayPointonRouteMapUI)
 					&& (isWayPointonRouteMapService);
@@ -516,9 +546,10 @@ public void verifyTotalRouteTime(String totalRouteTime)
 
 			if (IntegrationTestProperties.getTestProperty("routeType")
 					.equalsIgnoreCase("GPX")) {
-				aTime.setTime(GPHService.getTotalRouteTime());
+				aTime.setTime(GPHServiceUtil.getTotalRouteTime());
 			} else {
-				aTime.setTime(GPHJsonService.getTotalRouteTime());
+				// aTime.setTime(GPHJsonService.getTotalRouteTime());
+				aTime.setTime(GPHJSONUtil.getTotalRouteTime());
 			}
 			LOG.info("The total route time expected is " + eTime.getTime()
 					+ " and actual is " + aTime.getTime());
@@ -531,9 +562,10 @@ public void verifyTotalRouteTime(String totalRouteTime)
 
 			if (IntegrationTestProperties.getTestProperty("routeType")
 					.equalsIgnoreCase("GPX")) {
-				aTime.setTime(GPHService.getTotalRouteTime());
+				aTime.setTime(GPHServiceUtil.getTotalRouteTime());
 			} else {
-				aTime.setTime(GPHJsonService.getTotalRouteTime());
+				// aTime.setTime(GPHJsonService.getTotalRouteTime());
+				aTime.setTime(GPHJSONUtil.getTotalRouteTime());
 			}
 			actualTime = getValue(TOTAL_ROUTE_TIME).split("take ")[1].trim()
 					.replaceAll(" ", "");
@@ -567,13 +599,13 @@ public void isTrackPointonRouteMap(List<Map<String, String>> trackPointsList)
 			Waypoint trackPoint = buildWayPoint(waypointco);
 			if (IntegrationTestProperties.getTestProperty("routeType").equals(
 					"gpx")) {
-				assertTrue(GPHService.isWayPointOnTrack(trackPoint, GPHService
+				assertTrue(GPHServiceUtil.isWayPointOnTrack(trackPoint, GPHServiceUtil
 						.getTracks().iterator().next()));
 			}
 
 			else {
-				assertTrue(GPHJsonService.isWayPointinPath(trackPoint,
-						GPHJsonService.getJsonCoordinatesAsHashSet()));
+				assertTrue(GPHJSONUtil.isWayPointinPath(trackPoint,
+						GPHJSONUtil.getJsonCoordinatesAsHashSet()));
 
 			}
 
@@ -592,13 +624,13 @@ public void isTrackPointNotonRouteMap(
 
 			Waypoint trackPoint = buildWayPoint(waypointco);
 			if (requestParameters.get("type").get(0).equals("gpx")) {
-				assertTrue(!GPHService.isWayPointOnTrack(trackPoint, GPHService
+				assertTrue(!GPHServiceUtil.isWayPointOnTrack(trackPoint, GPHServiceUtil
 						.getTracks().iterator().next()));
 			}
 
 			else {
-				assertTrue(!GPHJsonService.isWayPointinPath(trackPoint,
-						GPHJsonService.getJsonCoordinatesAsHashSet()));
+				assertTrue(!GPHJSONUtil.isWayPointinPath(trackPoint,
+						GPHJSONUtil.getJsonCoordinatesAsHashSet()));
 
 			}
 
@@ -674,7 +706,6 @@ public void verifyWayPointsThroughService() {
 
 	}
 
-
 	protected void addParameter(String key, String value) {
 		ArrayList<String> tempList = null;
 		if (requestParameters.containsKey(key)) {
@@ -703,16 +734,64 @@ protected void addRoutePointsToParameters(String paramName, DataTable dt) {
 
 	public void getRouteFromServiceWithParameters(StringBuffer sb) {
 
-		if (requestParameters.get("type").get(0).equalsIgnoreCase("gpx")) {
-			GPHService.parseRoute(sb);
+		sendAndGetResponse(sb);
+
+	}
+
+	void sendAndGetResponse(StringBuffer sb) {
+		String serviceResponse = "";
+		try {
+			CloseableHttpResponse httpResponse = dispatchServiceRequest(sb.toString());
+			serviceResponse = IOUtils.toString(httpResponse.getEntity()
+					.getContent(), "UTF-8");
+
+		} catch (IOException e) {
+			LOG.info("Exception raised whilst attempting to call graphhopper server "
+					+ e.getMessage());
 		}
 
-		else {
+		if (serviceResponse != null && serviceResponse.length() > 0) {
 
-			GPHJsonService.parse(sb);
+			if (IntegrationTestProperties.getTestProperty("routeType")
+					.equalsIgnoreCase("gpx")) {
+				GPHServiceUtil.parseGPXFromString(serviceResponse);
+			} else {
+				GPHJSONUtil.parse(serviceResponse);
+
+			}
 		}
 
 	}
+	
+	
+	public CloseableHttpResponse dispatchServiceRequest(String requestUrl)
+			throws IOException {
+		String serviceUrl = requestUrl;
+		if (IntegrationTestProperties.getTestPropertyBool("viaApigee")) {
+			serviceUrl += "&apikey="
+					+ IntegrationTestProperties.getTestProperty("apiKey");
+			LOG.debug("APPLYING KEY:");
+		}
+
+		return doSendAndGetResponse(serviceUrl);
+	}
+	
+	private void addCustomHeaders(HttpGet httpget) {
+		for (Entry<String, String> header : customHeaders.entrySet()) {
+			httpget.addHeader(header.getKey(), header.getValue());
+		}
+	}
+
+	CloseableHttpResponse doSendAndGetResponse(String serviceUrl)
+			throws IOException, ClientProtocolException {
+		CloseableHttpClient httpClient = HttpClientUtils.createClient();
+		HttpGet httpget = new HttpGet(serviceUrl);
+		addCustomHeaders(httpget);
+
+		return httpClient.execute(httpget);
+	}
+
+	
 
 	protected void getRouteFromServiceWithParameters() {
 
@@ -923,18 +1002,31 @@ public void getRouteFromUI() {
 
 	public void verifyErrorMessage(String responseMessage) {
 		if (requestParameters.get("type").get(0).equalsIgnoreCase("gpx")) {
-			GPHService.verifyMessage(responseMessage);
+			GPHServiceUtil.verifyMessage(responseMessage);
 		} else {
-			GPHJsonService.verifyMessage(responseMessage);
+			GPHJSONUtil.verifyMessage(responseMessage);
 		}
 	}
 
 	public void verifyStatusCode(int statusCode) {
 		if (requestParameters.get("type").get(0).equalsIgnoreCase("gpx")) {
-			GPHService.verifyStatusCode(statusCode);
+			GPHServiceUtil.verifyStatusCode(statusCode);
 		} else {
-			GPHJsonService.verifyStatusCode(statusCode);
+			GPHJSONUtil.verifyStatusCode(statusCode);
 		}
 	}
 
+	public String getNearestPoint() {
+		
+		return GPHJSONUtil.getNearestPoint();
+		
+	}
+
+	public String getNearestPointDistance() {
+		// TODO Auto-generated method stub
+		return GPHJSONUtil.getNearestPointDistance();
+	}
+
+
+
 }
diff --git a/acceptancetesting/src/test/java/GPHRouteTest.java b/acceptancetesting/src/test/java/GPHRouteTest.java
index 9d7d563a97..4cfa0ccf1b 100644
--- a/acceptancetesting/src/test/java/GPHRouteTest.java
+++ b/acceptancetesting/src/test/java/GPHRouteTest.java
@@ -12,10 +12,14 @@
 import org.junit.Test;
 
 import uk.co.ordnancesurvey.gpx.extensions.ExtensionConstants;
-import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperGPXParserRouteTest;
+import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperGPXParser;
+import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperGPXUtil;
+import uk.co.ordnancesurvey.routing.GraphHopperUIUtil;
 
 public class GPHRouteTest {
-
+	String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
+	GraphHopperGPXParser ghrt = GraphHopperGPXParser.getParserForgpxFileName(path);
+	GraphHopperGPXUtil GPHGPXUtil= new GraphHopperGPXUtil();
 	@BeforeClass
 	public static void setUpBeforeClass() throws Exception {
 	}
@@ -34,44 +38,40 @@ public void tearDown() throws Exception {
 	
 	@Test
 	public void testrouteContainsTurn() {
-		String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
-		GraphHopperGPXParserRouteTest ghrt = GraphHopperGPXParserRouteTest.getParserForgpxFileName(path);
+		
 		HashSet<Route> hs = ghrt.getRoutes();
 		String turn = "turn sharp right onto Bellemoor Road";
 		
-		assertTrue(ghrt.routeContainsTurn(turn, hs.iterator().next()));
+		assertTrue(GPHGPXUtil.routeContainsTurn(turn, hs.iterator().next()));
 	}
 	
 	
 	@Test
 	public void testWayPointIsOnRoute() {
 
-				
-		String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
-		GraphHopperGPXParserRouteTest ghrt = GraphHopperGPXParserRouteTest.getParserForgpxFileName(path);
 		Waypoint wayPoint = getTestWayPoint("50.927146","-1.416787","339","N","2515","13.974","turn  right onto Wellington Road");
 		
 
 		HashSet<Route> hs = ghrt.getRoutes();
 		
-		assertTrue(ghrt.isWayPointOnRoute(wayPoint,hs.iterator().next()));
+		assertTrue(GPHGPXUtil.isWayPointOnRoute(wayPoint,hs.iterator().next()));
 	}
 	
 	@Test
 	public void testTotalRouteTime() {
 		String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
-		GraphHopperGPXParserRouteTest ghrt = GraphHopperGPXParserRouteTest.getParserForgpxFileName(path);
+		GraphHopperGPXParser ghrt = GraphHopperGPXParser.getParserForgpxFileName(path);
 		assertEquals(269000, ghrt.getTotalRouteTime());
 	}
 	
 	@Test
 	public void testGetRouteAsGPX() {
 		String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
-		GraphHopperGPXParserRouteTest ghrt = GraphHopperGPXParserRouteTest.getParserForgpxFileName(path);
+		GraphHopperGPXParser ghrt = GraphHopperGPXParser.getParserForgpxFileName(path);
 		HashSet<Route> hs = ghrt.getRoutes();
 		
 		Route next = hs.iterator().next();
-		assertTrue(ghrt.routeContainsTurn("turn sharp right onto Bellemoor Road",next));
+		assertTrue(GPHGPXUtil.routeContainsTurn("turn sharp right onto Bellemoor Road",next));
 	}
 
 	private Waypoint getTestWayPoint(String lat, String lon,String azimuth,String direction,String time,String distance,String description) {
