diff --git a/config-example.yml b/config-example.yml
deleted file mode 100644
index ebebcccd84..0000000000
--- a/config-example.yml
+++ /dev/null
@@ -1,144 +0,0 @@
-graphhopper:
-
-  # OpenStreetMap input file
-  # datareader.file: some.pbf
-
-  ##### Vehicles #####
-
-
-  # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
-  # bike2 takes elevation data into account (like up-hill is slower than down-hill) and requires enabling graph.elevation.provider below
-  graph.flag_encoders: car
-
-
-  # Enable turn restrictions for car or motorcycle.
-  # graph.flag_encoders: car|turn_costs=true
-
-
-  ##### Elevation #####
-
-
-  # To populate your graph with elevation data use SRTM, default is noop (no elevation)
-  # graph.elevation.provider: srtm
-
-
-  # default location for cache is /tmp/srtm
-  # graph.elevation.cache_dir: ./srtmprovider/
-
-
-  # If you have a slow disk or plenty of RAM change the default MMAP to:
-  # graph.elevation.dataaccess: RAM_STORE
-
-
-
-  #### Speed, hybrid and flexible mode ####
-
-
-  # By default the speed mode with the 'fastest' weighting is used. Internally a graph preparation via
-  # contraction hierarchies (CH) is done to speed routing up. This requires more RAM/disc space for holding the
-  # graph but less for every request. You can also setup multiple weightings, by providing a comma separated list.
-  prepare.ch.weightings: fastest
-
-
-  # Disable the speed mode. Should be used only with routing.max_visited_nodes or when the hybrid mode is enabled instead
-  # prepare.ch.weightings: no
-
-
-  # To make CH preparation faster for multiple flagEncoders you can increase the default threads if you have enough RAM.
-  # Change this setting only if you know what you are doing and if the default worked for you.
-  # prepare.ch.threads: 1
-
-
-  # The hybrid mode can be enabled with
-  # prepare.lm.weightings: fastest
-
-  # To tune the performance vs. memory usage for the hybrid mode use
-  # prepare.lm.landmarks: 16
-
-  # Make landmark preparation parallel if you have enough RAM. Change this only if you know what you are doing and if the default worked for you.
-  # prepare.lm.threads: 1
-
-
-  # avoid being stuck in a (oneway) subnetwork, see https://discuss.graphhopper.com/t/93
-  prepare.min_network_size: 200
-  prepare.min_one_way_network_size: 200
-
-
-
-  ##### Routing #####
-
-
-  # You can define the maximum visited nodes when routing. This may result in not found connections if there is no
-  # connection between two points within the given visited nodes. The default is Integer.MAX_VALUE. Useful for flexibility mode
-  # routing.max_visited_nodes: 1000000
-
-
-  # If enabled, allows a user to run flexibility requests even if speed mode is enabled. Every request then has to include a hint routing.ch.disable=true.
-  # Attention, non-CH route calculations take way more time and resources, compared to CH routing.
-  # A possible attacker might exploit this to slow down your service. Only enable it if you need it and with routing.maxVisitedNodes
-  # routing.ch.disabling_allowed: true
-
-
-  # If enabled, allows a user to run flexible mode requests even if the hybrid mode is enabled. Every such request then has to include a hint routing.lm.disable=true.
-  # routing.lm.disabling_allowed: true
-
-  # Control how many active landmarks are picked per default, this can improve query performance
-  # routing.lm.active_landmarks: 4
-
-
-  # You can limit the max distance between two consecutive waypoints of flexible routing requests to be less or equal
-  # the given distance in meter. Default is set to 1000km.
-  routing.non_ch.max_waypoint_distance: 1000000
-
-
-  ##### Storage #####
-
-
-  # configure the memory access, use RAM_STORE for well equipped servers (default and recommended)
-  graph.dataaccess: RAM_STORE
-
-
-  # will write way names in the preferred language (language code as defined in ISO 639-1 or ISO 639-2):
-  # datareader.preferred_language: en
-
-
-  # Sort the graph after import to make requests roughly ~10% faster. Note that this requires significantly more RAM on import.
-  # graph.do_sort: true
-
-
-
-  ##### Spatial Rules #####
-  # Spatial Rules require some configuration and only work with the DataFlagEncoder.
-
-
-  # Spatial Rules require you to provide Polygons in which the rules are enforced
-  # The line below contains the default location for these rules
-  # spatial_rules.location: core/files/spatialrules/countries.geo.json
-
-  # You can define the maximum BBox for which spatial rules are loaded.
-  # You might want to do this if you are only importing a small area and don't need rules for other countries.
-  # Having less rules, might result in a smaller graph. The line below contains the world-wide bounding box, uncomment and adapt to your need.
-  # spatial_rules.max_bbox: -180,180,-90,90
-
-
-# Uncomment the following to point /maps to the source directory in the filesystem instead of
-# the Java resource path. Helpful for development of the web client.
-# Assumes that the web module is the working directory.
-#
-# assets:
-#  overrides:
-#    /maps: web/src/main/resources/assets/
-
-# Dropwizard server configuration
-server:
-  applicationConnectors:
-  - type: http
-    port: 8989
-    # for security reasons bind to localhost
-    bindHost: localhost
-  requestLog:
-      appenders: []
-  adminConnectors:
-  - type: http
-    port: 8990
-    bindHost: localhost
diff --git a/core/pom.xml b/core/pom.xml
index 0bfd37bedc..d95f0ca5d0 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -89,6 +89,12 @@
             <version>${project.parent.version}</version>
             <scope>test</scope>
         </dependency>
+
+        <dependency>
+            <groupId>com.vividsolutions</groupId>
+            <artifactId>jts-core</artifactId>
+            <version>1.14.0</version>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 3ed6365439..a715d4fc38 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -925,6 +925,10 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
             weighting = new ShortFastestWeighting(encoder, hintsMap);
         }
 
+        if (encoder.getClass() == GreenWalkFlagEncoder.class) {
+            weighting = new GreenWalkWeighting(encoder, hintsMap);
+        }
+
         if (weighting == null)
             throw new IllegalArgumentException("weighting " + weightingStr + " not supported");
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java b/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
index 8a07722194..a3a4b6b0c2 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultFlagEncoderFactory.java
@@ -57,6 +57,9 @@ else if (name.equals(CAR4WD))
         if (name.equals(MOTORCYCLE))
             return new MotorcycleFlagEncoder(configuration);
 
+        if (name.equals(GREEN_WALK))
+            return new GreenWalkFlagEncoder(configuration);
+
         throw new IllegalArgumentException("entry in encoder list not supported " + name);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
index 71eb01bca9..8c997752ad 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
@@ -33,6 +33,7 @@
     final String HIKE = "hike";
     final String MOTORCYCLE = "motorcycle";
     final String GENERIC = "generic";
+    final String GREEN_WALK = "green_walk";
     final FlagEncoderFactory DEFAULT = new DefaultFlagEncoderFactory();
 
     FlagEncoder createFlagEncoder(String name, PMap configuration);
diff --git a/core/src/main/java/com/graphhopper/routing/util/GreenWalkFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/GreenWalkFlagEncoder.java
new file mode 100644
index 0000000000..5ff1edac78
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/GreenWalkFlagEncoder.java
@@ -0,0 +1,402 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.graphhopper.reader.ReaderRelation;
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.weighting.GreenWalkWeighting;
+import com.graphhopper.routing.weighting.PriorityWeighting;
+import com.graphhopper.util.PMap;
+
+import java.util.*;
+
+import static com.graphhopper.routing.util.PriorityCode.*;
+
+/**
+ * Defines bit layout for pedestrians (speed, access, surface, ...). Here we put a penalty on unsafe
+ * roads only. If you wish to also prefer routes due to beauty like hiking routes use the
+ * HikeFlagEncoder instead.
+ * <p>
+ *
+ * @author Peter Karich
+ * @author Nop
+ * @author Karl HÃ¼bner
+ */
+public class GreenWalkFlagEncoder extends AbstractFlagEncoder {
+    public static final int GREENNESS_KEY = 113;
+    private static final int SPEED = 5;
+    private final Set<String> safeHighwayTags = new HashSet<>();
+    private final Set<String> allowedHighwayTags = new HashSet<>();
+    private final Set<String> avoidHighwayTags = new HashSet<>();
+    // convert network tag of hiking routes into a way route code
+    private final Map<String, Integer> hikingNetworkToCode = new HashMap<>();
+    private HashSet<String> sidewalkValues = new HashSet<>(5);
+    private HashSet<String> sidewalksNoValues = new HashSet<>(5);
+    private EncodedValue priorityWayEncoder;
+    private EncodedValue relationCodeEncoder;
+    private EncodedValue greennessEncoder;
+
+    /**
+     * Should be only instantiated via EncodingManager
+     */
+    public GreenWalkFlagEncoder() {
+        this(4, 1);
+    }
+
+    public GreenWalkFlagEncoder(PMap properties) {
+        this((int) properties.getLong("speedBits", 4),
+                properties.getDouble("speedFactor", 1));
+        this.properties = properties;
+        this.setBlockFords(properties.getBool("block_fords", true));
+    }
+
+    public GreenWalkFlagEncoder(String propertiesStr) {
+        this(new PMap(propertiesStr));
+    }
+
+    public GreenWalkFlagEncoder(int speedBits, double speedFactor) {
+        super(speedBits, speedFactor, 0);
+        restrictions.addAll(Arrays.asList("foot", "access"));
+        restrictedValues.add("private");
+        restrictedValues.add("no");
+        restrictedValues.add("restricted");
+        restrictedValues.add("military");
+        restrictedValues.add("emergency");
+
+        intendedValues.add("yes");
+        intendedValues.add("designated");
+        intendedValues.add("official");
+        intendedValues.add("permissive");
+
+        sidewalksNoValues.add("no");
+        sidewalksNoValues.add("none");
+        // see #712
+        sidewalksNoValues.add("separate");
+
+        sidewalkValues.add("yes");
+        sidewalkValues.add("both");
+        sidewalkValues.add("left");
+        sidewalkValues.add("right");
+
+        setBlockByDefault(false);
+        potentialBarriers.add("gate");
+
+        safeHighwayTags.add("footway");
+        safeHighwayTags.add("path");
+        safeHighwayTags.add("steps");
+        safeHighwayTags.add("pedestrian");
+        safeHighwayTags.add("living_street");
+        safeHighwayTags.add("track");
+        safeHighwayTags.add("residential");
+        safeHighwayTags.add("service");
+
+        avoidHighwayTags.add("trunk");
+        avoidHighwayTags.add("trunk_link");
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("secondary");
+        avoidHighwayTags.add("secondary_link");
+        avoidHighwayTags.add("tertiary");
+        avoidHighwayTags.add("tertiary_link");
+
+        // for now no explicit avoiding #257
+        //avoidHighwayTags.add("cycleway"); 
+        allowedHighwayTags.addAll(safeHighwayTags);
+        allowedHighwayTags.addAll(avoidHighwayTags);
+        allowedHighwayTags.add("cycleway");
+        allowedHighwayTags.add("unclassified");
+        allowedHighwayTags.add("road");
+        // disallowed in some countries
+        //allowedHighwayTags.add("bridleway");
+
+        hikingNetworkToCode.put("iwn", UNCHANGED.getValue());
+        hikingNetworkToCode.put("nwn", UNCHANGED.getValue());
+        hikingNetworkToCode.put("rwn", UNCHANGED.getValue());
+        hikingNetworkToCode.put("lwn", UNCHANGED.getValue());
+
+        maxPossibleSpeed = SPEED;
+
+        init();
+    }
+
+    @Override
+    public int getVersion() {
+        return 4;
+    }
+
+    @Override
+    public int defineWayBits(int index, int shift) {
+        // first two bits are reserved for route handling in superclass
+        shift = super.defineWayBits(index, shift);
+        // larger value required - ferries are faster than pedestrians
+        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, SPEED, maxPossibleSpeed);
+        shift += speedEncoder.getBits();
+
+        priorityWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
+        shift += priorityWayEncoder.getBits();
+
+        greennessEncoder = new EncodedValue("Greenness", shift, 4, 1, 0, 9);
+        shift += greennessEncoder.getBits();
+
+        return shift;
+    }
+
+    @Override
+    public int defineRelationBits(int index, int shift) {
+        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
+        return shift + relationCodeEncoder.getBits();
+    }
+
+    /**
+     * Foot flag encoder does not provide any turn cost / restrictions
+     */
+    @Override
+    public int defineTurnBits(int index, int shift) {
+        return shift;
+    }
+
+    /**
+     * Foot flag encoder does not provide any turn cost / restrictions
+     * <p>
+     *
+     * @return <code>false</code>
+     */
+    @Override
+    public boolean isTurnRestricted(long flag) {
+        return false;
+    }
+
+    /**
+     * Foot flag encoder does not provide any turn cost / restrictions
+     * <p>
+     *
+     * @return 0
+     */
+    @Override
+    public double getTurnCost(long flag) {
+        return 0;
+    }
+
+    @Override
+    public long getTurnFlags(boolean restricted, double costs) {
+        return 0;
+    }
+
+    /**
+     * Some ways are okay but not separate for pedestrians.
+     * <p>
+     */
+    @Override
+    public long acceptWay(ReaderWay way) {
+        String highwayValue = way.getTag("highway");
+        if (highwayValue == null) {
+            long acceptPotentially = 0;
+
+            if (way.hasTag("route", ferries)) {
+                String footTag = way.getTag("foot");
+                if (footTag == null || "yes".equals(footTag))
+                    acceptPotentially = acceptBit | ferryBit;
+            }
+
+            // special case not for all acceptedRailways, only platform
+            if (way.hasTag("railway", "platform"))
+                acceptPotentially = acceptBit;
+
+            if (way.hasTag("man_made", "pier"))
+                acceptPotentially = acceptBit;
+
+            if (acceptPotentially != 0) {
+                if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
+                    return 0;
+                return acceptPotentially;
+            }
+
+            return 0;
+        }
+
+        String sacScale = way.getTag("sac_scale");
+        if (sacScale != null) {
+            if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale)
+                    && !"demanding_mountain_hiking".equals(sacScale) && !"alpine_hiking".equals(sacScale))
+                // other scales are too dangerous, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
+                return 0;
+        }
+
+        // no need to evaluate ferries or fords - already included here
+        if (way.hasTag("foot", intendedValues))
+            return acceptBit;
+
+        // check access restrictions
+        if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
+            return 0;
+
+        if (way.hasTag("sidewalk", sidewalkValues))
+            return acceptBit;
+
+        if (!allowedHighwayTags.contains(highwayValue))
+            return 0;
+
+        if (way.hasTag("motorroad", "yes"))
+            return 0;
+
+        // do not get our feet wet, "yes" is already included above
+        if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
+            return 0;
+
+        if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
+            return 0;
+
+        return acceptBit;
+    }
+
+    @Override
+    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
+        int code = 0;
+        if (relation.hasTag("route", "hiking") || relation.hasTag("route", "foot")) {
+            Integer val = hikingNetworkToCode.get(relation.getTag("network"));
+            if (val != null)
+                code = val;
+            else
+                code = hikingNetworkToCode.get("lwn");
+        } else if (relation.hasTag("route", "ferry")) {
+            code = PriorityCode.AVOID_IF_POSSIBLE.getValue();
+        }
+
+        int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
+        if (oldCode < code)
+            return relationCodeEncoder.setValue(0, code);
+        return oldRelationFlags;
+    }
+
+    @Override
+    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
+        if (!isAccept(allowed))
+            return 0;
+
+        long flags = 0;
+        flags = speedEncoder.setDoubleValue(flags, SPEED);
+        flags |= directionBitMask;
+
+        boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
+        if (isRoundabout)
+            flags = setBool(flags, K_ROUNDABOUT, true);
+
+        int priorityFromRelation = 0;
+        if (relationFlags != 0)
+            priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
+
+        flags = priorityWayEncoder.setValue(flags, handlePriority(way, priorityFromRelation));
+
+        // COMPUTE GREENNESS
+        int greenness = 0;
+
+        if ("footway".equals(way.getTag("highway"))) {
+            greenness += 1;
+        }
+
+        greenness += Math.log10(Integer.parseInt(way.getTag("nearby_trees")) + 1);
+
+        greenness = Math.min(greenness, 9);
+
+        flags = greennessEncoder.setValue(flags, greenness);
+
+        return flags;
+    }
+
+    @Override
+    public double getDouble(long flags, int key) {
+        switch (key) {
+            case PriorityWeighting.KEY:
+                return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
+            case GreenWalkFlagEncoder.GREENNESS_KEY:
+                return (double) greennessEncoder.getValue(flags);
+            default:
+                return super.getDouble(flags, key);
+        }
+    }
+
+    protected int handlePriority(ReaderWay way, int priorityFromRelation) {
+        TreeMap<Double, Integer> weightToPrioMap = new TreeMap<>();
+        if (priorityFromRelation == 0)
+            weightToPrioMap.put(0d, UNCHANGED.getValue());
+        else
+            weightToPrioMap.put(110d, priorityFromRelation);
+
+        collect(way, weightToPrioMap);
+
+        // pick priority with biggest order value
+        return weightToPrioMap.lastEntry().getValue();
+    }
+
+    /**
+     * @param weightToPrioMap associate a weight with every priority. This sorted map allows
+     *                        subclasses to 'insert' more important priorities as well as overwrite determined priorities.
+     */
+    void collect(ReaderWay way, TreeMap<Double, Integer> weightToPrioMap) {
+        String highway = way.getTag("highway");
+        if (way.hasTag("foot", "designated"))
+            weightToPrioMap.put(100d, PREFER.getValue());
+
+        double maxSpeed = getMaxSpeed(way);
+        if (safeHighwayTags.contains(highway) || maxSpeed > 0 && maxSpeed <= 20) {
+            weightToPrioMap.put(40d, PREFER.getValue());
+            if (way.hasTag("tunnel", intendedValues)) {
+                if (way.hasTag("sidewalk", sidewalksNoValues))
+                    weightToPrioMap.put(40d, AVOID_IF_POSSIBLE.getValue());
+                else
+                    weightToPrioMap.put(40d, UNCHANGED.getValue());
+            }
+        } else if (maxSpeed > 50 || avoidHighwayTags.contains(highway)) {
+            if (!way.hasTag("sidewalk", sidewalkValues))
+                weightToPrioMap.put(45d, AVOID_IF_POSSIBLE.getValue());
+        }
+
+        if (way.hasTag("bicycle", "official") || way.hasTag("bicycle", "designated"))
+            weightToPrioMap.put(44d, AVOID_IF_POSSIBLE.getValue());
+    }
+
+    @Override
+    public boolean supports(Class<?> feature) {
+        if (super.supports(feature))
+            return true;
+
+        if (GreenWalkWeighting.class.isAssignableFrom(feature)) {
+            return true;
+        }
+
+        return PriorityWeighting.class.isAssignableFrom(feature);
+    }
+
+    @Override
+    public String toString() {
+        return "green_walk";
+    }
+
+    /*
+     * This method is a current hack, to allow ferries to be actually faster than our current storable maxSpeed.
+     */
+    @Override
+    public double getSpeed(long flags) {
+        double speed = super.getSpeed(flags);
+        if (speed == getMaxSpeed()) {
+            // We cannot be sure if it was a long or a short trip
+            return SHORT_TRIP_FERRY_SPEED;
+        }
+        return speed;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/GreenWalkWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/GreenWalkWeighting.java
new file mode 100644
index 0000000000..929024b254
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/weighting/GreenWalkWeighting.java
@@ -0,0 +1,59 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.GreenWalkFlagEncoder;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PMap;
+
+public class GreenWalkWeighting extends PriorityWeighting {
+    private final double minFactor;
+
+    public GreenWalkWeighting(FlagEncoder flagEncoder, PMap pMap) {
+        super(flagEncoder, pMap);
+
+        minFactor = 0.2;
+    }
+
+    @Override
+    public double getMinWeight(double distance) {
+        return minFactor * distance;
+    }
+
+    @Override
+    public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+        double priority = flagEncoder.getDouble(edge.getFlags(), KEY);
+        double greenness = flagEncoder.getDouble(edge.getFlags(), GreenWalkFlagEncoder.GREENNESS_KEY);
+
+        double distance = edge.getDistance();
+        double factor = 1 / (0.5 + priority);
+        if (greenness > 0) {
+            factor *= 1 / greenness;
+        }
+
+        factor = Math.max(factor, minFactor);
+
+        return factor * distance;
+    }
+
+    @Override
+    public String getName() {
+        return "green_walk_weighting";
+    }
+}
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index 52d49d695a..aa132244d1 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -31,6 +31,9 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import com.vividsolutions.jts.geom.Coordinate;
+import com.vividsolutions.jts.geom.Envelope;
+import com.vividsolutions.jts.index.kdtree.KdTree;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -114,6 +117,9 @@
     private Date osmDataDate;
     private boolean createStorage = true;
 
+    private KdTree trees = new KdTree();
+    private int treesCount = 0;
+
     public OSMReader(GraphHopperStorage ghStorage) {
         this.ghStorage = ghStorage;
         this.graph = ghStorage;
@@ -160,7 +166,14 @@ void preProcess(File osmFile) {
             long tmpRelationCounter = 1;
             ReaderElement item;
             while ((item = in.getNext()) != null) {
-                if (item.isType(ReaderElement.WAY)) {
+                if (item.isType(ReaderElement.NODE)) {
+                    final ReaderNode node = (ReaderNode) item;
+                    boolean isTree = "tree".equals(node.getTag("natural"));
+                    if (isTree) {
+                        trees.insert(new Coordinate(node.getLon(), node.getLat()), node);
+                        treesCount++;
+                    }
+                } else if (item.isType(ReaderElement.WAY)) {
                     final ReaderWay way = (ReaderWay) item;
                     boolean valid = filterWay(way);
                     if (valid) {
@@ -265,7 +278,7 @@ private void writeOsm2Graph(File osmFile) {
 
                     case ReaderElement.WAY:
                         if (wayStart < 0) {
-                            LOGGER.info(nf(counter) + ", now parsing ways");
+                            LOGGER.info(nf(counter) + "/" + treesCount + ", now parsing ways");
                             wayStart = counter;
                         }
                         processWay((ReaderWay) item);
@@ -349,6 +362,42 @@ void processWay(ReaderWay way) {
             }
         }
 
+        if (osmNodeIds.size() > 1) {
+            int first = getNodeMap().get(osmNodeIds.get(0));
+            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+
+            double delta = 0.0005;
+
+            Envelope envQuery = new Envelope();
+            envQuery.expandToInclude(firstLon, firstLat);
+            envQuery.expandToInclude(lastLon, lastLat);
+            int nearbyTrees = trees.query(envQuery).size();
+
+//            Envelope firstEnv = new Envelope();
+//            firstEnv.expandToInclude(firstLon, firstLat);
+//            firstEnv.expandBy(delta);
+//
+//            Envelope lastEnv = new Envelope();
+//            lastEnv.expandToInclude(lastLon, lastLat);
+//            lastEnv.expandBy(delta);
+//
+//            int nearbyTrees = trees.query(firstEnv).size() + trees.query(lastEnv).size();
+//
+//            if (way.getId() == 68881723) {
+//                System.out.println(firstEnv);
+//                System.out.println(lastEnv);
+//            }
+
+            if (way.getId() == 68881723) {
+                System.out.println(nearbyTrees);
+            }
+
+            way.setTag("nearby_trees", Integer.toString(nearbyTrees));
+
+        }
+
         long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
         if (wayFlags == 0)
             return;
