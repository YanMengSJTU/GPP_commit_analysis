diff --git a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
index ef4526d9de..d8d557b08d 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/dpn/OsDpnElement.java
@@ -42,144 +42,175 @@
  * @author Nop
  * @author Peter
  */
-public abstract class OsDpnElement implements RoutingElement {
+public abstract class OsDpnElement implements RoutingElement
+{
     public static final int NODE = 0;
     public static final int WAY = 1;
     public static final int RELATION = 2;
     private final int type;
     private final String id;
-    private final Map<String, Object> properties = new HashMap<String, Object>(
-            5);
-    private static final Logger logger = LoggerFactory
-            .getLogger(OsDpnElement.class);
-
-    protected OsDpnElement(String id, int type) {
-        this.id = id;
-        this.type = type;
+    private final Map<String, Object> properties = new HashMap<String, Object>(5);
+    private static final Logger logger = LoggerFactory.getLogger(OsDpnElement.class);
+
+    private boolean nameSet = false;
+
+    protected OsDpnElement(String id, int type)
+    {
+	this.id = id;
+	this.type = type;
     }
 
-    public String getId() {
-        return id;
+    public String getId()
+    {
+	return id;
     }
 
     protected void readTags(XMLStreamReader parser) throws XMLStreamException,
-            MismatchedDimensionException, FactoryException, TransformException {
-        int event = parser.getEventType();
-        while (event != XMLStreamConstants.END_DOCUMENT
-                && (event != XMLStreamConstants.END_ELEMENT || !exitElement(parser))) {
-            if (event == XMLStreamConstants.CHARACTERS) {
-                event = parser.next();
-            } else {
-                if (event == XMLStreamConstants.START_ELEMENT) {
-                    // logger.info("LOCALNAME: {}", parser.getLocalName());
-                    switch (parser.getLocalName()) {
-                        case "pos":
-                        case "coordinates": {
-                            event = handleCoordinates(parser);
-                            break;
-                        }
-                        case "networkMember": {
-                            event = handleNetworkMember(parser);
-                            break;
-                        }
-                        case "posList": {
-                            event = handleMultiDimensionCoords(parser);
-                            break;
-                        }
-                        case "startNode":
-                        case "endNode": {
-                            event = handleNode(parser);
-                            break;
-                        }
-                        case "directedLink": {
-                            event = handleDirectedLink(parser);
-                            break;
-                        }
-                        case "instruction": {
-                            System.err.println("INSTRUCTION:");
-                            setTag("type", "restriction");
-                            event = handleTag("restriction", parser);
-                            break;
-                        }
-                        case "descriptiveTerm": {
-                            event = handleDescriptiveTerm(parser);
-                            break;
-                        }
-                        case "name": {
-                            event = handleTag("name", parser);
-                            break;
-                        }
-                        default: {
-                            event = parser.next();
-                        }
-                    }
-                } else {
-                    // logger.trace("EVENT:" + event);
-                    event = parser.next();
-                }
-            }
-        }
+		    MismatchedDimensionException, FactoryException, TransformException
+    {
+	int event = parser.getEventType();
+	while (event != XMLStreamConstants.END_DOCUMENT
+			&& (event != XMLStreamConstants.END_ELEMENT || !exitElement(parser)))
+	    if (event == XMLStreamConstants.CHARACTERS)
+		event = parser.next();
+	    else if (event == XMLStreamConstants.START_ELEMENT)
+		// logger.info("LOCALNAME: {}", parser.getLocalName());
+		switch (parser.getLocalName())
+		{
+		case "pos":
+		case "coordinates":
+		{
+		    event = handleCoordinates(parser);
+		    break;
+		}
+		case "networkMember":
+		{
+		    event = handleNetworkMember(parser);
+		    break;
+		}
+		case "posList":
+		{
+		    event = handleMultiDimensionCoords(parser);
+		    break;
+		}
+		case "startNode":
+		case "endNode":
+		{
+		    event = handleNode(parser);
+		    break;
+		}
+		case "directedLink":
+		{
+		    event = handleDirectedLink(parser);
+		    break;
+		}
+		case "instruction":
+		{
+		    System.err.println("INSTRUCTION:");
+		    setTag("type", "restriction");
+		    event = handleTag("restriction", parser);
+		    break;
+		}
+		case "descriptiveTerm":
+		{
+		    event = handleDescriptiveTerm(parser);
+		    break;
+		}
+		case "name":
+		case "alternativeName":
+		{
+		    event = handleName(parser);
+		    break;
+		}
+		default:
+		{
+		    event = parser.next();
+		}
+		}
+	    else
+		// logger.trace("EVENT:" + event);
+		event = parser.next();
+    }
+
+    private int handleName(XMLStreamReader parser) throws XMLStreamException
+    {
+	StringBuilder nameString = new StringBuilder();
+	if (nameSet)
+	{
+	    nameString.append(getTag("name"));
+	    nameString.append(" (");
+	}
+	nameString.append(parser.getElementText());
+	if (nameSet)
+	    nameString.append(")");
+	nameSet = true;
+	setTag("name", nameString.toString());
+	return parser.getEventType();
+    }
+
+    private int handleDescriptiveTerm(XMLStreamReader parser) throws XMLStreamException
+    {
+	String roadType = parser.getElementText();
+	setTag("type", "route");
+	setTag("highway", roadType);
+	setTag("name", getTypeBasedName(roadType));
+	return parser.getEventType();
     }
 
-    private int handleDescriptiveTerm(XMLStreamReader parser)
-            throws XMLStreamException {
-        String roadType = parser.getElementText();
-        setTag("type", "route");
-        setTag("highway", roadType);
-        setTag("name", roadType);
-        return parser.getEventType();
+    private Object getTypeBasedName(String roadType)
+    {
+	if (roadType.equals("No Physical Manifestation"))
+	    return "Route";
+	return roadType;
     }
 
-    private int handleDirectedLink(XMLStreamReader parser)
-            throws XMLStreamException {
-        String orientation = parser.getAttributeValue(null, "orientation");
-        String nodeId = parser.getAttributeValue(
-                "http://www.w3.org/1999/xlink", "href");
-        addDirectedLink(nodeId, orientation);
-        return parser.next();
+    private int handleDirectedLink(XMLStreamReader parser) throws XMLStreamException
+    {
+	String orientation = parser.getAttributeValue(null, "orientation");
+	String nodeId = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
+	addDirectedLink(nodeId, orientation);
+	return parser.next();
     }
 
-    private int handleNode(XMLStreamReader parser) throws XMLStreamException {
-        String nodeId = parser.getAttributeValue(
-                "http://www.w3.org/1999/xlink", "href");
-        addNode(nodeId);
-        return parser.next();
+    private int handleNode(XMLStreamReader parser) throws XMLStreamException
+    {
+	String nodeId = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
+	addNode(nodeId);
+	return parser.next();
     }
 
-    private int handleTag(String key, XMLStreamReader parser)
-            throws XMLStreamException {
-        properties.put(key, parser.getElementText());
-        return parser.getEventType();
+    private int handleTag(String key, XMLStreamReader parser) throws XMLStreamException
+    {
+	properties.put(key, parser.getElementText());
+	return parser.getEventType();
     }
 
-    private int handleNetworkMember(XMLStreamReader parser)
-            throws XMLStreamException {
-        String elementText = parser.getAttributeValue(
-                "http://www.w3.org/1999/xlink", "href");
-        parseNetworkMember(elementText);
-        return parser.next();
+    private int handleNetworkMember(XMLStreamReader parser) throws XMLStreamException
+    {
+	String elementText = parser.getAttributeValue("http://www.w3.org/1999/xlink", "href");
+	parseNetworkMember(elementText);
+	return parser.next();
     }
 
-    private int handleCoordinates(XMLStreamReader parser)
-            throws XMLStreamException, MismatchedDimensionException,
-            FactoryException, TransformException {
-        String elementText = parser.getElementText();
-        parseCoords(elementText);
-        return parser.getEventType();
+    private int handleCoordinates(XMLStreamReader parser) throws XMLStreamException,
+		    MismatchedDimensionException, FactoryException, TransformException
+    {
+	String elementText = parser.getElementText();
+	parseCoords(elementText);
+	return parser.getEventType();
     }
 
-    private int handleMultiDimensionCoords(XMLStreamReader parser)
-            throws XMLStreamException {
-        String dimensionality = parser.getAttributeValue(null, "srsDimension");
-        logger.info("Dimensions:" + dimensionality);
-        String elementText = parser.getElementText();
-        parseCoords(Integer.valueOf(dimensionality), elementText);
-        return parser.getEventType();
+    private int handleMultiDimensionCoords(XMLStreamReader parser) throws XMLStreamException
+    {
+	String dimensionality = parser.getAttributeValue(null, "srsDimension");
+	logger.info("Dimensions:" + dimensionality);
+	String elementText = parser.getElementText();
+	parseCoords(Integer.valueOf(dimensionality), elementText);
+	return parser.getEventType();
     }
 
-    protected abstract void parseCoords(String coordinates)
-            throws MismatchedDimensionException, FactoryException,
-            TransformException;
+    protected abstract void parseCoords(String coordinates) throws MismatchedDimensionException,
+		    FactoryException, TransformException;
 
     protected abstract void parseCoords(int dimensions, String lineDefinition);
 
@@ -189,131 +220,146 @@ protected abstract void parseCoords(String coordinates)
 
     protected abstract void parseNetworkMember(String elementText);
 
-    private boolean exitElement(XMLStreamReader parser) {
-        switch (parser.getLocalName()) {
-            case "RouteNode":
-            case "RouteLink":
-            case "Route":
-                return true;
-        }
-        return false;
+    private boolean exitElement(XMLStreamReader parser)
+    {
+	switch (parser.getLocalName())
+	{
+	case "RouteNode":
+	case "RouteLink":
+	case "Route":
+	    return true;
+	}
+	return false;
     }
 
-    protected String tagsToString() {
-        if (properties.isEmpty())
-            return "<empty>";
-
-        StringBuilder tagTxt = new StringBuilder();
-        for (Map.Entry<String, Object> entry : properties.entrySet()) {
-            tagTxt.append(entry.getKey());
-            tagTxt.append("=");
-            tagTxt.append(entry.getValue());
-            tagTxt.append("\n");
-        }
-        return tagTxt.toString();
+    protected String tagsToString()
+    {
+	if (properties.isEmpty())
+	    return "<empty>";
+
+	StringBuilder tagTxt = new StringBuilder();
+	for (Map.Entry<String, Object> entry : properties.entrySet())
+	{
+	    tagTxt.append(entry.getKey());
+	    tagTxt.append("=");
+	    tagTxt.append(entry.getValue());
+	    tagTxt.append("\n");
+	}
+	return tagTxt.toString();
     }
 
-    protected Map<String, Object> getTags() {
-        return properties;
+    protected Map<String, Object> getTags()
+    {
+	return properties;
     }
 
-    public void setTags(Map<String, String> newTags) {
-        properties.clear();
-        if (newTags != null)
-            for (Entry<String, String> e : newTags.entrySet()) {
-                setTag(e.getKey(), e.getValue());
-            }
+    public void setTags(Map<String, String> newTags)
+    {
+	properties.clear();
+	if (newTags != null)
+	    for (Entry<String, String> e : newTags.entrySet())
+		setTag(e.getKey(), e.getValue());
     }
 
     @Override
-    public boolean hasTags() {
-        return !properties.isEmpty();
+    public boolean hasTags()
+    {
+	return !properties.isEmpty();
     }
 
     @Override
-    public String getTag(String name) {
-        return (String) properties.get(name);
+    public String getTag(String name)
+    {
+	return (String) properties.get(name);
     }
 
     @Override
     @SuppressWarnings("unchecked")
-    public <T> T getTag(String key, T defaultValue) {
-        T val = (T) properties.get(key);
-        if (val == null)
-            return defaultValue;
-        return val;
+    public <T> T getTag(String key, T defaultValue)
+    {
+	T val = (T) properties.get(key);
+	if (val == null)
+	    return defaultValue;
+	return val;
     }
 
     @Override
-    public void setTag(String name, Object value) {
-        properties.put(name, value);
+    public void setTag(String name, Object value)
+    {
+	properties.put(name, value);
     }
 
     /**
      * Chaeck that the object has a given tag with a given value.
      */
     @Override
-    public boolean hasTag(String key, Object value) {
-        return value.equals(properties.get(key));
+    public boolean hasTag(String key, Object value)
+    {
+	return value.equals(properties.get(key));
     }
 
     /**
-     * Check that a given tag has one of the specified values. If no values are
-     * given, just checks for presence of the tag
+     * Check that a given tag has one of the specified values. If no values are given, just checks
+     * for presence of the tag
      */
     @Override
-    public boolean hasTag(String key, String... values) {
-        Object osmValue = properties.get(key);
-        if (osmValue == null)
-            return false;
-
-        // tag present, no values given: success
-        if (values.length == 0)
-            return true;
-
-        for (String val : values) {
-            if (val.equals(osmValue))
-                return true;
-        }
-        return false;
+    public boolean hasTag(String key, String... values)
+    {
+	Object osmValue = properties.get(key);
+	if (osmValue == null)
+	    return false;
+
+	// tag present, no values given: success
+	if (values.length == 0)
+	    return true;
+
+	for (String val : values)
+	    if (val.equals(osmValue))
+		return true;
+	return false;
     }
 
     /**
      * Check that a given tag has one of the specified values.
      */
     @Override
-    public final boolean hasTag(String key, Set<String> values) {
-        return values.contains(properties.get(key));
+    public final boolean hasTag(String key, Set<String> values)
+    {
+	return values.contains(properties.get(key));
     }
 
     /**
-     * Check a number of tags in the given order for the any of the given
-     * values. Used to parse hierarchical access restrictions
+     * Check a number of tags in the given order for the any of the given values. Used to parse
+     * hierarchical access restrictions
      */
     @Override
-    public boolean hasTag(List<String> keyList, Set<String> values) {
-        for (String key : keyList) {
-            if (values.contains(properties.get(key)))
-                return true;
-        }
-        return false;
+    public boolean hasTag(List<String> keyList, Set<String> values)
+    {
+	for (String key : keyList)
+	    if (values.contains(properties.get(key)))
+		return true;
+	return false;
     }
 
-    public void removeTag(String name) {
-        properties.remove(name);
+    public void removeTag(String name)
+    {
+	properties.remove(name);
     }
 
-    public void clearTags() {
-        properties.clear();
+    public void clearTags()
+    {
+	properties.clear();
     }
 
     @Override
-    public int getType() {
-        return type;
+    public int getType()
+    {
+	return type;
     }
 
     @Override
-    public boolean isType(int type) {
-        return this.type == type;
+    public boolean isType(int type)
+    {
+	return this.type == type;
     }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
index 66535dcf04..3175bb493e 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
@@ -37,7 +37,7 @@
     protected EdgeFilter carInEdges;
     protected boolean turnCosts = true;
     protected EdgeExplorer carOutExplorer;
-    protected EdgeExplorer carAllExplorer;
+    protected EdgeExplorer explorer;
     protected BikeFlagEncoder bikeEncoder;
     protected FootFlagEncoder footEncoder;
 
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/dpn/OsDpnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/dpn/OsDpnReaderTest.java
index 0f649b48b1..c03cb0834e 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/dpn/OsDpnReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/dpn/OsDpnReaderTest.java
@@ -1,5 +1,10 @@
 package com.graphhopper.reader.osgb.dpn;
 
+import static com.graphhopper.util.GHUtility.count;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
 import java.io.File;
 import java.io.IOException;
 
@@ -8,24 +13,128 @@
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.GHUtility;
 
-public class OsDpnReaderTest extends AbstractOsDpnReaderTest {
+public class OsDpnReaderTest extends AbstractOsDpnReaderTest
+{
+
+    @Test
+    public void testReadDpnSampleLayout() throws IOException
+    {
+	final GraphHopperStorage graph = readGraph();
+	GHUtility.printInfo(graph, 0, 30, EdgeFilter.ALL_EDGES);
+	configureExplorer(graph);
+
+	assertEquals(5, graph.getNodes());
+
+	assertEquals(4, count(explorer.setBaseNode(0))); // Central Tower
+	assertEquals(1, count(explorer.setBaseNode(1))); // Cross Road Vertex
+	assertEquals(1, count(explorer.setBaseNode(2))); // Cross Road Vertex
+	assertEquals(1, count(explorer.setBaseNode(3))); // Cross Road Vertex
+	assertEquals(1, count(explorer.setBaseNode(4))); // Cross Road Vertex
+
+	// Assert that this is true
+	EdgeIterator iter = explorer.setBaseNode(0);
+	assertTrue(iter.next());
+	assertEquals(4, iter.getAdjNode());
+	assertTrue(iter.next());
+	assertEquals(3, iter.getAdjNode());
+	assertTrue(iter.next());
+	assertEquals(2, iter.getAdjNode());
+	assertTrue(iter.next());
+	assertEquals(1, iter.getAdjNode());
+	assertFalse(iter.next());
+
+	iter = explorer.setBaseNode(1);
+	assertTrue(iter.next());
+	assertEquals(0, iter.getAdjNode());
+	assertFalse(iter.next());
+
+	iter = explorer.setBaseNode(2);
+	assertTrue(iter.next());
+	assertEquals(0, iter.getAdjNode());
+	assertFalse(iter.next());
+
+	iter = explorer.setBaseNode(3);
+	assertTrue(iter.next());
+	assertEquals(0, iter.getAdjNode());
+	assertFalse(iter.next());
+
+	iter = explorer.setBaseNode(4);
+	assertTrue(iter.next());
+	assertEquals(0, iter.getAdjNode());
+	assertFalse(iter.next());
+    }
+
+    @Test
+    public void testReadDpnSampleName() throws IOException
+    {
+	final GraphHopperStorage graph = readGraph();
+	configureExplorer(graph);
+
+	EdgeIterator iter = explorer.setBaseNode(0);
+	assertTrue(iter.next());
+	assertTrue(iter.next());
+	assertTrue(iter.next());
+	assertTrue(iter.next());
+	assertEquals("Name field available so should be set", "Named Road", iter.getName());
+    }
 
     @Test
-    public void testReadDpnSample() throws IOException {
-        final boolean turnRestrictionsImport = true;
-        final boolean is3D = false;
-        final GraphHopperStorage graph = configureStorage(
-                turnRestrictionsImport, is3D);
-
-        final File file = new File(
-                "./src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml");
-        readGraphFile(graph, file);
-        GHUtility.printInfo(graph, 0, 30, EdgeFilter.ALL_EDGES);
-        carAllExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(
-                carEncoder, true, true));
-        printNodes(carAllExplorer, 30);
+    public void testReadDpnSampleNameWithAlternate() throws IOException
+    {
+	final GraphHopperStorage graph = readGraph();
+	configureExplorer(graph);
+
+	EdgeIterator iter = explorer.setBaseNode(0);
+	assertTrue(iter.next());
+	assertTrue(iter.next());
+	assertTrue(iter.next());
+	assertEquals("Name fields both available so should be set",
+			"Named Road Two (With Alternate)", iter.getName());
+    }
+
+    @Test
+    public void testReadDpnSampleNameDefaultToTrackType() throws IOException
+    {
+	final GraphHopperStorage graph = readGraph();
+	configureExplorer(graph);
+
+	EdgeIterator iter = explorer.setBaseNode(0);
+	assertTrue(iter.next());
+	assertEquals("No Name field available so should report track type", "Alley", iter.getName());
+    }
+
+    @Test
+    public void testReadDpnSampleNameDefaultToTrackFriendlyNameWhenNoPhysicalManifestation()
+		    throws IOException
+    {
+	final GraphHopperStorage graph = readGraph();
+	configureExplorer(graph);
+
+	EdgeIterator iter = explorer.setBaseNode(0);
+	assertTrue(iter.next());
+	assertTrue(iter.next());
+	assertEquals("No Name field available so should be report track type", "Route",
+			iter.getName());
+    }
+
+    private void configureExplorer(final GraphHopperStorage graph)
+    {
+	explorer = graph.createEdgeExplorer(new DefaultEdgeFilter(carEncoder, true, true));
+    }
+
+    private GraphHopperStorage readGraph() throws IOException
+    {
+	final boolean turnRestrictionsImport = false;
+	final boolean is3D = false;
+	final GraphHopperStorage graph = configureStorage(turnRestrictionsImport, is3D);
+
+	final File file = new File(
+			"./src/test/resources/com/graphhopper/reader/osgb/dpn/os-dpn-sample.xml");
+	readGraphFile(graph, file);
+	return graph;
     }
 
 }
