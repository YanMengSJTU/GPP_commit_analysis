diff --git a/.gitignore b/.gitignore
index 524a4e70e3..993fdf3572 100644
--- a/.gitignore
+++ b/.gitignore
@@ -26,4 +26,8 @@ core/docs/
 .*#
 cgiarprovider/
 /nbactions.xml
-tools/nb-configuration.xml/acceptancetesting
+tools/nb-configuration.xml
+/acceptancetesting
+android/build/
+android/app/build/
+android/.gradle
diff --git a/.travis.yml b/.travis.yml
index 01e661078f..41d020a24b 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -8,4 +8,7 @@ install: true
 script: ./core/files/travis-build.sh
 notifications:
   email:
-    - engaric@hotmail.com
\ No newline at end of file
+    - engaric@hotmail.com
+
+# enable container-based stack
+sudo: false
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 49cc8da521..d3264e5372 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -7,6 +7,7 @@
  * dardin88, instructions improved
  * lmar, improved instructions information
  * fredao, translations
+ * jansoe, algorithm improvements
  * jansonhanson, general host config
  * JohannesPelzer, improved GPX information and various other things
  * karussell, lead developer
diff --git a/README.md b/README.md
index 0b78adb55e..1d2bba0701 100644
--- a/README.md
+++ b/README.md
@@ -3,27 +3,42 @@
 [![Build Status](https://secure.travis-ci.org/graphhopper/graphhopper.png?branch=master)](http://travis-ci.org/graphhopper/graphhopper)
 
 GraphHopper is a fast and memory efficient Java road routing engine released under Apache License 2.0.
-It is tuned towards road networks with OpenStreetMap data but can be useful for public transport problems as well.
+Per default it uses OpenStreetMap data but can import other data sources.
 
-Try it
+GraphHopper for the Web
 --------------
 
-See GraphHopper in action via [GraphHopper Maps](http://graphhopper.com/maps)!
+See GraphHopper in action on [GraphHopper Maps](https://graphhopper.com/maps)
 
+[![GraphHopper Maps](https://karussell.files.wordpress.com/2014/12/graphhopper-maps-0-4-preview.png)](https://graphhopper.com/maps)
 
-Get Started & Contribute
+GraphHopper Maps uses the [Directions API for Business](https://graphhopper.com/#directions-api), which provides 
+routing and matrix routing through GraphHopper and also a fast address search via [Photon](https://github.com/komoot/photon).
+Additionally the map tiles from various Providers like [Lyrk](https://geodienste.lyrk.de/pakete)
+are used and all is available for free and through HTTPS for a secure route planning experience!
+
+
+GraphHopper for Mobile
+---------------
+
+There are subprojects to make GraphHopper working offline
+on [Android](https://github.com/graphhopper/graphhopper/tree/master/android)
+and [iOS](http://github.com/graphhopper/graphhopper-ios)
+
+
+Get Started
 ---------------
 
-Read through our [docs](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), 
-[how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md) and 
+Read through our Documentation ([0.3](https://github.com/graphhopper/graphhopper/blob/0.3/docs/index.md), [unstable](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md)), 
 ask questions on [Stackoverflow](http://stackoverflow.com/questions/tagged/graphhopper)
-or sign up to the [mailing list](http://graphhopper.com/#developers).
+and sign up to the [mailing list](http://graphhopper.com/#developers).
 
-**Please only email me directly if you need consultancy** or can't explain your problem in the public.
 
-There are subprojects to make GraphHopper working on [Android](https://github.com/graphhopper/graphhopper/blob/master/docs/android/index.md), 
-[iOS](http://github.com/graphhopper/graphhopper-ios) or 
-as a [web application](https://github.com/graphhopper/graphhopper/tree/master/web).
+Contribute
+---------------
+
+Read through [how to contribute](https://github.com/graphhopper/graphhopper/blob/master/CONTRIBUTING.md)
+like finding and fixing bugs and improving our documentation or translations!
 
 
 Features
@@ -33,6 +48,6 @@ Features
  * Open Source
  * Memory efficient and fast
  * Highly customizable
- * Works on the desktop, as a web service and offline on Android
- * Well tested
- * [... more](http://graphhopper.com/#overview)
\ No newline at end of file
+ * Works on the desktop, as a web service and offline on Android or iOS
+ * Large test suite
+ * [... more](http://graphhopper.com/#overview)
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/beans/RouteWayPoint.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/beans/RouteWayPoint.java
index 5abc347d8b..ccf7aedacf 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/beans/RouteWayPoint.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/gpx/beans/RouteWayPoint.java
@@ -25,73 +25,76 @@ public boolean equals(RouteWayPoint routeWayPoint) {
 		boolean isEqual = false;
 		Field[] fields = waypoint.getClass().getDeclaredFields();
 		for (Field f : fields) {
-			
-	
-			if(!f.getName().equalsIgnoreCase("time"))
-			{
-				
-			
-			
-			try {
-				String first = f.getName().substring(0, 1);
-				String getter = "get" + f.getName().replaceFirst(first, first.toUpperCase());
-				Method m = waypoint.getClass().getMethod(getter,new Class[] {});
-				
-
-				
-				Object thisValue = m.invoke(waypoint);
-				Object thatValue = m.invoke(routeWayPoint.waypoint);
-				
-				if (f.getName()=="description")
-				{
-					// description string comparison ignoring case and special char "'"
-					
-					
-					String thisValueAsString = ((String) thisValue).replaceAll("[^\\w]", "");
-					String thatValueAsString=((String)thatValue).replaceAll("[^\\w]", "");
-					isEqual = thisValueAsString.equalsIgnoreCase(( thatValueAsString));
-					
-				}
-				if (thisValue instanceof String) {
 
-					
-				} else {
-					isEqual = Objects.equals(thisValue, thatValue);
-				}
-			
-				if (!isEqual) {
-					break;
+			if (!f.getName().equalsIgnoreCase("time")) {
+
+				try {
+					String first = f.getName().substring(0, 1);
+					String getter = "get"
+							+ f.getName().replaceFirst(first,
+									first.toUpperCase());
+					Method m = waypoint.getClass().getMethod(getter,
+							new Class[] {});
+
+					Object thisValue = m.invoke(waypoint);
+					Object thatValue = m.invoke(routeWayPoint.waypoint);
+
+					if (f.getName() == "description") {
+						// description string comparison ignoring case and
+						// special char "'"
+
+						try {
+							String thisValueAsString = ((String) thisValue)
+									.replaceAll("[^\\w]", "");
+							String thatValueAsString = ((String) thatValue)
+									.replaceAll("[^\\w]", "");
+							isEqual = thisValueAsString
+									.equalsIgnoreCase((thatValueAsString));
+						}
+
+						catch (Exception e) {
+							e.printStackTrace();
+						}
+					}
+					if (thisValue instanceof String) {
+
+					} else {
+						isEqual = Objects.equals(thisValue, thatValue);
+					}
+
+					if (!isEqual) {
+						break;
+					}
+				} catch (NoSuchMethodException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+				} catch (InvocationTargetException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+				} catch (IllegalAccessException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
+				} catch (IllegalArgumentException e) {
+					// TODO Auto-generated catch block
+					e.printStackTrace();
 				}
-			} catch (NoSuchMethodException e) {
-				// TODO Auto-generated catch block
-				e.printStackTrace();
-			} catch (InvocationTargetException e) {
-				// TODO Auto-generated catch block
-				e.printStackTrace();
-			} catch (IllegalAccessException e) {
-				// TODO Auto-generated catch block
-				e.printStackTrace();
-			} catch (IllegalArgumentException e) {
-				// TODO Auto-generated catch block
-				e.printStackTrace();
 			}
 		}
-		}
 		if (isEqual) {
 			System.out.println(routeWayPoint.waypoint.getExtensionData());
-			if (null!=routeWayPoint.waypoint.getExtensionData())
-			{for (String anExtensionDataKey : waypoint.getExtensionData()
-					.keySet()) {
-				isEqual = Objects.equals(waypoint
-						.getExtensionData(anExtensionDataKey),
-						routeWayPoint.waypoint
-								.getExtensionData(anExtensionDataKey));
-				if (!isEqual) {
-					break;
+			if (null != routeWayPoint.waypoint.getExtensionData()) {
+				for (String anExtensionDataKey : waypoint.getExtensionData()
+						.keySet()) {
+					isEqual = Objects.equals(waypoint
+							.getExtensionData(anExtensionDataKey),
+							routeWayPoint.waypoint
+									.getExtensionData(anExtensionDataKey));
+					if (!isEqual) {
+						break;
+					}
 				}
 			}
 		}
-		}
 
 		return isEqual;
 	}
diff --git a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperServiceUtil.java b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperServiceUtil.java
index 97e8dab003..0f87a78a1f 100644
--- a/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperServiceUtil.java
+++ b/acceptancetesting/src/main/java/uk/co/ordnancesurvey/routing/GraphHopperServiceUtil.java
@@ -1,5 +1,6 @@
-	package uk.co.ordnancesurvey.routing;
-	import static org.junit.Assert.assertTrue;
+package uk.co.ordnancesurvey.routing;
+
+import static org.junit.Assert.assertTrue;
 
 import java.util.HashSet;
 
@@ -12,71 +13,26 @@
 import uk.co.ordnancesurvey.gpx.graphhopper.GraphHopperGPXParserRouteTest;
 
 public class GraphHopperServiceUtil {
-	
-			private static final Logger LOG = LoggerFactory
-				.getLogger(GraphHopperServiceUtil.class);
-		
 
-		
-		public void testrouteContainsTurn(String turn) {
-			String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
-			GraphHopperGPXParserRouteTest ghrt = GraphHopperGPXParserRouteTest.getParserForgpxFileName(path);
-			HashSet<Route> hs = ghrt.getRoutes();
-			if( null==turn)
-			{turn = "turn sharp right onto Bellemoor Road";}
-			
-			assertTrue(ghrt.routeContainsTurn(turn, hs.iterator().next()));
-		}
+	private static final Logger LOG = LoggerFactory
+			.getLogger(GraphHopperServiceUtil.class);
 
-		
-		public void testWayPointIsOnRoute() {
-			
-			String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
-			GraphHopperGPXParserRouteTest ghrt = GraphHopperGPXParserRouteTest.getParserForgpxFileName(path);
-			//Waypoint wayPoint = getTestWayPoint();
-			HashSet<Route> hs = ghrt.getRoutes();
-			
-			
-			//assertTrue(ghrt.isWayPointOnRoute(wayPoint,hs.iterator().next()));
-		}
-		
+	public GraphHopperGPXParserRouteTest testGetRouteAsGPX() {
+		LOG.info("Starting To Test");
+		GraphHopperGPXParserRouteTest ghrt = new GraphHopperGPXParserRouteTest();
+		String gpxString = ghrt
+				.parseRoute(
+						"50.93602556772844,-1.4194250106811523,50.92544987854478,-1.389212608337402",
+						"gpx", "car");
 
-		public void testTotalRouteTime() {
-			String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
-			GraphHopperGPXParserRouteTest ghrt = GraphHopperGPXParserRouteTest.getParserForgpxFileName(path);
-			ghrt.getTotalRouteTime();
-			assertTrue(true);
-		}
-		
-		
-		public GraphHopperGPXParserRouteTest testGetRouteAsGPX() {
-			LOG.info("Starting To Test");
-			GraphHopperGPXParserRouteTest ghrt = new GraphHopperGPXParserRouteTest();
-			String gpxString = ghrt.parseRoute("50.93602556772844,-1.4194250106811523,50.92544987854478,-1.389212608337402", "gpx", "car");
-			
-			LOG.info(gpxString);
-			HashSet<Route> hs = ghrt.getRoutes();
-			
-			assertTrue(ghrt.routeContainsTurn("turn sharp right onto ROCKLEIGH ROAD",hs.iterator().next()));
-			return ghrt;
-		}
-
-		private Waypoint getTestWayPoint(String longitude,String latitude) {
-			
-			Waypoint wp = new Waypoint();
-			wp.setLatitude(new Double(50.927146));
-			wp.setLongitude(new Double(-1.416787));
-			wp.addExtensionData(ExtensionConstants.AZIMUTH, "339");
-			wp.addExtensionData(ExtensionConstants.DIRECTION, "N");
-			wp.addExtensionData(ExtensionConstants.TIME, "2515");
-			wp.addExtensionData(ExtensionConstants.DISTANCE, "13.974");
-			
-			return wp;
-		}
-		
-		
+		LOG.info(gpxString);
+		HashSet<Route> hs = ghrt.getRoutes();
 
+		assertTrue(ghrt.routeContainsTurn(
+				"turn sharp right onto ROCKLEIGH ROAD", hs.iterator().next()));
+		return ghrt;
 	}
+	
+	
 
-
-
+}
diff --git a/acceptancetesting/src/test/java/GPHRouteTest.java b/acceptancetesting/src/test/java/GPHRouteTest.java
index 47a76db22f..f305acb0b1 100644
--- a/acceptancetesting/src/test/java/GPHRouteTest.java
+++ b/acceptancetesting/src/test/java/GPHRouteTest.java
@@ -41,13 +41,17 @@ public void testrouteContainsTurn() {
 		
 		assertTrue(ghrt.routeContainsTurn(turn, hs.iterator().next()));
 	}
-
+	
+	
 	@Test
 	public void testWayPointIsOnRoute() {
-		
+
+				
 		String path = getClass().getResource("sampleGraphHopper.gpx").getPath();
 		GraphHopperGPXParserRouteTest ghrt = GraphHopperGPXParserRouteTest.getParserForgpxFileName(path);
-		Waypoint wayPoint = getTestWayPoint();
+		Waypoint wayPoint = getTestWayPoint("50.927146","-1.416787","339","N","2515","13.974");
+		
+
 		HashSet<Route> hs = ghrt.getRoutes();
 		
 		assertTrue(ghrt.isWayPointOnRoute(wayPoint,hs.iterator().next()));
@@ -70,16 +74,20 @@ public void testGetRouteAsGPX() {
 		assertTrue(ghrt.routeContainsTurn("turn sharp right onto Bellemoor Road",next));
 	}
 
-	private Waypoint getTestWayPoint() {
+	private Waypoint getTestWayPoint(String lat, String lon,String azimuth,String direction,String time,String distance) {
 		
 		Waypoint wp = new Waypoint();
-		wp.setLatitude(new Double(50.927146));
-		wp.setLongitude(new Double(-1.416787));
-		wp.addExtensionData(ExtensionConstants.AZIMUTH, "339");
-		wp.addExtensionData(ExtensionConstants.DIRECTION, "N");
-		wp.addExtensionData(ExtensionConstants.TIME, "2515");
-		wp.addExtensionData(ExtensionConstants.DISTANCE, "13.974");
-		
-		return wp;
+		wp.setLatitude(new Double(lat));
+		wp.setLongitude(new Double(lon));
+		wp.addExtensionData(ExtensionConstants.AZIMUTH, azimuth);
+		wp.addExtensionData(ExtensionConstants.DIRECTION, direction);
+		wp.addExtensionData(ExtensionConstants.TIME, time);
+		wp.addExtensionData(ExtensionConstants.DISTANCE, distance);
+return wp;
 	}
+	
+	
+
+	
+
 }
diff --git a/acceptancetesting/src/test/resources/test.properties b/acceptancetesting/src/test/resources/test.properties
index e8e64e073b..76a12b7057 100644
--- a/acceptancetesting/src/test/resources/test.properties
+++ b/acceptancetesting/src/test/resources/test.properties
@@ -1,7 +1,7 @@
 graphHopperWebUrl=http://os-gh-ite.elasticbeanstalk.com/
 DPNgraphHopperWebUrl=http://dpn-env.elasticbeanstalk.com/
 #webDriverHubUrl=http://ND28350.ordsvy.gov.uk:5555/wd/hub
-webDriverHubUrl=http://ND26185.ordsvy.gov.uk:5555/wd/hub
+webDriverHubUrl=http://ND27983.ordsvy.gov.uk:5555/wd/hub
 #testON=Web,Service  // Default both
 testON=
 traceEnabled=false
diff --git a/android/.classpath b/android/.classpath
deleted file mode 100644
index 497def70c6..0000000000
--- a/android/.classpath
+++ /dev/null
@@ -1,14 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6">
-		<attributes>
-			<attribute name="maven.pomderived" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/android/.settings/org.eclipse.jdt.core.prefs b/android/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index b080d2ddc8..0000000000
--- a/android/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,4 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
-org.eclipse.jdt.core.compiler.compliance=1.6
-org.eclipse.jdt.core.compiler.source=1.6
diff --git a/android/README.md b/android/README.md
index b482c1b545..f896af0373 100644
--- a/android/README.md
+++ b/android/README.md
@@ -1,6 +1,6 @@
-This is a simple Eclipse project which uses graphhoppers routing and mapsforge to display the map.
-
-* Download the apk [here](http://graphhopper.com/#download)
-* More information about setup, maps creation etc is [in the wiki](https://github.com/graphhopper/graphhopper/wiki/Android)
+This maven module can be used for various IDEs like NetBeans or Eclipse to
+make GraphHopper offline routing working on Android. For offline
+maps the mapsforge project is used. For more information see the 
+[android docs](https://github.com/graphhopper/graphhopper/blob/master/docs/android/index.md).
 
 ![simple routing](http://karussell.files.wordpress.com/2012/09/graphhopper-android.png)
diff --git a/android/app/.classpath b/android/app/.classpath
new file mode 100644
index 0000000000..7397c6ef3c
--- /dev/null
+++ b/android/app/.classpath
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" output="target/classes" path="src">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="output" path="target/classes"/>
+</classpath>
diff --git a/android/.project b/android/app/.project
similarity index 50%
rename from android/.project
rename to android/app/.project
index 9f2869b63c..815c1709c8 100644
--- a/android/.project
+++ b/android/app/.project
@@ -1,33 +1,23 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>GraphHopper</name>
+	<name>graphhopper-android</name>
 	<comment></comment>
 	<projects>
 	</projects>
 	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
 		<buildCommand>
 			<name>org.eclipse.jdt.core.javabuilder</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
 		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
+			<name>org.eclipse.m2e.core.maven2Builder</name>
 			<arguments>
 			</arguments>
 		</buildCommand>
 	</buildSpec>
 	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
 		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.m2e.core.maven2Nature</nature>
 	</natures>
 </projectDescription>
diff --git a/android/app/.settings/org.eclipse.core.resources.prefs b/android/app/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000000..7a53139284
--- /dev/null
+++ b/android/app/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,3 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
+encoding/src=UTF-8
diff --git a/android/app/.settings/org.eclipse.jdt.core.prefs b/android/app/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000000..abec6ca389
--- /dev/null
+++ b/android/app/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,5 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.source=1.5
diff --git a/android/app/.settings/org.eclipse.m2e.core.prefs b/android/app/.settings/org.eclipse.m2e.core.prefs
new file mode 100644
index 0000000000..f897a7f1cb
--- /dev/null
+++ b/android/app/.settings/org.eclipse.m2e.core.prefs
@@ -0,0 +1,4 @@
+activeProfiles=
+eclipse.preferences.version=1
+resolveWorkspaceProjects=true
+version=1
diff --git a/android/app/build.gradle b/android/app/build.gradle
new file mode 100644
index 0000000000..f22f47f714
--- /dev/null
+++ b/android/app/build.gradle
@@ -0,0 +1,51 @@
+apply plugin: 'com.android.application'
+
+android {
+    compileSdkVersion 19
+    buildToolsVersion "21.1.2"
+
+    defaultConfig {
+        applicationId "com.graphhopper.android"
+        minSdkVersion 8
+        targetSdkVersion 19
+    }
+
+    buildTypes {
+        release {
+            minifyEnabled false
+            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
+        }
+    }
+
+    lintOptions {
+        /* CGIARProvider refers to java.awt
+         * Helper7 refers to java.lang.management
+         * HeightTile refers to javax.imageio and java.awt
+         * OSMElement refers to javax.xml.stream
+         */
+        disable 'InvalidPackage'
+    }
+}
+
+/** only necessary if you need to use latest SNAPSHOT
+configurations.all {
+    // check for updates every build
+    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
+}
+ **/
+
+dependencies {
+    compile(group: 'com.graphhopper', name: 'graphhopper', version: '0.4-SNAPSHOT') {
+       exclude group: 'com.google.protobuf', module: 'protobuf-java'
+       exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
+       exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
+    }
+
+    compile group: 'org.mapsforge', name: 'mapsforge-core', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-android', version: '0.5.0'
+    compile group: 'org.mapsforge', name: 'mapsforge-map-reader', version: '0.5.0'
+
+    compile group: 'org.slf4j', name: 'slf4j-android', version: '1.7.10'
+    compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.10'
+}
diff --git a/android/pom.xml b/android/app/pom.xml
similarity index 95%
rename from android/pom.xml
rename to android/app/pom.xml
index b257acaa32..02da41255b 100644
--- a/android/pom.xml
+++ b/android/app/pom.xml
@@ -18,10 +18,7 @@
         <version>0.4-SNAPSHOT</version>
     </parent>
     <properties>
-        <!--
-        <mapsforge.version>0.3-0.4.0-SNAPSHOT</mapsforge.version>
-        -->
-        <mapsforge.version>0.4.3</mapsforge.version>
+        <mapsforge.version>0.5.0</mapsforge.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -84,13 +81,13 @@
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-android</artifactId>
-            <version>1.7.7</version>
+            <version>1.7.10</version>
         </dependency>
         
         <dependency>
             <groupId>org.slf4j</groupId>
             <artifactId>slf4j-api</artifactId>
-            <version>1.7.7</version>
+            <version>1.7.10</version>
         </dependency>
 
         <!-- Make sure this is above (!) the android dependencies -->
@@ -118,13 +115,12 @@
         -->
         <sourceDirectory>src</sourceDirectory>        
         <finalName>${project.artifactId}</finalName>        
-
+        
         <plugins>     
             <!-- android (apache harmony) is nearly java but not really 1.6 -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.1</version>
                 <configuration>
                     <!-- <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
@@ -136,7 +132,7 @@
                 <!-- See http://code.google.com/p/maven-android-plugin/ -->
                 <groupId>com.jayway.maven.plugins.android.generation2</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>3.8.2</version>
+                <version>4.0.0-rc.2</version>
                 <extensions>true</extensions>
                 <configuration>
                     <sdk>
@@ -145,6 +141,7 @@
                     </sdk>
                     <deleteConflictingFiles>true</deleteConflictingFiles>
                     <undeployBeforeDeploy>true</undeployBeforeDeploy>
+		    
                     <!--
                     bug in maven plugin I think
                     <extractDuplicates>true</extractDuplicates>
diff --git a/android/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
similarity index 100%
rename from android/AndroidManifest.xml
rename to android/app/src/main/AndroidManifest.xml
diff --git a/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
new file mode 100644
index 0000000000..63f874629a
--- /dev/null
+++ b/android/app/src/main/java/com/graphhopper/android/AndroidDownloader.java
@@ -0,0 +1,58 @@
+package com.graphhopper.android;
+
+import com.graphhopper.util.Downloader;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.ProgressListener;
+import com.graphhopper.util.Unzipper;
+
+import org.apache.http.HttpEntity;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.DefaultHttpClient;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+
+public class AndroidDownloader extends Downloader {
+
+    public AndroidDownloader() {
+        super("GraphHopper Android");
+    }
+
+    public void downloadAndUnzip(String url, String toFolder, final ProgressListener progressListener) throws IOException {
+        HttpEntity entity = getEntity(url);
+        InputStream iStream = entity.getContent();
+        final long length = entity.getContentLength();
+
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener() {
+            @Override
+            public void update(long sumBytes) {
+                progressListener.update((int) (100 * sumBytes / length));
+            }
+        });
+    }
+
+    private HttpEntity getEntity(String url) {
+        // there is something broken with HTTPS and Android HttpURLConnection
+        HttpClient httpclient = new DefaultHttpClient();
+        HttpGet httpget = new HttpGet(url);
+        try {
+            HttpResponse response = httpclient.execute(httpget);
+            HttpEntity entity = response.getEntity();
+            if (entity == null)
+                throw new RuntimeException("no entity for URL " + url);
+
+            return entity;
+
+        } catch (Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    @Override
+    public String downloadAsString(String url) throws IOException {
+        return Helper.isToString(getEntity(url).getContent());
+    }
+}
diff --git a/android/src/com/graphhopper/android/AndroidHelper.java b/android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
similarity index 100%
rename from android/src/com/graphhopper/android/AndroidHelper.java
rename to android/app/src/main/java/com/graphhopper/android/AndroidHelper.java
diff --git a/android/src/com/graphhopper/android/GHAsyncTask.java b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
similarity index 99%
rename from android/src/com/graphhopper/android/GHAsyncTask.java
rename to android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
index e1b0276a94..62923ec579 100644
--- a/android/src/com/graphhopper/android/GHAsyncTask.java
+++ b/android/app/src/main/java/com/graphhopper/android/GHAsyncTask.java
@@ -20,8 +20,6 @@ protected C doInBackground( A... params )
         }
     }
 
-    ;
-
 	public boolean hasError()
     {
         return error != null;
diff --git a/android/src/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
similarity index 96%
rename from android/src/com/graphhopper/android/MainActivity.java
rename to android/app/src/main/java/com/graphhopper/android/MainActivity.java
index ea66e6fa82..0853a4bc74 100644
--- a/android/src/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -50,8 +50,8 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.util.Constants;
-import com.graphhopper.util.Downloader;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.ProgressListener;
@@ -188,7 +188,7 @@ boolean isReady()
             logUser("Preparation still in progress");
             return false;
         }
-        log("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
+        logUser("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
         return false;
     }
 
@@ -238,8 +238,7 @@ private void chooseAreaFromRemote()
             protected List<String> saveDoInBackground( Void... params )
                     throws Exception
             {
-                String[] lines = new Downloader("GraphHopper Android").
-                        downloadAsString(fileListURL).split("\n");
+                String[] lines = new AndroidDownloader().downloadAsString(fileListURL).split("\n");
                 List<String> res = new ArrayList<String>();
                 for (String str : lines)
                 {
@@ -260,8 +259,13 @@ private void chooseAreaFromRemote()
             @Override
             protected void onPostExecute( List<String> nameList )
             {
-                if (hasError() || nameList.isEmpty())
+                if(nameList.isEmpty())
                 {
+                    logUser("No maps created for your version!? " + fileListURL);
+                    return;
+                } else if (hasError())
+                {
+                    getError().printStackTrace();
                     logUser("Are you connected to the internet? Problem while fetching remote area list: "
                             + getErrorMessage());
                     return;
@@ -272,10 +276,8 @@ protected void onPostExecute( List<String> nameList )
                     public void onSelect( String selectedArea, String selectedFile )
                     {
                         if (selectedFile == null
-                                || new File(mapsFolder, selectedArea + ".ghz")
-                                .exists()
-                                || new File(mapsFolder, selectedArea + "-gh")
-                                .exists())
+                                || new File(mapsFolder, selectedArea + ".ghz").exists()
+                                || new File(mapsFolder, selectedArea + "-gh").exists())
                         {
                             downloadURL = null;
                         } else
@@ -356,7 +358,7 @@ protected Object saveDoInBackground( Void... _ignore )
                 String localFolder = Helper.pruneFileEnd(AndroidHelper.getFileName(downloadURL));
                 localFolder = new File(mapsFolder, localFolder + "-gh").getAbsolutePath();
                 log("downloading & unzipping " + downloadURL + " to " + localFolder);
-                Downloader downloader = new Downloader("GraphHopper Android");
+                AndroidDownloader downloader = new AndroidDownloader();
                 downloader.setTimeout(30000);
                 downloader.downloadAndUnzip(downloadURL, localFolder,
                         new ProgressListener()
@@ -400,6 +402,7 @@ void loadMap( File areaFolder )
         mapView.getLayerManager().getLayers().clear();
 
         TileRendererLayer tileRendererLayer = new TileRendererLayer(tileCache, mapView.getModel().mapViewPosition,
+                false,
                 true, AndroidGraphicFactory.INSTANCE)
                 {
                     @Override
@@ -498,7 +501,7 @@ protected GHResponse doInBackground( Void... v )
             {
                 StopWatch sw = new StopWatch().start();
                 GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
-                        setAlgorithm("dijkstrabi");
+                        setAlgorithm(AlgorithmOptions.DIJKSTRA_BI);
                 req.getHints().
                         put("instructions", "false");
                 GHResponse resp = hopper.route(req);
@@ -540,6 +543,7 @@ private void log( String str, Throwable t )
 
     private void logUser( String str )
     {
+        log(str);
         Toast.makeText(this, str, Toast.LENGTH_LONG).show();
     }
     private static final int NEW_MENU_ID = Menu.FIRST + 1;
diff --git a/android/res/drawable/flag_green.png b/android/app/src/main/res/drawable/flag_green.png
similarity index 100%
rename from android/res/drawable/flag_green.png
rename to android/app/src/main/res/drawable/flag_green.png
diff --git a/android/res/drawable/flag_red.png b/android/app/src/main/res/drawable/flag_red.png
similarity index 100%
rename from android/res/drawable/flag_red.png
rename to android/app/src/main/res/drawable/flag_red.png
diff --git a/android/res/drawable/logo.png b/android/app/src/main/res/drawable/logo.png
similarity index 100%
rename from android/res/drawable/logo.png
rename to android/app/src/main/res/drawable/logo.png
diff --git a/android/res/layout/main.xml b/android/app/src/main/res/layout/main.xml
similarity index 100%
rename from android/res/layout/main.xml
rename to android/app/src/main/res/layout/main.xml
diff --git a/android/res/values-large/dimens.xml b/android/app/src/main/res/values-large/dimens.xml
similarity index 100%
rename from android/res/values-large/dimens.xml
rename to android/app/src/main/res/values-large/dimens.xml
diff --git a/android/res/values/dimens.xml b/android/app/src/main/res/values/dimens.xml
similarity index 100%
rename from android/res/values/dimens.xml
rename to android/app/src/main/res/values/dimens.xml
diff --git a/android/res/values/strings.xml b/android/app/src/main/res/values/strings.xml
similarity index 100%
rename from android/res/values/strings.xml
rename to android/app/src/main/res/values/strings.xml
diff --git a/android/res/values/styles.xml b/android/app/src/main/res/values/styles.xml
similarity index 100%
rename from android/res/values/styles.xml
rename to android/app/src/main/res/values/styles.xml
diff --git a/android/build.gradle b/android/build.gradle
new file mode 100644
index 0000000000..fd24035602
--- /dev/null
+++ b/android/build.gradle
@@ -0,0 +1,19 @@
+// Top-level build file where you can add configuration options common to all sub-projects/modules.
+buildscript {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        /*jcenter()*/
+    }
+    dependencies {
+        classpath 'com.android.tools.build:gradle:1.0.0'
+    }
+}
+
+allprojects {
+    repositories {
+        mavenLocal()
+        mavenCentral()
+        /*jcenter()*/
+    }
+}
diff --git a/android/gradle/wrapper/gradle-wrapper.jar b/android/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 0000000000..8c0fb64a86
Binary files /dev/null and b/android/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 0000000000..0c71e760dc
--- /dev/null
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
diff --git a/android/gradlew b/android/gradlew
new file mode 100755
index 0000000000..91a7e269e1
--- /dev/null
+++ b/android/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/android/gradlew.bat b/android/gradlew.bat
new file mode 100644
index 0000000000..8a0b282aa6
--- /dev/null
+++ b/android/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/android/libs/mapsforge-core-0.4.3.jar b/android/libs/mapsforge-core-0.4.3.jar
deleted file mode 100644
index 82d62ee4f7..0000000000
Binary files a/android/libs/mapsforge-core-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-0.4.3.jar b/android/libs/mapsforge-map-0.4.3.jar
deleted file mode 100644
index eba6643ef4..0000000000
Binary files a/android/libs/mapsforge-map-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-android-0.4.3.jar b/android/libs/mapsforge-map-android-0.4.3.jar
deleted file mode 100644
index 0a6789d6c8..0000000000
Binary files a/android/libs/mapsforge-map-android-0.4.3.jar and /dev/null differ
diff --git a/android/libs/mapsforge-map-reader-0.4.3.jar b/android/libs/mapsforge-map-reader-0.4.3.jar
deleted file mode 100644
index 214bb5c8f3..0000000000
Binary files a/android/libs/mapsforge-map-reader-0.4.3.jar and /dev/null differ
diff --git a/android/libs/slf4j-android-1.6.1-RC1.jar b/android/libs/slf4j-android-1.6.1-RC1.jar
deleted file mode 100644
index 9bb01355a4..0000000000
Binary files a/android/libs/slf4j-android-1.6.1-RC1.jar and /dev/null differ
diff --git a/android/local.properties b/android/local.properties
new file mode 100644
index 0000000000..efc8662bc7
--- /dev/null
+++ b/android/local.properties
@@ -0,0 +1,7 @@
+## This file must *NOT* be checked into Version Control Systems,
+# as it contains information specific to your local configuration.
+#
+# Location of the SDK. This is only used by Gradle.
+#
+#Mon Jan 19 09:31:41 CET 2015
+sdk.dir=/home/peterk/Programme/adt-bundle-linux-x86/sdk
diff --git a/android/proguard-project.txt b/android/proguard-project.txt
deleted file mode 100644
index f2fe1559a2..0000000000
--- a/android/proguard-project.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-# To enable ProGuard in your project, edit project.properties
-# to define the proguard.config property as described in that file.
-#
-# Add project specific ProGuard rules here.
-# By default, the flags in this file are appended to flags specified
-# in ${sdk.dir}/tools/proguard/proguard-android.txt
-# You can edit the include path and order by changing the ProGuard
-# include property in project.properties.
-#
-# For more details, see
-#   http://developer.android.com/guide/developing/tools/proguard.html
-
-# Add any project specific keep options here:
-
-# If your project uses WebView with JS, uncomment the following
-# and specify the fully qualified class name to the JavaScript interface
-# class:
-#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
-#   public *;
-#}
diff --git a/android/project.properties b/android/project.properties
deleted file mode 100644
index 4ab125693c..0000000000
--- a/android/project.properties
+++ /dev/null
@@ -1,14 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system edit
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-#
-# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
-#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
-
-# Project target.
-target=android-19
diff --git a/android/settings.gradle b/android/settings.gradle
new file mode 100644
index 0000000000..e7b4def49c
--- /dev/null
+++ b/android/settings.gradle
@@ -0,0 +1 @@
+include ':app'
diff --git a/config-example.properties b/config-example.properties
index 2bee25fb1f..7890d07015 100644
--- a/config-example.properties
+++ b/config-example.properties
@@ -1,40 +1,52 @@
-#################
-### OSMReader ###
-
-graph.dataaccess=RAM_STORE
-# graph.dataaccess=MMAP_STORE_SYNC
-
-# Default: use contraction hierarchies to speed things up. requires more RAM/disc space for holding the graph
-# Use chWeighting=no to disable it (more flexibility while querying) 
-# Java API usage is: GraphHopper.setCHWeighting("fastest")
-prepare.chWeighting=fastest
-
-# increase from 1 to 5, to reduce way geometry e.g. for android
-osmreader.wayPointMaxDistance=1
-
+##### Vehicles #####
+#
 # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
-# When using two or three option together remeber to set "prepare.chWeighting=no" above.
 # bike2 takes elevation data into account (like up-hill is slower than down-hill)
-# and requires enabling graph.elevation.provider below, e.g. see #169
+# and requires enabling graph.elevation.provider below
 graph.flagEncoders=car
 
-# to enable turn restrictions for car do
-#graph.flagEncoders=car|turnCosts=true
+# Enable turn restrictions for car or motorcycle. 
+# Currently you need to additionally set prepare.chWeighting=no before using this (see below and #270)
+# graph.flagEncoders=car|turnCosts=true
 
-# if you want to reduce storage size and you don't need instructions for a path uncomment this
-# osmreader.instructions=false
 
+##### Elevation #####
+#
 # To populate your graph with elevation data use SRTM, default is noop
 # graph.elevation.provider=srtm
-# default location for cache is used /tmp/srtm
+#
+# default location for cache is /tmp/srtm
 # graph.elevation.cachedir=./srtmprovider/
-# If you have a slow disk or plenty of RAM change the default MMAP to
+#
+# If you have a slow disk or plenty of RAM change the default MMAP to:
 # graph.elevation.dataaccess=RAM_STORE
 
-# Location index lookup. Advanced customization. Resolution is in meter, the search specifies the 'radius' in number of tiles.
-# E.g. decrease resolution for a faster lookup and increase region search for a more dynamic search and less 'location not found' results
-# index.highResolution=300
-# index.maxRegionSearch=4
 
-# if you want to support jsonp response type you need to add it explicitely here:
-#web.jsonpAllowed=true
+
+##### Storage #####
+#
+# configure the memory access, use RAM_STORE for well equipped servers, 
+# MMAP_STORE_SYNC could be used otherwise but will be a lot slower
+graph.dataaccess=RAM_STORE
+
+# if you want to reduce storage size and you don't need instructions for the resulting path use:
+# osmreader.instructions=false
+
+#### Speed-up Mode vs. Flexibility Mode ####
+#
+# By default the speed-up mode with the 'fastest' weighting is used. Internally contraction hierarchies is 
+# used to speed routing up. This requires more RAM/disc space for holding the graph but less for every request.
+# prepare.chWeighting=fastest
+#
+# Disable the speed-up mode (contraction hierarchies, CH) via enabling the flexibility mode:
+# prepare.chWeighting=no
+
+
+# If multiple vehicles are used and prepare.chWeighting=fastest only one vehicle can be in speed-up
+# When nothing is specified the (lexicographically) first vehicle from the graph.flagEncoders list is chosen
+# algorithm.defaultVehicle=car
+
+##### Web #####
+# if you want to support jsonp response type you need to add it explicitely here. By default it is disabled for 
+# stronger security.
+# web.jsonpAllowed=true
diff --git a/core/.classpath b/core/.classpath
index e43402fa4f..add55f2e73 100644
--- a/core/.classpath
+++ b/core/.classpath
@@ -30,6 +30,7 @@
 	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
 		<attributes>
 			<attribute name="maven.pomderived" value="true"/>
+			<attribute name="org.eclipse.jst.component.nondependency" value=""/>
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="output" path="target/classes"/>
diff --git a/core/.project b/core/.project
index 3089b8c783..5d6f2b7d22 100644
--- a/core/.project
+++ b/core/.project
@@ -6,6 +6,11 @@
 	<projects>
 	</projects>
 	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.wst.common.project.facet.core.builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 		<buildCommand>
 			<name>org.eclipse.jdt.core.javabuilder</name>
 			<arguments>
@@ -16,9 +21,17 @@
 			<arguments>
 			</arguments>
 		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.wst.validation.validationbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 	</buildSpec>
 	<natures>
+		<nature>org.eclipse.jem.workbench.JavaEMFNature</nature>
+		<nature>org.eclipse.wst.common.modulecore.ModuleCoreNature</nature>
 		<nature>org.eclipse.m2e.core.maven2Nature</nature>
 		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.wst.common.project.facet.core.nature</nature>
 	</natures>
 </projectDescription>
diff --git a/core/.settings/org.eclipse.wst.common.component b/core/.settings/org.eclipse.wst.common.component
new file mode 100644
index 0000000000..d905cf963b
--- /dev/null
+++ b/core/.settings/org.eclipse.wst.common.component
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?><project-modules id="moduleCoreId" project-version="1.5.0">
+    <wb-module deploy-name="graphhopper">
+        <wb-resource deploy-path="/" source-path="/src/main/java"/>
+        <wb-resource deploy-path="/" source-path="/src/main/resources"/>
+    </wb-module>
+</project-modules>
diff --git a/core/.settings/org.eclipse.wst.common.project.facet.core.xml b/core/.settings/org.eclipse.wst.common.project.facet.core.xml
new file mode 100644
index 0000000000..1b22d705a5
--- /dev/null
+++ b/core/.settings/org.eclipse.wst.common.project.facet.core.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<faceted-project>
+  <installed facet="java" version="1.7"/>
+  <installed facet="jst.utility" version="1.0"/>
+</faceted-project>
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index cea8a4eb06..e5f083fce5 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,4 +1,23 @@
 0.4.0
+    translation key turn changed and merged with left etc into turn_left, turn_right etc
+    create location index before preparation in the GraphHopper class
+    encodingManager.getSingle() is removed as one can specify an encoder explicitly. GraphHopper picks the first encoder automatically for default vehicle, can be overwritten via setDefaultVehicle
+    removed LocationIndexTreeSC, use new LocationIndexTree(levelGraph.getBaseGraph(), directory) instead
+    getLevel and setLevel do no longer automatically increase node count, use getNodeAccess.ensureNode for that
+    normal algorithms are now possible on prepared graph use getBaseGraph, see #116
+    GHResponse no longer has isFound method, use !hasErrors instead
+    merged unused Edge class into EdgeEntry
+    astar and astarbi are now both none-heuristic and take parameters for beeline approximation: astar.approximation=BeelineSimplification|BeelineAccurate or astarbi.approximation=...
+    making GPX export according to the schema to support import from various tools like basecamp
+    refactoring: AllEdgesIterator.getMaxId is now named getCount
+    major change of internal API: moved method "Path RoutingAlgorithm.calcPath(QueryResult,QueryResult)" to a helper method QueryGraph.lookup, call queryResult.getClosestNode for the calcPath(nodeFrom,nodeTo) method
+    no cachedWays and cachedPoints in Path anymore
+    Path.findInstruction was moved to InstructionList.find
+    if start and end point are identical an algorithm will find the path consisting only of one node, one point and one instruction (finish instruction), but without edges
+    astarbi has new default values for approximation (false) and approximation_factor (1.2) in RoutingAlgorithmFactorySimple
+    instead of strings use the variables in AlgorithmOptions to specify an algorithm
+    use RoutingAlgorithmFactorySimple instead of RoutingAlgorithmFactory, also more constistent algorithm preparation handling due to new AlgorithmOptions, therefor removed NoOpAlgorithmPreparation
+    GHResponse.getXX methods now fail fast (throw an exception) if an error while route calculation occured. See #287
     renamed less often used URL parameter 'min_path_precision' to way_point_max_distance which makes it identical to the setWayPointMaxDistance method used for simplification at OSMImport
     removed douglas.minprecision from Java API ghRequest.hints => use wayPointMaxDistance instead
     encoder.supportTurnCost is replaced by encoder.supports(TurnWeighting.class)
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index da0517fa84..4bea556c07 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP bg ca de_DE el es fil fr gl he it ja nl pt_PT pt_BR ro ru sk si sv_SE tr uk"
+translations="en_US SKIP bg ca de_DE el es fil fi fr gl he it ja ne nl pt_BR pt_PT ro ru si sk sv_SE tr uk vi_VI zh_CN"
 file=$1
 
 # You can execute the following
diff --git a/core/itngen.sh b/core/itngen.sh
index 26922974fb..a41c3392fe 100755
--- a/core/itngen.sh
+++ b/core/itngen.sh
@@ -1,20 +1,30 @@
+STARTTIME=$(date +%s)
+
 LOGIT=
 #LOGIT=:${HOME}/.m2/repository/org/slf4j/slf4j-log4j12/1.7.7/slf4j-log4j12-1.7.7.jar:${HOME}/.m2/repository/log4j/log4j/1.2.17/log4j-1.2.17.jar
 
 # Actual ITN Data
 #ITNDATA=${HOME}/Development/OSMMITN/data
-#GRAPHOUTPUTDIR=${HOME}/Documents/graphhopper/core/itn-gh
+GRAPHOUTPUTDIR=${HOME}/Documents/graphhopper/core/itn-gh
 
 # Sample Data
 #ITNDATA=${HOME}/Development/geoserver-service-test/geoservertest/itn-sample-data/58096-SX9192-2c1.gz
 #GRAPHOUTPUTDIR=${HOME}/Documents/graphhopper/core/58096-SX9192-2c1-gh
 
+# Modified Sample Data
+ITNDATA=/media/sf_/media/shared/modified-exeter/58096-SX9192-modified.xml
+#GRAPHOUTPUTDIR=${HOME}/Documents/graphhopper/core/58096-SX9192-modified-gh
+
 #ITNDATA=${HOME}/Development/graphhopper2/graphhopper/tools/os-itn-m27-m3-north.xml
 #GRAPHOUTPUTDIR=${HOME}/Documents/graphhopper/core/os-itn-m27-m3-north-gh
 
-ITNDATA=${HOME}/Development/graphhopper2/graphhopper/core/os-itn-carlisle-warwick-road.xml
-GRAPHOUTPUTDIR=${HOME}/Documents/graphhopper/core/os-itn-carlisle-warwick-road-gh
+#ITNDATA=${HOME}/Development/graphhopper2/graphhopper/core/os-itn-carlisle-warwick-road.xml
+#GRAPHOUTPUTDIR=${HOME}/Documents/graphhopper/core/os-itn-carlisle-warwick-road-gh
 
-java -Xmx4596m -Xms2048m -XX:+UseParallelGC -XX:+UseParallelOldGC -cp ../tools/target/classes:target/classes:${HOME}/.m2/repository/net/java/dev/jsr-275/jsr-275/1.0-beta-2/jsr-275-1.0-beta-2.jar:${HOME}/.m2/repository/java3d/vecmath/1.3.2/vecmath-1.3.2.jar:${HOME}/.m2/repository/org/geotools/gt-opengis/12.1/gt-opengis-12.1.jar:${HOME}/.m2/repository/org/geotools/gt-epsg-hsql/12.1/gt-epsg-hsql-12.1.jar:${HOME}/.m2/repository/org/hsqldb/hsqldb/2.3.2/hsqldb-2.3.2.jar:${HOME}/.m2/repository/javax/media/jai_core/1.1.3/jai_core-1.1.3.jar:${HOME}/.m2/repository/org/geotools/gt-referencing/12.1/gt-referencing-12.1.jar:${HOME}/.m2/repository/org/geotools/gt-metadata/12.1/gt-metadata-12.1.jar:${HOME}/.m2/repository/org/slf4j/slf4j-api/1.7.7/slf4j-api-1.7.7.jar:${HOME}/.m2/repository/net/sf/trove4j/trove4j/3.0.3/trove4j-3.0.3.jar${LOGIT} com.graphhopper.tools.Import osmreader.osm=${ITNDATA} reader.implementation=OSITN graph.location=${GRAPHOUTPUTDIR} config=../config.properties
+#ITNDATA=${HOME}/Development/graphhopper2/graphhopper/tools/os-itn-wickham-direction-error.xml
+#GRAPHOUTPUTDIR=${HOME}/Documents/graphhopper/core/os-itn-wickham-direction-error-gh
 
+java -Xmx4596m -Xms2048m -XX:+UseParallelGC -XX:+UseParallelOldGC -cp ../tools/target/classes:target/classes:${HOME}/.m2/repository/net/java/dev/jsr-275/jsr-275/1.0-beta-2/jsr-275-1.0-beta-2.jar:${HOME}/.m2/repository/java3d/vecmath/1.3.2/vecmath-1.3.2.jar:${HOME}/.m2/repository/org/geotools/gt-opengis/12.1/gt-opengis-12.1.jar:${HOME}/.m2/repository/org/geotools/gt-epsg-hsql/12.1/gt-epsg-hsql-12.1.jar:${HOME}/.m2/repository/org/hsqldb/hsqldb/2.3.2/hsqldb-2.3.2.jar:${HOME}/.m2/repository/javax/media/jai_core/1.1.3/jai_core-1.1.3.jar:${HOME}/.m2/repository/org/geotools/gt-referencing/12.1/gt-referencing-12.1.jar:${HOME}/.m2/repository/org/geotools/gt-metadata/12.1/gt-metadata-12.1.jar:${HOME}/.m2/repository/org/slf4j/slf4j-api/1.7.7/slf4j-api-1.7.7.jar:${HOME}/.m2/repository/net/sf/trove4j/trove4j/3.0.3/trove4j-3.0.3.jar${LOGIT} com.graphhopper.tools.Import osmreader.osm=${ITNDATA} reader.implementation=OSITN graph.location=${GRAPHOUTPUTDIR} config=../config.properties
 
+ENDTIME=$(date +%s)
+echo "Generation took $[$ENDTIME - $STARTTIME] seconds"
diff --git a/core/pom.xml b/core/pom.xml
index 13552a2af0..ad56f83600 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -115,78 +115,106 @@ working seamlessly with OpenStreetMap data.
             <version>1.9.5</version>
             <scope>test</scope>
         </dependency>
+        
+        <!-- for using CGIAR: elevation data importing via tif files-->
+        <dependency>
+            <groupId>org.apache.xmlgraphics</groupId>
+            <artifactId>xmlgraphics-commons</artifactId>
+            <version>1.5</version>
+        </dependency>
+        
+        <dependency>
+            <groupId>com.google.protobuf</groupId>
+            <artifactId>protobuf-java</artifactId>
+            <version>2.6.1</version>
+        </dependency>        
+        <dependency>
+            <groupId>org.openstreetmap.osmosis</groupId>
+            <artifactId>osmosis-osm-binary</artifactId>
+            <version>0.43.1</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.json</groupId>
+            <artifactId>json</artifactId>
+            <!-- keep oldish version as we want to support 1.5 for a while -->
+            <version>20140107</version>
+            <scope>test</scope>
+        </dependency>
+        
     </dependencies>
-	<build>
-		<pluginManagement>
-			<plugins>
-				<plugin>
-					<groupId>org.apache.maven.plugins</groupId>
-					<artifactId>maven-assembly-plugin</artifactId>
-					<version>2.4.1</version>
-					<configuration>
-						<!-- for usage on android -->
-						<descriptors>
-							<descriptor>src/main/assembly/android.xml</descriptor>
-						</descriptors>
-					</configuration>
-				</plugin>
-				<plugin>
-					<groupId>org.apache.maven.plugins</groupId>
-					<artifactId>maven-site-plugin</artifactId>
-					<version>3.4</version>
-					<configuration>
-						<reportPlugins>
-							<plugin>
-								<!-- either call mvn compile site or mvn findbugs:gui -->
-								<groupId>org.codehaus.mojo</groupId>
-								<artifactId>findbugs-maven-plugin</artifactId>
-								<version>2.5.2</version>
-								<configuration>
-									<!-- <xmlOutput>true</xmlOutput> -->
-									<!-- Optional directory to put FindBugs xdoc xml report -->
-									<xmlOutputDirectory>target/site</xmlOutputDirectory>
-									<threshold>Normal</threshold>
-									<effort>Default</effort>
-									<!-- <threshold>High|Normal|Low|Exp|Ignore</threshold> <effort>Min|Default|Max</effort> -->
-								</configuration>
-							</plugin>
-						</reportPlugins>
-					</configuration>
-				</plugin>
-				<!-- create jar with test classes to be reused in other projects -->
-				<plugin>
-					<groupId>org.apache.maven.plugins</groupId>
-					<artifactId>maven-jar-plugin</artifactId>
-					<version>2.4</version>
-					<executions>
-						<execution>
-							<goals>
-								<goal>test-jar</goal>
-							</goals>
-						</execution>
-					</executions>
-				</plugin>
-			</plugins>
-		</pluginManagement>
-		<!-- make version available at runtime via version file -->
-		<resources>
-			<resource>
-				<directory>src/main/resources</directory>
-				<filtering>true</filtering>
-				<includes>
-					<include>**/version</include>
-					<include>**/builddate</include>
-				</includes>
-			</resource>
-			<resource>
-				<directory>src/main/resources</directory>
-				<filtering>false</filtering>
-				<excludes>
-					<exclude>**/version</exclude>
-					<exclude>**/builddate</exclude>
-				</excludes>
-			</resource>
-		</resources>
-	</build>
+        
+    <build>
+        <pluginManagement>
+            <plugins>
+                <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-assembly-plugin</artifactId>
+                    <configuration>                     
+                        <!-- for usage on android -->
+                        <descriptors>
+                            <descriptor>src/main/assembly/android.xml</descriptor>
+                        </descriptors>
+                    </configuration>
+                </plugin>                
+                    <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-site-plugin</artifactId>
+                    <version>3.4</version>
+                    <configuration>
+                        <reportPlugins>
+                            <plugin>
+                                <!-- either call mvn compile site or mvn findbugs:gui -->
+                                <groupId>org.codehaus.mojo</groupId>
+                                <artifactId>findbugs-maven-plugin</artifactId>
+                                <version>2.5.2</version>
+                                <configuration>
+                                    <!-- <xmlOutput>true</xmlOutput> -->
+                                    <!-- Optional directory to put FindBugs xdoc xml report -->
+                                    <xmlOutputDirectory>target/site</xmlOutputDirectory>
+                                    <threshold>Normal</threshold>
+                                    <effort>Default</effort>
+                                    <!-- <threshold>High|Normal|Low|Exp|Ignore</threshold> <effort>Min|Default|Max</effort> -->
+                                </configuration>
+                            </plugin>
+                        </reportPlugins>
+                    </configuration>
+                </plugin>
+                <!-- create jar with test classes to be reused in other projects -->                
+                <plugin>
+                    <groupId>org.apache.maven.plugins</groupId>
+                    <artifactId>maven-jar-plugin</artifactId>
+                    <executions>
+                        <execution>
+                            <goals>
+                                <goal>test-jar</goal>
+                            </goals>
+                        </execution>
+                    </executions>
+                </plugin>
+                
+            </plugins>
+        </pluginManagement>
+        
+        <!-- make version available at runtime via version file -->
+        <resources>
+            <resource>
+                <directory>src/main/resources</directory>
+                <filtering>true</filtering>
+                <includes>
+                    <include>**/version</include>
+                    <include>**/builddate</include>
+                </includes>
+            </resource>
+            <resource>
+                <directory>src/main/resources</directory>
+                <filtering>false</filtering>
+                <excludes>
+                    <exclude>**/version</exclude>
+                    <exclude>**/builddate</exclude>
+                </excludes>
+            </resource>
+        </resources>
+    </build>
 </project>
 
diff --git a/core/src/main/java/com/graphhopper/GHRequest.java b/core/src/main/java/com/graphhopper/GHRequest.java
index 7c0441b375..f68f7cf332 100644
--- a/core/src/main/java/com/graphhopper/GHRequest.java
+++ b/core/src/main/java/com/graphhopper/GHRequest.java
@@ -19,7 +19,6 @@
 
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.PMap;
 import com.graphhopper.util.shapes.GHPoint;
 import java.util.ArrayList;
 import java.util.List;
@@ -97,8 +96,7 @@ public GHRequest addPoint( GHPoint point )
     }
 
     /**
-     * Possible values: astar (A* algorithm, default), astarbi (bidirectional A*), dijkstra
-     * (Dijkstra) or dijkstrabi. Or specify empty to use default.
+     * For possible values see AlgorithmOptions.*
      */
     public GHRequest setAlgorithm( String algo )
     {
diff --git a/core/src/main/java/com/graphhopper/GHResponse.java b/core/src/main/java/com/graphhopper/GHResponse.java
index c0086f42da..bb4cf99981 100644
--- a/core/src/main/java/com/graphhopper/GHResponse.java
+++ b/core/src/main/java/com/graphhopper/GHResponse.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,11 +17,12 @@
  */
 package com.graphhopper;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
-import java.util.ArrayList;
-import java.util.List;
 
 /**
  * Wrapper to simplify output of GraphHopper.
@@ -34,9 +35,9 @@
     private final List<Throwable> errors = new ArrayList<Throwable>(4);
     private PointList list = PointList.EMPTY;
     private double distance;
-    private double weight;
+    private double routeWeight;
     private long time;
-    private InstructionList instructions = InstructionList.EMPTY;
+    private InstructionList instructions = null;
     private boolean found;
 
     public GHResponse()
@@ -45,8 +46,18 @@ public GHResponse()
 
     public String getDebugInfo()
     {
+        check("getDebugInfo");
         return debugInfo;
     }
+    public GHResponse setFound( boolean found )
+    {
+        this.found = found;
+        return this;
+    }
+    public boolean isFound()
+    {
+        return found;
+    }
 
     public GHResponse setDebugInfo( String debugInfo )
     {
@@ -55,6 +66,15 @@ public GHResponse setDebugInfo( String debugInfo )
         return this;
     }
 
+    private void check( String method )
+    {
+        if (hasErrors())
+        {
+            throw new RuntimeException("You cannot call " + method + " if response contains errors. Check this with ghResponse.hasErrors(). "
+                    + "Errors are: " + getErrors());
+        }
+    }
+
     /**
      * @return true if one or more error found
      */
@@ -88,6 +108,7 @@ public GHResponse setPoints( PointList points )
      */
     public PointList getPoints()
     {
+        check("getPoints");
         return list;
     }
 
@@ -105,6 +126,7 @@ public GHResponse setDistance( double distance )
      */
     public double getDistance()
     {
+        check("getDistance");
         return distance;
     }
 
@@ -124,7 +146,7 @@ public long getMillis()
 
     public GHResponse setRouteWeight( double weight )
     {
-        this.weight = weight;
+        this.routeWeight = weight;
         return this;
     }
 
@@ -135,18 +157,8 @@ public GHResponse setRouteWeight( double weight )
      */
     public double getRouteWeight()
     {
-        return weight;
-    }
-
-    public GHResponse setFound( boolean found )
-    {
-        this.found = found;
-        return this;
-    }
-
-    public boolean isFound()
-    {
-        return found;
+        check("getRouteWeight");
+        return routeWeight;
     }
 
     /**
@@ -154,7 +166,8 @@ public boolean isFound()
      */
     public BBox calcRouteBBox( BBox _fallback )
     {
-        BBox bounds = BBox.INVERSE.clone();
+        check("calcRouteBBox");
+        BBox bounds = BBox.createInverse(_fallback.hasElevation());
         int len = list.getSize();
         if (len == 0)
             return _fallback;
@@ -163,17 +176,14 @@ public BBox calcRouteBBox( BBox _fallback )
         {
             double lat = list.getLatitude(i);
             double lon = list.getLongitude(i);
-            if (lat > bounds.maxLat)
-                bounds.maxLat = lat;
-
-            if (lat < bounds.minLat)
-                bounds.minLat = lat;
-
-            if (lon > bounds.maxLon)
-                bounds.maxLon = lon;
-
-            if (lon < bounds.minLon)
-                bounds.minLon = lon;
+            if (bounds.hasElevation())
+            {
+                double ele = list.getEle(i);
+                bounds.update(lat, lon, ele);
+            } else
+            {
+                bounds.update(lat, lon);
+            }
         }
         return bounds;
     }
@@ -181,7 +191,7 @@ public BBox calcRouteBBox( BBox _fallback )
     @Override
     public String toString()
     {
-        String str = "found:" + isFound() + ", nodes:" + list.getSize() + ": " + list.toString();
+        String str = "nodes:" + list.getSize() + ": " + list.toString();
         if (!instructions.isEmpty())
             str += ", " + instructions.toString();
 
@@ -198,6 +208,10 @@ public void setInstructions( InstructionList instructions )
 
     public InstructionList getInstructions()
     {
+        check("getInstructions");
+        if (instructions == null)
+            throw new IllegalArgumentException("To access instructions you need to enable creation before routing");
+
         return instructions;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 8adf1a44d8..4661e36a7e 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -37,16 +37,18 @@
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.reader.osgb.OsItnReader;
 import com.graphhopper.reader.osgb.dpn.OsDpnReader;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.Path;
+import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.routing.util.AlgorithmPreparation;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FastestWeighting;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
 import com.graphhopper.routing.util.PrepareRoutingSubnetworks;
 import com.graphhopper.routing.util.PriorityWeighting;
 import com.graphhopper.routing.util.ShortestWeighting;
@@ -57,6 +59,7 @@
 import com.graphhopper.storage.DAType;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.LevelGraph;
@@ -65,10 +68,9 @@
 import com.graphhopper.storage.LockFactory;
 import com.graphhopper.storage.NativeFSLockFactory;
 import com.graphhopper.storage.SimpleFSLockFactory;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Constants;
@@ -84,11 +86,11 @@
 /**
  * Easy to use access point to configure import and (offline) routing.
  * <p/>
+ *
  * @see GraphHopperAPI
  * @author Peter Karich
  */
-public class GraphHopper implements GraphHopperAPI
-{
+public class GraphHopper implements GraphHopperAPI {
     private static final String READER_UNAVAILABLE = "DataReader implementation %s not available check your setting for reader.implementation.  Allowed options are OSM or OSITN";
     private final Logger logger = LoggerFactory.getLogger(getClass());
     // for graph:
@@ -103,23 +105,25 @@
     private LockFactory lockFactory = new NativeFSLockFactory();
     private final String fileLockName = "gh.lock";
     private boolean allowWrites = true;
-    private boolean enableInstructions = true;
+    boolean enableInstructions = true;
     private boolean fullyLoaded = false;
     // for routing
+    private double defaultWeightLimit = Double.MAX_VALUE;
     private boolean simplifyResponse = true;
     private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private String defaultVehicleStr;
+    private RoutingAlgorithmFactory algoFactory;
     // for index
     private LocationIndex locationIndex;
     private int preciseIndexResolution = 300;
     private int maxRegionSearch = 4;
     // for prepare
     private int minNetworkSize = 200;
-    private int minOnewayNetworkSize = 0;
+    private int minOneWayNetworkSize = 0;
     // for CH prepare
-    private AlgorithmPreparation prepare;
     private boolean doPrepare = true;
     private boolean chEnabled = true;
-    private String chWeighting = "fastest";
+    private String chWeightingStr = "fastest";
     private int periodicUpdates = -1;
     private int lazyUpdates = -1;
     private int neighborUpdates = -1;
@@ -135,39 +139,43 @@
     private final AtomicLong visitedSum = new AtomicLong(0);
     private String dataReader = "OSM";
 
-    public GraphHopper()
-    {
+    public GraphHopper() {
     }
 
     /**
      * For testing only
      */
-    protected GraphHopper loadGraph(GraphStorage g)
-    {
+    protected GraphHopper loadGraph(GraphStorage g) {
         this.graph = g;
         fullyLoaded = true;
         initLocationIndex();
+        initDefaultVehicleIfNecessary();
         return this;
     }
 
     /**
-     * Specify which vehicles can be read by this GraphHopper instance. An encoding manager defines
-     * how data from every vehicle is written (und read) into edges of the graph.
+     * Specify which vehicles can be read by this GraphHopper instance. An
+     * encoding manager defines how data from every vehicle is written (und
+     * read) into edges of the graph.
      */
-    public GraphHopper setEncodingManager(EncodingManager em)
-    {
+    public GraphHopper setEncodingManager(EncodingManager em) {
         ensureNotLoaded();
         this.encodingManager = em;
+        if (em.needsTurnCostsSupport())
+            traversalMode = TraversalMode.EDGE_BASED_2DIR;
+
         return this;
     }
 
-    public EncodingManager getEncodingManager()
-    {
+    private FlagEncoder getFirstVehicle() {
+        return encodingManager.fetchEdgeEncoders().get(0);
+    }
+
+    public EncodingManager getEncodingManager() {
         return encodingManager;
     }
 
-    public GraphHopper setElevationProvider(ElevationProvider eleProvider)
-    {
+    public GraphHopper setElevationProvider(ElevationProvider eleProvider) {
         if (eleProvider == null || eleProvider == ElevationProvider.NOOP)
             setElevation(false);
         else
@@ -179,25 +187,24 @@ public GraphHopper setElevationProvider(ElevationProvider eleProvider)
     /**
      * Threads for data reading.
      */
-    protected int getWorkerThreads()
-    {
+    protected int getWorkerThreads() {
         return workerThreads;
     }
 
     /**
-     * Return maximum distance (in meter) to reduce points via douglas peucker while OSM import.
+     * Return maximum distance (in meter) to reduce points via douglas peucker
+     * while OSM import.
      */
-    protected double getWayPointMaxDistance()
-    {
+    protected double getWayPointMaxDistance() {
         return osmReaderWayPointMaxDistance;
     }
 
     /**
-     * This parameter specifies how to reduce points via douglas peucker while OSM import. Higher
-     * value means more details, unit is meter. Default is 1. Disable via 0.
+     * This parameter specifies how to reduce points via douglas peucker while
+     * OSM import. Higher value means more details, unit is meter. Default is 1.
+     * Disable via 0.
      */
-    public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance)
-    {
+    public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance) {
         this.osmReaderWayPointMaxDistance = wayPointMaxDistance;
         return this;
     }
@@ -205,79 +212,79 @@ public GraphHopper setWayPointMaxDistance(double wayPointMaxDistance)
     /**
      * Sets the default traversal mode used for the algorithms and preparation.
      */
-    public GraphHopper setTraversalMode(TraversalMode traversalMode)
-    {
+    public GraphHopper setTraversalMode(TraversalMode traversalMode) {
         this.traversalMode = traversalMode;
         return this;
     }
 
-    public TraversalMode getTraversalMode()
-    {
+    public TraversalMode getTraversalMode() {
         return traversalMode;
     }
 
     /**
-     * Configures the underlying storage to be used on a well equipped server.
+     * Configures the underlying storage and response to be used on a well
+     * equipped server. Result also optimized for usage in the web module i.e.
+     * try reduce network IO.
      */
-    public GraphHopper forServer()
-    {
-        // simplify to reduce network IO
+    public GraphHopper forServer() {
         setSimplifyResponse(true);
         return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a Desktop computer with enough RAM but no
-     * network latency.
+     * Configures the underlying storage to be used on a Desktop computer or
+     * within another Java application with enough RAM but no network latency.
      */
-    public GraphHopper forDesktop()
-    {
+    public GraphHopper forDesktop() {
         setSimplifyResponse(false);
         return setInMemory();
     }
 
     /**
-     * Configures the underlying storage to be used on a less powerful machine like Android and
-     * Raspberry Pi with only few RAM.
+     * Configures the underlying storage to be used on a less powerful machine
+     * like Android or Raspberry Pi with only few MB of RAM.
      */
-    public GraphHopper forMobile()
-    {
+    public GraphHopper forMobile() {
         setSimplifyResponse(false);
         return setMemoryMapped();
     }
 
     /**
-     * Precise location resolution index means also more space (disc/RAM) could be consumed and
-     * probably slower query times, which would be e.g. not suitable for Android. The resolution
-     * specifies the tile width (in meter).
+     * Precise location resolution index means also more space (disc/RAM) could
+     * be consumed and probably slower query times, which would be e.g. not
+     * suitable for Android. The resolution specifies the tile width (in meter).
      */
-    public GraphHopper setPreciseIndexResolution(int precision)
-    {
+    public GraphHopper setPreciseIndexResolution(int precision) {
         ensureNotLoaded();
         preciseIndexResolution = precision;
         return this;
     }
 
+    public void setMinNetworkSize(int minNetworkSize, int minOneWayNetworkSize) {
+        this.minNetworkSize = minNetworkSize;
+        this.minOneWayNetworkSize = minOneWayNetworkSize;
+    }
+
     /**
      * This method call results in an in-memory graph.
      */
-    public GraphHopper setInMemory()
-    {
+    public GraphHopper setInMemory() {
         ensureNotLoaded();
         dataAccessType = DAType.RAM_STORE;
         return this;
     }
 
     /**
-     * Only valid option for in-memory graph and if you e.g. want to disable store on flush for unit
-     * tests. Specify storeOnFlush to true if you want that existing data will be loaded FROM disc
-     * and all in-memory data will be flushed TO disc after flush is called e.g. while OSM import.
+     * Only valid option for in-memory graph and if you e.g. want to disable
+     * store on flush for unit tests. Specify storeOnFlush to true if you want
+     * that existing data will be loaded FROM disc and all in-memory data will
+     * be flushed TO disc after flush is called e.g. while OSM import.
      * <p>
+     *
      * @param storeOnFlush
      *            true by default
      */
-    public GraphHopper setStoreOnFlush(boolean storeOnFlush)
-    {
+    public GraphHopper setStoreOnFlush(boolean storeOnFlush) {
         ensureNotLoaded();
         if (storeOnFlush)
             dataAccessType = DAType.RAM_STORE;
@@ -287,10 +294,10 @@ public GraphHopper setStoreOnFlush(boolean storeOnFlush)
     }
 
     /**
-     * Enable memory mapped configuration if not enough memory is available on the target platform.
+     * Enable memory mapped configuration if not enough memory is available on
+     * the target platform.
      */
-    public GraphHopper setMemoryMapped()
-    {
+    public GraphHopper setMemoryMapped() {
         ensureNotLoaded();
         dataAccessType = DAType.MMAP;
         return this;
@@ -299,99 +306,140 @@ public GraphHopper setMemoryMapped()
     /**
      * Not yet stable enough to offer it for everyone
      */
-    private GraphHopper setUnsafeMemory()
-    {
+    private GraphHopper setUnsafeMemory() {
         ensureNotLoaded();
         dataAccessType = DAType.UNSAFE_STORE;
         return this;
     }
 
     /**
-     * Disables "CH-preparation". Use only if you know what you do.
+     * This method sets the default vehicle to use if no vehicle is specified in
+     * the GHRequest object. Per default the lexicographically first vehicle is
+     * used.
      */
-    public GraphHopper setDoPrepare(boolean doPrepare)
+    // <<<<<<< HEAD
+    // public GraphHopper setDoPrepare(boolean doPrepare)
+    // =======
+    public void setDefaultVehicle(String defaultVehicleStr)
+    // >>>>>>> upstream/master
     {
-        this.doPrepare = doPrepare;
-        return this;
+        if (this.defaultVehicleStr != null)
+            throw new RuntimeException("Cannot change default vehicle " + this.defaultVehicleStr + " to " + defaultVehicleStr);
+
+        this.defaultVehicleStr = defaultVehicleStr;
+    }
+
+    /**
+     * The default vehicle is the single vehicle used for CH preparation as well
+     * as the default vehicle if no specified in GHRequest. Per default the
+     * lexicographically first vehicle is used.
+     */
+    public String getDefaultVehicle() {
+        if (defaultVehicleStr == null)
+            throw new RuntimeException("Set default vehicle before");
+
+        return defaultVehicleStr;
     }
 
     /**
-     * Enables the use of contraction hierarchies to reduce query times. Enabled by default.
+     * Enables the use of contraction hierarchies to reduce query times. Enabled
+     * by default.
      * <p/>
+     *
      * @param weighting
-     *            can be "fastest", "shortest" or your own weight-calculation type.
+     *            can be "fastest", "shortest" or your own weight-calculation
+     *            type.
      * @see #setCHEnable(boolean)
      */
-    public GraphHopper setCHWeighting(String weighting)
-    {
+    public GraphHopper setCHWeighting(String weighting) {
         ensureNotLoaded();
-        chWeighting = weighting;
+        chWeightingStr = weighting;
         return this;
     }
 
-    public String getCHWeighting()
-    {
-        return chWeighting;
+    public String getCHWeighting() {
+        return chWeightingStr;
     }
 
     /**
-     * Enables or disables contraction hierarchies. Enabled by default.
+     * Disables the "CH-preparation" preparation only. Use only if you know what
+     * you do. To disable the full usage of CH use setCHEnable(false) instead.
      */
-    public GraphHopper setCHEnable(boolean enable)
-    {
+    public GraphHopper setDoPrepare(boolean doPrepare) {
+        this.doPrepare = doPrepare;
+        return this;
+    }
+
+    /**
+     * Enables or disables contraction hierarchies (CH). This speed-up mode is
+     * enabled by default. Disabling CH is only recommended for short routes or
+     * in combination with setDefaultWeightLimit and called flexibility mode
+     * <p>
+     *
+     * @see #setDefaultWeightLimit(double)
+     */
+    public GraphHopper setCHEnable(boolean enable) {
         ensureNotLoaded();
+        algoFactory = null;
         chEnabled = enable;
         return this;
     }
 
-    public boolean isCHEnabled()
-    {
+    /**
+     * This methods stops the algorithm from searching further if the resulting
+     * path would go over specified weight, important if CH is disabled. The
+     * unit is defined by the used weighting created from createWeighting, e.g.
+     * distance for shortest or seconds for the standard FastestWeighting
+     * implementation.
+     */
+    public void setDefaultWeightLimit(double defaultWeightLimit) {
+        this.defaultWeightLimit = defaultWeightLimit;
+    }
+
+    public boolean isCHEnabled() {
         return chEnabled;
     }
 
     /**
-     * @return true if storing and fetching elevation data is enabled. Default is false
+     * @return true if storing and fetching elevation data is enabled. Default
+     *         is false
      */
-    public boolean hasElevation()
-    {
+    public boolean hasElevation() {
         return elevation;
     }
 
     /**
      * Enable storing and fetching elevation data. Default is false
      */
-    public GraphHopper setElevation(boolean includeElevation)
-    {
+    public GraphHopper setElevation(boolean includeElevation) {
         this.elevation = includeElevation;
         return this;
     }
 
     /**
-     * This method specifies if the import should include way names to be able to return
-     * instructions for a route.
+     * This method specifies if the import should include way names to be able
+     * to return instructions for a route.
      */
-    public GraphHopper setEnableInstructions(boolean b)
-    {
+    public GraphHopper setEnableInstructions(boolean b) {
         ensureNotLoaded();
         enableInstructions = b;
         return this;
     }
 
     /**
-     * This methods enables gps point calculation. If disabled only distance will be calculated.
+     * This methods enables gps point calculation. If disabled only distance
+     * will be calculated.
      */
-    public GraphHopper setEnableCalcPoints(boolean b)
-    {
+    public GraphHopper setEnableCalcPoints(boolean b) {
         calcPoints = b;
         return this;
     }
 
     /**
-     * This method specifies if the returned path should be simplified or not, via douglas-peucker
-     * or similar algorithm.
+     * This method specifies if the returned path should be simplified or not,
+     * via douglas-peucker or similar algorithm.
      */
-    private GraphHopper setSimplifyResponse(boolean doSimplify)
-    {
+    private GraphHopper setSimplifyResponse(boolean doSimplify) {
         this.simplifyResponse = doSimplify;
         return this;
     }
@@ -399,8 +447,7 @@ private GraphHopper setSimplifyResponse(boolean doSimplify)
     /**
      * Sets the graphhopper folder.
      */
-    public GraphHopper setGraphHopperLocation(String ghLocation)
-    {
+    public GraphHopper setGraphHopperLocation(String ghLocation) {
         ensureNotLoaded();
         if (ghLocation == null)
             throw new IllegalArgumentException("graphhopper location cannot be null");
@@ -409,17 +456,15 @@ public GraphHopper setGraphHopperLocation(String ghLocation)
         return this;
     }
 
-    public String getGraphHopperLocation()
-    {
+    public String getGraphHopperLocation() {
         return ghLocation;
     }
 
     /**
-     * This file can be an osm xml (.osm), a compressed xml (.osm.zip or .osm.gz) or a protobuf file
-     * (.pbf).
+     * This file can be an osm xml (.osm), a compressed xml (.osm.zip or
+     * .osm.gz) or a protobuf file (.pbf).
      */
-    public GraphHopper setOSMFile(String osmFileStr)
-    {
+    public GraphHopper setOSMFile(String osmFileStr) {
         ensureNotLoaded();
         if (Helper.isEmpty(osmFileStr))
             throw new IllegalArgumentException("OSM file cannot be empty.");
@@ -428,91 +473,80 @@ public GraphHopper setOSMFile(String osmFileStr)
         return this;
     }
 
-    public String getOSMFile()
-    {
+    public String getOSMFile() {
         return osmFile;
     }
 
     /**
      * The underlying graph used in algorithms.
      * <p>
+     *
      * @throws IllegalStateException
      *             if graph is not instantiated.
      */
-    public GraphStorage getGraph()
-    {
+    public GraphStorage getGraph() {
         if (graph == null)
             throw new IllegalStateException("Graph not initialized");
 
         return graph;
     }
 
-    public void setGraph(GraphStorage graph)
-    {
+    public void setGraph(GraphStorage graph) {
         this.graph = graph;
     }
 
-    protected void setLocationIndex(LocationIndex locationIndex)
-    {
+    protected void setLocationIndex(LocationIndex locationIndex) {
         this.locationIndex = locationIndex;
     }
 
     /**
      * The location index created from the graph.
      * <p>
+     *
      * @throws IllegalStateException
      *             if index is not initialized
      */
-    public LocationIndex getLocationIndex()
-    {
+    public LocationIndex getLocationIndex() {
         if (locationIndex == null)
             throw new IllegalStateException("Location index not initialized");
 
         return locationIndex;
     }
 
-    public AlgorithmPreparation getPreparation()
-    {
-        return prepare;
-    }
-
     /**
      * Sorts the graph which requires more RAM while import. See #12
      */
-    public GraphHopper setSortGraph(boolean sortGraph)
-    {
+    public GraphHopper setSortGraph(boolean sortGraph) {
         ensureNotLoaded();
         this.sortGraph = sortGraph;
         return this;
     }
 
     /**
-     * Specifies if it is allowed for GraphHopper to write. E.g. for read only filesystems it is not
-     * possible to create a lock file and so we can avoid write locks.
+     * Specifies if it is allowed for GraphHopper to write. E.g. for read only
+     * filesystems it is not possible to create a lock file and so we can avoid
+     * write locks.
      */
-    public GraphHopper setAllowWrites(boolean allowWrites)
-    {
+    public GraphHopper setAllowWrites(boolean allowWrites) {
         this.allowWrites = allowWrites;
         return this;
     }
 
-    public boolean isAllowWrites()
-    {
+    public boolean isAllowWrites() {
         return allowWrites;
     }
 
-    public TranslationMap getTranslationMap()
-    {
+    public TranslationMap getTranslationMap() {
         return trMap;
     }
 
     /**
-     * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
-     * args) ala CmdArgs.read(args) or via configuration file ala
-     * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
+     * Reads configuration from a CmdArgs object. Which can be manually filled,
+     * or via main(String[] args) ala CmdArgs.read(args) or via configuration
+     * file ala CmdArgs.readFromConfig("config.properties",
+     * "graphhopper.config")
      */
-    public GraphHopper init(CmdArgs args)
-    {
+    public GraphHopper init(CmdArgs args) {
         args = CmdArgs.readFromConfigAndMerge(args, "config", "graphhopper.config");
         String tmpOsmFile = args.get("osmreader.osm", "");
         if (!Helper.isEmpty(tmpOsmFile))
@@ -521,8 +555,7 @@ public GraphHopper init(CmdArgs args)
         dataReader = args.get("reader.implementation", dataReader);
 
         String graphHopperFolder = args.get("graph.location", "");
-        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation))
-        {
+        if (Helper.isEmpty(graphHopperFolder) && Helper.isEmpty(ghLocation)) {
             if (Helper.isEmpty(osmFile))
                 throw new IllegalArgumentException("You need to specify an OSM file.");
 
@@ -553,11 +586,9 @@ public GraphHopper init(CmdArgs args)
         ElevationProvider tmpProvider = ElevationProvider.NOOP;
         if (eleProviderStr.equalsIgnoreCase("srtm"))
             tmpProvider = new SRTMProvider();
-        else if (eleProviderStr.equalsIgnoreCase("cgiar"))
-        {
+        else if (eleProviderStr.equalsIgnoreCase("cgiar")) {
             CGIARProvider cgiarProvider = new CGIARProvider();
-            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear",
-                    true));
+            cgiarProvider.setAutoRemoveTemporaryFiles(args.getBool("graph.elevation.cgiar.clear", true));
             tmpProvider = cgiarProvider;
         }
 
@@ -570,7 +601,7 @@ else if (eleProviderStr.equalsIgnoreCase("cgiar"))
 
         // optimizable prepare
         minNetworkSize = args.getInt("prepare.minNetworkSize", minNetworkSize);
-        minOnewayNetworkSize = args.getInt("prepare.minOnewayNetworkSize", minOnewayNetworkSize);
+        minOneWayNetworkSize = args.getInt("prepare.minOneWayNetworkSize", minOneWayNetworkSize);
 
         // prepare CH
         doPrepare = args.getBool("prepare.doPrepare", doPrepare);
@@ -585,38 +616,48 @@ else if (eleProviderStr.equalsIgnoreCase("cgiar"))
         logMessages = args.getDouble("prepare.logmessages", logMessages);
 
         // osm import
-        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance",
-                osmReaderWayPointMaxDistance);
-        String flagEncoders = args.get("graph.flagEncoders", "CAR");
-        if (flagEncoders.toLowerCase().contains("turncosts=true"))
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
-        encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+        // <<<<<<< HEAD
+        // osmReaderWayPointMaxDistance =
+        // args.getDouble("osmreader.wayPointMaxDistance",
+        // osmReaderWayPointMaxDistance);
+        // String flagEncoders = args.get("graph.flagEncoders", "CAR");
+        // if (flagEncoders.toLowerCase().contains("turncosts=true"))
+        // traversalMode = TraversalMode.EDGE_BASED_2DIR;
+        // encodingManager = new EncodingManager(flagEncoders, bytesForFlags);
+        // =======
+        osmReaderWayPointMaxDistance = args.getDouble("osmreader.wayPointMaxDistance", osmReaderWayPointMaxDistance);
+        String flagEncoders = args.get("graph.flagEncoders", "");
+        setEncodingManager(new EncodingManager(flagEncoders, bytesForFlags));
+        // >>>>>>> upstream/master
         workerThreads = args.getInt("osmreader.workerThreads", workerThreads);
         enableInstructions = args.getBool("osmreader.instructions", enableInstructions);
 
+        // default vehicle which is used if no algorithm is specified
+        setDefaultVehicle(args.get("algorithm.defaultVehicle", getFirstVehicle().toString()));
+
         // index
         preciseIndexResolution = args.getInt("index.highResolution", preciseIndexResolution);
         maxRegionSearch = args.getInt("index.maxRegionSearch", maxRegionSearch);
+
+        // routing
+        defaultWeightLimit = args.getDouble("routing.defaultWeightLimit", defaultWeightLimit);
         return this;
     }
 
-    private void printInfo()
-    {
-        logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " ("
-                + Constants.getVersions() + ")");
+    private void printInfo() {
+        logger.info("version " + Constants.VERSION + "|" + Constants.BUILD_DATE + " (" + Constants.getVersions() + ")");
         if (graph != null)
             logger.info("graph " + graph.toString() + ", details:" + graph.toDetailsString());
     }
 
     /**
-     * Imports provided data from disc and creates graph. Depending on the settings the resulting
-     * graph will be stored to disc so on a second call this method will only load the graph from
-     * disc which is usually a lot faster.
+     * Imports provided data from disc and creates graph. Depending on the
+     * settings the resulting graph will be stored to disc so on a second call
+     * this method will only load the graph from disc which is usually a lot
+     * faster.
      */
-    public GraphHopper importOrLoad()
-    {
-        if (!load(ghLocation))
-        {
+    public GraphHopper importOrLoad() {
+        if (!load(ghLocation)) {
             printInfo();
             process(ghLocation);
         } else
@@ -627,52 +668,41 @@ public GraphHopper importOrLoad()
     /**
      * Creates the graph from OSM data.
      */
-    private GraphHopper process(String graphHopperLocation)
-    {
+    private GraphHopper process(String graphHopperLocation) {
         setGraphHopperLocation(graphHopperLocation);
         Lock lock = null;
-        try
-        {
-            if (graph.getDirectory().getDefaultType().isStoring())
-            {
+        try {
+            if (graph.getDirectory().getDefaultType().isStoring()) {
                 lockFactory.setLockDir(new File(graphHopperLocation));
                 lock = lockFactory.create(fileLockName, true);
                 if (!lock.tryLock())
-                    throw new RuntimeException(
-                            "To avoid multiple writers we need to obtain a write lock but it failed. In "
-                                    + graphHopperLocation,
-                                    lock.getObtainFailedReason());
+                    throw new RuntimeException("To avoid multiple writers we need to obtain a write lock but it failed. In " + graphHopperLocation, lock.getObtainFailedReason());
             }
 
-            try
-            {
+            try {
                 importData();
                 graph.getProperties().put("osmreader.import.date", formatDateTime(new Date()));
-            } catch (IOException ex)
-            {
+            } catch (IOException ex) {
                 throw new RuntimeException("Cannot parse OSM file " + getOSMFile(), ex);
             }
             cleanUp();
             optimize();
             postProcessing();
             flush();
-        } finally
-        {
+        } finally {
             if (lock != null)
                 lock.release();
         }
         return this;
     }
 
-    protected DataReader importData() throws IOException
-    {
+    protected DataReader importData() throws IOException {
         ensureWriteAccess();
         if (graph == null)
             throw new IllegalStateException("Load graph before importing OSM data");
 
         if (osmFile == null)
-            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
-                    + " but also cannot import from OSM file as it wasn't specified!");
+            throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation + " but also cannot import from OSM file as it wasn't specified!");
 
         encodingManager.setEnableInstructions(enableInstructions);
         DataReader reader = createReader(graph);
@@ -681,8 +711,7 @@ protected DataReader importData() throws IOException
         return reader;
     }
 
-    protected DataReader createReader(GraphStorage tmpGraph)
-    {
+    protected DataReader createReader(GraphStorage tmpGraph) {
         DataReader reader;
         if ("OSM".equals(dataReader))
             reader = new OSMReader(tmpGraph);
@@ -690,70 +719,61 @@ else if ("OSITN".equals(dataReader))
             reader = new OsItnReader(tmpGraph);
         else if ("OSDPN".equals(dataReader))
             reader = new OsDpnReader(tmpGraph);
-        else
-        {
+        else {
             String exceptionMessage = String.format(READER_UNAVAILABLE, dataReader);
             throw new IllegalArgumentException(exceptionMessage);
         }
         return initReader(reader);
     }
 
-    protected DataReader initReader(DataReader reader)
-    {
+    protected DataReader initReader(DataReader reader) {
         if (osmFile == null)
             throw new IllegalArgumentException("No OSM file specified");
 
         logger.info("start creating graph from " + osmFile);
         File osmTmpFile = new File(osmFile);
-        return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider)
-                .setWorkerThreads(workerThreads).setEncodingManager(encodingManager)
-                .setWayPointMaxDistance(osmReaderWayPointMaxDistance);
+        return reader.setOSMFile(osmTmpFile).setElevationProvider(eleProvider).setWorkerThreads(workerThreads).setEncodingManager(encodingManager).setWayPointMaxDistance(osmReaderWayPointMaxDistance);
     }
 
     /**
      * Opens existing graph.
      * <p/>
+     *
      * @param graphHopperFolder
-     *            is the folder containing graphhopper files (which can be compressed too)
+     *            is the folder containing graphhopper files (which can be
+     *            compressed too)
      */
     @Override
-    public boolean load(String graphHopperFolder)
-    {
+    public boolean load(String graphHopperFolder) {
         if (Helper.isEmpty(graphHopperFolder))
-            throw new IllegalStateException(
-                    "graphHopperLocation is not specified. call init before");
+            throw new IllegalStateException("graphHopperLocation is not specified. call init before");
 
         if (fullyLoaded)
             throw new IllegalStateException("graph is already successfully loaded");
 
-        if (graphHopperFolder.endsWith("-gh"))
-        {
+        if (graphHopperFolder.endsWith("-gh")) {
             // do nothing
         } else if (graphHopperFolder.endsWith(".osm") || graphHopperFolder.endsWith(".xml"))
             throw new IllegalArgumentException("To import an osm file you need to use importOrLoad");
-        else if (!graphHopperFolder.contains("."))
-        {
+        else if (!graphHopperFolder.contains(".")) {
             if (new File(graphHopperFolder + "-gh").exists())
                 graphHopperFolder += "-gh";
-        } else
-        {
+        } else {
             File compressed = new File(graphHopperFolder + ".ghz");
             if (compressed.exists() && !compressed.isDirectory())
-                try
-            {
-                    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder,
-                            removeZipped);
-            } catch (IOException ex)
-            {
-                throw new RuntimeException("Couldn't extract file "
-                        + compressed.getAbsolutePath() + " to " + graphHopperFolder, ex);
-            }
+                try {
+                    new Unzipper().unzip(compressed.getAbsolutePath(), graphHopperFolder, removeZipped);
+                } catch (IOException ex) {
+                    throw new RuntimeException("Couldn't extract file " + compressed.getAbsolutePath() + " to " + graphHopperFolder, ex);
+                }
         }
 
         setGraphHopperLocation(graphHopperFolder);
 
         if (encodingManager == null)
-            encodingManager = EncodingManager.create(ghLocation);
+            setEncodingManager(EncodingManager.create(ghLocation));
+
+        initDefaultVehicleIfNecessary();
 
         if (!allowWrites && dataAccessType.isMMap())
             dataAccessType = DAType.MMAP_RO;
@@ -762,27 +782,28 @@ else if (!graphHopperFolder.contains("."))
         if (chEnabled)
             graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
         else if (encodingManager.needsTurnCostsSupport())
-            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(),
-                    new TurnCostStorage());
+            // <<<<<<< HEAD
+            // graph = new GraphHopperStorage(dir, encodingManager,
+            // hasElevation(),
+            // new TurnCostStorage());
+            // =======
+            graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
+        // >>>>>>> upstream/master
         else
             graph = new GraphHopperStorage(dir, encodingManager, hasElevation());
 
         graph.setSegmentSize(defaultSegmentSize);
 
         Lock lock = null;
-        try
-        {
+        try {
             // create locks only if writes are allowed, if they are not allowed
             // a lock cannot be created
             // (e.g. on a read only filesystem locks would fail)
-            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites())
-            {
+            if (graph.getDirectory().getDefaultType().isStoring() && isAllowWrites()) {
                 lockFactory.setLockDir(new File(ghLocation));
                 lock = lockFactory.create(fileLockName, false);
                 if (!lock.tryLock())
-                    throw new RuntimeException(
-                            "To avoid reading partial data we need to obtain the read lock but it failed. In "
-                                    + ghLocation, lock.getObtainFailedReason());
+                    throw new RuntimeException("To avoid reading partial data we need to obtain the read lock but it failed. In " + ghLocation, lock.getObtainFailedReason());
             }
 
             if (!graph.loadExisting())
@@ -791,234 +812,315 @@ else if (encodingManager.needsTurnCostsSupport())
             postProcessing();
             fullyLoaded = true;
             return true;
-        } finally
-        {
+        } finally {
             if (lock != null)
                 lock.release();
         }
     }
 
+    public RoutingAlgorithmFactory getAlgorithmFactory() {
+        if (algoFactory == null)
+            this.algoFactory = new RoutingAlgorithmFactorySimple();
+
+        return algoFactory;
+    }
+
+    public void setAlgorithmFactory(RoutingAlgorithmFactory algoFactory) {
+        this.algoFactory = algoFactory;
+    }
+
     /**
      * Sets EncodingManager, does the preparation and creates the locationIndex
      */
-    protected void postProcessing()
-    {
-        encodingManager = graph.getEncodingManager();
+    protected void postProcessing() {
+        initLocationIndex();
         if (chEnabled)
-            initCHPrepare();
+            algoFactory = createPrepare();
+        else
+            algoFactory = new RoutingAlgorithmFactorySimple();
 
         if (!isPrepared())
             prepare();
-        initLocationIndex();
     }
 
-    private boolean isPrepared()
-    {
+    private boolean isPrepared() {
         return "true".equals(graph.getProperties().get("prepare.done"));
     }
 
-    protected void initCHPrepare()
-    {
-        FlagEncoder encoder = encodingManager.getSingle();
-        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(encoder,
-                createWeighting(new WeightingMap(chWeighting), encoder), traversalMode);
-        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
-        .setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
+    protected RoutingAlgorithmFactory createPrepare() {
+        // <<<<<<< HEAD
+        // FlagEncoder encoder = encodingManager.getSingle();
+        // PrepareContractionHierarchies tmpPrepareCH = new
+        // PrepareContractionHierarchies(encoder,
+        // createWeighting(new WeightingMap(chWeighting), encoder),
+        // traversalMode);
+        // tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates)
+        // .setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
+        // =======
+        if (!encodingManager.supports(getDefaultVehicle())) {
+            throw new IllegalStateException("Should not happen: default vehicle " + getDefaultVehicle() + " not supported" + " from EncodingManager " + encodingManager.toDetailsString() + ". Cannot do CH preparation");
+        }
+
+        FlagEncoder defaultVehicle = encodingManager.getEncoder(getDefaultVehicle());
+        Weighting weighting = createWeighting(new WeightingMap(chWeightingStr), defaultVehicle);
+        PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies((LevelGraph) graph, defaultVehicle, weighting, traversalMode);
+        tmpPrepareCH.setPeriodicUpdates(periodicUpdates).setLazyUpdates(lazyUpdates).setNeighborUpdates(neighborUpdates).setLogMessages(logMessages);
+        // >>>>>>> upstream/master
 
-        prepare = tmpPrepareCH;
-        prepare.setGraph(graph);
+        return tmpPrepareCH;
     }
 
     /**
-     * Based on the weightingParameters and the specified vehicle a Weighting instance can be
-     * created. Note that all URL parameters are available in the weightingParameters as String if
-     * you use the GraphHopper Web module.
+     * Based on the weightingParameters and the specified vehicle a Weighting
+     * instance can be created. Note that all URL parameters are available in
+     * the weightingParameters as String if you use the GraphHopper Web module.
      * <p>
      *
      * @see Weighting.Params.create
      * @param wMap
-     *            all parameters influencing the weighting. E.g. URL parameters coming via GHRequest
+     *            all parameters influencing the weighting. E.g. URL parameters
+     *            coming via GHRequest
      * @param encoder
      *            the required vehicle
      * @return the weighting to be used for route calculation
      */
-    public Weighting createWeighting(WeightingMap wMap, FlagEncoder encoder)
-    {
+    public Weighting createWeighting(WeightingMap wMap, FlagEncoder encoder) {
         String weighting = wMap.getWeighting();
         Weighting result;
 
         if ("shortest".equalsIgnoreCase(weighting))
             result = new ShortestWeighting();
-        else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty())
-        {
+        else if ("fastest".equalsIgnoreCase(weighting) || weighting.isEmpty()) {
             if (encoder.supports(PriorityWeighting.class))
                 result = new PriorityWeighting(encoder);
             else
                 result = new FastestWeighting(encoder);
         } else
             throw new UnsupportedOperationException("weighting " + weighting + " not supported");
-
-        if (encoder.supports(TurnWeighting.class))
-            result = new TurnWeighting(result, encoder,
-                    (TurnCostStorage) graph.getExtendedStorage());
         return result;
     }
 
-    @Override
-    public GHResponse route(GHRequest request)
-    {
-        if (graph == null || !fullyLoaded)
-            throw new IllegalStateException("Call load or importOrLoad before routing");
-
-        if (graph.isClosed())
-            throw new IllegalStateException(
-                    "You need to create a new GraphHopper instance as it is already closed");
+    /**
+     * Potentially wraps the specified weighting into a TurnWeighting instance.
+     */
+    public Weighting createTurnWeighting(Weighting weighting, Graph graph, FlagEncoder encoder) {
+        if (encoder.supports(TurnWeighting.class)) {
+            // <<<<<<< HEAD
+            // result = new TurnWeighting(result, encoder,
+            // (TurnCostStorage) graph.getExtendedStorage());
+            // return result;
+            // =======
+            return new TurnWeighting(weighting, encoder, (TurnCostExtension) graph.getExtension());
+        }
+        return weighting;
+        // >>>>>>> upstream/master
+    }
 
+    @Override
+    public GHResponse route(GHRequest request) {
+        // <<<<<<< HEAD
+        // if (graph == null || !fullyLoaded)
+        // throw new
+        // IllegalStateException("Call load or importOrLoad before routing");
+        //
+        // if (graph.isClosed())
+        // throw new IllegalStateException(
+        // "You need to create a new GraphHopper instance as it is already closed");
+        //
+        // =======
+        // >>>>>>> upstream/master
         GHResponse response = new GHResponse();
         List<Path> paths = getPaths(request, response);
         if (response.hasErrors())
             return response;
 
-        enableInstructions = request.getHints().getBool("instructions", enableInstructions);
-        calcPoints = request.getHints().getBool("calcPoints", calcPoints);
+        boolean tmpEnableInstructions = request.getHints().getBool("instructions", enableInstructions);
+        boolean tmpCalcPoints = request.getHints().getBool("calcPoints", calcPoints);
         double wayPointMaxDistance = request.getHints().getDouble("wayPointMaxDistance", 1d);
         Locale locale = request.getLocale();
         DouglasPeucker peucker = new DouglasPeucker().setMaxDistance(wayPointMaxDistance);
 
-        new PathMerger().setCalcPoints(calcPoints).setDouglasPeucker(peucker)
-        .setEnableInstructions(enableInstructions)
-        .setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
-        .doWork(response, paths, trMap.getWithFallBack(locale));
+        // <<<<<<< HEAD
+        // new PathMerger().setCalcPoints(calcPoints).setDouglasPeucker(peucker)
+        // .setEnableInstructions(enableInstructions)
+        // .setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0)
+        // .doWork(response, paths, trMap.getWithFallBack(locale));
+        // =======
+        new PathMerger().setCalcPoints(tmpCalcPoints).setDouglasPeucker(peucker).setEnableInstructions(tmpEnableInstructions).setSimplifyResponse(simplifyResponse && wayPointMaxDistance > 0).doWork(response, paths, trMap.getWithFallBack(locale));
+        // >>>>>>> upstream/master
         return response;
     }
 
-    protected List<Path> getPaths(GHRequest request, GHResponse rsp)
-    {
+    protected List<Path> getPaths(GHRequest request, GHResponse rsp) {
+        if (graph == null || !fullyLoaded)
+            throw new IllegalStateException("Call load or importOrLoad before routing");
+
+        if (graph.isClosed())
+            throw new IllegalStateException("You need to create a new GraphHopper instance as it is already closed");
+
         String vehicle = request.getVehicle();
         if (vehicle.isEmpty())
-            vehicle = encodingManager.getSingle().toString();
+            vehicle = getDefaultVehicle();
 
-        if (!encodingManager.supports(vehicle))
-        {
-            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
-                    + "Supported are: " + getEncodingManager()));
+        if (!encodingManager.supports(vehicle)) {
+            rsp.addError(new IllegalArgumentException("Vehicle " + vehicle + " unsupported. " + "Supported are: " + getEncodingManager()));
             return Collections.emptyList();
         }
 
         TraversalMode tMode;
         String tModeStr = request.getHints().get("traversal_mode", traversalMode.toString());
-        try
-        {
+        try {
             tMode = TraversalMode.fromString(tModeStr);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             rsp.addError(ex);
             return Collections.emptyList();
         }
 
         List<GHPoint> points = request.getPoints();
-        if (points.size() < 2)
-        {
-            rsp.addError(new IllegalStateException(
-                    "At least 2 points has to be specified, but was:" + points.size()));
+        if (points.size() < 2) {
+            rsp.addError(new IllegalStateException("At least 2 points has to be specified, but was:" + points.size()));
             return Collections.emptyList();
         }
 
+        visitedSum.set(0);
+
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
         EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-        GHPoint startPoint = points.get(0);
+
         StopWatch sw = new StopWatch().start();
-        QueryResult fromRes = locationIndex.findClosest(startPoint.lat, startPoint.lon, edgeFilter);
-        String debug = "idLookup[0]:" + sw.stop().getSeconds() + "s";
-        sw.stop();
-        if (!fromRes.isValid())
-        {
-            rsp.addError(new IllegalArgumentException("Cannot find point 0: " + startPoint));
+        List<QueryResult> qResults = new ArrayList<QueryResult>(points.size());
+        for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
+            GHPoint point = points.get(placeIndex);
+            QueryResult res = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+            if (!res.isValid())
+                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": " + point));
+
+            qResults.add(res);
+        }
+
+        if (rsp.hasErrors())
             return Collections.emptyList();
+
+        String debug = "idLookup:" + sw.stop().getSeconds() + "s";
+
+        QueryGraph queryGraph;
+        RoutingAlgorithmFactory tmpAlgoFactory = getAlgorithmFactory();
+        if (chEnabled && !vehicle.equals(getDefaultVehicle())) {
+            // fall back to normal traversing
+            tmpAlgoFactory = new RoutingAlgorithmFactorySimple();
+            queryGraph = new QueryGraph(graph.getBaseGraph());
+        } else {
+            queryGraph = new QueryGraph(graph);
         }
 
-        List<Path> paths = new ArrayList<Path>(points.size() - 1);
-        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++)
-        {
-            GHPoint point = points.get(placeIndex);
-            sw = new StopWatch().start();
-            QueryResult toRes = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
-            debug += ", [" + placeIndex + "] idLookup:" + sw.stop().getSeconds() + "s";
-            if (!toRes.isValid())
-            {
-                rsp.addError(new IllegalArgumentException("Cannot find point " + placeIndex + ": "
-                        + point));
-                break;
-            }
+        queryGraph.lookup(qResults);
 
+        List<Path> paths = new ArrayList<Path>(points.size() - 1);
+        QueryResult fromQResult = qResults.get(0);
+        Weighting weighting = createWeighting(request.getHints(), encoder);
+        weighting = createTurnWeighting(weighting, queryGraph, encoder);
+
+        double weightLimit = request.getHints().getDouble("defaultWeightLimit", defaultWeightLimit);
+        String algoStr = request.getAlgorithm().isEmpty() ? AlgorithmOptions.DIJKSTRA_BI : request.getAlgorithm();
+        AlgorithmOptions algoOpts = AlgorithmOptions.start().algorithm(algoStr).traversalMode(tMode).flagEncoder(encoder).weighting(weighting).build();
+
+        for (int placeIndex = 1; placeIndex < points.size(); placeIndex++) {
+            // <<<<<<< HEAD
+            // GHPoint point = points.get(placeIndex);
+            // sw = new StopWatch().start();
+            // QueryResult toRes = locationIndex.findClosest(point.lat,
+            // point.lon, edgeFilter);
+            // debug += ", [" + placeIndex + "] idLookup:" +
+            // sw.stop().getSeconds() + "s";
+            // if (!toRes.isValid())
+            // {
+            // rsp.addError(new IllegalArgumentException("Cannot find point " +
+            // placeIndex + ": "
+            // + point));
+            // break;
+            // }
+            //
+            // sw = new StopWatch().start();
+            // String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi"
+            // : request
+            // .getAlgorithm();
+            // RoutingAlgorithm algo = null;
+            // if (chEnabled)
+            // {
+            // if (prepare == null)
+            // throw new IllegalStateException(
+            // "Preparation object is null. CH-preparation wasn't done or did you "
+            // + "forget to call setCHEnable(false)?");
+            //
+            // if (algoStr.equals("dijkstrabi"))
+            // algo = prepare.createAlgo();
+            // else if (algoStr.equals("astarbi"))
+            // algo = ((PrepareContractionHierarchies) prepare).createAStar();
+            // else
+            // {
+            // rsp.addError(new IllegalStateException(
+            // "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
+            // break;
+            // }
+            // } else
+            // {
+            // Weighting weighting = createWeighting(request.getHints(),
+            // encoder);
+            // prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph,
+            // algoStr, encoder,
+            // weighting, tMode);
+            // algo = prepare.createAlgo();
+            // }
+            //
+            // =======
+            QueryResult toQResult = qResults.get(placeIndex);
             sw = new StopWatch().start();
-            String algoStr = request.getAlgorithm().isEmpty() ? "dijkstrabi" : request
-                    .getAlgorithm();
-            RoutingAlgorithm algo = null;
-            if (chEnabled)
-            {
-                if (prepare == null)
-                    throw new IllegalStateException(
-                            "Preparation object is null. CH-preparation wasn't done or did you "
-                                    + "forget to call setCHEnable(false)?");
-
-                if (algoStr.equals("dijkstrabi"))
-                    algo = prepare.createAlgo();
-                else if (algoStr.equals("astarbi"))
-                    algo = ((PrepareContractionHierarchies) prepare).createAStar();
-                else
-                {
-                    rsp.addError(new IllegalStateException(
-                            "Only dijkstrabi and astarbi is supported for LevelGraph (using contraction hierarchies)!"));
-                    break;
-                }
-            } else
-            {
-                Weighting weighting = createWeighting(request.getHints(), encoder);
-                prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, algoStr, encoder,
-                        weighting, tMode);
-                algo = prepare.createAlgo();
-            }
-
+            RoutingAlgorithm algo = tmpAlgoFactory.createAlgo(queryGraph, algoOpts);
+            algo.setWeightLimit(weightLimit);
+            // >>>>>>> upstream/master
             debug += ", algoInit:" + sw.stop().getSeconds() + "s";
-            sw = new StopWatch().start();
 
-            Path path = algo.calcPath(fromRes, toRes);
+            sw = new StopWatch().start();
+            Path path = algo.calcPath(fromQResult.getClosestNode(), toQResult.getClosestNode());
             if (path.getMillis() < 0)
-                throw new RuntimeException("Time was negative. Please report as bug and include:"
-                        + request);
+                throw new RuntimeException("Time was negative. Please report as bug and include:" + request);
 
             paths.add(path);
-            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, "
-                    + path.getDebugInfo();
+            // <<<<<<< HEAD
+            // debug += ", " + algo.getName() + "-routing:" +
+            // sw.stop().getSeconds() + "s, "
+            // + path.getDebugInfo();
+            // =======
+            debug += ", " + algo.getName() + "-routing:" + sw.stop().getSeconds() + "s, " + path.getDebugInfo();
+
+            // >>>>>>> upstream/master
             visitedSum.addAndGet(algo.getVisitedNodes());
-            fromRes = toRes;
+            fromQResult = toQResult;
         }
 
         if (rsp.hasErrors())
             return Collections.emptyList();
 
         if (points.size() - 1 != paths.size())
-            throw new RuntimeException(
-                    "There should be exactly one more places than paths. places:"
-                            + points.size() + ", paths:" + paths.size());
+            throw new RuntimeException("There should be exactly one more places than paths. places:" + points.size() + ", paths:" + paths.size());
 
         rsp.setDebugInfo(debug);
         return paths;
     }
 
-    protected LocationIndex createLocationIndex(Directory dir)
-    {
-        LocationIndex tmpIndex;
-        if (graph instanceof LevelGraph)
-            tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-        else
-            tmpIndex = new LocationIndexTree(graph, dir);
+    protected LocationIndex createLocationIndex(Directory dir) {
+        // <<<<<<< HEAD
+        // LocationIndex tmpIndex;
+        // if (graph instanceof LevelGraph)
+        // tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
+        // else
+        // tmpIndex = new LocationIndexTree(graph, dir);
+        // =======
+        LocationIndexTree tmpIndex = new LocationIndexTree(graph.getBaseGraph(), dir);
+        // >>>>>>> upstream/master
         tmpIndex.setResolution(preciseIndexResolution);
-        ((LocationIndexTree) tmpIndex).setMaxRegionSearch(maxRegionSearch);
-
-        if (!tmpIndex.loadExisting())
-        {
+        tmpIndex.setMaxRegionSearch(maxRegionSearch);
+        if (!tmpIndex.loadExisting()) {
             ensureWriteAccess();
             tmpIndex.prepareIndex();
         }
@@ -1027,21 +1129,16 @@ protected LocationIndex createLocationIndex(Directory dir)
     }
 
     /**
-     * Initializes the location index. Currently this has to be done after the ch-preparation!
-     * Because - to improve performance - certain edges won't be available in a ch-graph and the
-     * index needs to know this and selects the correct nodes which still see the correct neighbors.
-     * See #116
+     * Initializes the location index after the import is done.
      */
-    protected void initLocationIndex()
-    {
+    protected void initLocationIndex() {
         if (locationIndex != null)
             throw new IllegalStateException("Cannot initialize locationIndex twice!");
 
         locationIndex = createLocationIndex(graph.getDirectory());
     }
 
-    protected void optimize()
-    {
+    protected void optimize() {
         logger.info("optimizing ... (" + Helper.getMemInfo() + ")");
         graph.optimize();
         logger.info("finished optimize (" + Helper.getMemInfo() + ")");
@@ -1049,11 +1146,9 @@ protected void optimize()
         // Later: move this into the GraphStorage.optimize method
         // Or: Doing it after preparation to optimize shortcuts too. But not
         // possible yet #12
-        if (sortGraph)
-        {
+        if (sortGraph) {
             if (graph instanceof LevelGraph && isPrepared())
-                throw new IllegalArgumentException(
-                        "Sorting prepared LevelGraph is not possible yet. See #12");
+                throw new IllegalArgumentException("Sorting prepared LevelGraph is not possible yet. See #12");
 
             GraphStorage newGraph = GHUtility.newStorage(graph);
             GHUtility.sortDFS(graph, newGraph);
@@ -1062,82 +1157,85 @@ protected void optimize()
         }
     }
 
-    protected void prepare()
-    {
-        boolean tmpPrepare = doPrepare && prepare != null;
-        if (tmpPrepare)
-        {
+    protected void prepare() {
+        boolean tmpPrepare = doPrepare && algoFactory instanceof PrepareContractionHierarchies;
+        if (tmpPrepare) {
             ensureWriteAccess();
-            if (prepare instanceof PrepareContractionHierarchies
-                    && encodingManager.getVehicleCount() > 1)
-                throw new IllegalArgumentException("Contraction hierarchies preparation "
-                        + "requires (at the moment) only one vehicle. But was:"
-                        + encodingManager);
-
-            logger.info("calling prepare.doWork for " + encodingManager.toString() + " ... ("
-                    + Helper.getMemInfo() + ")");
-            prepare.doWork();
+            // <<<<<<< HEAD
+            // if (prepare instanceof PrepareContractionHierarchies
+            // && encodingManager.getVehicleCount() > 1)
+            // throw new
+            // IllegalArgumentException("Contraction hierarchies preparation "
+            // + "requires (at the moment) only one vehicle. But was:"
+            // + encodingManager);
+            //
+            // logger.info("calling prepare.doWork for " +
+            // encodingManager.toString() + " ... ("
+            // + Helper.getMemInfo() + ")");
+            // prepare.doWork();
+            // =======
+            logger.info("calling prepare.doWork for " + getDefaultVehicle() + " ... (" + Helper.getMemInfo() + ")");
+            ((PrepareContractionHierarchies) algoFactory).doWork();
+            // >>>>>>> upstream/master
             graph.getProperties().put("prepare.date", formatDateTime(new Date()));
         }
         graph.getProperties().put("prepare.done", tmpPrepare);
     }
 
-    protected void cleanUp()
-    {
+    protected void cleanUp() {
         int prev = graph.getNodes();
-        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph,
-                encodingManager);
+        PrepareRoutingSubnetworks preparation = new PrepareRoutingSubnetworks(graph, encodingManager);
         preparation.setMinNetworkSize(minNetworkSize);
-        preparation.setMinOnewayNetworkSize(this.minOnewayNetworkSize);
+        preparation.setMinOneWayNetworkSize(minOneWayNetworkSize);
         logger.info("start finding subnetworks, " + Helper.getMemInfo());
         preparation.doWork();
         int n = graph.getNodes();
         // calculate remaining subnetworks
         int remainingSubnetworks = preparation.findSubnetworks().size();
-        logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " + n + ", there were "
-                + preparation.getSubNetworks() + " subnetworks. removed them => "
-                + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
-    }
-
-    protected void flush()
-    {
-        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString()
-                + ", " + Helper.getMemInfo() + ")");
+        // <<<<<<< HEAD
+        // logger.info("edges: " + graph.getAllEdges().getMaxId() + ", nodes " +
+        // n + ", there were "
+        // + preparation.getSubNetworks() + " subnetworks. removed them => "
+        // + (prev - n) + " less nodes. Remaining subnetworks:" +
+        // remainingSubnetworks);
+        // =======
+        logger.info("edges: " + graph.getAllEdges().getCount() + ", nodes " + n + ", there were " + preparation.getSubNetworks() + " subnetworks. removed them => " + (prev - n) + " less nodes. Remaining subnetworks:" + remainingSubnetworks);
+        // >>>>>>> upstream/master
+    }
+
+    protected void flush() {
+        logger.info("flushing graph " + graph.toString() + ", details:" + graph.toDetailsString() + ", " + Helper.getMemInfo() + ")");
         graph.flush();
         fullyLoaded = true;
     }
 
     /**
-     * Releases all associated resources like memory or files. But it does not remove them. To
-     * remove the files created in graphhopperLocation you have to call clean().
+     * Releases all associated resources like memory or files. But it does not
+     * remove them. To remove the files created in graphhopperLocation you have
+     * to call clean().
      */
-    public void close()
-    {
+    public void close() {
         if (graph != null)
             graph.close();
 
         if (locationIndex != null)
             locationIndex.close();
 
-        try
-        {
+        try {
             lockFactory.forceRemove(fileLockName, true);
-        } catch (Exception ex)
-        {
+        } catch (Exception ex) {
             // silently fail e.g. on Windows where we cannot remove an
             // unreleased native lock
         }
     }
 
     /**
-     * Removes the on-disc routing files. Call only after calling close or before importOrLoad or
-     * load
+     * Removes the on-disc routing files. Call only after calling close or
+     * before importOrLoad or load
      */
-    public void clean()
-    {
+    public void clean() {
         if (getGraphHopperLocation().isEmpty())
-            throw new IllegalStateException(
-                    "Cannot clean GraphHopper without specified graphHopperLocation");
+            throw new IllegalStateException("Cannot clean GraphHopper without specified graphHopperLocation");
 
         File folder = new File(getGraphHopperLocation());
         Helper.removeDir(folder);
@@ -1145,42 +1243,51 @@ public void clean()
 
     // make sure this is identical to buildDate used in pom.xml
     // <maven.build.timestamp.format>yyyy-MM-dd'T'HH:mm:ssZ</maven.build.timestamp.format>
-    private String formatDateTime(Date date)
-    {
+    private String formatDateTime(Date date) {
         return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(date);
     }
 
-    protected void ensureNotLoaded()
-    {
+    protected void ensureNotLoaded() {
         if (fullyLoaded)
-            throw new IllegalStateException(
-                    "No configuration changes are possible after loading the graph");
+            throw new IllegalStateException("No configuration changes are possible after loading the graph");
     }
 
-    protected void ensureWriteAccess()
-    {
+    protected void ensureWriteAccess() {
         if (!allowWrites)
             throw new IllegalStateException("Writes are not allowed!");
     }
 
     /**
-     * Returns the current sum of the visited nodes while routing. Mainly for statistic and
-     * debugging purposes.
+     * Returns the current sum of the visited nodes while routing. Mainly for
+     * statistic and debugging purposes.
      */
-    public long getVisitedSum()
-    {
+    public long getVisitedSum() {
         return visitedSum.get();
     }
+
+    // <<<<<<< HEAD
     public GraphHopper setAsOSMReader() {
         dataReader = "OSM";
         return this;
     }
+
     public GraphHopper setAsItnReader() {
         dataReader = "OSITN";
         return this;
     }
+
     public GraphHopper setAsDpnReader() {
         dataReader = "OSDPN";
         return this;
+        // =======
+    }
+
+    private void initDefaultVehicleIfNecessary() {
+        if (defaultVehicleStr == null)
+            setDefaultVehicle(getFirstVehicle().toString());
+
+        if (!encodingManager.supports(getDefaultVehicle()))
+            throw new IllegalArgumentException("Default vehicle " + defaultVehicleStr + " is not supported. " + "Include vehicle in EncodingManager or via the property graph.flagEncoders OR set it explicitely via setDefaultVehicle");
+        // >>>>>>> upstream/master
     }
 }
diff --git a/core/src/main/java/com/graphhopper/GraphHopperAPI.java b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
index 5f81b8344f..9f76e601b5 100644
--- a/core/src/main/java/com/graphhopper/GraphHopperAPI.java
+++ b/core/src/main/java/com/graphhopper/GraphHopperAPI.java
@@ -20,27 +20,6 @@
 /**
  * Wrapper of the graphhopper online or offline API. Provides read only access.
  * <p/>
- * Usage:
- * <pre>
- *
- * // init offline graph
- * GraphHopperAPI gh = new GraphHopper().setInMemory(true);
- * gh.load("graph-hopper-folder");
- *
- * // init online service
- * GraphHopperAPI gh = new GraphHopperWeb();
- * gh.load("http://your-graphhopper-service.com");
- *
- * gh.algorithm("astar");
- * GHResponse ph = gh.route(new GHRequest(new GHPoint(fromLat, fromLon), new GHPoint(toLat, toLon)));
- * print(ph.distance() + " " + ph.time());
- * PointList points = response.getPoints();
- * for(int i = 0; i &lt; points.size(); i++) {
- *    add(point.latitude(i), point.longitude(i));
- * }
- *
- * </pre>
- * <p/>
  * @author Peter Karich
  */
 public interface GraphHopperAPI
diff --git a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
index 3b6e167958..06f694cbae 100644
--- a/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
+++ b/core/src/main/java/com/graphhopper/geohash/LinearKeyAlgo.java
@@ -61,7 +61,7 @@ public LinearKeyAlgo setBounds( double minLonInit, double maxLonInit, double min
 
     public LinearKeyAlgo setBounds( BBox bounds )
     {
-        setBounds(bounds.minLon, bounds.maxLat, bounds.minLat, bounds.maxLat);
+        setBounds(bounds.minLon, bounds.maxLon, bounds.minLat, bounds.maxLat);
         return this;
     }
 
@@ -115,4 +115,5 @@ public double getLonDelta()
     {
         return lonDelta;
     }
+
 }
diff --git a/core/src/main/java/com/graphhopper/reader/ITurnCostTableEntry.java b/core/src/main/java/com/graphhopper/reader/ITurnCostTableEntry.java
index 2c0e78973c..684e207392 100644
--- a/core/src/main/java/com/graphhopper/reader/ITurnCostTableEntry.java
+++ b/core/src/main/java/com/graphhopper/reader/ITurnCostTableEntry.java
@@ -1,10 +1,12 @@
 package com.graphhopper.reader;
 
 public interface ITurnCostTableEntry {
-	long getItemId();
-	int getEdgeFrom();
-	int getEdgeTo();
-	int getVia();
-	long getFlags();
-	void setFlags(long flags);
+    long getItemId();
+    int getEdgeFrom();
+    int getEdgeTo();
+    void setEdgeFrom(int from);
+    void setEdgeTo(int to);
+    int getVia();
+    long getFlags();
+    void setFlags(long flags);
 }
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index 475f496b83..f2b815ab6b 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,8 +22,10 @@
 import gnu.trove.list.array.TLongArrayList;
 import gnu.trove.map.TIntLongMap;
 import gnu.trove.map.TLongLongMap;
+import gnu.trove.map.TLongObjectMap;
 import gnu.trove.map.hash.TIntLongHashMap;
 import gnu.trove.map.hash.TLongLongHashMap;
+import gnu.trove.map.hash.TLongObjectHashMap;
 import gnu.trove.set.TLongSet;
 import gnu.trove.set.hash.TLongHashSet;
 
@@ -31,7 +33,10 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import javax.xml.stream.XMLStreamException;
 
@@ -41,15 +46,18 @@
 import com.graphhopper.coll.GHLongIntBTree;
 import com.graphhopper.coll.LongIntMap;
 import com.graphhopper.reader.dem.ElevationProvider;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.ExtendedStorage;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TurnWeighting;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalc3D;
-import com.graphhopper.util.DistanceCalcEarth;
 import com.graphhopper.util.DouglasPeucker;
+import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
@@ -76,7 +84,7 @@
  * 2.b) Reads ways OSM file and creates edges while calculating the speed etc from the OSM tags.
  * When creating an edge the pillar node information from the intermediate datastructure will be
  * stored in the way geometry of that edge.
- * <p/> 
+ * <p/>
  * @author Peter Karich
  */
 public class OSMReader implements DataReader<Long>
@@ -111,8 +119,8 @@
     private TIntLongMap edgeIdToOsmWayIdMap;
     private final TLongList barrierNodeIds = new TLongArrayList();
     protected PillarInfo pillarInfo;
-    private final DistanceCalc distCalc = new DistanceCalcEarth();
-    private final DistanceCalc3D distCalc3D = new DistanceCalc3D();
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private final DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private final DouglasPeucker simplifyAlgo = new DouglasPeucker();
     private boolean doSimplify = true;
     private int nextTowerId = 0;
@@ -122,41 +130,43 @@
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
     private boolean exitOnlyPillarNodeException = true;
     private File osmFile;
+    private Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
 
     public OSMReader(GraphStorage storage)
     {
-	this.graphStorage = storage;
-	this.nodeAccess = graphStorage.getNodeAccess();
+        this.graphStorage = storage;
+        this.nodeAccess = graphStorage.getNodeAccess();
 
-	osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
-	osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
-	osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
-	pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+        osmNodeIdToInternalNodeMap = new GHLongIntBTree(200);
+        osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
+        osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
+        pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
     }
 
     @Override
     public void readGraph() throws IOException
     {
-	if (encodingManager == null)
-	    throw new IllegalStateException("Encoding manager was not set.");
+        if (encodingManager == null)
+            throw new IllegalStateException("Encoding manager was not set.");
 
-	if (osmFile == null)
-	    throw new IllegalStateException("No OSM file specified");
+        if (osmFile == null)
+            throw new IllegalStateException("No OSM file specified");
 
-	if (!osmFile.exists())
-	    throw new IllegalStateException("Your specified OSM file does not exist:"
-			    + osmFile.getAbsolutePath());
+        if (!osmFile.exists())
+            throw new IllegalStateException("Your specified OSM file does not exist:"
+                    + osmFile.getAbsolutePath());
 
-	StopWatch sw1 = new StopWatch().start();
-	preProcess(osmFile);
-	sw1.stop();
+        StopWatch sw1 = new StopWatch().start();
+        preProcess(osmFile);
+        sw1.stop();
 
-	StopWatch sw2 = new StopWatch().start();
-	writeOsm2Graph(osmFile);
-	sw2.stop();
+        StopWatch sw2 = new StopWatch().start();
+        writeOsm2Graph(osmFile);
+        sw2.stop();
 
-	logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds()
-			+ " total:" + (int) (sw1.getSeconds() + sw2.getSeconds()));
+        logger.info("time(pass1): " + (int) sw1.getSeconds() + " pass2: " + (int) sw2.getSeconds()
+                + " total:" + (int) (sw1.getSeconds() + sw2.getSeconds()));
     }
 
     /**
@@ -165,71 +175,71 @@ public void readGraph() throws IOException
      */
     void preProcess(File osmFile)
     {
-	OSMInputFile in = null;
-	try
-	{
-	    in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
-
-	    long tmpWayCounter = 1;
-	    long tmpRelationCounter = 1;
-	    RoutingElement item;
-	    while ((item = in.getNext()) != null)
-	    {
-		if (item.isType(OSMElement.WAY))
-		{
-		    final OSMWay way = (OSMWay) item;
-		    boolean valid = filterWay(way);
-		    if (valid)
-		    {
-			TLongList wayNodes = way.getNodes();
-			int s = wayNodes.size();
-			for (int index = 0; index < s; index++)
-			{
-			    prepareHighwayNode(wayNodes.get(index));
-			}
-
-			if (++tmpWayCounter % 5000000 == 0)
-			{
-			    logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:"
-					    + nf(getNodeMap().getSize()) + " ("
-					    + getNodeMap().getMemoryUsage() + "MB) "
-					    + Helper.getMemInfo());
-			}
-		    }
-		}
-		if (item.isType(OSMElement.RELATION))
-		{
-		    final OSMRelation relation = (OSMRelation) item;
-		    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
-			prepareWaysWithRelationInfo(relation);
-
-		    if (relation.hasTag("type", "restriction"))
-			prepareRestrictionRelation(relation);
-
-		    if (++tmpRelationCounter % 50000 == 0)
-		    {
-			logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:"
-					+ nf(getRelFlagsMap().size()) + " " + Helper.getMemInfo());
-		    }
-		}
-	    }
-	} catch (Exception ex)
-	{
-	    throw new RuntimeException("Problem while parsing file", ex);
-	} finally
-	{
-	    Helper.close(in);
-	}
+        OSMInputFile in = null;
+        try
+        {
+            in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
+
+            long tmpWayCounter = 1;
+            long tmpRelationCounter = 1;
+            RoutingElement item;
+            while ((item = in.getNext()) != null)
+            {
+                if (item.isType(OSMElement.WAY))
+                {
+                    final OSMWay way = (OSMWay) item;
+                    boolean valid = filterWay(way);
+                    if (valid)
+                    {
+                        TLongList wayNodes = way.getNodes();
+                        int s = wayNodes.size();
+                        for (int index = 0; index < s; index++)
+                        {
+                            prepareHighwayNode(wayNodes.get(index));
+                        }
+
+                        if (++tmpWayCounter % 5000000 == 0)
+                        {
+                            logger.info(nf(tmpWayCounter) + " (preprocess), osmIdMap:"
+                                    + nf(getNodeMap().getSize()) + " ("
+                                    + getNodeMap().getMemoryUsage() + "MB) "
+                                    + Helper.getMemInfo());
+                        }
+                    }
+                }
+                if (item.isType(OSMElement.RELATION))
+                {
+                    final OSMRelation relation = (OSMRelation) item;
+                    if (!relation.isMetaRelation() && relation.hasTag("type", "route"))
+                        prepareWaysWithRelationInfo(relation);
+
+                    if (relation.hasTag("type", "restriction"))
+                        prepareRestrictionRelation(relation);
+
+                    if (++tmpRelationCounter % 50000 == 0)
+                    {
+                        logger.info(nf(tmpRelationCounter) + " (preprocess), osmWayMap:"
+                                + nf(getRelFlagsMap().size()) + " " + Helper.getMemInfo());
+                    }
+                }
+            }
+        } catch (Exception ex)
+        {
+            throw new RuntimeException("Problem while parsing file", ex);
+        } finally
+        {
+            Helper.close(in);
+        }
     }
 
     private void prepareRestrictionRelation(OSMRelation relation)
     {
-	TurnRelation turnRelation = createTurnRelation(relation);
-	if (turnRelation != null)
-	{
-	    getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
-	    getOsmWayIdSet().add(turnRelation.getOsmIdTo());
-	}
+        TurnRelation turnRelation = createTurnRelation(relation);
+        if (turnRelation != null)
+        {
+            getOsmWayIdSet().add(turnRelation.getOsmIdFrom());
+            getOsmWayIdSet().add(turnRelation.getOsmIdTo());
+        }
     }
 
     /**
@@ -237,15 +247,15 @@ private void prepareRestrictionRelation(OSMRelation relation)
      */
     private TLongSet getOsmWayIdSet()
     {
-	return osmWayIdSet;
+        return osmWayIdSet;
     }
 
     private TIntLongMap getEdgeIdToOsmWayIdMap()
     {
-	if (edgeIdToOsmWayIdMap == null)
-	    edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
+        if (edgeIdToOsmWayIdMap == null)
+            edgeIdToOsmWayIdMap = new TIntLongHashMap(getOsmWayIdSet().size(), 0.5f, -1, -1);
 
-	return edgeIdToOsmWayIdMap;
+        return edgeIdToOsmWayIdMap;
     }
 
     /**
@@ -256,15 +266,15 @@ private TIntLongMap getEdgeIdToOsmWayIdMap()
      */
     boolean filterWay(OSMWay item)
     {
-	// ignore broken geometry
-	if (item.getNodes().size() < 2)
-	    return false;
+        // ignore broken geometry
+        if (item.getNodes().size() < 2)
+            return false;
 
-	// ignore multipolygon geometry
-	if (!item.hasTags())
-	    return false;
+        // ignore multipolygon geometry
+        if (!item.hasTags())
+            return false;
 
-	return encodingManager.acceptWay(item) > 0;
+        return encodingManager.acceptWay(item) > 0;
     }
 
     /**
@@ -272,72 +282,72 @@ boolean filterWay(OSMWay item)
      */
     private void writeOsm2Graph(File osmFile)
     {
-	int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
-
-	logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize())
-			+ ", " + Helper.getMemInfo());
-	graphStorage.create(tmp);
-	long wayStart = -1;
-	long relationStart = -1;
-	long counter = 1;
-	OSMInputFile in = null;
-	try
-	{
-	    in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
-	    LongIntMap nodeFilter = getNodeMap();
-
-	    RoutingElement item;
-	    while ((item = in.getNext()) != null)
-	    {
-		switch (item.getType())
-		{
-		case OSMElement.NODE:
-		    OSMNode node = (OSMNode) item;
-		    if (nodeFilter.get(node.getId()) != -1)
-		    {
-			processNode((OSMNode) item);
-		    }
-		    break;
-
-		case OSMElement.WAY:
-		    if (wayStart < 0)
-		    {
-			logger.info(nf(counter) + ", now parsing ways");
-			wayStart = counter;
-		    }
-		    processWay((OSMWay) item);
-		    break;
-		case OSMElement.RELATION:
-		    if (relationStart < 0)
-		    {
-			logger.info(nf(counter) + ", now parsing relations");
-			relationStart = counter;
-		    }
-		    processRelation((OSMRelation) item);
-		    break;
-		}
-		if (++counter % 100000000 == 0)
-		{
-		    logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations
-				    + ") " + Helper.getMemInfo());
-		}
-	    }
-
-	    // logger.info("storage nodes:" + storage.nodes() +
-	    // " vs. graph nodes:" + storage.getGraph().nodes());
-	} catch (Exception ex)
-	{
-	    throw new RuntimeException("Couldn't process file " + osmFile + ", error: "
-			    + ex.getMessage(), ex);
-	} finally
-	{
-	    Helper.close(in);
-	}
-
-	finishedReading();
-	if (graphStorage.getNodes() == 0)
-	    throw new IllegalStateException("osm must not be empty. read " + counter
-			    + " lines and " + locations + " locations");
+        int tmp = (int) Math.max(getNodeMap().getSize() / 50, 100);
+
+        logger.info("creating graph. Found nodes (pillar+tower):" + nf(getNodeMap().getSize())
+                + ", " + Helper.getMemInfo());
+        graphStorage.create(tmp);
+        long wayStart = -1;
+        long relationStart = -1;
+        long counter = 1;
+        OSMInputFile in = null;
+        try
+        {
+            in = new OSMInputFile(osmFile).setWorkerThreads(workerThreads).open();
+            LongIntMap nodeFilter = getNodeMap();
+
+            RoutingElement item;
+            while ((item = in.getNext()) != null)
+            {
+                switch (item.getType())
+                {
+                case OSMElement.NODE:
+                    OSMNode node = (OSMNode) item;
+                    if (nodeFilter.get(node.getId()) != -1)
+                    {
+                        processNode((OSMNode) item);
+                    }
+                    break;
+
+                case OSMElement.WAY:
+                    if (wayStart < 0)
+                    {
+                        logger.info(nf(counter) + ", now parsing ways");
+                        wayStart = counter;
+                    }
+                    processWay((OSMWay) item);
+                    break;
+                case OSMElement.RELATION:
+                    if (relationStart < 0)
+                    {
+                        logger.info(nf(counter) + ", now parsing relations");
+                        relationStart = counter;
+                    }
+                    processRelation((OSMRelation) item);
+                    break;
+                }
+                if (++counter % 100000000 == 0)
+                {
+                    logger.info(nf(counter) + ", locs:" + nf(locations) + " (" + skippedLocations
+                            + ") " + Helper.getMemInfo());
+                }
+            }
+
+            // logger.info("storage nodes:" + storage.nodes() +
+            // " vs. graph nodes:" + storage.getGraph().nodes());
+        } catch (Exception ex)
+        {
+            throw new RuntimeException("Couldn't process file " + osmFile + ", error: "
+                    + ex.getMessage(), ex);
+        } finally
+        {
+            Helper.close(in);
+        }
+
+        finishedReading();
+        if (graphStorage.getNodes() == 0)
+            throw new IllegalStateException("osm must not be empty. read " + counter
+                    + " lines and " + locations + " locations");
     }
 
     /**
@@ -345,129 +355,171 @@ private void writeOsm2Graph(File osmFile)
      */
     void processWay(OSMWay way)
     {
-	if (way.getNodes().size() < 2)
-	    return;
-
-	// ignore multipolygon geometry
-	if (!way.hasTags())
-	    return;
-
-	long wayOsmId = way.getId();
-
-	long includeWay = encodingManager.acceptWay(way);
-	if (includeWay == 0)
-	    return;
-
-	long relationFlags = getRelFlagsMap().get(way.getId());
-
-	// TODO move this after we have created the edge and know the
-	// coordinates => encodingManager.applyWayTags
-	// estimate length of the track e.g. for ferry speed calculation
-	TLongList osmNodeIds = way.getNodes();
-	if (osmNodeIds.size() > 1)
-	{
-	    int first = getNodeMap().get(osmNodeIds.get(0));
-	    int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
-	    double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
-	    double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-	    if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat)
-			    && !Double.isNaN(lastLon))
-	    {
-		double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
-		way.setTag("estimated_distance", estimatedDist);
-		way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2,
-				(firstLon + lastLon) / 2));
-	    }
-	}
-
-	long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
-	if (wayFlags == 0)
-	    return;
-
-	List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
-	// look for barriers along the way
-	final int size = osmNodeIds.size();
-	int lastBarrier = -1;
-	for (int i = 0; i < size; i++)
-	{
-	    long nodeId = osmNodeIds.get(i);
-	    long nodeFlags = getNodeFlagsMap().get(nodeId);
-	    // barrier was spotted and way is otherwise passable for that mode
-	    // of travel
-	    if (nodeFlags > 0)
-		if ((nodeFlags & wayFlags) > 0)
-		{
-		    // remove barrier to avoid duplicates
-		    getNodeFlagsMap().put(nodeId, 0);
-
-		    // create shadow node copy for zero length edge
-		    long newNodeId = addBarrierNode(nodeId);
-		    if (i > 0)
-		    {
-			// start at beginning of array if there was no previous
-			// barrier
-			if (lastBarrier < 0)
-			    lastBarrier = 0;
-
-			// add way up to barrier shadow node
-			long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
-			transfer[transfer.length - 1] = newNodeId;
-			TLongList partIds = new TLongArrayList(transfer);
-			createdEdges.addAll(addOSMWay(partIds, wayFlags, wayOsmId));
-
-			// create zero length edge for barrier
-			createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags,
-					wayOsmId));
-		    } else
-		    {
-			// run edge from real first node to shadow node
-			createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags,
-					wayOsmId));
-
-			// exchange first node for created barrier node
-			osmNodeIds.set(0, newNodeId);
-		    }
-		    // remember barrier for processing the way behind it
-		    lastBarrier = i;
-		}
-	}
-
-	// just add remainder of way to graph if barrier was not the last node
-	if (lastBarrier >= 0)
-	{
-	    if (lastBarrier < size - 1)
-	    {
-		long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
-		TLongList partNodeIds = new TLongArrayList(transfer);
-		createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
-	    }
-	} else
-	    // no barriers - simply add the whole way
-	    createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
-
-	for (EdgeIteratorState edge : createdEdges)
-	    encodingManager.applyWayTags(way, edge);
-    }
-
-    public void processRelation(OSMRelation relation) throws XMLStreamException
-    {
-	if (relation.hasTag("type", "restriction"))
-	{
-	    TurnRelation turnRelation = createTurnRelation(relation);
-	    if (turnRelation != null)
-	    {
-		ExtendedStorage extendedStorage = graphStorage.getExtendedStorage();
-		if (extendedStorage instanceof TurnCostStorage)
-		{
-		    TurnCostStorage tcs = (TurnCostStorage) extendedStorage;
-		    Collection<ITurnCostTableEntry> entries = encodingManager.analyzeTurnRelation(
-				    turnRelation, this);
-		    for (ITurnCostTableEntry entry : entries)
-			tcs.addTurnInfo(entry.getVia(), entry.getEdgeFrom(), entry.getEdgeTo(),
-					(int) entry.getFlags());
-		}
-	    }
-	}
+        if (way.getNodes().size() < 2)
+            return;
+
+        // ignore multipolygon geometry
+        if (!way.hasTags())
+            return;
+
+        long wayOsmId = way.getId();
+
+        long includeWay = encodingManager.acceptWay(way);
+        if (includeWay == 0)
+            return;
+
+        long relationFlags = getRelFlagsMap().get(way.getId());
+
+        // TODO move this after we have created the edge and know the
+        // coordinates => encodingManager.applyWayTags
+        // estimate length of the track e.g. for ferry speed calculation
+        TLongList osmNodeIds = way.getNodes();
+        if (osmNodeIds.size() > 1)
+        {
+            int first = getNodeMap().get(osmNodeIds.get(0));
+            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat)
+                    && !Double.isNaN(lastLon))
+            {
+                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+                way.setTag("estimated_distance", estimatedDist);
+                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2,
+                        (firstLon + lastLon) / 2));
+            }
+        }
+
+        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
+        if (wayFlags == 0)
+            return;
+
+        List<EdgeIteratorState> createdEdges = new ArrayList<EdgeIteratorState>();
+        // look for barriers along the way
+        final int size = osmNodeIds.size();
+        int lastBarrier = -1;
+        for (int i = 0; i < size; i++)
+        {
+            long nodeId = osmNodeIds.get(i);
+            long nodeFlags = getNodeFlagsMap().get(nodeId);
+            // barrier was spotted and way is otherwise passable for that mode
+            // of travel
+            if (nodeFlags > 0)
+                if ((nodeFlags & wayFlags) > 0)
+                {
+                    // remove barrier to avoid duplicates
+                    getNodeFlagsMap().put(nodeId, 0);
+
+                    // create shadow node copy for zero length edge
+                    long newNodeId = addBarrierNode(nodeId);
+                    if (i > 0)
+                    {
+                        // start at beginning of array if there was no previous
+                        // barrier
+                        if (lastBarrier < 0)
+                            lastBarrier = 0;
+
+                        // add way up to barrier shadow node
+                        long transfer[] = osmNodeIds.toArray(lastBarrier, i - lastBarrier + 1);
+                        transfer[transfer.length - 1] = newNodeId;
+                        TLongList partIds = new TLongArrayList(transfer);
+                        createdEdges.addAll(addOSMWay(partIds, wayFlags, wayOsmId));
+
+                        // create zero length edge for barrier
+                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags,
+                                wayOsmId));
+                    } else
+                    {
+                        // run edge from real first node to shadow node
+                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags,
+                                wayOsmId));
+
+                        // exchange first node for created barrier node
+                        osmNodeIds.set(0, newNodeId);
+                    }
+                    // remember barrier for processing the way behind it
+                    lastBarrier = i;
+                }
+        }
+
+        // just add remainder of way to graph if barrier was not the last node
+        if (lastBarrier >= 0)
+        {
+            if (lastBarrier < size - 1)
+            {
+                long transfer[] = osmNodeIds.toArray(lastBarrier, size - lastBarrier);
+                TLongList partNodeIds = new TLongArrayList(transfer);
+                createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
+            }
+        } else
+            // no barriers - simply add the whole way
+            createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
+
+        for (EdgeIteratorState edge : createdEdges)
+            encodingManager.applyWayTags(way, edge);
+    }
+
+    public void processRelation( OSMRelation relation ) throws XMLStreamException
+    {
+        if (relation.hasTag("type", "restriction"))
+        {
+            TurnRelation turnRelation = createTurnRelation(relation);
+            if (turnRelation != null)
+            {
+                GraphExtension extendedStorage = graphStorage.getExtension();
+                if (extendedStorage instanceof TurnCostExtension)
+                {
+                    TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
+                    Collection<ITurnCostTableEntry> entries = analyzeTurnRelation(turnRelation);
+                    for (ITurnCostTableEntry entry : entries)
+                    {
+                        tcs.addTurnInfo(entry.getEdgeFrom(), entry.getVia(), entry.getEdgeTo(), entry.getFlags());
+                    }
+                }
+            }
+        }
+    }
+
+    public Collection<ITurnCostTableEntry> analyzeTurnRelation( TurnRelation turnRelation )
+    {
+        TLongObjectMap<ITurnCostTableEntry> entries = new TLongObjectHashMap<>();
+
+        for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders())
+        {
+            for (ITurnCostTableEntry entry : analyzeTurnRelation(encoder, turnRelation))
+            {
+                ITurnCostTableEntry oldEntry = entries.get(entry.getItemId());
+                if (oldEntry != null)
+                {
+                    // merging different encoders
+                    oldEntry.setFlags(oldEntry.getFlags() | entry.getFlags());
+                } else
+                {
+                    entries.put(entry.getItemId(), entry);
+                }
+            }
+        }
+
+        return entries.valueCollection();
+    }
+
+    public Collection<ITurnCostTableEntry> analyzeTurnRelation( FlagEncoder encoder, TurnRelation turnRelation )
+    {
+        if (!encoder.supports(TurnWeighting.class))
+            return Collections.emptyList();
+
+        EdgeExplorer edgeOutExplorer = outExplorerMap.get(encoder);
+        EdgeExplorer edgeInExplorer = inExplorerMap.get(encoder);
+
+        if (edgeOutExplorer == null || edgeInExplorer == null)
+        {
+            edgeOutExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
+            outExplorerMap.put(encoder, edgeOutExplorer);
+
+            edgeInExplorer = getGraphStorage().createEdgeExplorer(new DefaultEdgeFilter(encoder, true, false));
+            inExplorerMap.put(encoder, edgeInExplorer);
+        }
+        return turnRelation.getRestrictionAsEntries(encoder, edgeOutExplorer, edgeInExplorer, this);
     }
 
     /**
@@ -477,158 +529,158 @@ public void processRelation(OSMRelation relation) throws XMLStreamException
     @Override
     public Long getOsmIdOfInternalEdge(int edgeId)
     {
-	return getEdgeIdToOsmWayIdMap().get(edgeId);
+        return getEdgeIdToOsmWayIdMap().get(edgeId);
     }
 
     @Override
     public int getInternalNodeIdOfOsmNode(Long nodeOsmId)
     {
-	int id = getNodeMap().get(nodeOsmId);
-	if (id < TOWER_NODE)
-	    return -id - 3;
+        int id = getNodeMap().get(nodeOsmId);
+        if (id < TOWER_NODE)
+            return -id - 3;
 
-	return EMPTY;
+        return EMPTY;
     }
 
     // TODO remove this ugly stuff via better preparsing phase! E.g. putting
     // every tags etc into a helper file!
     double getTmpLatitude(int id)
     {
-	if (id == EMPTY)
-	    return Double.NaN;
-	if (id < TOWER_NODE)
-	{
-	    // tower node
-	    id = -id - 3;
-	    return nodeAccess.getLatitude(id);
-	} else if (id > -TOWER_NODE)
-	{
-	    // pillar node
-	    id = id - 3;
-	    return pillarInfo.getLatitude(id);
-	} else
-	    // e.g. if id is not handled from preparse (e.g. was ignored via
-	    // isInBounds)
-	    return Double.NaN;
+        if (id == EMPTY)
+            return Double.NaN;
+        if (id < TOWER_NODE)
+        {
+            // tower node
+            id = -id - 3;
+            return nodeAccess.getLatitude(id);
+        } else if (id > -TOWER_NODE)
+        {
+            // pillar node
+            id = id - 3;
+            return pillarInfo.getLatitude(id);
+        } else
+            // e.g. if id is not handled from preparse (e.g. was ignored via
+            // isInBounds)
+            return Double.NaN;
     }
 
     double getTmpLongitude(int id)
     {
-	if (id == EMPTY)
-	    return Double.NaN;
-	if (id < TOWER_NODE)
-	{
-	    // tower node
-	    id = -id - 3;
-	    return nodeAccess.getLongitude(id);
-	} else if (id > -TOWER_NODE)
-	{
-	    // pillar node
-	    id = id - 3;
-	    return pillarInfo.getLon(id);
-	} else
-	    // e.g. if id is not handled from preparse (e.g. was ignored via
-	    // isInBounds)
-	    return Double.NaN;
+        if (id == EMPTY)
+            return Double.NaN;
+        if (id < TOWER_NODE)
+        {
+            // tower node
+            id = -id - 3;
+            return nodeAccess.getLongitude(id);
+        } else if (id > -TOWER_NODE)
+        {
+            // pillar node
+            id = id - 3;
+            return pillarInfo.getLon(id);
+        } else
+            // e.g. if id is not handled from preparse (e.g. was ignored via
+            // isInBounds)
+            return Double.NaN;
     }
 
     private void processNode(OSMNode node)
     {
-	if (isInBounds(node))
-	{
-	    addNode(node);
-
-	    // analyze node tags for barriers
-	    if (node.hasTags())
-	    {
-		long nodeFlags = encodingManager.handleNodeTags(node);
-		if (nodeFlags != 0)
-		    getNodeFlagsMap().put(node.getId(), nodeFlags);
-	    }
-
-	    locations++;
-	} else
-	    skippedLocations++;
+        if (isInBounds(node))
+        {
+            addNode(node);
+
+            // analyze node tags for barriers
+            if (node.hasTags())
+            {
+                long nodeFlags = encodingManager.handleNodeTags(node);
+                if (nodeFlags != 0)
+                    getNodeFlagsMap().put(node.getId(), nodeFlags);
+            }
+
+            locations++;
+        } else
+            skippedLocations++;
     }
 
     boolean addNode(OSMNode node)
     {
-	int nodeType = getNodeMap().get(node.getId());
-	if (nodeType == EMPTY)
-	    return false;
-
-	double lat = node.getLat();
-	double lon = node.getLon();
-	double ele = getElevation(node);
-	if (nodeType == TOWER_NODE)
-	    addTowerNode(node.getId(), lat, lon, ele);
-	else if (nodeType == PILLAR_NODE)
-	{
-	    pillarInfo.setNode(nextPillarId, lat, lon, ele);
-	    getNodeMap().put(node.getId(), nextPillarId + 3);
-	    nextPillarId++;
-	}
-	return true;
+        int nodeType = getNodeMap().get(node.getId());
+        if (nodeType == EMPTY)
+            return false;
+
+        double lat = node.getLat();
+        double lon = node.getLon();
+        double ele = getElevation(node);
+        if (nodeType == TOWER_NODE)
+            addTowerNode(node.getId(), lat, lon, ele);
+        else if (nodeType == PILLAR_NODE)
+        {
+            pillarInfo.setNode(nextPillarId, lat, lon, ele);
+            getNodeMap().put(node.getId(), nextPillarId + 3);
+            nextPillarId++;
+        }
+        return true;
     }
 
     protected double getElevation(OSMNode node)
     {
-	return eleProvider.getEle(node.getLat(), node.getLon());
+        return eleProvider.getEle(node.getLat(), node.getLon());
     }
 
     void prepareWaysWithRelationInfo(OSMRelation osmRelation)
     {
-	// is there at least one tag interesting for the registed encoders?
-	if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
-	    return;
-
-	int size = osmRelation.getMembers().size();
-	for (int index = 0; index < size; index++)
-	{
-	    OSMRelation.Member member = osmRelation.getMembers().get(index);
-	    if (member.type() != OSMRelation.Member.WAY)
-		continue;
-
-	    long osmId = member.ref();
-	    long oldRelationFlags = getRelFlagsMap().get(osmId);
-
-	    // Check if our new relation data is better comparated to the the
-	    // last one
-	    long newRelationFlags = encodingManager.handleRelationTags(osmRelation,
-			    oldRelationFlags);
-	    if (oldRelationFlags != newRelationFlags)
-		getRelFlagsMap().put(osmId, newRelationFlags);
-	}
+        // is there at least one tag interesting for the registed encoders?
+        if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
+            return;
+
+        int size = osmRelation.getMembers().size();
+        for (int index = 0; index < size; index++)
+        {
+            OSMRelation.Member member = osmRelation.getMembers().get(index);
+            if (member.type() != OSMRelation.Member.WAY)
+                continue;
+
+            long osmId = member.ref();
+            long oldRelationFlags = getRelFlagsMap().get(osmId);
+
+            // Check if our new relation data is better comparated to the the
+            // last one
+            long newRelationFlags = encodingManager.handleRelationTags(osmRelation,
+                    oldRelationFlags);
+            if (oldRelationFlags != newRelationFlags)
+                getRelFlagsMap().put(osmId, newRelationFlags);
+        }
     }
 
     void prepareHighwayNode(long osmId)
     {
-	int tmpIndex = getNodeMap().get(osmId);
-	if (tmpIndex == EMPTY)
-	{
-	    // osmId is used exactly once
-	    getNodeMap().put(osmId, PILLAR_NODE);
-	} else if (tmpIndex > EMPTY)
-	{
-	    // mark node as tower node as it occured at least twice times
-	    getNodeMap().put(osmId, TOWER_NODE);
-	} else
-	{
-	    // tmpIndex is already negative (already tower node)
-	}
+        int tmpIndex = getNodeMap().get(osmId);
+        if (tmpIndex == EMPTY)
+        {
+            // osmId is used exactly once
+            getNodeMap().put(osmId, PILLAR_NODE);
+        } else if (tmpIndex > EMPTY)
+        {
+            // mark node as tower node as it occured at least twice times
+            getNodeMap().put(osmId, TOWER_NODE);
+        } else
+        {
+            // tmpIndex is already negative (already tower node)
+        }
     }
 
     int addTowerNode(long osmId, double lat, double lon, double ele)
     {
-	if (nodeAccess.is3D())
-	    nodeAccess.setNode(nextTowerId, lat, lon, ele);
-	else
-	    nodeAccess.setNode(nextTowerId, lat, lon);
-
-	int id = -(nextTowerId + 3);
-	getNodeMap().put(osmId, id);
-	nextTowerId++;
-	return id;
+        if (nodeAccess.is3D())
+            nodeAccess.setNode(nextTowerId, lat, lon, ele);
+        else
+            nodeAccess.setNode(nextTowerId, lat, lon);
+
+        int id = -(nextTowerId + 3);
+        getNodeMap().put(osmId, id);
+        nextTowerId++;
+        return id;
     }
 
     /**
@@ -636,149 +688,149 @@ int addTowerNode(long osmId, double lat, double lon, double ele)
      */
     Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long flags, long wayOsmId)
     {
-	PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
-	List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
-	int firstNode = -1;
-	int lastIndex = osmNodeIds.size() - 1;
-	int lastInBoundsPillarNode = -1;
-	try
-	{
-	    for (int i = 0; i < osmNodeIds.size(); i++)
-	    {
-		long osmId = osmNodeIds.get(i);
-		int tmpNode = getNodeMap().get(osmId);
-		if (tmpNode == EMPTY)
-		    continue;
-
-		// skip osmIds with no associated pillar or tower id (e.g.
-		// !OSMReader.isBounds)
-		if (tmpNode == TOWER_NODE)
-		    continue;
-
-		if (tmpNode == PILLAR_NODE)
-		{
-		    // In some cases no node information is saved for the
-		    // specified osmId.
-		    // ie. a way references a <node> which does not exist in the
-		    // current file.
-		    // => if the node before was a pillar node then convert into
-		    // to tower node (as it is also end-standing).
-		    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
-		    {
-			// transform the pillar node to a tower node
-			tmpNode = lastInBoundsPillarNode;
-			tmpNode = handlePillarNode(tmpNode, osmId, null, true);
-			tmpNode = -tmpNode - 3;
-			if (pointList.getSize() > 1 && firstNode >= 0)
-			{
-			    // TOWER node
-			    newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
-			    pointList.clear();
-			    pointList.add(nodeAccess, tmpNode);
-			}
-			firstNode = tmpNode;
-			lastInBoundsPillarNode = -1;
-		    }
-		    continue;
-		}
-
-		if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
-		    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", "
-				    + osmId);
-
-		if (tmpNode > -TOWER_NODE)
-		{
-		    boolean convertToTowerNode = i == 0 || i == lastIndex;
-		    if (!convertToTowerNode)
-		    {
-			lastInBoundsPillarNode = tmpNode;
-		    }
-		    // PILLAR node, but convert to towerNode if end-standing
-		    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
-		}
-
-		if (tmpNode < TOWER_NODE)
-		{
-		    // TOWER node
-		    tmpNode = -tmpNode - 3;
-		    pointList.add(nodeAccess, tmpNode);
-		    if (firstNode >= 0)
-		    {
-			newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
-			pointList.clear();
-			pointList.add(nodeAccess, tmpNode);
-		    }
-		    firstNode = tmpNode;
-		}
-	    }
-	} catch (RuntimeException ex)
-	{
-	    logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
-	    if (exitOnlyPillarNodeException)
-		throw ex;
-	}
-	return newEdges;
+        PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
+        List<EdgeIteratorState> newEdges = new ArrayList<EdgeIteratorState>(5);
+        int firstNode = -1;
+        int lastIndex = osmNodeIds.size() - 1;
+        int lastInBoundsPillarNode = -1;
+        try
+        {
+            for (int i = 0; i < osmNodeIds.size(); i++)
+            {
+                long osmId = osmNodeIds.get(i);
+                int tmpNode = getNodeMap().get(osmId);
+                if (tmpNode == EMPTY)
+                    continue;
+
+                // skip osmIds with no associated pillar or tower id (e.g.
+                // !OSMReader.isBounds)
+                if (tmpNode == TOWER_NODE)
+                    continue;
+
+                if (tmpNode == PILLAR_NODE)
+                {
+                    // In some cases no node information is saved for the
+                    // specified osmId.
+                    // ie. a way references a <node> which does not exist in the
+                    // current file.
+                    // => if the node before was a pillar node then convert into
+                    // to tower node (as it is also end-standing).
+                    if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE)
+                    {
+                        // transform the pillar node to a tower node
+                        tmpNode = lastInBoundsPillarNode;
+                        tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+                        tmpNode = -tmpNode - 3;
+                        if (pointList.getSize() > 1 && firstNode >= 0)
+                        {
+                            // TOWER node
+                            newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+                            pointList.clear();
+                            pointList.add(nodeAccess, tmpNode);
+                        }
+                        firstNode = tmpNode;
+                        lastInBoundsPillarNode = -1;
+                    }
+                    continue;
+                }
+
+                if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
+                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", "
+                            + osmId);
+
+                if (tmpNode > -TOWER_NODE)
+                {
+                    boolean convertToTowerNode = i == 0 || i == lastIndex;
+                    if (!convertToTowerNode)
+                    {
+                        lastInBoundsPillarNode = tmpNode;
+                    }
+                    // PILLAR node, but convert to towerNode if end-standing
+                    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
+                }
+
+                if (tmpNode < TOWER_NODE)
+                {
+                    // TOWER node
+                    tmpNode = -tmpNode - 3;
+                    pointList.add(nodeAccess, tmpNode);
+                    if (firstNode >= 0)
+                    {
+                        newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
+                        pointList.clear();
+                        pointList.add(nodeAccess, tmpNode);
+                    }
+                    firstNode = tmpNode;
+                }
+            }
+        } catch (RuntimeException ex)
+        {
+            logger.error("Couldn't properly add edge with osm ids:" + osmNodeIds, ex);
+            if (exitOnlyPillarNodeException)
+                throw ex;
+        }
+        return newEdges;
     }
 
     EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags,
-		    long wayOsmId)
-    {
-	// sanity checks
-	if (fromIndex < 0 || toIndex < 0)
-	    throw new AssertionError("to or from index is invalid for this edge " + fromIndex
-			    + "->" + toIndex + ", points:" + pointList);
-	if (pointList.getDimension() != nodeAccess.getDimension())
-	    throw new AssertionError("Dimension does not match for pointList vs. nodeAccess "
-			    + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
-
-	double towerNodeDistance = 0;
-	double prevLat = pointList.getLatitude(0);
-	double prevLon = pointList.getLongitude(0);
-	double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
-	double lat, lon, ele = Double.NaN;
-	PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
-	int nodes = pointList.getSize();
-	for (int i = 1; i < nodes; i++)
-	{
-	    // we could save some lines if we would use
-	    // pointList.calcDistance(distCalc);
-	    lat = pointList.getLatitude(i);
-	    lon = pointList.getLongitude(i);
-	    if (pointList.is3D())
-	    {
-		ele = pointList.getElevation(i);
-		towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
-		prevEle = ele;
-	    } else
-		towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
-	    prevLat = lat;
-	    prevLon = lon;
-	    if (nodes > 2 && i < nodes - 1)
-		if (pillarNodes.is3D())
-		    pillarNodes.add(lat, lon, ele);
-		else
-		    pillarNodes.add(lat, lon);
-	}
-	if (towerNodeDistance == 0)
-	{
-	    // As investigation shows often two paths should have crossed via
-	    // one identical point
-	    // but end up in two very release points.
-	    zeroCounter++;
-	    towerNodeDistance = 0.0001;
-	}
-
-	EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
-			.setDistance(towerNodeDistance).setFlags(flags);
-	if (nodes > 2)
-	{
-	    if (doSimplify)
-		simplifyAlgo.simplify(pillarNodes);
-
-	    iter.setWayGeometry(pillarNodes);
-	}
-	storeOsmWayID(iter.getEdge(), wayOsmId);
-	return iter;
+            long wayOsmId)
+    {
+        // sanity checks
+        if (fromIndex < 0 || toIndex < 0)
+            throw new AssertionError("to or from index is invalid for this edge " + fromIndex
+                    + "->" + toIndex + ", points:" + pointList);
+        if (pointList.getDimension() != nodeAccess.getDimension())
+            throw new AssertionError("Dimension does not match for pointList vs. nodeAccess "
+                    + pointList.getDimension() + " <-> " + nodeAccess.getDimension());
+
+        double towerNodeDistance = 0;
+        double prevLat = pointList.getLatitude(0);
+        double prevLon = pointList.getLongitude(0);
+        double prevEle = pointList.is3D() ? pointList.getElevation(0) : Double.NaN;
+        double lat, lon, ele = Double.NaN;
+        PointList pillarNodes = new PointList(pointList.getSize() - 2, nodeAccess.is3D());
+        int nodes = pointList.getSize();
+        for (int i = 1; i < nodes; i++)
+        {
+            // we could save some lines if we would use
+            // pointList.calcDistance(distCalc);
+            lat = pointList.getLatitude(i);
+            lon = pointList.getLongitude(i);
+            if (pointList.is3D())
+            {
+                ele = pointList.getElevation(i);
+                towerNodeDistance += distCalc3D.calcDist(prevLat, prevLon, prevEle, lat, lon, ele);
+                prevEle = ele;
+            } else
+                towerNodeDistance += distCalc.calcDist(prevLat, prevLon, lat, lon);
+            prevLat = lat;
+            prevLon = lon;
+            if (nodes > 2 && i < nodes - 1)
+                if (pillarNodes.is3D())
+                    pillarNodes.add(lat, lon, ele);
+                else
+                    pillarNodes.add(lat, lon);
+        }
+        if (towerNodeDistance == 0)
+        {
+            // As investigation shows often two paths should have crossed via
+            // one identical point
+            // but end up in two very release points.
+            zeroCounter++;
+            towerNodeDistance = 0.0001;
+        }
+
+        EdgeIteratorState iter = graphStorage.edge(fromIndex, toIndex)
+                .setDistance(towerNodeDistance).setFlags(flags);
+        if (nodes > 2)
+        {
+            if (doSimplify)
+                simplifyAlgo.simplify(pillarNodes);
+
+            iter.setWayGeometry(pillarNodes);
+        }
+        storeOsmWayID(iter.getEdge(), wayOsmId);
+        return iter;
     }
 
     /**
@@ -786,47 +838,47 @@ EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long
      */
     private void storeOsmWayID(int edgeId, long osmWayId)
     {
-	if (getOsmWayIdSet().contains(osmWayId))
-	    getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
+        if (getOsmWayIdSet().contains(osmWayId))
+            getEdgeIdToOsmWayIdMap().put(edgeId, osmWayId);
     }
 
     /**
      * @return converted tower node
      */
     private int handlePillarNode(int tmpNode, long osmId, PointList pointList,
-		    boolean convertToTowerNode)
+            boolean convertToTowerNode)
     {
-	tmpNode = tmpNode - 3;
-	double lat = pillarInfo.getLatitude(tmpNode);
-	double lon = pillarInfo.getLongitude(tmpNode);
-	double ele = pillarInfo.getElevation(tmpNode);
-	if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
-	    throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
-			    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
-
-	if (convertToTowerNode)
-	{
-	    // convert pillarNode type to towerNode, make pillar values invalid
-	    pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
-	    tmpNode = addTowerNode(osmId, lat, lon, ele);
-	} else if (pointList.is3D())
-	    pointList.add(lat, lon, ele);
-	else
-	    pointList.add(lat, lon);
-
-	return tmpNode;
+        tmpNode = tmpNode - 3;
+        double lat = pillarInfo.getLatitude(tmpNode);
+        double lon = pillarInfo.getLongitude(tmpNode);
+        double ele = pillarInfo.getElevation(tmpNode);
+        if (lat == Double.MAX_VALUE || lon == Double.MAX_VALUE)
+            throw new RuntimeException("Conversion pillarNode to towerNode already happended!? "
+                    + "osmId:" + osmId + " pillarIndex:" + tmpNode);
+
+        if (convertToTowerNode)
+        {
+            // convert pillarNode type to towerNode, make pillar values invalid
+            pillarInfo.setNode(tmpNode, Double.MAX_VALUE, Double.MAX_VALUE, Double.MAX_VALUE);
+            tmpNode = addTowerNode(osmId, lat, lon, ele);
+        } else if (pointList.is3D())
+            pointList.add(lat, lon, ele);
+        else
+            pointList.add(lat, lon);
+
+        return tmpNode;
     }
 
     protected void finishedReading()
     {
-	printInfo("way");
-	pillarInfo.clear();
-	eleProvider.release();
-	osmNodeIdToInternalNodeMap = null;
-	osmNodeIdToNodeFlagsMap = null;
-	osmWayIdToRouteWeightMap = null;
-	osmWayIdSet = null;
-	edgeIdToOsmWayIdMap = null;
+        printInfo("way");
+        pillarInfo.clear();
+        eleProvider.release();
+        osmNodeIdToInternalNodeMap = null;
+        osmNodeIdToNodeFlagsMap = null;
+        osmWayIdToRouteWeightMap = null;
+        osmWayIdSet = null;
+        edgeIdToOsmWayIdMap = null;
     }
 
     /**
@@ -834,73 +886,73 @@ protected void finishedReading()
      */
     long addBarrierNode(long nodeId)
     {
-	OSMNode newNode;
-	int graphIndex = getNodeMap().get(nodeId);
-	if (graphIndex < TOWER_NODE)
-	{
-	    graphIndex = -graphIndex - 3;
-	    newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
-	} else
-	{
-	    graphIndex = graphIndex - 3;
-	    newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
-	}
-
-	final long id = newNode.getId();
-	prepareHighwayNode(id);
-	addNode(newNode);
-	return id;
+        OSMNode newNode;
+        int graphIndex = getNodeMap().get(nodeId);
+        if (graphIndex < TOWER_NODE)
+        {
+            graphIndex = -graphIndex - 3;
+            newNode = new OSMNode(createNewNodeId(), nodeAccess, graphIndex);
+        } else
+        {
+            graphIndex = graphIndex - 3;
+            newNode = new OSMNode(createNewNodeId(), pillarInfo, graphIndex);
+        }
+
+        final long id = newNode.getId();
+        prepareHighwayNode(id);
+        addNode(newNode);
+        return id;
     }
 
     private long createNewNodeId()
     {
-	return newUniqueOsmId++;
+        return newUniqueOsmId++;
     }
 
     /**
      * Add a zero length edge with reduced routing options to the graph.
      */
     Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags,
-		    long nodeFlags, long wayOsmId)
-    {
-	// clear barred directions from routing flags
-	flags &= ~nodeFlags;
-	// add edge
-	barrierNodeIds.clear();
-	barrierNodeIds.add(fromId);
-	barrierNodeIds.add(toId);
-	return addOSMWay(barrierNodeIds, flags, wayOsmId);
-    }
+            long nodeFlags, long wayOsmId)
+            {
+        // clear barred directions from routing flags
+        flags &= ~nodeFlags;
+        // add edge
+        barrierNodeIds.clear();
+        barrierNodeIds.add(fromId);
+        barrierNodeIds.add(toId);
+        return addOSMWay(barrierNodeIds, flags, wayOsmId);
+            }
 
     /**
      * Creates an OSM turn relation out of an unspecified OSM relation
      * <p>
-     * 
+     *
      * @return the OSM turn relation, <code>null</code>, if unsupported turn relation
      */
     TurnRelation createTurnRelation(OSMRelation relation)
     {
-	OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation
-			.getTag("restriction"));
-	if (type != OSMTurnRelation.Type.UNSUPPORTED)
-	{
-	    long fromWayID = -1;
-	    long viaNodeID = -1;
-	    long toWayID = -1;
-
-	    for (OSMRelation.Member member : relation.getMembers())
-		if (OSMElement.WAY == member.type())
-		{
-		    if ("from".equals(member.role()))
-			fromWayID = member.ref();
-		    else if ("to".equals(member.role()))
-			toWayID = member.ref();
-		} else if (OSMElement.NODE == member.type() && "via".equals(member.role()))
-		    viaNodeID = member.ref();
-	    if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
-		return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
-	}
-	return null;
+        OSMTurnRelation.Type type = OSMTurnRelation.Type.getRestrictionType(relation
+                .getTag("restriction"));
+        if (type != OSMTurnRelation.Type.UNSUPPORTED)
+        {
+            long fromWayID = -1;
+            long viaNodeID = -1;
+            long toWayID = -1;
+
+            for (OSMRelation.Member member : relation.getMembers())
+                if (OSMElement.WAY == member.type())
+                {
+                    if ("from".equals(member.role()))
+                        fromWayID = member.ref();
+                    else if ("to".equals(member.role()))
+                        toWayID = member.ref();
+                } else if (OSMElement.NODE == member.type() && "via".equals(member.role()))
+                    viaNodeID = member.ref();
+            if (fromWayID >= 0 && toWayID >= 0 && viaNodeID >= 0)
+                return new OSMTurnRelation(fromWayID, viaNodeID, toWayID, type);
+        }
+        return null;
     }
 
     /**
@@ -908,7 +960,7 @@ else if ("to".equals(member.role()))
      */
     boolean isInBounds(OSMNode node)
     {
-	return true;
+        return true;
     }
 
     /**
@@ -916,17 +968,17 @@ boolean isInBounds(OSMNode node)
      */
     protected LongIntMap getNodeMap()
     {
-	return osmNodeIdToInternalNodeMap;
+        return osmNodeIdToInternalNodeMap;
     }
 
     protected TLongLongMap getNodeFlagsMap()
     {
-	return osmNodeIdToNodeFlagsMap;
+        return osmNodeIdToNodeFlagsMap;
     }
 
     TLongLongHashMap getRelFlagsMap()
     {
-	return osmWayIdToRouteWeightMap;
+        return osmWayIdToRouteWeightMap;
     }
 
     /**
@@ -935,67 +987,67 @@ TLongLongHashMap getRelFlagsMap()
     @Override
     public OSMReader setEncodingManager(EncodingManager em)
     {
-	this.encodingManager = em;
-	return this;
+        this.encodingManager = em;
+        return this;
     }
 
     @Override
     public OSMReader setWayPointMaxDistance(double maxDist)
     {
-	doSimplify = maxDist > 0;
-	simplifyAlgo.setMaxDistance(maxDist);
-	return this;
+        doSimplify = maxDist > 0;
+        simplifyAlgo.setMaxDistance(maxDist);
+        return this;
     }
 
     @Override
     public OSMReader setWorkerThreads(int numOfWorkers)
     {
-	this.workerThreads = numOfWorkers;
-	return this;
+        this.workerThreads = numOfWorkers;
+        return this;
     }
 
     @Override
     public OSMReader setElevationProvider(ElevationProvider eleProvider)
     {
-	if (eleProvider == null)
-	    throw new IllegalStateException(
-			    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
+        if (eleProvider == null)
+            throw new IllegalStateException(
+                    "Use the NOOP elevation provider instead of null or don't call setElevationProvider");
 
-	if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
-	    throw new IllegalStateException("Make sure you graph accepts 3D data");
+        if (!nodeAccess.is3D() && ElevationProvider.NOOP != eleProvider)
+            throw new IllegalStateException("Make sure you graph accepts 3D data");
 
-	this.eleProvider = eleProvider;
-	return this;
+        this.eleProvider = eleProvider;
+        return this;
     }
 
     @Override
     public DataReader setOSMFile(File osmFile)
     {
-	this.osmFile = osmFile;
-	return this;
+        this.osmFile = osmFile;
+        return this;
     }
 
     private void printInfo(String str)
     {
-	LoggerFactory.getLogger(getClass()).info(
-			"finished " + str + " processing." + " nodes: " + graphStorage.getNodes()
-					+ ", osmIdMap.size:" + getNodeMap().getSize()
-					+ ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
-					+ ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
-					+ ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
-					+ Helper.getMemInfo());
+        LoggerFactory.getLogger(getClass()).info(
+                "finished " + str + " processing." + " nodes: " + graphStorage.getNodes()
+                + ", osmIdMap.size:" + getNodeMap().getSize()
+                + ", osmIdMap:" + getNodeMap().getMemoryUsage() + "MB"
+                + ", nodeFlagsMap.size:" + getNodeFlagsMap().size()
+                + ", relFlagsMap.size:" + getRelFlagsMap().size() + " "
+                + Helper.getMemInfo());
     }
 
     @Override
     public String toString()
     {
-	return getClass().getSimpleName();
+        return getClass().getSimpleName();
     }
 
     @Override
     public GraphStorage getGraphStorage()
     {
-	return graphStorage;
+        return graphStorage;
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
index 0a76564e00..b3b541ba7a 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMTurnRelation.java
@@ -6,7 +6,6 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import com.graphhopper.reader.osgb.OsItnReader;
 import com.graphhopper.routing.util.TurnCostEncoder;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
@@ -20,28 +19,28 @@
 {
     public enum Type
     {
-	UNSUPPORTED, NOT, ONLY;
-
-	private static final Map<String, Type> tags = new HashMap<String, Type>();
-
-	static
-	{
-	    tags.put("no_left_turn", NOT);
-	    tags.put("no_right_turn", NOT);
-	    tags.put("no_straight_on", NOT);
-	    tags.put("no_u_turn", NOT);
-	    tags.put("only_right_turn", ONLY);
-	    tags.put("only_left_turn", ONLY);
-	    tags.put("only_straight_on", ONLY);
-	}
-
-	public static Type getRestrictionType(String tag)
-	{
-	    Type result = null;
-	    if (tag != null)
-		result = tags.get(tag);
-	    return result != null ? result : UNSUPPORTED;
-	}
+        UNSUPPORTED, NOT, ONLY;
+
+        private static final Map<String, Type> tags = new HashMap<String, Type>();
+
+        static
+        {
+            tags.put("no_left_turn", NOT);
+            tags.put("no_right_turn", NOT);
+            tags.put("no_straight_on", NOT);
+            tags.put("no_u_turn", NOT);
+            tags.put("only_right_turn", ONLY);
+            tags.put("only_left_turn", ONLY);
+            tags.put("only_straight_on", ONLY);
+        }
+
+        public static Type getRestrictionType(String tag)
+        {
+            Type result = null;
+            if (tag != null)
+                result = tags.get(tag);
+            return result != null ? result : UNSUPPORTED;
+        }
     }
 
     private final long fromOsmWayId;
@@ -51,38 +50,38 @@ public static Type getRestrictionType(String tag)
 
     public OSMTurnRelation(long fromWayID, long viaNodeID, long toWayID, Type restrictionType)
     {
-	this.fromOsmWayId = fromWayID;
-	this.viaOsmNodeId = viaNodeID;
-	this.toOsmWayId = toWayID;
-	this.restriction = restrictionType;
+        this.fromOsmWayId = fromWayID;
+        this.viaOsmNodeId = viaNodeID;
+        this.toOsmWayId = toWayID;
+        this.restriction = restrictionType;
     }
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.graphhopper.reader.TurnRelation#getOsmIdFrom()
      */
     @Override
     public long getOsmIdFrom()
     {
-	return fromOsmWayId;
+        return fromOsmWayId;
     }
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.graphhopper.reader.TurnRelation#getOsmIdTo()
      */
     @Override
     public long getOsmIdTo()
     {
-	return toOsmWayId;
+        return toOsmWayId;
     }
 
     /**
      * Transforms this relation into a collection of turn cost entries
      * <p>
-     * 
+     *
      * @param edgeOutExplorer
      *            an edge filter which only allows outgoing edges
      * @param edgeInExplorer
@@ -91,72 +90,68 @@ public long getOsmIdTo()
      */
     @Override
     public Collection<ITurnCostTableEntry> getRestrictionAsEntries(TurnCostEncoder encoder,
-		    EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader dataReader)
-    {
-	OSMReader osmReader = (OSMReader) dataReader;
-	int viaNodeId = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
-
-	try
-	{
-	    // street with restriction was not included (access or tag limits
-	    // etc)
-	    if (viaNodeId == OSMReader.EMPTY)
-		return Collections.emptyList();
-
-	    int edgeIdFrom = EdgeIterator.NO_EDGE;
-
-	    // get all incoming edges and receive the edge which is defined by
-	    // fromOsm
-	    EdgeIterator iter = edgeInExplorer.setBaseNode(viaNodeId);
-
-	    while (iter.next())
-		if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
-		{
-		    edgeIdFrom = iter.getEdge();
-		    break;
-		}
-
-	    if (edgeIdFrom == EdgeIterator.NO_EDGE)
-		return Collections.emptyList();
-
-	    final Collection<ITurnCostTableEntry> entries = new ArrayList<ITurnCostTableEntry>();
-	    // get all outgoing edges of the via node
-	    iter = edgeOutExplorer.setBaseNode(viaNodeId);
-	    // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT
-	    // the given turn
-	    // for TYPE_NOT_* we add ONE restriction (from, via, to)
-	    while (iter.next())
-	    {
-		int edgeId = iter.getEdge();
-		long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
-		if (edgeId != edgeIdFrom && this.restriction == Type.ONLY
-				&& wayId != this.toOsmWayId || this.restriction == Type.NOT
-				&& wayId == this.toOsmWayId && wayId >= 0)
-		{
-		    final TurnCostTableEntry entry = new TurnCostTableEntry();
-		    entry.nodeViaNode = viaNodeId;
-		    entry.edgeFrom = edgeIdFrom;
-		    entry.edgeTo = iter.getEdge();
-		    entry.flags = encoder.getTurnFlags(true, 0);
-		    entries.add(entry);
-
-		    if (this.restriction == Type.NOT)
-			break;
-		}
-	    }
-	    return entries;
-	} catch (Exception e)
-	{
-	    throw new IllegalStateException(
-			    "Could not built turn table entry for relation of node with osmId:"
-					    + this.viaOsmNodeId, e);
-	}
-    }
+            EdgeExplorer edgeOutExplorer, EdgeExplorer edgeInExplorer, DataReader dataReader)
+            {
+        OSMReader osmReader = (OSMReader) dataReader;
+        int nodeVia = osmReader.getInternalNodeIdOfOsmNode(this.viaOsmNodeId);
+
+        try
+        {
+            // street with restriction was not included (access or tag limits etc)
+            if (nodeVia == OSMReader.EMPTY)
+                return Collections.emptyList();
+
+            int edgeIdFrom = EdgeIterator.NO_EDGE;
+
+            // get all incoming edges and receive the edge which is defined by fromOsm
+            EdgeIterator iter = edgeInExplorer.setBaseNode(nodeVia);
+
+            while (iter.next())
+            {
+                if (osmReader.getOsmIdOfInternalEdge(iter.getEdge()) == this.fromOsmWayId)
+                {
+                    edgeIdFrom = iter.getEdge();
+                    break;
+                }
+            }
+
+            if (edgeIdFrom == EdgeIterator.NO_EDGE)
+                return Collections.emptyList();
+
+            final Collection<ITurnCostTableEntry> entries = new ArrayList<>();
+            // get all outgoing edges of the via node
+            iter = edgeOutExplorer.setBaseNode(nodeVia);
+            // for TYPE_ONLY_* we add ALL restrictions (from, via, * ) EXCEPT the given turn
+            // for TYPE_NOT_*  we add ONE restriction  (from, via, to)
+            while (iter.next())
+            {
+                int edgeId = iter.getEdge();
+                long wayId = osmReader.getOsmIdOfInternalEdge(edgeId);
+                if (edgeId != edgeIdFrom && this.restriction == Type.ONLY && wayId != this.toOsmWayId
+                        || this.restriction == Type.NOT && wayId == this.toOsmWayId && wayId >= 0)
+                {
+                    final TurnCostTableEntry entry = new TurnCostTableEntry();
+                    entry.nodeViaNode = nodeVia;
+                    entry.edgeFrom = edgeIdFrom;
+                    entry.edgeTo = iter.getEdge();
+                    entry.flags = encoder.getTurnFlags(true, 0);
+                    entries.add(entry);
+
+                    if (this.restriction == Type.NOT)
+                        break;
+                }
+            }
+            return entries;
+        } catch (Exception e)
+        {
+            throw new IllegalStateException("Could not built turn table entry for relation of node with osmId:" + this.viaOsmNodeId, e);
+        }
+            }
 
     @Override
     public String toString()
     {
-	return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
+        return "*-(" + fromOsmWayId + ")->" + viaOsmNodeId + "-(" + toOsmWayId + ")->*";
     }
 
     /**
@@ -164,56 +159,66 @@ public String toString()
      */
     public static class TurnCostTableEntry implements ITurnCostTableEntry
     {
-	public int edgeFrom;
-	public int nodeViaNode;
-	public int edgeTo;
-	public long flags;
-
-	/**
-	 * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
-	 *         are involved.
-	 */
-	@Override
-	public long getItemId()
-	{
-	    return (long) edgeFrom << 32 | edgeTo;
-	}
-
-	@Override
-	public int getEdgeFrom()
-	{
-	    return edgeFrom;
-	}
-
-	@Override
-	public int getEdgeTo()
-	{
-	    return edgeTo;
-	}
-
-	@Override
-	public int getVia()
-	{
-	    return nodeViaNode;
-	}
-
-	@Override
-	public long getFlags()
-	{
-	    return flags;
-	}
-
-	@Override
-	public void setFlags(long flags)
-	{
-	    this.flags = flags;
-	}
-
-	@Override
-	public String toString()
-	{
-	    return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
-	}
+        public int edgeFrom;
+        public int nodeViaNode;
+        public int edgeTo;
+        public long flags;
+
+        /**
+         * @return an unique id (edgeFrom, edgeTo) to avoid duplicate entries if multiple encoders
+         *         are involved.
+         */
+        @Override
+        public long getItemId()
+        {
+            return ((long) edgeFrom) << 32 | (edgeTo);
+        }
+
+        @Override
+        public int getEdgeFrom()
+        {
+            return edgeFrom;
+        }
+
+        @Override
+        public int getEdgeTo()
+        {
+            return edgeTo;
+        }
+
+        @Override
+        public int getVia()
+        {
+            return nodeViaNode;
+        }
+
+        @Override
+        public long getFlags()
+        {
+            return flags;
+        }
+
+        @Override
+        public void setFlags(long flags)
+        {
+            this.flags = flags;
+        }
+
+        @Override
+        public String toString()
+        {
+            return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo + ")->*";
+        }
+
+        @Override
+        public void setEdgeFrom(int from) {
+            this.edgeFrom = from;
+        }
+
+        @Override
+        public void setEdgeTo(int to) {
+            this.edgeTo = to;
+        }
     }
 
 }
diff --git a/core/src/main/java/com/graphhopper/reader/PillarInfo.java b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
index 2edee09bc7..0c612d5e7b 100644
--- a/core/src/main/java/com/graphhopper/reader/PillarInfo.java
+++ b/core/src/main/java/com/graphhopper/reader/PillarInfo.java
@@ -57,26 +57,28 @@ public int getDimension()
     }
 
     @Override
-    public void setNode( int id, double lat, double lon )
+    public void ensureNode( int nodeId )
     {
-//        if (is3D())
-//            throw new IllegalStateException("Can only be called if 3D is disabled");
+        long tmp = (long) nodeId * rowSizeInBytes;
+        da.ensureCapacity(tmp + rowSizeInBytes);
+    }        
 
-        _setNode(id, lat, lon, Double.NaN);
+    @Override
+    public void setNode( int nodeId, double lat, double lon )
+    {
+        _setNode(nodeId, lat, lon, Double.NaN);
     }
 
     @Override
-    public void setNode( int id, double lat, double lon, double ele )
+    public void setNode( int nodeId, double lat, double lon, double ele )
     {
-//        if (!is3D())
-//            throw new IllegalStateException("Can only be called if 3D is enabled");
-        _setNode(id, lat, lon, ele);
+        _setNode(nodeId, lat, lon, ele);
     }
 
-    private void _setNode( int id, double lat, double lon, double ele )
+    private void _setNode( int nodeId, double lat, double lon, double ele )
     {
-        long tmp = (long) id * rowSizeInBytes;
-        da.ensureCapacity(tmp + rowSizeInBytes);
+        ensureNode(nodeId);
+        long tmp = (long) nodeId * rowSizeInBytes;
         da.setInt(tmp + LAT, Helper.degreeToInt(lat));
         da.setInt(tmp + LON, Helper.degreeToInt(lon));
 
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java b/core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java
index 5e26885088..4b763fe346 100644
--- a/core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OSITNTurnRelation.java
@@ -21,7 +21,7 @@
  * Helper object which gives OSGB ITN instruction to GraphHopper relation
  * mapping
  * <p>
- * 
+ *
  * @author Stuart Adam
  */
 public class OSITNTurnRelation implements TurnRelation {
@@ -58,7 +58,7 @@ public OSITNTurnRelation(long fromWayID, long viaNodeID, long toWayID,
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.graphhopper.reader.TurnRelation#getOsmIdFrom()
      */
     @Override
@@ -68,7 +68,7 @@ public long getOsmIdFrom() {
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see com.graphhopper.reader.TurnRelation#getOsmIdTo()
      */
     @Override
@@ -79,7 +79,7 @@ public long getOsmIdTo() {
     /**
      * Transforms this relation into a collection of turn cost entries
      * <p>
-     * 
+     *
      * @param edgeOutExplorer
      *            an edge filter which only allows outgoing edges
      * @param edgeInExplorer
@@ -197,7 +197,15 @@ public void setFlags(long flags) {
             this.flags = flags;
 
         }
+        @Override
+        public void setEdgeFrom(int from) {
+            this.edgeFrom = from;
+        }
 
+        @Override
+        public void setEdgeTo(int to) {
+            this.edgeTo = to;
+        }
         @Override
         public String toString() {
             return "*-(" + edgeFrom + ")->" + nodeViaNode + "-(" + edgeTo
diff --git a/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java b/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
index 0436255309..0a44af2e6b 100755
--- a/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
+++ b/core/src/main/java/com/graphhopper/reader/osgb/OsItnReader.java
@@ -49,11 +49,10 @@
 import com.graphhopper.reader.Way;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.ExtendedStorage;
-import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalc3D;
 import com.graphhopper.util.DistanceCalcEarth;
@@ -1456,15 +1455,13 @@ public void processRelation(Relation relation) throws XMLStreamException {
                 logger.info(TURN_FROM_TO_VIA_FORMAT,
                         turnRelation.getOsmIdFrom(), turnRelation.getOsmIdTo(),
                         turnRelation.getVia());
-                ExtendedStorage extendedStorage = ((GraphHopperStorage) graphStorage)
-                        .getExtendedStorage();
-                if (extendedStorage instanceof TurnCostStorage) {
+                GraphExtension extendedStorage = graphStorage.getExtension();
+                if (extendedStorage instanceof TurnCostExtension) {
+                    TurnCostExtension tcs = (TurnCostExtension) extendedStorage;
                     Collection<ITurnCostTableEntry> entries = encodingManager
                             .analyzeTurnRelation(turnRelation, this);
                     for (ITurnCostTableEntry entry : entries) {
-                        ((TurnCostStorage) extendedStorage).addTurnInfo(
-                                entry.getVia(), entry.getEdgeFrom(),
-                                entry.getEdgeTo(), (int) entry.getFlags());
+                        tcs.addTurnInfo(entry.getEdgeFrom(), entry.getVia(), entry.getEdgeTo(), entry.getFlags());
                     }
                 }
             }
diff --git a/core/src/main/java/com/graphhopper/routing/AStar.java b/core/src/main/java/com/graphhopper/routing/AStar.java
index 2fd110cef9..56ba796d60 100644
--- a/core/src/main/java/com/graphhopper/routing/AStar.java
+++ b/core/src/main/java/com/graphhopper/routing/AStar.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.util.DistancePlaneProjection;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
@@ -25,11 +26,10 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.routing.util.BeelineWeightApproximator;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 
@@ -43,32 +43,28 @@
  */
 public class AStar extends AbstractRoutingAlgorithm
 {
-    private DistanceCalc dist;
+    private WeightApproximator weightApprox;
     private int visitedCount;
     private TIntObjectMap<AStarEdge> fromMap;
     private PriorityQueue<AStarEdge> prioQueueOpenSet;
     private AStarEdge currEdge;
     private int to1 = -1;
-    private double toLat;
-    private double toLon;
 
     public AStar( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
         super(g, encoder, weighting, tMode);
         initCollections(1000);
-        setApproximation(true);
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     /**
-     * @param approx if true it enables an approximative distance calculation from lat,lon values
+     * @param approx defines how distance to goal Node is approximated
      */
-    public AStar setApproximation( boolean approx )
+    public AStar setApproximation( WeightApproximator approx )
     {
-        if (approx)
-            dist = new DistancePlaneProjection();
-        else
-            dist = new DistanceCalcEarth();
-
+        weightApprox = approx;
         return this;
     }
 
@@ -82,9 +78,8 @@ protected void initCollections( int size )
     public Path calcPath( int from, int to )
     {
         checkAlreadyRun();
-        toLat = nodeAccess.getLatitude(to);
-        toLon = nodeAccess.getLongitude(to);
         to1 = to;
+        weightApprox.setGoalNode(to);
         currEdge = createEdgeEntry(from, 0);
         if (!traversalMode.isEdgeBased())
         {
@@ -95,12 +90,15 @@ public Path calcPath( int from, int to )
 
     private Path runAlgo()
     {
-        double currWeightToGoal, distEstimation, tmpLat, tmpLon;
+        double currWeightToGoal, distEstimation;
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             int currVertex = currEdge.adjNode;
             visitedCount++;
+            if (isWeightLimitReached())
+                return createEmptyPath();
+
             if (finished())
                 break;
 
@@ -112,30 +110,29 @@ private Path runAlgo()
 
                 int neighborNode = iter.getAdjNode();
                 int traversalId = traversalMode.createTraversalId(iter, false);
-                double alreadyVisitedWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightToCompare;
+                // cast to float to avoid rounding errors in comparison to float entry of AStarEdge weight
+                float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, false, currEdge.edge)
+                        + currEdge.weightOfVisitedPath);
                 if (Double.isInfinite(alreadyVisitedWeight))
                     continue;
 
                 AStarEdge ase = fromMap.get(traversalId);
-                if (ase == null || ase.weightToCompare > alreadyVisitedWeight)
+                if ((ase == null) || ase.weightOfVisitedPath > alreadyVisitedWeight)
                 {
-                    tmpLat = nodeAccess.getLatitude(neighborNode);
-                    tmpLon = nodeAccess.getLongitude(neighborNode);
-                    currWeightToGoal = dist.calcDist(toLat, toLon, tmpLat, tmpLon);
-                    currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                    currWeightToGoal = weightApprox.approximate(neighborNode);
                     distEstimation = alreadyVisitedWeight + currWeightToGoal;
                     if (ase == null)
                     {
                         ase = new AStarEdge(iter.getEdge(), neighborNode, distEstimation, alreadyVisitedWeight);
                         fromMap.put(traversalId, ase);
-                    } else if (ase.weight > distEstimation)
+                    } else
                     {
+                        assert (ase.weight > distEstimation) : "Inconsistent distance estimate";
                         prioQueueOpenSet.remove(ase);
                         ase.edge = iter.getEdge();
                         ase.weight = distEstimation;
-                        ase.weightToCompare = alreadyVisitedWeight;
-                    } else
-                        continue;
+                        ase.weightOfVisitedPath = alreadyVisitedWeight;
+                    }
 
                     ase.parent = currEdge;
                     prioQueueOpenSet.add(ase);
@@ -179,23 +176,27 @@ public int getVisitedNodes()
         return visitedCount;
     }
 
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
+    }
+
     public static class AStarEdge extends EdgeEntry
     {
         // the variable 'weight' is used to let heap select smallest *full* distance.
         // but to compare distance we need it only from start:
-        double weightToCompare;
+        double weightOfVisitedPath;
 
-        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightToCompare )
+        public AStarEdge( int edgeId, int adjNode, double weightForHeap, double weightOfVisitedPath )
         {
             super(edgeId, adjNode, weightForHeap);
-            // round makes distance smaller => heuristic should underestimate the distance!
-            this.weightToCompare = (float) weightToCompare;
+            this.weightOfVisitedPath = (float) weightOfVisitedPath;
         }
     }
 
     @Override
     public String getName()
     {
-        return "astar";
+        return AlgorithmOptions.ASTAR;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index 42b420105b..f8a92e1bf3 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -17,33 +17,27 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.*;
 import gnu.trove.map.TIntObjectMap;
 import gnu.trove.map.hash.TIntObjectHashMap;
 
 import java.util.PriorityQueue;
 
 import com.graphhopper.routing.AStar.AStarEdge;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.GHPoint;
 
 /**
  * This class implements a bidirectional A* algorithm. It is interesting to note that a
  * bidirectional dijkstra is far more efficient than a single direction one. The same does not hold
- * for a bidirectional A* as the finish condition can not be so strict which leads to either
- * suboptimal paths or suboptimal node exploration (too many nodes). Still very good approximations
- * with a rougly twice times faster running time than the normal A* can be reached.
+ * for a bidirectional A* as the heuristic can not be as tight.
  * <p/>
- * Computing the Shortest Path: A∗ Search Meets Graph Theory ->
- * http://research.microsoft.com/apps/pubs/default.aspx?id=64511
+ * See http://research.microsoft.com/apps/pubs/default.aspx?id=64511
  * http://i11www.iti.uni-karlsruhe.de/_media/teaching/sommer2012/routenplanung/vorlesung4.pdf
  * http://research.microsoft.com/pubs/64504/goldberg-sofsem07.pdf
  * http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
  * <p/>
- * better stop condition
+ * and
  * <p/>
  * 1. Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
  * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
@@ -56,10 +50,11 @@
  * www.lix.polytechnique.fr/~giacomon/papers/bidirtimedep.pdf
  * <p/>
  * @author Peter Karich
+ * @author jansoe
  */
 public class AStarBidirection extends AbstractBidirAlgo
 {
-    private DistanceCalc dist;
+    private ConsistentWeightApproximator weightApprox;
     private PriorityQueue<AStarEdge> prioQueueOpenSetFrom;
     private TIntObjectMap<AStarEdge> bestWeightMapFrom;
     private PriorityQueue<AStarEdge> prioQueueOpenSetTo;
@@ -67,9 +62,6 @@
     private TIntObjectMap<AStarEdge> bestWeightMapOther;
     protected AStarEdge currFrom;
     protected AStarEdge currTo;
-    protected double approximationFactor;
-    private GHPoint fromCoord;
-    private GHPoint toCoord;
     protected PathBidirRef bestPath;
 
     public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
@@ -77,9 +69,9 @@ public AStarBidirection( Graph graph, FlagEncoder encoder, Weighting weighting,
         super(graph, encoder, weighting, tMode);
         int nodes = Math.max(20, graph.getNodes());
         initCollections(nodes);
-
-        // different default value for approximation than AStar
-        setApproximation(false);
+        BeelineWeightApproximator defaultApprox = new BeelineWeightApproximator(nodeAccess, weighting);
+        defaultApprox.setDistanceCalc(new DistancePlaneProjection());
+        setApproximation(defaultApprox);
     }
 
     protected void initCollections( int size )
@@ -94,26 +86,9 @@ protected void initCollections( int size )
     /**
      * @param approx if true it enables approximative distance calculation from lat,lon values
      */
-    public AStarBidirection setApproximation( boolean approx )
-    {
-        if (approx)
-        {
-            dist = new DistancePlaneProjection();
-            approximationFactor = 0.5;
-        } else
-        {
-            dist = new DistanceCalcEarth();
-            approximationFactor = 1.2;
-        }
-        return this;
-    }
-
-    /**
-     * Specify a low value like 0.5 for worse but faster results. Or over 1.1 for more precise.
-     */
-    public AStarBidirection setApproximationFactor( double approxFactor )
+    public AStarBidirection setApproximation( WeightApproximator approx )
     {
-        this.approximationFactor = approxFactor;
+        weightApprox = new ConsistentWeightApproximator(approx);
         return this;
     }
 
@@ -127,7 +102,7 @@ protected AStarEdge createEdgeEntry( int node, double dist )
     public void initFrom( int from, double dist )
     {
         currFrom = createEdgeEntry(from, dist);
-        fromCoord = new GHPoint(nodeAccess.getLatitude(from), nodeAccess.getLongitude(from));
+        weightApprox.setSourceNode(from);
         prioQueueOpenSetFrom.add(currFrom);
         if (!traversalMode.isEdgeBased())
         {
@@ -141,6 +116,9 @@ public void initFrom( int from, double dist )
         {
             if (currTo != null && currTo.adjNode == from)
             {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
             }
@@ -151,7 +129,7 @@ public void initFrom( int from, double dist )
     public void initTo( int to, double dist )
     {
         currTo = createEdgeEntry(to, dist);
-        toCoord = new GHPoint(nodeAccess.getLatitude(to), nodeAccess.getLongitude(to));
+        weightApprox.setGoalNode(to);
         prioQueueOpenSetTo.add(currTo);
         if (!traversalMode.isEdgeBased())
         {
@@ -165,6 +143,9 @@ public void initTo( int to, double dist )
         {
             if (currFrom != null && currFrom.adjNode == to)
             {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
             }
@@ -181,6 +162,9 @@ protected Path createAndInitPath()
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -191,17 +175,19 @@ void checkState( int fromBase, int fromAdj, int toBase, int toAdj )
             throw new IllegalStateException("Either 'from'-edge or 'to'-edge is inaccessible. From:" + bestWeightMapFrom + ", to:" + bestWeightMapTo);
     }
 
-    // Problem is the correct finish condition! if the bounds are too wide too many nodes are visited :/   
-    // d_f (v) + (v, w) + d_r (w) < μ + p_r(t)
-    // where pi_r_of_t = p_r(t) = 1/2(pi_r(t) - pi_f(t) + pi_f(s)), and pi_f(t)=0
     @Override
     protected boolean finished()
     {
         if (finishedFrom || finishedTo)
             return true;
 
-        double tmp = bestPath.getWeight() * approximationFactor;
-        return currFrom.weightToCompare + currTo.weightToCompare >= tmp;
+        return currFrom.weight + currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
     }
 
     @Override
@@ -212,7 +198,7 @@ boolean fillEdgesFrom()
 
         currFrom = prioQueueOpenSetFrom.poll();
         bestWeightMapOther = bestWeightMapTo;
-        fillEdges(currFrom, toCoord, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
+        fillEdges(currFrom, prioQueueOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
         visitedCountFrom++;
         return true;
     }
@@ -225,13 +211,12 @@ boolean fillEdgesTo()
 
         currTo = prioQueueOpenSetTo.poll();
         bestWeightMapOther = bestWeightMapFrom;
-        fillEdges(currTo, fromCoord, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
+        fillEdges(currTo, prioQueueOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);
         visitedCountTo++;
         return true;
     }
 
-    private void fillEdges( AStarEdge currEdge, GHPoint goal,
-            PriorityQueue<AStarEdge> prioQueueOpenSet,
+    private void fillEdges( AStarEdge currEdge, PriorityQueue<AStarEdge> prioQueueOpenSet,
             TIntObjectMap<AStarEdge> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
 
@@ -246,34 +231,32 @@ private void fillEdges( AStarEdge currEdge, GHPoint goal,
             int traversalId = traversalMode.createTraversalId(iter, reverse);
             // TODO performance: check if the node is already existent in the opposite direction
             // then we could avoid the approximation as we already know the exact complete path!
-            double alreadyVisitedWeight = weighting.calcWeight(iter, reverse, currEdge.edge) + currEdge.weightToCompare;
+            float alreadyVisitedWeight = (float) (weighting.calcWeight(iter, reverse, currEdge.edge)
+                    + currEdge.weightOfVisitedPath);
             if (Double.isInfinite(alreadyVisitedWeight))
-                    continue;
-            
-            AStarEdge aee = shortestWeightMap.get(traversalId);
-            if (aee == null || aee.weightToCompare > alreadyVisitedWeight)
+                continue;
+
+            AStarEdge ase = shortestWeightMap.get(traversalId);
+            if (ase == null || ase.weightOfVisitedPath > alreadyVisitedWeight)
             {
-                double tmpLat = nodeAccess.getLatitude(neighborNode);
-                double tmpLon = nodeAccess.getLongitude(neighborNode);
-                double currWeightToGoal = dist.calcDist(goal.lat, goal.lon, tmpLat, tmpLon);
-                currWeightToGoal = weighting.getMinWeight(currWeightToGoal);
+                double currWeightToGoal = weightApprox.approximate(neighborNode, reverse);
                 double estimationFullDist = alreadyVisitedWeight + currWeightToGoal;
-                if (aee == null)
+                if (ase == null)
                 {
-                    aee = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
-                    shortestWeightMap.put(traversalId, aee);
-                } else if (aee.weight > estimationFullDist)
-                {
-                    prioQueueOpenSet.remove(aee);
-                    aee.edge = iter.getEdge();
-                    aee.weight = estimationFullDist;
-                    aee.weightToCompare = alreadyVisitedWeight;
+                    ase = new AStarEdge(iter.getEdge(), neighborNode, estimationFullDist, alreadyVisitedWeight);
+                    shortestWeightMap.put(traversalId, ase);
                 } else
-                    continue;
+                {
+                    assert (ase.weight > estimationFullDist) : "Inconsistent distance estimate";
+                    prioQueueOpenSet.remove(ase);
+                    ase.edge = iter.getEdge();
+                    ase.weight = estimationFullDist;
+                    ase.weightOfVisitedPath = alreadyVisitedWeight;
+                }
 
-                aee.parent = currEdge;
-                prioQueueOpenSet.add(aee);
-                updateBestPath(iter, aee, traversalId);
+                ase.parent = currEdge;
+                prioQueueOpenSet.add(ase);
+                updateBestPath(iter, ase, traversalId);
             }
         }
     }
@@ -287,7 +270,7 @@ public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent,
 
         boolean reverse = bestWeightMapFrom == bestWeightMapOther;
         // update μ
-        double newWeight = entryCurrent.weightToCompare + entryOther.weightToCompare;
+        double newWeight = entryCurrent.weightOfVisitedPath + entryOther.weightOfVisitedPath;
         if (traversalMode.isEdgeBased())
         {
             if (entryOther.edge != entryCurrent.edge)
@@ -318,6 +301,6 @@ public void updateBestPath( EdgeIteratorState edgeState, AStarEdge entryCurrent,
     @Override
     public String getName()
     {
-        return "astarbi";
+        return AlgorithmOptions.ASTAR_BI;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index c2fb75debd..2a047c7434 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -40,6 +40,8 @@
 
     protected abstract Path createAndInitPath();
 
+    protected abstract boolean isWeightLimitReached();
+
     abstract void checkState( int fromBase, int fromAdj, int toBase, int toAdj );
 
     abstract boolean fillEdgesFrom();
@@ -62,9 +64,9 @@ public Path calcPath( int from, int to )
         return extractPath();
     }
 
-    void runAlgo()
+    protected void runAlgo()
     {
-        while (!finished())
+        while (!finished() && !isWeightLimitReached())
         {
             if (!finishedFrom)
                 finishedFrom = !fillEdgesFrom();
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 828a3628d3..62349b3d81 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -21,27 +21,24 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
-import java.util.ArrayList;
-import java.util.List;
-
 /**
  * @author Peter Karich
  */
 public abstract class AbstractRoutingAlgorithm implements RoutingAlgorithm
 {
     private EdgeFilter additionalEdgeFilter;
-    protected Graph graph;
+    protected final Graph graph;
     protected NodeAccess nodeAccess;
     protected EdgeExplorer inEdgeExplorer;
     protected EdgeExplorer outEdgeExplorer;
     protected final Weighting weighting;
     protected final FlagEncoder flagEncoder;
     protected final TraversalMode traversalMode;
+    protected double weightLimit = Double.MAX_VALUE;
     private boolean alreadyRun;
 
     /**
@@ -55,39 +52,18 @@ public AbstractRoutingAlgorithm( Graph graph, FlagEncoder encoder, Weighting wei
         this.weighting = weighting;
         this.flagEncoder = encoder;
         this.traversalMode = traversalMode;
-        setGraph(graph);
-    }
-
-    /**
-     * Specify the graph on which this algorithm should operate. API glitch: this method overwrites
-     * graph specified while constructing the algorithm. Only necessary if graph is a QueryGraph.
-     */
-    protected RoutingAlgorithm setGraph( Graph graph )
-    {
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
         outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, false, true));
         inEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(flagEncoder, true, false));
-        return this;
-    }
-
-    protected QueryGraph createQueryGraph()
-    {
-        return new QueryGraph(graph);
     }
 
     @Override
-    public Path calcPath( QueryResult fromRes, QueryResult toRes )
+    public void setWeightLimit( double weight )
     {
-        QueryGraph queryGraph = createQueryGraph();
-        List<QueryResult> results = new ArrayList<QueryResult>(2);
-        results.add(fromRes);
-        results.add(toRes);
-        queryGraph.lookup(results);
-        setGraph(queryGraph);
-        return calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
+        this.weightLimit = weight;
     }
-
+       
     public RoutingAlgorithm setEdgeFilter( EdgeFilter additionalEdgeFilter )
     {
         this.additionalEdgeFilter = additionalEdgeFilter;
diff --git a/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
new file mode 100644
index 0000000000..6cd1313e15
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/AlgorithmOptions.java
@@ -0,0 +1,194 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.util.PMap;
+
+/**
+ * The algorithm options. Create an immutable object via:
+ * <pre>
+ * AlgorithmOptions algoOpts = AlgorithmOptions.start().
+ *        algorithm(AlgorithmOptions.DIJKSTRA).
+ *        weighting(weighting).
+ *        build();
+ * </pre>
+ * <p>
+ * @author Peter Karich
+ */
+public class AlgorithmOptions
+{
+    /**
+     * Bidirectional Dijkstra
+     */
+    public static final String DIJKSTRA_BI = "dijkstrabi";
+    /**
+     * Unidirectional Dijkstra
+     */
+    public static final String DIJKSTRA = "dijkstra";
+    /**
+     * one to many Dijkstra
+     */
+    public static final String DIJKSTRA_ONE_TO_MANY = "dijkstraOneToMany";
+    /**
+     * Unidirectional A*
+     */
+    public static final String ASTAR = "astar";
+    /**
+     * Bidirectional A*
+     */
+    public static final String ASTAR_BI = "astarbi";
+    private String algorithm = DIJKSTRA_BI;
+    private Weighting weighting;
+    private TraversalMode traversalMode = TraversalMode.NODE_BASED;
+    private FlagEncoder flagEncoder;
+    private final PMap hints = new PMap(5);
+
+    private AlgorithmOptions()
+    {
+    }
+
+    /**
+     * Default traversal mode NODE_BASED is used.
+     */
+    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting )
+    {
+        this.algorithm = algorithm;
+        this.weighting = weighting;
+        this.flagEncoder = flagEncoder;
+    }
+
+    public AlgorithmOptions( String algorithm, FlagEncoder flagEncoder, Weighting weighting, TraversalMode tMode )
+    {
+        this.algorithm = algorithm;
+        this.weighting = weighting;
+        this.flagEncoder = flagEncoder;
+        this.traversalMode = tMode;
+    }
+
+    /**
+     * @return the traversal mode, where node-based is the default.
+     */
+    public TraversalMode getTraversalMode()
+    {
+        return traversalMode;
+    }
+
+    public Weighting getWeighting()
+    {
+        assertNotNull(weighting, "weighting");
+        return weighting;
+    }
+
+    public String getAlgorithm()
+    {
+        assertNotNull(algorithm, "algorithm");
+        return algorithm;
+    }
+
+    public FlagEncoder getFlagEncoder()
+    {
+        assertNotNull(flagEncoder, "flagEncoder");
+        return flagEncoder;
+    }
+
+    public PMap getHints()
+    {
+        return hints;
+    }
+
+    private void assertNotNull( Object optionValue, String optionName )
+    {
+        if (optionValue == null)
+            throw new NullPointerException("Option '" + optionName + "' must NOT be null");
+    }
+
+    @Override
+    public String toString()
+    {
+        return algorithm + ", " + weighting + ", " + flagEncoder + ", " + traversalMode;
+    }
+
+    /**
+     * This method starts the building process for AlgorithmOptions.
+     */
+    public static Builder start()
+    {
+        return new Builder();
+    }
+
+    /**
+     * This method clones the specified AlgorithmOption object with the possibility for further
+     * changes.
+     */
+    public static Builder start( AlgorithmOptions opts )
+    {
+        Builder b = new Builder();
+        if (opts.algorithm != null)
+            b.algorithm(opts.getAlgorithm());
+        if (opts.flagEncoder != null)
+            b.flagEncoder(opts.getFlagEncoder());
+        if (opts.traversalMode != null)
+            b.traversalMode(opts.getTraversalMode());
+        if (opts.weighting != null)
+            b.weighting(opts.getWeighting());
+        return b;
+    }
+
+    public static class Builder
+    {
+        private final AlgorithmOptions opts = new AlgorithmOptions();
+
+        public Builder traversalMode( TraversalMode traversalMode )
+        {
+            if (traversalMode == null)
+                throw new IllegalArgumentException("null as traversal mode is not allowed");
+
+            this.opts.traversalMode = traversalMode;
+            return this;
+        }
+
+        public Builder weighting( Weighting weighting )
+        {
+            this.opts.weighting = weighting;
+            return this;
+        }
+
+        /**
+         * For possible values see AlgorithmOptions.*
+         */
+        public Builder algorithm( String algorithm )
+        {
+            this.opts.algorithm = algorithm;
+            return this;
+        }
+
+        public Builder flagEncoder( FlagEncoder flagEncoder )
+        {
+            this.opts.flagEncoder = flagEncoder;
+            return this;
+        }
+
+        public AlgorithmOptions build()
+        {
+            return opts;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index a29522753e..16d7cd0df6 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -38,11 +38,11 @@
  */
 public class Dijkstra extends AbstractRoutingAlgorithm
 {
-    private TIntObjectMap<EdgeEntry> fromMap;
-    private PriorityQueue<EdgeEntry> fromHeap;
+    protected TIntObjectMap<EdgeEntry> fromMap;
+    protected PriorityQueue<EdgeEntry> fromHeap;
+    protected EdgeEntry currEdge;
     private int visitedNodes;
     private int to = -1;
-    private EdgeEntry currEdge;
 
     public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
     {
@@ -66,16 +66,17 @@ public Path calcPath( int from, int to )
         {
             fromMap.put(from, currEdge);
         }
-        return runAlgo();
+        runAlgo();
+        return extractPath();
     }
 
-    private Path runAlgo()
+    protected void runAlgo()
     {
         EdgeExplorer explorer = outEdgeExplorer;
         while (true)
         {
             visitedNodes++;
-            if (finished())
+            if (isWeightLimitReached() || finished())
                 break;
 
             int startNode = currEdge.adjNode;
@@ -111,13 +112,12 @@ private Path runAlgo()
             }
 
             if (fromHeap.isEmpty())
-                return createEmptyPath();
+                break;
 
             currEdge = fromHeap.poll();
             if (currEdge == null)
                 throw new AssertionError("Empty edge cannot happen");
         }
-        return extractPath();
     }
 
     @Override
@@ -129,20 +129,26 @@ protected boolean finished()
     @Override
     protected Path extractPath()
     {
-        if (currEdge == null || !finished())
+        if (currEdge == null || isWeightLimitReached() || !finished())
             return createEmptyPath();
+
         return new Path(graph, flagEncoder).setWeight(currEdge.weight).setEdgeEntry(currEdge).extract();
     }
 
     @Override
-    public String getName()
+    public int getVisitedNodes()
     {
-        return "dijkstra";
+        return visitedNodes;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return currEdge.weight >= weightLimit;
     }
 
     @Override
-    public int getVisitedNodes()
+    public String getName()
     {
-        return visitedNodes;
+        return AlgorithmOptions.DIJKSTRA;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index b17472b455..d3de4faa19 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -84,6 +84,9 @@ public void initFrom( int from, double dist )
         {
             if (currTo != null && currTo.adjNode == from)
             {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
             }
@@ -107,6 +110,9 @@ public void initTo( int to, double dist )
         {
             if (currFrom != null && currFrom.adjNode == to)
             {
+                // special case of identical start and end
+                bestPath.edgeEntry = currFrom;
+                bestPath.edgeTo = currTo;
                 finishedFrom = true;
                 finishedTo = true;
             }
@@ -123,6 +129,9 @@ protected Path createAndInitPath()
     @Override
     protected Path extractPath()
     {
+        if (isWeightLimitReached())
+            return bestPath;
+
         return bestPath.extract();
     }
 
@@ -171,6 +180,12 @@ public boolean finished()
         return currFrom.weight + currTo.weight >= bestPath.getWeight();
     }
 
+    @Override
+    protected boolean isWeightLimitReached()
+    {
+        return currFrom.weight + currTo.weight >= weightLimit;
+    }
+
     void fillEdges( EdgeEntry currEdge, PriorityQueue<EdgeEntry> prioQueue,
             TIntObjectMap<EdgeEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
     {
@@ -246,12 +261,6 @@ protected void updateBestPath( EdgeIteratorState edgeState, EdgeEntry entryCurre
         }
     }
 
-    @Override
-    public String getName()
-    {
-        return "dijkstrabi";
-    }
-
     TIntObjectMap<EdgeEntry> getBestFromMap()
     {
         return bestWeightMapFrom;
@@ -296,4 +305,10 @@ void setBestPath( PathBidirRef bestPath )
     {
         this.bestPath = bestPath;
     }
+
+    @Override
+    public String getName()
+    {
+        return AlgorithmOptions.DIJKSTRA_BI;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
index 4b4b4280e6..d566173302 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraOneToMany.java
@@ -22,7 +22,6 @@
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.Helper;
 import gnu.trove.list.array.TIntArrayList;
@@ -45,7 +44,6 @@
     private IntDoubleBinHeap heap;
     private int visitedNodes;
     private boolean doClear = true;
-    private double limitWeight = Double.MAX_VALUE;
     private int limitVisitedNodes = Integer.MAX_VALUE;
     private int endNode;
     private int currNode, fromNode, to;
@@ -68,24 +66,12 @@ public DijkstraOneToMany( Graph graph, FlagEncoder encoder, Weighting weighting,
         changedNodes = new TIntArrayListWithCap();
     }
 
-    public DijkstraOneToMany setLimitWeight( double weight )
-    {
-        limitWeight = weight;
-        return this;
-    }
-
     public DijkstraOneToMany setLimitVisitedNodes( int nodes )
     {
         this.limitVisitedNodes = nodes;
         return this;
     }
 
-    @Override
-    public Path calcPath( QueryResult fromRes, QueryResult toRes )
-    {
-        throw new IllegalStateException("not supported yet");
-    }
-
     @Override
     public Path calcPath( int from, int to )
     {
@@ -101,8 +87,9 @@ public Path extractPath()
         if (endNode >= 0)
             p.setWeight(weights[endNode]);
         p.setFromNode(fromNode);
-        if (endNode < 0)
+        if (endNode < 0 || isWeightLimitReached())
             return p;
+
         return p.setEndNode(endNode).extract();
     }
 
@@ -170,7 +157,7 @@ public int findEndNode( int from, int to )
             EdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);
             while (iter.next())
             {
-                int adjNode = iter.getAdjNode();                
+                int adjNode = iter.getAdjNode();
                 int prevEdgeId = edgeIds[adjNode];
                 if (!accept(iter, prevEdgeId))
                     continue;
@@ -198,7 +185,7 @@ public int findEndNode( int from, int to )
                 }
             }
 
-            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes)
+            if (heap.isEmpty() || visitedNodes >= limitVisitedNodes || isWeightLimitReached())
                 return NOT_FOUND;
 
             // calling just peek and not poll is important if the next query is cached
@@ -213,7 +200,12 @@ public int findEndNode( int from, int to )
     @Override
     public boolean finished()
     {
-        return weights[currNode] >= limitWeight || currNode == to;
+        return currNode == to;
+    }
+
+    protected boolean isWeightLimitReached()
+    {
+        return weights[currNode] >= weightLimit;
     }
 
     public void close()
@@ -233,7 +225,7 @@ public int getVisitedNodes()
     @Override
     public String getName()
     {
-        return "dijkstraOneToMany";
+        return AlgorithmOptions.DIJKSTRA_ONE_TO_MANY;
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index 9a4a493bed..3e1eabd247 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -1,19 +1,19 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
+ * Licensed to GraphHopper and Peter Karich under one or more contributor
+ * license agreements. See the NOTICE file distributed with this work for
+ * additional information regarding copyright ownership.
  *
- *  GraphHopper licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
+ * GraphHopper licenses this file to you under the Apache License,
+ * Version 2.0 (the "License"); you may not use this file except in
+ * compliance with the License. You may obtain a copy of the License at
  *
- *       http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 package com.graphhopper.routing;
 
@@ -23,12 +23,13 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.AngleCalc;
-import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.FinishInstruction;
@@ -36,6 +37,7 @@
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.PointList;
+import com.graphhopper.util.RoundaboutInstruction;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.Translation;
 
@@ -47,6 +49,7 @@
  *
  * @author Peter Karich
  * @author Ottavio Campana
+ * @author jan soe
  */
 public class Path {
     private static final AngleCalc ac = new AngleCalc();
@@ -63,8 +66,6 @@
     private int fromNode = -1;
     protected int endNode = -1;
     private TIntList edgeIds;
-    private PointList cachedPoints;
-    private InstructionList cachedWays;
     private double weight;
     private NodeAccess nodeAccess;
 
@@ -115,7 +116,6 @@ protected Path setFromNode(int from) {
     private int getFromNode() {
         if (fromNode < 0)
             throw new IllegalStateException("Call extract() before retrieving fromNode");
-
         return fromNode;
     }
 
@@ -131,7 +131,6 @@ public Path setFound(boolean found) {
     void reverseOrder() {
         if (!reverseOrder)
             throw new IllegalStateException("Switching order multiple times is not supported");
-
         reverseOrder = false;
         edgeIds.reverse();
     }
@@ -169,7 +168,6 @@ public Path setWeight(double w) {
     public Path extract() {
         if (isFound())
             throw new IllegalStateException("Extract can only be called once");
-
         extractSW.start();
         EdgeEntry goalEdge = edgeEntry;
         setEndNode(goalEdge.adjNode);
@@ -177,7 +175,6 @@ public Path extract() {
             processEdge(goalEdge.edge, goalEdge.adjNode);
             goalEdge = goalEdge.parent;
         }
-
         setFromNode(goalEdge.adjNode);
         reverseOrder();
         extractSW.stop();
@@ -213,11 +210,11 @@ protected void processEdge(int edgeId, int adjNode) {
     protected long calcMillis(double distance, long flags, boolean revert) {
         if (revert && !encoder.isBool(flags, FlagEncoder.K_BACKWARD) || !revert && !encoder.isBool(flags, FlagEncoder.K_FORWARD))
             throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. " + "Reverse:" + revert + ", fwd:" + encoder.isBool(flags, FlagEncoder.K_FORWARD) + ", bwd:" + encoder.isBool(flags, FlagEncoder.K_BACKWARD));
-
         double speed = revert ? encoder.getReverseSpeed(flags) : encoder.getSpeed(flags);
         if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
             throw new IllegalStateException("Invalid speed stored in edge! " + speed);
-
+        if (speed == 0)
+            throw new IllegalStateException("Speed cannot be 0 for unblocked edge, use access properties to mark edge blocked! Should only occur for shortest path calculation. See #242.");
         return (long) (distance * 3600 / speed);
     }
 
@@ -244,9 +241,9 @@ private void forEveryEdge(EdgeVisitor visitor) {
             EdgeIteratorState edgeBase = graph.getEdgeProps(edgeIds.get(i), tmpNode);
             if (edgeBase == null)
                 throw new IllegalStateException("Edge " + edgeIds.get(i) + " was empty when requested with node " + tmpNode + ", array index:" + i + ", edges:" + edgeIds.size());
-
             tmpNode = edgeBase.getBaseNode();
-            // later: more efficient swap
+            // more efficient swap, currently not implemented for virtual edges:
+            // visitor.next(edgeBase.detach(true), i);
             edgeBase = graph.getEdgeProps(edgeBase.getEdge(), tmpNode);
             visitor.next(edgeBase, i);
         }
@@ -259,7 +256,6 @@ private void forEveryEdge(EdgeVisitor visitor) {
         final List<EdgeIteratorState> edges = new ArrayList<EdgeIteratorState>(edgeIds.size());
         if (edgeIds.isEmpty())
             return edges;
-
         forEveryEdge(new EdgeVisitor() {
             @Override
             public void next(EdgeIteratorState eb, int i) {
@@ -274,9 +270,12 @@ public void next(EdgeIteratorState eb, int i) {
      */
     public TIntList calcNodes() {
         final TIntArrayList nodes = new TIntArrayList(edgeIds.size() + 1);
-        if (edgeIds.isEmpty())
+        if (edgeIds.isEmpty()) {
+            if (isFound()) {
+                nodes.add(endNode);
+            }
             return nodes;
-
+        }
         int tmpNode = getFromNode();
         nodes.add(tmpNode);
         forEveryEdge(new EdgeVisitor() {
@@ -292,47 +291,50 @@ public void next(EdgeIteratorState eb, int i) {
      * This method calculated a list of points for this path
      * <p>
      *
-     * @return this path its geometry (cached)
+     * @return this path its geometry
      */
     public PointList calcPoints() {
-        if (cachedPoints != null)
-            return cachedPoints;
-
-        cachedPoints = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
-        if (edgeIds.isEmpty())
-            return cachedPoints;
-
+        final PointList points = new PointList(edgeIds.size() + 1, nodeAccess.is3D());
+        if (edgeIds.isEmpty()) {
+            if (isFound()) {
+                points.add(graph.getNodeAccess(), endNode);
+            }
+            return points;
+        }
         int tmpNode = getFromNode();
-        cachedPoints.add(nodeAccess, tmpNode);
+        points.add(nodeAccess, tmpNode);
         forEveryEdge(new EdgeVisitor() {
             @Override
             public void next(EdgeIteratorState eb, int index) {
                 PointList pl = eb.fetchWayGeometry(2);
                 for (int j = 0; j < pl.getSize(); j++) {
-                    cachedPoints.add(pl, j);
+                    points.add(pl, j);
                 }
             }
         });
-        return cachedPoints;
+        return points;
     }
 
     /**
      * @return the list of instructions for this path.
      */
     public InstructionList calcInstructions(final Translation tr) {
-        cachedWays = new InstructionList(edgeIds.size() / 4, tr);
-        if (edgeIds.isEmpty())
-            return cachedWays;
-
+        final InstructionList ways = new InstructionList(edgeIds.size() / 4, tr);
+        if (edgeIds.isEmpty()) {
+            if (isFound()) {
+                ways.add(new FinishInstruction(nodeAccess, endNode));
+            }
+            return ways;
+        }
         final int tmpNode = getFromNode();
         forEveryEdge(new EdgeVisitor() {
             /*
              * We need three points to make directions
              *
-             *     (1)----(2)
-             *    /
-             *   /
-             * (0)
+             *          (1)----(2)
+             *          /
+             *         /
+             *       (0)
              *
              * 0 is the node visited at t-2, 1 is the node visited at t-1 and 2
              * is the node being visited at instant t. orientation is the angle
@@ -346,11 +348,14 @@ public InstructionList calcInstructions(final Translation tr) {
              */
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node
+            // t-2
             private double prevOrientation;
             private Instruction prevInstruction;
-            private PointList points = new PointList(10, nodeAccess.is3D());
-            private String name = null;
-            private InstructionAnnotation annotation;
+            private boolean prevInRoundabout = false;
+            private String name, prevName = null;
+            private InstructionAnnotation annotation, prevAnnotation;
+            private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
             public void next(EdgeIteratorState edge, int index) {
@@ -363,95 +368,150 @@ public void next(EdgeIteratorState edge, int index) {
                 // of precision in Lat/Lon calculations in GHNodeAccess so we
                 // have to handle <=0.1 as zero length.
                 if (edge.getDistance() > 0.1) {
-
                     // baseNode is the current node and adjNode is the next
                     int adjNode = edge.getAdjNode();
+                    int baseNode = edge.getBaseNode();
                     long flags = edge.getFlags();
                     double adjLat = nodeAccess.getLatitude(adjNode);
                     double adjLon = nodeAccess.getLongitude(adjNode);
                     double latitude, longitude;
                     PointList wayGeo = edge.fetchWayGeometry(3);
+                    boolean isRoundabout = encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT);
                     if (wayGeo.getSize() <= 2) {
-                        // The way is a straight line
                         latitude = adjLat;
                         longitude = adjLon;
                     } else {
-                        // The way contains pillar nodes so calc angle based on
-                        // the latitude of the 1st one along.
                         latitude = wayGeo.getLatitude(1);
                         longitude = wayGeo.getLongitude(1);
-
-                        // overwrite previous lat,lon
-                        int baseNode = edge.getBaseNode();
-                        prevLat = nodeAccess.getLatitude(baseNode);
-                        prevLon = nodeAccess.getLongitude(baseNode);
+                        assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
+                        assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                     }
-
-                    double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
-                    if (name == null) {
-                        // very first instruction
-                        name = edge.getName();
-                        annotation = encoder.getAnnotation(flags, tr);
-                        prevInstruction = new Instruction(Instruction.CONTINUE_ON_STREET, name, annotation, points);
-                        updatePointsAndInstruction(edge, wayGeo);
-                        cachedWays.add(prevInstruction);
+                    name = edge.getName();
+                    annotation = encoder.getAnnotation(flags, tr);
+                    if ((prevName == null) && (!isRoundabout)) // very first
+                        // instruction (if
+                        // not in Roundabout)
+                    {
+                        int sign = Instruction.CONTINUE_ON_STREET;
+                        prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                        ways.add(prevInstruction);
+                        prevName = name;
+                        prevAnnotation = annotation;
                     } else {
-                        double tmpOrientation = ac.alignOrientation(prevOrientation, orientation);
-                        String tmpName = edge.getName();
-                        InstructionAnnotation tmpAnnotation = encoder.getAnnotation(flags, tr);
-                        if ((!name.equals(tmpName)) || (!annotation.equals(tmpAnnotation))) {
-                            points = new PointList(10, nodeAccess.is3D());
-                            name = tmpName;
-                            annotation = tmpAnnotation;
-                            double delta = Math.abs(tmpOrientation - prevOrientation);
+                        if (isRoundabout)
+                            // remark: names and annotations within roundabout are
+                            // ignored
+                        {
+                            if (!prevInRoundabout) // just entered roundabout
+                            {
+                                int sign = Instruction.USE_ROUNDABOUT;
+                                RoundaboutInstruction roundaboutInstruction = new RoundaboutInstruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                                if (prevName != null) {
+                                    // previous orientation is last orientation
+                                    // before entering roundabout
+                                    prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                                    // calculate direction of entrance turn to
+                                    // determine direction of rotation
+                                    // right turn == counterclockwise and vice versa
+                                    double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                    orientation = ac.alignOrientation(prevOrientation, orientation);
+                                    double delta = (orientation - prevOrientation);
+                                    roundaboutInstruction.setDirOfRotation(delta);
+                                } else // first instructions is roundabout
+                                    // instruction
+                                {
+                                    prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                    prevName = name;
+                                    prevAnnotation = annotation;
+                                }
+                                prevInstruction = roundaboutInstruction;
+                                ways.add(prevInstruction);
+                            }
+                            // Add passed exits to instruction. There is an exit if
+                            // there are
+                            // at least 2 out-going edges (one continuing in the
+                            // roundabout)
+                            // This could lead to problems if there are non-complete
+                            // roundabouts!
+                            EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                            edgeIter.next();
+                            if (edgeIter.next()) {
+                                ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
+                            }
+                        } else if (prevInRoundabout) // previously in roundabout but
+                            // not anymore
+                        {
+                            prevInstruction.setName(name);
+                            // calc angle between roundabout entrance and exit
+                            double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                            orientation = ac.alignOrientation(prevOrientation, orientation);
+                            double deltaInOut = (orientation - prevOrientation);
+                            // calculate direction of exit turn to determine
+                            // direction of rotation
+                            // right turn == counterclockwise and vice versa
+                            double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                            orientation = ac.alignOrientation(recentOrientation, orientation);
+                            double deltaOut = (orientation - recentOrientation);
+                            prevInstruction = ((RoundaboutInstruction) prevInstruction).setRadian(deltaInOut).setDirOfRotation(deltaOut).setExited();
+                            prevName = name;
+                            prevAnnotation = annotation;
+                        } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation))) {
+                            prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                            double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                            orientation = ac.alignOrientation(prevOrientation, orientation);
+                            double delta = orientation - prevOrientation;
+                            double absDelta = Math.abs(delta);
                             int sign;
-                            if (delta < 0.2) {
+                            if (absDelta < 0.2) {
                                 // 0.2 ~= 11°
                                 sign = Instruction.CONTINUE_ON_STREET;
-
-                            } else if (delta < 0.8) {
+                            } else if (absDelta < 0.8) {
                                 // 0.8 ~= 40°
-                                if (tmpOrientation > prevOrientation)
+                                if (delta > 0)
                                     sign = Instruction.TURN_SLIGHT_LEFT;
                                 else
                                     sign = Instruction.TURN_SLIGHT_RIGHT;
-
-                            } else if (delta < 1.8) {
+                            } else if (absDelta < 1.8) {
                                 // 1.8 ~= 103°
-                                if (tmpOrientation > prevOrientation)
+                                if (delta > 0)
                                     sign = Instruction.TURN_LEFT;
                                 else
                                     sign = Instruction.TURN_RIGHT;
-
                             } else {
-                                if (tmpOrientation > prevOrientation)
+                                if (delta > 0)
                                     sign = Instruction.TURN_SHARP_LEFT;
                                 else
                                     sign = Instruction.TURN_SHARP_RIGHT;
-
                             }
-
-                            prevInstruction = new Instruction(sign, name, annotation, points);
-                            cachedWays.add(prevInstruction);
+                            prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()));
+                            ways.add(prevInstruction);
+                            prevName = name;
+                            prevAnnotation = annotation;
                         }
-
-                        updatePointsAndInstruction(edge, wayGeo);
                     }
-
-                    prevLat = adjLat;
-                    prevLon = adjLon;
+                    updatePointsAndInstruction(edge, wayGeo);
                     if (wayGeo.getSize() <= 2) {
-                        prevOrientation = orientation;
+                        doublePrevLat = prevLat;
+                        doublePrevLong = prevLon;
                     } else {
                         int beforeLast = wayGeo.getSize() - 2;
-                        double latBeforeLast = wayGeo.getLatitude(beforeLast);
-                        double lonBeforeLast = wayGeo.getLongitude(beforeLast);
-                        prevOrientation = ac.calcOrientation(latBeforeLast, lonBeforeLast, adjLat, adjLon);
+                        doublePrevLat = wayGeo.getLatitude(beforeLast);
+                        doublePrevLong = wayGeo.getLongitude(beforeLast);
                     }
-
+                    prevInRoundabout = isRoundabout;
+                    prevLat = adjLat;
+                    prevLon = adjLon;
                     boolean lastEdge = index == edgeIds.size() - 1;
-                    if (lastEdge)
-                        cachedWays.add(new FinishInstruction(adjLat, adjLon, nodeAccess.is3D() ? nodeAccess.getElevation(adjNode) : 0));
+                    if (lastEdge) {
+                        if (isRoundabout) {
+                            // calc angle between roundabout entrance and finish
+                            double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                            orientation = ac.alignOrientation(prevOrientation, orientation);
+                            double delta = (orientation - prevOrientation);
+                            ((RoundaboutInstruction) prevInstruction).setRadian(delta);
+                        }
+                        ways.add(new FinishInstruction(nodeAccess, adjNode));
+                    }
                 }
             }
 
@@ -459,7 +519,7 @@ private void updatePointsAndInstruction(EdgeIteratorState edge, PointList pl) {
                 // skip adjNode
                 int len = pl.size() - 1;
                 for (int i = 0; i < len; i++) {
-                    points.add(pl, i);
+                    prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
@@ -467,35 +527,7 @@ private void updatePointsAndInstruction(EdgeIteratorState edge, PointList pl) {
                 prevInstruction.setTime(calcMillis(newDist, flags, false) + prevInstruction.getTime());
             }
         });
-
-        return cachedWays;
-    }
-
-    public Instruction findInstruction(double lat, double lon) {
-        DistanceCalcEarth distanceCalc = new DistanceCalcEarth();
-
-        double distanceToPath = Double.MAX_VALUE;
-
-        int nextInstrNumber = 0;
-
-        // Search the closest edge to the point
-        for (int i = 0; i < cachedWays.getSize() - 1; i++) {
-            double edgeNodeLat1 = cachedWays.get(i).getPoints().getLatitude(0);
-            double edgeNodeLon1 = cachedWays.get(i).getPoints().getLongitude(0);
-            int node2NOP = cachedWays.get(i + 1).getPoints().getSize();
-            double edgeNodeLat2 = cachedWays.get(i + 1).getPoints().getLatitude(node2NOP - 1);
-            double edgeNodeLon2 = cachedWays.get(i + 1).getPoints().getLongitude(node2NOP - 1);
-
-            // Calculate the distance from the point to the edge
-            double distanceToEdge = distanceCalc.calcNormalizedEdgeDistance(lat, lon, edgeNodeLat1, edgeNodeLon1, edgeNodeLat2, edgeNodeLon2);
-
-            if (distanceToEdge < distanceToPath) {
-                distanceToPath = distanceToEdge;
-                nextInstrNumber = i + 1;
-            }
-        }
-
-        return cachedWays.get(nextInstrNumber);
+        return ways;
     }
 
     @Override
@@ -508,9 +540,8 @@ public String toDetailsString() {
         for (int i = 0; i < edgeIds.size(); i++) {
             if (i > 0)
                 str += "->";
-
             str += edgeIds.get(i);
         }
-        return toString() + ", " + str;
+        return toString() + ", found:" + isFound() + ", " + str;
     }
-}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index 06717a6d82..3ae0152479 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -21,7 +21,6 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.GHUtility;
 
 /**
  * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
@@ -66,8 +65,6 @@ public Path extract()
         if (edgeEntry == null || edgeTo == null)
             return this;
 
-//        int from = GHUtility.getAdjNode(graph, edgeEntry.edge, );
-//        int to = GHUtility.getAdjNode(graph, edgeTo.edge, );
         if (edgeEntry.adjNode != edgeTo.adjNode)
             throw new IllegalStateException("Locations of the 'to'- and 'from'-Edge has to be the same." + toString() + ", fromEntry:" + edgeEntry + ", toEntry:" + edgeTo);
 
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index c92b2b64c6..ffbb943041 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -19,8 +19,7 @@
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -52,6 +51,8 @@
     private final NodeAccess mainNodeAccess;
     private final int mainNodes;
     private final int mainEdges;
+    private final QueryGraph baseGraph;
+    private final GraphExtension wrappedExtension;
     private List<QueryResult> queryResults;
     /**
      * Virtual edges are created between existing graph and new virtual tower nodes. For every
@@ -64,14 +65,46 @@
      * Store lat,lon of virtual tower nodes.
      */
     private PointList virtualNodes;
-    private final DistanceCalc distCalc = new DistancePlaneProjection();
 
     public QueryGraph( Graph graph )
     {
         mainGraph = graph;
         mainNodeAccess = graph.getNodeAccess();
         mainNodes = graph.getNodes();
-        mainEdges = graph.getAllEdges().getMaxId();
+        mainEdges = graph.getAllEdges().getCount();
+
+        if (mainGraph.getExtension() instanceof TurnCostExtension)
+            wrappedExtension = new QueryGraphTurnExt(this);
+        else
+            wrappedExtension = mainGraph.getExtension();
+
+        // create very lightweight QueryGraph which uses variables from this QueryGraph (same virtual edges)
+        baseGraph = new QueryGraph(graph.getBaseGraph(), this);
+    }
+
+    /**
+     * See 'lookup' for further variables that are initialized
+     */
+    private QueryGraph( Graph graph, QueryGraph superQueryGraph )
+    {
+        mainGraph = graph;
+        baseGraph = this;
+        wrappedExtension = superQueryGraph.wrappedExtension;
+        mainNodeAccess = graph.getNodeAccess();
+        mainNodes = superQueryGraph.mainNodes;
+        mainEdges = superQueryGraph.mainEdges;
+    }
+
+    /**
+     * Convenient method to initialize this QueryGraph with the two specified query results.
+     */
+    public QueryGraph lookup( QueryResult fromRes, QueryResult toRes )
+    {
+        List<QueryResult> results = new ArrayList<QueryResult>(2);
+        results.add(fromRes);
+        results.add(toRes);
+        lookup(results);
+        return this;
     }
 
     /**
@@ -83,9 +116,13 @@ public void lookup( List<QueryResult> resList )
         if (isInitialized())
             throw new IllegalStateException("Call lookup only once. Otherwise you'll have problems for queries sharing the same edge.");
 
+        // initialize all none-final variables
         virtualEdges = new ArrayList<EdgeIteratorState>(resList.size() * 2);
         virtualNodes = new PointList(resList.size(), mainNodeAccess.is3D());
         queryResults = new ArrayList<QueryResult>(resList.size());
+        baseGraph.virtualEdges = virtualEdges;
+        baseGraph.virtualNodes = virtualNodes;
+        baseGraph.queryResults = queryResults;
 
         TIntObjectMap<List<QueryResult>> edge2res = new TIntObjectHashMap<List<QueryResult>>(resList.size());
 
@@ -95,9 +132,13 @@ public void lookup( List<QueryResult> resList )
         {
             // Do not create virtual node for a query result if it is directly on a tower node or not found
             EdgeIteratorState closestEdge = res.getClosestEdge();
-            if (res.getSnappedPosition() == QueryResult.Position.TOWER || closestEdge == null)
+
+            if (res.getSnappedPosition() == QueryResult.Position.TOWER)
                 continue;
 
+            if (closestEdge == null)
+                throw new IllegalStateException("Do not call QueryGraph.lookup with invalid QueryResult " + res);
+
             int base = closestEdge.getBaseNode();
 
             // Force the identical direction for all closest edges. 
@@ -167,8 +208,8 @@ public int compare( QueryResult o1, QueryResult o2 )
 
                             double fromLat = fullPL.getLatitude(o1.getWayIndex());
                             double fromLon = fullPL.getLongitude(o1.getWayIndex());
-                            if (distCalc.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
-                                    > distCalc.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
+                            if (Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
+                                    > Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
                                 return 1;
                             return -1;
                         }
@@ -181,18 +222,28 @@ public int compare( QueryResult o1, QueryResult o2 )
                 long reverseFlags = closestEdge.detach(true).getFlags();
                 int prevWayIndex = 1;
                 int prevNodeId = baseNode;
-                int counter = 0;
                 int virtNodeId = virtualNodes.getSize() + mainNodes;
-                // Create base and adjacent PointLists for all virtual nodes!
+                boolean addedEdges = false;
+
+                // Create base and adjacent PointLists for all none-equal virtual nodes.
                 // We do so via inserting them at the correct position of fullPL and cutting the                
                 // fullPL into the right pieces.
-                for (QueryResult res : results)
+                for (int counter = 0; counter < results.size(); counter++)
                 {
+                    QueryResult res = results.get(counter);
                     if (res.getClosestEdge().getBaseNode() != baseNode)
                         throw new IllegalStateException("Base nodes have to be identical but were not: " + closestEdge + " vs " + res.getClosestEdge());
 
-                    queryResults.add(res);
                     GHPoint3D currSnapped = res.getSnappedPoint();
+
+                    // no new virtual nodes if exactly the same snapped point
+                    if (prevPoint.equals(currSnapped))
+                    {
+                        res.setClosestNode(prevNodeId);
+                        continue;
+                    }
+
+                    queryResults.add(res);
                     createEdges(prevPoint, prevWayIndex,
                             res.getSnappedPoint(), res.getWayIndex(),
                             fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
@@ -200,29 +251,83 @@ public int compare( QueryResult o1, QueryResult o2 )
                     virtualNodes.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
                     // add edges again to set adjacent edges for newVirtNodeId
-                    if (counter > 0)
+                    if (addedEdges)
                     {
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                         virtualEdges.add(virtualEdges.get(virtualEdges.size() - 2));
                     }
 
+                    addedEdges = true;
                     res.setClosestNode(virtNodeId);
                     prevNodeId = virtNodeId;
                     prevWayIndex = res.getWayIndex() + 1;
                     prevPoint = currSnapped;
-                    counter++;
                     virtNodeId++;
                 }
 
-                // two edges between last result and adjacent node are still missing
-                createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
-                        fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
+                // two edges between last result and adjacent node are still missing if not all points skipped
+                if (addedEdges)
+                    createEdges(prevPoint, prevWayIndex, fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                            fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
 
                 return true;
             }
         });
     }
 
+    @Override
+    public Graph getBaseGraph()
+    {
+        // Note: if the mainGraph of this QueryGraph is a LevelGraph then ignoring the shortcuts will produce a 
+        // huge gap of edgeIds between base and virtual edge ids. The only solution would be to move virtual edges
+        // directly after normal edge ids which is ugly as we limit virtual edges to N edges and waste memory or make everything more complex.        
+        return baseGraph;
+    }
+
+    public boolean isVirtualEdge( int edgeId )
+    {
+        return edgeId >= mainEdges;
+    }
+
+    public boolean isVirtualNode( int nodeId )
+    {
+        return nodeId >= mainNodes;
+    }
+
+    class QueryGraphTurnExt extends TurnCostExtension
+    {
+        private final TurnCostExtension mainTurnExtension;
+
+        public QueryGraphTurnExt( QueryGraph qGraph )
+        {
+            this.mainTurnExtension = (TurnCostExtension) mainGraph.getExtension();
+        }
+
+        @Override
+        public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
+        {
+            if (isVirtualNode(nodeVia))
+            {
+                return 0;
+            } else if (isVirtualEdge(edgeFrom) || isVirtualEdge(edgeTo))
+            {
+                if (isVirtualEdge(edgeFrom))
+                {
+                    edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                if (isVirtualEdge(edgeTo))
+                {
+                    edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
+                }
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+
+            } else
+            {
+                return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
+            }
+        }
+    }
+
     private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
             PointList fullPL, EdgeIteratorState closestEdge,
             int prevNodeId, int nodeId, long reverseFlags )
@@ -238,8 +343,8 @@ private void createEdges( GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D cur
         basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
         PointList baseReversePoints = basePoints.clone(true);
-        double baseDistance = basePoints.calcDistance(distCalc);
-        int virtEdgeId = virtualEdges.size() + mainEdges;
+        double baseDistance = basePoints.calcDistance(Helper.DIST_PLANE);
+        int virtEdgeId = mainEdges + virtualEdges.size();
 
         // edges between base and snapped point
         VirtualEdgeIState baseEdge = new VirtualEdgeIState(virtEdgeId, prevNodeId, nodeId,
@@ -265,6 +370,12 @@ public NodeAccess getNodeAccess()
 
     private final NodeAccess nodeAccess = new NodeAccess()
     {
+        @Override
+        public void ensureNode( int nodeId )
+        {
+            mainNodeAccess.ensureNode(nodeId);
+        }
+
         @Override
         public boolean is3D()
         {
@@ -280,7 +391,7 @@ public int getDimension()
         @Override
         public double getLatitude( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getLatitude(nodeId - mainNodes);
             return mainNodeAccess.getLatitude(nodeId);
         }
@@ -288,7 +399,7 @@ public double getLatitude( int nodeId )
         @Override
         public double getLongitude( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getLongitude(nodeId - mainNodes);
             return mainNodeAccess.getLongitude(nodeId);
         }
@@ -296,7 +407,7 @@ public double getLongitude( int nodeId )
         @Override
         public double getElevation( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return virtualNodes.getElevation(nodeId - mainNodes);
             return mainNodeAccess.getElevation(nodeId);
         }
@@ -304,7 +415,7 @@ public double getElevation( int nodeId )
         @Override
         public int getAdditionalNodeField( int nodeId )
         {
-            if (nodeId >= mainNodes)
+            if (isVirtualNode(nodeId))
                 return 0;
             return mainNodeAccess.getAdditionalNodeField(nodeId);
         }
@@ -355,7 +466,7 @@ public BBox getBounds()
     @Override
     public EdgeIteratorState getEdgeProps( int origEdgeId, int adjNode )
     {
-        if (origEdgeId < mainEdges)
+        if (!isVirtualEdge(origEdgeId))
             return mainGraph.getEdgeProps(origEdgeId, adjNode);
 
         int edgeId = origEdgeId - mainEdges;
@@ -406,10 +517,12 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
             int virtNode = mainNodes + i;
             node2EdgeMap.put(virtNode, virtEdgeIter);
 
-            // replace edge list of neighboring tower nodes: a) add virtual edges only and collect tower nodes where real edges will be added in step 2.
+            // replace edge list of neighboring tower nodes: 
+            // add virtual edges only and collect tower nodes where real edges will be added in step 2.
+            //
             // base node
             int towerNode = baseRevEdge.getAdjNode();
-            if (towerNode < mainNodes)
+            if (!isVirtualNode(towerNode))
             {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, true, towerNode, i);
@@ -417,7 +530,7 @@ public EdgeExplorer createEdgeExplorer( final EdgeFilter edgeFilter )
 
             // adj node
             towerNode = adjEdge.getAdjNode();
-            if (towerNode < mainNodes)
+            if (!isVirtualNode(towerNode))
             {
                 towerNodesToChange.add(towerNode);
                 addVirtualEdges(node2EdgeMap, edgeFilter, false, towerNode, i);
@@ -472,8 +585,8 @@ private void addVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2EdgeMap, E
 
     void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
     {
-        if (towerNode >= mainNodes)
-            throw new IllegalStateException("should not happen:" + towerNode + ", " + node2Edge);
+        if (isVirtualNode(towerNode))
+            throw new IllegalStateException("Node should not be virtual:" + towerNode + ", " + node2Edge);
 
         VirtualEdgeIterator vIter = node2Edge.get(towerNode);
         TIntArrayList ignoreEdges = new TIntArrayList(vIter.count() * 2);
@@ -531,360 +644,14 @@ public Graph copyTo( Graph g )
         throw exc();
     }
 
-    private UnsupportedOperationException exc()
+    @Override
+    public GraphExtension getExtension()
     {
-        return new UnsupportedOperationException("QueryGraph cannot be modified.");
+        return wrappedExtension;
     }
 
-    static class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState
-    {
-
-        private final List<EdgeIteratorState> edges;
-        private int current;
-
-        public VirtualEdgeIterator( int edgeCount )
-        {
-            edges = new ArrayList<EdgeIteratorState>(edgeCount);
-            reset();
-        }
-
-        void add( EdgeIteratorState edge )
-        {
-            edges.add(edge);
-        }
-
-        EdgeIterator reset()
-        {
-            current = -1;
-            return this;
-        }
-
-        int count()
-        {
-            return edges.size();
-        }
-
-        @Override
-        public boolean next()
-        {
-            current++;
-            return current < edges.size();
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverse )
-        {
-            if (reverse)
-                throw new IllegalStateException("Not yet supported");
-
-            return edges.get(current);
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return edges.get(current).getEdge();
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return edges.get(current).getBaseNode();
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return edges.get(current).getAdjNode();
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            return edges.get(current).fetchWayGeometry(mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            return edges.get(current).setWayGeometry(list);
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return edges.get(current).getDistance();
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            return edges.get(current).setDistance(dist);
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return edges.get(current).getFlags();
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            return edges.get(current).setFlags(flags);
-        }
-
-        @Override
-        public String getName()
-        {
-            return edges.get(current).getName();
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            return edges.get(current).setName(name);
-        }
-
-        @Override
-        public String toString()
-        {
-            return edges.toString();
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            return edges.get(current).getAdditionalField();
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            return edges.get(current).setAdditionalField(value);
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            return edges.get(current).copyPropertiesTo(edge);
-        }
-
-        @Override
-        public boolean isShortcut()
-        {
-            EdgeIteratorState edge = edges.get(current);
-            return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
-        }
-
-        @Override
-        public double getWeight()
-        {
-            // will be called only from PreparationWeighting and if isShortcut is true
-            return ((EdgeSkipIterState) edges.get(current)).getWeight();
-        }
-
-        @Override
-        public EdgeSkipIterState setWeight( double weight )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge1()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge2()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void setSkippedEdges( int edge1, int edge2 )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-    }
-
-    /**
-     * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
-     */
-    private static class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState
+    private UnsupportedOperationException exc()
     {
-
-        private final PointList pointList;
-        private final int edgeId;
-        private double distance;
-        private long flags;
-        private String name;
-        private final int baseNode;
-        private final int adjNode;
-
-        public VirtualEdgeIState( int edgeId, int baseNode, int adjNode,
-                double distance, long flags, String name, PointList pointList )
-        {
-            this.edgeId = edgeId;
-            this.baseNode = baseNode;
-            this.adjNode = adjNode;
-            this.distance = distance;
-            this.flags = flags;
-            this.name = name;
-            this.pointList = pointList;
-        }
-
-        @Override
-        public int getEdge()
-        {
-            return edgeId;
-        }
-
-        @Override
-        public int getBaseNode()
-        {
-            return baseNode;
-        }
-
-        @Override
-        public int getAdjNode()
-        {
-            return adjNode;
-        }
-
-        @Override
-        public PointList fetchWayGeometry( int mode )
-        {
-            if (pointList.getSize() == 0)
-                return PointList.EMPTY;
-
-            // due to API we need to create a new instance per call!
-            if (mode == 3)
-                return pointList.clone(false);
-            else if (mode == 1)
-                return pointList.copy(0, pointList.getSize() - 1);
-            else if (mode == 2)
-                return pointList.copy(1, pointList.getSize());
-            else if (mode == 0)
-            {
-                if (pointList.getSize() == 1)
-                    return PointList.EMPTY;
-                return pointList.copy(1, pointList.getSize() - 1);
-            }
-
-            throw new UnsupportedOperationException("Illegal mode:" + mode);
-        }
-
-        @Override
-        public EdgeIteratorState setWayGeometry( PointList list )
-        {
-            throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
-        }
-
-        @Override
-        public double getDistance()
-        {
-            return distance;
-        }
-
-        @Override
-        public EdgeIteratorState setDistance( double dist )
-        {
-            this.distance = dist;
-            return this;
-        }
-
-        @Override
-        public long getFlags()
-        {
-            return flags;
-        }
-
-        @Override
-        public EdgeIteratorState setFlags( long flags )
-        {
-            this.flags = flags;
-            return this;
-        }
-
-        @Override
-        public String getName()
-        {
-            return name;
-        }
-
-        @Override
-        public EdgeIteratorState setName( String name )
-        {
-            this.name = name;
-            return this;
-        }
-
-        @Override
-        public String toString()
-        {
-            return baseNode + "->" + adjNode;
-        }
-
-        @Override
-        public boolean isShortcut()
-        {
-            return false;
-        }
-
-        @Override
-        public int getAdditionalField()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge1()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public int getSkippedEdge2()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public void setSkippedEdges( int edge1, int edge2 )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState detach( boolean reverse )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState setAdditionalField( int value )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public EdgeSkipIterState setWeight( double weight )
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
-
-        @Override
-        public double getWeight()
-        {
-            throw new UnsupportedOperationException("Not supported.");
-        }
+        return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
index b1ee8174c5..b7a5abf53c 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithm.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.NotThreadSafe;
 
 /**
@@ -36,15 +35,10 @@
     Path calcPath( int from, int to );
 
     /**
-     * Calculates the best path between the specified query results from GPS lookup.
-     * <p/>
-     * Note: The underlying implementation introduces a state of the algorithm and so it is tightly
-     * coupled to the query! Reusing this instance should be done carefully: only from within one
-     * thread and only via this calcPath method.
-     * <p/>
-     * @return the path. Call the method found() to make sure that the path is valid.
+     * Limits the search to avoid full graph exploration in the case of disconnected networks. The
+     * default value is Double.MAX_VALUE. See #104
      */
-    Path calcPath( QueryResult from, QueryResult to );
+    void setWeightLimit( double weight );
 
     /**
      * @return name of this algorithm
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
index 6cb5c54455..58d0f17a3a 100644
--- a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactory.java
@@ -17,51 +17,12 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 
 /**
  * @author Peter Karich
  */
-public class RoutingAlgorithmFactory
+public interface RoutingAlgorithmFactory
 {
-    private final String algoStr;
-    private final boolean approx;
-    private final TraversalMode traversalMode;
-
-    /**
-     * @param algo possible values are astar (A* algorithm), astarbi (bidirectional A*), dijkstra
-     * (Dijkstra) or dijkstrabi.
-     */
-    public RoutingAlgorithmFactory( String algo, boolean approx, TraversalMode tMode )
-    {
-        this.algoStr = algo;
-        this.approx = approx;
-        this.traversalMode = tMode;
-    }
-
-    public RoutingAlgorithm createAlgo( Graph g, FlagEncoder encoder, Weighting weighting )
-    {
-        AbstractRoutingAlgorithm algo;
-        if ("dijkstrabi".equalsIgnoreCase(algoStr))
-        {
-            algo = new DijkstraBidirectionRef(g, encoder, weighting, traversalMode);        
-        } else if ("dijkstra".equalsIgnoreCase(algoStr))
-        {
-            algo = new Dijkstra(g, encoder, weighting, traversalMode);
-        } else if ("astarbi".equalsIgnoreCase(algoStr))
-        {
-            algo = new AStarBidirection(g, encoder, weighting, traversalMode).setApproximation(approx);
-        } else if ("dijkstraOneToMany".equalsIgnoreCase(algoStr))
-        {
-            algo = new DijkstraOneToMany(g, encoder, weighting, traversalMode);
-        } else
-        {
-            algo = new AStar(g, encoder, weighting, traversalMode);
-        }
-        
-        return algo;
-    }
+    RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts );   
 }
diff --git a/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
new file mode 100644
index 0000000000..ae6609148f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/RoutingAlgorithmFactorySimple.java
@@ -0,0 +1,84 @@
+/*
+ *  Licensed to GraphHopper and Peter Karich under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.util.BeelineWeightApproximator;
+import com.graphhopper.routing.util.WeightApproximator;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.Helper;
+
+/**
+ * A simple factory creating normal algorithms (RoutingAlgorithm) without preparation.
+ * <p>
+ * @author Peter Karich
+ */
+public class RoutingAlgorithmFactorySimple implements RoutingAlgorithmFactory
+{
+    @Override
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
+    {        
+        AbstractRoutingAlgorithm algo;
+        String algoStr = opts.getAlgorithm();
+        if (AlgorithmOptions.DIJKSTRA_BI.equalsIgnoreCase(algoStr))
+        {
+            return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.DIJKSTRA.equalsIgnoreCase(algoStr))
+        {
+            return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.ASTAR_BI.equalsIgnoreCase(algoStr))
+        {
+            AStarBidirection aStarBi = new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(),
+                    opts.getTraversalMode());
+            aStarBi.setApproximation(getApproximation(AlgorithmOptions.ASTAR_BI, opts, g.getNodeAccess()));
+            return aStarBi;
+        } else if (AlgorithmOptions.DIJKSTRA_ONE_TO_MANY.equalsIgnoreCase(algoStr))
+        {
+            return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+        } else if (AlgorithmOptions.ASTAR.equalsIgnoreCase(algoStr))
+        {
+            AStar aStar = new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), opts.getTraversalMode());
+            aStar.setApproximation(getApproximation(AlgorithmOptions.ASTAR, opts, g.getNodeAccess()));
+            return aStar;
+        } else
+        {
+            throw new IllegalArgumentException("Algorithm " + algoStr + " not found in " + getClass().getName());
+        }
+
+    }
+
+    private WeightApproximator getApproximation( String prop, AlgorithmOptions opts, NodeAccess na )
+    {
+        String approxAsStr = opts.getHints().get(prop + ".approximation", "BeelineSimplification");
+        if ("BeelineSimplification".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_PLANE);
+            return approx;
+
+        } else if ("BeelineAccurate".equals(approxAsStr))
+        {
+            BeelineWeightApproximator approx = new BeelineWeightApproximator(na, opts.getWeighting());
+            approx.setDistanceCalc(Helper.DIST_EARTH);
+            return approx;
+        } else
+        {
+            throw new IllegalArgumentException("Approximation " + approxAsStr + " not found in " + getClass().getName());
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
new file mode 100644
index 0000000000..9552052d02
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIState.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.PointList;
+
+/**
+ * Creates an edge state decoupled from a graph where nodes, pointList, etc are kept in memory.
+ */
+class VirtualEdgeIState implements EdgeIteratorState, EdgeSkipIterState {
+    private final PointList pointList;
+    private final int edgeId;
+    private double distance;
+    private long flags;
+    private String name;
+    private final int baseNode;
+    private final int adjNode;
+
+    public VirtualEdgeIState( int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList )
+    {
+        this.edgeId = edgeId;
+        this.baseNode = baseNode;
+        this.adjNode = adjNode;
+        this.distance = distance;
+        this.flags = flags;
+        this.name = name;
+        this.pointList = pointList;
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edgeId;
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return baseNode;
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return adjNode;
+    }
+
+    @Override
+    public PointList fetchWayGeometry( int mode )
+    {
+        if (pointList.getSize() == 0)
+            return PointList.EMPTY;
+        // due to API we need to create a new instance per call!
+        if (mode == 3)
+            return pointList.clone(false);
+        else if (mode == 1)
+            return pointList.copy(0, pointList.getSize() - 1);
+        else if (mode == 2)
+            return pointList.copy(1, pointList.getSize());
+        else if (mode == 0)
+        {
+            if (pointList.getSize() == 1)
+                return PointList.EMPTY;
+            return pointList.copy(1, pointList.getSize() - 1);
+        }
+        throw new UnsupportedOperationException("Illegal mode:" + mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry( PointList list )
+    {
+        throw new UnsupportedOperationException("Not supported for virtual edge. Set when creating it.");
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return distance;
+    }
+
+    @Override
+    public EdgeIteratorState setDistance( double dist )
+    {
+        this.distance = dist;
+        return this;
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return flags;
+    }
+
+    @Override
+    public EdgeIteratorState setFlags( long flags )
+    {
+        this.flags = flags;
+        return this;
+    }
+
+    @Override
+    public String getName()
+    {
+        return name;
+    }
+
+    @Override
+    public EdgeIteratorState setName( String name )
+    {
+        this.name = name;
+        return this;
+    }
+
+    @Override
+    public String toString()
+    {
+        return baseNode + "->" + adjNode;
+    }
+
+    @Override
+    public boolean isShortcut()
+    {
+        return false;
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge1()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge2()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setSkippedEdges( int edge1, int edge2 )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState detach( boolean reverse )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField( int value )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public EdgeSkipIterState setWeight( double weight )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public double getWeight()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+    
+}
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
new file mode 100644
index 0000000000..22abb0004f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2015 Peter Karich.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.PointList;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ *
+ * @author Peter Karich
+ */
+class VirtualEdgeIterator implements EdgeIterator, EdgeSkipIterState {
+    private final List<EdgeIteratorState> edges;
+    private int current;
+
+    public VirtualEdgeIterator( int edgeCount )
+    {
+        edges = new ArrayList<EdgeIteratorState>(edgeCount);
+        reset();
+    }
+
+    void add( EdgeIteratorState edge )
+    {
+        edges.add(edge);
+    }
+
+    EdgeIterator reset()
+    {
+        current = -1;
+        return this;
+    }
+
+    int count()
+    {
+        return edges.size();
+    }
+
+    @Override
+    public boolean next()
+    {
+        current++;
+        return current < edges.size();
+    }
+
+    @Override
+    public EdgeIteratorState detach( boolean reverse )
+    {
+        if (reverse)
+            throw new IllegalStateException("Not yet supported");
+        return edges.get(current);
+    }
+
+    @Override
+    public int getEdge()
+    {
+        return edges.get(current).getEdge();
+    }
+
+    @Override
+    public int getBaseNode()
+    {
+        return edges.get(current).getBaseNode();
+    }
+
+    @Override
+    public int getAdjNode()
+    {
+        return edges.get(current).getAdjNode();
+    }
+
+    @Override
+    public PointList fetchWayGeometry( int mode )
+    {
+        return edges.get(current).fetchWayGeometry(mode);
+    }
+
+    @Override
+    public EdgeIteratorState setWayGeometry( PointList list )
+    {
+        return edges.get(current).setWayGeometry(list);
+    }
+
+    @Override
+    public double getDistance()
+    {
+        return edges.get(current).getDistance();
+    }
+
+    @Override
+    public EdgeIteratorState setDistance( double dist )
+    {
+        return edges.get(current).setDistance(dist);
+    }
+
+    @Override
+    public long getFlags()
+    {
+        return edges.get(current).getFlags();
+    }
+
+    @Override
+    public EdgeIteratorState setFlags( long flags )
+    {
+        return edges.get(current).setFlags(flags);
+    }
+
+    @Override
+    public String getName()
+    {
+        return edges.get(current).getName();
+    }
+
+    @Override
+    public EdgeIteratorState setName( String name )
+    {
+        return edges.get(current).setName(name);
+    }
+
+    @Override
+    public String toString()
+    {
+        return edges.toString();
+    }
+
+    @Override
+    public int getAdditionalField()
+    {
+        return edges.get(current).getAdditionalField();
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField( int value )
+    {
+        return edges.get(current).setAdditionalField(value);
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesTo( EdgeIteratorState edge )
+    {
+        return edges.get(current).copyPropertiesTo(edge);
+    }
+
+    @Override
+    public boolean isShortcut()
+    {
+        EdgeIteratorState edge = edges.get(current);
+        return edge instanceof EdgeSkipIterState && ((EdgeSkipIterState) edge).isShortcut();
+    }
+
+    @Override
+    public double getWeight()
+    {
+        // will be called only from PreparationWeighting and if isShortcut is true
+        return ((EdgeSkipIterState) edges.get(current)).getWeight();
+    }
+
+    @Override
+    public EdgeSkipIterState setWeight( double weight )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge1()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getSkippedEdge2()
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setSkippedEdges( int edge1, int edge2 )
+    {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+    
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 54807733e7..fe8163b088 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -30,17 +30,20 @@
  */
 public class Path4CH extends PathBidirRef
 {
-    public Path4CH( Graph g, FlagEncoder encoder )
+    private final Graph routingGraph;
+
+    public Path4CH( Graph routingGraph, Graph baseGraph, FlagEncoder encoder )
     {
-        super(g, encoder);
+        super(baseGraph, encoder);
+        this.routingGraph = routingGraph;
     }
 
     @Override
-    protected void processEdge( int tmpEdge, int endNode )
+    protected final void processEdge( int tmpEdge, int endNode )
     {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((EdgeSkipIterState) graph.getEdgeProps(tmpEdge, endNode), false);
+        expandEdge((EdgeSkipIterState) routingGraph.getEdgeProps(tmpEdge, endNode), false);
     }
 
     private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
@@ -58,6 +61,8 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         int skippedEdge1 = mainEdgeState.getSkippedEdge1();
         int skippedEdge2 = mainEdgeState.getSkippedEdge2();
         int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
+
+        // get properties like speed of the edge in the correct direction
         if (reverse)
         {
             int tmp = from;
@@ -68,32 +73,32 @@ private void expandEdge( EdgeSkipIterState mainEdgeState, boolean reverse )
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
         if (reverseOrder)
         {
-            EdgeSkipIterState edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+            EdgeSkipIterState edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             boolean empty = edgeState == null;
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(edgeState, false);
 
             if (empty)
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             else
-                edgeState = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                edgeState = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(edgeState, true);
         } else
         {
-            EdgeSkipIterState iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, from);
+            EdgeSkipIterState iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, from);
             boolean empty = iter == null;
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, from);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, from);
 
             expandEdge(iter, true);
 
             if (empty)
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge1, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge1, to);
             else
-                iter = (EdgeSkipIterState) graph.getEdgeProps(skippedEdge2, to);
+                iter = (EdgeSkipIterState) routingGraph.getEdgeProps(skippedEdge2, to);
 
             expandEdge(iter, false);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index fd3006faf1..9fa3bf8ed4 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -37,13 +37,13 @@ public PreparationWeighting( Weighting userWeighting )
     }
 
     @Override
-    public double getMinWeight( double distance )
+    public final double getMinWeight( double distance )
     {
         return userWeighting.getMinWeight(distance);
     }
 
     @Override
-    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId)
+    public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId )
     {
         if (edgeState instanceof EdgeSkipIterState)
         {
@@ -60,9 +60,4 @@ public String toString()
     {
         return "PREPARE+" + userWeighting.toString();
     }
-
-    Weighting getUserWeighting()
-    {
-        return userWeighting;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 8a79b645fb..ad64b3b922 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -49,7 +49,7 @@
  * <p/>
  * @author Peter Karich
  */
-public class PrepareContractionHierarchies extends AbstractAlgoPreparation<PrepareContractionHierarchies>
+public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final PreparationWeighting prepareWeighting;
@@ -60,15 +60,17 @@
     private EdgeSkipExplorer vehicleAllExplorer;
     private EdgeSkipExplorer vehicleAllTmpExplorer;
     private EdgeSkipExplorer calcPrioAllExplorer;
-    private LevelGraph g;
+    private LevelEdgeFilter levelFilter;
+    private int maxLevel;
+    private final LevelGraph prepareGraph;
+
     // the most important nodes comes last
     private GHTreeMapComposed sortedNodes;
     private int oldPriorities[];
     private final DataAccess originalEdges;
     private final Map<Shortcut, Shortcut> shortcuts = new HashMap<Shortcut, Shortcut>();
     private IgnoreNodeFilter ignoreNodeFilter;
-    private DijkstraOneToMany algo;
-    private boolean removesHigher2LowerEdges = true;
+    private DijkstraOneToMany prepareAlgo;
     private long counter;
     private int newShortcuts;
     private long dijkstraCount;
@@ -83,8 +85,9 @@
     private double nodesContractedPercentage = 100;
     private double logMessagesPercentage = 20;
 
-    public PrepareContractionHierarchies( FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
+    public PrepareContractionHierarchies( LevelGraph g, FlagEncoder encoder, Weighting weighting, TraversalMode traversalMode )
     {
+        this.prepareGraph = g;
         this.traversalMode = traversalMode;
         this.prepareFlagEncoder = encoder;
         long scFwdDir = encoder.setAccess(0, true, false);
@@ -95,17 +98,10 @@ public PrepareContractionHierarchies( FlagEncoder encoder, Weighting weighting,
                     + "It seems that you have imported more than one.");
 
         prepareWeighting = new PreparationWeighting(weighting);
-        originalEdges = new GHDirectory("", DAType.RAM_INT).find("originalEdges");
+        originalEdges = new GHDirectory("", DAType.RAM_INT).find("original_edges");
         originalEdges.create(1000);
     }
 
-    @Override
-    public PrepareContractionHierarchies setGraph( Graph g )
-    {
-        this.g = (LevelGraph) g;
-        return this;
-    }
-
     /**
      * The higher the values are the longer the preparation takes but the less shortcuts are
      * produced.
@@ -188,22 +184,9 @@ public void setInitialCollectionSize( int initialCollectionSize )
         this.initialCollectionSize = initialCollectionSize;
     }
 
-    /**
-     * Disconnect is very important to improve query time and preparation if enabled. It will remove
-     * the edge going from the higher level node to the currently contracted one. But the original
-     * graph is no longer available, so it is only useful for bidirectional CH algorithms. Default
-     * is true.
-     */
-    public PrepareContractionHierarchies setRemoveHigher2LowerEdges( boolean removeHigher2LowerEdges )
-    {
-        this.removesHigher2LowerEdges = removeHigher2LowerEdges;
-        return this;
-    }
-
     @Override
-    public PrepareContractionHierarchies doWork()
+    public void doWork()
     {
-        checkGraph();
         if (prepareFlagEncoder == null)
             throw new IllegalStateException("No vehicle encoder set.");
 
@@ -215,18 +198,17 @@ public PrepareContractionHierarchies doWork()
 
         initFromGraph();
         if (!prepareEdges())
-            return this;
+            return;
 
         if (!prepareNodes())
-            return this;
+            return;
 
         contractNodes();
-        return this;
     }
 
     boolean prepareEdges()
     {
-        EdgeIterator iter = g.getAllEdges();
+        EdgeIterator iter = prepareGraph.getAllEdges();
         int c = 0;
         while (iter.next())
         {
@@ -236,15 +218,15 @@ boolean prepareEdges()
         return c > 0;
     }
 
-    // TODO we can avoid node level if we store this into a temporary array and 
-    // disconnect all edges which goes from higher to lower level
-    // uninitialized nodes have a level of 0
-    // TODO we could avoid the second storage for skippedEdge as we could store that info into linkB or A if it is disconnected
     boolean prepareNodes()
     {
-        int len = g.getNodes();
+        int nodes = prepareGraph.getNodes();
+        for (int node = 0; node < nodes; node++)
+        {
+            prepareGraph.setLevel(node, maxLevel);
+        }
 
-        for (int node = 0; node < len; node++)
+        for (int node = 0; node < nodes; node++)
         {
             int priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
@@ -258,7 +240,7 @@ boolean prepareNodes()
 
     void contractNodes()
     {
-        meanDegree = g.getAllEdges().getMaxId() / g.getNodes();
+        meanDegree = prepareGraph.getAllEdges().getCount() / prepareGraph.getNodes();
         int level = 1;
         counter = 0;
         int initSize = sortedNodes.getSize();
@@ -277,7 +259,7 @@ void contractNodes()
 
         // disable as preparation is slower and query time does not benefit
         long lastNodesLazyUpdates = lastNodesLazyUpdatePercentage == 0
-                ? 0l
+                ? 0L
                 : Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
@@ -293,7 +275,7 @@ void contractNodes()
             neighborUpdate = false;
 
         StopWatch neighborSW = new StopWatch();
-        LevelGraphStorage lg = ((LevelGraphStorage) g);
+        LevelGraphStorage levelGraphCast = ((LevelGraphStorage) prepareGraph);
         while (!sortedNodes.isEmpty())
         {
             // periodically update priorities of ALL nodes            
@@ -301,10 +283,10 @@ void contractNodes()
             {
                 periodSW.start();
                 sortedNodes.clear();
-                int len = g.getNodes();
+                int len = prepareGraph.getNodes();
                 for (int node = 0; node < len; node++)
                 {
-                    if (g.getLevel(node) != 0)
+                    if (prepareGraph.getLevel(node) != maxLevel)
                         continue;
 
                     int priority = oldPriorities[node] = calculatePriority(node);
@@ -327,7 +309,7 @@ void contractNodes()
                         + ", t(lazy):" + (int) lazySW.getSeconds()
                         + ", t(neighbor):" + (int) neighborSW.getSeconds()
                         + ", meanDegree:" + (long) meanDegree
-                        + ", algo:" + algo.getMemoryUsageAsString()
+                        + ", algo:" + prepareAlgo.getMemoryUsageAsString()
                         + ", " + Helper.getMemInfo());
                 dijkstraSW = new StopWatch();
                 periodSW = new StopWatch();
@@ -353,25 +335,18 @@ void contractNodes()
 
             // contract!            
             newShortcuts += addShortcuts(polledNode);
-            g.setLevel(polledNode, level);
+            prepareGraph.setLevel(polledNode, level);
             level++;
 
             if (sortedNodes.getSize() < nodesToAvoidContract)
-            {
-                while (!sortedNodes.isEmpty())
-                {
-                    polledNode = sortedNodes.pollKey();
-                    g.setLevel(polledNode, level);
-                }
+                // skipped nodes are already set to maxLevel
                 break;
-            }
 
             EdgeSkipIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next())
             {
                 int nn = iter.getAdjNode();
-                if (g.getLevel(nn) != 0)
-                    // already contracted no update necessary
+                if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
                 if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage)
@@ -385,8 +360,7 @@ void contractNodes()
                     neighborSW.stop();
                 }
 
-                if (removesHigher2LowerEdges)
-                    lg.disconnect(vehicleAllTmpExplorer, iter);
+                levelGraphCast.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
@@ -397,7 +371,6 @@ void contractNodes()
                 + ", new shortcuts: " + newShortcuts
                 + ", " + prepareWeighting
                 + ", " + prepareFlagEncoder
-                + ", removeHigher2LowerEdges:" + removesHigher2LowerEdges
                 + ", dijkstras:" + dijkstraCount
                 + ", t(dijk):" + (int) dijkstraSW.getSeconds()
                 + ", t(period):" + (int) periodSW.getSeconds()
@@ -407,13 +380,13 @@ void contractNodes()
                 + ", initSize:" + initSize
                 + ", periodic:" + periodicUpdatesPercentage
                 + ", lazy:" + lastNodesLazyUpdatePercentage
-                + ", neighbor:" + neighborUpdatePercentage                
+                + ", neighbor:" + neighborUpdatePercentage
                 + ", " + Helper.getMemInfo());
     }
 
     public void close()
     {
-        algo.close();
+        prepareAlgo.close();
         originalEdges.close();
         sortedNodes = null;
         oldPriorities = null;
@@ -494,8 +467,6 @@ public void foundShortcut( int u_fromNode, int w_toNode,
             // and also in the graph for u->w. If existing AND identical weight => update setProperties.
             // Hint: shortcuts are always one-way due to distinct level of every node but we don't
             // know yet the levels so we need to determine the correct direction or if both directions
-            // minor improvement: if (shortcuts.containsKey(sc) 
-            // then two shortcuts with the same nodes (u<->n.adjNode) exists => check current shortcut against both
             Shortcut sc = new Shortcut(u_fromNode, w_toNode, existingDirectWeight, existingDistSum);
             if (shortcuts.containsKey(sc))
                 return;
@@ -587,7 +558,7 @@ void findShortcuts( ShortcutHandler sch )
         {
             int u_fromNode = incomingEdges.getAdjNode();
             // accept only uncontracted nodes
-            if (g.getLevel(u_fromNode) != 0)
+            if (prepareGraph.getLevel(u_fromNode) != maxLevel)
                 continue;
 
             double v_u_dist = incomingEdges.getDistance();
@@ -597,13 +568,13 @@ void findShortcuts( ShortcutHandler sch )
             // collect outgoing nodes (goal-nodes) only once
             EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
             // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
-            algo.clear();
+            prepareAlgo.clear();
             tmpDegreeCounter++;
             while (outgoingEdges.next())
             {
                 int w_toNode = outgoingEdges.getAdjNode();
                 // add only uncontracted nodes
-                if (g.getLevel(w_toNode) != 0 || u_fromNode == w_toNode)
+                if (prepareGraph.getLevel(w_toNode) != maxLevel || u_fromNode == w_toNode)
                     continue;
 
                 // Limit weight as ferries or forbidden edges can increase local search too much.
@@ -612,23 +583,24 @@ void findShortcuts( ShortcutHandler sch )
                 double existingDirectWeight = v_u_weight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
                 if (Double.isNaN(existingDirectWeight))
                     throw new IllegalStateException("Weighting should never return NaN values"
-                            + ", in:" + getCoords(incomingEdges, g) + ", out:" + getCoords(outgoingEdges, g)
+                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
                             + ", dist:" + outgoingEdges.getDistance() + ", speed:" + prepareFlagEncoder.getSpeed(outgoingEdges.getFlags()));
 
-                if (existingDirectWeight >= Double.MAX_VALUE)
+                if (Double.isInfinite(existingDirectWeight))
                     continue;
+
                 double existingDistSum = v_u_dist + outgoingEdges.getDistance();
-                algo.setLimitWeight(existingDirectWeight)
-                        .setLimitVisitedNodes((int) meanDegree * 100)
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setLimitVisitedNodes((int) meanDegree * 100)
                         .setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
 
                 dijkstraSW.start();
                 dijkstraCount++;
-                int endNode = algo.findEndNode(u_fromNode, w_toNode);
+                int endNode = prepareAlgo.findEndNode(u_fromNode, w_toNode);
                 dijkstraSW.stop();
 
                 // compare end node as the limit could force dijkstra to finish earlier
-                if (endNode == w_toNode && algo.getWeight(endNode) <= existingDirectWeight)
+                if (endNode == w_toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
                     // FOUND witness path, so do not add shortcut                
                     continue;
 
@@ -672,10 +644,10 @@ int addShortcuts( int v )
                     {
                         throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
                                 + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
-                                + ", edge " + iter + ":" + getCoords(iter, g)
+                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
                                 + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(g.getEdgeProps(sc.skippedEdge1, sc.from), g)
-                                + ", skippedEdge2: " + getCoords(g.getEdgeProps(sc.skippedEdge2, sc.to), g)
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeProps(sc.skippedEdge2, sc.to), prepareGraph)
                                 + ", neighbors:" + GHUtility.getNeighbors(iter));
                     }
 
@@ -692,7 +664,7 @@ int addShortcuts( int v )
 
             if (!updatedInGraph)
             {
-                EdgeSkipIterState edgeState = g.shortcut(sc.from, sc.to);
+                EdgeSkipIterState edgeState = prepareGraph.shortcut(sc.from, sc.to);
                 // note: flags overwrite weight => call first
                 edgeState.setFlags(sc.flags);
                 edgeState.setWeight(sc.weight);
@@ -716,20 +688,38 @@ String getCoords( EdgeIteratorState e, Graph g )
 
     PrepareContractionHierarchies initFromGraph()
     {
-        checkGraph();
-        vehicleInExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
-        vehicleOutExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
-        vehicleAllExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        vehicleAllTmpExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        calcPrioAllExplorer = g.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, true));
-        ignoreNodeFilter = new IgnoreNodeFilter(g);
+        vehicleInExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, true, false));
+        vehicleOutExplorer = prepareGraph.createEdgeExplorer(new DefaultEdgeFilter(prepareFlagEncoder, false, true));
+        final EdgeFilter allFilter = new DefaultEdgeFilter(prepareFlagEncoder, true, true);
+
+        // filter by vehicle and level number
+        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph)
+        {
+            @Override
+            public final boolean accept( EdgeIteratorState edgeState )
+            {
+                if (!super.accept(edgeState))
+                    return false;
+
+                return allFilter.accept(edgeState);
+            }
+        };
+
+        levelFilter = new LevelEdgeFilter(prepareGraph);
+        maxLevel = prepareGraph.getNodes() + 1;
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
+        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
+
         // Use an alternative to PriorityQueue as it has some advantages: 
-        //   1. Gets automatically smaller if less entries are stored => less total RAM used (as Graph is increasing until the end)
+        //   1. Gets automatically smaller if less entries are stored => less total RAM used. 
+        //      Important because Graph is increasing until the end.
         //   2. is slightly faster
-        //   but we need additional priorities array to keep old value which is necessary for update method
+        //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
-        oldPriorities = new int[g.getNodes()];
-        algo = new DijkstraOneToMany(g, prepareFlagEncoder, prepareWeighting, traversalMode);
+        oldPriorities = new int[prepareGraph.getNodes()];
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareFlagEncoder, prepareWeighting, traversalMode);
         return this;
     }
 
@@ -741,11 +731,13 @@ public int getShortcuts()
     static class IgnoreNodeFilter implements EdgeFilter
     {
         int avoidNode;
+        int maxLevel;
         LevelGraph graph;
 
-        public IgnoreNodeFilter( LevelGraph g )
+        public IgnoreNodeFilter( LevelGraph g, int maxLevel )
         {
             this.graph = g;
+            this.maxLevel = maxLevel;
         }
 
         public IgnoreNodeFilter setAvoidNode( int node )
@@ -757,9 +749,9 @@ public IgnoreNodeFilter setAvoidNode( int node )
         @Override
         public final boolean accept( EdgeIteratorState iter )
         {
-            // ignore if it is skipNode or a adjNode already contracted
+            // ignore if it is skipNode or adjNode is already contracted
             int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == 0;
+            return avoidNode != node && graph.getLevel(node) == maxLevel;
         }
     }
 
@@ -779,110 +771,107 @@ private int getOrigEdgeCount( int index )
     }
 
     @Override
-    public RoutingAlgorithm createAlgo()
+    public RoutingAlgorithm createAlgo( Graph graph, AlgorithmOptions opts )
     {
-        checkGraph();
-        // do not change weight within DijkstraBidirectionRef => so use ShortestWeighting
-        DijkstraBidirectionRef dijkstrabi = new DijkstraBidirectionRef(g, prepareFlagEncoder, prepareWeighting, traversalMode)
+        AbstractBidirAlgo algo;
+        if (AlgorithmOptions.ASTAR_BI.equals(opts.getAlgorithm()))
         {
-            @Override
-            protected void initCollections( int nodes )
+            AStarBidirection astarBi = new AStarBidirection(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
             {
-                // algorithm with CH does not need that much memory pre allocated
-                super.initCollections(Math.min(initialCollectionSize, nodes));
-            }
+                @Override
+                protected void initCollections( int nodes )
+                {
+                    // algorithm with CH does not need that much memory pre allocated
+                    super.initCollections(Math.min(initialCollectionSize, nodes));
+                }
 
-            @Override
-            public boolean finished()
-            {
-                // we need to finish BOTH searches for CH!
-                if (finishedFrom && finishedTo)
-                    return true;
+                @Override
+                protected boolean finished()
+                {
+                    // we need to finish BOTH searches for CH!
+                    if (finishedFrom && finishedTo)
+                        return true;
 
-                // changed also the final finish condition for CH                
-                return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
-            }
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
 
-            @Override
-            protected Path createAndInitPath()
-            {
-                bestPath = new Path4CH(graph, flagEncoder);
-                return bestPath;
-            }
+                    // changed finish condition for CH
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+                }
 
-            @Override
-            public String getName()
-            {
-                return "dijkstrabiCH";
-            }
+                @Override
 
-            @Override
-            public String toString()
-            {
-                return getName() + "|" + prepareWeighting;
-            }
-        };
+                protected Path createAndInitPath()
+                {
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
+                    return bestPath;
+                }
 
-        if (!removesHigher2LowerEdges)
-            dijkstrabi.setEdgeFilter(new LevelEdgeFilter(g));
+                @Override
+                public String getName()
+                {
+                    return "astarbiCH";
+                }
 
-        return dijkstrabi;
-    }
+                @Override
 
-    public AStarBidirection createAStar()
-    {
-        checkGraph();
-        AStarBidirection astar = new AStarBidirection(g, prepareFlagEncoder, prepareWeighting, traversalMode)
+                public String toString()
+                {
+                    return getName() + "|" + prepareWeighting;
+                }
+            };
+            algo = astarBi;
+        } else if (AlgorithmOptions.DIJKSTRA_BI.equals(opts.getAlgorithm()))
         {
-            @Override
-            protected void initCollections( int nodes )
+            algo = new DijkstraBidirectionRef(graph, prepareFlagEncoder, prepareWeighting, traversalMode)
             {
-                // algorithm with CH does not need that much memory pre allocated
-                super.initCollections(Math.min(initialCollectionSize, nodes));
-            }
-
-            @Override
-            protected boolean finished()
-            {
-                // we need to finish BOTH searches for CH!
-                if (finishedFrom && finishedTo)
-                    return true;
+                @Override
+                protected void initCollections( int nodes )
+                {
+                    // algorithm with CH does not need that much memory pre allocated
+                    super.initCollections(Math.min(initialCollectionSize, nodes));
+                }
 
-                // changed finish condition for CH
-                double tmpWeight = bestPath.getWeight() * approximationFactor;
-                return currFrom.weight >= tmpWeight && currTo.weight >= tmpWeight;
-            }
+                @Override
+                public boolean finished()
+                {
+                    // we need to finish BOTH searches for CH!
+                    if (finishedFrom && finishedTo)
+                        return true;
 
-            @Override
-            protected Path createAndInitPath()
-            {
-                bestPath = new Path4CH(graph, flagEncoder);
-                return bestPath;
-            }
+                    if (currFrom.weight + currTo.weight > weightLimit)
+                        return true;
 
-            @Override
-            public String getName()
-            {
-                return "astarbiCH";
-            }
+                    // changed also the final finish condition for CH                
+                    return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+                }
 
-            @Override
-            public String toString()
-            {
-                return getName() + "|" + prepareWeighting;
-            }
-        };
+                @Override
+                protected Path createAndInitPath()
+                {
+                    bestPath = new Path4CH(graph, graph.getBaseGraph(), flagEncoder);
+                    return bestPath;
+                }
 
-        if (!removesHigher2LowerEdges)
-            astar.setEdgeFilter(new LevelEdgeFilter(g));
+                @Override
+                public String getName()
+                {
+                    return "dijkstrabiCH";
+                }
 
-        return astar;
-    }
+                @Override
+                public String toString()
+                {
+                    return getName() + "|" + prepareWeighting;
+                }
+            };
+        } else
+        {
+            throw new UnsupportedOperationException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies");
+        }
 
-    private void checkGraph()
-    {
-        if (g == null)
-            throw new NullPointerException("setGraph before usage");
+        algo.setEdgeFilter(levelFilter);
+        return algo;
     }
 
     private static class PriorityNode implements Comparable<PriorityNode>
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
index c98da4c65a..3de7c2c89a 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractAlgoPreparation.java
@@ -17,36 +17,21 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.Graph;
-
 /**
  * @author Peter Karich
  */
-public abstract class AbstractAlgoPreparation<T extends AlgorithmPreparation> implements AlgorithmPreparation
+public abstract class AbstractAlgoPreparation
 {
-    protected Graph _graph;
     private boolean prepared = false;
 
-    @Override
-    public AlgorithmPreparation setGraph( Graph g )
-    {
-        _graph = g;
-        return this;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public T doWork()
+    public void doWork()
     {
         if (prepared)
             throw new IllegalStateException("Call doWork only once!");
 
         prepared = true;
-        // no operation        
-        return (T) this;
     }
 
-    @Override
     public boolean isPrepared()
     {
         return prepared;
diff --git a/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java b/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java
deleted file mode 100644
index 2eb5a9e664..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/AlgorithmPreparation.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.storage.Graph;
-
-/**
- * Holds an algorithm which can be prepared and created.
- * <p/>
- * @author Peter Karich
- */
-public interface AlgorithmPreparation
-{
-    /**
-     * Prepares the underlying graph to be used by a specialized algorithm.
-     */
-    AlgorithmPreparation doWork();
-
-    /**
-     * @return true if doWork was already called.
-     */
-    boolean isPrepared();
-
-    AlgorithmPreparation setGraph( Graph g );
-
-    RoutingAlgorithm createAlgo();
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
index 3f256b5280..3a88c83a7b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AllEdgesIterator.java
@@ -24,5 +24,8 @@
  */
 public interface AllEdgesIterator extends EdgeIterator
 {
-    int getMaxId();
+    /**
+     * @return the number of edges
+     */
+    int getCount();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
new file mode 100644
index 0000000000..5df84cfe62
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/BeelineWeightApproximator.java
@@ -0,0 +1,52 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.DistancePlaneProjection;
+
+/**
+ * Approximates the distance to the goalNode by weighting the beeline distance according to the distance weighting
+ * @author jansoe
+ */
+public class BeelineWeightApproximator implements WeightApproximator {
+
+    private NodeAccess nodeAccess;
+    private Weighting weighting;
+    private DistanceCalc distanceCalc;
+    double toLat, toLon;
+
+    public BeelineWeightApproximator(NodeAccess nodeAccess, Weighting weighting) {
+        this.nodeAccess = nodeAccess;
+        this.weighting = weighting;
+        setDistanceCalc(new DistanceCalcEarth());
+    }
+
+    public void setGoalNode(int toNode){
+        toLat = nodeAccess.getLatitude(toNode);
+        toLon = nodeAccess.getLongitude(toNode);
+    }
+
+    @Override
+    public WeightApproximator duplicate() {
+        return new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(distanceCalc);
+    }
+
+
+    @Override
+    public double approximate(int fromNode) {
+
+        double fromLat, fromLon, dist2goal, weight2goal;
+        fromLat  = nodeAccess.getLatitude(fromNode);
+        fromLon = nodeAccess.getLongitude(fromNode);
+        dist2goal = distanceCalc.calcDist(toLat, toLon, fromLat, fromLon);
+        weight2goal = weighting.getMinWeight(dist2goal);
+
+        return weight2goal;
+    }
+
+    public BeelineWeightApproximator setDistanceCalc(DistanceCalc distanceCalc) {
+        this.distanceCalc = distanceCalc;
+        return this;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index de35630029..090232b13c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -67,6 +67,7 @@ protected BikeCommonFlagEncoder( int speedBits, double speedFactor, int maxTurnC
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("designated");
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index 5bc0701c2c..19b0553f68 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -70,6 +70,7 @@ public CarFlagEncoder( int speedBits, double speedFactor, int maxTurnCosts )
         restrictedValues.add("no");
         restrictedValues.add("restricted");
         restrictedValues.add("delivery");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("permissive");
@@ -256,7 +257,7 @@ public long acceptWay( Way way )
         if ("track".equals(highwayValue))
         {
             String tt = way.getTag("tracktype");
-            if (tt != null && !tt.equals("grade1"))
+            if (tt != null && !tt.equals("grade1") && !tt.equals("grade2") && !tt.equals("grade3"))
                 return 0;
         }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
new file mode 100644
index 0000000000..c7b67e7c68
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/ConsistentWeightApproximator.java
@@ -0,0 +1,43 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.storage.NodeAccess;
+
+/**
+ * Turns an unidirectional weight Approximation into a bidirectional consistent one.
+ * <p/>
+ * Ikeda, T., Hsu, M.-Y., Imai, H., Nishimura, S., Shimoura, H., Hashimoto, T., Tenmoku, K., and
+ * Mitoh, K. (1994). A fast algorithm for finding better routes by ai search techniques. In VNIS,
+ * pages 291–296.
+ * <p/>
+ *
+ * @author jansoe
+ */
+public class ConsistentWeightApproximator {
+
+    private NodeAccess nodeAccess;
+    private Weighting weighting;
+    private WeightApproximator uniDirApproximatorForward, uniDirApproximatorReverse;
+
+    public ConsistentWeightApproximator(WeightApproximator weightApprox){
+        uniDirApproximatorForward = weightApprox;
+        uniDirApproximatorReverse = weightApprox.duplicate();
+    }
+
+    public void setSourceNode(int sourceNode){
+        uniDirApproximatorReverse.setGoalNode(sourceNode);
+    }
+
+    public void setGoalNode(int goalNode){
+        uniDirApproximatorForward.setGoalNode(goalNode);
+    }
+
+    public double approximate(int fromNode, boolean reverse)    {
+        double weightApproximation = 0.5*(uniDirApproximatorForward.approximate(fromNode)
+                                          - uniDirApproximatorReverse.approximate(fromNode));
+        if (reverse) {
+            weightApproximation *= -1;
+        }
+
+        return weightApproximation;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
index 8823be538b..a108e4826c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
@@ -29,12 +29,12 @@
     /**
      * @return true if the current edge should be processed and false otherwise.
      */
-    boolean accept( EdgeIteratorState edgeIterState );
+    boolean accept( EdgeIteratorState edgeState );
 
     static final EdgeFilter ALL_EDGES = new EdgeFilter()
     {
         @Override
-        public final boolean accept( EdgeIteratorState edgeIterState )
+        public final boolean accept( EdgeIteratorState edgeState )
         {
             return true;
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 4d3b54c3d9..82548f3b4f 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -104,25 +104,28 @@ public EncodingManager( List<? extends FlagEncoder> flagEncoders )
         this(flagEncoders, 4);
     }
 
-    public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForFlags )
+    public EncodingManager( List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags )
     {
-        if (bytesForFlags != 4 && bytesForFlags != 8)
-            throw new IllegalStateException("For 'flags' currently only 4 or 8 bytes supported");
+        if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8)
+            throw new IllegalStateException("For 'edge flags' currently only 4 or 8 bytes supported");
 
-        this.bitsForEdgeFlags = bytesForFlags * 8;
+        this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
 
         Collections.sort(flagEncoders, new Comparator<FlagEncoder>()
-        {
+                {
             @Override
             public int compare( FlagEncoder o1, FlagEncoder o2 )
             {
                 return o1.toString().compareTo(o2.toString());
             }
-        });
+                });
         for (FlagEncoder flagEncoder : flagEncoders)
         {
             registerEncoder((AbstractFlagEncoder) flagEncoder);
         }
+
+        if (edgeEncoders.isEmpty())
+            throw new IllegalStateException("No vehicles found");
     }
 
     public int getBytesForFlags()
@@ -282,11 +285,6 @@ public long handleWayTags( Way way, long includeWay, long relationFlags )
         return flags;
     }
 
-    public int getVehicleCount()
-    {
-        return edgeEncoders.size();
-    }
-
     @Override
     public String toString()
     {
@@ -318,17 +316,6 @@ public String toDetailsString()
         return str.toString();
     }
 
-    public FlagEncoder getSingle()
-    {
-        if (getVehicleCount() > 1)
-            throw new IllegalStateException("Multiple encoders are active. cannot return one:" + toString());
-
-        if (getVehicleCount() == 0)
-            throw new IllegalStateException("No encoder is active!");
-
-        return edgeEncoders.get(0);
-    }
-
     public long flagsDefault( boolean forward, boolean backward )
     {
         long flags = 0;
@@ -417,10 +404,10 @@ private static int determineRequiredBits( int value )
                 if (oldEntry != null)
                 {
                     // merging different encoders
-                	long oldFlags = oldEntry.getFlags();
-                	long flags = entry.getFlags();
-                	oldFlags |= flags;
-                	oldEntry.setFlags(oldFlags);
+                    long oldFlags = oldEntry.getFlags();
+                    long flags = entry.getFlags();
+                    oldFlags |= flags;
+                    oldEntry.setFlags(oldFlags);
                 } else
                 {
                     entries.put(entry.getItemId(), entry);
@@ -464,6 +451,16 @@ public void applyWayTags( Way way, EdgeIteratorState edge )
         }
     }
 
+    /**
+     * The returned list is never empty.
+     */
+    public List<FlagEncoder> fetchEdgeEncoders()
+    {
+        List<FlagEncoder> list = new ArrayList<FlagEncoder>();
+        list.addAll(edgeEncoders);
+        return list;
+    }
+
     static String fixWayName( String str )
     {
         if (str == null)
@@ -506,7 +503,7 @@ public static EncodingManager create( String ghLoc )
             bytesForFlags = 8;
         return new EncodingManager(acceptStr, bytesForFlags);
     }
-    
+
     public boolean isVehicleQualifierTypeIncluded(RoutingElement routingElement) {
         for (AbstractFlagEncoder encoder : edgeEncoders)
         {
diff --git a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
index 789e41a269..3a5a7f1632 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FastestWeighting.java
@@ -38,7 +38,7 @@
     public FastestWeighting( FlagEncoder encoder )
     {
         this.encoder = encoder;
-        maxSpeed = encoder.getMaxSpeed() * SPEED_CONV;
+        maxSpeed = encoder.getMaxSpeed() / SPEED_CONV;
     }
 
     @Override
@@ -53,7 +53,7 @@ public double calcWeight( EdgeIteratorState edge, boolean reverse, int prevOrNex
         double speed = reverse ? encoder.getReverseSpeed(edge.getFlags()) : encoder.getSpeed(edge.getFlags());
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
-        return edge.getDistance() / (speed * SPEED_CONV);
+        return edge.getDistance() / speed * SPEED_CONV;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index 1c327ac7ec..34a2415fb6 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -66,6 +66,7 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         restrictedValues.add("private");
         restrictedValues.add("no");
         restrictedValues.add("restricted");
+        restrictedValues.add("military");
 
         intendedValues.add("yes");
         intendedValues.add("designated");
@@ -92,27 +93,23 @@ public FootFlagEncoder( int speedBits, double speedFactor )
         safeHighwayTags.add("residential");
         safeHighwayTags.add("service");
 
+        avoidHighwayTags.add("trunk");
+        avoidHighwayTags.add("trunk_link");
+        avoidHighwayTags.add("primary");
+        avoidHighwayTags.add("primary_link");
+        avoidHighwayTags.add("tertiary");
+        avoidHighwayTags.add("tertiary_link");
+        avoidHighwayTags.add("cycleway");
+
         allowedHighwayTags.addAll(safeHighwayTags);
-        allowedHighwayTags.add("trunk");
-        allowedHighwayTags.add("trunk_link");
-        allowedHighwayTags.add("primary");
-        allowedHighwayTags.add("primary_link");
+        allowedHighwayTags.addAll(avoidHighwayTags);
         allowedHighwayTags.add("secondary");
         allowedHighwayTags.add("secondary_link");
-        allowedHighwayTags.add("tertiary");
-        allowedHighwayTags.add("tertiary_link");
         allowedHighwayTags.add("unclassified");
         allowedHighwayTags.add("road");
         // disallowed in some countries
         //allowedHighwayTags.add("bridleway");
 
-        avoidHighwayTags.add("trunk");
-        avoidHighwayTags.add("trunk_link");
-        avoidHighwayTags.add("primary");
-        avoidHighwayTags.add("primary_link");
-        avoidHighwayTags.add("tertiary");
-        avoidHighwayTags.add("tertiary_link");
-
         hikingNetworkToCode.put("iwn", BEST.getValue());
         hikingNetworkToCode.put("nwn", BEST.getValue());
         hikingNetworkToCode.put("rwn", VERY_NICE.getValue());
@@ -223,9 +220,6 @@ public long acceptWay( Way way )
         if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
             return 0;
 
-        if (way.hasTag("bicycle", "official"))
-            return 0;
-
         // check access restrictions
         if (way.hasTag(restrictions, restrictedValues))
             return 0;
@@ -368,7 +362,7 @@ void collect( Way way, TreeMap<Double, Integer> weightToPrioMap )
                 weightToPrioMap.put(40d, UNCHANGED.getValue());
         }
 
-        if (avoidHighwayTags.contains(highway) || maxSpeed > 50)
+        if (avoidHighwayTags.contains(highway) || maxSpeed > 50 || way.hasTag("bicycle", "official"))
         {
             weightToPrioMap.put(50d, REACH_DEST.getValue());
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
index 1db6312e76..985a4477d5 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LevelEdgeFilter.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterState;
+import com.graphhopper.util.EdgeSkipIterator;
 
 /**
  * Only certain nodes are accepted and therefor the others are ignored.
@@ -27,16 +29,28 @@
  */
 public class LevelEdgeFilter implements EdgeFilter
 {
-    protected LevelGraph graph;
+    private final LevelGraph graph;
+    private final int maxNodes;
 
     public LevelEdgeFilter( LevelGraph g )
     {
         graph = g;
+        maxNodes = g.getNodes();
     }
 
     @Override
-    public boolean accept( EdgeIteratorState edgeIter )
+    public boolean accept( EdgeIteratorState edgeIterState )
     {
-        return graph.getLevel(edgeIter.getBaseNode()) <= graph.getLevel(edgeIter.getAdjNode());
+        int base = edgeIterState.getBaseNode();
+        int adj = edgeIterState.getAdjNode();
+        // always accept virtual edges, see #288
+        if (base >= maxNodes || adj >= maxNodes)
+            return true;
+
+        // minor performance improvement: shortcuts in wrong direction are disconnected, so no need to exclude them
+        if (((EdgeSkipIterState) edgeIterState).isShortcut())
+            return true;
+
+        return graph.getLevel(base) <= graph.getLevel(adj);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java b/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java
deleted file mode 100644
index c3e0f8b2fb..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/NoOpAlgorithmPreparation.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.RoutingAlgorithmFactory;
-import com.graphhopper.storage.Graph;
-
-/**
- * @author Peter Karich
- */
-public abstract class NoOpAlgorithmPreparation extends AbstractAlgoPreparation<NoOpAlgorithmPreparation>
-{
-    public NoOpAlgorithmPreparation()
-    {
-    }
-
-    /**
-     * Creates a preparation wrapper for the specified algorithm. Possible values for algorithmStr:
-     * astar (A* algorithm), astarbi (bidirectional A*), dijkstra (Dijkstra) or dijkstrabi.
-     */
-    public static AlgorithmPreparation createAlgoPrepare( Graph g, final String algorithmStr,
-            FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        return p(new RoutingAlgorithmFactory(algorithmStr, false, tMode), encoder, weighting).setGraph(g);
-    }
-
-    private static AlgorithmPreparation p( final RoutingAlgorithmFactory factory,
-            final FlagEncoder encoder, final Weighting weighting )
-    {
-        return new NoOpAlgorithmPreparation()
-        {
-            @Override
-            public RoutingAlgorithm createAlgo()
-            {
-                try
-                {
-                    return factory.createAlgo(_graph, encoder, weighting);
-                } catch (Exception ex)
-                {
-                    throw new RuntimeException(ex);
-                }
-            }
-
-            @Override
-            public String toString()
-            {
-                return createAlgo().getName() + ", " + encoder + ", " + weighting;
-            }
-        };
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
index 1a2293824c..a02bf36a83 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PrepareRoutingSubnetworks.java
@@ -43,21 +43,19 @@
     private final GraphStorage g;
     private final EdgeFilter edgeFilter;
     private int minNetworkSize = 200;
-    private int minOnewayNetworkSize = 0;
+    private int minOneWayNetworkSize = 0;
     private int subNetworks = -1;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
-    private final EncodingManager encodingManager;
+    private FlagEncoder singleEncoder;
 
     public PrepareRoutingSubnetworks( GraphStorage g, EncodingManager em )
     {
         this.g = g;
-        if (em.getVehicleCount() == 0)
-            throw new IllegalStateException("No vehicles found");
-        else if (em.getVehicleCount() > 1)
+        List<FlagEncoder> encoders = em.fetchEdgeEncoders();
+        if (encoders.size() > 1)
             edgeFilter = EdgeFilter.ALL_EDGES;
         else
-            edgeFilter = new DefaultEdgeFilter(em.getSingle());
-        this.encodingManager = em;
+            edgeFilter = new DefaultEdgeFilter(singleEncoder = encoders.get(0));
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
@@ -66,9 +64,9 @@ public PrepareRoutingSubnetworks setMinNetworkSize( int minNetworkSize )
         return this;
     }
 
-    public PrepareRoutingSubnetworks setMinOnewayNetworkSize( int minOnewayNetworkSize )
+    public PrepareRoutingSubnetworks setMinOneWayNetworkSize( int minOnewayNetworkSize )
     {
-        this.minOnewayNetworkSize = minOnewayNetworkSize;
+        this.minOneWayNetworkSize = minOnewayNetworkSize;
         return this;
     }
 
@@ -78,9 +76,9 @@ public void doWork()
         Map<Integer, Integer> map = findSubnetworks();
         keepLargeNetworks(map);
 
-        int unvisitedDeadEnds = 0;
-        if ((this.minOnewayNetworkSize > 0) && (this.encodingManager.getVehicleCount() == 1))
-            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(this.encodingManager.getSingle());
+        int unvisitedDeadEnds = -1;
+        if ((this.minOneWayNetworkSize > 0) && singleEncoder != null)
+            unvisitedDeadEnds = removeDeadEndUnvisitedNetworks(singleEncoder);
 
         logger.info("optimize to remove subnetworks (" + map.size() + "), zero-degree-nodes (" + del + "), "
                 + "unvisited-dead-end-nodes(" + unvisitedDeadEnds + "), "
@@ -231,9 +229,9 @@ int removeZeroDegreeNodes()
 
     /**
      * Clean small networks that will be never be visited by this explorer See #86 For example,
-     * small areas like parking lots are sometimes connected to the whole network through a one-way road.
-     * This is clearly an error - but is causes the routing to fail when point get connected to this
-     * small area. This routines removed all these points from the graph.
+     * small areas like parking lots are sometimes connected to the whole network through a one-way
+     * road. This is clearly an error - but is causes the routing to fail when point get connected
+     * to this small area. This routines removed all these points from the graph.
      * <p/>
      * @return number of removed nodes;
      */
@@ -245,12 +243,14 @@ public int removeDeadEndUnvisitedNetworks( final FlagEncoder encoder )
 
         // remove components less than minimum size
         int removed = 0;
-        for (TIntArrayList component : components) {
-
-            if (component.size() < minOnewayNetworkSize) {
-                for (int i = 0; i < component.size(); i++) {
+        for (TIntArrayList component : components)
+        {
+            if (component.size() < minOneWayNetworkSize)
+            {
+                for (int i = 0; i < component.size(); i++)
+                {
                     g.markNodeRemoved(component.get(i));
-                    removed ++;
+                    removed++;
                 }
             }
         }
diff --git a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java b/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
deleted file mode 100644
index 6e7769e6e1..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/RoutingAlgorithmSpecialAreaTests.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.coll.MapEntry;
-import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.ch.PrepareContractionHierarchies;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.index.LocationIndex;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.StopWatch;
-import static com.graphhopper.routing.util.NoOpAlgorithmPreparation.*;
-import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.*;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map.Entry;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Integration tests for one bigger area - at the moment Unterfranken (Germany). Execute via
- * ./graphhopper.sh test unterfranken.osm
- * <p/>
- * @author Peter Karich
- */
-public class RoutingAlgorithmSpecialAreaTests
-{
-    private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final Graph unterfrankenGraph;
-    private final LocationIndex idx;
-
-    public RoutingAlgorithmSpecialAreaTests( GraphHopper graphhopper )
-    {
-        this.unterfrankenGraph = graphhopper.getGraph();
-        StopWatch sw = new StopWatch().start();
-        idx = graphhopper.getLocationIndex();
-        logger.info(idx.getClass().getSimpleName() + " index. Size:"
-                + (float) idx.getCapacity() / (1 << 20) + " MB, took:" + sw.stop().getSeconds());
-    }
-
-    public void start()
-    {
-        testIndex();
-        testAlgos();
-    }
-
-    void testAlgos()
-    {
-        if (unterfrankenGraph instanceof LevelGraph)
-        {
-            throw new IllegalStateException("run testAlgos only with a none-LevelGraph. Use prepare.chWeighting=no "
-                    + "Or use prepare.chWeighting=shortest and avoid the preparation");
-        }
-
-        TestAlgoCollector testCollector = new TestAlgoCollector("testAlgos");
-        final EncodingManager encodingManager = new EncodingManager("CAR", 4);
-        CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-        boolean ch = true;
-        Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = createAlgos(unterfrankenGraph, idx,
-                carEncoder, ch, TraversalMode.NODE_BASED, new ShortestWeighting(), encodingManager);
-        EdgeFilter ef = new DefaultEdgeFilter(carEncoder);
-
-        for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
-        {
-            AlgorithmPreparation prepare = entry.getKey();
-            int failed = testCollector.errors.size();
-
-            OneRun or = new OneRun(50.0314, 10.5105, 50.0303, 10.5070, 571, 22);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.51451, 9.967346, 50.2920, 10.4650, 107909, 1929);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.0780, 9.1570, 49.5860, 9.9750, 95562, 1556);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.2800, 9.7190, 49.8960, 10.3890, 81016, 1724);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.8020, 9.2470, 50.4940, 10.1970, 134767, 2295);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(49.72449, 9.23482, 50.4140, 10.2750, 140809, 2680);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-            or = new OneRun(50.1100, 10.7530, 49.6500, 10.3410, 77381, 1863);
-            testCollector.assertDistance(prepare, or.getList(idx, ef), or);
-
-            System.out.println("unterfranken " + prepare.createAlgo() + ": " + (testCollector.errors.size() - failed) + " failed");
-        }
-
-        testCollector.printSummary();
-    }
-
-    private static class ME extends MapEntry<AlgorithmPreparation, LocationIndex>
-    {
-        public ME( AlgorithmPreparation ap, LocationIndex idx )
-        {
-            super(ap, idx);
-        }
-    }
-
-    public static Collection<Entry<AlgorithmPreparation, LocationIndex>> createAlgos( Graph g,
-            LocationIndex idx, FlagEncoder encoder, boolean withCh, TraversalMode tMode, Weighting weighting, EncodingManager manager )
-    {
-        List<Entry<AlgorithmPreparation, LocationIndex>> prepare = new ArrayList<Entry<AlgorithmPreparation, LocationIndex>>();
-        prepare.add(new ME(createAlgoPrepare(g, "astar", encoder, weighting, tMode), idx));
-        // prepare.add(new ME(createAlgoPrepare(g, "dijkstraOneToMany", encoder, weighting, edgeBased), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "astarbi", encoder, weighting, tMode), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstrabi", encoder, weighting, tMode), idx));
-        prepare.add(new ME(createAlgoPrepare(g, "dijkstra", encoder, weighting, tMode), idx));
-
-        if (withCh)
-        {
-            LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
-                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
-            PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(encoder, weighting, tMode).
-                    setGraph(graphCH);
-            prepareCH.doWork();
-            LocationIndex idxCH = new LocationIndexTreeSC(graphCH, new RAMDirectory()).prepareIndex();
-            prepare.add(new ME(prepareCH, idxCH));
-
-            PrepareContractionHierarchies prepareCHAStar = new PrepareContractionHierarchies(encoder, weighting, tMode)
-            {
-                @Override
-                public RoutingAlgorithm createAlgo()
-                {
-                    return createAStar().setApproximation(true).setApproximationFactor(1);
-                }
-            }.setGraph(graphCH);
-            prepare.add(new ME(prepareCHAStar, idxCH));
-        }
-        return prepare;
-    }
-
-    void testIndex()
-    {
-        TestAlgoCollector testCollector = new TestAlgoCollector("testIndex");
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.080539, 10.125854, 63.35);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.081146, 10.124496, 0.0);
-        testCollector.queryIndex(unterfrankenGraph, idx, 49.68243, 9.933271, 436.29);
-        testCollector.queryIndex(unterfrankenGraph, idx, 50.066495, 10.191836, 14.63);
-
-        testCollector.printSummary();
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index 1356a796e1..66d437d1ac 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -18,15 +18,12 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.GHResponse;
-import com.graphhopper.routing.Path;
+import com.graphhopper.routing.*;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.PathMerger;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.TranslationMap;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import java.util.ArrayList;
 import java.util.List;
@@ -38,24 +35,34 @@
 public class TestAlgoCollector
 {
     private final String name;
-    private final DistanceCalc distCalc = new DistanceCalcEarth();
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
     private final TranslationMap trMap = new TranslationMap().doImport();
-    public List<String> errors = new ArrayList<String>();
+    public final List<String> errors = new ArrayList<String>();
 
     public TestAlgoCollector( String name )
     {
         this.name = name;
     }
 
-    public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<QueryResult> queryList, OneRun oneRun )
+    public TestAlgoCollector assertDistance( AlgoHelperEntry algoEntry, List<QueryResult> queryList,
+            OneRun oneRun )
     {
         List<Path> viaPaths = new ArrayList<Path>();
+        QueryGraph queryGraph = new QueryGraph(algoEntry.getQueryGraph());
+        queryGraph.lookup(queryList);
+        AlgorithmOptions opts = algoEntry.opts;
+        FlagEncoder encoder = opts.getFlagEncoder();
+        if (encoder.supports(TurnWeighting.class))
+            algoEntry.setAlgorithmOptions(AlgorithmOptions.start(opts).weighting(new TurnWeighting(opts.getWeighting(), opts.getFlagEncoder(), (TurnCostExtension) queryGraph.getExtension())).build());
+
         for (int i = 0; i < queryList.size() - 1; i++)
         {
-            Path path = prepare.createAlgo().calcPath(queryList.get(i), queryList.get(i + 1));
+            Path path = algoEntry.createAlgo(queryGraph).
+                    calcPath(queryList.get(i).getClosestNode(), queryList.get(i + 1).getClosestNode());
             // System.out.println(path.calcInstructions().createGPX("temp", 0, "GMT"));
             viaPaths.add(path);
         }
+
         PathMerger pathMerger = new PathMerger().
                 setCalcPoints(true).
                 setSimplifyResponse(false).
@@ -63,10 +70,10 @@ public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<Quer
         GHResponse rsp = new GHResponse();
         pathMerger.doWork(rsp, viaPaths, trMap.getWithFallBack(Locale.US));
 
-        if (!rsp.isFound())
+        if (rsp.hasErrors())
         {
-            errors.add(prepare + " returns no path! expected distance: " + rsp.getDistance()
-                    + ", expected points: " + oneRun + ". " + queryList);
+            errors.add(algoEntry + " response contains errors. Expected distance: " + rsp.getDistance()
+                    + ", expected points: " + oneRun + ". " + queryList + ", errors:" + rsp.getErrors());
             return this;
         }
 
@@ -74,14 +81,14 @@ public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<Quer
         double tmpDist = pointList.calcDistance(distCalc);
         if (Math.abs(rsp.getDistance() - tmpDist) > 2)
         {
-            errors.add(prepare + " path.getDistance was  " + rsp.getDistance()
+            errors.add(algoEntry + " path.getDistance was  " + rsp.getDistance()
                     + "\t pointList.calcDistance was " + tmpDist + "\t (expected points " + oneRun.getLocs()
                     + ", expected distance " + oneRun.getDistance() + ") " + queryList);
         }
 
         if (Math.abs(rsp.getDistance() - oneRun.getDistance()) > 2)
         {
-            errors.add(prepare + " returns path not matching the expected distance of " + oneRun.getDistance()
+            errors.add(algoEntry + " returns path not matching the expected distance of " + oneRun.getDistance()
                     + "\t Returned was " + rsp.getDistance() + "\t (expected points " + oneRun.getLocs()
                     + ", was " + pointList.getSize() + ") " + queryList);
         }
@@ -89,7 +96,7 @@ public TestAlgoCollector assertDistance( AlgorithmPreparation prepare, List<Quer
         // There are real world instances where A-B-C is identical to A-C (in meter precision).
         if (Math.abs(pointList.getSize() - oneRun.getLocs()) > 1)
         {
-            errors.add(prepare + " returns path not matching the expected points of " + oneRun.getLocs()
+            errors.add(algoEntry + " returns path not matching the expected points of " + oneRun.getLocs()
                     + "\t Returned was " + pointList.getSize() + "\t (expected distance " + oneRun.getDistance()
                     + ", was " + rsp.getDistance() + ") " + queryList);
         }
@@ -139,6 +146,51 @@ void printSummary()
         }
     }
 
+    public static class AlgoHelperEntry
+    {
+        private Graph queryGraph;
+        private final LocationIndex idx;
+        private AlgorithmOptions opts;
+
+        public AlgoHelperEntry( Graph g, AlgorithmOptions opts, LocationIndex idx )
+        {
+            this.queryGraph = g;
+            this.opts = opts;
+            this.idx = idx;
+        }
+
+        public Graph getQueryGraph()
+        {
+            return queryGraph;
+        }
+
+        public void setQueryGraph( Graph queryGraph )
+        {
+            this.queryGraph = queryGraph;
+        }
+
+        public void setAlgorithmOptions( AlgorithmOptions opts )
+        {
+            this.opts = opts;
+        }
+
+        public LocationIndex getIdx()
+        {
+            return idx;
+        }
+
+        public RoutingAlgorithm createAlgo( Graph qGraph )
+        {
+            return new RoutingAlgorithmFactorySimple().createAlgo(qGraph, opts);
+        }
+
+        @Override
+        public String toString()
+        {
+            return opts.getAlgorithm();
+        }
+    }
+
     public static class OneRun
     {
         private final List<AssumptionPerPath> assumptions = new ArrayList<AssumptionPerPath>();
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
index a2d54f09ec..bde1c79da6 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnWeighting.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
@@ -33,21 +33,21 @@
      * Encoder, which decodes the turn flags
      */
     private final TurnCostEncoder turnCostEncoder;
-    private final TurnCostStorage turnCostStorage;
+    private final TurnCostExtension turnCostExt;
     private final Weighting superWeighting;
     private double defaultUTurnCost = 40;
 
     /**
-     * @param turnCostStorage the turn cost storage to be used
+     * @param turnCostExt the turn cost storage to be used
      */
-    public TurnWeighting( Weighting superWeighting, TurnCostEncoder encoder, TurnCostStorage turnCostStorage )
+    public TurnWeighting( Weighting superWeighting, TurnCostEncoder encoder, TurnCostExtension turnCostExt )
     {
         this.turnCostEncoder = encoder;
         this.superWeighting = superWeighting;
-        this.turnCostStorage = turnCostStorage;
+        this.turnCostExt = turnCostExt;
         if (encoder == null)
             throw new IllegalArgumentException("No encoder set to calculate turn weight");
-        if (turnCostStorage == null)
+        if (turnCostExt == null)
             throw new RuntimeException("No storage set to calculate turn weight");
     }
 
@@ -89,7 +89,7 @@ public double calcWeight( EdgeIteratorState edgeState, boolean reverse, int prev
 
     public double calcTurnWeight( int edgeFrom, int nodeVia, int edgeTo )
     {
-        long turnFlags = turnCostStorage.getTurnCostFlags(nodeVia, edgeFrom, edgeTo);
+        long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
         if (turnCostEncoder.isTurnRestricted(turnFlags))
             return Double.POSITIVE_INFINITY;
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
new file mode 100644
index 0000000000..f471be0d07
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/WeightApproximator.java
@@ -0,0 +1,22 @@
+package com.graphhopper.routing.util;
+
+/**
+ * Specifies a weight approximation between an node and the goalNode according to the specified weighting.
+ * <p/>
+ * @author jansoe
+ */
+public interface WeightApproximator
+{
+
+    /**
+     * @return minimal weight fromNode to the goalNode
+     */
+    double approximate(int fromNode);
+
+    void setGoalNode(int to);
+
+    /**
+     * makes a deep copy of itself
+     */
+    WeightApproximator duplicate();
+}
diff --git a/core/src/main/java/com/graphhopper/search/NameIndex.java b/core/src/main/java/com/graphhopper/search/NameIndex.java
index 53bccab6c8..71c10990cc 100644
--- a/core/src/main/java/com/graphhopper/search/NameIndex.java
+++ b/core/src/main/java/com/graphhopper/search/NameIndex.java
@@ -20,6 +20,7 @@
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Storable;
+import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.Helper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -30,13 +31,13 @@
  */
 public class NameIndex implements Storable<NameIndex>
 {
-    private static Logger logger = LoggerFactory.getLogger(NameIndex.class);
-    private static final int START_POINTER = 1;
-    private int bytePointer = START_POINTER;
-    private DataAccess names;
+    private static final Logger logger = LoggerFactory.getLogger(NameIndex.class);
+    private static final long START_POINTER = 1;
+    private final DataAccess names;
+    private long bytePointer = START_POINTER;
     // minor optimization for the previous stored name
     private String lastName;
-    private int lastIndex;
+    private long lastIndex;
 
     public NameIndex( Directory dir )
     {
@@ -55,7 +56,7 @@ public boolean loadExisting()
     {
         if (names.loadExisting())
         {
-            bytePointer = names.getHeader(0);
+            bytePointer = BitUtil.LITTLE.combineIntsToLong(names.getHeader(0), names.getHeader(1));
             return true;
         }
 
@@ -63,9 +64,9 @@ public boolean loadExisting()
     }
 
     /**
-     * @return the integer reference
+     * @return the byte pointer to the name
      */
-    public int put( String name )
+    public long put( String name )
     {
         if (name == null || name.isEmpty())
         {
@@ -76,7 +77,7 @@ public int put( String name )
             return lastIndex;
         }
         byte[] bytes = getBytes(name);
-        int oldPointer = bytePointer;
+        long oldPointer = bytePointer;
         names.ensureCapacity(bytePointer + 1 + bytes.length);
         byte[] sizeBytes = new byte[]
         {
@@ -119,7 +120,7 @@ public int put( String name )
         return bytes;
     }
 
-    public String get( int pointer )
+    public String get( long pointer )
     {
         if (pointer < 0)
         {
@@ -140,7 +141,8 @@ public String get( int pointer )
     @Override
     public void flush()
     {
-        names.setHeader(0, bytePointer);
+        names.setHeader(0, BitUtil.LITTLE.getIntLow(bytePointer));
+        names.setHeader(4, BitUtil.LITTLE.getIntHigh(bytePointer));
         names.flush();
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
similarity index 59%
rename from core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
rename to core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 6839b38ede..21fbf67926 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTreeSC.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -1,79 +1,99 @@
 /*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  Licensed to Peter Karich under one or more contributor license
+ *  agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
+ *  Peter Karich licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except
+ *  in compliance with the License. You may obtain a copy of the
+ *  License at
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.storage.index;
+package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.AllEdgesSkipIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.LevelGraph;
-import com.graphhopper.util.*;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.EdgeSkipIterator;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.shapes.BBox;
 
 /**
- * The LevelGraph has some edges disconnected (to be more efficient), but this happens before the
- * index is created! So we need to take care of this and also ignore the introduced shortcuts e.g.
- * for calculating closest edges.
- * <p/>
- * TODO avoid some of the tricks if we move a disconnected edge to the end of the edge-list (instead
- * of just disconnecting them). And then while accessing them break iteration if we encounter the
- * first of those disconnected edges (this should have the same speed). Therefor we also need to
- * change the EdgeFilter interface and add a stop(EdgeIterator) method or similar.
- * <p/>
  * @author Peter Karich
  */
-public class LocationIndexTreeSC extends LocationIndexTree
+class BaseGraph implements Graph
 {
-    private final static EdgeFilter NO_SHORTCUT = new EdgeFilter()
-    {
-        @Override
-        public boolean accept( EdgeIteratorState edgeIterState )
-        {
-            return !((EdgeSkipIterator) edgeIterState).isShortcut();
-        }
-    };
     private final LevelGraph lg;
 
-    public LocationIndexTreeSC( LevelGraph g, Directory dir )
+    BaseGraph( LevelGraph lg )
+    {
+        this.lg = lg;
+    }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
+    @Override
+    public int getNodes()
+    {
+        return lg.getNodes();
+    }
+
+    @Override
+    public NodeAccess getNodeAccess()
+    {
+        return lg.getNodeAccess();
+    }
+
+    @Override
+    public BBox getBounds()
+    {
+        return lg.getBounds();
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b )
+    {
+        return lg.edge(a, b);
+    }
+
+    @Override
+    public EdgeIteratorState edge( int a, int b, double distance, boolean bothDirections )
     {
-        super(g, dir);
-        lg = g;
+        return lg.edge(a, b, distance, bothDirections);
     }
 
     @Override
-    protected int pickBestNode( int nodeA, int nodeB )
+    public EdgeIteratorState getEdgeProps( int edgeId, int adjNode )
     {
-        // return lower level nodes as those nodes are always connected to higher ones
-        // (high level nodes are potentially disconnected from lower ones in order to improve performance on Android)
-        if (lg.getLevel(nodeA) < lg.getLevel(nodeB))
-            return nodeA;
-        return nodeB;
+        if (lg.isShortcut(edgeId))
+            throw new IllegalStateException("Do not fetch shortcuts from BaseGraph use the LevelGraph instead");
+
+        return lg.getEdgeProps(edgeId, adjNode);
     }
 
     @Override
-    protected AllEdgesIterator getAllEdges()
+    public AllEdgesIterator getAllEdges()
     {
         final AllEdgesSkipIterator tmpIter = lg.getAllEdges();
         return new AllEdgesIterator()
         {
             @Override
-            public int getMaxId()
+            public int getCount()
             {
-                return tmpIter.getMaxId();
+                return tmpIter.getCount();
             }
 
             @Override
@@ -182,8 +202,48 @@ public EdgeIteratorState detach( boolean reverse )
     }
 
     @Override
-    protected EdgeFilter getEdgeFilter()
+    public EdgeExplorer createEdgeExplorer( final EdgeFilter filter )
+    {
+        if (filter == EdgeFilter.ALL_EDGES)
+            return createEdgeExplorer();
+
+        return lg.createEdgeExplorer(new EdgeFilter()
+        {
+            @Override
+            public boolean accept( EdgeIteratorState edgeIterState )
+            {
+                if (((EdgeSkipIterator) edgeIterState).isShortcut())
+                    return false;
+
+                return filter.accept(edgeIterState);
+            }
+        });
+    }
+
+    private final static EdgeFilter NO_SHORTCUTS = new EdgeFilter()
+    {
+        @Override
+        public boolean accept( EdgeIteratorState edgeIterState )
+        {
+            return !((EdgeSkipIterator) edgeIterState).isShortcut();
+        }
+    };
+
+    @Override
+    public EdgeExplorer createEdgeExplorer()
+    {
+        return lg.createEdgeExplorer(NO_SHORTCUTS);
+    }
+
+    @Override
+    public Graph copyTo( Graph g )
+    {
+        throw new UnsupportedOperationException("Not supported yet.");
+    }
+
+    @Override
+    public GraphExtension getExtension()
     {
-        return NO_SHORTCUT;
+        return lg.getExtension();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/Edge.java b/core/src/main/java/com/graphhopper/storage/Edge.java
deleted file mode 100644
index e4da0fef75..0000000000
--- a/core/src/main/java/com/graphhopper/storage/Edge.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.storage;
-
-/**
- * 'Edges' do not exist as separate objects in GraphHopper for the storage as this would be too
- * memory intensive. Look into EdgeIterator and Graph.getEdges(index) instead. But it is used as
- * base class in all algorithms except the native BidirectionalDijkstra.
- * <p/>
- * @see EdgeEntry
- * @author Peter Karich
- */
-public class Edge implements Comparable<Edge>
-{
-    public int edge;
-    public int adjNode;
-    public double weight;
-
-    public Edge( int edgeId, int adjNode, double weight )
-    {
-        this.edge = edgeId;
-        this.adjNode = adjNode;
-        this.weight = weight;
-    }
-
-    @Override
-    public int compareTo( Edge o )
-    {
-        return Double.compare(weight, o.weight);
-    }
-
-    @Override
-    public String toString()
-    {
-        return adjNode + " (" + edge + ") weight: " + weight;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
index e835cac4c7..184a4ba9fe 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeEntry.java
@@ -22,13 +22,18 @@
  * <p/>
  * @author Peter Karich
  */
-public class EdgeEntry extends Edge implements Cloneable
+public class EdgeEntry implements Cloneable, Comparable<EdgeEntry>
 {
+    public int edge;
+    public int adjNode;
+    public double weight;
     public EdgeEntry parent;
 
     public EdgeEntry( int edgeId, int adjNode, double weight )
     {
-        super(edgeId, adjNode, weight);
+        this.edge = edgeId;
+        this.adjNode = adjNode;
+        this.weight = weight;
     }
 
     @Override
@@ -50,4 +55,16 @@ public EdgeEntry cloneFull()
         }
         return de;
     }
+
+    @Override
+    public int compareTo( EdgeEntry o )
+    {
+        return Double.compare(weight, o.weight);
+    }
+
+    @Override
+    public String toString()
+    {
+        return adjNode + " (" + edge + ") weight: " + weight;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
index d3a50c7956..b075f3864f 100644
--- a/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/GHNodeAccess.java
@@ -36,6 +36,12 @@ public GHNodeAccess( GraphHopperStorage that, boolean withElevation )
         this.elevation = withElevation;
     }
 
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        that.ensureNodeIndex(nodeId);
+    }
+
     @Override
     public final void setNode( int nodeId, double lat, double lon )
     {
@@ -43,10 +49,10 @@ public final void setNode( int nodeId, double lat, double lon )
     }
 
     @Override
-    public final void setNode( int index, double lat, double lon, double ele )
+    public final void setNode( int nodeId, double lat, double lon, double ele )
     {
-        that.ensureNodeIndex(index);
-        long tmp = (long) index * that.nodeEntryBytes;
+        that.ensureNodeIndex(nodeId);
+        long tmp = (long) nodeId * that.nodeEntryBytes;
         that.nodes.setInt(tmp + that.N_LAT, Helper.degreeToInt(lat));
         that.nodes.setInt(tmp + that.N_LON, Helper.degreeToInt(lon));
 
@@ -54,25 +60,13 @@ public final void setNode( int index, double lat, double lon, double ele )
         {
             // meter precision is sufficient for now
             that.nodes.setInt(tmp + that.N_ELE, Helper.eleToInt(ele));
-            if (ele > that.bounds.maxEle)
-                that.bounds.maxEle = ele;
+            that.bounds.update(lat, lon, ele);
 
-            if (ele < that.bounds.minEle)
-                that.bounds.minEle = ele;
+        } else
+        {
+            that.bounds.update(lat, lon);
         }
 
-        if (lat > that.bounds.maxLat)
-            that.bounds.maxLat = lat;
-
-        if (lat < that.bounds.minLat)
-            that.bounds.minLat = lat;
-
-        if (lon > that.bounds.maxLon)
-            that.bounds.maxLon = lon;
-
-        if (lon < that.bounds.minLon)
-            that.bounds.minLon = lon;
-
         // set the default value for the additional field of this node
         if (that.extStorage.isRequireNodeField())
             that.nodes.setInt(tmp + that.N_ADDITIONAL, that.extStorage.getDefaultNodeFieldValue());
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 4ed4457156..65e9c63b26 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -31,6 +31,12 @@
  */
 public interface Graph
 {
+    /**
+     * @return a graph which behaves like an unprepared graph and e.g. the normal unidirectional
+     * Dijkstra or any graph traversal algorithm can be executed.
+     */
+    Graph getBaseGraph();
+
     /**
      * @return the number of created locations - via setNode() or edge()
      */
@@ -100,4 +106,9 @@
      * @return the specified GraphStorage g
      */
     Graph copyTo( Graph g );
+
+    /**
+     * @return the graph extension like a TurnCostExtension
+     */
+    GraphExtension getExtension();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index 2381732ffa..cfcbc63c83 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -117,7 +117,7 @@ public GraphStorage build()
         else
         {
             if (encodingManager.needsTurnCostsSupport())
-                graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostStorage());
+                graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostExtension());
             else
                 graph = new GraphHopperStorage(dir, encodingManager, elevation);
         }
diff --git a/core/src/main/java/com/graphhopper/storage/ExtendedStorage.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
similarity index 82%
rename from core/src/main/java/com/graphhopper/storage/ExtendedStorage.java
rename to core/src/main/java/com/graphhopper/storage/GraphExtension.java
index bafb042ce0..380bf4ec82 100644
--- a/core/src/main/java/com/graphhopper/storage/ExtendedStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -21,7 +21,7 @@
  * If you need custom storages, like turn cost tables, or osmid tables for your graph you implement
  * this interface and put it in any graph storage you want.
  */
-public interface ExtendedStorage
+public interface GraphExtension extends Storable<GraphExtension>
 {
     /**
      * @return true, if and only if, if an additional field at the graphs node storage is required
@@ -48,46 +48,21 @@
      */
     void init( GraphStorage graph );
 
-    /**
-     * creates all additional data storages
-     */
-    void create( long initSize );
-
-    /**
-     * loads from existing data storages
-     */
-    boolean loadExisting();
-
     /**
      * sets the segment size in all additional data storages
      */
     void setSegmentSize( int bytes );
 
-    /**
-     * flushes all additional data storages
-     */
-    void flush();
-
-    /**
-     * closes all additional data storages
-     */
-    void close();
-
-    /**
-     * returns the sum of all additional data storages capacity
-     */
-    long getCapacity();
-
     /**
      * creates a copy of this extended storage
      */
-    ExtendedStorage copyTo( ExtendedStorage extStorage );
+    GraphExtension copyTo( GraphExtension extStorage );
 
     /**
      * default implementation defines no additional fields or any logic. there's like nothing , like
      * the default behavior.
      */
-    public class NoExtendedStorage implements ExtendedStorage
+    public class NoExtendedStorage implements GraphExtension
     {
 
         @Override
@@ -121,9 +96,10 @@ public void init( GraphStorage grap )
         }
 
         @Override
-        public void create( long initSize )
+        public GraphExtension create( long byteCount )
         {
             // noop
+            return this;
         }
 
         @Override
@@ -158,7 +134,7 @@ public long getCapacity()
         }
 
         @Override
-        public ExtendedStorage copyTo( ExtendedStorage extStorage )
+        public GraphExtension copyTo( GraphExtension extStorage )
         {
             // noop
             return extStorage;
@@ -168,6 +144,12 @@ public ExtendedStorage copyTo( ExtendedStorage extStorage )
         public String toString()
         {
             return "NoExt";
-        }       
+        }
+
+        @Override
+        public boolean isClosed()
+        {
+            return false;
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 368d32233c..b3f749525f 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -35,8 +35,6 @@
 
 import static com.graphhopper.util.Helper.nf;
 import java.io.UnsupportedEncodingException;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * The main implementation which handles nodes and edges file format. It can be used with different
@@ -98,16 +96,16 @@
     private final StorableProperties properties;
     private final BitUtil bitUtil;
     private boolean flagsSizeIsLong;
-    final ExtendedStorage extStorage;
+    final GraphExtension extStorage;
     private final NodeAccess nodeAccess;
 
     public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation )
     {
-        this(dir, encodingManager, withElevation, new ExtendedStorage.NoExtendedStorage());
+        this(dir, encodingManager, withElevation, new GraphExtension.NoExtendedStorage());
     }
 
     public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boolean withElevation,
-            ExtendedStorage extendedStorage )
+            GraphExtension extendedStorage )
     {
         if (encodingManager == null)
             throw new IllegalArgumentException("EncodingManager cannot be null in GraphHopperStorage since 0.4. "
@@ -122,11 +120,17 @@ public GraphHopperStorage( Directory dir, EncodingManager encodingManager, boole
         this.wayGeometry = dir.find("geometry");
         this.nameIndex = new NameIndex(dir);
         this.properties = new StorableProperties(dir);
-        this.bounds = BBox.INVERSE.clone();
+        this.bounds = BBox.createInverse(withElevation);
         this.nodeAccess = new GHNodeAccess(this, withElevation);
         extendedStorage.init(this);
     }
 
+    @Override
+    public Graph getBaseGraph()
+    {
+        return this;
+    }
+
     void checkInit()
     {
         if (initialized)
@@ -144,7 +148,7 @@ protected final int nextEdgeEntryIndex( int sizeInBytes )
     protected final int nextNodeEntryIndex( int sizeInBytes )
     {
         int tmp = nodeEntryIndex;
-        nodeEntryIndex += 4;
+        nodeEntryIndex += sizeInBytes;
         return tmp;
     }
 
@@ -511,7 +515,7 @@ public AllEdgeIterator()
         }
 
         @Override
-        public int getMaxId()
+        public int getCount()
         {
             return edgeCount;
         }
@@ -617,8 +621,11 @@ public String getName()
         @Override
         public EdgeIteratorState setName( String name )
         {
-            int nameIndexRef = nameIndex.put(name);
-            edges.setInt(edgePointer + E_NAME, nameIndexRef);
+            long nameIndexRef = nameIndex.put(name);
+            if (nameIndexRef < 0)
+                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
             return this;
         }
 
@@ -692,7 +699,7 @@ private long getFlags( long edgePointer, boolean reverse )
         if (flagsSizeIsLong)
         {
             int high = edges.getInt(edgePointer + E_FLAGS + 4);
-            res = ((long) high << 32) | (low & 0xFFFFFFFFL);
+            res = bitUtil.combineIntsToLong(low, high);
         }
         if (reverse)
             return reverseFlags(edgePointer, res);
@@ -709,12 +716,10 @@ private void setFlags( long edgePointer, boolean reverse, long flags )
         if (reverse)
             flags = reverseFlags(edgePointer, flags);
 
+        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
+
         if (flagsSizeIsLong)
-        {
-            edges.setInt(edgePointer + E_FLAGS, (int) (flags & 0xFFFFFFFFL));
-            edges.setInt(edgePointer + E_FLAGS + 4, (int) (flags >> 32));
-        } else
-            edges.setInt(edgePointer + E_FLAGS, (int) (flags & 0xFFFFFFFFL));
+            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
     }
 
     protected class SingleEdge extends EdgeIterable
@@ -800,13 +805,13 @@ public final boolean next()
                 adjNode = getOtherNode(baseNode, edgePointer);
                 reverse = baseNode > adjNode;
 
-                // position to next edge
+                // position to next edge                
                 nextEdge = edges.getInt(getLinkPosInEdgeArea(baseNode, adjNode, edgePointer));
                 if (nextEdge == edgeId)
                     throw new AssertionError("endless loop detected for " + baseNode + ", " + adjNode
                             + ", " + edgePointer + ", " + edgeId);
 
-                foundNext = filter == null || filter.accept(this);
+                foundNext = filter.accept(this);
                 if (foundNext)
                     break;
             }
@@ -890,8 +895,11 @@ public String getName()
         @Override
         public EdgeIteratorState setName( String name )
         {
-            int nameIndexRef = nameIndex.put(name);
-            edges.setInt(edgePointer + E_NAME, nameIndexRef);
+            long nameIndexRef = nameIndex.put(name);
+            if (nameIndexRef < 0)
+                throw new IllegalStateException("Too many names are stored, currently limited to int pointer");
+
+            edges.setInt(edgePointer + E_NAME, (int) nameIndexRef);
             return this;
         }
 
@@ -901,7 +909,7 @@ public EdgeIteratorState detach( boolean reverseArg )
             if (edgeId == nextEdge)
                 throw new IllegalStateException("call next before detaching");
 
-            EdgeIterable iter = iter = new EdgeIterable(filter);
+            EdgeIterable iter = new EdgeIterable(filter);
             iter.setBaseNode(baseNode);
             iter.setEdgeId(edgeId);
             iter.next();
@@ -1137,7 +1145,7 @@ public void optimize()
         if (delNodes <= 0)
             return;
 
-        // Deletes only nodes. 
+        // Deletes only nodes.
         // It reduces the fragmentation of the node space but introduces new unused edges.
         inPlaceNodeRemove(delNodes);
 
@@ -1287,7 +1295,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
         }
 
         // *rewrites* all edges connected to moved nodes
-        // go through all edges and pick the necessary <- this is easier to implement then
+        // go through all edges and pick the necessary <- this is easier to implement than
         // a more efficient (?) breadth-first search
         EdgeIterator iter = getAllEdges();
         while (iter.next())
@@ -1482,6 +1490,13 @@ protected int loadNodesHeader()
         bounds.maxLon = Helper.intToDegree(nodes.getHeader(4 * 4));
         bounds.minLat = Helper.intToDegree(nodes.getHeader(5 * 4));
         bounds.maxLat = Helper.intToDegree(nodes.getHeader(6 * 4));
+
+        if (bounds.hasElevation())
+        {
+            bounds.minEle = Helper.intToEle(nodes.getHeader(7 * 4));
+            bounds.maxEle = Helper.intToEle(nodes.getHeader(8 * 4));
+        }        
+
         return 7;
     }
 
@@ -1494,6 +1509,12 @@ protected int setNodesHeader()
         nodes.setHeader(4 * 4, Helper.degreeToInt(bounds.maxLon));
         nodes.setHeader(5 * 4, Helper.degreeToInt(bounds.minLat));
         nodes.setHeader(6 * 4, Helper.degreeToInt(bounds.maxLat));
+        if (bounds.hasElevation())
+        {
+            nodes.setHeader(7 * 4, Helper.eleToInt(bounds.minEle));
+            nodes.setHeader(8 * 4, Helper.eleToInt(bounds.maxEle));
+        }
+
         return 7;
     }
 
@@ -1558,7 +1579,7 @@ public boolean isClosed()
     }
 
     @Override
-    public ExtendedStorage getExtendedStorage()
+    public GraphExtension getExtension()    
     {
         return extStorage;
     }
@@ -1575,7 +1596,7 @@ public String toDetailsString()
     {
         return "edges:" + nf(edgeCount) + "(" + edges.getCapacity() / Helper.MB + "), "
                 + "nodes:" + nf(nodeCount) + "(" + nodes.getCapacity() / Helper.MB + "), "
-                + "name: - (" + nameIndex.getCapacity() / Helper.MB + "), "
+                + "name: /(" + nameIndex.getCapacity() / Helper.MB + "), "
                 + "geo:" + nf(maxGeoRef) + "(" + wayGeometry.getCapacity() / Helper.MB + "), "
                 + "bounds:" + bounds;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphStorage.java b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
index f87f91ab09..4a556f3624 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphStorage.java
@@ -45,9 +45,4 @@
      * Performs optimization routines like deletion or node rearrangements.
      */
     void optimize();
-    
-    /**
-     * @return the extended storage, e.g. TurnCostStorage to store turn costs
-     */
-    ExtendedStorage getExtendedStorage();
 }
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraph.java b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
index 8bca2098a9..d7917c32ef 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraph.java
@@ -23,16 +23,29 @@
 import com.graphhopper.util.EdgeSkipIterState;
 
 /**
- * Extended graph interface which supports storing and retrieving the level for a node.
+ * Extended graph interface which supports storing and retrieving the level for a node and creating
+ * shortcuts, which are additional 'artificial' edges to speedup traversal in certain cases.
  * <p/>
  * @author Peter Karich
  */
 public interface LevelGraph extends Graph
 {
-    void setLevel( int index, int level );
-
-    int getLevel( int index );
-
+    /**
+     * This methods sets the level of the specified node.
+     */
+    void setLevel( int nodeId, int level );
+
+    /**
+     * @return the level of the specified node.
+     */
+    int getLevel( int nodeId );
+
+    boolean isShortcut( int edgeId );
+
+    /**
+     * This method creates a shortcut between a to b which is nearly identical to creating an edge
+     * except that it can be excluded or included for certain traversals or algorithms.
+     */
     EdgeSkipIterState shortcut( int a, int b );
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index 1b666abd0c..d16a114944 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -42,10 +42,18 @@
     // after the last edge only shortcuts are stored
     private int lastEdgeIndex = -1;
     private final long scDirMask = PrepareEncoder.getScDirMask();
+    private final Graph baseGraph;
 
     public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D )
     {
         super(dir, encodingManager, enabled3D);
+        baseGraph = new BaseGraph(this);
+    }
+
+    @Override
+    public boolean isShortcut( int edgeId )
+    {
+        return edgeId > lastEdgeIndex;
     }
 
     @Override
@@ -59,17 +67,22 @@ protected void initStorage()
     }
 
     @Override
-    public final void setLevel( int index, int level )
+    public final void setLevel( int nodeIndex, int level )
     {
-        ensureNodeIndex(index);
-        nodes.setInt((long) index * nodeEntryBytes + I_LEVEL, level);
+        if (nodeIndex >= getNodes())
+            return;
+
+        nodes.setInt((long) nodeIndex * nodeEntryBytes + I_LEVEL, level);
     }
 
     @Override
-    public final int getLevel( int index )
+    public final int getLevel( int nodeIndex )
     {
-        ensureNodeIndex(index);
-        return nodes.getInt((long) index * nodeEntryBytes + I_LEVEL);
+        // automatically allocate new nodes only via creating edges or setting node properties
+        if (nodeIndex >= getNodes())
+            throw new IllegalStateException("node " + nodeIndex + " is invalid. Not in [0," + getNodes() + ")");
+
+        return nodes.getInt((long) nodeIndex * nodeEntryBytes + I_LEVEL);
     }
 
     @Override
@@ -267,25 +280,20 @@ long reverseFlags( long edgePointer, long flags )
      */
     public void disconnect( EdgeSkipExplorer explorer, EdgeIteratorState edgeState )
     {
-        // search edge with opposite direction        
+        // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
         // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
         EdgeSkipIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
         int tmpPrevEdge = EdgeIterator.NO_EDGE;
-        boolean found = false;
         while (tmpIter.next())
         {
-            // If we disconnect shortcuts only we could run normal algos on the graph too
-            // BUT CH queries will be 10-20% slower and preparation will be 10% slower
-            if (/*tmpIter.isShortcut() &&*/tmpIter.getEdge() == edgeState.getEdge())
+            if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge())
             {
-                found = true;
+                internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
                 break;
             }
 
             tmpPrevEdge = tmpIter.getEdge();
         }
-        if (found)
-            internalEdgeDisconnect(edgeState.getEdge(), (long) tmpPrevEdge * edgeEntryBytes, edgeState.getAdjNode(), edgeState.getBaseNode());
     }
 
     @Override
@@ -431,4 +439,10 @@ protected int setEdgesHeader()
         edges.setHeader(next * 4, lastEdgeIndex);
         return next + 1;
     }
+
+    @Override
+    public Graph getBaseGraph()
+    {
+        return baseGraph;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
similarity index 88%
rename from core/src/main/java/com/graphhopper/storage/TurnCostStorage.java
rename to core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index c500592291..84f77a6513 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -25,8 +25,9 @@
  * getCosts.
  * <p>
  * @author Karl Hübner
+ * @author Peter Karich
  */
-public class TurnCostStorage implements ExtendedStorage
+public class TurnCostExtension implements GraphExtension
 {
     /* pointer for no cost entry */
     private final int NO_TURN_ENTRY = -1;
@@ -46,7 +47,7 @@
     private GraphStorage graph;
     private NodeAccess nodeAccess;
 
-    public TurnCostStorage()
+    public TurnCostExtension()
     {
         TC_FROM = nextTurnCostEntryIndex();
         TC_TO = nextTurnCostEntryIndex();
@@ -64,7 +65,7 @@ public void init( GraphStorage graph )
 
         this.graph = graph;
         this.nodeAccess = graph.getNodeAccess();
-        this.turnCosts = this.graph.getDirectory().find("turnCosts");
+        this.turnCosts = this.graph.getDirectory().find("turn_costs");
     }
 
     private int nextTurnCostEntryIndex()
@@ -80,9 +81,10 @@ public void setSegmentSize( int bytes )
     }
 
     @Override
-    public void create( long initBytes )
+    public TurnCostExtension create( long initBytes )
     {
         turnCosts.create((long) initBytes * turnCostsEntryBytes);
+        return this;
     }
 
     @Override
@@ -120,7 +122,7 @@ public boolean loadExisting()
      * This method adds a new entry which is a turn restriction or cost information via the
      * turnFlags.
      */
-    public void addTurnInfo( int nodeIndex, int from, int to, long turnFlags )
+    public void addTurnInfo( int from, int viaNode, int to, long turnFlags )
     {
         // no need to store turn information
         if (turnFlags == EMPTY_FLAGS)
@@ -132,11 +134,11 @@ public void addTurnInfo( int nodeIndex, int from, int to, long turnFlags )
         ensureTurnCostIndex(newEntryIndex);
 
         // determine if we already have an cost entry for this node
-        int previousEntryIndex = nodeAccess.getAdditionalNodeField(nodeIndex);
+        int previousEntryIndex = nodeAccess.getAdditionalNodeField(viaNode);
         if (previousEntryIndex == NO_TURN_ENTRY)
         {
             // set cost-pointer to this new cost entry
-            nodeAccess.setAdditionalNodeField(nodeIndex, newEntryIndex);
+            nodeAccess.setAdditionalNodeField(viaNode, newEntryIndex);
         } else
         {
             int i = 0;
@@ -165,27 +167,27 @@ public void addTurnInfo( int nodeIndex, int from, int to, long turnFlags )
     /**
      * @return turn flags of the specified node and edge properties.
      */
-    public long getTurnCostFlags( int node, int edgeFrom, int edgeTo )
+    public long getTurnCostFlags( int edgeFrom, int nodeVia, int edgeTo )
     {
         if (edgeFrom == EdgeIterator.NO_EDGE || edgeTo == EdgeIterator.NO_EDGE)
             throw new IllegalArgumentException("from and to edge cannot be NO_EDGE");
-        if (node < 0)
+        if (nodeVia < 0)
             throw new IllegalArgumentException("via node cannot be negative");
 
-        return nextCostFlags(node, edgeFrom, edgeTo);
+        return nextCostFlags(edgeFrom, nodeVia, edgeTo);
     }
 
-    private long nextCostFlags( int node, int edgeFrom, int edgeTo )
+    private long nextCostFlags( int edgeFrom, int nodeVia, int edgeTo )
     {
-        int turnCostIndex = nodeAccess.getAdditionalNodeField(node);
+        int turnCostIndex = nodeAccess.getAdditionalNodeField(nodeVia);
         int i = 0;
         for (; i < 1000; i++)
         {
             if (turnCostIndex == NO_TURN_ENTRY)
                 break;
-            long turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;            
+            long turnCostPtr = (long) turnCostIndex * turnCostsEntryBytes;
             if (edgeFrom == turnCosts.getInt(turnCostPtr + TC_FROM))
-            {                
+            {
                 if (edgeTo == turnCosts.getInt(turnCostPtr + TC_TO))
                     return turnCosts.getInt(turnCostPtr + TC_FLAGS);
             }
@@ -233,14 +235,14 @@ public int getDefaultEdgeFieldValue()
     }
 
     @Override
-    public ExtendedStorage copyTo( ExtendedStorage clonedStorage )
+    public GraphExtension copyTo( GraphExtension clonedStorage )
     {
-        if (!(clonedStorage instanceof TurnCostStorage))
+        if (!(clonedStorage instanceof TurnCostExtension))
         {
             throw new IllegalStateException("the extended storage to clone must be the same");
         }
 
-        TurnCostStorage clonedTC = (TurnCostStorage) clonedStorage;
+        TurnCostExtension clonedTC = (TurnCostExtension) clonedStorage;
 
         turnCosts.copyTo(clonedTC.turnCosts);
         clonedTC.turnCostsCount = turnCostsCount;
@@ -248,6 +250,12 @@ public ExtendedStorage copyTo( ExtendedStorage clonedStorage )
         return clonedStorage;
     }
 
+    @Override
+    public boolean isClosed()
+    {
+        return turnCosts.isClosed();
+    }
+
     @Override
     public String toString()
     {
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 64e24b3706..8a0a88955f 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -22,8 +22,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.Circle;
 
 /**
@@ -33,7 +32,7 @@
  */
 public class Location2IDFullIndex implements LocationIndex
 {
-    private DistanceCalc calc = new DistancePlaneProjection();
+    private DistanceCalc calc = Helper.DIST_PLANE;
     private final Graph graph;
     private final NodeAccess nodeAccess;
     private boolean closed = false;
@@ -54,9 +53,9 @@ public boolean loadExisting()
     public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         else
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
 
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index 04769a6280..a189adffd4 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -24,6 +24,7 @@
 import com.graphhopper.util.DistancePlaneProjection;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
 
 /**
  * Same as full index but calculates distance to all edges too
@@ -32,7 +33,7 @@
  */
 public class Location2IDFullWithEdgesIndex implements LocationIndex
 {
-    private DistanceCalc calc = new DistanceCalcEarth();
+    private DistanceCalc calc = Helper.DIST_EARTH;
     private final Graph graph;
     private final NodeAccess nodeAccess;
     private boolean closed = false;
@@ -60,10 +61,10 @@ public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
         {
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         } else
         {
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
         }
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 390d763af4..513e17fa7d 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -24,11 +24,7 @@
 import com.graphhopper.geohash.LinearKeyAlgo;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
-import com.graphhopper.util.DistancePlaneProjection;
-import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.BreadthFirstSearch;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import java.util.Arrays;
@@ -50,7 +46,7 @@
     private final static int MAGIC_INT = Integer.MAX_VALUE / 12306;
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private KeyAlgo keyAlgo;
-    protected DistanceCalc distCalc = new DistancePlaneProjection();
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
     private final DataAccess index;
     private double maxRasterWidth2InMeterNormed;
     private final Graph graph;
@@ -69,9 +65,9 @@ public Location2IDQuadtree( Graph g, Directory dir )
     public LocationIndex setApproximation( boolean approxDist )
     {
         if (approxDist)
-            distCalc = new DistancePlaneProjection();
+            distCalc = Helper.DIST_PLANE;
         else
-            distCalc = new DistanceCalcEarth();
+            distCalc = Helper.DIST_EARTH;
 
         return this;
     }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index d056f25101..c3773e96f4 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,25 +17,40 @@
  */
 package com.graphhopper.storage.index;
 
+import gnu.trove.iterator.TIntIterator;
+import gnu.trove.list.array.TIntArrayList;
+import gnu.trove.procedure.TIntProcedure;
+import gnu.trove.set.hash.TIntHashSet;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.geohash.SpatialKeyAlgo;
-import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.util.*;
+import com.graphhopper.util.BitUtil;
+import com.graphhopper.util.BreadthFirstSearch;
+import com.graphhopper.util.DistanceCalc;
+import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PointList;
+import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
-import gnu.trove.iterator.TIntIterator;
-import gnu.trove.list.array.TIntArrayList;
-import gnu.trove.procedure.TIntProcedure;
-import gnu.trove.set.hash.TIntHashSet;
-import java.util.*;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 /**
  * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
@@ -50,8 +65,8 @@
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
     private final int MAGIC_INT;
-    protected DistanceCalc distCalc = new DistancePlaneProjection();
-    private DistanceCalc preciseDistCalc = new DistanceCalcEarth();
+    protected DistanceCalc distCalc = Helper.DIST_PLANE;
+    private DistanceCalc preciseDistCalc = Helper.DIST_EARTH;
     protected final Graph graph;
     private final NodeAccess nodeAccess;
     final DataAccess dataAccess;
@@ -74,12 +89,19 @@
      */
     private double equalNormedDelta;
 
+    /**
+     * @param g the graph for which this index should do the lookup based on latitude,longitude.
+     * @param dir
+     */
     public LocationIndexTree( Graph g, Directory dir )
     {
+        if (g instanceof LevelGraph)
+            throw new IllegalArgumentException("Call LevelGraph.getBaseGraph() instead of using the LevelGraph itself");
+
         MAGIC_INT = Integer.MAX_VALUE / 22316;
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
-        dataAccess = dir.find("locationIndex");
+        dataAccess = dir.find("location_index");
     }
 
     public int getMinResolutionInMeter()
@@ -121,17 +143,15 @@ void prepareAlgo()
         equalNormedDelta = distCalc.calcNormalizedDist(0.1);
 
         // now calculate the necessary maxDepth d for our current bounds
-        // if we assume a minimum resolution like 0.5km for a leaf-tile                
+        // if we assume a minimum resolution like 0.5km for a leaf-tile
         // n^(depth/2) = toMeter(dLon) / minResolution
         BBox bounds = graph.getBounds();
-        int nodes = graph.getNodes();
-		if (nodes == 0) {
-			throw new IllegalStateException("No Nodes");
-		}
-		if(!bounds.check()) {
-            throw new IllegalStateException("Bounds of graph are invalid: " + bounds);
-		}
-		
+        if (graph.getNodes() == 0)
+            throw new IllegalStateException("Cannot create location index of empty graph!");
+
+        if (!bounds.isValid())
+            throw new IllegalStateException("Cannot create location index when graph has invalid bounds: " + bounds);
+
         double lat = Math.min(Math.abs(bounds.maxLat), Math.abs(bounds.minLat));
         double maxDistInMeter = Math.max(
                 (bounds.maxLat - bounds.minLat) / 360 * DistanceCalcEarth.C,
@@ -181,7 +201,7 @@ void prepareAlgo()
     private LocationIndexTree initEntries( int[] entries )
     {
         if (entries.length < 1)
-        // at least one depth should have been specified
+            // at least one depth should have been specified
         {
             throw new IllegalStateException("depth needs to be at least 1");
         }
@@ -275,9 +295,9 @@ public LocationIndex setResolution( int minResolutionInMeter )
     public LocationIndex setApproximation( boolean approx )
     {
         if (approx)
-            distCalc = new DistancePlaneProjection();
+            distCalc = Helper.DIST_PLANE;
         else
-            distCalc = new DistanceCalcEarth();
+            distCalc = Helper.DIST_EARTH;
         return this;
     }
 
@@ -376,7 +396,7 @@ public InMemConstructionIndex( int noOfSubEntries )
 
         void prepare()
         {
-            final EdgeIterator allIter = getAllEdges();
+            final EdgeIterator allIter = graph.getAllEdges();
             try
             {
                 while (allIter.next())
@@ -420,7 +440,7 @@ public void set( double lat, double lon )
                     long key = keyAlgo.encode(lat, lon);
                     long keyPart = createReverseKey(key);
                     // no need to feed both nodes as we search neighbors in fillIDs
-                    addNode(root, pickBestNode(nodeA, nodeB), 0, keyPart, key);
+                    addNode(root, nodeA, 0, keyPart, key);
                 }
             };
             BresenhamLine.calcPoints(lat1, lon1, lat2, lon2, pointEmitter,
@@ -438,29 +458,29 @@ void addNode( InMemEntry entry, int nodeId, int depth, long keyPart, long key )
             {
                 int index = (int) (bitmasks[depth] & keyPart);
                 keyPart = keyPart >>> shifts[depth];
-                InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
-                InMemEntry subentry = treeEntry.getSubEntry(index);
-                depth++;
-                if (subentry == null)
-                {
-                    if (depth == entries.length)
-                    {
-                        subentry = new InMemLeafEntry(initSizeLeafEntries, key);
-                    } else
-                    {
-                        subentry = new InMemTreeEntry(entries[depth]);
-                    }
-                    treeEntry.setSubEntry(index, subentry);
-                }
+        InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
+        InMemEntry subentry = treeEntry.getSubEntry(index);
+        depth++;
+        if (subentry == null)
+        {
+            if (depth == entries.length)
+            {
+                subentry = new InMemLeafEntry(initSizeLeafEntries, key);
+            } else
+            {
+                subentry = new InMemTreeEntry(entries[depth]);
+            }
+            treeEntry.setSubEntry(index, subentry);
+        }
 
-                addNode(subentry, nodeId, depth, keyPart, key);
+        addNode(subentry, nodeId, depth, keyPart, key);
             }
         }
 
         Collection<InMemEntry> getEntriesOf( int selectDepth )
         {
             List<InMemEntry> list = new ArrayList<InMemEntry>();
-            fillLayer(list, selectDepth, 0, ((InMemTreeEntry) root).getSubEntriesForDebug());
+            fillLayer(list, selectDepth, 0, root.getSubEntriesForDebug());
             return list;
         }
 
@@ -530,7 +550,7 @@ int store( InMemEntry entry, int intIndex )
                 size += len;
                 intIndex++;
                 leafs++;
-                dataAccess.ensureCapacity((long)(intIndex + len + 1) * 4);
+                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
                 if (len == 1)
                 {
                     // less disc space for single entries
@@ -555,7 +575,7 @@ int store( InMemEntry entry, int intIndex )
                     {
                         continue;
                     }
-                    dataAccess.ensureCapacity((long)(intIndex + 1) * 4);
+                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
                     int beforeIntIndex = intIndex;
                     intIndex = store(subEntry, beforeIntIndex);
                     if (intIndex == beforeIntIndex)
@@ -584,7 +604,7 @@ final void fillIDs( long keyPart, int intIndex, TIntHashSet set, int depth )
         {
             int value = dataAccess.getInt(pointer);
             if (value < 0)
-            // single data entries (less disc space)            
+                // single data entries (less disc space)
             {
                 set.add(-(value + 1));
             } else
@@ -789,11 +809,11 @@ public QueryResult findClosest( final double queryLat, final double queryLon, fi
         // clone storedIds to avoid interference with forEach
         final GHBitSet checkBitset = new GHTBitSet(new TIntHashSet(storedNetworkEntryIds));
         // find nodes from the network entries which are close to 'point'
-        final EdgeExplorer explorer = graph.createEdgeExplorer(getEdgeFilter());
+        final EdgeExplorer explorer = graph.createEdgeExplorer();
         storedNetworkEntryIds.forEach(new TIntProcedure()
         {
             @Override
-            public boolean execute( final int networkEntryNodeId )
+            public boolean execute( int networkEntryNodeId )
             {
                 new XFirstSearchCheck(queryLat, queryLon, checkBitset, edgeFilter)
                 {
@@ -824,7 +844,7 @@ protected boolean check( int node, double normedDist, int wayIndex, EdgeIterator
 
         if (closestMatch.isValid())
         {
-            // denormalize distance            
+            // denormalize distance
             closestMatch.setQueryDistance(distCalc.calcDenormalizedDist(closestMatch.getQueryDistance()));
             closestMatch.calcSnappedPoint(distCalc);
         }
@@ -912,16 +932,19 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
                     tmpNormedDist = distCalc.calcNormalizedEdgeDistance(queryLat, queryLon,
                             tmpLat, tmpLon, wayLat, wayLon);
                     check(tmpClosestNode, tmpNormedDist, pointIndex, currEdge, pos);
-                } else if (pointIndex + 1 == len)
-                {
-                    tmpNormedDist = adjDist;
-                    pos = QueryResult.Position.TOWER;
                 } else
                 {
-                    tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
-                    pos = QueryResult.Position.PILLAR;
+                    if (pointIndex + 1 == len)
+                    {
+                        tmpNormedDist = adjDist;
+                        pos = QueryResult.Position.TOWER;
+                    } else
+                    {
+                        tmpNormedDist = distCalc.calcNormalizedDist(queryLat, queryLon, wayLat, wayLon);
+                        pos = QueryResult.Position.PILLAR;
+                    }
+                    check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
                 }
-                check(tmpClosestNode, tmpNormedDist, pointIndex + 1, currEdge, pos);
 
                 if (tmpNormedDist <= equalNormedDelta)
                     return false;
@@ -937,23 +960,6 @@ protected boolean checkAdjacent( EdgeIteratorState currEdge )
         protected abstract boolean check( int node, double normedDist, int wayIndex, EdgeIteratorState iter, QueryResult.Position pos );
     }
 
-    protected int pickBestNode( int nodeA, int nodeB )
-    {
-        // For normal graph the node does not matter because if nodeA is conntected to nodeB
-        // then nodeB is also connect to nodeA, but for a LevelGraph this does not apply.
-        return nodeA;
-    }
-
-    protected EdgeFilter getEdgeFilter()
-    {
-        return EdgeFilter.ALL_EDGES;
-    }
-
-    protected AllEdgesIterator getAllEdges()
-    {
-        return graph.getAllEdges();
-    }
-
     // make entries static as otherwise we get an additional reference to this class (memory waste)
     static interface InMemEntry
     {
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index 80efeb8ae1..c371733f82 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -44,6 +44,14 @@
     private GHPoint3D snappedPoint;
     private Position snappedPosition;
 
+    /**
+     * Due to precision differences it is hard to define when something is exactly 90° or "on-node"
+     * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
+     * "on-edge" even if it could be 90°. To prefer "on-node" you could use e.g. GHPoint.equals with
+     * a default precision of 1e-6.
+     * <p>
+     * @see DistanceCalc#validEdgeDistance
+     */
     public static enum Position
     {
         EDGE, TOWER, PILLAR
diff --git a/core/src/main/java/com/graphhopper/util/AngleCalc.java b/core/src/main/java/com/graphhopper/util/AngleCalc.java
index 4b1a3f1f65..5e98e3ca80 100644
--- a/core/src/main/java/com/graphhopper/util/AngleCalc.java
+++ b/core/src/main/java/com/graphhopper/util/AngleCalc.java
@@ -87,13 +87,13 @@ public double alignOrientation( double baseOrientation, double orientation )
     }
 
     /**
-     * Calculate Azimuth for a line given by two coordinates. Direction in 'degree' where 0 is
-     * north, 90 is east, 180 is south and 270 is west.
+     * Calculate the azimuth in degree for a line given by two coordinates. Direction in 'degree'
+     * where 0 is north, 90 is east, 180 is south and 270 is west.
      */
     double calcAzimuth( double lat1, double lon1, double lat2, double lon2 )
     {
         double orientation = -calcOrientation(lat1, lon1, lat2, lon2);
-        orientation = Helper.round4(orientation + Math.PI / 2);        
+        orientation = Helper.round4(orientation + Math.PI / 2);
         if (orientation < 0)
             orientation += 2 * Math.PI;
 
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index 2cc2bf043a..11957181dd 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -195,6 +195,9 @@ public final long fromBitString2Long( String str )
 
     public abstract byte[] fromBitString( String str );
 
+    /**
+     * Similar to Long.toBinaryString
+     */
     public final String toBitString( long value )
     {
         return toBitString(value, 64);
@@ -265,6 +268,21 @@ public final long reverse( long value, int maxBits )
         return res;
     }
 
+    public final int getIntLow( long longValue )
+    {
+        return (int) (longValue & 0xFFFFFFFFL);
+    }
+
+    public final int getIntHigh( long longValue )
+    {
+        return (int) (longValue >> 32);
+    }
+
+    public final long combineIntsToLong( int intLow, int intHigh )
+    {
+        return ((long) intHigh << 32) | (intLow & 0xFFFFFFFFL);
+    }
+
     public final long reverseLeft( long value, int maxBits )
     {
         long res = 0;
diff --git a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
index dab4a9bd47..05d3a3d009 100644
--- a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import com.graphhopper.coll.GHBitSet;
-import com.graphhopper.coll.GHBitSetImpl;
 
 /**
  * Implementattion of breadth first search (BFS)
@@ -27,9 +26,8 @@
  */
 public class BreadthFirstSearch extends XFirstSearch
 {
-
     @Override
-    public void start( EdgeExplorer explorer, int startNode)
+    public void start( EdgeExplorer explorer, int startNode )
     {
         SimpleIntDeque fifo = new SimpleIntDeque();
         GHBitSet visited = createBitSet();
@@ -39,20 +37,19 @@ public void start( EdgeExplorer explorer, int startNode)
         while (!fifo.isEmpty())
         {
             current = fifo.pop();
-            if (goFurther(current))
+            if (!goFurther(current))
+                continue;
+
+            EdgeIterator iter = explorer.setBaseNode(current);
+            while (iter.next())
             {
-                EdgeIterator iter = explorer.setBaseNode(current);
-                while (iter.next())
+                int connectedId = iter.getAdjNode();
+                if (checkAdjacent(iter) && !visited.contains(connectedId))
                 {
-                    int connectedId = iter.getAdjNode();
-                    if (checkAdjacent(iter) && !visited.contains(connectedId))
-                    {
-                        visited.add(connectedId);
-                        fifo.push(connectedId);
-                    }
+                    visited.add(connectedId);
+                    fifo.push(connectedId);
                 }
             }
         }
     }
-
 }
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 7eac90a65e..61922dbdc7 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -50,8 +50,8 @@
     public static final String OS_ARCH = System.getProperty("os.arch");
     public static final String OS_VERSION = System.getProperty("os.version");
     public static final String JAVA_VENDOR = System.getProperty("java.vendor");
-    public static final int VERSION_NODE = 3;
-    public static final int VERSION_EDGE = 9;
+    public static final int VERSION_NODE = 4;
+    public static final int VERSION_EDGE = 11;
     public static final int VERSION_GEOMETRY = 3;
     public static final int VERSION_LOCATION_IDX = 2;
     public static final int VERSION_NAME_IDX = 2;
diff --git a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
index 7e7056cecb..987657798a 100644
--- a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
@@ -23,28 +23,28 @@
 /**
  * Implementation of depth first search (DFS) by LIFO queue
  * <p/>
- * @author Peter Karich & Jan Sölter
+ * @author Peter Karich
+ * @author Jan Sölter
  */
 public class DepthFirstSearch extends XFirstSearch
 {
-
     /**
      * beginning with startNode add all following nodes to LIFO queue. If node has been already
      * explored before, skip reexploration.
      */
     @Override
-    public void start( EdgeExplorer explorer, int startNode)
+    public void start( EdgeExplorer explorer, int startNode )
     {
         TIntArrayStack stack = new TIntArrayStack();
 
         GHBitSet explored = createBitSet();
         stack.push(startNode);
         int current;
-        while (stack.size()>0)
+        while (stack.size() > 0)
         {
             current = stack.pop();
             if (!explored.contains(current) && goFurther(current))
-            {   
+            {
                 EdgeIterator iter = explorer.setBaseNode(current);
                 while (iter.next())
                 {
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc.java b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
index 0a58b949f5..d0ea52f8a4 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc.java
@@ -55,20 +55,23 @@
     double calcNormalizedDist( double fromLat, double fromLon, double toLat, double toLon );
 
     /**
-     * This method decides case 1: if we should use distance(r to edge) where r=(lat,lon) or case 2:
-     * min(distance(r to a), distance(r to b)) where edge=(a to b)
-     * <p/>
-     * @return true for case 1
+     * This method decides for case 1: if we should use distance(r to edge) where r=(lat,lon) or
+     * case 2: min(distance(r to a), distance(r to b)) where edge=(a to b). Note that due to
+     * rounding errors it cannot properly detect if it is case 1 or 90°.
+     * <pre>
+     * case 1 (including ):
+     *   r
+     *  .
+     * a-------b
+     *
+     * case 2:
+     * r
+     *  .
+     *    a-------b
+     * </pre>
+     * <p>
+     * @return true for case 1 which is "on edge" or the special case of 90° to the edge
      */
-    // case 1:
-    //   r
-    //  . 
-    // a-------b
-    //    
-    // case 2:
-    // r
-    //  .
-    //    a-------b
     boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
             double b_lat_deg, double b_lon_deg );
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 209ee796c8..7e21bb6055 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -214,21 +214,6 @@ else if (factor < 0)
         return new GHPoint(c_lat, c_lon / shrink_factor);
     }
 
-    /**
-     * This method decides case 1: if we should use distance(r to edge) where r=(lat,lon) or case 2:
-     * min(distance(r to a), distance(r to b)) where edge=(a to b)
-     * <p/>
-     * @return true for case 1
-     */
-    // case 1:
-    //   r
-    //  . 
-    // a-------b
-    //    
-    // case 2:
-    // r
-    //  .
-    //    a-------b
     @Override
     public boolean validEdgeDistance( double r_lat_deg, double r_lon_deg,
             double a_lat_deg, double a_lon_deg,
diff --git a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java b/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
index e210cb7fbd..112bbaa1ab 100644
--- a/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
+++ b/core/src/main/java/com/graphhopper/util/DistancePlaneProjection.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.util.AngleCalc;
 import static java.lang.Math.*;
 
 /**
diff --git a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
index 24c0e94798..db35c29f03 100644
--- a/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
+++ b/core/src/main/java/com/graphhopper/util/DouglasPeucker.java
@@ -42,9 +42,9 @@ public void setApproximation( boolean a )
     {
         approx = a;
         if (approx)
-            calc = new DistancePlaneProjection();
+            calc = Helper.DIST_PLANE;
         else
-            calc = new DistanceCalcEarth();
+            calc = Helper.DIST_EARTH;
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/Downloader.java b/core/src/main/java/com/graphhopper/util/Downloader.java
index 4014857e44..297a917ccb 100644
--- a/core/src/main/java/com/graphhopper/util/Downloader.java
+++ b/core/src/main/java/com/graphhopper/util/Downloader.java
@@ -29,7 +29,6 @@
  */
 public class Downloader
 {
-
     public static void main( String[] args ) throws IOException
     {
         new Downloader("GraphHopper Downloader").downloadAndUnzip("http://graphhopper.com/public/maps/0.1/europe_germany_berlin.ghz", "somefolder",
@@ -46,7 +45,6 @@ public void update( long val )
     private final String userAgent;
     private String acceptEncoding = "gzip, deflate";
     private int timeout = 4000;
-    private int size = 1024 * 8;
 
     public Downloader( String userAgent )
     {
@@ -107,6 +105,7 @@ public void downloadFile( String url, String toFile ) throws IOException
     {
         HttpURLConnection conn = createConnection(url);
         InputStream iStream = fetch(conn);
+        int size = 8 * 1024;
         BufferedOutputStream writer = new BufferedOutputStream(new FileOutputStream(toFile), size);
         InputStream in = new BufferedInputStream(iStream, size);
         try
@@ -130,7 +129,7 @@ public void downloadAndUnzip( String url, String toFolder, final ProgressListene
         final int length = conn.getContentLength();
         InputStream iStream = fetch(conn);
 
-        new Unzipper().setSize(size).unzip(iStream, new File(toFolder), new ProgressListener()
+        new Unzipper().unzip(iStream, new File(toFolder), new ProgressListener()
         {
             @Override
             public void update( long sumBytes )
@@ -142,26 +141,6 @@ public void update( long sumBytes )
 
     public String downloadAsString( String url ) throws IOException
     {
-        return readString(fetch(url));
-    }
-
-    private String readString( InputStream inputStream ) throws IOException
-    {
-        String encoding = "UTF-8";
-        InputStream in = new BufferedInputStream(inputStream, size);
-        try
-        {
-            byte[] buffer = new byte[size];
-            ByteArrayOutputStream output = new ByteArrayOutputStream();
-            int numRead;
-            while ((numRead = in.read(buffer)) != -1)
-            {
-                output.write(buffer, 0, numRead);
-            }
-            return output.toString(encoding);
-        } finally
-        {
-            in.close();
-        }
+        return Helper.isToString(fetch(url));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index d0b64b939e..b59f453b7b 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.storage.NodeAccess;
+
 /**
  * @author Peter Karich
  */
@@ -27,13 +29,19 @@
     public FinishInstruction( final double lat, final double lon, final double ele )
     {
         super(FINISH, "", InstructionAnnotation.EMPTY, new PointList(2, true)
-        {   
+        {
             {
                 add(lat, lon, ele);
             }
         });
     }
 
+    public FinishInstruction( NodeAccess nodeAccess, int node )
+    {
+        this(nodeAccess.getLatitude(node), nodeAccess.getLongitude(node),
+                nodeAccess.is3D() ? nodeAccess.getElevation(node) : 0);
+    }
+
     void setVia( int i )
     {
         sign = REACHED_VIA;
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index d3b0b2d93b..25902783fb 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -129,7 +129,7 @@ public static int count( EdgeIterator iter )
 
     public static void printEdgeInfo( final Graph g, FlagEncoder encoder )
     {
-        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getMaxId() + " ---");
+        System.out.println("-- Graph n:" + g.getNodes() + " e:" + g.getAllEdges().getCount() + " ---");
         AllEdgesIterator iter = g.getAllEdges();
         while (iter.next())
         {
diff --git a/core/src/main/java/com/graphhopper/util/Helper.java b/core/src/main/java/com/graphhopper/util/Helper.java
index 4a41404b17..5e56078c64 100644
--- a/core/src/main/java/com/graphhopper/util/Helper.java
+++ b/core/src/main/java/com/graphhopper/util/Helper.java
@@ -42,7 +42,9 @@
  */
 public class Helper
 {
-    private static final DistanceCalc dce = new DistanceCalcEarth();
+    public static final DistanceCalc DIST_EARTH = new DistanceCalcEarth();
+    public static final DistanceCalc3D DIST_3D = new DistanceCalc3D();
+    public static final DistancePlaneProjection DIST_PLANE = new DistancePlaneProjection();
     private static final Logger logger = LoggerFactory.getLogger(Helper.class);
     public static Charset UTF_CS = Charset.forName("UTF-8");
     public static final long MB = 1L << 20;
@@ -163,6 +165,27 @@ public static void saveProperties( Map<String, String> map, Writer tmpWriter ) t
         }
     }
 
+    public static String isToString( InputStream inputStream ) throws IOException
+    {
+        int size = 1024 * 8;
+        String encoding = "UTF-8";
+        InputStream in = new BufferedInputStream(inputStream, size);
+        try
+        {
+            byte[] buffer = new byte[size];
+            ByteArrayOutputStream output = new ByteArrayOutputStream();
+            int numRead;
+            while ((numRead = in.read(buffer)) != -1)
+            {
+                output.write(buffer, 0, numRead);
+            }
+            return output.toString(encoding);
+        } finally
+        {
+            in.close();
+        }
+    }
+
     public static int idealIntArraySize( int need )
     {
         return idealByteArraySize(need * 4) / 4;
@@ -271,7 +294,7 @@ public static int calcIndexSize( BBox graphBounds )
         if (!graphBounds.isValid())
             throw new IllegalArgumentException("Bounding box is not valid to calculate index size: " + graphBounds);
 
-        double dist = dce.calcDist(graphBounds.maxLat, graphBounds.minLon,
+        double dist = DIST_EARTH.calcDist(graphBounds.maxLat, graphBounds.minLon,
                 graphBounds.minLat, graphBounds.maxLon);
         // convert to km and maximum is 50000km => 1GB
         dist = Math.min(dist / 1000, 50000);
@@ -335,6 +358,8 @@ public static final int degreeToInt( double deg )
     {
         if (deg >= Double.MAX_VALUE)
             return Integer.MAX_VALUE;
+        if (deg <= -Double.MAX_VALUE)
+            return -Integer.MAX_VALUE;
         return (int) (deg * DEGREE_FACTOR);
     }
 
@@ -347,6 +372,8 @@ public static final double intToDegree( int storedInt )
     {
         if (storedInt == Integer.MAX_VALUE)
             return Double.MAX_VALUE;
+        if (storedInt == -Integer.MAX_VALUE)
+            return -Double.MAX_VALUE;
         return (double) storedInt / DEGREE_FACTOR;
     }
 
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index da4e2dabf3..ab9bb92d6d 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,12 +17,16 @@
  */
 package com.graphhopper.util;
 
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 public class Instruction
 {
     private static final AngleCalc ac = new AngleCalc();
-    private static final DistanceCalc3D distanceCalc = new DistanceCalc3D();
+
+    public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
     public static final int TURN_SLIGHT_LEFT = -1;
@@ -32,18 +36,20 @@
     public static final int TURN_SHARP_RIGHT = 3;
     public static final int FINISH = 4;
     public static final int REACHED_VIA = 5;
+    public static final int USE_ROUNDABOUT = 6;
+
     protected int sign;
-    private final String name;
-    private double distance;
-    private long time;
-    final PointList points;
-    private final InstructionAnnotation annotation;
+    protected String name;
+    protected double distance;
+    protected long time;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
      * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl)
     {
         this.sign = sign;
         this.name = name;
@@ -56,19 +62,34 @@ public InstructionAnnotation getAnnotation()
         return annotation;
     }
 
+    /**
+     * The instruction for the person/driver to execute.
+     */
     public int getSign()
     {
         return sign;
     }
 
-    /**
-     * The instruction for the person/driver to execute.
-     */
     public String getName()
     {
         return name;
     }
 
+    public void setName(String name)
+    {
+        this.name = name;
+    }
+
+    public Map<String,Object> getExtraInfoJSON()
+    {
+        return Collections.<String, Object>emptyMap();
+    }
+
+    public void setExtraInfo(String key, Object value)
+    {
+        throw new IllegalArgumentException("Key" + key + " is not a valid option");
+    }
+
     public Instruction setDistance( double distance )
     {
         this.distance = distance;
@@ -144,16 +165,16 @@ long fillGPXList( List<GPXEntry> list, long time,
 
         for (int i = 0; i < len; i++)
         {
+            list.add(new GPXEntry(lat, lon, ele, prevTime));
+
             boolean last = i + 1 == len;
             double nextLat = last ? nextInstr.getFirstLat() : points.getLatitude(i + 1);
             double nextLon = last ? nextInstr.getFirstLon() : points.getLongitude(i + 1);
             double nextEle = is3D ? (last ? nextInstr.getFirstEle() : points.getElevation(i + 1)) : Double.NaN;
-
-            list.add(new GPXEntry(lat, lon, ele, prevTime));
             if (is3D)
-                prevTime = Math.round(prevTime + this.time * distanceCalc.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
+                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
             else
-                prevTime = Math.round(prevTime + this.time * distanceCalc.calcDist(nextLat, nextLon, lat, lon) / distance);
+                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, lat, lon) / distance);
 
             lat = nextLat;
             lon = nextLon;
@@ -176,12 +197,10 @@ public String toString()
     }
 
     /**
-     * Return Direction/Compass point based on the first tracksegment of the instruction. If
+     * Return the direction like 'NE' based on the first tracksegment of the instruction. If
      * Instruction does not contain enough coordinate points, an empty string will be returned.
-     * <p>
-     * @return
      */
-    String getDirection( Instruction nextI )
+    String calcDirection( Instruction nextI )
     {
         double azimuth = calcAzimuth(nextI);
         if (Double.isNaN(azimuth))
@@ -191,19 +210,10 @@ String getDirection( Instruction nextI )
     }
 
     /**
-     * Return Azimuth based on the first tracksegment of the instruction. If Instruction does not
-     * contain enough coordinate points, an empty string will be returned.
+     * Return the azimuth in degree based on the first tracksegment of the instruction. If
+     * Instruction does not contain enough coordinate points, an empty string will be returned.
      */
-    String getAzimuth( Instruction nextI )
-    {
-        double az = calcAzimuth(nextI);
-        if (Double.isNaN(az))
-            return "";
-
-        return "" + Math.round(az);
-    }
-
-    private double calcAzimuth( Instruction nextI )
+    public double calcAzimuth( Instruction nextI )
     {
         double nextLat;
         double nextLon;
@@ -212,7 +222,7 @@ private double calcAzimuth( Instruction nextI )
         {
             nextLat = points.getLatitude(1);
             nextLon = points.getLongitude(1);
-        } else if (points.getSize() == 1 && null != nextI)
+        } else if (nextI != null && points.getSize() == 1)
         {
             nextLat = nextI.points.getLatitude(0);
             nextLon = nextI.points.getLongitude(0);
@@ -235,7 +245,7 @@ void checkOne()
     public String getTurnDescription( Translation tr )
     {
         String str;
-        String n = getName();
+        String streetName = getName();
         int indi = getSign();
         if (indi == Instruction.FINISH)
         {
@@ -245,35 +255,35 @@ public String getTurnDescription( Translation tr )
             str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
         } else if (indi == Instruction.CONTINUE_ON_STREET)
         {
-            str = Helper.isEmpty(n) ? tr.tr("continue") : tr.tr("continue_onto", n);
+            str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
         } else
         {
             String dir = null;
             switch (indi)
             {
                 case Instruction.TURN_SHARP_LEFT:
-                    dir = tr.tr("sharp_left");
+                    dir = tr.tr("turn_sharp_left");
                     break;
                 case Instruction.TURN_LEFT:
-                    dir = tr.tr("left");
+                    dir = tr.tr("turn_left");
                     break;
                 case Instruction.TURN_SLIGHT_LEFT:
-                    dir = tr.tr("slight_left");
+                    dir = tr.tr("turn_slight_left");
                     break;
                 case Instruction.TURN_SLIGHT_RIGHT:
-                    dir = tr.tr("slight_right");
+                    dir = tr.tr("turn_slight_right");
                     break;
                 case Instruction.TURN_RIGHT:
-                    dir = tr.tr("right");
+                    dir = tr.tr("turn_right");
                     break;
                 case Instruction.TURN_SHARP_RIGHT:
-                    dir = tr.tr("sharp_right");
+                    dir = tr.tr("turn_sharp_right");
                     break;
             }
             if (dir == null)
-                throw new IllegalStateException("Indication not found " + indi);
+                throw new IllegalStateException("Turn indication not found " + indi);
 
-            str = Helper.isEmpty(n) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, n);
+            str = Helper.isEmpty(streetName) ? dir : tr.tr("turn_onto", dir, streetName);
         }
         return str;
     }
diff --git a/core/src/main/java/com/graphhopper/util/InstructionList.java b/core/src/main/java/com/graphhopper/util/InstructionList.java
index f1b63173a0..5d36783569 100644
--- a/core/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/core/src/main/java/com/graphhopper/util/InstructionList.java
@@ -61,47 +61,6 @@ public int size()
         return instructions.size();
     }
 
-    /**
-     * Returns the descriptions of the distance per instruction.
-     */
-    public List<String> createDistances( boolean mile )
-    {
-        List<String> labels = new ArrayList<String>(instructions.size());
-        for (int i = 0; i < instructions.size(); i++)
-        {
-            double distInMeter = instructions.get(i).getDistance();
-            if (mile)
-            {
-                // calculate miles
-                double distInMiles = distInMeter / 1000 / DistanceCalcEarth.KM_MILE;
-                if (distInMiles < 0.9)
-                {
-                    labels.add((int) Helper.round(distInMiles * 5280, 1) + " " + tr.tr("ftAbbr"));
-                } else
-                {
-                    if (distInMiles < 100)
-                        labels.add(Helper.round(distInMiles, 2) + " " + tr.tr("miAbbr"));
-                    else
-                        labels.add((int) Helper.round(distInMiles, 1) + " " + tr.tr("miAbbr"));
-                }
-            } else
-            {
-                if (distInMeter < 950)
-                {
-                    labels.add((int) Helper.round(distInMeter, 1) + " " + tr.tr("mAbbr"));
-                } else
-                {
-                    distInMeter /= 1000;
-                    if (distInMeter < 100)
-                        labels.add(Helper.round(distInMeter, 2) + " " + tr.tr("kmAbbr"));
-                    else
-                        labels.add((int) Helper.round(distInMeter, 1) + " " + tr.tr("kmAbbr"));
-                }
-            }
-        }
-        return labels;
-    }
-
     public List<Map<String, Object>> createJson()
     {
         List<Map<String, Object>> instrList = new ArrayList<Map<String, Object>>(instructions.size());
@@ -126,6 +85,7 @@ public int size()
             instrJson.put("time", instruction.getTime());
             instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
             instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
 
             int tmpIndex = pointsIndex + instruction.getPoints().size();
             // the last instruction should not point to the next instruction
@@ -219,9 +179,12 @@ public String createGPX( String trackName, long startTimeMillis, String timeZone
         formatter.setTimeZone(tz);
         String header = "<?xml version='1.0' encoding='UTF-8' standalone='no' ?>"
                 + "<gpx xmlns='http://www.topografix.com/GPX/1/1' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'"
-                + " xsi:schemaLocation='https://graphhopper.com/public/schema https://graphhopper.com/public/schema/gpx-1.1.xsd'"
-                + " creator='Graphhopper' version='1.1'>"
-                + "<metadata>"
+                + " creator='Graphhopper' version='1.1'"
+                // This xmlns:gh acts only as ID, no valid URL necessary.
+                // Use a separate namespace for custom extensions to make basecamp happy.
+                + " xmlns:gh='https://graphhopper.com/public/schema/gpx/1.1'>"
+                + "\n<metadata>"
+                + "<copyright author=\"OpenStreetMap contributors\"/>"
                 + "<link href='http://graphhopper.com'>"
                 + "<text>GraphHopper GPX</text>"
                 + "</link>"
@@ -230,36 +193,35 @@ public String createGPX( String trackName, long startTimeMillis, String timeZone
         StringBuilder track = new StringBuilder(header);
         if (!isEmpty())
         {
-            track.append("<rte>");
-            Instruction nextI = null;
-            for (Instruction instr : instructions)
+            track.append("\n<rte>");
+            Instruction nextInstr = null;
+            for (Instruction currInstr : instructions)
             {
-                if (null != nextI)
-                    createRteptBlock(track, nextI, instr);
+                if (null != nextInstr)
+                    createRteptBlock(track, nextInstr, currInstr);
 
-                nextI = instr;
+                nextInstr = currInstr;
             }
-            createRteptBlock(track, nextI, null);
+            createRteptBlock(track, nextInstr, null);
             track.append("</rte>");
         }
 
-        track.append("<trk><name>").append(trackName).append("</name>");
+        track.append("\n<trk><name>").append(trackName).append("</name>");
 
         track.append("<trkseg>");
         for (GPXEntry entry : createGPXList())
         {
             track.append("\n<trkpt lat='").append(Helper.round6(entry.getLat()));
             track.append("' lon='").append(Helper.round6(entry.getLon())).append("'>");
-            track.append("<time>").append(tzHack(formatter.format(startTimeMillis + entry.getMillis()))).append("</time>");
             if (includeElevation)
                 track.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
-
+            track.append("<time>").append(tzHack(formatter.format(startTimeMillis + entry.getMillis()))).append("</time>");
             track.append("</trkpt>");
         }
         track.append("</trkseg>");
         track.append("</trk>");
 
-        // TODO #147 use wpt for via points!
+        // we could now use 'wpt' for via points
         track.append("</gpx>");
         return track.toString().replaceAll("\\'", "\"");
     }
@@ -274,24 +236,25 @@ private static String tzHack( String str )
 
     private void createRteptBlock( StringBuilder output, Instruction instruction, Instruction nextI )
     {
-        output.append("<rtept lat=\"").append(Helper.round6(instruction.getFirstLat())).
+        output.append("\n<rtept lat=\"").append(Helper.round6(instruction.getFirstLat())).
                 append("\" lon=\"").append(Helper.round6(instruction.getFirstLon())).append("\">");
 
         if (!instruction.getName().isEmpty())
             output.append("<desc>").append(instruction.getTurnDescription(tr)).append("</desc>");
 
         output.append("<extensions>");
-        output.append("<distance>").append(Helper.round(instruction.getDistance(), 3)).append("</distance>");
-        output.append("<time>").append(instruction.getTime()).append("</time>");
+        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
+        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
 
-        String direction = instruction.getDirection(nextI);
-        if (direction != null)
-            output.append("<direction>").append(direction).append("</direction>");
+        String direction = instruction.calcDirection(nextI);
+        if (!direction.isEmpty())
+            output.append("<gh:direction>").append(direction).append("</gh:direction>");
 
-        String azimuth = instruction.getAzimuth(nextI);
-        if (azimuth != null)
-            output.append("<azimuth>").append(azimuth).append("</azimuth>");
+        double azimuth = instruction.calcAzimuth(nextI);
+        if (!Double.isNaN(azimuth))
+            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
 
+        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
         output.append("</extensions>");
         output.append("</rtept>");
     }
@@ -308,4 +271,75 @@ private void createRteptBlock( StringBuilder output, Instruction instruction, In
         }
         return res;
     }
+
+    /**
+     * This method is useful for navigation devices to find the next instruction for the specified
+     * coordinate (e.g. the current position).
+     * <p>
+     * @param maxDistance the maximum acceptable distance to the instruction (in meter)
+     * @return the next Instruction or null if too far away.
+     */
+    public Instruction find( double lat, double lon, double maxDistance )
+    {
+        // handle special cases
+        if (getSize() == 0)
+        {
+            return null;
+        }
+        PointList points = get(0).getPoints();
+        double prevLat = points.getLatitude(0);
+        double prevLon = points.getLongitude(0);
+        DistanceCalc distCalc = Helper.DIST_EARTH;
+        double foundMinDistance = distCalc.calcNormalizedDist(lat, lon, prevLat, prevLon);
+        int foundInstruction = 0;
+
+        // Search the closest edge to the query point
+        if (getSize() > 1)
+        {
+            for (int instructionIndex = 0; instructionIndex < getSize(); instructionIndex++)
+            {
+                points = get(instructionIndex).getPoints();
+                for (int pointIndex = 0; pointIndex < points.size(); pointIndex++)
+                {
+                    double currLat = points.getLatitude(pointIndex);
+                    double currLon = points.getLongitude(pointIndex);
+
+                    if (!(instructionIndex == 0 && pointIndex == 0))
+                    {
+                        // calculate the distance from the point to the edge
+                        double distance;
+                        int index = instructionIndex;
+                        if (distCalc.validEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon))
+                        {
+                            distance = distCalc.calcNormalizedEdgeDistance(lat, lon, currLat, currLon, prevLat, prevLon);
+                            if (pointIndex > 0)
+                                index++;
+                        } else
+                        {
+                            distance = distCalc.calcNormalizedDist(lat, lon, currLat, currLon);
+                        }
+
+                        if (distance < foundMinDistance)
+                        {
+                            foundMinDistance = distance;
+                            foundInstruction = index;
+                        }
+                    }
+
+                    prevLat = currLat;
+                    prevLon = currLon;
+                }
+            }
+        }
+
+        if (distCalc.calcDenormalizedDist(foundMinDistance) > maxDistance)
+            return null;
+
+        // special case finish condition
+        if (foundInstruction == getSize())
+            foundInstruction--;
+
+        return get(foundInstruction);
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 24cb8cd371..590c89b2fa 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -63,25 +63,33 @@ public MiniPerfTest setIterations( int counts )
         return this;
     }
 
-    // in ms
+    /**
+     * @return minimum time of every call, in ms
+     */
     public double getMin()
     {
         return min / 1e6;
     }
 
-    // in ms
+    /**
+     * @return maximum time of every calls, in ms
+     */
     public double getMax()
     {
         return max / 1e6;
     }
 
-    // in ms
+    /**
+     * @return time for all calls accumulated, in ms
+     */
     public double getSum()
     {
         return fullTime / 1e6;
     }
 
-    // in ms
+    /**
+     * @return mean time per call, in ms
+     */
     public double getMean()
     {
         return getSum() / counts;
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 5141534f13..a8c8288634 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -31,9 +31,9 @@
 public class PathMerger
 {
     private boolean enableInstructions = true;
-    private boolean simplifyResponse = false;
+    private boolean simplifyResponse = true;
     private DouglasPeucker douglasPeucker;
-    private boolean calcPoints;
+    private boolean calcPoints = true;
 
     public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
     {
@@ -60,7 +60,11 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
                 if (!il.isEmpty())
                 {
                     if (fullPoints.isEmpty())
-                        fullPoints = createSimilarPL(il.get(0).getPoints());
+                    {
+                        PointList pl = il.get(0).getPoints();
+                        // do a wild guess about the total number of points to avoid reallocation a bit
+                        fullPoints = new PointList(il.size() * Math.min(10, pl.size()), pl.is3D());
+                    }
 
                     for (Instruction i : il)
                     {
@@ -86,7 +90,7 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
             {
                 PointList tmpPoints = path.calcPoints();
                 if (fullPoints.isEmpty())
-                    fullPoints = createSimilarPL(tmpPoints);
+                    fullPoints = new PointList(tmpPoints.size(), tmpPoints.is3D());
 
                 if (simplifyResponse)
                 {
@@ -110,18 +114,17 @@ public void doWork( GHResponse rsp, List<Path> paths, Translation tr )
         if (enableInstructions)
             rsp.setInstructions(fullInstructions);
 
-        rsp.setFound(allFound).
-                setPoints(fullPoints).
+        if (!allFound)
+        {
+            rsp.addError(new RuntimeException("Not found"));
+        }
+
+        rsp.setPoints(fullPoints).
                 setRouteWeight(fullWeight).
                 setDistance(fullDistance).
                 setMillis(fullMillis);
     }
 
-    PointList createSimilarPL( PointList pl )
-    {
-        return new PointList(pl.size(), pl.is3D());
-    }
-
     public PathMerger setCalcPoints( boolean calcPoints )
     {
         this.calcPoints = calcPoints;
diff --git a/core/src/main/java/com/graphhopper/util/PointAccess.java b/core/src/main/java/com/graphhopper/util/PointAccess.java
index e8a395192d..5d3068a599 100644
--- a/core/src/main/java/com/graphhopper/util/PointAccess.java
+++ b/core/src/main/java/com/graphhopper/util/PointAccess.java
@@ -23,7 +23,6 @@
  */
 public interface PointAccess
 {
-
     /**
      * @return true if elevation data is stored and can be retrieved
      */
@@ -34,6 +33,12 @@
      */
     int getDimension();
 
+    /**
+     * This method ensures that the node with the specified index exists i.e. allocates space for
+     * it.
+     */
+    void ensureNode( int nodeId );
+
     /**
      * This method ensures that the node with the specified index exists and prepares access to it.
      * The index goes from 0 (inclusive) to graph.getNodes() (exclusive)
diff --git a/core/src/main/java/com/graphhopper/util/PointList.java b/core/src/main/java/com/graphhopper/util/PointList.java
index f9af4daf73..63efd66fe5 100644
--- a/core/src/main/java/com/graphhopper/util/PointList.java
+++ b/core/src/main/java/com/graphhopper/util/PointList.java
@@ -32,7 +32,7 @@
  */
 public class PointList implements PointAccess
 {
-    private final static DistanceCalc3D distCalc3D = new DistanceCalc3D();
+    private final static DistanceCalc3D distCalc3D = Helper.DIST_3D;
     private static String ERR_MSG = "Tried to access PointList with too big index!";
     private double[] latitudes;
     private double[] longitudes;
@@ -68,6 +68,12 @@ public int getDimension()
         return 2;
     }
 
+    @Override
+    public void ensureNode( int nodeId )
+    {
+        incCap(nodeId + 1);
+    }
+
     @Override
     public void setNode( int nodeId, double lat, double lon )
     {
@@ -95,7 +101,7 @@ else if (!Double.isNaN(ele))
 
     private void incCap( int newSize )
     {
-        if (newSize < latitudes.length)
+        if (newSize <= latitudes.length)
             return;
 
         int cap = newSize * 2;
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
new file mode 100644
index 0000000000..c7786a3cc8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -0,0 +1,129 @@
+package com.graphhopper.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * @author jansoe
+ */
+public class RoundaboutInstruction extends Instruction
+{
+    private int exitNumber = 0;
+    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, 2 inconsistent
+    private boolean exited = false;
+    private double radian = Double.NaN;
+
+    public RoundaboutInstruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    {
+        super(sign, name, ia, pl);
+    }
+
+    public RoundaboutInstruction increaseExitNumber()
+    {
+        this.exitNumber += 1;
+        return this;
+    }
+
+    public RoundaboutInstruction setExitNumber( int exitNumber )
+    {
+        this.exitNumber = exitNumber;
+        return this;
+    }
+
+    public RoundaboutInstruction setDirOfRotation( double deltaIn )
+    {
+        if (clockwise == 0)
+        {
+            clockwise = deltaIn > 0 ? 1 : -1;
+        } else
+        {
+            int clockwise2 = deltaIn > 0 ? 1 : -1;
+            if (clockwise != clockwise2)
+            {
+                clockwise = 2;
+            }
+        }
+        return this;
+    }
+
+    public RoundaboutInstruction setExited()
+    {
+        exited = true;
+        return this;
+    }
+
+    public boolean isExited()
+    {
+        return exited;
+    }
+
+    public int getExitNumber()
+    {
+        if (exited && exitNumber == 0)
+        {
+            throw new IllegalStateException("RoundaboutInstruction must contain exitNumber>0");
+        }
+        return exitNumber;
+    }
+
+    /**
+     * @return radian of angle -2PI < x < 2PI between roundabout entrance and exit
+     *         values > 0 are clockwise rotation, <0 counterclockwise, NaN if direction of rotation unclear
+     */
+    public double getRadian()
+    {
+        if (Math.abs(clockwise) != 1)
+        {
+            return Double.NaN;
+        } else
+        {
+            double tmpRadian = Math.PI - clockwise * radian;
+            tmpRadian *= clockwise;
+            return tmpRadian;
+        }
+    }
+
+    public RoundaboutInstruction setRadian( double radian )
+    {
+        this.radian = radian;
+        return this;
+    }
+
+    @Override
+    public Map<String, Object> getExtraInfoJSON()
+    {
+        Map<String, Object> tmpMap = new HashMap<String, Object>(2);
+        tmpMap.put("exit_number", getExitNumber());
+        double radian = getRadian();
+        if (!Double.isNaN(radian))
+        {
+            tmpMap.put("turn_angle", Helper.round(radian, 2));
+        }
+
+        return tmpMap;
+
+    }
+
+    @Override
+    public String getTurnDescription( Translation tr )
+    {
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.USE_ROUNDABOUT)
+        {
+            if (!exited)
+            {
+                str = tr.tr("roundaboutEnter");
+            } else
+            {
+                str = Helper.isEmpty(streetName) ? tr.tr("roundaboutExit", getExitNumber())
+                        : tr.tr("roundaboutExitOnto", getExitNumber(), streetName);
+            }
+        } else
+        {
+            throw new IllegalStateException(indi + "no Roundabout indication");
+        }
+        return str;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index f1e420ef32..4d161efd39 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -33,7 +33,8 @@
 {
     // ISO codes (639-1), use 'en_US' as reference
     private static final List<String> LOCALES = Arrays.asList("bg", "ca", "de_DE", "el", "en_US", "es", "fil",
-            "fr", "gl", "he", "it", "ja", "nl", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk");
+            "fi", "fr", "gl", "he", "it", "ja", "ne", "nl", "pt_BR", "pt_PT", "ro", "ru", "si", "sk", "sv_SE", "tr", "uk",
+            "vi_VI", "zh_CN");
     private final Map<String, Translation> translations = new HashMap<String, Translation>();
 
     /**
diff --git a/core/src/main/java/com/graphhopper/util/Unzipper.java b/core/src/main/java/com/graphhopper/util/Unzipper.java
index bcb4fee96e..5a68816e8d 100644
--- a/core/src/main/java/com/graphhopper/util/Unzipper.java
+++ b/core/src/main/java/com/graphhopper/util/Unzipper.java
@@ -26,14 +26,6 @@
  */
 public class Unzipper
 {
-    private int size = 1024 * 8;
-
-    public Unzipper setSize( int size )
-    {
-        this.size = size;
-        return this;
-    }
-
     public void unzip( String from, boolean remove ) throws IOException
     {
         String to = Helper.pruneFileEnd(from);
@@ -66,7 +58,7 @@ public void unzip( InputStream fromIs, File toFolder, ProgressListener progressL
         try
         {
             ZipEntry ze = zis.getNextEntry();
-            byte[] buffer = new byte[size];
+            byte[] buffer = new byte[8 * 1024];
             while (ze != null)
             {
                 if (ze.isDirectory())
diff --git a/core/src/main/java/com/graphhopper/util/XFirstSearch.java b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
index e049426257..31b56569a7 100644
--- a/core/src/main/java/com/graphhopper/util/XFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
@@ -27,12 +27,12 @@
  */
 public abstract class XFirstSearch
 {
-        protected GHBitSet createBitSet()
+    protected GHBitSet createBitSet()
     {
         return new GHBitSetImpl();
     }
 
-    public abstract void start( EdgeExplorer explorer, int startNode);
+    public abstract void start( EdgeExplorer explorer, int startNode );
 
     protected boolean goFurther( int nodeId )
     {
diff --git a/core/src/main/java/com/graphhopper/util/shapes/BBox.java b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
index 09e46810ca..d0eb1ebb46 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -34,20 +34,7 @@
  */
 public class BBox implements Shape, Cloneable
 {
-    /**
-     * A bounding box which prefills the values with minimum values so that it can increase.
-     */
-    public static final BBox INVERSE = new BBox();
 
-    static
-    {
-        INVERSE.minLon = Double.MAX_VALUE;
-        INVERSE.maxLon = -Double.MAX_VALUE;
-        INVERSE.minLat = Double.MAX_VALUE;
-        INVERSE.maxLat = -Double.MAX_VALUE;
-        INVERSE.minEle = Double.MAX_VALUE;
-        INVERSE.maxEle = -Double.MAX_VALUE;
-    }
     // longitude (theta) = x, latitude (phi) = y, elevation = z
     public double minLon;
     public double maxLon;
@@ -55,17 +42,7 @@
     public double maxLat;
     public double minEle;
     public double maxEle;
-    private final boolean is3D;
-
-    private BBox()
-    {
-        this.is3D = false;
-    }
-
-    private BBox( boolean is3D )
-    {
-        this.is3D = is3D;
-    }
+    private final boolean elevation;
 
     public BBox( double minLon, double maxLon, double minLat, double maxLat )
     {
@@ -77,9 +54,9 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this(minLon, maxLon, minLat, maxLat, minEle, maxEle, true);
     }
 
-    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean is3D )
+    public BBox( double minLon, double maxLon, double minLat, double maxLat, double minEle, double maxEle, boolean elevation )
     {
-        this.is3D = is3D;
+        this.elevation = elevation;
         this.maxLat = maxLat;
         this.minLon = minLon;
         this.minLat = minLat;
@@ -88,28 +65,73 @@ public BBox( double minLon, double maxLon, double minLat, double maxLat, double
         this.maxEle = maxEle;
     }
 
-    public boolean check()
+    public boolean hasElevation()
     {
-        // second longitude should be bigger than the first
-        if (minLon >= maxLon)
-            return false;
+        return elevation;
+    }
 
-        // second latitude should be smaller than the first
-        if (minLat >= maxLat)
-            return false;
+    /**
+     * Prefills BBox with minimum values so that it can increase.
+     */
+    public static BBox createInverse( boolean elevation )
+    {
+        if (elevation)
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.MAX_VALUE, -Double.MAX_VALUE, true);
+        } else
+        {
+            return new BBox(Double.MAX_VALUE, -Double.MAX_VALUE, Double.MAX_VALUE, -Double.MAX_VALUE,
+                    Double.NaN, Double.NaN, false);
+        }
+    }
 
-        // second elevation should be smaller than the first
-        if (is3D && minEle >= maxEle)
-            return false;
+    public void update( double lat, double lon )
+    {
+        if (lat > maxLat)
+        {
+            maxLat = lat;
+        }
+
+        if (lat < minLat)
+        {
+            minLat = lat;
+        }
 
-        return true;
+        if (lon > maxLon)
+        {
+            maxLon = lon;
+        }
+        if (lon < minLon)
+        {
+            minLon = lon;
+        }
+    }
+
+    public void update( double lat, double lon, double elev )
+    {
+        if (elevation)
+        {
+            if (elev > maxEle)
+            {
+                maxEle = elev;
+            }
+            if (elev < minEle)
+            {
+                minEle = elev;
+            }
+        } else
+        {
+            throw new IllegalStateException("No BBox with elevation to update");
+        }
+        update(lat, lon);
 
     }
 
     @Override
     public BBox clone()
     {
-        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, is3D);
+        return new BBox(minLon, maxLon, minLat, maxLat, minEle, maxEle, elevation);
     }
 
     @Override
@@ -172,7 +194,7 @@ public boolean contains( Circle c )
     public String toString()
     {
         String str = minLon + "," + maxLon + "," + minLat + "," + maxLat;
-        if (is3D)
+        if (elevation)
             str += "," + minEle + "," + maxEle;
 
         return str;
@@ -214,10 +236,29 @@ public int hashCode()
 
     public boolean isValid()
     {
-        return Double.doubleToLongBits(maxLat) != Double.doubleToLongBits(INVERSE.maxLat)
-                && Double.doubleToLongBits(minLat) != Double.doubleToLongBits(INVERSE.minLat)
-                && Double.doubleToLongBits(maxLon) != Double.doubleToLongBits(INVERSE.maxLon)
-                && Double.doubleToLongBits(minLon) != Double.doubleToLongBits(INVERSE.minLon);
+        // second longitude should be bigger than the first
+        if (minLon >= maxLon)
+            return false;
+
+        // second latitude should be smaller than the first
+        if (minLat >= maxLat)
+            return false;
+
+        if (elevation)
+        {
+            // equal elevation is okay
+            if (minEle > maxEle)
+                return false;
+
+            if (Double.compare(maxEle, -Double.MAX_VALUE) == 0
+                    || Double.compare(minEle, Double.MAX_VALUE) == 0)
+                return false;
+        }
+
+        return Double.compare(maxLat, -Double.MAX_VALUE) != 0
+                && Double.compare(minLat, Double.MAX_VALUE) != 0
+                && Double.compare(maxLon, -Double.MAX_VALUE) != 0
+                && Double.compare(minLon, Double.MAX_VALUE) != 0;
     }
 
     /**
@@ -230,12 +271,12 @@ public boolean isValid()
         list.add(Helper.round6(minLon));
         list.add(Helper.round6(minLat));
         // hmh
-        if (is3D)
+        if (elevation)
             list.add(Helper.round2(minEle));
 
         list.add(Helper.round6(maxLon));
         list.add(Helper.round6(maxLat));
-        if (is3D)
+        if (elevation)
             list.add(Helper.round2(maxEle));
 
         return list;
diff --git a/core/src/main/java/com/graphhopper/util/shapes/Circle.java b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
index 2ff252007a..0eee29724e 100644
--- a/core/src/main/java/com/graphhopper/util/shapes/Circle.java
+++ b/core/src/main/java/com/graphhopper/util/shapes/Circle.java
@@ -18,15 +18,14 @@
 package com.graphhopper.util.shapes;
 
 import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.DistanceCalcEarth;
+import com.graphhopper.util.Helper;
 
 /**
  * @author Peter Karich
  */
 public class Circle implements Shape
 {
-    private final static DistanceCalc SINGLETON = new DistanceCalcEarth();
-    private DistanceCalc calc = SINGLETON;
+    private DistanceCalc calc = Helper.DIST_EARTH;
     private final double radiusInKm;
     private final double lat;
     private final double lon;
@@ -35,7 +34,7 @@
 
     public Circle( double lat, double lon, double radiusInMeter )
     {
-        this(lat, lon, radiusInMeter, SINGLETON);
+        this(lat, lon, radiusInMeter, Helper.DIST_EARTH);
     }
 
     public Circle( double lat, double lon, double radiusInMeter, DistanceCalc calc )
diff --git a/core/src/main/resources/com/graphhopper/util/bg.txt b/core/src/main/resources/com/graphhopper/util/bg.txt
index d4dd0a473d..6051b86336 100644
--- a/core/src/main/resources/com/graphhopper/util/bg.txt
+++ b/core/src/main/resources/com/graphhopper/util/bg.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=рязко наляво
-sharp_right=рязко надясно
-left=наляво
-right=надясно
-slight_left=леко наляво
-slight_right=леко надясно
 continue=продължи
 continue_onto=продължи по %1$s
-turn=завий %1$s
-turn_onto=завий %1$s по %2$s
+turn_left=завий наляво
+turn_right=завий надясно
+turn_slight_left=завий леко наляво
+turn_slight_right=завий леко надясно
+turn_sharp_left=завий рязко наляво
+turn_sharp_right=завий рязко надясно
+turn_onto=%1$s по %2$s
 web.searchButton=Търсене
 web.fromHint=От
 web.viaHint=през
@@ -24,6 +23,7 @@ web.mtb=Планинско колело
 web.car=Автомобил
 web.foot=Пеш
 web.staticlink=статична връзка
+web.motorcycle=Мотоциклет
 via=през
 finish=Крайна цел!
 hourAbbr=ч
@@ -40,5 +40,6 @@ way=път
 paved=асфалтиран
 unpaved=черен
 stopover=прехвърляне %1$s
-roundaboutInstruction=Влез в кръговото и използвай изход %1$s
-roundaboutInstructionWithDir=Влез в кръговото и използвай изход %1$s в посока %2$s
+roundaboutEnter=Влез в кръговото кръстовище
+roundaboutExit=На кръговото кръстовище използвайте изход %1$s
+roundaboutExitOnto=На кръговото кръстовище използвайте изход %1$s по %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ca.txt b/core/src/main/resources/com/graphhopper/util/ca.txt
index 5f74da7ad7..512ca12aa6 100644
--- a/core/src/main/resources/com/graphhopper/util/ca.txt
+++ b/core/src/main/resources/com/graphhopper/util/ca.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=just a l'esquerra
-sharp_right=just a la dreta
-left=a l'esquerra
-right=a la dreta
-slight_left=lleugerament a l'esquerra
-slight_right=lleugerament a la dreta
 continue=continua
 continue_onto=continua per %1$s
-turn=gira %1$s
-turn_onto=gira %1$s per %2$s
+turn_left=gira a l'esquerra
+turn_right=gira a la dreta
+turn_slight_left=gira lleugerament a l'esquerra
+turn_slight_right=gira lleugerament a la dreta
+turn_sharp_left=gira just a l'esquerra
+turn_sharp_right=gira just a la dreta
+turn_onto=%1$s per %2$s
 web.searchButton=Buscar
 web.fromHint=Des de
 web.viaHint=passant per
@@ -24,6 +23,7 @@ web.mtb=Bicicleta de montanya
 web.car=Cotxe
 web.foot=A peu
 web.staticlink=Enllaç
+web.motorcycle=Motocicleta
 via=passant per
 finish=Has arribat !!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=camí
 paved=pavimentat
 unpaved=sense pavimentar
 stopover=passant per %1$s
-roundaboutInstruction=Entra a la rotonda y agafa la %1$ sortida
-roundaboutInstructionWithDir=Entra a la rotonda y agafa la %1$s sortida direcció %2$s
+roundaboutEnter=Entra a la rotonda
+roundaboutExit=A la rotonda, agafa la %1$s sortida
+roundaboutExitOnto=A la rotonda, agafa la sortida %1$s cap a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/de_DE.txt b/core/src/main/resources/com/graphhopper/util/de_DE.txt
index d3d5bcce04..e778c5cc28 100644
--- a/core/src/main/resources/com/graphhopper/util/de_DE.txt
+++ b/core/src/main/resources/com/graphhopper/util/de_DE.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=scharf links
-sharp_right=scharf rechts
-left=links
-right=rechts
-slight_left=leicht links
-slight_right=leicht rechts
 continue=geradeaus
 continue_onto=geradeaus auf %1$s
-turn=%1$s abbiegen
-turn_onto=%1$s abbiegen auf %2$s
+turn_left=links abbiegen
+turn_right=rechts abbiegen
+turn_slight_left=leicht links abbiegen
+turn_slight_right=leicht rechts abbiegen
+turn_sharp_left=scharf links abbiegen
+turn_sharp_right=scharf rechts abbiegen
+turn_onto=%1$s auf %2$s
 web.searchButton=Suche
 web.fromHint=Von
 web.viaHint=Über
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=Auto
 web.foot=Zu Fuß
 web.staticlink=Link
+web.motorcycle=Motorrad
 via=über
 finish=Ziel erreicht!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=Weg
 paved=befestigt
 unpaved=unbefestigt
 stopover=Zwischenziel %1$s
-roundaboutInstruction=In den Kreisverkehr einfahren und Ausfahrt %1$s nehmen
-roundaboutInstructionWithDir=In den Kreisverkehr einfahren und Ausfahrt %1$s in Richtung %2$s nehmen
+roundaboutEnter=In den Kreisverkehr einfahren
+roundaboutExit=Im Kreisverkehr Ausfahrt %1$s nehmen
+roundaboutExitOnto=Im Kreisverkehr Ausfahrt %1$s auf %2$s nehmen
diff --git a/core/src/main/resources/com/graphhopper/util/el.txt b/core/src/main/resources/com/graphhopper/util/el.txt
index bc4d623f03..b60ca9b5cd 100644
--- a/core/src/main/resources/com/graphhopper/util/el.txt
+++ b/core/src/main/resources/com/graphhopper/util/el.txt
@@ -1,21 +1,20 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=κλειστά αριστερά
-sharp_right=κλειστά δεξιά
-left=αριστερά
-right=δεξιά
-slight_left=λοξά αριστερά
-slight_right=λοξά δεξιά
 continue=συνεχίστε
 continue_onto=συνεχίστε στην %1$s
-turn=στρίψτε %1$s
-turn_onto=στρίψτε %1$s στην %2$s
+turn_left=στρίψτε αριστερά
+turn_right=στρίψτε δεξιά
+turn_slight_left=στρίψτε λοξά αριστερά
+turn_slight_right=στρίψτε λοξά δεξιά
+turn_sharp_left=στρίψτε κλειστά αριστερά
+turn_sharp_right=στρίψτε κλειστά δεξιά
+turn_onto=%1$s στην %2$s
 web.searchButton=Αναζήτηση
 web.fromHint=Αφετηρία
-web.viaHint=μέσω
+web.viaHint=Μέσω
 web.toHint=Προορισμός
 web.moreButton=περισσότερα
-web.gpxExportButton=GPX εξαγωγή
+web.gpxExportButton=Εξαγωγή GPX
 web.routeInfo=%1$s σε %2$s
 web.locationsNotFound=Η δρομολόγηση δεν είναι δυνατή. Οι τοποθεσίες δεν βρέθηκαν στην περιοχή.
 web.bike=Ποδήλατο
@@ -24,6 +23,7 @@ web.mtb=Ποδήλατο βουνού
 web.car=Αυτοκίνητο
 web.foot=Πεζός
 web.staticlink=στατική διεύθυνση
+web.motorcycle=Μοτοσυκλέτα
 via=μέσω
 finish=Τέρμα!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=δρόμος
 paved=ασφαλτοστρωμένος
 unpaved=χωματόδρομος
 stopover=ενδιάμεση στάση %1$s
-roundaboutInstruction=Μπείτε στον κυκλικό κόμβο και βγείτε στην έξοδο %1$s
-roundaboutInstructionWithDir=Μπείτε στον κυκλικό κόμβο και βγείτε στην έξοδο %1$s στην κατεύθυνση %2$s
+roundaboutEnter=Μπείτε στον κυκλικό κόμβο
+roundaboutExit=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s
+roundaboutExitOnto=Στον κυκλικό κόμβο βγείτε στην έξοδο %1$s στην %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/en_US.txt b/core/src/main/resources/com/graphhopper/util/en_US.txt
index 73684cbc63..c886850443 100644
--- a/core/src/main/resources/com/graphhopper/util/en_US.txt
+++ b/core/src/main/resources/com/graphhopper/util/en_US.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=sharp left
-sharp_right=sharp right
-left=left
-right=right
-slight_left=slight left
-slight_right=slight right
 continue=continue
 continue_onto=continue onto %1$s
-turn=turn %1$s
-turn_onto=turn %1$s onto %2$s
+turn_left=turn left
+turn_right=turn right
+turn_slight_left=turn slight left
+turn_slight_right=turn slight right
+turn_sharp_left=turn sharp left
+turn_sharp_right=turn sharp right
+turn_onto=%1$s onto %2$s
 web.searchButton=Search
 web.fromHint=From
 web.viaHint=Via
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=Car
 web.foot=Foot
 web.staticlink=static link
+web.motorcycle=Motorcycle
 via=via
 finish=Finish!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=way
 paved=paved
 unpaved=unpaved
 stopover=stopover %1$s
-roundaboutInstruction=Enter roundabout and use exit %1$s
-roundaboutInstructionWithDir=Enter roundabout and use exit %1$s in direction %2$s
+roundaboutEnter=Enter roundabout
+roundaboutExit=At roundabout, take exit %1$s
+roundaboutExitOnto=At roundabout, take exit %1$s onto %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/es.txt b/core/src/main/resources/com/graphhopper/util/es.txt
index b857400770..f9cb775402 100644
--- a/core/src/main/resources/com/graphhopper/util/es.txt
+++ b/core/src/main/resources/com/graphhopper/util/es.txt
@@ -1,31 +1,31 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=justo a la izquierda
-sharp_right=justo a la derecha
-left=izquierda
-right=derecha
-slight_left=gire a la izquierda
-slight_right=gire a la derecha
 continue=continúe
 continue_onto=continúe por %1$s
-turn=gire %1$s
-turn_onto=gire %1$s por %2$s
+turn_left=gire a la izquierda
+turn_right=gire a la derecha
+turn_slight_left=gire ligeramente a la izquierda
+turn_slight_right=gire ligeramente a la derecha
+turn_sharp_left=gire fuerte a la izquierda
+turn_sharp_right=gire fuerte a la derecha
+turn_onto=%1$s por %2$s
 web.searchButton=Buscar
 web.fromHint=Desde
-web.viaHint=
+web.viaHint=Pasando por
 web.toHint=hasta
 web.moreButton=más
-web.gpxExportButton=
+web.gpxExportButton=Exportar GPX
 web.routeInfo=%1$s tardará %2$s 
 web.locationsNotFound=No se ha encontrado la ruta. El destino no se encuentra en el área.
 web.bike=Bicicleta
-web.racingbike=
-web.mtb=
+web.racingbike=Bicicleta de carrera
+web.mtb=Bicicleta de montaña
 web.car=Coche
-web.foot=A pié
-web.staticlink=
-via=
-finish=Objetivo logrado
+web.foot=A pie
+web.staticlink=enlace estático
+web.motorcycle=Motocicleta
+via=pasando por
+finish=¡Fin del recorrido!
 hourAbbr=h
 dayAbbr=d
 minAbbr=min
@@ -33,12 +33,13 @@ kmAbbr=km
 mAbbr=m
 miAbbr=mi
 ftAbbr=ft
-road=
-off_bike=
-cycleway=
-way=
-paved=
-unpaved=
-stopover=
-roundaboutInstruction=
-roundaboutInstructionWithDir=
+road=carretera
+off_bike=bájese de la bicicleta
+cycleway=Ciclovía 
+way=camino
+paved=pavimentado
+unpaved=no pavimentado
+stopover=pasando por %1$s
+roundaboutEnter=Entre en la rotonda
+roundaboutExit=En la rotonda, tome la salida %1$s
+roundaboutExitOnto=En la rotonda, tome la salida %1$s hacia %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fi.txt b/core/src/main/resources/com/graphhopper/util/fi.txt
new file mode 100644
index 0000000000..b5d23f834a
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/fi.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=jatka
+continue_onto=jatka tielle %1$S
+turn_left=käänny vasemmalle
+turn_right=käänny oikealle
+turn_slight_left=käänny loivasti vasemmalle
+turn_slight_right=käänny loivasti oikealle
+turn_sharp_left=käänny jyrkästi vasemmalle
+turn_sharp_right=käänny jyrkästi oikealle
+turn_onto=%1$S tielle %2$S
+web.searchButton=Etsi
+web.fromHint=Lähtöpaikka
+web.viaHint=Reittipiste
+web.toHint=Määränpää
+web.moreButton=lisää
+web.gpxExportButton=GPX-tuonti
+web.routeInfo=%1$s kestää %2$s
+web.locationsNotFound=Reittiohjeiden luonti epäonnistui. Paikkaa ei löydy tältä alueelta.
+web.bike=Pyörällä
+web.racingbike=Kilpapyörällä
+web.mtb=Maastopyörällä
+web.car=Autolla
+web.foot=Kävellen
+web.staticlink=
+web.motorcycle=Moottoripyörällä
+via=kautta
+finish=Olet perillä!
+hourAbbr=h
+dayAbbr=pv
+minAbbr=min
+kmAbbr=km
+mAbbr=m
+miAbbr=mi
+ftAbbr=ft
+road=tie
+off_bike=taluta pyörää
+cycleway=pyörätie
+way=tie
+paved=päällystetty
+unpaved=päällystämätön
+stopover=%1$s. pysähdys
+roundaboutEnter=Aja liikenneympyrään
+roundaboutExit=Liikenneympyrästä poistu %1$s. liittymästä
+roundaboutExitOnto=Liikenneympyrästä poistu %1$s. liittymästä suuntaan %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fil.txt b/core/src/main/resources/com/graphhopper/util/fil.txt
index c34bd37be7..7a94497034 100644
--- a/core/src/main/resources/com/graphhopper/util/fil.txt
+++ b/core/src/main/resources/com/graphhopper/util/fil.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=matalim kaliwa 
-sharp_right=matalim karapatan 
-left=kaliwa 
-right=karapatan 
-slight_left=bahagyang kaliwa
-slight_right=bahagyang kanan
 continue=tuwirín ang daán
 continue_onto=magpatuloy papunta sa %1$s
-turn=pagliko %1$s
-turn_onto=lumiko %1$s papunta sa %2$s
+turn_left=pagliko kaliwa
+turn_right=pagliko karapatan
+turn_slight_left=pagliko bahagyang kaliwa
+turn_slight_right=pagliko bahagyang kanan
+turn_sharp_left=pagliko matalim kaliwa
+turn_sharp_right=pagliko matalim karapatan
+turn_onto=%1$s papunta sa %2$s
 web.searchButton=Paghahanap
 web.fromHint=mula sa 
 web.viaHint=
@@ -24,6 +23,7 @@ web.mtb=MountainBike
 web.car=kotse
 web.foot=lumakad
 web.staticlink=
+web.motorcycle=
 via=
 finish=Tapusin!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=landas
 paved=aspaltado 
 unpaved=hindi aspaltado
 stopover=pamahingahan %1$s
-roundaboutInstruction=Lpasok rotonda at gamitin %1$s
-roundaboutInstructionWithDir=Epasok rotonda at gamitin %1$s direksyon %2$s
+roundaboutEnter=Lpasok Rotonda
+roundaboutExit=Sa rotonda, lumabas sa exit %1$s
+roundaboutExitOnto=Sa rotonda, lumabas sa exit papunta %1$s %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/fr.txt b/core/src/main/resources/com/graphhopper/util/fr.txt
index ff0fbb2614..7f77887d4f 100644
--- a/core/src/main/resources/com/graphhopper/util/fr.txt
+++ b/core/src/main/resources/com/graphhopper/util/fr.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=fort à gauche
-sharp_right=fort à droite
-left=à gauche
-right=à droite
-slight_left=légèrement à gauche
-slight_right=légèrement à droite
 continue=continuez
 continue_onto=continuez sur %1$s
-turn=tournez %1$s
-turn_onto=tournez %1$s sur %2$s
+turn_left=tournez à gauche
+turn_right=tournez à droite
+turn_slight_left=tournez légèrement à gauche
+turn_slight_right=tournez légèrement à droite
+turn_sharp_left=tournez fort à gauche
+turn_sharp_right=tournez fort à droite
+turn_onto=%1$s sur %2$s
 web.searchButton=Rechercher
 web.fromHint=De
 web.viaHint=via
@@ -24,6 +23,7 @@ web.mtb=VTT
 web.car=Voiture
 web.foot=À pied
 web.staticlink=Lien
+web.motorcycle=Vélo
 via=via
 finish=Fini!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=chemin
 paved=pavé
 unpaved=non-pavé
 stopover=escale %1$s
-roundaboutInstruction=empruntez le rond point et prenez la sortie %1$s
-roundaboutInstructionWithDir=empruntez le rond point et prenez la sortie %1$s, en direction de %2$s
+roundaboutEnter=Empruntez le rond-point
+roundaboutExit=Au rond-point, prennez la %1$s sortie
+roundaboutExitOnto=Au rond-point, prennez la %1$s sortie vers %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/gl.txt b/core/src/main/resources/com/graphhopper/util/gl.txt
index 4b93b10e45..8a91be54a8 100644
--- a/core/src/main/resources/com/graphhopper/util/gl.txt
+++ b/core/src/main/resources/com/graphhopper/util/gl.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=xusto á esquerda
-sharp_right=xusto á dereita
-left=esquerda
-right=dereita
-slight_left=vire á esquerda
-slight_right=vire á dereita
 continue=continúe
 continue_onto=continúe por %1$s
-turn=vire por %1$s
-turn_onto=vire %1$s por %2$s
+turn_left=vire por esquerda
+turn_right=vire por dereita
+turn_slight_left=vire á esquerda
+turn_slight_right=vire á dereita
+turn_sharp_left=vire por xusto á esquerda
+turn_sharp_right=vire por xusto á dereita
+turn_onto=%1$s por %2$s
 web.searchButton=buscar
 web.fromHint=dende
 web.viaHint=Vía
@@ -24,6 +23,7 @@ web.mtb=Bicicleta de montaña
 web.car=automóbil
 web.foot=A pé
 web.staticlink=Enlace
+web.motorcycle=
 via=vía
 finish=Obxectivo acadado
 hourAbbr=h
@@ -40,5 +40,6 @@ way=vía
 paved=asfaltada
 unpaved=non pavimentada
 stopover=escala%1$s
-roundaboutInstruction= Entre na rotonda e tome a saída %1$s
-roundaboutInstructionWithDir= Entre na rotonda e tome a saída %1$s en dirección%2$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/he.txt b/core/src/main/resources/com/graphhopper/util/he.txt
index 3ec68f2fde..2c6bbefec1 100644
--- a/core/src/main/resources/com/graphhopper/util/he.txt
+++ b/core/src/main/resources/com/graphhopper/util/he.txt
@@ -1,14 +1,13 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=שמאלה בחדות
-sharp_right=ימינה בחדות
-left=שמאלה
-right=ימינה
-slight_left=מעט שמאלה
-slight_right=מעט ימינה
 continue=להמשיך
 continue_onto=להמשיך לתוך %1$s
-turn=נא לפנות %1$s
+turn_left=שמאלה
+turn_right=ימינה
+turn_slight_left=מעט שמאלה
+turn_slight_right=מעט ימינה
+turn_sharp_left=שמאלה בחדות
+turn_sharp_right=ימינה בחדות
 turn_onto=נא לפנות %1$s לתוך %2$s
 web.searchButton=חיפוש
 web.fromHint=מוצא
@@ -24,6 +23,7 @@ web.mtb=אופני הרים
 web.car=מכונית
 web.foot=רגל
 web.staticlink=קישור קבוע
+web.motorcycle=אופנוע
 via=דרך
 finish=סיימת!
 hourAbbr=שע׳
@@ -40,5 +40,6 @@ way=דרך
 paved=סלולה
 unpaved=לא סלולה
 stopover=נקודת עצירה מס׳ %1$s
-roundaboutInstruction=יש להיכנס לכיכר ולצאת ביציאה מס׳ %1$s
-roundaboutInstructionWithDir=יש להיכנס לכיכר ולצאת ביציאה מס׳ %1$s בכיוון %2$s
+roundaboutEnter=יש להיכנס לכיכר
+roundaboutExit=בכיכר, יש לצאת ביציאה %1$s
+roundaboutExitOnto=בכיכר, יש לצאת ביציאה %1$s לתוך %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
index 6f16557c1d..869881f239 100644
--- a/core/src/main/resources/com/graphhopper/util/it.txt
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=nettamente a sinistra
-sharp_right=nettamente a destra
-left=a sinistra
-right=a destra
-slight_left=leggermente a sinistra
-slight_right=leggermente a destra
 continue=continua
 continue_onto=continua su %1$s
-turn=gira %1$s
-turn_onto=gira %1$s su %2$s
+turn_left=gira a sinistra
+turn_right=gira a destra
+turn_slight_left=gira leggermente a sinistra
+turn_slight_right=gira leggermente a destra
+turn_sharp_left=gira nettamente a sinistra
+turn_sharp_right=gira nettamente a destra
+turn_onto=%1$s su %2$s
 web.searchButton=Ricerca
 web.fromHint=Da
 web.viaHint=attraverso
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=Auto
 web.foot=A piedi
 web.staticlink=permalink
+web.motorcycle=Moto
 via=attraverso
 finish=Arrivo!
 hourAbbr=hh
@@ -40,5 +40,6 @@ way=via
 paved=pavimentata
 unpaved=non pavimentata
 stopover=sosta %1$s
-roundaboutInstruction=Prendere l'uscita %1$s
-roundaboutInstructionWithDir=Prendere l'uscita %1$s in direzione %2$s
+roundaboutEnter=Entrare nella rotatoria
+roundaboutExit=Nella rotatoria, prendere l'uscita %1$s
+roundaboutExitOnto=Nella rotatoria, prendere l'uscita %1$s su %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ja.txt b/core/src/main/resources/com/graphhopper/util/ja.txt
index 1aa3a9e2d5..506ae3a3fa 100644
--- a/core/src/main/resources/com/graphhopper/util/ja.txt
+++ b/core/src/main/resources/com/graphhopper/util/ja.txt
@@ -1,14 +1,13 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=左
-sharp_right=右
-left=左
-right=右
-slight_left=左
-slight_right=右
 continue=進む
 continue_onto=%1$sまで進む
-turn=%1$sに曲がる
+turn_left=左に曲がる
+turn_right=右に曲がる
+turn_slight_left=左に曲がる
+turn_slight_right=右に曲がる
+turn_sharp_left=左に曲がる
+turn_sharp_right=右に曲がる
 turn_onto=%1$sに曲がって%2$sに入る
 web.searchButton=検索
 web.fromHint=出発地点
@@ -24,6 +23,7 @@ web.mtb=マウンテンバイク
 web.car=車
 web.foot=徒歩
 web.staticlink=
+web.motorcycle=
 via=
 finish=目標達成
 hourAbbr=時間
@@ -40,5 +40,6 @@ way=道
 paved=舗装された道
 unpaved=未舗装の道
 stopover=%1$sで降りる
-roundaboutInstruction=円形交差点の%1$s出口から
-roundaboutInstructionWithDir=円形交差点の%1$s出口から%2$s方向へ
+roundaboutEnter=円形交差点に入る
+roundaboutExit=円形交差点の出口%1$sへ
+roundaboutExitOnto=円形交差点の出口%1$sから%2$sへ
diff --git a/core/src/main/resources/com/graphhopper/util/ne.txt b/core/src/main/resources/com/graphhopper/util/ne.txt
new file mode 100644
index 0000000000..e502256a5e
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/ne.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=गहिरख्नुहोस
+continue_onto=%1$s गहिरख्नुहोस
+turn_left=बाया मोड्नुहोस 
+turn_right=दाया मोड्नुहोस 
+turn_slight_left=थोरै बाया मोड्नुहोस 
+turn_slight_right=थोरै दाया मोड्नुहोस 
+turn_sharp_left=धेरै बाया मोड्नुहोस 
+turn_sharp_right=धेरै दाया मोड्नुहोस 
+turn_onto=%2$s मा %1$s मोड्नुहोस 
+web.searchButton=खोज 
+web.fromHint=सुरु 
+web.viaHint=बाट
+web.toHint=अन्त्य
+web.moreButton=अझै
+web.gpxExportButton=GPX मा परिबर्तन गर्नुहोस
+web.routeInfo=%1$s को लागि %2$s लाग्नेछ
+web.locationsNotFound=ठाउँ नभेटीनाले बाटो पत्ता लगाउन सकिएन
+web.bike=बाईक 
+web.racingbike=छिटो गतिका बाईक
+web.mtb=माउन्टेन बाईक
+web.car=गाडी
+web.foot=पैदल
+web.staticlink=ईस्ट्यातिक लिंक
+web.motorcycle=मोटरसाइकल 
+via=बाट
+finish=सकियो
+hourAbbr=घण्टा
+dayAbbr=दिन
+minAbbr=मिनेट
+kmAbbr=किलोमीटर 
+mAbbr=मीटर
+miAbbr=माइल्स
+ftAbbr=फुट
+road=सडक
+off_bike=बाईक बाट ओर्लनुहोस
+cycleway=साइकल हिड्ने बाटो
+way=बाटो
+paved=पक्कि
+unpaved=कच्ची
+stopover=%1$s रोकिने ठाउँ 
+roundaboutEnter=घुम्ती मा छिर्नुहोस
+roundaboutExit=घुम्तीमा %1$s नम्बर को मोडबाट निस्कनुहोस 
+roundaboutExitOnto=घुम्तीमा %1$s नम्बर को मोडबाट निस्केर %2$s मा जानुहोस
diff --git a/core/src/main/resources/com/graphhopper/util/nl.txt b/core/src/main/resources/com/graphhopper/util/nl.txt
index 7893b2ef22..059c334c4a 100644
--- a/core/src/main/resources/com/graphhopper/util/nl.txt
+++ b/core/src/main/resources/com/graphhopper/util/nl.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=scherp naar links
-sharp_right=scherp naar rechts
-left=links
-right=rechts
-slight_left=licht naar links
-slight_right=licht naar rechts
-continue=ga door
-continue_onto=ga door op %1$s
-turn=%1$s afbuigen
-turn_onto=sla %1$s op %2$s
+continue=neem 
+continue_onto=blijf op %1$s
+turn_left=links afbuigen
+turn_right=rechts afbuigen
+turn_slight_left=houd links aan afbuigen
+turn_slight_right=houd rechts aan afbuigen
+turn_sharp_left=ga linksaf afbuigen
+turn_sharp_right=ga rechtsaf afbuigen
+turn_onto=%1$s af naar %2$s
 web.searchButton=zoek
 web.fromHint=van
 web.viaHint=via
@@ -24,9 +23,10 @@ web.mtb=mountainbike
 web.car=auto
 web.foot=te voet
 web.staticlink=statische link
+web.motorcycle=motorfiets
 via=via
-finish=bestemming bereikt!
-hourAbbr=h
+finish=Bestemming bereikt
+hourAbbr=u
 dayAbbr=d
 minAbbr=min
 kmAbbr=km
@@ -39,6 +39,7 @@ cycleway=fietspad
 way=weg
 paved=verhard
 unpaved=onverhard
-stopover=tussenbestemming %1$s
-roundaboutInstruction=ga de rotonde op en gebruik afrit %1$s
-roundaboutInstructionWithDir=ga de rotonde op en gebruik affit %1$s in de richting %2$s
+stopover=tussenstop %1$s
+roundaboutEnter=ga de rotonde op
+roundaboutExit=neem afslag %1$s op de rotonde 
+roundaboutExitOnto=neem afslag %1$s naar %2$s op de rotonde 
diff --git a/core/src/main/resources/com/graphhopper/util/pt_BR.txt b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
index fc78ebd5be..9672f19f3f 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_BR.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_BR.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=curva acentuada à esquerda
-sharp_right=curva acentuada à direita
-left=esquerda
-right=direita
-slight_left=curva suave à esquerda
-slight_right=curva suave à direita
 continue=continuar
 continue_onto=continue na %1$s
-turn=vire à %1$s
-turn_onto=vire à %1$s em %2$s
+turn_left=vire à esquerda
+turn_right=vire à direita
+turn_slight_left=vire à curva suave à esquerda
+turn_slight_right=vire à curva suave à direita
+turn_sharp_left=vire à curva acentuada à esquerda
+turn_sharp_right=vire à curva acentuada à direita
+turn_onto=%1$s em %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
 web.viaHint=Via
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=Carro
 web.foot=A pé
 web.staticlink=Link estático
+web.motorcycle=Motocicleta
 via=via
 finish=Destino alcançado
 hourAbbr=h
@@ -40,5 +40,6 @@ way=caminho
 paved=pavimentada
 unpaved=não pavimentada
 stopover=parada %1$s
-roundaboutInstruction=Entre na rotatória e saia na saída número %1$s
-roundaboutInstructionWithDir=Entre na rotatória e saia na saída número %1$s em direção a %2$s
+roundaboutEnter=Entre na rotatória
+roundaboutExit=Na rotatória, saia na %1$ saída
+roundaboutExitOnto=Na rotatória, saia na %1$ saida em direção a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/pt_PT.txt b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
index 10bffbb4d5..1103e54ae1 100644
--- a/core/src/main/resources/com/graphhopper/util/pt_PT.txt
+++ b/core/src/main/resources/com/graphhopper/util/pt_PT.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=curva apertada à esquerda
-sharp_right=curva apertada à direita
-left=esquerda
-right=direita
-slight_left=curva ligeira à esquerda
-slight_right=curva ligeira à direita
 continue=continuar
 continue_onto=continue na %1$s
-turn=vire à %1$s
-turn_onto=vire à %1$s para %2$s
+turn_left=vire à esquerda
+turn_right=vire à direita
+turn_slight_left=vire à curva ligeira à esquerda
+turn_slight_right=vire à curva ligeira à direita
+turn_sharp_left=vire à curva apertada à esquerda
+turn_sharp_right=vire à curva apertada à direita
+turn_onto=%1$s para %2$s
 web.searchButton=Pesquisar
 web.fromHint=De
 web.viaHint=Por
@@ -24,6 +23,7 @@ web.mtb=Bicicleta de montanha
 web.car=Carro
 web.foot=A pé
 web.staticlink=Ligação permanente
+web.motorcycle=Motocicleta
 via=por
 finish=Chegou ao seu destino!
 hourAbbr=h
@@ -40,5 +40,6 @@ way=caminho
 paved=pavimentado
 unpaved=não pavimentada
 stopover=paragem %1$s
-roundaboutInstruction=Entre na rotunda e saia na saída número %1$s
-roundaboutInstructionWithDir=Entre na rotunda e saia na saída número %1$s em direção a %2$s
+roundaboutEnter=Entre na rotunda
+roundaboutExit=Na rotunda, saia na %1$ saída
+roundaboutExitOnto=Na rotunda, saia na %1$ saida em direção a %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/ro.txt b/core/src/main/resources/com/graphhopper/util/ro.txt
index af528cca78..67e0da87ad 100644
--- a/core/src/main/resources/com/graphhopper/util/ro.txt
+++ b/core/src/main/resources/com/graphhopper/util/ro.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=brusc la stânga
-sharp_right=brusc la dreapta
-left=stânga
-right=dreapta
-slight_left=ușor la stânga
-slight_right=ușor la dreapta
 continue=continuă
 continue_onto=continuă pe %1$s
-turn=schimbați direcția la %1$s
-turn_onto=schimbați direcția la %1$s pe %2$s
+turn_left=schimbați direcția la stânga
+turn_right=schimbați direcția la dreapta
+turn_slight_left=schimbați direcția la ușor la stânga
+turn_slight_right=schimbați direcția la ușor la dreapta
+turn_sharp_left=schimbați direcția la brusc la stânga
+turn_sharp_right=schimbați direcția la brusc la dreapta
+turn_onto=%1$s pe %2$s
 web.searchButton=Caută
 web.fromHint=De la
 web.viaHint=Prin
@@ -24,6 +23,7 @@ web.mtb=Mountainbike
 web.car=mașină
 web.foot=pe jos
 web.staticlink=link
+web.motorcycle=Motocicletă
 via=prin
 finish=obiectiv atins
 hourAbbr=h
@@ -40,5 +40,6 @@ way=cale
 paved=pavat
 unpaved=nepavat
 stopover=escala %1$s
-roundaboutInstruction= Intrați în giratoriu și folosiți ieșirea %1$s
-roundaboutInstructionWithDir= Intrați în giratoriu și folosiți ieșirea %1$s în direcția %2$s
+roundaboutEnter=Intrați în giratoriu 
+roundaboutExit=La giratoriu folosiți ieșirea %1$
+roundaboutExitOnto=La giratoriu folosiți ieșirea %1$ către %2$
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index 65dea0914f..d5b796eae4 100644
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -1,44 +1,45 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=резко налево
-sharp_right=резко направо
-left=налево
-right=направо
-slight_left=немного левее
-slight_right=немного правее
 continue=продолжайте
 continue_onto=продолжайте по %1$s
-turn=Поверните %1$s
-turn_onto=Поверните %1$s на %2$s
+turn_left=Поверните налево
+turn_right=Поверните направо
+turn_slight_left=Поверните немного левее
+turn_slight_right=Поверните немного правее
+turn_sharp_left=Поверните резко налево
+turn_sharp_right=Поверните резко направо
+turn_onto=%1$s на %2$s
 web.searchButton=Поиск
 web.fromHint=От
-web.viaHint=
+web.viaHint=Через
 web.toHint=До
 web.moreButton=еще
-web.gpxExportButton=
+web.gpxExportButton=Экспорт GPX
 web.routeInfo=%1$s займет %2$s
-web.locationsNotFound=Построение маршрута невозвозможно. Местоположение не определено
+web.locationsNotFound=Построить маршрут невозможно. Не определено местоположение.
 web.bike=Велосипед
-web.racingbike=
-web.mtb=
+web.racingbike=Гоночный велосипед
+web.mtb=Горный велосипед
 web.car=Автомобиль
 web.foot=Пешком
-web.staticlink=
-via=
-finish=Целевая достигнуто
-hourAbbr=h
-dayAbbr=d
-minAbbr=min
-kmAbbr=km
-mAbbr=m
-miAbbr=mi
-ftAbbr=ft
-road=
-off_bike=
-cycleway=
-way=
-paved=
-unpaved=
-stopover=
-roundaboutInstruction=
-roundaboutInstructionWithDir=
+web.staticlink=Ссылка
+web.motorcycle=Мотоцикл
+via=через
+finish=Цель достигнута!
+hourAbbr=ч
+dayAbbr=д
+minAbbr=мин
+kmAbbr=км
+mAbbr=м
+miAbbr=ми
+ftAbbr=фт
+road=дорога
+off_bike=слезьте с велосипеда
+cycleway=велодорожка
+way=путь
+paved=с покрытием
+unpaved=без покрытия
+stopover=остановка %1$s
+roundaboutEnter=Въезжайте на кольцо
+roundaboutExit=У кольца используйте съезд %1$s
+roundaboutExitOnto=У кольца используйте съезд %1$s на %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/si.txt b/core/src/main/resources/com/graphhopper/util/si.txt
index a398fc1826..7276fc5fa4 100644
--- a/core/src/main/resources/com/graphhopper/util/si.txt
+++ b/core/src/main/resources/com/graphhopper/util/si.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=ostro levo
-sharp_right=ostro desno
-left=levo
-right=desno
-slight_left=rahlo levo
-slight_right=rahlo desno
 continue=nadaljujte
 continue_onto=nadaljujte po %1$s
-turn=zavite %1$s
-turn_onto=zavite %1$s na %2$s
+turn_left=zavite levo
+turn_right=zavite desno
+turn_slight_left=zavite rahlo levo
+turn_slight_right=zavite rahlo desno
+turn_sharp_left=zavite ostro levo
+turn_sharp_right=zavite ostro desno
+turn_onto=%1$s na %2$s
 web.searchButton=Išči
 web.fromHint=Od 
 web.viaHint=
@@ -23,8 +22,9 @@ web.racingbike=cestno kolo
 web.mtb=gorsko kolo
 web.car=Avto
 web.foot=Peš
-web.staticlink=
-via=
+web.staticlink=povezava
+web.motorcycle=motorno kolo
+via=preko
 finish=Konec!
 hourAbbr=h
 dayAbbr=d
@@ -40,5 +40,6 @@ way=smer
 paved=tlakovana
 unpaved=netlakovana
 stopover=postanek %1$s
-roundaboutInstruction=zapelji v krožišče in izberi izhod %1$
-roundaboutInstructionWithDir=zapelji v krožišče in izberi izhod %1$ v smeri %2$s
+roundaboutEnter=zapeljite v krožišče
+roundaboutExit=v krožišču izberite izhod %1$s
+roundaboutExitOnto=v krožišču izberite izhod %1$s na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
index 3267b9dc25..623154278c 100644
--- a/core/src/main/resources/com/graphhopper/util/sk.txt
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=ostro doľava
-sharp_right=ostro doprava
-left=doľava
-right=doprava
-slight_left=mierne doľava
-slight_right=mierne doprava
 continue=pokračujte
 continue_onto=pokračujte na %1$s
-turn=odbočte %1$s
-turn_onto=odbočte %1$s na %2$s
+turn_left=odbočte doľava
+turn_right=odbočte doprava
+turn_slight_left=odbočte mierne doľava
+turn_slight_right=odbočte mierne doprava
+turn_sharp_left=odbočte ostro doľava
+turn_sharp_right=odbočte ostro doprava
+turn_onto=%1$s na %2$s
 web.searchButton=Vyhľadať
 web.fromHint=Z
 web.viaHint=Cez
@@ -24,6 +23,7 @@ web.mtb=Horský bicykel
 web.car=Automobil
 web.foot=Pešo
 web.staticlink=nemenný odkaz
+web.motorcycle=Motocykel
 via=cez
 finish=Cieľ!
 hourAbbr=Horský bicykel
@@ -40,5 +40,6 @@ way=smer
 paved=spevnená
 unpaved=nespevnená
 stopover=zastávka %1$s
-roundaboutInstruction=Vojdite na kruhový objazd a opustite ho cez %1$s. výjazd
-roundaboutInstructionWithDir=Vojdite na kruhový objazd a opustite ho cez %1$s. výjazd v smere %2$s
+roundaboutEnter=Vojdite na kruhový objazd
+roundaboutExit=Na kruhovom objazde, ho opustite cez %1$s. výjazd
+roundaboutExitOnto=Na kruhovom objazde, ho opustite cez %1$s. výjazd na %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/sv_SE.txt b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
index cbfcb87d05..07d7aba218 100644
--- a/core/src/main/resources/com/graphhopper/util/sv_SE.txt
+++ b/core/src/main/resources/com/graphhopper/util/sv_SE.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=kraftigt vänster
-sharp_right=kraftigt höger
-left=vänster
-right=höger
-slight_left=svagt vänster
-slight_right=svagt höger
 continue=fortsätt
 continue_onto=fortsätt in på %1$s
-turn=sväng %1$s
-turn_onto=sväng %1$s in på %2$s
+turn_left=sväng vänster
+turn_right=sväng höger
+turn_slight_left=sväng svagt vänster
+turn_slight_right=sväng svagt höger
+turn_sharp_left=sväng kraftigt vänster
+turn_sharp_right=sväng kraftigt höger
+turn_onto=%1$s in på %2$s
 web.searchButton=Sök
 web.fromHint=Från
 web.viaHint=Via
@@ -24,6 +23,7 @@ web.mtb=Mountain bike
 web.car=Bil
 web.foot=Gång
 web.staticlink=Direktlänk
+web.motorcycle=
 via=via
 finish=Framme!
 hourAbbr= tim
@@ -40,5 +40,6 @@ way=väg
 paved=belagd
 unpaved=obelagd
 stopover=delmål %1$s
-roundaboutInstruction=Kör in i rondellen och ta avfart %1$s
-roundaboutInstructionWithDir=Kör in i rondellen och ta avfart %1$s mot %2$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/tr.txt b/core/src/main/resources/com/graphhopper/util/tr.txt
index f45d1ae345..2b774ce29a 100644
--- a/core/src/main/resources/com/graphhopper/util/tr.txt
+++ b/core/src/main/resources/com/graphhopper/util/tr.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=sola keskin dönüş
-sharp_right=sağa keskin dönüş
-left=sol 
-right=sağ 
-slight_left=hafif sola
-slight_right=hafif sağa
 continue=devam
 continue_onto=-e devam %1$s
-turn=dön %1$s
-turn_onto=-e dön %1$s %2$s
+turn_left=dön sol 
+turn_right=dön sağ 
+turn_slight_left=dön hafif sola
+turn_slight_right=dön hafif sağa
+turn_sharp_left=dön sola keskin dönüş
+turn_sharp_right=dön sağa keskin dönüş
+turn_onto=%1$s %2$s
 web.searchButton=ara
 web.fromHint=-den 
 web.viaHint=araciligi ile
@@ -24,6 +23,7 @@ web.mtb=dag bisikleti
 web.car=Otomobil
 web.foot=Yürüyerek
 web.staticlink=duragan baglanti
+web.motorcycle=
 via=araciligi ile
 finish=Bitti !
 hourAbbr=s
@@ -40,5 +40,6 @@ way=yol
 paved=kaldırım
 unpaved=kaldırımsız yol
 stopover=mola yeri %1$s
-roundaboutInstruction=döner kavsağa girin ve cıkışı kullanın %1$
-roundaboutInstructionWithDir=döner kavşağa girin ve çıkışı kullanın %1$ - %2$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
index d0701f7371..a356a96217 100644
--- a/core/src/main/resources/com/graphhopper/util/uk.txt
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -1,15 +1,14 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-sharp_left=різко наліво
-sharp_right=різко направо
-left=наліво
-right=направо
-slight_left=трохи лівіше
-slight_right=трохи правіше
 continue=продовжуйте
 continue_onto=продовжуйте по „%1$s“
-turn=поверніть %1$s
-turn_onto=поверніть %1$s на „%2$s“
+turn_left=Поверніть наліво
+turn_right=Поверніть направо
+turn_slight_left=Поверніть трохи лівіше
+turn_slight_right=Поверніть трохи правіше
+turn_sharp_left=Поверніть різко наліво
+turn_sharp_right=Поверніть різко направо
+turn_onto=%1$s на „%2$s“
 web.searchButton=Пошук
 web.fromHint=Від
 web.viaHint=через
@@ -24,6 +23,7 @@ web.mtb=Гірський велосипед
 web.car=Автомобіль
 web.foot=Пішки
 web.staticlink=статичне посилання
+web.motorcycle=Мотоцикл
 via=через
 finish=Ви прибули до пункту призначення!
 hourAbbr= год
@@ -34,11 +34,12 @@ mAbbr= м
 miAbbr= милі
 ftAbbr= фути
 road=дорога
-off_bike=секція, що відкривається натисканням
+off_bike=злізьте з велосипеда
 cycleway=велосипедна доріжка
 way=шлях
 paved=з покриттям
 unpaved=без покриття
 stopover=зупинка %1$s
-roundaboutInstruction=в’їзд на кільце та виїзд по %1$s
-roundaboutInstructionWithDir=в’їзд на кільце та виїзд по %1$s у напрямку %2$s
+roundaboutEnter=В’їжджайте на кільце
+roundaboutExit=На кільці використовуйте з’їзд %1$s
+roundaboutExitOnto=На кільці використовуйте з’їзд %1$s на %2$s
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
new file mode 100644
index 0000000000..015af51a0e
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=tiếp tục
+continue_onto=tiếp tục theo %1$s
+turn_left=rẽ trái
+turn_right=rẽ phải
+turn_slight_left=rẽ nhẹ trái
+turn_slight_right=rẽ nhẹ phải
+turn_sharp_left=rẽ trái ngay
+turn_sharp_right=rẽ phải ngay
+turn_onto=%1$s theo %1$s
+web.searchButton=Tìm
+web.fromHint=Từ
+web.viaHint=Qua
+web.toHint=Đến
+web.moreButton=thêm
+web.gpxExportButton=Xuất GPX
+web.routeInfo=%1$s mất %2$s
+web.locationsNotFound=Không tìm thấy lộ trình! Các điểm đã chọn không tìm thấy trong vùng này
+web.bike=Xe đạp
+web.racingbike=Xe đua
+web.mtb=Xe leo núi
+web.car=Ô tô
+web.foot=Đi bộ
+web.staticlink=liên kết tĩnh
+web.motorcycle=Mô tô
+via=qua
+finish=Kết thúc!
+hourAbbr=g
+dayAbbr=n
+minAbbr=p
+kmAbbr=km
+mAbbr=m
+miAbbr=dặm
+ftAbbr=ft
+road=đường
+off_bike=bỏ xe đạp
+cycleway=đường xe đạp
+way=đường
+paved=đường lát
+unpaved=đường không lát
+stopover=điểm nghỉ %1$s
+roundaboutEnter=
+roundaboutExit=
+roundaboutExitOnto=
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
new file mode 100644
index 0000000000..1a5809a030
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -0,0 +1,45 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=继续
+continue_onto=继续行驶到 %1$s
+turn_left=左转
+turn_right=右转
+turn_slight_left=偏左转
+turn_slight_right=偏右转
+turn_sharp_left=左急转
+turn_sharp_right=右急转
+turn_onto=%1$s 到  %2$s
+web.searchButton=搜索
+web.fromHint=起点
+web.viaHint=途经点
+web.toHint=终点
+web.moreButton=更多
+web.gpxExportButton=GPX导出
+web.routeInfo=%1$s 的路线，需要 %2$s 时间
+web.locationsNotFound=地点未找到
+web.bike=自行车
+web.racingbike=竞技自行车
+web.mtb=山地自行车
+web.car=驾车
+web.foot=步行
+web.staticlink=静态链接
+web.motorcycle=摩托车
+via=途经
+finish=终点到达
+hourAbbr=小时
+dayAbbr=天
+minAbbr=分钟
+kmAbbr=公里
+mAbbr=米
+miAbbr=英里
+ftAbbr=英尺
+road=道路
+off_bike=下自行车
+cycleway=自行车道
+way=路
+paved=路面铺就
+unpaved=路面未铺就
+stopover=途中休息 %1$s
+roundaboutEnter=进入环岛
+roundaboutExit=在环岛内，使用%1$s出口出环岛
+roundaboutExitOnto=在环岛内，使用%1$s出口出环岛，进入%2$s
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 03e770c979..fd7d4a3721 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -54,14 +54,14 @@ public void testLoad()
                 setEncodingManager(encodingManager).
                 setCHEnable(false).
                 loadGraph(graph);
-        GHResponse ph = instance.route(new GHRequest(42, 10.4, 42, 10));
-        assertTrue(ph.isFound());
-        assertEquals(80, ph.getDistance(), 1e-6);
-        assertEquals(42, ph.getPoints().getLatitude(0), 1e-5);
-        assertEquals(10.4, ph.getPoints().getLongitude(0), 1e-5);
-        assertEquals(41.9, ph.getPoints().getLatitude(1), 1e-5);
-        assertEquals(10.2, ph.getPoints().getLongitude(1), 1e-5);
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(42, 10.4, 42, 10));
+        assertFalse(rsp.hasErrors());
+        assertEquals(80, rsp.getDistance(), 1e-6);
+        assertEquals(42, rsp.getPoints().getLatitude(0), 1e-5);
+        assertEquals(10.4, rsp.getPoints().getLongitude(0), 1e-5);
+        assertEquals(41.9, rsp.getPoints().getLatitude(1), 1e-5);
+        assertEquals(10.2, rsp.getPoints().getLongitude(1), 1e-5);
+        assertEquals(3, rsp.getPoints().getSize());
         instance.close();
     }
 
@@ -77,15 +77,23 @@ public void testDisconnected179()
 
         graph.edge(0, 1, 10, true);
         graph.edge(2, 3, 10, true);
-        
+
         GraphHopper instance = new GraphHopper().
                 setStoreOnFlush(false).
                 setEncodingManager(encodingManager).
                 setCHEnable(false).
                 loadGraph(graph);
-        GHResponse ph = instance.route(new GHRequest(42, 10, 42, 10.4));
-        assertFalse(ph.isFound());
-        assertEquals(0, ph.getPoints().getSize());        
+        GHResponse rsp = instance.route(new GHRequest(42, 10, 42, 10.4));
+        assertTrue(rsp.hasErrors());
+
+        try
+        {
+            rsp.getPoints();
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+        }
+
         instance.close();
     }
 
diff --git a/core/src/test/java/com/graphhopper/GraphHopperTest.java b/core/src/test/java/com/graphhopper/GraphHopperTest.java
index 41f1726050..f71ff9e8c2 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperTest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperTest.java
@@ -1,10 +1,10 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
  *
  *       http://www.apache.org/licenses/LICENSE-2.0
@@ -17,7 +17,24 @@
  */
 package com.graphhopper;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
 import com.graphhopper.reader.DataReader;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.index.QueryResult;
@@ -25,15 +42,6 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.shapes.GHPoint;
-import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import org.junit.After;
-import org.junit.Test;
-import static org.junit.Assert.*;
-import org.junit.Before;
 
 /**
  *
@@ -68,22 +76,23 @@ public void testLoadOSM()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         closableInstance.importOrLoad();
-        GHResponse ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         closableInstance.close();
-        closableInstance = new GraphHopper().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("CAR"));
+
+        // no encoding manager necessary
+        closableInstance = new GraphHopper().setStoreOnFlush(true);
         assertTrue(closableInstance.load(ghLoc));
-        ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         closableInstance.close();
         try
         {
-            ph = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+            rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
             assertTrue(false);
         } catch (Exception ex)
         {
@@ -109,18 +118,18 @@ public void testLoadOSMNoCH()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         gh.importOrLoad();
-        GHResponse ph = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         gh.close();
         gh = new GraphHopper().setStoreOnFlush(true).
                 setCHEnable(false).
                 setEncodingManager(new EncodingManager("CAR"));
         assertTrue(gh.load(ghLoc));
-        ph = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
+        rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
 
         gh.close();
     }
@@ -169,9 +178,9 @@ protected DataReader importData() throws IOException
                 return super.importData();
             }
         }.setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("CAR")).
-                setGraphHopperLocation(ghLoc).
-                setOSMFile(testOsm);
+        setEncodingManager(new EncodingManager("CAR")).
+        setGraphHopperLocation(ghLoc).
+        setOSMFile(testOsm);
         final AtomicReference<Exception> ar = new AtomicReference<Exception>();
         Thread thread = new Thread()
         {
@@ -226,10 +235,11 @@ public void testPrepare()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).setAlgorithm("dijkstrabi"));
-        assertTrue(ph.isFound());
-        assertEquals("(51.24921503475044,9.431716451757769), (52.0,9.0), (51.199999850988384,9.39999970197677)", ph.getPoints().toString());
-        assertEquals(3, ph.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+                setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
+        assertFalse(rsp.hasErrors());
+        assertEquals(Helper.createPointList(51.249215, 9.431716, 52.0, 9.0, 51.2, 9.4), rsp.getPoints());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
@@ -242,12 +252,23 @@ public void testSortedGraph_noCH()
                 setGraphHopperLocation(ghLoc).
                 setOSMFile(testOsm);
         instance.importOrLoad();
-        GHResponse ph = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).setAlgorithm("dijkstrabi"));
-        assertTrue(ph.isFound());
-        assertEquals(3, ph.getPoints().getSize());
-        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), ph.getPoints().toGHPoint(0));
-        assertEquals(new GHPoint(52.0, 9.0), ph.getPoints().toGHPoint(1));
-        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), ph.getPoints().toGHPoint(2));
+        GHResponse rsp = instance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4).
+                setAlgorithm(AlgorithmOptions.DIJKSTRA_BI));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
+        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().toGHPoint(0));
+        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().toGHPoint(1));
+        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().toGHPoint(2));
+
+        GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
+        boolean old = instance.enableInstructions;
+        req.getHints().put("instructions", true);
+        instance.route(req);
+        assertEquals(old, instance.enableInstructions);
+
+        req.getHints().put("instructions", false);
+        instance.route(req);
+        assertEquals("route method should not change instance field", old, instance.enableInstructions);
     }
 
     @Test
@@ -262,36 +283,43 @@ public void testFootAndCar()
         instance.importOrLoad();
 
         assertEquals(5, instance.getGraph().getNodes());
-        assertEquals(8, instance.getGraph().getAllEdges().getMaxId());
+        assertEquals(8, instance.getGraph().getAllEdges().getCount());
 
         // A to D
-        GHResponse res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
-        assertFalse(res.hasErrors());
-        assertTrue(res.isFound());
-        assertEquals(3, res.getPoints().getSize());
+        GHResponse rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
         // => found A and D
-        assertEquals(50, res.getPoints().getLongitude(0), 1e-3);
-        assertEquals(11.1, res.getPoints().getLatitude(0), 1e-3);
-        assertEquals(51, res.getPoints().getLongitude(2), 1e-3);
-        assertEquals(11.3, res.getPoints().getLatitude(2), 1e-3);
-
-        // A to D not allowed for foot. But the location index will choose a node close to D accessible to FOOT        
-        res = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(2, res.getPoints().getSize());
-        // => found a point on edge A-B        
-        assertEquals(11.680, res.getPoints().getLatitude(1), 1e-3);
-        assertEquals(50.644, res.getPoints().getLongitude(1), 1e-3);
+        assertEquals(50, rsp.getPoints().getLongitude(0), 1e-3);
+        assertEquals(11.1, rsp.getPoints().getLatitude(0), 1e-3);
+        assertEquals(51, rsp.getPoints().getLongitude(2), 1e-3);
+        assertEquals(11.3, rsp.getPoints().getLatitude(2), 1e-3);
+
+        // A to D not allowed for foot. But the location index will choose a node close to D accessible to FOOT
+        rsp = instance.route(new GHRequest(11.1, 50, 11.3, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().getSize());
+        // => found a point on edge A-B
+        assertEquals(11.680, rsp.getPoints().getLatitude(1), 1e-3);
+        assertEquals(50.644, rsp.getPoints().getLongitude(1), 1e-3);
 
         // A to E only for foot
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
-        assertEquals(2, res.getPoints().size());
+        // NOT 100% sure about this. need to test (Paul H)
+        //<<<<<<< HEAD
+        //        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
+        //        assertTrue(res.isFound());
+        //        assertEquals(2, res.getPoints().size());
+        //=======
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.FOOT));
+        assertFalse(rsp.hasErrors());
+        assertEquals(2, rsp.getPoints().size());
+        //>>>>>>> upstream/master
 
         // A D E for car
-        res = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
-        assertTrue(res.isFound());
-        assertEquals(4, res.getPoints().getSize());
+        rsp = instance.route(new GHRequest(11.1, 50, 10, 51).setVehicle(EncodingManager.CAR));
+        assertFalse(rsp.hasErrors());
+        assertEquals(3, rsp.getPoints().getSize());
     }
 
     @Test
@@ -393,7 +421,7 @@ public void testFailsForMissingParameters() throws IOException
                     + " but also cannot import from OSM file as it wasn't specified!", ex.getMessage());
         }
 
-        // missing encoding manager          
+        // missing encoding manager
         instance = new GraphHopper().
                 setStoreOnFlush(true).
                 setGraphHopperLocation(ghLoc).
@@ -434,11 +462,11 @@ public void testFootOnly()
         instance.importOrLoad();
 
         assertEquals(2, instance.getGraph().getNodes());
-        assertEquals(2, instance.getGraph().getAllEdges().getMaxId());
+        assertEquals(2, instance.getGraph().getAllEdges().getCount());
 
         // A to E only for foot
         GHResponse res = instance.route(new GHRequest(11.1, 50, 11.2, 52).setVehicle(EncodingManager.FOOT));
-        assertTrue(res.isFound());
+        assertFalse(res.hasErrors());
         assertEquals(3, res.getPoints().getSize());
     }
 
@@ -486,8 +514,8 @@ public void testVia()
                 init(new CmdArgs().
                         put("osmreader.osm", testOsm3).
                         put("prepare.minNetworkSize", "1").
-                        put("graph.acceptWay", "CAR")).
-                setGraphHopperLocation(ghLoc);
+                        put("graph.flagEncoders", "CAR")).
+                        setGraphHopperLocation(ghLoc);
         instance.importOrLoad();
 
         // A -> B -> C
@@ -495,16 +523,16 @@ public void testVia()
         GHPoint second = new GHPoint(12, 51);
         GHPoint third = new GHPoint(11.2, 51.9);
         GHResponse rsp12 = instance.route(new GHRequest().addPoint(first).addPoint(second));
-        assertTrue("should find 1->2", rsp12.isFound());
-        assertEquals(147931.5, rsp12.getDistance(), .1);
+        assertFalse("should find 1->2", rsp12.hasErrors());
+        assertEquals(147930.5, rsp12.getDistance(), .1);
         GHResponse rsp23 = instance.route(new GHRequest().addPoint(second).addPoint(third));
-        assertTrue("should find 2->3", rsp23.isFound());
+        assertFalse("should find 2->3", rsp23.hasErrors());
         assertEquals(176608.9, rsp23.getDistance(), .1);
 
         GHResponse rsp = instance.route(new GHRequest().addPoint(first).addPoint(second).addPoint(third));
 
         assertFalse(rsp.hasErrors());
-        assertTrue("should find 1->2->3", rsp.isFound());
+        assertFalse("should find 1->2->3", rsp.hasErrors());
         assertEquals(rsp12.getDistance() + rsp23.getDistance(), rsp.getDistance(), 1e-6);
         assertEquals(5, rsp.getPoints().getSize());
         assertEquals(5, rsp.getInstructions().size());
diff --git a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
index 803d4d751d..4e9b580902 100644
--- a/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
+++ b/core/src/test/java/com/graphhopper/coll/AbstractBinHeapTest.java
@@ -17,7 +17,7 @@
  */
 package com.graphhopper.coll;
 
-import com.graphhopper.storage.Edge;
+import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.EdgeIterator;
 import java.util.PriorityQueue;
 import java.util.Random;
@@ -123,7 +123,7 @@ public void testRekey()
     @Test
     public void testSize()
     {
-        PriorityQueue<Edge> juQueue = new PriorityQueue<Edge>(100);
+        PriorityQueue<EdgeEntry> juQueue = new PriorityQueue<EdgeEntry>(100);
         BinHeapWrapper<Number, Integer> binHeap = createHeap(100);
 
         Random rand = new Random(1);
@@ -132,7 +132,7 @@ public void testSize()
         {
             int val = rand.nextInt();
             binHeap.insert(val, i);
-            juQueue.add(new Edge(EdgeIterator.NO_EDGE, i, val));
+            juQueue.add(new EdgeEntry(EdgeIterator.NO_EDGE, i, val));
         }
 
         assertEquals(juQueue.size(), binHeap.getSize());
diff --git a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
index cb8e34888f..36dfb74cd2 100644
--- a/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
+++ b/core/src/test/java/com/graphhopper/geohash/LinearKeyAlgoTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.geohash;
 
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import static org.junit.Assert.*;
 import org.junit.Test;
@@ -67,4 +68,21 @@ public void testDecode()
         assertEquals(16.3333333, latLon.lat, 1e-7);
         assertEquals(5.25, latLon.lon, 1e-7);
     }
+    /*
+    * Test if different constructors yield same results
+     */
+    @Test
+    public void testInstantiation()
+    {
+        double minLon = 0; 
+        double minLat = 2;
+        double maxLat = 6;
+        double maxLon = 5;
+        
+        BBox bounds = new BBox(minLon,maxLon,minLat,maxLat);
+        LinearKeyAlgo algo1 = new LinearKeyAlgo(4,4).setBounds(bounds);
+        LinearKeyAlgo algo2 = new LinearKeyAlgo(4,4).setBounds(minLon, maxLon, minLat, maxLat);
+        assertEquals(algo1.getLonDelta(), algo2.getLonDelta(), 1e-7);
+        assertEquals(algo1.getLatDelta(), algo2.getLatDelta(), 1e-7);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
index 4bd61d53a1..84ce74f1d0 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMReaderTest.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -17,13 +17,18 @@
  */
 package com.graphhopper.reader;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
 import gnu.trove.list.TLongList;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URISyntaxException;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -37,15 +42,22 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.BikeFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EncodedValue;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.AbstractGraphStorageTester;
-import com.graphhopper.storage.ExtendedStorage;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.GraphStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -56,10 +68,10 @@
 /**
  * Tests the OSMReader with the normal helper initialized.
  * <p/>
+ *
  * @author Peter Karich
  */
-public class OSMReaderTest
-{
+public class OSMReaderTest {
     private final String file1 = "test-osm.xml";
     private final String file2 = "test-osm2.xml";
     private final String file3 = "test-osm3.xml";
@@ -75,44 +87,35 @@
     private EdgeExplorer carAllExplorer;
 
     @Before
-    public void setUp()
-    {
+    public void setUp() {
         new File(dir).mkdirs();
     }
 
     @After
-    public void tearDown()
-    {
+    public void tearDown() {
         Helper.removeDir(new File(dir));
     }
 
-    GraphStorage newGraph( String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport )
-    {
-        return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager,
-                is3D, turnRestrictionsImport ? new TurnCostStorage() : new ExtendedStorage.NoExtendedStorage());
+    GraphStorage newGraph(String directory, EncodingManager encodingManager, boolean is3D, boolean turnRestrictionsImport) {
+        return new GraphHopperStorage(new RAMDirectory(directory, false), encodingManager, is3D, turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoExtendedStorage());
     }
 
-    class GraphHopperTest extends GraphHopper
-    {
-        public GraphHopperTest( String osmFile )
-        {
+    class GraphHopperTest extends GraphHopper {
+        public GraphHopperTest(String osmFile) {
             this(osmFile, false);
         }
 
-        public GraphHopperTest( String osmFile, boolean turnCosts )
-        {
+        public GraphHopperTest(String osmFile, boolean turnCosts) {
             setStoreOnFlush(false);
             setOSMFile(osmFile);
             setGraphHopperLocation(dir);
             setEncodingManager(new EncodingManager("CAR,FOOT"));
             setCHEnable(false);
 
-            if (turnCosts)
-            {
+            if (turnCosts) {
                 carEncoder = new CarFlagEncoder(5, 5, 3);
                 bikeEncoder = new BikeFlagEncoder(4, 2, 3);
-            } else
-            {
+            } else {
                 carEncoder = new CarFlagEncoder();
                 bikeEncoder = new BikeFlagEncoder();
             }
@@ -123,23 +126,19 @@ public GraphHopperTest( String osmFile, boolean turnCosts )
         }
 
         @Override
-        protected DataReader createReader( GraphStorage tmpGraph )
-        {
+        protected DataReader createReader(GraphStorage tmpGraph) {
             return initReader(new OSMReader(tmpGraph));
         }
 
         @Override
-        protected DataReader importData() throws IOException
-        {
+        protected DataReader importData() throws IOException {
             GraphStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(), getEncodingManager().needsTurnCostsSupport());
             setGraph(tmpGraph);
 
             DataReader osmReader = createReader(tmpGraph);
-            try
-            {
+            try {
                 ((OSMReader) osmReader).setOSMFile(new File(getClass().getResource(getOSMFile()).toURI()));
-            } catch (URISyntaxException e)
-            {
+            } catch (URISyntaxException e) {
                 throw new RuntimeException(e);
             }
             osmReader.readGraph();
@@ -149,16 +148,14 @@ protected DataReader importData() throws IOException
         }
     }
 
-    InputStream getResource( String file )
-    {
+    InputStream getResource(String file) {
         return getClass().getResourceAsStream(file);
     }
 
     @Test
-    public void testMain()
-    {
+    public void testMain() {
         GraphHopper hopper = new GraphHopperTest(file1).importOrLoad();
-        GraphStorage graph = (GraphStorage) hopper.getGraph();
+        GraphStorage graph = hopper.getGraph();
 
         assertNotNull(graph.getProperties().get("osmreader.import.date"));
         assertNotEquals("", graph.getProperties().get("osmreader.import.date"));
@@ -212,8 +209,7 @@ public void testMain()
     }
 
     @Test
-    public void testSort()
-    {
+    public void testSort() {
         GraphHopper hopper = new GraphHopperTest(file1).setSortGraph(true).importOrLoad();
         Graph graph = hopper.getGraph();
         NodeAccess na = graph.getNodeAccess();
@@ -222,18 +218,13 @@ public void testSort()
     }
 
     @Test
-    public void testWithBounds()
-    {
-        GraphHopper hopper = new GraphHopperTest(file1)
-        {
+    public void testWithBounds() {
+        GraphHopper hopper = new GraphHopperTest(file1) {
             @Override
-            protected DataReader createReader( GraphStorage tmpGraph )
-            {
-                return new OSMReader(tmpGraph)
-                {
+            protected DataReader createReader(GraphStorage tmpGraph) {
+                return new OSMReader(tmpGraph) {
                     @Override
-                    public boolean isInBounds( OSMNode node )
-                    {
+                    public boolean isInBounds(OSMNode node) {
                         return node.getLat() > 49 && node.getLon() > 8;
                     }
                 }.setEncodingManager(getEncodingManager());
@@ -274,8 +265,7 @@ public boolean isInBounds( OSMNode node )
     }
 
     @Test
-    public void testOneWay()
-    {
+    public void testOneWay() {
         GraphHopper hopper = new GraphHopperTest(file2).importOrLoad();
         Graph graph = hopper.getGraph();
 
@@ -322,13 +312,10 @@ public void testOneWay()
     }
 
     @Test
-    public void testFerry()
-    {
-        GraphHopper hopper = new GraphHopperTest(file2)
-        {
+    public void testFerry() {
+        GraphHopper hopper = new GraphHopperTest(file2) {
             @Override
-            public void cleanUp()
-            {
+            public void cleanUp() {
             }
         }.importOrLoad();
         Graph graph = hopper.getGraph();
@@ -343,21 +330,19 @@ public void cleanUp()
         iter.next();
         assertEquals(5, carEncoder.getSpeed(iter.getFlags()), 1e-1);
 
-        // duration 01:10 is given => more precise speed calculation! 
-        // ~111km (from 54.0,10.1 to 55.0,10.2) in duration=70 minutes => 95km/h => / 1.4 => 71km/h        
+        // duration 01:10 is given => more precise speed calculation!
+        // ~111km (from 54.0,10.1 to 55.0,10.2) in duration=70 minutes => 95km/h
+        // => / 1.4 => 71km/h
         iter = carOutExplorer.setBaseNode(n40);
         iter.next();
         assertEquals(70, carEncoder.getSpeed(iter.getFlags()), 1e-1);
     }
 
     @Test
-    public void testMaxSpeed()
-    {
-        GraphHopper hopper = new GraphHopperTest(file2)
-        {
+    public void testMaxSpeed() {
+        GraphHopper hopper = new GraphHopperTest(file2) {
             @Override
-            public void cleanUp()
-            {
+            public void cleanUp() {
             }
         }.importOrLoad();
         Graph graph = hopper.getGraph();
@@ -369,8 +354,7 @@ public void cleanUp()
     }
 
     @Test
-    public void testWayReferencesNotExistingAdjNode()
-    {
+    public void testWayReferencesNotExistingAdjNode() {
         GraphHopper hopper = new GraphHopperTest(file4).importOrLoad();
         Graph graph = hopper.getGraph();
 
@@ -382,8 +366,7 @@ public void testWayReferencesNotExistingAdjNode()
     }
 
     @Test
-    public void testFoot()
-    {
+    public void testFoot() {
         GraphHopper hopper = new GraphHopperTest(file3).importOrLoad();
         Graph graph = hopper.getGraph();
 
@@ -405,8 +388,7 @@ public void testFoot()
     }
 
     @Test
-    public void testNegativeIds()
-    {
+    public void testNegativeIds() {
         GraphHopper hopper = new GraphHopperTest(fileNegIds).importOrLoad();
         Graph graph = hopper.getGraph();
         assertEquals(4, graph.getNodes());
@@ -430,8 +412,7 @@ public void testNegativeIds()
     }
 
     @Test
-    public void testBarriers()
-    {
+    public void testBarriers() {
         GraphHopper hopper = new GraphHopperTest(fileBarriers).importOrLoad();
         Graph graph = hopper.getGraph();
         assertEquals(8, graph.getNodes());
@@ -465,8 +446,7 @@ public void testBarriers()
     }
 
     @Test
-    public void testBarriersOnTowerNodes()
-    {
+    public void testBarriersOnTowerNodes() {
         GraphHopper hopper = new GraphHopperTest(fileBarriers).importOrLoad();
         Graph graph = hopper.getGraph();
         assertEquals(8, graph.getNodes());
@@ -487,11 +467,9 @@ public void testBarriersOnTowerNodes()
     }
 
     @Test
-    public void testRelation()
-    {
+    public void testRelation() {
         EncodingManager manager = new EncodingManager("bike");
-        OSMReader reader = new OSMReader(new GraphHopperStorage(new RAMDirectory(), manager, false)).
-                setEncodingManager(manager);
+        OSMReader reader = new OSMReader(new GraphHopperStorage(new RAMDirectory(), manager, false)).setEncodingManager(manager);
         OSMRelation osmRel = new OSMRelation(1);
         osmRel.getMembers().add(new OSMRelation.Member(OSMRelation.WAY, 1, ""));
         osmRel.getMembers().add(new OSMRelation.Member(OSMRelation.WAY, 2, ""));
@@ -517,14 +495,12 @@ public void testRelation()
     }
 
     @Test
-    public void testTurnRestrictions()
-    {
-        GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions, true).
-                importOrLoad();
+    public void testTurnRestrictions() {
+        GraphHopper hopper = new GraphHopperTest(fileTurnRestrictions, true).importOrLoad();
         GraphStorage graph = hopper.getGraph();
         assertEquals(15, graph.getNodes());
-        assertTrue(graph.getExtendedStorage() instanceof TurnCostStorage);
-        TurnCostStorage tcStorage = (TurnCostStorage) graph.getExtendedStorage();
+        assertTrue(graph.getExtension() instanceof TurnCostExtension);
+        TurnCostExtension tcStorage = (TurnCostExtension) graph.getExtension();
 
         int n1 = AbstractGraphStorageTester.getIdOf(graph, 50, 10);
         int n2 = AbstractGraphStorageTester.getIdOf(graph, 52, 10);
@@ -545,26 +521,26 @@ public void testTurnRestrictions()
 
         // (2-3)->(3-4) only_straight_on = (2-3)->(3-8) restricted
         // (4-3)->(3-8) no_right_turn = (4-3)->(3-8) restricted
-        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(n3, edge2_3, edge3_8)) > 0);
-        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(n3, edge4_3, edge3_8)) > 0);
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge2_3, edge3_4)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge2_3, edge3_2)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge2_3, edge3_4)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge4_3, edge3_2)));
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n3, edge8_3, edge3_2)));
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_8)) > 0);
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_8)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge2_3, n3, edge3_4)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge4_3, n3, edge3_2)));
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge8_3, n3, edge3_2)));
 
         // u-turn restriction for (6-1)->(1-6) but not for (1-6)->(6-1)
-        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(n1, edge1_6, edge1_6)) > 0);
-        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n6, edge1_6, edge1_6)));
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge1_6, n1, edge1_6)) > 0);
+        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(edge1_6, n6, edge1_6)));
 
         int edge4_5 = GHUtility.getEdge(graph, n4, n5).getEdge();
         int edge5_6 = GHUtility.getEdge(graph, n5, n6).getEdge();
         int edge5_1 = GHUtility.getEdge(graph, n5, n1).getEdge();
 
-        // (4-5)->(5-1) right_turn_only = (4-5)->(5-6) restricted 
-        long costsFlags = tcStorage.getTurnCostFlags(n5, edge4_5, edge5_6);
+        // (4-5)->(5-1) right_turn_only = (4-5)->(5-6) restricted
+        long costsFlags = tcStorage.getTurnCostFlags(edge4_5, n5, edge5_6);
         assertFalse(carEncoder.isTurnRestricted(costsFlags));
-        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(n5, edge4_5, edge5_1)) > 0);
+        assertTrue(carEncoder.getTurnCost(tcStorage.getTurnCostFlags(edge4_5, n5, edge5_1)) > 0);
 
         // for bike
         assertFalse(bikeEncoder.isTurnRestricted(costsFlags));
@@ -576,31 +552,27 @@ public void testTurnRestrictions()
         int edge10_11 = GHUtility.getEdge(graph, n10, n11).getEdge();
         int edge11_14 = GHUtility.getEdge(graph, n11, n14).getEdge();
 
-        assertEquals(0, tcStorage.getTurnCostFlags(n11, edge11_14, edge10_11));
+        assertEquals(0, tcStorage.getTurnCostFlags(edge11_14, n11, edge10_11));
 
-        costsFlags = tcStorage.getTurnCostFlags(n11, edge10_11, edge11_14);
+        costsFlags = tcStorage.getTurnCostFlags(edge10_11, n11, edge11_14);
         assertFalse(carEncoder.isTurnRestricted(costsFlags));
         assertTrue(bikeEncoder.isTurnRestricted(costsFlags));
     }
 
     @Test
-    public void testEstimatedCenter()
-    {
-        final CarFlagEncoder encoder = new CarFlagEncoder()
-        {
+    public void testEstimatedCenter() {
+        final CarFlagEncoder encoder = new CarFlagEncoder() {
             private EncodedValue objectEncoder;
 
             @Override
-            public int defineNodeBits( int index, int shift )
-            {
+            public int defineNodeBits(int index, int shift) {
                 shift = super.defineNodeBits(index, shift);
                 objectEncoder = new EncodedValue("oEnc", shift, 2, 1, 0, 3, true);
                 return shift + 2;
             }
 
             @Override
-            public long handleNodeTags( Node node )
-            {
+            public long handleNodeTags(Node node) {
                 if (node.hasTag("test", "now"))
                     return -objectEncoder.setValue(0, 1);
                 return 0;
@@ -616,24 +588,20 @@ public long handleNodeTags( Node node )
         lonMap.put(1, 1.0d);
         lonMap.put(2, 1.0d);
         final AtomicInteger increased = new AtomicInteger(0);
-        OSMReader osmreader = new OSMReader(graph)
-        {
+        OSMReader osmreader = new OSMReader(graph) {
             // mock data access
             @Override
-            double getTmpLatitude( int id )
-            {
+            double getTmpLatitude(int id) {
                 return latMap.get(id);
             }
 
             @Override
-            double getTmpLongitude( int id )
-            {
+            double getTmpLongitude(int id) {
                 return lonMap.get(id);
             }
 
             @Override
-            Collection<EdgeIteratorState> addOSMWay( TLongList osmNodeIds, long wayFlags, long osmId )
-            {
+            Collection<EdgeIteratorState> addOSMWay(TLongList osmNodeIds, long wayFlags, long osmId) {
                 return Collections.emptyList();
             }
         };
@@ -659,18 +627,13 @@ public long handleNodeTags( Node node )
     }
 
     @Test
-    public void testReadEleFromCustomOSM()
-    {
-        GraphHopper hopper = new GraphHopperTest("custom-osm-ele.xml")
-        {
+    public void testReadEleFromCustomOSM() {
+        GraphHopper hopper = new GraphHopperTest("custom-osm-ele.xml") {
             @Override
-            protected DataReader createReader( GraphStorage tmpGraph )
-            {
-                return initReader(new OSMReader(tmpGraph)
-                {
+            protected DataReader createReader(GraphStorage tmpGraph) {
+                return initReader(new OSMReader(tmpGraph) {
                     @Override
-                    protected double getElevation( OSMNode node )
-                    {
+                    protected double getElevation(OSMNode node) {
                         return node.getEle();
                     }
                 });
@@ -686,8 +649,7 @@ protected double getElevation( OSMNode node )
     }
 
     @Test
-    public void testReadEleFromDataProvider()
-    {
+    public void testReadEleFromDataProvider() {
         GraphHopper hopper = new GraphHopperTest("test-osm5.xml");
         // get N10E046.hgt.zip
         ElevationProvider provider = new SRTMProvider();
@@ -701,11 +663,89 @@ public void testReadEleFromDataProvider()
         int n50 = AbstractGraphStorageTester.getIdOf(graph, 49.5001);
 
         EdgeIteratorState edge = GHUtility.getEdge(graph, n50, n30);
-        assertEquals(Helper.createPointList3D(49.5001, 11.501, 426, 49.5002, 11.5015, 441, 49.5011, 11.502, 410.0),
-                edge.fetchWayGeometry(3));
+        assertEquals(Helper.createPointList3D(49.5001, 11.501, 426, 49.5002, 11.5015, 441, 49.5011, 11.502, 410.0), edge.fetchWayGeometry(3));
 
         edge = GHUtility.getEdge(graph, n10, n50);
-        assertEquals(Helper.createPointList3D(49.501, 11.5001, 383.0, 49.5001, 11.501, 426.0),
-                edge.fetchWayGeometry(3));
+        assertEquals(Helper.createPointList3D(49.501, 11.5001, 383.0, 49.5001, 11.501, 426.0), edge.fetchWayGeometry(3));
+    }
+
+    /**
+     * Tests the combination of different turn cost flags by different encoders.
+     */
+    @Test
+    public void testTurnFlagCombination() {
+        final ITurnCostTableEntry turnCostEntry_car = new OSMTurnRelation.TurnCostTableEntry();
+        final ITurnCostTableEntry turnCostEntry_foot = new OSMTurnRelation.TurnCostTableEntry();
+        final ITurnCostTableEntry turnCostEntry_bike = new OSMTurnRelation.TurnCostTableEntry();
+
+        CarFlagEncoder car = new CarFlagEncoder(5, 5, 24);
+        FootFlagEncoder foot = new FootFlagEncoder();
+        BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24);
+        EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
+
+        OSMReader reader = new OSMReader(new GraphBuilder(manager).create()) {
+            @Override
+            public Collection<ITurnCostTableEntry> analyzeTurnRelation(FlagEncoder encoder, TurnRelation turnRelation) {
+                // simulate by returning one turn cost entry directly
+                if (encoder.toString().equalsIgnoreCase("car")) {
+
+                    return Collections.singleton(turnCostEntry_car);
+                } else if (encoder.toString().equalsIgnoreCase("foot")) {
+                    return Collections.singleton(turnCostEntry_foot);
+                } else if (encoder.toString().equalsIgnoreCase("bike")) {
+                    return Collections.singleton(turnCostEntry_bike);
+                } else {
+                    throw new IllegalArgumentException("illegal encoder " + encoder.toString());
+                }
+            }
+        }.setEncodingManager(manager);
+
+        // turn cost entries for car and foot are for the same relations (same
+        // viaNode, edgeFrom and edgeTo),
+        // turn cost entry for bike is for another relation (different viaNode)
+        turnCostEntry_car.setEdgeFrom(1);
+        turnCostEntry_foot.setEdgeFrom(1);
+        turnCostEntry_bike.setEdgeFrom(2);
+
+        // calculating arbitrary flags using the encoders
+        turnCostEntry_car.setFlags(car.getTurnFlags(true, 0));
+        turnCostEntry_foot.setFlags(foot.getTurnFlags(true, 0));
+        turnCostEntry_bike.setFlags(bike.getTurnFlags(false, 10));
+
+        // we expect two different entries: the first one is a combination of
+        // turn flags of car and foot,
+        // since they provide the same relation, the other one is for bike only
+        long assertFlag1 = turnCostEntry_car.getFlags() | turnCostEntry_foot.getFlags();
+        long assertFlag2 = turnCostEntry_bike.getFlags();
+
+        // combine flags of all encoders
+        Collection<ITurnCostTableEntry> entries = reader.analyzeTurnRelation(null);
+
+        // we expect two different turnCost entries
+        assertEquals(2, entries.size());
+
+        for (ITurnCostTableEntry entry : entries) {
+            if (entry.getEdgeFrom() == 1) {
+                // the first entry provides turn flags for car and foot only
+                assertEquals(assertFlag1, entry.getFlags());
+                assertTrue(car.isTurnRestricted(entry.getFlags()));
+                assertFalse(foot.isTurnRestricted(entry.getFlags()));
+                assertFalse(bike.isTurnRestricted(entry.getFlags()));
+
+                assertTrue(Double.isInfinite(car.getTurnCost(entry.getFlags())));
+                assertEquals(0, foot.getTurnCost(entry.getFlags()), 1e-1);
+                assertEquals(0, bike.getTurnCost(entry.getFlags()), 1e-1);
+            } else if (entry.getEdgeFrom() == 2) {
+                // the 2nd entry provides turn flags for bike only
+                assertEquals(assertFlag2, entry.getFlags());
+                assertFalse(car.isTurnRestricted(entry.getFlags()));
+                assertFalse(foot.isTurnRestricted(entry.getFlags()));
+                assertFalse(bike.isTurnRestricted(entry.getFlags()));
+
+                assertEquals(0, car.getTurnCost(entry.getFlags()), 1e-1);
+                assertEquals(0, foot.getTurnCost(entry.getFlags()), 1e-1);
+                assertEquals(10, bike.getTurnCost(entry.getFlags()), 1e-1);
+            }
+        }
     }
 }
diff --git a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
index b0c2880235..615c4f5380 100644
--- a/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
+++ b/core/src/test/java/com/graphhopper/reader/OSMTurnRelationTest.java
@@ -36,7 +36,7 @@
 import com.graphhopper.util.EdgeExplorer;
 
 /**
- * 
+ *
  * @author Peter Karich
  */
 public class OSMTurnRelationTest
@@ -54,7 +54,7 @@ public void testGetRestrictionAsEntries()
         internalToOSMEdge.put(4, 4L);
 
         GraphStorage graph = new GraphBuilder(new EncodingManager(encoder))
-                .create();
+        .create();
         EdgeBasedRoutingAlgorithmTest.initGraph(graph);
         OSMReader osmReader = new OSMReader(graph) {
 
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
index 5d99fdeb9d..24bf88b985 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/AbstractOsItnReaderTest.java
@@ -19,10 +19,10 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.FootFlagEncoder;
-import com.graphhopper.storage.ExtendedStorage;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 
@@ -88,7 +88,7 @@ public void initEncoding() {
 
     /**
      * So we can create a specific encoding manager in subclasses
-     * 
+     *
      * @return
      */
     protected EncodingManager createEncodingManager() {
@@ -111,8 +111,7 @@ protected GraphHopperStorage configureStorage(
     protected GraphHopperStorage configureStorage(
             boolean turnRestrictionsImport, boolean is3D, boolean addAdditionalTowerNodes) {
         String directory = "/tmp";
-        ExtendedStorage extendedStorage = turnRestrictionsImport ? new TurnCostStorage()
-                : new ExtendedStorage.NoExtendedStorage();
+        GraphExtension extendedStorage = turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoExtendedStorage();
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(
                 directory, false), encodingManager, is3D, extendedStorage);
         graph.getProperties().put("add.additional.tower.nodes", addAdditionalTowerNodes);
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/CombinationRestrictionTest.java b/core/src/test/java/com/graphhopper/reader/osgb/CombinationRestrictionTest.java
index 6165adf9f2..c31771e260 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/CombinationRestrictionTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/CombinationRestrictionTest.java
@@ -12,7 +12,7 @@
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.storage.AbstractGraphStorageTester;
 import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.GHUtility;
 
 /**
@@ -26,7 +26,7 @@
     public void testNoTurnFrom17To19() throws IOException {
         runNoMotorVehicleTurnFrom17To19Test("./src/test/resources/com/graphhopper/reader/os-itn-no-turn-mandatory-turn-combination-crossroad.xml");
     }
-    
+
     @Test
     public void testMandatoryTurnExceptBusTrueFrom19To17() throws IOException {
         runMandatoryMotorVehicleTurnFrom19To17Test("./src/test/resources/com/graphhopper/reader/os-itn-no-turn-mandatory-turn-combination-crossroad.xml");
@@ -43,7 +43,7 @@ private void runMandatoryMotorVehicleTurnFrom19To17Test(String filename) throws
         checkSimpleNodeNetwork(graph);
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
-                carOutExplorer = graph.createEdgeExplorer(carOutFilter);
+        carOutExplorer = graph.createEdgeExplorer(carOutFilter);
 
         GHUtility.printInfo(graph, 0, 20, carOutFilter);
         int n80 = AbstractGraphStorageTester.getIdOf(graph, node0Lat, node0Lon);
@@ -57,7 +57,7 @@ private void runMandatoryMotorVehicleTurnFrom19To17Test(String filename) throws
         int edge19_81_83 = getEdge(n81, n83);
         int edge20_81_84 = getEdge(n81, n84);
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         // Check that there is no restriction from 19 to 17 (our Mandatory turn)
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge17_80_81)));
@@ -66,27 +66,27 @@ private void runMandatoryMotorVehicleTurnFrom19To17Test(String filename) throws
         long turnCostFlags = tcStorage.getTurnCostFlags(n81, edge19_81_83, edge20_81_84);
         double cost = carEncoder.getTurnCost(turnCostFlags);
         assertTrue(cost > 0.0);
-        
+
         // Check that 19 to 18 is restricted (high cost)
         turnCostFlags = tcStorage.getTurnCostFlags(n81, edge19_81_83, edge18_81_82);
         cost = carEncoder.getTurnCost(turnCostFlags);
         assertTrue(cost > 0.0);
 
 
-//        // Every route from 19 is not restricted
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge17_80_81)));
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge18_81_82)));
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge20_81_84)));
+        //        // Every route from 19 is not restricted
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge17_80_81)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge18_81_82)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge20_81_84)));
         // Every route from 18 is not restricted
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge17_80_81)));
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge19_81_83)));
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge20_81_84)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge17_80_81)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge19_81_83)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge20_81_84)));
         // Every route from 20 is not restricted
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge17_80_81)));
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge18_81_82)));
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge19_81_83)));
     }
-    
+
     private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOException {
         boolean turnRestrictionsImport = true;
         boolean is3D = false;
@@ -98,7 +98,7 @@ private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOExcep
         checkSimpleNodeNetwork(graph);
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
-                carOutExplorer = graph.createEdgeExplorer(carOutFilter);
+        carOutExplorer = graph.createEdgeExplorer(carOutFilter);
 
         GHUtility.printInfo(graph, 0, 20, carOutFilter);
         int n80 = AbstractGraphStorageTester.getIdOf(graph, node0Lat, node0Lon);
@@ -112,7 +112,7 @@ private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOExcep
         int edge19_81_83 = getEdge(n81, n83);
         int edge20_81_84 = getEdge(n81, n84);
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         // Check that 17 to 19 is restricted (high cost)
         long turnCostFlags = tcStorage.getTurnCostFlags(n81, edge17_80_81, edge19_81_83);
@@ -121,19 +121,19 @@ private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOExcep
 
         // We don't care about whether 17 to 20 is restricted (high cost) but it won't be in this example
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge17_80_81, edge20_81_84)));
-        
+
         // We don't care about whether 17 to 18 is restricted (high cost)
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge17_80_81, edge18_81_82)));
 
 
         // Every route from 19 is not restricted
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge17_80_81)));
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge18_81_82)));
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge20_81_84)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge17_80_81)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge18_81_82)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge19_81_83, edge20_81_84)));
         // Every route from 18 is not restricted
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge17_80_81)));
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge19_81_83)));
-//        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge20_81_84)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge17_80_81)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge19_81_83)));
+        //        assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge18_81_82, edge20_81_84)));
         // Every route from 20 is not restricted
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge17_80_81)));
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge18_81_82)));
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/HeavitreeRoadDenmarkRoadCrossroadTest.java b/core/src/test/java/com/graphhopper/reader/osgb/HeavitreeRoadDenmarkRoadCrossroadTest.java
index fbf3036cd7..d9e11f24cf 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/HeavitreeRoadDenmarkRoadCrossroadTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/HeavitreeRoadDenmarkRoadCrossroadTest.java
@@ -19,7 +19,7 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.AbstractGraphStorageTester;
 import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.GHUtility;
@@ -74,8 +74,8 @@ private void runMandatoryMotorVehicleTurnFromSWToNWTest(String filename) throws
         carOutExplorer = graph.createEdgeExplorer(carOutFilter);
 
         GHUtility.printInfo(graph, 0, 20, EdgeFilter.ALL_EDGES);
-//        GHUtility.printInfo(graph, 2, 20, EdgeFilter.ALL_EDGES);
-//        GHUtility.printInfo(graph, 3, 20, EdgeFilter.ALL_EDGES);
+        //        GHUtility.printInfo(graph, 2, 20, EdgeFilter.ALL_EDGES);
+        //        GHUtility.printInfo(graph, 3, 20, EdgeFilter.ALL_EDGES);
 
         assertEquals(5, graph.getNodes());
         checkSimpleNodeNetwork(graph);
@@ -91,7 +91,7 @@ private void runMandatoryMotorVehicleTurnFromSWToNWTest(String filename) throws
         int edge6127_NE_CENTER = getEdge(nNE, nCenter);
         int edge6216_SE_CENTER = getEdge(nSE, nCenter);
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         // Check that there is no restriction from SW to NW (our Mandatory turn)
         long turnCostFlags = tcStorage.getTurnCostFlags(nCenter, edge1264_SW_CENTER, edge1253_NW_CENTER);
@@ -109,18 +109,18 @@ private void runMandatoryMotorVehicleTurnFromSWToNWTest(String filename) throws
         cost = carEncoder.getTurnCost(turnCostFlags);
         assertTrue(cost > 0.0);
 
-         // Every route from 19 is not restricted
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81,         edge19_81_83, edge17_80_81)));
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81,         edge19_81_83, edge18_81_82)));
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81,         edge19_81_83, edge20_81_84)));
-////         Every route from 18 is not restricted
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge18_81_82, edge17_80_81)));
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge18_81_82, edge19_81_83)));
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge18_81_82, edge20_81_84)));
-////         Every route from 20 is not restricted
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge20_81_84, edge17_80_81)));
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge20_81_84, edge18_81_82)));
-//         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge20_81_84, edge19_81_83)));
+        // Every route from 19 is not restricted
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81,         edge19_81_83, edge17_80_81)));
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81,         edge19_81_83, edge18_81_82)));
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81,         edge19_81_83, edge20_81_84)));
+        ////         Every route from 18 is not restricted
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge18_81_82, edge17_80_81)));
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge18_81_82, edge19_81_83)));
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge18_81_82, edge20_81_84)));
+        ////         Every route from 20 is not restricted
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge20_81_84, edge17_80_81)));
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge20_81_84, edge18_81_82)));
+        //         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(nCenter,         edge20_81_84, edge19_81_83)));
     }
 
     private void runNoMotorVehicleTurnFromNWToSWTest(String filename) throws IOException {
@@ -154,7 +154,7 @@ private void runNoMotorVehicleTurnFromNWToSWTest(String filename) throws IOExcep
         int edge6127_NE_CENTER = getEdge(nNE, nCenter);
         int edge6216_SE_CENTER = getEdge(nSE, nCenter);
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         // Check that NW to SW is restricted (high cost)
         long turnCostFlags = tcStorage.getTurnCostFlags(nCenter, edge1253_NW_CENTER, edge1264_SW_CENTER);
@@ -193,6 +193,7 @@ private void runNoMotorVehicleTurnFromNWToSWTest(String filename) throws IOExcep
         // edge20_81_84, edge19_81_83)));
     }
 
+    @Override
     protected void checkSimpleNodeNetwork(GraphHopperStorage graph) {
         EdgeExplorer explorer = graph.createEdgeExplorer(carOutEdges);
         assertEquals(4, count(explorer.setBaseNode(0)));
@@ -217,7 +218,7 @@ protected void checkSimpleNodeNetwork(GraphHopperStorage graph) {
     public void testActualGraph() {
         String graphLoc = "/home/phopkins/Documents/graphhopper/core/58096-SX9192-2c1";
         String inputFile = "/home/phopkins/Development/geoserver-service-test/geoservertest/itn-sample-data/58096-SX9192-2c1.xml";
-         EncodingManager enc = new EncodingManager(new CarFlagEncoder(5, 5, 3));
+        EncodingManager enc = new EncodingManager(new CarFlagEncoder(5, 5, 3));
         GraphHopper graphHopper = new GraphHopper().setInMemory().setGraphHopperLocation(graphLoc).setOSMFile(inputFile).setCHEnable(false).setEncodingManager(enc);
         graphHopper.importOrLoad();
         outputRoute(graphHopper, nodeNWLatitude, nodeNWLongitude, nodeSWLatitude, nodeSWLongitude);
@@ -238,14 +239,14 @@ private void outputRoute(GraphHopper graphHopper, double lat1, double lon1, doub
         System.err.println("ghResponse.getDebugInfo() " + ghResponse.getDebugInfo());
     }
 
-   // @Test
+    // @Test
     public void testIngest() throws IOException {
         boolean turnRestrictionsImport = true;
         boolean is3D = false;
         GraphHopperStorage graph = configureStorage(turnRestrictionsImport, is3D);
 
         File file = new File("/home/phopkins/Development/OSMMITN/data");
-//        File file = new File("/home/phopkins/Development/geoserver-service-test/geoservertest/itn-sample-data/58096-SX9192-2c1.xml");
+        //        File file = new File("/home/phopkins/Development/geoserver-service-test/geoservertest/itn-sample-data/58096-SX9192-2c1.xml");
         readGraphFile(graph, file);
     }
 
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/MandatoryTurnTest.java b/core/src/test/java/com/graphhopper/reader/osgb/MandatoryTurnTest.java
index 64676e2428..3821834bd4 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/MandatoryTurnTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/MandatoryTurnTest.java
@@ -12,7 +12,7 @@
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.storage.AbstractGraphStorageTester;
 import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.GHUtility;
 
 public class MandatoryTurnTest extends AbstractOsItnReaderTest{
@@ -21,7 +21,7 @@
     public void testReadSimpleCrossRoadsWithMandatoryTurnRestrictionFrom17To19() throws IOException {
         runMandatoryMotorVehicleTurnFrom17To19Test("./src/test/resources/com/graphhopper/reader/os-itn-simple-mandatory-turn-restricted-crossroad.xml");
     }
-    
+
     @Test
     public void testMandatoryTurnExceptBusTrueFrom17To19() throws IOException {
         runMandatoryMotorVehicleTurnFrom17To19Test("./src/test/resources/com/graphhopper/reader/os-itn-mandatory-turn-except-for-buses-true-crossroad.xml");
@@ -42,7 +42,7 @@ public void testMandatoryTurnExceptMotorVehicleTrueFrom17To19() throws IOExcepti
     public void testMandatoryTurnExceptMotorVehicleFalseFrom17To19() throws IOException {
         runMandatoryMotorVehicleTurnFrom17To19Test("./src/test/resources/com/graphhopper/reader/os-itn-mandatory-turn-except-for-motor-vehicles-false-crossroad.xml");
     }
-    
+
     private void runMandatoryMotorVehicleTurnFrom17To19Test(String filename) throws IOException {
         boolean turnRestrictionsImport = true;
         boolean is3D = false;
@@ -54,7 +54,7 @@ private void runMandatoryMotorVehicleTurnFrom17To19Test(String filename) throws
         checkSimpleNodeNetwork(graph);
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
-                carOutExplorer = graph.createEdgeExplorer(carOutFilter);
+        carOutExplorer = graph.createEdgeExplorer(carOutFilter);
 
         GHUtility.printInfo(graph, 0, 20, carOutFilter);
         int n80 = AbstractGraphStorageTester.getIdOf(graph, node0Lat, node0Lon);
@@ -68,7 +68,7 @@ private void runMandatoryMotorVehicleTurnFrom17To19Test(String filename) throws
         int edge19_81_83 = getEdge(n81, n83);
         int edge20_81_84 = getEdge(n81, n84);
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         // Check that there is no restriction from 17 to 19 (our Mandatory turn)
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge17_80_81, edge19_81_83)));
@@ -77,7 +77,7 @@ private void runMandatoryMotorVehicleTurnFrom17To19Test(String filename) throws
         long turnCostFlags = tcStorage.getTurnCostFlags(n81, edge17_80_81, edge20_81_84);
         double cost = carEncoder.getTurnCost(turnCostFlags);
         assertTrue(cost > 0.0);
-        
+
         // Check that 17 to 18 is restricted (high cost)
         turnCostFlags = tcStorage.getTurnCostFlags(n81, edge17_80_81, edge18_81_82);
         cost = carEncoder.getTurnCost(turnCostFlags);
@@ -97,7 +97,7 @@ private void runMandatoryMotorVehicleTurnFrom17To19Test(String filename) throws
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge18_81_82)));
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge19_81_83)));
     }
-    
+
     private void runNonMandatoryMotorVehicleTurnFrom17To19Test(String filename) throws IOException {
         boolean turnRestrictionsImport = true;
         boolean is3D = false;
@@ -109,7 +109,7 @@ private void runNonMandatoryMotorVehicleTurnFrom17To19Test(String filename) thro
         checkSimpleNodeNetwork(graph);
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
-                carOutExplorer = graph.createEdgeExplorer(carOutFilter);
+        carOutExplorer = graph.createEdgeExplorer(carOutFilter);
 
         GHUtility.printInfo(graph, 0, 20, carOutFilter);
         int n80 = AbstractGraphStorageTester.getIdOf(graph, node0Lat, node0Lon);
@@ -123,7 +123,7 @@ private void runNonMandatoryMotorVehicleTurnFrom17To19Test(String filename) thro
         int edge19_81_83 = getEdge(n81, n83);
         int edge20_81_84 = getEdge(n81, n84);
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         // Check that there is no restriction from 17 to 19 (our Mandatory turn)
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge17_80_81, edge19_81_83)));
@@ -131,7 +131,7 @@ private void runNonMandatoryMotorVehicleTurnFrom17To19Test(String filename) thro
         // Check that 17 to 20 is NOT restricted
         long turnCostFlags = tcStorage.getTurnCostFlags(n81, edge17_80_81, edge20_81_84);
         assertFalse(carEncoder.isTurnRestricted(turnCostFlags));
-        
+
         // Check that 17 to 18 is NOT restricted
         turnCostFlags = tcStorage.getTurnCostFlags(n81, edge17_80_81, edge18_81_82);
         assertFalse(carEncoder.isTurnRestricted(turnCostFlags));
@@ -150,5 +150,5 @@ private void runNonMandatoryMotorVehicleTurnFrom17To19Test(String filename) thro
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge18_81_82)));
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge19_81_83)));
     }
-    
+
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/NoTurnTest.java b/core/src/test/java/com/graphhopper/reader/osgb/NoTurnTest.java
index c905f03f46..7480b7a588 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/NoTurnTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/NoTurnTest.java
@@ -14,12 +14,12 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.AbstractGraphStorageTester;
 import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.GHUtility;
 
 public class NoTurnTest extends AbstractOsItnReaderTest{
-    
+
     @Test
     public void testNoTurnExceptBusTrueFrom17To19() throws IOException {
         runNoMotorVehicleTurnFrom17To19Test("./src/test/resources/com/graphhopper/reader/os-itn-no-turn-except-for-buses-true-crossroad.xml");
@@ -57,17 +57,17 @@ public void testNoTurnFromHeavitreeToDenmark() throws IOException {
         File file = new File("./src/test/resources/com/graphhopper/reader/os-itn-heavitree-road-denmark-road.xml");
         readGraphFile(graph, file);
         System.out.println("Node Count: " + graph.getNodes());
-//        assertEquals(5, graph.getNodes());
-//        checkSimpleNodeNetwork(graph);
+        //        assertEquals(5, graph.getNodes());
+        //        checkSimpleNodeNetwork(graph);
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
         carOutExplorer = graph.createEdgeExplorer(carOutFilter);
-        
+
         GHUtility.printInfo(graph, 0, 20, EdgeFilter.ALL_EDGES);
         System.out.println(count(carOutExplorer.setBaseNode(0)) + " node 0");
         System.out.println(count(carOutExplorer.setBaseNode(1)) + " node 1");
         assertEquals(4, count(carOutExplorer.setBaseNode(0)));
-        
+
         EdgeIterator iter = carOutExplorer.setBaseNode(0);
         while (iter.next()) {
             System.out.println("Edge: " + iter.getEdge());
@@ -77,7 +77,7 @@ public void testNoTurnFromHeavitreeToDenmark() throws IOException {
             System.out.println("Edge: " + iter.getEdge());
         }
     }
-    
+
     private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOException {
         boolean turnRestrictionsImport = true;
         boolean is3D = false;
@@ -89,7 +89,7 @@ private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOExcep
         checkSimpleNodeNetwork(graph);
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
-                carOutExplorer = graph.createEdgeExplorer(carOutFilter);
+        carOutExplorer = graph.createEdgeExplorer(carOutFilter);
 
         GHUtility.printInfo(graph, 0, 20, carOutFilter);
         int n80 = AbstractGraphStorageTester.getIdOf(graph, node0Lat, node0Lon);
@@ -103,7 +103,7 @@ private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOExcep
         int edge19_81_83 = getEdge(n81, n83);
         int edge20_81_84 = getEdge(n81, n84);
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         // Check that 17 to 19 is restricted (high cost)
         long turnCostFlags = tcStorage.getTurnCostFlags(n81, edge17_80_81, edge19_81_83);
@@ -112,7 +112,7 @@ private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOExcep
 
         // We don't care about whether 17 to 20 is restricted (high cost) but it won't be in this example
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge17_80_81, edge20_81_84)));
-        
+
         // We don't care about whether 17 to 18 is restricted (high cost)
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge17_80_81, edge18_81_82)));
 
@@ -130,7 +130,7 @@ private void runNoMotorVehicleTurnFrom17To19Test(String filename) throws IOExcep
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge18_81_82)));
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge19_81_83)));
     }
-    
+
     private void runNonNoMotorVehicleTurnFrom17To19Test(String filename) throws IOException {
         boolean turnRestrictionsImport = true;
         boolean is3D = false;
@@ -142,7 +142,7 @@ private void runNonNoMotorVehicleTurnFrom17To19Test(String filename) throws IOEx
         checkSimpleNodeNetwork(graph);
 
         DefaultEdgeFilter carOutFilter = new DefaultEdgeFilter(carEncoder, false, true);
-                carOutExplorer = graph.createEdgeExplorer(carOutFilter);
+        carOutExplorer = graph.createEdgeExplorer(carOutFilter);
 
         GHUtility.printInfo(graph, 0, 20, carOutFilter);
         int n80 = AbstractGraphStorageTester.getIdOf(graph, node0Lat, node0Lon);
@@ -156,7 +156,7 @@ private void runNonNoMotorVehicleTurnFrom17To19Test(String filename) throws IOEx
         int edge19_81_83 = getEdge(n81, n83);
         int edge20_81_84 = getEdge(n81, n84);
 
-        TurnCostStorage tcStorage = (TurnCostStorage) ((GraphHopperStorage) graph).getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         // Check that there is no restriction from 17 to 19 (our Non No turn)
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge17_80_81, edge19_81_83)));
@@ -164,7 +164,7 @@ private void runNonNoMotorVehicleTurnFrom17To19Test(String filename) throws IOEx
         // Check that 17 to 20 is NOT restricted
         long turnCostFlags = tcStorage.getTurnCostFlags(n81, edge17_80_81, edge20_81_84);
         assertFalse(carEncoder.isTurnRestricted(turnCostFlags));
-        
+
         // Check that 17 to 18 is NOT restricted
         turnCostFlags = tcStorage.getTurnCostFlags(n81, edge17_80_81, edge18_81_82);
         assertFalse(carEncoder.isTurnRestricted(turnCostFlags));
@@ -183,5 +183,5 @@ private void runNonNoMotorVehicleTurnFrom17To19Test(String filename) throws IOEx
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge18_81_82)));
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n81, edge20_81_84, edge19_81_83)));
     }
-    
+
 }
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/OsItnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/OsItnReaderTest.java
index a8d2c021a6..8e4ba53e59 100755
--- a/core/src/test/java/com/graphhopper/reader/osgb/OsItnReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/OsItnReaderTest.java
@@ -35,7 +35,7 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.AbstractGraphStorageTester;
 import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.GHUtility;
@@ -164,8 +164,8 @@ public void testReadItnNoEntryMultipointCrossroad() throws IOException {
 
         assertEquals(2, count(explorer.setBaseNode(2)));
         assertEquals(1, count(explorer.setBaseNode(3))); // No Entry part way
-                                                         // down one crossroad
-                                                         // branch
+        // down one crossroad
+        // branch
 
         // Assert that this is true
         iter = explorer.setBaseNode(0);
@@ -212,7 +212,7 @@ public void testReadItnNoEntryMultipointCrossroad() throws IOException {
         assertFalse(iter.next());
     }
 
- 
+
     @Test
     public void testReadSimpleCrossRoads() throws IOException {
         final boolean turnRestrictionsImport = false;
@@ -261,7 +261,7 @@ public void testReadSimpleCrossRoadsWithTurnRestriction() throws IOException {
         final int edge1_3 = getEdge(n1, n3);
         final int edge1_4 = getEdge(n1, n4);
 
-        final TurnCostStorage tcStorage = (TurnCostStorage) graph.getExtendedStorage();
+        TurnCostExtension tcStorage = (TurnCostExtension)graph.getExtension();
 
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n1, edge0_1, edge1_2)));
         assertFalse(carEncoder.isTurnRestricted(tcStorage.getTurnCostFlags(n1, edge1_2, edge0_1)));
diff --git a/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java b/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
index 77b7093596..7e28296ba4 100644
--- a/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/osgb/dpn/AbstractOsDpnReaderTest.java
@@ -11,16 +11,14 @@
 import com.graphhopper.routing.util.AbstractFlagEncoder;
 import com.graphhopper.routing.util.BikeFlagEncoder;
 import com.graphhopper.routing.util.BusFlagEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.FootFlagEncoder;
-import com.graphhopper.storage.ExtendedStorage;
+import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 
@@ -74,7 +72,7 @@ public void initEncoding() {
 
     /**
      * So we can create a specific encoding manager in subclasses
-     * 
+     *
      * @return
      */
     protected EncodingManager createEncodingManager() {
@@ -94,8 +92,7 @@ protected OsDpnReader readGraphFile(GraphHopperStorage graph, File file)
     protected GraphHopperStorage configureStorage(
             boolean turnRestrictionsImport, boolean is3D) {
         String directory = "/tmp";
-        ExtendedStorage extendedStorage = turnRestrictionsImport ? new TurnCostStorage()
-                : new ExtendedStorage.NoExtendedStorage();
+        GraphExtension extendedStorage = turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoExtendedStorage();
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(
                 directory, false), encodingManager, is3D, extendedStorage);
         return graph;
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index 5a584597da..ea30e4233c 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -24,11 +24,7 @@
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import com.graphhopper.routing.util.AlgorithmPreparation;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
 import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.storage.Graph;
 
 /**
@@ -41,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
@@ -61,15 +57,15 @@ public AStarBidirectionTest( TraversalMode tMode )
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph g, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new AStarBidirection(_graph, encoder, w, traversalMode);
+                return new AStarBidirection(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(g);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 7ad145aee5..92c5a2b0a7 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -36,7 +36,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
@@ -56,15 +56,15 @@ public AStarTest( TraversalMode tMode )
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph g, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new AStar(_graph, encoder, w, traversalMode);
+                return new AStar(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(g);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index b3209ded80..5b09bd3268 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -21,12 +21,12 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
-import com.graphhopper.storage.index.LocationIndexTreeSC;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import java.util.Random;
 import static org.junit.Assert.*;
+import org.junit.Before;
 import org.junit.Test;
 
 /**
@@ -38,8 +38,18 @@
     // problem is: matrix graph is expensive to create to cache it in a static variable
     private static Graph matrixGraph;
     protected static final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
-    protected FlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
-    protected FlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+    protected FlagEncoder carEncoder;
+    protected FlagEncoder footEncoder;
+    protected AlgorithmOptions defaultOpts;
+
+    @Before
+    public void setUp()
+    {
+        carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
+        footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
+        defaultOpts = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new ShortestWeighting()).build();
+    }
 
     protected Graph createGraph( EncodingManager em, boolean is3D )
     {
@@ -51,20 +61,38 @@ protected Graph createGraph( boolean is3D )
         return createGraph(encodingManager, is3D);
     }
 
-    public AlgorithmPreparation prepareGraph( Graph g )
+    public RoutingAlgorithm createAlgo( Graph g )
+    {
+        return createAlgo(g, defaultOpts);
+    }
+
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     {
-        return prepareGraph(g, carEncoder, new ShortestWeighting());
+        return createFactory(g, opts).createAlgo(g, opts);
     }
 
-    public abstract AlgorithmPreparation prepareGraph( Graph g, FlagEncoder encoder, Weighting w );
+    public abstract RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts );
 
     @Test
     public void testCalcShortestPath()
     {
         Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 7);
-        assertEquals(p.toString(), 13, p.getDistance(), 1e-4);
-        assertEquals(p.toString(), Helper.createTList(0, 4, 6, 5, 7), p.calcNodes());
+        RoutingAlgorithm algo = createAlgo(graph);
+        Path p = algo.calcPath(0, 7);
+        assertEquals(p.toString(), Helper.createTList(0, 4, 5, 7), p.calcNodes());
+        assertEquals(p.toString(), 62.1, p.getDistance(), .1);
+    }
+
+    @Test
+    public void testCalcShortestPathWithLimit()
+    {
+        Graph graph = createTestGraph();
+        RoutingAlgorithm algo = createAlgo(graph);
+        algo.setWeightLimit(10);
+        Path p = algo.calcPath(0, 7);
+        assertTrue(algo.getVisitedNodes() < 7);
+        assertFalse(p.isFound());
+        assertEquals(p.toString(), Helper.createTList(), p.calcNodes());
     }
 
     // see calc-fastest-graph.svg
@@ -72,15 +100,17 @@ public void testCalcShortestPath()
     public void testCalcFastestPath()
     {
         Graph graphShortest = createGraph(false);
-        initDirectedAndDiffSpeed(graphShortest);
-        Path p1 = prepareGraph(graphShortest, carEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 3);
+        initDirectedAndDiffSpeed(graphShortest, carEncoder);
+        Path p1 = createAlgo(graphShortest, defaultOpts).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 144823, p1.getMillis());
 
         Graph graphFastest = createGraph(false);
-        initDirectedAndDiffSpeed(graphFastest);
-        Path p2 = prepareGraph(graphFastest, carEncoder, new FastestWeighting(carEncoder)).createAlgo().calcPath(0, 3);
+        initDirectedAndDiffSpeed(graphFastest, carEncoder);
+        Path p2 = createAlgo(graphFastest,
+                AlgorithmOptions.start().flagEncoder(carEncoder).weighting(new FastestWeighting(carEncoder)).build()).
+                calcPath(0, 3);
         assertEquals(Helper.createTList(0, 4, 6, 7, 5, 3), p2.calcNodes());
         assertEquals(p2.toString(), 1261.714, p2.getDistance(), 1e-6);
         assertEquals(p2.toString(), 111437, p2.getMillis());
@@ -91,28 +121,28 @@ public void testCalcFastestPath()
     // 4-5-- |
     // |/ \--7
     // 6----/
-    void initDirectedAndDiffSpeed( Graph graph )
+    protected void initDirectedAndDiffSpeed( Graph graph, FlagEncoder enc )
     {
-        graph.edge(0, 1).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
+        graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(1, 4).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setFlags(carEncoder.setProperties(10, true, true));
-        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(carEncoder.setProperties(10, true, true));
+        graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
+        graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
+        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
 
-        graph.edge(5, 2).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
+        graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
 
-        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setFlags(carEncoder.setProperties(10, true, false));
+        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
+        graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(4, 6).setFlags(carEncoder.setProperties(100, true, false));
-        graph.edge(5, 4).setFlags(carEncoder.setProperties(10, true, false));
+        graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
+        graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
 
-        graph.edge(5, 6).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setFlags(carEncoder.setProperties(100, true, false));
+        graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
+        graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
 
-        graph.edge(6, 7).setFlags(carEncoder.setProperties(100, true, true));
+        graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
 
         updateDistancesFor(graph, 0, 0.002, 0);
         updateDistancesFor(graph, 1, 0.002, 0.001);
@@ -132,13 +162,15 @@ public void testCalcFootPath()
     {
         Graph graphShortest = createGraph(false);
         initFootVsCar(graphShortest);
-        Path p1 = prepareGraph(graphShortest, footEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 7);
+        Path p1 = createAlgo(graphShortest, AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new ShortestWeighting()).build()).
+                calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getMillis());
         assertEquals(Helper.createTList(0, 4, 5, 7), p1.calcNodes());
     }
 
-    void initFootVsCar( Graph graph )
+    protected void initFootVsCar( Graph graph )
     {
         graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
         graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
@@ -186,24 +218,26 @@ protected Graph createTestGraph()
         graph.edge(5, 6, 2, true);
         graph.edge(5, 7, 1, true);
 
-        graph.edge(6, 7, 5, true);
-        return graph;
-    }
+        EdgeIteratorState edge6_7 = graph.edge(6, 7, 5, true);
 
-    @Test
-    public void testCalcIfEmptyWay()
-    {
-        Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 0);
-        assertEquals(p.calcNodes().toString(), 0, p.calcNodes().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        updateDistancesFor(graph, 0, 0.0010, 0.00001);
+        updateDistancesFor(graph, 1, 0.0008, 0.0000);
+        updateDistancesFor(graph, 2, 0.0005, 0.0001);
+        updateDistancesFor(graph, 3, 0.0006, 0.0002);
+        updateDistancesFor(graph, 4, 0.0009, 0.0001);
+        updateDistancesFor(graph, 5, 0.0007, 0.0001);
+        updateDistancesFor(graph, 6, 0.0009, 0.0002);
+        updateDistancesFor(graph, 7, 0.0008, 0.0003);
+
+        edge6_7.setDistance(5 * edge6_7.getDistance());
+        return graph;
     }
 
     @Test
     public void testNoPathFound()
     {
         Graph graph = createGraph(false);
-        assertFalse(prepareGraph(graph).createAlgo().calcPath(0, 1).isFound());
+        assertFalse(createAlgo(graph).calcPath(0, 1).isFound());
 
         // two disconnected areas
         graph.edge(0, 1, 7, true);
@@ -212,23 +246,22 @@ public void testNoPathFound()
         graph.edge(5, 7, 1, true);
         graph.edge(5, 8, 1, true);
         graph.edge(7, 8, 1, true);
-        RoutingAlgorithm algo = prepareGraph(graph).createAlgo();
+        RoutingAlgorithm algo = createAlgo(graph);
         assertFalse(algo.calcPath(0, 5).isFound());
-        // assertEquals(4, algo.getVisitedNodes());
+        // assertEquals(3, algo.getVisitedNodes());
 
         // disconnected as directed graph
         graph = createGraph(false);
         graph.edge(0, 1, 1, false);
         graph.edge(0, 2, 1, true);
-        algo = prepareGraph(graph).createAlgo();
-        assertFalse(algo.calcPath(1, 2).isFound());
+        assertFalse(createAlgo(graph).calcPath(1, 2).isFound());
     }
 
     @Test
     public void testWikipediaShortestPath()
     {
         Graph graph = createWikipediaTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 4, p.calcNodes().size());
     }
@@ -237,9 +270,9 @@ public void testWikipediaShortestPath()
     public void testCalcIf1EdgeAway()
     {
         Graph graph = createTestGraph();
-        Path p = prepareGraph(graph).createAlgo().calcPath(1, 2);
+        Path p = createAlgo(graph).calcPath(1, 2);
         assertEquals(Helper.createTList(1, 2), p.calcNodes());
-        assertEquals(p.toString(), 2, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
     // see wikipedia-graph.svg !
@@ -263,7 +296,7 @@ protected Graph createWikipediaTestGraph()
     // |    8  |
     // \   /   |
     //  7-6----5
-    public static void initBiGraph( Graph graph )
+    public static Graph initBiGraph( Graph graph )
     {
         // distance will be overwritten in second step as we need to calculate it from lat,lon
         graph.edge(0, 1, 1, true);
@@ -290,6 +323,7 @@ public static void initBiGraph( Graph graph )
         updateDistancesFor(graph, 7, 0, 0);
         updateDistancesFor(graph, 6, 0, 0.001);
         updateDistancesFor(graph, 5, 0, 0.004);
+        return graph;
     }
 
     private static final DistanceCalc distCalc = new DistanceCalcEarth();
@@ -305,6 +339,7 @@ public static void updateDistancesFor( Graph g, int node, double lat, double lon
             double adjLat = na.getLatitude(adj);
             double adjLon = na.getLongitude(adj);
             iter.setDistance(distCalc.calcDist(lat, lon, adjLat, adjLon));
+            // System.out.println(node + "->" + adj + ": " + iter.getDistance());
         }
     }
 
@@ -315,12 +350,12 @@ public void testBidirectional()
         initBiGraph(graph);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
         assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 4), p.calcNodes());
         assertEquals(p.toString(), 335.77, p.getDistance(), 1e-2);
 
-        p = prepareGraph(graph).createAlgo().calcPath(1, 2);
+        p = createAlgo(graph).calcPath(1, 2);
         // the other way around is even larger as 0-1 is already 11008.452
         assertEquals(p.toString(), Helper.createTList(1, 2), p.calcNodes());
         assertEquals(p.toString(), 10007.679, p.getDistance(), 1e-4);
@@ -347,7 +382,7 @@ public void testBidirectional2()
         graph.edge(3, 8, 20, true);
         graph.edge(8, 6, 20, true);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 4);
+        Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 40, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 5, p.calcNodes().size());
         assertEquals(Helper.createTList(0, 7, 6, 5, 4), p.calcNodes());
@@ -357,7 +392,7 @@ public void testBidirectional2()
     public void testRekeyBugOfIntBinHeap()
     {
         // using Dijkstra + IntBinHeap then rekey loops endlessly
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(36, 91);
+        Path p = createAlgo(getMatrixGraph()).calcPath(36, 91);
         assertEquals(12, p.calcNodes().size());
 
         TIntList list = p.calcNodes();
@@ -372,7 +407,7 @@ public void testRekeyBugOfIntBinHeap()
     @Test
     public void testBug1()
     {
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(34, 36);
+        Path p = createAlgo(getMatrixGraph()).calcPath(34, 36);
         assertEquals(Helper.createTList(34, 35, 36), p.calcNodes());
         assertEquals(3, p.calcNodes().size());
         assertEquals(17, p.getDistance(), 1e-5);
@@ -381,7 +416,7 @@ public void testBug1()
     @Test
     public void testCorrectWeight()
     {
-        Path p = prepareGraph(getMatrixGraph()).createAlgo().calcPath(45, 72);
+        Path p = createAlgo(getMatrixGraph()).calcPath(45, 72);
         assertEquals(Helper.createTList(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
         assertEquals(38f, p.getDistance(), 1e-3);
     }
@@ -393,7 +428,7 @@ public void testCannotCalculateSP()
         graph.edge(0, 1, 1, false);
         graph.edge(1, 2, 1, false);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 2);
+        Path p = createAlgo(graph).calcPath(0, 2);
         assertEquals(p.toString(), 3, p.calcNodes().size());
     }
 
@@ -408,7 +443,7 @@ public void testDirectedGraphBug1()
         graph.edge(3, 4, 3, false);
         graph.edge(4, 2, 1, false);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 2);
+        Path p = createAlgo(graph).calcPath(0, 2);
         assertEquals(Helper.createTList(0, 1, 2), p.calcNodes());
         assertEquals(p.toString(), 5.99, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 3, p.calcNodes().size());
@@ -424,7 +459,7 @@ public void testDirectedGraphBug2()
 
         graph.edge(3, 1, 4, true);
 
-        Path p = prepareGraph(graph).createAlgo().calcPath(0, 3);
+        Path p = createAlgo(graph).calcPath(0, 3);
         assertEquals(Helper.createTList(0, 1, 2, 3), p.calcNodes());
     }
 
@@ -452,45 +487,69 @@ public void testWithCoordinates()
         graph.edge(1, 3, 1.3, true);
         graph.edge(1, 4, 1, true);
 
-        AlgorithmPreparation prepare = prepareGraph(graph);
-        Path p = prepare.createAlgo().calcPath(4, 0);
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, new ShortestWeighting());
+        RoutingAlgorithmFactory prepare = createFactory(graph, opts);
+        Path p = prepare.createAlgo(graph, opts).calcPath(4, 0);
         assertEquals(Helper.createTList(4, 1, 0), p.calcNodes());
         assertEquals(Helper.createPointList(0.5, 4.5, 0, 3.5, 0, 3, 0, 2), p.calcPoints());
         assertEquals(291110, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
         // PrepareTowerNodesShortcutsTest.printEdges((LevelGraph) graph);
-        p = prepare.createAlgo().calcPath(2, 1);
+        p = prepare.createAlgo(graph, opts).calcPath(2, 1);
         // System.out.println(p.toDetailsString());
         assertEquals(Helper.createTList(2, 0, 1), p.calcNodes());
         assertEquals(Helper.createPointList(1, 1, 1, 0, 0, 0, 0, 1.6, 0, 2, 0, 3, 0, 3.5), p.calcPoints());
         assertEquals(611555, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
     }
 
+    @Test
+    public void testCalcIfEmptyWay()
+    {
+        Graph graph = createTestGraph();
+        Path p = createAlgo(graph).calcPath(0, 0);
+        assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+    }
+
+    @Test
+    public void testViaEdges_FromEqualsTo()
+    {
+        Graph graph = createTestGraph();
+        // identical tower nodes
+        Path p = calcPathViaQuery(graph, 0.001, 0.000, 0.001, 0.000);
+        assertTrue(p.isFound());
+        assertEquals(Helper.createTList(0), p.calcNodes());
+        // assertEquals(1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+        // identical query points on edge
+        p = calcPath(graph, 0, 1, 0, 1);
+        assertTrue(p.isFound());
+        assertEquals(Helper.createTList(8), p.calcNodes());
+        // assertEquals(1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+
+        // very close
+        p = calcPathViaQuery(graph, 0.00092, 0, 0.00091, 0);
+        assertEquals(Helper.createTList(8, 9), p.calcNodes());
+        assertEquals(p.toString(), 1.11, p.getDistance(), .1);
+    }
+
     @Test
     public void testViaEdges_BiGraph()
     {
         Graph graph = createGraph(false);
         initBiGraph(graph);
 
-        // 0-7 to 4-3
+        // 0-7 to 4-3        
         Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
         assertEquals(p.toString(), Helper.createTList(10, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 324.11, p.getDistance(), 1e-2);
+        assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
 
         // 0-1 to 2-3
         p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
-        assertEquals(p.toString(), Helper.createTList(10, 0, 7, 6, 8, 3, 9), p.calcNodes());
-        assertEquals(p.toString(), 1335.42, p.getDistance(), .2);
-    }
-
-    @Test
-    public void testViaEdges_FromEqualsTo()
-    {
-        Graph graph = createTestGraph();
-        Path p = calcPath(graph, 0, 1, 0, 1);
-        // or one node would be acceptable
-        assertEquals(Helper.createTList(8, 9), p.calcNodes());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), Helper.createTList(0, 7, 6, 8, 3, 9), p.calcNodes());
+        assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
     }
 
     @Test
@@ -499,7 +558,7 @@ public void testViaEdges_WithCoordinates()
         Graph graph = createTestGraph();
         Path p = calcPath(graph, 0, 1, 2, 3);
         assertEquals(Helper.createTList(9, 1, 2, 8), p.calcNodes());
-        assertEquals(p.toString(), 2, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 56.7, p.getDistance(), .1);
     }
 
     @Test
@@ -527,9 +586,9 @@ public void testViaEdges_SpecialCases()
         assertEquals(p.toString(), 26.81, p.getDistance(), .1);
 
         // overlapping edges: 2-3 and 3-2
-        p = calcPathViaQuery(graph, 0.000049, 0.00015, 0.00001, 0.0001);
+        p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
         assertEquals(Helper.createTList(5, 6), p.calcNodes());
-        assertEquals(p.toString(), 7, p.getDistance(), .1);
+        assertEquals(p.toString(), 6.2, p.getDistance(), .1);
 
         // 'from' and 'to' edge share one node '2': 1-2 to 3-2
         p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
@@ -541,7 +600,7 @@ public void testViaEdges_SpecialCases()
     public void testQueryGraphAndFastest()
     {
         Graph graph = createGraph(false);
-        initDirectedAndDiffSpeed(graph);
+        initDirectedAndDiffSpeed(graph, carEncoder);
         Path p = calcPathViaQuery("fastest", graph, 0.002, 0.0005, 0.0017, 0.0031);
         assertEquals(Helper.createTList(9, 1, 5, 3, 8), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
@@ -555,19 +614,20 @@ Path calcPathViaQuery( Graph graph, double fromLat, double fromLon, double toLat
 
     Path calcPathViaQuery( String weighting, Graph graph, double fromLat, double fromLon, double toLat, double toLon )
     {
-        LocationIndex index;
-        if (graph instanceof LevelGraph)
-            index = new LocationIndexTreeSC((LevelGraph) graph, new RAMDirectory());
-        else
-            index = new LocationIndexTree(graph, new RAMDirectory());
-
+        LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory());
         index.prepareIndex();
         QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
         QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
         Weighting w = new ShortestWeighting();
         if (weighting.equalsIgnoreCase("fastest"))
             w = new FastestWeighting(carEncoder);
-        return prepareGraph(graph, carEncoder, w).createAlgo().calcPath(from, to);
+
+        // correct order for CH: in factory do prepare and afterwards wrap in query graph
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(w).build();
+        RoutingAlgorithmFactory factory = createFactory(graph, opts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        return factory.createAlgo(qGraph, opts).
+                calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
     Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNode2 )
@@ -575,7 +635,10 @@ Path calcPath( Graph graph, int fromNode1, int fromNode2, int toNode1, int toNod
         // lookup two edges: fromNode1-fromNode2 and toNode1-toNode2        
         QueryResult from = newQR(graph, fromNode1, fromNode2);
         QueryResult to = newQR(graph, toNode1, toNode2);
-        return prepareGraph(graph).createAlgo().calcPath(from, to);
+
+        RoutingAlgorithmFactory factory = createFactory(graph, defaultOpts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        return factory.createAlgo(qGraph, defaultOpts).calcPath(from.getClosestNode(), to.getClosestNode());
     }
 
     /**
@@ -612,12 +675,31 @@ public void testTwoWeightsPerEdge()
 
         // for two weights per edge it happened that Path (and also the Weighting) read the wrong side 
         // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
-        Path p = prepareGraph(graph, encoder, new FastestWeighting(encoder)).
-                createAlgo().calcPath(0, 10);
+        Path p = createAlgo(graph, AlgorithmOptions.start().flagEncoder(encoder).weighting(new FastestWeighting(encoder)).build()).calcPath(0, 10);
 //        assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(85124371, p.getMillis());
         assertEquals(425622, p.getDistance(), 1);
-        assertEquals(6568, p.getWeight(), 1);
+        assertEquals(85124.4, p.getWeight(), 1);
+    }
+
+    @Test
+    public void test0SpeedButUnblocked_Issue242()
+    {
+        Graph graph = createGraph(false);
+        long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
+
+        graph.edge(0, 1).setFlags(flags).setDistance(10);
+        graph.edge(1, 2).setFlags(flags).setDistance(10);
+
+        RoutingAlgorithm algo = createAlgo(graph);
+        try
+        {
+            Path p = algo.calcPath(0, 2);
+            assertTrue(false);
+        } catch (Exception ex)
+        {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Speed cannot be 0"));
+        }
     }
 
     @Test
@@ -625,7 +707,7 @@ public void testTwoWeightsPerEdge2()
     {
         // other direction should be different!
         Graph graph = initEleGraph(createGraph(true));
-        Path p = prepareGraph(graph, carEncoder, new ShortestWeighting()).createAlgo().calcPath(0, 10);
+        Path p = createAlgo(graph).calcPath(0, 10);
         // GHUtility.printEdgeInfo(graph, carEncoder);
         assertEquals(Helper.createTList(0, 4, 6, 10), p.calcNodes());
         Weighting fakeWeighting = new Weighting()
@@ -663,7 +745,11 @@ else if (adj == 4)
         graph = initEleGraph(createGraph(true));
         QueryResult from = newQR(graph, 3, 0);
         QueryResult to = newQR(graph, 10, 9);
-        p = prepareGraph(graph, carEncoder, fakeWeighting).createAlgo().calcPath(from, to);
+
+        AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(fakeWeighting).build();
+        RoutingAlgorithmFactory factory = createFactory(graph, opts);
+        QueryGraph qGraph = new QueryGraph(graph).lookup(from, to);
+        p = factory.createAlgo(qGraph, opts).calcPath(from.getClosestNode(), to.getClosestNode());
         assertEquals(Helper.createTList(13, 0, 1, 2, 11, 7, 10, 12), p.calcNodes());
         assertEquals(37009621, p.getMillis());
         assertEquals(616827, p.getDistance(), 1);
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index 91475c0a43..0f67d59627 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -37,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
@@ -57,15 +57,15 @@ public DijkstraBidirectionRefTest( TraversalMode tMode )
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new DijkstraBidirectionRef(_graph, encoder, w, traversalMode);
+                return new DijkstraBidirectionRef(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };    
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 73ea744950..3f156783dc 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -28,6 +28,7 @@
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 /**
  *
@@ -39,36 +40,38 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameterized.Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
         {
-            { TraversalMode.NODE_BASED },
+            {
+                TraversalMode.NODE_BASED
+            },
 //            TODO { TraversalMode.EDGE_BASED_1DIR },
 //            TODO { TraversalMode.EDGE_BASED_2DIR },
 //            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
         });
     }
 
-    private final TraversalMode traversalmode;
+    private final TraversalMode traversalMode;
 
     public DijkstraOneToManyTest( TraversalMode tMode )
     {
-        this.traversalmode = tMode;
+        this.traversalMode = tMode;
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting w )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new DijkstraOneToMany(_graph, encoder, w, traversalmode);
+                return new DijkstraOneToMany(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 
     @Override
@@ -110,8 +113,7 @@ public void testTwoWeightsPerEdge2()
     @Test
     public void testIssue182()
     {
-        AlgorithmPreparation prep = prepareGraph(initGraph(createGraph(false)));
-        RoutingAlgorithm algo = prep.createAlgo();
+        RoutingAlgorithm algo = createAlgo(initGraph(createGraph(false)));
         Path p = algo.calcPath(0, 8);
         assertEquals(Helper.createTList(0, 7, 8), p.calcNodes());
 
@@ -132,8 +134,7 @@ public void testIssue239()
         g.edge(5, 6, 1, true);
         g.edge(6, 4, 1, true);
 
-        AlgorithmPreparation prep = prepareGraph(g);
-        DijkstraOneToMany algo = (DijkstraOneToMany) prep.createAlgo();
+        DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
         assertEquals(-1, algo.findEndNode(0, 4));
         assertEquals(-1, algo.findEndNode(0, 4));
     }
@@ -141,14 +142,13 @@ public void testIssue239()
     @Test
     public void testUseCache()
     {
-        AlgorithmPreparation prep = prepareGraph(createTestGraph());
-        RoutingAlgorithm algo = prep.createAlgo();
+        RoutingAlgorithm algo = createAlgo(createTestGraph());
         Path p = algo.calcPath(0, 4);
         assertEquals(Helper.createTList(0, 4), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 7);
-        assertEquals(Helper.createTList(0, 4, 6, 5, 7), p.calcNodes());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p.calcNodes());
 
         // use SPT
         p = algo.calcPath(0, 2);
@@ -165,8 +165,7 @@ public void testDifferentEdgeFilter()
         g.edge(4, 5, 10, true);
         g.edge(5, 6, 10, true);
 
-        AlgorithmPreparation prep = prepareGraph(g);
-        DijkstraOneToMany algo = (DijkstraOneToMany) prep.createAlgo();
+        DijkstraOneToMany algo = (DijkstraOneToMany) createAlgo(g);
         algo.setEdgeFilter(new EdgeFilter()
         {
             @Override
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index 7e42cdfa81..fb8c479901 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -37,7 +37,7 @@
     /**
      * Runs the same test with each of the supported traversal modes
      */
-    @Parameters
+    @Parameters(name = "{0}")
     public static Collection<Object[]> configs()
     {
         return Arrays.asList(new Object[][]
@@ -49,7 +49,7 @@
         });
     }
 
-    private TraversalMode traversalMode;
+    private final TraversalMode traversalMode;
 
     public DijkstraTest( TraversalMode tMode )
     {
@@ -57,15 +57,15 @@ public DijkstraTest( TraversalMode tMode )
     }
 
     @Override
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder, final Weighting weighting )
+    public RoutingAlgorithmFactory createFactory( Graph prepareGraph, AlgorithmOptions prepareOpts )
     {
-        return new NoOpAlgorithmPreparation()
+        return new RoutingAlgorithmFactory()
         {
             @Override
-            public RoutingAlgorithm createAlgo()
+            public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
             {
-                return new Dijkstra(_graph, encoder, weighting, traversalMode);
+                return new Dijkstra(g, opts.getFlagEncoder(), opts.getWeighting(), traversalMode);
             }
-        }.setGraph(defaultGraph);
+        };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index 2a08df8a6d..1bbc864885 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -22,7 +22,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.TurnCostStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import static org.junit.Assert.*;
@@ -57,12 +57,11 @@ EncodingManager createEncodingManager( boolean restrictedOnly )
     {
         return Arrays.asList(new Object[][]
         {
-            { "dijkstra" },
-            { "dijkstrabi" },
-            { "astar" },
-            { "astarbi" },
-            { "dijkstraNative" },
-        // TODO { "dijkstraOneToMany" }
+            { AlgorithmOptions.DIJKSTRA },
+            { AlgorithmOptions.DIJKSTRA_BI },
+            { AlgorithmOptions.ASTAR },
+            { AlgorithmOptions.ASTAR_BI }
+        // TODO { AlgorithmOptions.DIJKSTRA_ONE_TO_MANY }
         });
     }
 
@@ -73,10 +72,10 @@ public EdgeBasedRoutingAlgorithmTest( String algo )
         this.algoStr = algo;
     }
 
-    public AlgorithmPreparation prepareGraph( Graph defaultGraph, final FlagEncoder encoder,
-            final Weighting w, TraversalMode tMode )
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     {
-        return NoOpAlgorithmPreparation.createAlgoPrepare(defaultGraph, algoStr, encoder, w, tMode);
+        opts = AlgorithmOptions.start(opts).algorithm(algoStr).build();
+        return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
     }
 
     protected GraphStorage createGraph( EncodingManager em )
@@ -103,37 +102,37 @@ public static void initGraph( Graph g )
         g.edge(6, 7, 1, true);
     }
 
-    private void initTurnRestrictions( Graph g, TurnCostStorage tcs, TurnCostEncoder tEncoder )
+    private void initTurnRestrictions( Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder )
     {
         long tflags = tEncoder.getTurnFlags(true, 0);
 
         // only forward from 2-3 to 3-4 => limit 2,3->3,6 and 2,3->3,1
-        tcs.addTurnInfo(3, getEdge(g, 2, 3).getEdge(), getEdge(g, 3, 6).getEdge(), tflags);
-        tcs.addTurnInfo(3, getEdge(g, 2, 3).getEdge(), getEdge(g, 3, 1).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
 
         // only right   from 5-2 to 2-3 => limit 5,2->2,0
-        tcs.addTurnInfo(2, getEdge(g, 5, 2).getEdge(), getEdge(g, 2, 0).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 0).getEdge(), tflags);
 
         // only right   from 7-6 to 6-3 => limit 7,6->6,5
-        tcs.addTurnInfo(6, getEdge(g, 7, 6).getEdge(), getEdge(g, 6, 5).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
 
         // no 5-6 to 6-3
-        tcs.addTurnInfo(6, getEdge(g, 5, 6).getEdge(), getEdge(g, 6, 3).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 5, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
         // no 4-3 to 3-1
-        tcs.addTurnInfo(3, getEdge(g, 4, 3).getEdge(), getEdge(g, 3, 1).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
         // no 4-3 to 3-2
-        tcs.addTurnInfo(3, getEdge(g, 4, 3).getEdge(), getEdge(g, 3, 2).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), tflags);
 
         // no u-turn at 6-7
-        tcs.addTurnInfo(7, getEdge(g, 6, 7).getEdge(), getEdge(g, 7, 6).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 6, 7).getEdge(), 7, getEdge(g, 7, 6).getEdge(), tflags);
 
         // no u-turn at 3-6
-        tcs.addTurnInfo(6, getEdge(g, 3, 6).getEdge(), getEdge(g, 6, 3).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
     }
 
-    Weighting createWeighting( FlagEncoder encoder, TurnCostStorage tcs )
+    Weighting createWeighting( FlagEncoder encoder, TurnCostExtension tcs, double turnCosts )
     {
-        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs);
+        return new TurnWeighting(new FastestWeighting(encoder), encoder, tcs).setDefaultUTurnCost(turnCosts);
     }
 
     @Test
@@ -141,19 +140,28 @@ public void testBasicTurnRestriction()
     {
         GraphStorage g = createGraph(createEncodingManager(true));
         initGraph(g);
-        TurnCostStorage tcs = (TurnCostStorage) g.getExtendedStorage();
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
         initTurnRestrictions(g, tcs, carEncoder);
-        Path p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_2DIR).
-                createAlgo().calcPath(5, 1);
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
+                calcPath(5, 1);
         assertEquals(Helper.createTList(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
 
         // test 7-6-5 and reverse
-        p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_1DIR).
-                createAlgo().calcPath(5, 7);
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 7);
         assertEquals(Helper.createTList(5, 6, 7), p.calcNodes());
 
-        p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_1DIR).
-                createAlgo().calcPath(7, 5);
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(7, 5);
         assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
     }
 
@@ -162,27 +170,33 @@ public void testUTurns()
     {
         GraphStorage g = createGraph(createEncodingManager(true));
         initGraph(g);
-        TurnCostStorage tcs = (TurnCostStorage) g.getExtendedStorage();
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
 
         long tflags = carEncoder.getTurnFlags(true, 0);
 
         // force u-turn via lowering the cost for it
         EdgeIteratorState e3_6 = getEdge(g, 3, 6);
         e3_6.setDistance(0.1);
-        getEdge(g, 3, 2).setDistance(8642);
-        getEdge(g, 1, 0).setDistance(8642);
+        getEdge(g, 3, 2).setDistance(864);
+        getEdge(g, 1, 0).setDistance(864);
 
-        tcs.addTurnInfo(6, getEdge(g, 7, 6).getEdge(), getEdge(g, 6, 5).getEdge(), tflags);
-        tcs.addTurnInfo(3, getEdge(g, 4, 3).getEdge(), e3_6.getEdge(), tflags);
-        Path p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_2DIR_UTURN).
-                createAlgo().calcPath(7, 5);
+        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
+        AlgorithmOptions opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 50)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        Path p = createAlgo(g, opts).calcPath(7, 5);        
 
         assertEquals(Helper.createTList(7, 6, 3, 6, 5), p.calcNodes());
 
-        // no u-turn    from 6-3
-        tcs.addTurnInfo(3, getEdge(g, 6, 3).getEdge(), getEdge(g, 3, 6).getEdge(), tflags);
-        p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_2DIR_UTURN).
-                createAlgo().calcPath(7, 5);
+        // no u-turn for 6-3
+        opts = AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 100)).
+                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
+        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
+        p = createAlgo(g, opts).calcPath(7, 5);
 
         assertEquals(Helper.createTList(7, 6, 3, 2, 5), p.calcNodes());
     }
@@ -192,9 +206,12 @@ public void testBasicTurnCosts()
     {
         GraphStorage g = createGraph(createEncodingManager(false));
         initGraph(g);
-        TurnCostStorage tcs = (TurnCostStorage) g.getExtendedStorage();
-        Path p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_1DIR).
-                createAlgo().calcPath(5, 1);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        Path p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 1);
 
         // no restriction and costs
         EdgeIteratorState e3_6 = getEdge(g, 5, 6);
@@ -203,10 +220,13 @@ public void testBasicTurnCosts()
 
         // now introduce some turn costs
         long tflags = carEncoder.getTurnFlags(false, 2);
-        tcs.addTurnInfo(2, getEdge(g, 5, 2).getEdge(), getEdge(g, 2, 3).getEdge(), tflags);
+        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
 
-        p = prepareGraph(g, carEncoder, createWeighting(carEncoder, tcs), TraversalMode.EDGE_BASED_1DIR).
-                createAlgo().calcPath(5, 1);
+        p = createAlgo(g, AlgorithmOptions.start().
+                flagEncoder(carEncoder).
+                weighting(createWeighting(carEncoder, tcs, 40)).
+                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
+                calcPath(5, 1);
         assertEquals(Helper.createTList(5, 6, 3, 1), p.calcNodes());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java b/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
index 4b0abea3c1..22b886c9a8 100644
--- a/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
+++ b/core/src/test/java/com/graphhopper/routing/GraphHopperIT.java
@@ -28,48 +28,61 @@
 import java.io.File;
 import java.util.List;
 import java.util.Map;
-import org.junit.After;
-import org.junit.Test;
+import org.junit.*;
 import static org.junit.Assert.*;
-import org.junit.Before;
 
 /**
  * @author Peter Karich
  */
 public class GraphHopperIT
 {
-    String graphFile = "target/graph-GraphHopperIT";
-    String osmFile = "files/monaco.osm.gz";
-    String vehicle = "FOOT";
-    String importVehicles = "FOOT";
-    String weightCalcStr = "shortest";
+    private static GraphHopper hopper;
+    private static final String graphFileFoot = "target/graphhopperIT-foot";
+    private static final String osmFile = "files/monaco.osm.gz";
+    private static final String importVehicles = "FOOT";
+    private static final String vehicle = "FOOT";
+    private static final String weightCalcStr = "shortest";
+
+    private final String tmpGraphFile = "target/graphhopperIT-tmp";
 
     @Before
     public void setUp()
     {
-        // make sure we are using fresh graphhopper files with correct vehicle
-        Helper.removeDir(new File(graphFile));
+        Helper.removeDir(new File(tmpGraphFile));
     }
 
     @After
     public void tearDown()
     {
-        Helper.removeDir(new File(graphFile));
+        Helper.removeDir(new File(tmpGraphFile));
     }
 
-    @Test
-    public void testMonacoWithInstructions() throws Exception
+    @BeforeClass
+    public static void beforeClass()
     {
-        GraphHopper hopper = new GraphHopper().
+        // make sure we are using fresh graphhopper files with correct vehicle
+        Helper.removeDir(new File(graphFileFoot));
+
+        hopper = new GraphHopper().
                 setStoreOnFlush(true).
                 setOSMFile(osmFile).
                 setCHEnable(false).
-                setGraphHopperLocation(graphFile).
+                setGraphHopperLocation(graphFileFoot).
                 setEncodingManager(new EncodingManager(importVehicles)).
                 importOrLoad();
+    }
 
+    @AfterClass
+    public static void afterClass()
+    {
+        Helper.removeDir(new File(graphFileFoot));
+    }
+
+    @Test
+    public void testMonacoWithInstructions() throws Exception
+    {
         GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         assertEquals(3437.6, rsp.getDistance(), .1);
         assertEquals(89, rsp.getPoints().getSize());
@@ -106,21 +119,90 @@ public void testMonacoWithInstructions() throws Exception
         assertEquals(totalResponseMillis, lastEntryMillis);
     }
 
+    @Test
+    public void testMonacoVia()
+    {
+        GHResponse rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.74958, 7.436566)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+
+        assertEquals(6875.1, rsp.getDistance(), .1);
+        assertEquals(179, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(26, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
+        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
+        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
+        assertEquals("Turn left", resultJson.get(3).get("text"));
+        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+
+        assertEquals("Stopover 1", resultJson.get(12).get("text"));
+
+        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
+        assertEquals("Turn left", resultJson.get(21).get("text"));
+        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
+        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
+        assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
+        assertEquals("Finish!", resultJson.get(25).get("text"));
+
+        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
+        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
+        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
+        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
+        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
+        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+
+        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
+        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
+        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
+        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
+        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
+        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+
+        // special case of identical start and end point
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(1, rsp.getPoints().getSize());
+        assertEquals(1, rsp.getInstructions().size());
+        assertEquals("Finish!", rsp.getInstructions().createJson().get(0).get("text"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(0).get("sign"));
+
+        rsp = hopper.route(new GHRequest().
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                addPoint(new GHPoint(43.727687, 7.418737)).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
+        assertEquals(0, rsp.getDistance(), .1);
+        assertEquals(0, rsp.getRouteWeight(), .1);
+        assertEquals(2, rsp.getPoints().getSize());
+        assertEquals(2, rsp.getInstructions().size());
+        assertEquals(Instruction.REACHED_VIA, rsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals(Instruction.FINISH, rsp.getInstructions().createJson().get(1).get("sign"));
+    }
+
     @Test
     public void testSRTMWithInstructions() throws Exception
     {
-        GraphHopper hopper = new GraphHopper().
+        GraphHopper tmpHopper = new GraphHopper().
                 setStoreOnFlush(true).
                 setOSMFile(osmFile).
                 setCHEnable(false).
-                setGraphHopperLocation(graphFile).
+                setGraphHopperLocation(tmpGraphFile).
                 setEncodingManager(new EncodingManager(importVehicles));
 
-        hopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
-        hopper.importOrLoad();
+        tmpHopper.setElevationProvider(new SRTMProvider().setCacheDir(new File("./files/")));
+        tmpHopper.importOrLoad();
 
-        GHResponse rsp = hopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.730729, 7.421288, 43.727697, 7.419199).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
         assertEquals(1626.8, rsp.getDistance(), .1);
         assertEquals(60, rsp.getPoints().getSize());
@@ -160,110 +242,101 @@ public void testSRTMWithInstructions() throws Exception
     public void testKremsCyclewayInstructionsWithWayTypeInfo()
     {
         String tmpOsmFile = "files/krems.osm.gz";
-        String tmpGraphFile = "target/graph-krems";
         String tmpVehicle = "BIKE";
         String tmpImportVehicles = "CAR,BIKE";
         String tmpWeightCalcStr = "fastest";
 
-        try
-        {
-            // make sure we are using fresh graphhopper files with correct vehicle
-            Helper.removeDir(new File(tmpGraphFile));
-            GraphHopper hopper = new GraphHopper().
-                    setStoreOnFlush(true).
-                    setOSMFile(tmpOsmFile).
-                    setCHEnable(false).
-                    setGraphHopperLocation(tmpGraphFile).
-                    setEncodingManager(new EncodingManager(tmpImportVehicles)).
-                    importOrLoad();
-
-            GHResponse rsp = hopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
-                    setAlgorithm("astar").setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
-
-            assertEquals(6932.24, rsp.getDistance(), .1);
-            assertEquals(110, rsp.getPoints().getSize());
-
-            InstructionList il = rsp.getInstructions();
-            assertEquals(19, il.size());
-            List<Map<String, Object>> resultJson = il.createJson();
-
-            assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
-            assertEquals("get off the bike", resultJson.get(0).get("annotationText"));
-            assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
-            assertEquals("get off the bike", resultJson.get(1).get("annotationText"));
-
-            assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
-            assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
-            assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
-            assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
-            assertEquals("Turn slight left onto Untere Landstraße", resultJson.get(6).get("text"));
-            assertEquals("Turn right onto Ringstraße, L73", resultJson.get(7).get("text"));
-            assertEquals("Continue onto Eyblparkstraße", resultJson.get(8).get("text"));
-            assertEquals("Continue onto Austraße", resultJson.get(9).get("text"));
-            assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
-            //..
-            assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
-            assertEquals("cycleway", resultJson.get(15).get("annotationText"));
-
-        } catch (Exception ex)
-        {
-            throw new RuntimeException("cannot handle osm file " + tmpOsmFile, ex);
-        } finally
-        {
-            Helper.removeDir(new File(tmpGraphFile));
-        }
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
+                setAlgorithm(AlgorithmOptions.ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+
+        assertEquals(6932.24, rsp.getDistance(), .1);
+        assertEquals(110, rsp.getPoints().getSize());
+
+        InstructionList il = rsp.getInstructions();
+        assertEquals(19, il.size());
+        List<Map<String, Object>> resultJson = il.createJson();
+
+        assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
+        assertEquals("get off the bike", resultJson.get(0).get("annotationText"));
+        assertEquals("Turn sharp left onto Kirchengasse", resultJson.get(1).get("text"));
+        assertEquals("get off the bike", resultJson.get(1).get("annotationText"));
+
+        assertEquals("Turn sharp right onto Pfarrplatz", resultJson.get(2).get("text"));
+        assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
+        assertEquals("Turn left onto Hoher Markt", resultJson.get(4).get("text"));
+        assertEquals("Turn slight right onto Wegscheid", resultJson.get(5).get("text"));
+        assertEquals("Turn slight left onto Untere Landstraße", resultJson.get(6).get("text"));
+        assertEquals("Turn right onto Ringstraße, L73", resultJson.get(7).get("text"));
+        assertEquals("Continue onto Eyblparkstraße", resultJson.get(8).get("text"));
+        assertEquals("Continue onto Austraße", resultJson.get(9).get("text"));
+        assertEquals("Turn slight left onto Rechte Kremszeile", resultJson.get(10).get("text"));
+        //..
+        assertEquals("Turn right onto Treppelweg", resultJson.get(15).get("text"));
+        assertEquals("cycleway", resultJson.get(15).get("annotationText"));
     }
 
     @Test
-    public void testMonacoVia()
+    public void testRoundaboutInstructionsWithCH()
     {
-        GraphHopper hopper = new GraphHopper().
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpVehicle = "car";
+        String tmpImportVehicles = "foot,car";
+        String tmpWeightCalcStr = "fastest";
+
+        GraphHopper tmpHopper = new GraphHopper().
                 setStoreOnFlush(true).
-                setOSMFile(osmFile).
-                setCHEnable(false).
-                setGraphHopperLocation(graphFile).
-                setEncodingManager(new EncodingManager(importVehicles)).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
                 importOrLoad();
 
-        GHResponse rsp = hopper.route(new GHRequest().
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                addPoint(new GHPoint(43.74958, 7.436566)).
-                addPoint(new GHPoint(43.727687, 7.418737)).
-                setAlgorithm("astar").setVehicle(vehicle).setWeighting(weightCalcStr));
+        // lexicographically first vehicle
+        assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle());
+        assertFalse(RoutingAlgorithmFactorySimple.class.isAssignableFrom(tmpHopper.getAlgorithmFactory().getClass()));
 
-        assertEquals(6875.1, rsp.getDistance(), .1);
-        assertEquals(179, rsp.getPoints().getSize());
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.745084, 7.430513, 43.745247, 7.430347)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
 
-        InstructionList il = rsp.getInstructions();
-        assertEquals(26, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Turn slight left onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(2).get("text"));
-        assertEquals("Turn left", resultJson.get(3).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(4).get("text"));
+        rsp = tmpHopper.route(new GHRequest(43.745968, 7.42907, 43.745832, 7.428614)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
+        assertEquals(2, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
 
-        assertEquals("Stopover 1", resultJson.get(12).get("text"));
+        rsp = tmpHopper.route(new GHRequest(43.745948, 7.42914, 43.746173, 7.428834)
+                .setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
 
-        assertEquals("Continue onto Avenue Albert II", resultJson.get(20).get("text"));
-        assertEquals("Turn left", resultJson.get(21).get("text"));
-        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(22).get("text"));
-        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(23).get("text"));
-        assertEquals("Turn slight right onto Avenue des Guelfes", resultJson.get(24).get("text"));
-        assertEquals("Finish!", resultJson.get(25).get("text"));
+        assertEquals(1, ((RoundaboutInstruction) rsp.getInstructions().get(1)).getExitNumber());
+    }
 
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(289, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(43, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(122, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(447, (Double) resultJson.get(5).get("distance"), 1);
+    @Test
+    public void testMultipleVehiclesAndCH()
+    {
+        String tmpOsmFile = "files/monaco.osm.gz";
+        String tmpImportVehicles = "foot,car";
 
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(207, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(87, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(321, (Long) resultJson.get(5).get("time") / 1000);
+        GraphHopper tmpHopper = new GraphHopper().
+                setStoreOnFlush(true).
+                setOSMFile(tmpOsmFile).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                importOrLoad();
+
+        GHResponse rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("car"));
+        assertEquals(207, rsp.getMillis() / 1000f, 1);
+        assertEquals(2838, rsp.getDistance(), 1);        
+
+        rsp = tmpHopper.route(new GHRequest(43.73005, 7.415707, 43.741522, 7.42826)
+                .setVehicle("foot"));
+        assertEquals(1574, rsp.getMillis() / 1000f, 1);
+        assertEquals(2187, rsp.getDistance(), 1);        
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index adfe9ea1ec..a74897fb02 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -17,9 +17,7 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
@@ -28,9 +26,8 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+import java.util.*;
+
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -40,10 +37,11 @@
  */
 public class PathTest
 {
-    private final EncodingManager carManager = new EncodingManager("CAR");
-    private final FlagEncoder encoder = new EncodingManager("CAR").getEncoder("CAR");
+    private final FlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager carManager = new EncodingManager(encoder);
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
+    private final AngleCalc ac = new AngleCalc();
 
     @Test
     public void testFound()
@@ -141,7 +139,7 @@ public void testWayList()
         path.extract();
         // 2-1-0
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
-        
+
         instr = path.calcInstructions(tr);
         res = instr.createJson();
         tmp = res.get(0);
@@ -192,16 +190,186 @@ public void testFindInstruction()
         path.setEdgeEntry(e1);
         path.extract();
 
-        path.calcInstructions(tr);
-        Instruction nextInstr1 = path.findInstruction(0.0, 0.1);
-        Instruction nextInstr2 = path.findInstruction(5.0, 0.4);
-        Instruction nextInstr3 = path.findInstruction(9.0, 0.53);
-        Instruction nextInstr4 = path.findInstruction(7.8, 0.25);
-
+        InstructionList il = path.calcInstructions(tr);
+        Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
+        assertEquals(Instruction.CONTINUE_ON_STREET, nextInstr0.getSign());
+        
+        Instruction nextInstr1 = il.find(0.001, 0.001, 1000);
         assertEquals(Instruction.TURN_RIGHT, nextInstr1.getSign());
+
+        Instruction nextInstr2 = il.find(5.0, 0.004, 1000);
         assertEquals(Instruction.TURN_LEFT, nextInstr2.getSign());
+
+        Instruction nextInstr3 = il.find(9.99, 0.503, 1000);
         assertEquals(Instruction.TURN_SHARP_LEFT, nextInstr3.getSign());
+
+        // a bit far away ...
+        Instruction nextInstr4 = il.find(7.40, 0.25, 20000);
         assertEquals(Instruction.FINISH, nextInstr4.getSign());
+
+        // too far away
+        assertNull(il.find(50.8, 50.25, 1000));
+    }
+
+    private class RoundaboutGraph
+    {
+        public EdgeIteratorState edge2change;
+        boolean clockwise;
+        final public Graph g = new GraphBuilder(carManager).create();
+        final public NodeAccess na = g.getNodeAccess();
+
+        private RoundaboutGraph(boolean clockwise)
+        {
+            //
+            //      8
+            //       \
+            //         5
+            //       /  \
+            //  1 - 2    4 - 7
+            //       \  /
+            //        3
+            //        |
+            //        6
+
+            na.setNode(1, 52.514, 13.348);
+            na.setNode(2, 52.514, 13.349);
+            na.setNode(3, 52.5135,13.35);
+            na.setNode(4, 52.514, 13.351);
+            na.setNode(5, 52.5145,13.351);
+            na.setNode(6, 52.513, 13.351);
+            na.setNode(7, 52.514, 13.352);
+            na.setNode(8, 52.515, 13.351);
+
+            EdgeIteratorState tmpEdge;
+            tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+            tmpEdge = clockwise? g.edge(3, 2, 5, false).setName("2-3") : g.edge(2, 3, 5, false).setName("2-3");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(4, 3, 5, false).setName("3-4") : g.edge(3, 4, 5, false).setName("3-4");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(5, 4, 5, false).setName("4-5") : g.edge(4, 5, 5, false).setName("4-5");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = clockwise? g.edge(2, 5, 5, false).setName("5-2") : g.edge(5, 2, 5, false).setName("5-2");
+            tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+            tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+            tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+            tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+            edge2change = tmpEdge.detach(false);
+            this.clockwise = clockwise;
+        }
+
+        private double getAngle(int n1, int n2, int n3, int n4)
+        {
+            double inOrientation = ac.calcOrientation(na.getLat(n1), na.getLon(n1), na.getLat(n2), na.getLon(n2));
+            double outOrientation = ac.calcOrientation(na.getLat(n3), na.getLon(n3), na.getLat(n4), na.getLon(n4));
+            outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+            double delta = (inOrientation - outOrientation);
+            delta = clockwise? (Math.PI+delta) : -1*(Math.PI - delta);
+            return delta;
+        }
+    }
+
+    @Test
+    public void testCalcInstructionsRoundabout()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        // Test instructions
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 3 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+
+        // case of continuing a street through a roundabout
+        p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+        wayList = p.calcInstructions(tr);
+        tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto MainStreet",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        delta = rg.getAngle(1, 2, 4, 7);
+        instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    /**
+     * case with one edge being not an exit
+     */
+    @Test
+    public void testCalcInstructionsRoundabout2()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, true));
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(2, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "At roundabout, take exit 3 onto 5-8",
+                                    "Finish!"),
+                tmpList);
+    }
+
+    /**
+     * case starting in Roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutBegin()
+    {
+        RoundaboutGraph rg = new RoundaboutGraph(false);
+        rg.edge2change.setFlags(encoder.setBool(rg.edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList("Continue onto MainStreet",
+                        "At roundabout, take exit 2 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+
+    /**
+     * clockwise roundabout
+     */
+    @Test
+    public void testCalcInstructionsRoundaboutClockwise()
+    {
+
+        RoundaboutGraph rg = new RoundaboutGraph(true);
+        System.out.println(rg.clockwise);
+
+        Path p = new Dijkstra(rg.g, encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                        "At roundabout, take exit 1 onto 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        double delta = rg.getAngle(1, 2, 5, 8);
+        RoundaboutInstruction instr = (RoundaboutInstruction) wayList.get(1);
+        assertEquals(delta, instr.getRadian(), 0.01);
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index f97d893b5c..9d2bc3acaa 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -17,15 +17,8 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import static com.graphhopper.storage.index.QueryResult.Position.*;
 import com.graphhopper.util.*;
@@ -43,12 +36,15 @@
  */
 public class QueryGraphTest
 {
-    private final EncodingManager encodingManager = new EncodingManager("CAR");
+    private EncodingManager encodingManager;
+    private FlagEncoder carEncoder;
     private GraphStorage g;
 
     @Before
     public void setUp()
     {
+        carEncoder = new CarFlagEncoder();
+        encodingManager = new EncodingManager(carEncoder);
         g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false).create(100);
     }
 
@@ -160,7 +156,7 @@ public void testFillVirtualEdges()
         {
 
             @Override
-            void fillVirtualEdges( TIntObjectMap<QueryGraph.VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
+            void fillVirtualEdges( TIntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode, EdgeExplorer mainExpl )
             {
                 super.fillVirtualEdges(node2Edge, towerNode, mainExpl);
                 // ignore nodes should include baseNode == 1
@@ -260,7 +256,7 @@ public void testVirtEdges()
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(0);
         iter.next();
 
-        QueryGraph.VirtualEdgeIterator vi = new QueryGraph.VirtualEdgeIterator(2);
+        VirtualEdgeIterator vi = new VirtualEdgeIterator(2);
         vi.add(iter.detach(false));
 
         assertTrue(vi.next());
@@ -313,7 +309,7 @@ public void testLoopStreet_Issue151()
 
         QueryResult qr = new QueryResult(-0.0005, 0.001);
         qr.setClosestEdge(edge);
-        qr.setWayIndex(0);
+        qr.setWayIndex(1);
         qr.calcSnappedPoint(new DistanceCalc2D());
 
         QueryGraph qg = new QueryGraph(g);
@@ -332,8 +328,7 @@ public void testOneWayLoop_Issue162()
         // | x
         // 0<-\
         // |
-        // 1
-        FlagEncoder carEncoder = encodingManager.getSingle();
+        // 1        
         NodeAccess na = g.getNodeAccess();
         na.setNode(0, 0, 0);
         na.setNode(1, 0, -0.001);
@@ -381,6 +376,35 @@ public void testEdgesShareOneNode()
         assertNotNull(GHUtility.getEdge(queryGraph, 0, 3));
     }
 
+    @Test
+    public void testAvoidDuplicateVirtualNodesIfIdentical()
+    {
+        initGraph(g);
+
+        EdgeIteratorState edgeState = GHUtility.getEdge(g, 0, 2);
+        QueryResult res1 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        QueryResult res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(res1, res2));
+        assertEquals(new GHPoint(0.5, 0), res1.getSnappedPoint());
+        assertEquals(new GHPoint(0.5, 0), res2.getSnappedPoint());
+        assertEquals(3, res1.getClosestNode());
+        assertEquals(3, res2.getClosestNode());
+
+        // force skip due to **tower** node snapping in phase 2, but no virtual edges should be created for res1
+        edgeState = GHUtility.getEdge(g, 0, 1);
+        res1 = createLocationResult(1, 0, edgeState, 0, EDGE);
+        // now create virtual edges
+        edgeState = GHUtility.getEdge(g, 0, 2);
+        res2 = createLocationResult(0.5, 0, edgeState, 0, EDGE);
+        queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Arrays.asList(res1, res2));
+        // make sure only one virtual node was created
+        assertEquals(queryGraph.getNodes(), g.getNodes() + 1);
+        EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(0);
+        assertEquals(GHUtility.asSet(1, 3), GHUtility.getNeighbors(iter));
+    }
+
     @Test
     public void testGetEdgeProps()
     {
@@ -417,7 +441,7 @@ public QueryResult createLocationResult( double lat, double lon,
     }
 
     @Test
-    public void testIterationBug_163()
+    public void testIteration_Issue163()
     {
         EdgeFilter outEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("CAR"), false, true);
         EdgeFilter inEdgeFilter = new DefaultEdgeFilter(encodingManager.getEncoder("CAR"), true, false);
@@ -441,10 +465,9 @@ public void testIterationBug_163()
         assertEdgeIdsStayingEqual(inExplorer, outExplorer, nodeA, nodeB);
 
         // setup query results
-        EdgeIterator it = outExplorer.setBaseNode(0);
-        it.next();
-        QueryResult res1 = createLocationResult(1.5, 3, it, 0, QueryResult.Position.EDGE);
-        QueryResult res2 = createLocationResult(1.5, 7, it, 0, QueryResult.Position.EDGE);
+        EdgeIteratorState it = GHUtility.getEdge(g, nodeA, nodeB);
+        QueryResult res1 = createLocationResult(1.5, 3, it, 1, QueryResult.Position.EDGE);
+        QueryResult res2 = createLocationResult(1.5, 7, it, 2, QueryResult.Position.EDGE);
 
         QueryGraph q = new QueryGraph(g);
         q.lookup(Arrays.asList(res1, res2));
@@ -478,4 +501,44 @@ private void assertEdgeIdsStayingEqual( EdgeExplorer inExplorer, EdgeExplorer ou
         assertEquals("The edge id is not the same,", expectedEdgeId, it.getEdge());
         assertFalse(it.next());
     }
+
+    @Test
+    public void testTurnCostsProperlyPropagated_Issue282()
+    {
+        TurnCostExtension turnExt = new TurnCostExtension();
+        FlagEncoder encoder = new CarFlagEncoder(5, 5, 15);
+
+        GraphStorage graphWithTurnCosts = new GraphHopperStorage(new RAMDirectory(),
+                new EncodingManager(encoder), false, turnExt).
+                create(100);
+        NodeAccess na = graphWithTurnCosts.getNodeAccess();
+        na.setNode(0, .00, .00);
+        na.setNode(1, .00, .01);
+        na.setNode(2, .01, .01);
+
+        EdgeIteratorState edge0 = graphWithTurnCosts.edge(0, 1, 10, true);
+        EdgeIteratorState edge1 = graphWithTurnCosts.edge(2, 1, 10, true);
+
+        QueryGraph qGraph = new QueryGraph(graphWithTurnCosts);
+        FastestWeighting weighting = new FastestWeighting(encoder);
+        TurnWeighting turnWeighting = new TurnWeighting(weighting, encoder, (TurnCostExtension) qGraph.getExtension());
+
+        assertEquals(0, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
+
+        // now use turn costs and QueryGraph
+        turnExt.addTurnInfo(edge0.getEdge(), 1, edge1.getEdge(), encoder.getTurnFlags(false, 10));
+        assertEquals(10, turnWeighting.calcTurnWeight(edge0.getEdge(), 1, edge1.getEdge()), .1);
+
+        QueryResult res1 = createLocationResult(0.000, 0.005, edge0, 0, QueryResult.Position.EDGE);
+        QueryResult res2 = createLocationResult(0.005, 0.010, edge1, 0, QueryResult.Position.EDGE);
+
+        qGraph.lookup(Arrays.asList(res1, res2));
+
+        int fromQueryEdge = GHUtility.getEdge(qGraph, res1.getClosestNode(), 1).getEdge();
+        int toQueryEdge = GHUtility.getEdge(qGraph, res2.getClosestNode(), 1).getEdge();
+
+        assertEquals(10, turnWeighting.calcTurnWeight(fromQueryEdge, 1, toQueryEdge), .1);
+
+        graphWithTurnCosts.close();
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 9ddf6ff9ce..cf1ece6a4e 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -21,19 +21,21 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.PrinctonReader;
 import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
 import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.StopWatch;
 import java.io.File;
 import java.io.IOException;
 import java.util.*;
-import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.zip.GZIPInputStream;
 import static org.junit.Assert.*;
@@ -78,9 +80,69 @@ public void setUp()
     @Test
     public void testMonaco()
     {
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+        Graph g = runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 createMonacoCar(), "CAR", true, "CAR", "shortest", false);
+
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        // When OSM file stays unchanged make static edge and node IDs a requirement
+        assertEquals(GHUtility.asSet(9, 111, 182), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(19, 21), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(20)));
+        assertEquals(GHUtility.asSet(478, 84, 83), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(480)));
+
+        assertEquals(43.736989, g.getNodeAccess().getLat(10), 1e-6);
+        assertEquals(7.429758, g.getNodeAccess().getLon(201), 1e-6);
+    }
+
+    @Test
+    public void testMonacoAllAlgorithmsWithBaseGraph()
+    {
+        String vehicle = "car";
+        String graphFile = "target/monaco-gh";
+        String osmFile = "files/monaco.osm.gz";
+        String importVehicles = vehicle;
+
+        Helper.removeDir(new File(graphFile));
+        GraphHopper hopper = new GraphHopper().
+                // avoid that path.getDistance is too different to path.getPoint.calcDistance
+                setWayPointMaxDistance(0).
+                setOSMFile(osmFile).
+                setCHEnable(false).
+                setGraphHopperLocation(graphFile).
+                setEncodingManager(new EncodingManager(importVehicles));
+
+        hopper.importOrLoad();
+
+        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
+        Weighting weighting = hopper.createWeighting(new WeightingMap("shortest"), encoder);
+
+        List<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                encoder, true, TraversalMode.NODE_BASED, weighting, hopper.getEncodingManager());
+        AlgoHelperEntry chPrepare = prepares.get(prepares.size() - 1);
+        if (!(chPrepare.getQueryGraph() instanceof LevelGraph))
+            throw new IllegalStateException("Last prepared queryGraph has to be a levelGraph");
+
+        // set all normal algorithms to baseGraph of already prepared to see if all algorithms still work
+        Graph baseGraphOfCHPrepared = chPrepare.getQueryGraph().getBaseGraph();
+        for (AlgoHelperEntry ahe : prepares)
+        {
+            if (!(ahe.getQueryGraph() instanceof LevelGraph))
+            {
+                ahe.setQueryGraph(baseGraphOfCHPrepared);
+            }
+        }
+
+        List<OneRun> forEveryAlgo = createMonacoCar();
+        EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
+        for (AlgoHelperEntry entry : prepares)
+        {
+            LocationIndex idx = entry.getIdx();
+            for (OneRun oneRun : forEveryAlgo)
+            {
+                List<QueryResult> list = oneRun.getList(idx, edgeFilter);
+                testCollector.assertDistance(entry, list, oneRun);
+            }
+        }
     }
 
     @Test
@@ -122,9 +184,7 @@ public void testMoscowTurnCosts()
     {
         List<OneRun> list = new ArrayList<OneRun>();
         list.add(new OneRun(55.813357, 37.5958585, 55.811042, 37.594689, 1043.99, 12));
-
-        // TODO #163
-        // list.add(new OneRun(55.813159,37.593884, 55.811278,37.594217, 1000, 12));
+        list.add(new OneRun(55.813159, 37.593884, 55.811278, 37.594217, 1048, 13));
         // TODO include CH
         boolean testAlsoCH = false, is3D = false;
         runAlgo(testCollector, "files/moscow.osm.gz", "target/graph-moscow",
@@ -178,9 +238,17 @@ public void testMonacoMixed()
     @Test
     public void testMonacoFoot()
     {
-        runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
+        Graph g = runAlgo(testCollector, "files/monaco.osm.gz", "target/monaco-gh",
                 createMonacoFoot(), "FOOT", true, "FOOT", "shortest", false);
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+
+        // see testMonaco for similar ID test
+        assertEquals(GHUtility.asSet(2, 906, 570), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(10)));
+        assertEquals(GHUtility.asSet(443, 952, 739), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(440)));
+        assertEquals(GHUtility.asSet(909, 580, 912), GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(911)));
+
+        assertEquals(43.743705, g.getNodeAccess().getLat(100), 1e-6);
+        assertEquals(7.426362, g.getNodeAccess().getLon(701), 1e-6);
     }
 
     @Test
@@ -421,11 +489,11 @@ public void testNeudrossenfeld()
      * @param testAlsoCH if true also the CH algorithms will be tested which needs preparation and
      * takes a bit longer
      */
-    void runAlgo( TestAlgoCollector testCollector, String osmFile,
+    Graph runAlgo( TestAlgoCollector testCollector, String osmFile,
             String graphFile, List<OneRun> forEveryAlgo, String importVehicles,
-            boolean testAlsoCH, String vehicle, String weightCalcStr, boolean is3D )
+            boolean testAlsoCH, String vehicle, String weightStr, boolean is3D )
     {
-        AlgorithmPreparation tmpPrepare = null;
+        AlgoHelperEntry algoEntry = null;
         OneRun tmpOneRun = null;
         try
         {
@@ -446,28 +514,30 @@ void runAlgo( TestAlgoCollector testCollector, String osmFile,
             TraversalMode tMode = importVehicles.toLowerCase().contains("turncosts=true")
                     ? TraversalMode.EDGE_BASED_1DIR : TraversalMode.NODE_BASED;
             FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
-            Weighting weighting = hopper.createWeighting(new WeightingMap(weightCalcStr), encoder);
+            Weighting weighting = hopper.createWeighting(new WeightingMap(weightStr), encoder);
 
-            Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = RoutingAlgorithmSpecialAreaTests.
-                    createAlgos(hopper.getGraph(), hopper.getLocationIndex(), encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
+            Collection<AlgoHelperEntry> prepares = createAlgos(hopper.getGraph(), hopper.getLocationIndex(),
+                    encoder, testAlsoCH, tMode, weighting, hopper.getEncodingManager());
             EdgeFilter edgeFilter = new DefaultEdgeFilter(encoder);
-            for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
+            for (AlgoHelperEntry entry : prepares)
             {
-                tmpPrepare = entry.getKey();
-                LocationIndex idx = entry.getValue();
+                algoEntry = entry;
+                LocationIndex idx = entry.getIdx();
                 for (OneRun oneRun : forEveryAlgo)
                 {
                     tmpOneRun = oneRun;
                     List<QueryResult> list = oneRun.getList(idx, edgeFilter);
-                    testCollector.assertDistance(tmpPrepare, list, oneRun);
+                    testCollector.assertDistance(algoEntry, list, oneRun);
                 }
             }
+
+            return hopper.getGraph();
         } catch (Exception ex)
         {
-            if (tmpPrepare == null)
+            if (algoEntry == null)
                 throw new RuntimeException("cannot handle file " + osmFile + ", " + ex.getMessage(), ex);
 
-            throw new RuntimeException("cannot handle " + tmpPrepare.toString() + ", for " + tmpOneRun
+            throw new RuntimeException("cannot handle " + algoEntry.toString() + ", for " + tmpOneRun
                     + ", file " + osmFile + ", " + ex.getMessage(), ex);
         } finally
         {
@@ -487,18 +557,17 @@ public void testPerformance() throws IOException
         Graph graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
-        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile), 8 * (1 << 10))).read();
-        Collection<Entry<AlgorithmPreparation, LocationIndex>> prepares = RoutingAlgorithmSpecialAreaTests.
-                createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED, new ShortestWeighting(), eManager);
-        for (Entry<AlgorithmPreparation, LocationIndex> entry : prepares)
+        new PrinctonReader(graph).setStream(new GZIPInputStream(PrinctonReader.class.getResourceAsStream(bigFile))).read();
+        Collection<AlgoHelperEntry> prepares = createAlgos(graph, null, encoder, false, TraversalMode.NODE_BASED,
+                new ShortestWeighting(), eManager);
+        for (AlgoHelperEntry entry : prepares)
         {
-            AlgorithmPreparation prepare = entry.getKey();
             StopWatch sw = new StopWatch();
             for (int i = 0; i < N; i++)
             {
                 int node1 = Math.abs(rand.nextInt(graph.getNodes()));
                 int node2 = Math.abs(rand.nextInt(graph.getNodes()));
-                RoutingAlgorithm d = prepare.createAlgo();
+                RoutingAlgorithm d = entry.createAlgo(graph);
                 if (i >= noJvmWarming)
                     sw.start();
 
@@ -511,7 +580,7 @@ public void testPerformance() throws IOException
             }
 
             float perRun = sw.stop().getSeconds() / ((float) (N - noJvmWarming));
-            System.out.println("# " + getClass().getSimpleName() + " " + prepare.createAlgo().getName()
+            System.out.println("# " + getClass().getSimpleName() + " " + entry
                     + ":" + sw.stop().getSeconds() + ", per run:" + perRun);
             assertTrue("speed to low!? " + perRun + " per run", perRun < 0.08);
         }
@@ -529,7 +598,8 @@ public void testMonacoParallel() throws IOException
                 setEncodingManager(encodingManager).
                 setCHEnable(false).
                 setWayPointMaxDistance(0).
-                setOSMFile("files/monaco.osm.gz").setGraphHopperLocation(graphFile).
+                setOSMFile("files/monaco.osm.gz").
+                setGraphHopperLocation(graphFile).
                 importOrLoad();
         final Graph g = hopper.getGraph();
         final LocationIndex idx = hopper.getLocationIndex();
@@ -537,23 +607,22 @@ public void testMonacoParallel() throws IOException
         List<Thread> threads = new ArrayList<Thread>();
         final AtomicInteger integ = new AtomicInteger(0);
         int MAX = 100;
-        FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
+        final FlagEncoder carEncoder = encodingManager.getEncoder("CAR");
 
         // testing if algorithms are independent. should be. so test only two algorithms. 
         // also the preparing is too costly to be called for every thread
         int algosLength = 2;
-        Weighting weighting = new ShortestWeighting();
+        final Weighting weighting = new ShortestWeighting();
         final EdgeFilter filter = new DefaultEdgeFilter(carEncoder);
         for (int no = 0; no < MAX; no++)
         {
             for (int instanceNo = 0; instanceNo < instances.size(); instanceNo++)
             {
-                RoutingAlgorithm[] algos = new RoutingAlgorithm[]
+                String[] algos = new String[]
                 {
-                    new AStar(g, carEncoder, weighting, TraversalMode.NODE_BASED),
-                    new DijkstraBidirectionRef(g, carEncoder, weighting, TraversalMode.NODE_BASED)
+                    "astar", "dijkstrabi"
                 };
-                for (final RoutingAlgorithm algo : algos)
+                for (final String algoStr : algos)
                 {
                     // an algorithm is not thread safe! reuse via clear() is ONLY appropriated if used from same thread!
                     final int instanceIndex = instanceNo;
@@ -563,21 +632,9 @@ public void testMonacoParallel() throws IOException
                         public void run()
                         {
                             OneRun oneRun = instances.get(instanceIndex);
-                            testCollector.assertDistance(new NoOpAlgorithmPreparation()
-                            {
-                                @Override
-                                public RoutingAlgorithm createAlgo()
-                                {
-                                    return algo;
-                                }
-
-                                @Override
-                                public String toString()
-                                {
-                                    return algo.toString();
-                                }
-
-                            }, oneRun.getList(idx, filter), oneRun);
+                            AlgorithmOptions opts = AlgorithmOptions.start().flagEncoder(carEncoder).weighting(weighting).algorithm(algoStr).build();
+                            testCollector.assertDistance(new AlgoHelperEntry(g, opts, idx),
+                                    oneRun.getList(idx, filter), oneRun);
                             integ.addAndGet(1);
                         }
                     };
@@ -602,4 +659,47 @@ public String toString()
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
         hopper.close();
     }
+
+    static List<AlgoHelperEntry> createAlgos( Graph g,
+            LocationIndex idx, final FlagEncoder encoder, boolean withCh,
+            final TraversalMode tMode, final Weighting weighting, final EncodingManager manager )
+    {
+        List<AlgoHelperEntry> prepare = new ArrayList<AlgoHelperEntry>();
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.ASTAR, encoder, weighting, tMode), idx));
+        // later: include dijkstraOneToMany        
+        prepare.add(new AlgoHelperEntry(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA, encoder, weighting, tMode), idx));
+
+        final AlgorithmOptions astarbiOpts = new AlgorithmOptions(AlgorithmOptions.ASTAR_BI, encoder, weighting, tMode);
+        astarbiOpts.getHints().put(AlgorithmOptions.ASTAR_BI + ".approximation", "BeelineSimplification");
+        final AlgorithmOptions dijkstrabiOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting, tMode);
+        prepare.add(new AlgoHelperEntry(g, astarbiOpts, idx));
+        prepare.add(new AlgoHelperEntry(g, dijkstrabiOpts, idx));
+
+        if (withCh)
+        {
+            final LevelGraph graphCH = (LevelGraph) ((GraphStorage) g).copyTo(new GraphBuilder(manager).
+                    set3D(g.getNodeAccess().is3D()).levelGraphCreate());
+            final PrepareContractionHierarchies prepareCH = new PrepareContractionHierarchies(graphCH, encoder, weighting, tMode);
+            prepareCH.doWork();
+            LocationIndex idxCH = new LocationIndexTree(graphCH.getBaseGraph(), new RAMDirectory()).prepareIndex();
+            prepare.add(new AlgoHelperEntry(graphCH, dijkstrabiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, dijkstrabiOpts);
+                }
+            });
+
+            prepare.add(new AlgoHelperEntry(graphCH, astarbiOpts, idxCH)
+            {
+                @Override
+                public RoutingAlgorithm createAlgo( Graph qGraph )
+                {
+                    return prepareCH.createAlgo(qGraph, astarbiOpts);
+                }
+            });
+        }
+        return prepare;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
index d6adb30691..9dd71bd9c2 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/DijkstraBidirectionCHTest.java
@@ -17,15 +17,8 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.LevelGraph;
 import com.graphhopper.storage.LevelGraphStorage;
@@ -44,7 +37,7 @@
  */
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester
 {
-    // graph is expensive to create and to prepare!
+    // matrix graph is expensive to create and to prepare!
     private static Graph preparedMatrixGraph;
 
     @Override
@@ -54,7 +47,7 @@ public Graph getMatrixGraph()
         {
             LevelGraph lg = (LevelGraph) createGraph(false);
             getMatrixAlikeGraph().copyTo(lg);
-            prepareGraph(lg);
+            createFactory(lg, defaultOpts);
             preparedMatrixGraph = lg;
         }
         return preparedMatrixGraph;
@@ -67,10 +60,17 @@ protected LevelGraph createGraph( EncodingManager em, boolean is3D )
     }
 
     @Override
-    public PrepareContractionHierarchies prepareGraph( Graph g, FlagEncoder encoder, Weighting w )
+    public RoutingAlgorithm createAlgo( Graph g, AlgorithmOptions opts )
     {
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(encoder, w, TraversalMode.NODE_BASED).setGraph(g);
-        // hack: prepare matrixgraph only once
+        return createFactory(g, opts).createAlgo(g, opts);
+    }
+
+    @Override
+    public RoutingAlgorithmFactory createFactory( Graph g, AlgorithmOptions opts )
+    {
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies((LevelGraph) g,
+                opts.getFlagEncoder(), opts.getWeighting(), TraversalMode.NODE_BASED);
+        // hack: prepare matrixGraph only once
         if (g != preparedMatrixGraph)
             ch.doWork();
 
@@ -115,8 +115,10 @@ public void testPathRecursiveUnpacking()
         g2.setLevel(7, 6);
         g2.setLevel(0, 7);
 
-        Path p = new PrepareContractionHierarchies(encoder, new ShortestWeighting(), TraversalMode.NODE_BASED).
-                setGraph(g2).createAlgo().calcPath(0, 7);
+        ShortestWeighting weighting = new ShortestWeighting();
+        AlgorithmOptions opts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
+        Path p = new PrepareContractionHierarchies(g2, encoder, weighting, TraversalMode.NODE_BASED).
+                createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(Helper.createTList(0, 2, 5, 7), p.calcNodes());
         assertEquals(1064, p.getMillis());
@@ -138,9 +140,60 @@ public long setProperties( double speed, boolean forward, boolean backward )
             }
         };
 
-        footEncoder = new EncodingManager("FOOT").getSingle();
+        footEncoder = new FootFlagEncoder();
+        new EncodingManager(footEncoder);
+        
         super.testCalcFootPath();
         footEncoder = tmpFootEncoder;
         carEncoder = tmpCarEncoder;
     }
+
+    @Test
+    public void testBaseGraph()
+    {
+        CarFlagEncoder carFE = new CarFlagEncoder();
+        Graph g = createGraph(new EncodingManager(carFE), false);
+        initDirectedAndDiffSpeed(g, carFE);
+
+        // do CH preparation for car
+        createFactory(g, defaultOpts);
+
+        // use base graph for solving normal Dijkstra
+        Path p1 = new RoutingAlgorithmFactorySimple().createAlgo(g, defaultOpts).calcPath(0, 3);
+        assertEquals(Helper.createTList(0, 1, 5, 2, 3), p1.calcNodes());
+        assertEquals(p1.toString(), 402.293, p1.getDistance(), 1e-6);
+        assertEquals(p1.toString(), 144823, p1.getMillis());
+    }
+
+    @Test
+    public void testBaseGraphMultipleVehicles()
+    {
+        Graph g = createGraph(encodingManager, false);
+        initFootVsCar(g);
+
+        AlgorithmOptions footOptions = AlgorithmOptions.start().flagEncoder(footEncoder).
+                weighting(new FastestWeighting(footEncoder)).build();
+        AlgorithmOptions carOptions = AlgorithmOptions.start().flagEncoder(carEncoder).
+                weighting(new FastestWeighting(carEncoder)).build();
+
+        // do CH preparation for car
+        RoutingAlgorithmFactory contractedFactory = createFactory(g, carOptions);
+
+        // use contracted graph
+        Path p1 = contractedFactory.createAlgo(g, carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p1.calcNodes());
+        assertEquals(p1.toString(), 15000, p1.getDistance(), 1e-6);
+
+        // use base graph for solving normal Dijkstra via car
+        Path p2 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), carOptions).calcPath(0, 7);
+        assertEquals(Helper.createTList(0, 4, 6, 7), p2.calcNodes());
+        assertEquals(p2.toString(), 15000, p2.getDistance(), 1e-6);
+        assertEquals(p2.toString(), 2700 * 1000, p2.getMillis());
+
+        // use base graph for solving normal Dijkstra via foot
+        Path p3 = new RoutingAlgorithmFactorySimple().createAlgo(g.getBaseGraph(), footOptions).calcPath(0, 7);
+        assertEquals(p3.toString(), 17000, p3.getDistance(), 1e-6);
+        assertEquals(p3.toString(), 12240 * 1000, p3.getMillis());
+        assertEquals(Helper.createTList(0, 4, 5, 7), p3.calcNodes());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 7ba3f170ba..d2956408f6 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -17,10 +17,7 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies.Shortcut;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
@@ -41,7 +38,7 @@
     private final EncodingManager encodingManager = new EncodingManager("CAR");
     private final CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("CAR");
     private final Weighting weighting = new ShortestWeighting();
-    private TraversalMode tMode = TraversalMode.NODE_BASED;
+    private final TraversalMode tMode = TraversalMode.NODE_BASED;
 
     LevelGraph createGraph()
     {
@@ -74,8 +71,11 @@ public void testShortestPathSkipNode()
         LevelGraph g = createExampleGraph();
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(100).findEndNode(4, 2);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(100);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
 
         algo.clear();
@@ -90,11 +90,14 @@ public void testShortestPathSkipNode2()
         double normalDist = new Dijkstra(g, carEncoder, weighting, tMode).calcPath(4, 2).getDistance();
         assertEquals(3, normalDist, 1e-5);
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(3));
-        int nodeEntry = algo.setLimitWeight(10).findEndNode(4, 2);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(3));
+        algo.setWeightLimit(10);
+        int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
 
-        nodeEntry = algo.setLimitWeight(10).findEndNode(4, 1);
+        nodeEntry = algo.findEndNode(4, 1);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
     }
 
@@ -103,8 +106,11 @@ public void testShortestPathLimit()
     {
         LevelGraph g = createExampleGraph();
         DijkstraOneToMany algo = new DijkstraOneToMany(g, carEncoder, weighting, tMode);
-        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g).setAvoidNode(0));
-        int endNode = algo.setLimitWeight(2).findEndNode(4, 1);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        prepare.initFromGraph().prepareNodes();
+        algo.setEdgeFilter(new PrepareContractionHierarchies.IgnoreNodeFilter(g, g.getNodes() + 1).setAvoidNode(0));
+        algo.setWeightLimit(2);
+        int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
         assertNotEquals(1, endNode);
     }
@@ -113,22 +119,20 @@ public void testShortestPathLimit()
     public void testAddShortcuts()
     {
         LevelGraph g = createExampleGraph();
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 1, g.getAllEdges().getMaxId());
+        assertEquals(old + 1, g.getAllEdges().getCount());
     }
 
     @Test
     public void testMoreComplexGraph()
     {
         LevelGraph g = initShortcutsGraph(createGraph());
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 10, g.getAllEdges().getMaxId());
+        assertEquals(old + 10, g.getAllEdges().getCount());
     }
 
     @Test
@@ -142,11 +146,10 @@ public void testDirectedGraph()
         g.edge(3, 5, 1, false);
         g.edge(4, 3, 1, false);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(old + 2, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo();
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(4, 3, 5, 2), p.calcNodes());
@@ -158,12 +161,11 @@ public void testDirectedGraph2()
         LevelGraph g = createGraph();
         initDirected2(g);
         int old = GHUtility.count(g.getAllEdges());
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(old + 9, GHUtility.count(g.getAllEdges()));
-        RoutingAlgorithm algo = prepare.createAlgo();
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
         assertEquals(Helper.createTList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
@@ -192,9 +194,9 @@ public void testDirectedGraph3()
         g.edge(3, 6, 2, true);
         g.edge(3, 7, 2, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.initFromGraph();
+        prepare.prepareNodes();
         // find all shortcuts if we contract node 1
         Collection<Shortcut> scs = prepare.testFindShortcuts(1);
         assertEquals(2, scs.size());
@@ -278,12 +280,11 @@ public void testRoundaboutUnpacking()
     {
         LevelGraph g = createGraph();
         initRoundaboutGraph(g);
-        int old = g.getAllEdges().getMaxId();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        int old = g.getAllEdges().getCount();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
-        assertEquals(old + 22, g.getAllEdges().getMaxId());
-        RoutingAlgorithm algo = prepare.createAlgo();
+        assertEquals(old + 22, g.getAllEdges().getCount());
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(4, 7);
         assertEquals(Helper.createTList(4, 5, 6, 7), p.calcNodes());
     }
@@ -299,13 +300,8 @@ public void testFindShortcuts_Roundabout()
         EdgeIteratorState iter3_1 = g.edge(6, 7, 1, true);
         EdgeIteratorState iter3_2 = g.edge(6, 8, 2, false);
         g.edge(8, 4, 1, false);
-        g.setLevel(3, 3);
-        g.setLevel(5, 5);
-        g.setLevel(7, 7);
-        g.setLevel(8, 8);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         EdgeSkipIterState tmp = g.shortcut(1, 4);
         tmp.setFlags(PrepareEncoder.getScDirMask());
         tmp.setWeight(2);
@@ -321,6 +317,12 @@ public void testFindShortcuts_Roundabout()
         tmp.setSkippedEdges(iter3_1.getEdge(), iter3_2.getEdge());
 
         prepare.initFromGraph();
+        prepare.prepareNodes();
+        g.setLevel(3, 3);
+        g.setLevel(5, 5);
+        g.setLevel(7, 7);
+        g.setLevel(8, 8);
+
         // there should be two different shortcuts for both directions!
         Collection<Shortcut> sc = prepare.testFindShortcuts(4);
         assertEquals(2, sc.size());
@@ -376,9 +378,8 @@ public void testUnpackingOrder()
     {
         LevelGraphStorage g = (LevelGraphStorage) createGraph();
         initUnpackingGraph(g, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
-        RoutingAlgorithm algo = prepare.createAlgo();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -391,9 +392,8 @@ public void testUnpackingOrder_Fastest()
         Weighting w = new FastestWeighting(carEncoder);
         initUnpackingGraph(g, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, w, tMode).
-                setGraph(g);
-        RoutingAlgorithm algo = prepare.createAlgo();
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
+        RoutingAlgorithm algo = prepare.createAlgo(g, new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, carEncoder, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
         assertEquals(Helper.createTList(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
@@ -410,8 +410,7 @@ public void testCircleBug()
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
@@ -435,8 +434,7 @@ public void testBug178()
         g.edge(3, 4, 1, true);
         g.edge(6, 3, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(carEncoder, weighting, tMode).
-                setGraph(g);
+        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(g, carEncoder, weighting, tMode);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 0a6d47f4e7..2bf1cb7e1c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -48,10 +48,12 @@ public void testAccess()
         way.setTag("motorcar", "no");
         assertFalse(encoder.acceptWay(way) > 0);
 
+        // for now allow grade1+2+3 for every country, see #253
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("tracktype", "grade2");
-        // disallow too rough tracks
+        assertTrue(encoder.acceptWay(way) > 0);
+        way.setTag("tracktype", "grade4");
         assertFalse(encoder.acceptWay(way) > 0);
 
         way.clearTags();
@@ -96,6 +98,15 @@ public void testAccess()
         assertFalse(encoder.isBool(flags, FlagEncoder.K_BACKWARD));
     }
 
+    @Test
+    public void testMilitaryAccess()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "track");
+        way.setTag("access", "military");
+        assertFalse(encoder.acceptWay(way) > 0);
+    }
+
     @Test
     public void testSetAccess()
     {
@@ -240,8 +251,8 @@ public void testRailway()
 
         // on disallowed highway, railway is allowed, sometimes incorrectly mapped
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);        
-        
+        assertTrue(encoder.acceptWay(way) > 0);
+
         // this is fully okay as sometimes old rails are on the road
         way.setTag("highway", "primary");
         way.setTag("railway", "historic");
@@ -433,12 +444,14 @@ public void testFordAccess()
         assertFalse(encoder.acceptWay(way) > 0);
         assertTrue(encoder.handleNodeTags(node) > 0);
 
-        try {
+        try
+        {
             // Now they are passable
             encoder.setBlockFords(false);
             assertTrue(encoder.acceptWay(way) > 0);
             assertFalse(encoder.handleNodeTags(node) > 0);
-        } finally {
+        } finally
+        {
             encoder.setBlockFords(true);
         }
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index edbbd1d9e3..3387227fd0 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -3,8 +3,8 @@
  *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
  *
  *       http://www.apache.org/licenses/LICENSE-2.0
@@ -22,19 +22,11 @@
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-
 import org.junit.Test;
 
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.ITurnCostTableEntry;
 import com.graphhopper.reader.OSMRelation;
-import com.graphhopper.reader.OSMTurnRelation.TurnCostTableEntry;
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.reader.Relation;
-import com.graphhopper.reader.TurnRelation;
 import com.graphhopper.reader.Way;
 import com.graphhopper.util.BitUtil;
 
@@ -169,7 +161,7 @@ public void testMixBikeTypesAndRelationCombination()
         long allow = bikeEncoder.acceptBit | mtbEncoder.acceptBit;
         long flags = manager.handleWayTags(osmWay, allow, relFlags);
 
-        // bike: uninfluenced speed for grade but via network => VERY_NICE                
+        // bike: uninfluenced speed for grade but via network => VERY_NICE
         // mtb: uninfluenced speed only PREFER
         assertTrue(bikeEncoder.getDouble(flags, PriorityWeighting.KEY)
                 > mtbEncoder.getDouble(flags, PriorityWeighting.KEY));
@@ -186,93 +178,6 @@ public void testFullBitMask()
         assertTrue(bitUtil.toBitString(foot.getNodeBitMask()).endsWith("00011111110000000"));
     }
 
-    /**
-     * Tests the combination of different turn cost flags by different encoders.
-     */
-    @Test
-    public void testTurnFlagCombination()
-    {
-        final TurnCostTableEntry turnCostEntry_car = new TurnCostTableEntry();
-        final TurnCostTableEntry turnCostEntry_foot = new TurnCostTableEntry();
-        final TurnCostTableEntry turnCostEntry_bike = new TurnCostTableEntry();
-
-        CarFlagEncoder car = new CarFlagEncoder(5, 5, 24)
-        {
-            @Override
-            public Collection<ITurnCostTableEntry> analyzeTurnRelation( TurnRelation turnRelation, DataReader osmReader )
-            {
-                // simulate by returning one turn cost entry directly
-                return Collections.singleton((ITurnCostTableEntry)turnCostEntry_car);
-            }
-        };
-        FootFlagEncoder foot = new FootFlagEncoder()
-        {
-            @Override
-            public Collection<ITurnCostTableEntry> analyzeTurnRelation( TurnRelation turnRelation, DataReader osmReader )
-            {
-                return Collections.singleton((ITurnCostTableEntry)turnCostEntry_foot);
-            }
-        };
-
-        BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24)
-        {
-            @Override
-            public Collection<ITurnCostTableEntry> analyzeTurnRelation( TurnRelation turnRelation, DataReader osmReader )
-            {
-                return Collections.singleton((ITurnCostTableEntry)turnCostEntry_bike);
-            }
-        };
-
-        EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
-
-        // turn cost entries for car and foot are for the same relations (same viaNode, edgeFrom and edgeTo), turn cost entry for bike is for another relation (different viaNode) 
-        turnCostEntry_car.edgeFrom = 1;
-        turnCostEntry_foot.edgeFrom = 1;
-        turnCostEntry_bike.edgeFrom = 2;
-
-        // calculating arbitrary flags using the encoders
-        turnCostEntry_car.flags = car.getTurnFlags(true, 0);
-        turnCostEntry_foot.flags = foot.getTurnFlags(true, 0);
-        turnCostEntry_bike.flags = bike.getTurnFlags(false, 10);
-
-        // we expect two different entries: the first one is a combination of turn flags of car and foot, since they provide the same relation, the other one is for bike only
-        long assertFlag1 = turnCostEntry_car.flags | turnCostEntry_foot.flags;
-        long assertFlag2 = turnCostEntry_bike.flags;
-
-        // RUN: analyze = combine flags of all encoders
-        Collection<ITurnCostTableEntry> entries = manager.analyzeTurnRelation(null, null);
-
-        assertEquals(2, entries.size()); //we expect two different turnCost entries
-
-        for (ITurnCostTableEntry entry : entries)
-        {
-            int edgeFrom = entry.getEdgeFrom();
-			if (edgeFrom == 1)
-            {
-                // the first entry provides turn flags for car and foot only 
-                assertEquals(assertFlag1, entry.getFlags());
-                assertTrue(car.isTurnRestricted(entry.getFlags()));
-                assertFalse(foot.isTurnRestricted(entry.getFlags()));
-                assertFalse(bike.isTurnRestricted(entry.getFlags()));
-
-                assertTrue(Double.isInfinite(car.getTurnCost(entry.getFlags())));
-                assertEquals(0, foot.getTurnCost(entry.getFlags()), 1e-1);
-                assertEquals(0, bike.getTurnCost(entry.getFlags()), 1e-1);
-            } else if (edgeFrom == 2)
-            {
-                // the 2nd entry provides turn flags for bike only
-                assertEquals(assertFlag2, entry.getFlags());
-                assertFalse(car.isTurnRestricted(entry.getFlags()));
-                assertFalse(foot.isTurnRestricted(entry.getFlags()));
-                assertFalse(bike.isTurnRestricted(entry.getFlags()));
-
-                assertEquals(0, car.getTurnCost(entry.getFlags()), 1e-1);
-                assertEquals(0, foot.getTurnCost(entry.getFlags()), 1e-1);
-                assertEquals(10, bike.getTurnCost(entry.getFlags()), 1e-1);
-            }
-        }
-    }
-
     @Test
     public void testFixWayName()
     {
@@ -288,7 +193,7 @@ public void testCompatibilityBug()
         osmWay.setTag("highway", "footway");
         osmWay.setTag("name", "test");
 
-        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getSingle();
+        BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getEncoder("bike2");
         long flags = manager2.handleWayTags(osmWay, singleBikeEnc.acceptBit, 0);
         double singleSpeed = singleBikeEnc.getSpeed(flags);
         assertEquals(4, singleSpeed, 1e-3);
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 4eb37f1984..ce145c8b57 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -111,6 +111,8 @@ public void testAccess()
         assertTrue(footEncoder.acceptWay(way) > 0);
 
         way.setTag("bicycle", "official");
+        assertTrue(footEncoder.acceptWay(way) > 0);
+        way.setTag("foot", "no");
         assertFalse(footEncoder.acceptWay(way) > 0);
 
         way.setTag("foot", "official");
@@ -128,9 +130,9 @@ public void testAccess()
 
         way.clearTags();
         way.setTag("highway", "cycleway");
-        assertFalse(footEncoder.acceptWay(way) > 0);
-        way.setTag("foot", "yes");
         assertTrue(footEncoder.acceptWay(way) > 0);
+        way.setTag("foot", "no");
+        assertFalse(footEncoder.acceptWay(way) > 0);
 
         way.clearTags();
         way.setTag("highway", "track");
@@ -150,7 +152,6 @@ public void testAccess()
     public void testMixSpeedAndSafe()
     {
         OSMWay way = new OSMWay(1);
-
         way.setTag("highway", "motorway");
         long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
         assertEquals(0, flags);
@@ -165,6 +166,18 @@ public void testMixSpeedAndSafe()
         assertEquals(5, footEncoder.getSpeed(flags), 1e-1);
     }
 
+    @Test
+    public void testPriority()
+    {
+        OSMWay way = new OSMWay(1);
+        way.setTag("highway", "cycleway");
+        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));
+
+        way.setTag("highway", "track");
+        way.setTag("bicycle", "official");
+        assertEquals(PriorityCode.REACH_DEST.getValue(), footEncoder.handlePriority(way, 0));
+    }
+
     @Test
     public void testSlowHiking()
     {
@@ -233,7 +246,7 @@ public void testBarrierAccess()
         node.setTag("foot", "yes");
         // no barrier!
         assertTrue(footEncoder.handleNodeTags(node) == 0);
-        
+
         node.setTag("locked", "yes");
         // barrier!
         assertTrue(footEncoder.handleNodeTags(node) > 0);
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 81df2aac3c..92f737654c 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -27,8 +27,8 @@
  */
 public class MotorcycleFlagEncoderTest
 {
-    private final EncodingManager em = new EncodingManager("CAR,BIKE,FOOT");
-    private final CarFlagEncoder encoder = (CarFlagEncoder) em.getEncoder("CAR");
+    private final EncodingManager em = new EncodingManager("motorcycle,foot");
+    private final MotorcycleFlagEncoder encoder = (MotorcycleFlagEncoder) em.getEncoder("motorcycle");
 
     @Test
     public void testHandleWayTags()
diff --git a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
index 36b2489024..61a2936111 100644
--- a/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/PrepareRoutingSubnetworksTest.java
@@ -28,13 +28,14 @@
 import java.util.Map;
 import org.junit.*;
 import static org.junit.Assert.*;
+
 /**
  *
  * @author Peter Karich
  */
 public class PrepareRoutingSubnetworksTest
 {
-    private final EncodingManager em = new EncodingManager("CAR");
+    private final EncodingManager em = new EncodingManager("car");
 
     GraphStorage createGraph( EncodingManager eman )
     {
@@ -197,8 +198,9 @@ public void testRemoveDeadEndUnvisitedNetworks()
         GraphStorage g = createDeadEndUnvisitedNetworkGraph(em);
         assertEquals(11, g.getNodes());
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(3);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
         assertEquals(3, removed);
 
@@ -212,7 +214,7 @@ public void testTarjan()
         GraphStorage g = createSubnetworkTestGraph();
 
         // Requires a single vehicle type, otherwise we throw.
-        final FlagEncoder flagEncoder = em.getSingle();
+        final FlagEncoder flagEncoder = em.getEncoder("car");
         final EdgeFilter filter = new DefaultEdgeFilter(flagEncoder, false, true);
 
         TarjansStronglyConnectedComponentsAlgorithm tarjan = new TarjansStronglyConnectedComponentsAlgorithm(g, filter);
@@ -220,24 +222,36 @@ public void testTarjan()
         List<TIntArrayList> components = tarjan.findComponents();
 
         assertEquals(4, components.size());
-        assertEquals(new TIntArrayList(new int[]{ 13, 5, 3, 7, 0 }), components.get(0));
-        assertEquals(new TIntArrayList(new int[]{ 2, 4, 12, 11, 8, 1 }), components.get(1));
-        assertEquals(new TIntArrayList(new int[] {10, 14, 6}), components.get(2));
-        assertEquals(new TIntArrayList(new int[] {9}), components.get(3));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            13, 5, 3, 7, 0
+        }), components.get(0));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            2, 4, 12, 11, 8, 1
+        }), components.get(1));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            10, 14, 6
+        }), components.get(2));
+        assertEquals(new TIntArrayList(new int[]
+        {
+            9
+        }), components.get(3));
     }
 
     // Previous two-pass implementation failed on 1 -> 2 -> 0
     @Test
-    public void testNodeOrderingRegression() {
+    public void testNodeOrderingRegression()
+    {
         // 1 -> 2 -> 0
         GraphStorage g = createGraph(em);
         g.edge(1, 2, 1, false);
         g.edge(2, 0, 1, false);
+        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).
+                setMinOneWayNetworkSize(2);
+        int removed = instance.removeDeadEndUnvisitedNetworks(em.getEncoder("car"));
 
-        PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em).setMinOnewayNetworkSize(2);
-        int removed = instance.removeDeadEndUnvisitedNetworks(em.getSingle());
-        
         assertEquals(3, removed);
     }
-
 }
diff --git a/core/src/test/java/com/graphhopper/search/NameIndexTest.java b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
index c990ad6065..746d286993 100644
--- a/core/src/test/java/com/graphhopper/search/NameIndexTest.java
+++ b/core/src/test/java/com/graphhopper/search/NameIndexTest.java
@@ -37,7 +37,7 @@ public void testNoErrorOnLargeName()
         {
             str += "ß";
         }
-        int result = index.put(str);
+        long result = index.put(str);
         assertEquals(127, index.get(result).length());
     }
 
@@ -45,10 +45,10 @@ public void testNoErrorOnLargeName()
     public void testPut()
     {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
-        int result = index.put("Something Streetä");
+        long result = index.put("Something Streetä");
         assertEquals("Something Streetä", index.get(result));
 
-        int existing = index.put("Something Streetä");
+        long existing = index.put("Something Streetä");
         assertEquals(result, existing);
 
         result = index.put("testing");
@@ -65,10 +65,10 @@ public void testCreate()
     {
         NameIndex index = new NameIndex(new RAMDirectory()).create(1000);
         String str1 = "nice";
-        int pointer1 = index.put(str1);
+        long pointer1 = index.put(str1);
 
         String str2 = "nice work äöß";
-        int pointer2 = index.put(str2);
+        long pointer2 = index.put(str2);
 
         assertEquals(str2, index.get(pointer2));
         assertEquals(str1, index.get(pointer1));
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index 98fe465365..181c5d1adc 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -686,7 +686,7 @@ public void testBounds()
     {
         graph = createGraph();
         BBox b = graph.getBounds();
-        assertEquals(BBox.INVERSE.maxLat, b.maxLat, 1e-6);
+        assertEquals(BBox.createInverse(false).maxLat, b.maxLat, 1e-6);
 
         NodeAccess na = graph.getNodeAccess();
         na.setNode(0, 10, 20);
@@ -947,14 +947,14 @@ public void testGetAllEdgesWithDelete()
         graph.edge(2, 3, 1, true);
         AllEdgesIterator iter = graph.getAllEdges();
         assertEquals(4, GHUtility.count(iter));
-        assertEquals(4, iter.getMaxId());
+        assertEquals(4, iter.getCount());
 
         // delete
         graph.markNodeRemoved(1);
         graph.optimize();
         iter = graph.getAllEdges();
         assertEquals(2, GHUtility.count(iter));
-        assertEquals(4, iter.getMaxId());
+        assertEquals(4, iter.getCount());
 
         iter = graph.getAllEdges();
         iter.next();
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index 1c0900623a..ff4bdbacc0 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -67,16 +67,17 @@ public void testNoCreateCalled() throws IOException
     @Test
     public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 10, 10);
-        na.setNode(1, 11, 20);
-        na.setNode(2, 12, 12);
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
@@ -88,7 +89,7 @@ public void testSave_and_fileFormat() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -96,14 +97,17 @@ public void testSave_and_fileFormat() throws IOException
 
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
     protected void checkGraph( Graph g )
     {
         NodeAccess na = g.getNodeAccess();
-        assertEquals(new BBox(10, 20, 10, 12), g.getBounds());
+        assertTrue(na.is3D());
+        assertTrue(g.getBounds().isValid());
+        
+        assertEquals(new BBox(10, 20, 10, 12, 0, 1), g.getBounds());
         assertEquals(10, na.getLatitude(0), 1e-2);
         assertEquals(10, na.getLongitude(0), 1e-2);
         EdgeExplorer explorer = g.createEdgeExplorer(carOutFilter);
@@ -112,12 +116,12 @@ protected void checkGraph( Graph g )
 
         EdgeIterator iter = explorer.setBaseNode(0);
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(3.5, 4.5, 5, 6), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0), iter.fetchWayGeometry(0));
 
         assertTrue(iter.next());
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3), iter.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(10, 10, 1.5, 1, 2, 3), iter.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(1.5, 1, 2, 3, 11, 20), iter.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(10, 10, 0, 1.5, 1, 0, 2, 3, 0), iter.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0, 11, 20, 1), iter.fetchWayGeometry(2));
 
         assertEquals(11, na.getLatitude(1), 1e-2);
         assertEquals(20, na.getLongitude(1), 1e-2);
@@ -131,9 +135,9 @@ protected void checkGraph( Graph g )
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
 
         EdgeIteratorState eib = GHUtility.getEdge(g, 1, 2);
-        assertEquals(Helper.createPointList(), eib.fetchWayGeometry(0));
-        assertEquals(Helper.createPointList(11, 20), eib.fetchWayGeometry(1));
-        assertEquals(Helper.createPointList(12, 12), eib.fetchWayGeometry(2));
+        assertEquals(Helper.createPointList3D(), eib.fetchWayGeometry(0));
+        assertEquals(Helper.createPointList3D(11, 20, 1), eib.fetchWayGeometry(1));
+        assertEquals(Helper.createPointList3D(12, 12, 0.4), eib.fetchWayGeometry(2));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(2)));
     }
 
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
index 261860313d..e624d5ce83 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageWithTurnCostsTest.java
@@ -33,12 +33,12 @@
  */
 public class GraphHopperStorageWithTurnCostsTest extends GraphHopperStorageTest
 {
-    private TurnCostStorage turnCostStorage;
+    private TurnCostExtension turnCostStorage;
 
     @Override
     protected GraphStorage newGraph( Directory dir, boolean is3D )
     {
-        turnCostStorage = new TurnCostStorage();
+        turnCostStorage = new TurnCostExtension();
         return new GraphHopperStorage(dir, encodingManager, is3D, turnCostStorage);
     }
 
@@ -48,26 +48,28 @@ protected GraphStorage newRAMGraph()
         return newGraph(new RAMDirectory(), false);
     }
 
+    @Override
     @Test
-    public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
+    public void testSave_and_fileFormat() throws IOException
     {
-        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGraph(new RAMDirectory(defaultGraphLoc, true), true).create(defaultSize);
         NodeAccess na = graph.getNodeAccess();
-        na.setNode(0, 10, 10);
-        na.setNode(1, 11, 20);
-        na.setNode(2, 12, 12);
+        assertTrue(na.is3D());
+        na.setNode(0, 10, 10, 0);
+        na.setNode(1, 11, 20, 1);
+        na.setNode(2, 12, 12, 0.4);
 
         EdgeIteratorState iter2 = graph.edge(0, 1, 100, true);
-        iter2.setWayGeometry(Helper.createPointList(1.5, 1, 2, 3));
+        iter2.setWayGeometry(Helper.createPointList3D(1.5, 1, 0, 2, 3, 0));
         EdgeIteratorState iter1 = graph.edge(0, 2, 200, true);
-        iter1.setWayGeometry(Helper.createPointList(3.5, 4.5, 5, 6));
+        iter1.setWayGeometry(Helper.createPointList3D(3.5, 4.5, 0, 5, 6, 0));
         graph.edge(9, 10, 200, true);
         graph.edge(9, 11, 200, true);
         graph.edge(1, 2, 120, false);
 
-        turnCostStorage.addTurnInfo(0, iter1.getEdge(), iter2.getEdge(), 1337);
-        turnCostStorage.addTurnInfo(0, iter2.getEdge(), iter1.getEdge(), 666);
-        turnCostStorage.addTurnInfo(1, iter1.getEdge(), iter2.getEdge(), 815);
+        turnCostStorage.addTurnInfo(iter1.getEdge(), 0, iter2.getEdge(), 1337);
+        turnCostStorage.addTurnInfo(iter2.getEdge(), 0, iter1.getEdge(), 666);
+        turnCostStorage.addTurnInfo(iter1.getEdge(), 1, iter2.getEdge(), 815);
 
         iter1.setName("named street1");
         iter2.setName("named street2");
@@ -76,7 +78,7 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         graph.flush();
         graph.close();
 
-        graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
+        graph = newGraph(new MMapDirectory(defaultGraphLoc), true);
         assertTrue(graph.loadExisting());
 
         assertEquals(12, graph.getNodes());
@@ -85,17 +87,18 @@ public void testSave_and_fileFormat_withTurnCostEntries() throws IOException
         assertEquals("named street1", graph.getEdgeProps(iter1.getEdge(), iter1.getAdjNode()).getName());
         assertEquals("named street2", graph.getEdgeProps(iter2.getEdge(), iter2.getAdjNode()).getName());
 
-        assertEquals(1337, turnCostStorage.getTurnCostFlags(0, iter1.getEdge(), iter2.getEdge()));
-        assertEquals(666, turnCostStorage.getTurnCostFlags(0, iter2.getEdge(), iter1.getEdge()));
-        assertEquals(815, turnCostStorage.getTurnCostFlags(1, iter1.getEdge(), iter2.getEdge()));
-        assertEquals(0, turnCostStorage.getTurnCostFlags(3, iter1.getEdge(), iter2.getEdge()));
+        assertEquals(1337, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 0, iter2.getEdge()));
+        assertEquals(666, turnCostStorage.getTurnCostFlags(iter2.getEdge(), 0, iter1.getEdge()));
+        assertEquals(815, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 1, iter2.getEdge()));
+        assertEquals(0, turnCostStorage.getTurnCostFlags(iter1.getEdge(), 3, iter2.getEdge()));
 
-        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList(4.4, 5.5, 6.6, 7.7));
+        graph.edge(3, 4, 123, true).setWayGeometry(Helper.createPointList3D(4.4, 5.5, 0, 6.6, 7.7, 0));
         checkGraph(graph);
     }
 
     @Test
-    public void testEnsureCapacity() throws IOException {
+    public void testEnsureCapacity() throws IOException
+    {
         graph = newGraph(new MMapDirectory(defaultGraphLoc), false);
         graph.setSegmentSize(128);
         graph.create(100); // 100 is the minimum size
@@ -106,7 +109,8 @@ public void testEnsureCapacity() throws IOException {
         Random r = new Random();
 
         NodeAccess na = graph.getNodeAccess();
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 100; i++)
+        {
             double randomLat = 90 * r.nextDouble();
             double randomLon = 180 * r.nextDouble();
 
@@ -114,23 +118,26 @@ public void testEnsureCapacity() throws IOException {
         }
 
         // Make node 50 the 'center' node
-        for (int nodeId = 51; nodeId < 100; nodeId++) {
+        for (int nodeId = 51; nodeId < 100; nodeId++)
+        {
             graph.edge(50, nodeId, r.nextDouble(), true);
         }
-        for (int nodeId = 0; nodeId < 50; nodeId++) {
+        for (int nodeId = 0; nodeId < 50; nodeId++)
+        {
             graph.edge(nodeId, 50, r.nextDouble(), true);
         }
 
         // add 100 turn cost entries around node 50
-        for (int edgeId = 0; edgeId < 50; edgeId++) {
-            turnCostStorage.addTurnInfo(50, edgeId, edgeId + 50, 1337);
-            turnCostStorage.addTurnInfo(50, edgeId + 50, edgeId, 1337);
+        for (int edgeId = 0; edgeId < 50; edgeId++)
+        {
+            turnCostStorage.addTurnInfo(edgeId, 50, edgeId + 50, 1337);
+            turnCostStorage.addTurnInfo(edgeId + 50, 50, edgeId, 1337);
         }
 
-        turnCostStorage.addTurnInfo(50, 0, 1, 1337);
+        turnCostStorage.addTurnInfo(0, 50, 1, 1337);
         assertEquals(104, turnCostStorage.getCapacity() / 16); // we are still good here
 
-        turnCostStorage.addTurnInfo(50, 0, 2, 1337);
+        turnCostStorage.addTurnInfo(0, 50, 2, 1337);
         // A new segment should be added, which will support 128 / 16 = 8 more entries.
         assertEquals(112, turnCostStorage.getCapacity() / 16);
     }
diff --git a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
index cad468fb81..0fbc9477e4 100644
--- a/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/LevelGraphStorageTest.java
@@ -17,14 +17,15 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.LevelEdgeFilter;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeSkipIterState;
-import com.graphhopper.util.GHUtility;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
 import static org.junit.Assert.*;
 import org.junit.Test;
 
@@ -46,7 +47,7 @@ public GraphStorage newGraph( Directory dir, boolean is3D )
     }
 
     @Test
-    public void testCannotBeLoadedViaDifferentClass()
+    public void testCannotBeLoadedWithNormalGraphHopperStorageClass()
     {
         GraphStorage g = newGraph(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
         g.flush();
@@ -63,12 +64,15 @@ public void testCannotBeLoadedViaDifferentClass()
 
         g = newGraph(new RAMDirectory(defaultGraphLoc, true), false);
         assertTrue(g.loadExisting());
+        // empty graph still has invalid bounds
+        assertEquals(g.getBounds(), BBox.createInverse(false));
     }
 
     @Test
     public void testPriosWhileDeleting()
     {
         LevelGraphStorage g = createGraph();
+        g.getNodeAccess().ensureNode(19);
         for (int i = 0; i < 20; i++)
         {
             g.setLevel(i, i);
@@ -77,13 +81,14 @@ public void testPriosWhileDeleting()
         g.optimize();
         assertEquals(9, g.getLevel(9));
         assertNotSame(10, g.getLevel(10));
-        assertEquals(19, g.getNodes());
     }
 
     @Test
     public void testPrios()
     {
         LevelGraph g = createGraph();
+        g.getNodeAccess().ensureNode(30);
+
         assertEquals(0, g.getLevel(10));
 
         g.setLevel(10, 100);
@@ -180,7 +185,7 @@ public void testGetWeight()
         flags = carEncoder.setProperties(10, false, true);
         sc1.setFlags(flags);
         sc1.setWeight(100.123);
-        assertEquals(100.123, sc1.getWeight(), 1e-3);        
+        assertEquals(100.123, sc1.getWeight(), 1e-3);
         assertFalse(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_FORWARD));
         assertTrue(carEncoder.isBool(sc1.getFlags(), FlagEncoder.K_BACKWARD));
     }
@@ -207,4 +212,47 @@ public void testGetWeightIfAdvancedEncoder()
         sc1.setWeight(1.011011);
         assertEquals(1.011011, sc1.getWeight(), 1e-3);
     }
+
+    @Test
+    public void testQueryGraph()
+    {
+        LevelGraph levelGraph = createGraph();
+        NodeAccess na = levelGraph.getNodeAccess();
+        na.setNode(0, 1.00, 1.00);
+        na.setNode(1, 1.02, 1.00);
+        na.setNode(2, 1.04, 1.00);
+
+        EdgeIteratorState edge1 = levelGraph.edge(0, 1);
+        EdgeIteratorState edge2 = levelGraph.edge(1, 2);
+        levelGraph.shortcut(0, 1);
+        
+        QueryGraph qGraph = new QueryGraph(levelGraph);
+        QueryResult fromRes = createQR(1.004, 1.01, 0, edge1);
+        QueryResult toRes = createQR(1.019, 1.00, 0, edge1);
+        qGraph.lookup(fromRes, toRes);
+
+        Graph oGraph = qGraph.getBaseGraph();
+        EdgeExplorer explorer = oGraph.createEdgeExplorer();
+
+        assertTrue(levelGraph.getNodes() < qGraph.getNodes());
+        assertTrue(oGraph.getNodes() == qGraph.getNodes());
+
+        // traverse virtual edges and normal edges but no shortcuts!
+        assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
+        assertEquals(GHUtility.asSet(toRes.getClosestNode(), 2), GHUtility.getNeighbors(explorer.setBaseNode(1)));
+
+        // get neighbors from virtual nodes
+        assertEquals(GHUtility.asSet(0, toRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(fromRes.getClosestNode())));
+        assertEquals(GHUtility.asSet(1, fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(toRes.getClosestNode())));
+    }
+
+    QueryResult createQR( double lat, double lon, int wayIndex, EdgeIteratorState edge )
+    {
+        QueryResult res = new QueryResult(lat, lon);
+        res.setClosestEdge(edge);
+        res.setWayIndex(wayIndex);
+        res.setSnappedPosition(QueryResult.Position.EDGE);
+        res.calcSnappedPoint(Helper.DIST_PLANE);
+        return res;
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index cf996add31..e447b1c058 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -74,7 +74,7 @@ public void testSimpleGraph()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 8);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -128,7 +128,7 @@ public void testSimpleGraph2()
         Graph g = createGraph(new EncodingManager("CAR"));
         initSimpleGraph(g);
 
-        idx = createIndex(g, 28);
+        idx = createIndex(g, -1);
         assertEquals(4, idx.findID(5, 2));
         assertEquals(3, idx.findID(1.5, 2));
         assertEquals(0, idx.findID(-1, -1));
@@ -153,7 +153,7 @@ public void testGrid()
         Graph g = createSampleGraph(new EncodingManager("CAR"));
         int locs = g.getNodes();
 
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
         // if we would use less array entries then some points gets the same key so avoid that for this test
         // e.g. for 16 we get "expected 6 but was 9" i.e 6 was overwritten by node j9 which is a bit closer to the grid center        
         // go through every point of the graph if all points are reachable
@@ -211,7 +211,7 @@ boolean testGridIgnore( int i )
     public void testSinglePoints120()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 120);
+        idx = createIndex(g, -1);
 
         assertEquals(1, idx.findID(1.637, 2.23));
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -227,7 +227,7 @@ public void testSinglePoints120()
     public void testSinglePoints32()
     {
         Graph g = createSampleGraph(new EncodingManager("CAR"));
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
 
         // 10 or 6
         assertEquals(10, idx.findID(3.649, 1.375));
@@ -355,7 +355,7 @@ public void testDifferentVehicles()
         final EncodingManager encodingManager = new EncodingManager("CAR,FOOT");
         Graph g = createGraph(encodingManager);
         initSimpleGraph(g);
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         assertEquals(1, idx.findID(1, -1));
 
         // now make all edges from node 1 accessible for CAR only
@@ -367,7 +367,7 @@ public void testDifferentVehicles()
         }
         idx.close();
 
-        idx = createIndex(g, 32);
+        idx = createIndex(g, -1);
         FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("FOOT");
         assertEquals(2, idx.findClosest(1, -1, new DefaultEdgeFilter(footEncoder)).getClosestNode());
         Helper.close((Closeable) g);
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index 801367d298..bb43cef11b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -33,13 +33,16 @@
     @Override
     public LocationIndex createIndex( Graph g, int resolution )
     {
-        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).setResolution(resolution).prepareIndex();
+        if(resolution < 0)
+            resolution = 120;
+        return new Location2IDQuadtree(g, new MMapDirectory(location + "loc2idIndex")).
+                setResolution(resolution).prepareIndex();
     }
 
     @Test
     public void testNormedDist()
     {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager()), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGraph(new EncodingManager("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
similarity index 85%
rename from core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
rename to core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
index 0b59bcb6c9..0f3c93d92b 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeSCTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeForLevelGraphTest.java
@@ -40,15 +40,23 @@
 /**
  * @author Peter Karich
  */
-public class LocationIndexTreeSCTest extends LocationIndexTreeTest
+public class LocationIndexTreeForLevelGraphTest extends LocationIndexTreeTest
 {
     @Override
-    public LocationIndexTreeSC createIndex( Graph g, int resolution )
+    public LocationIndexTree createIndex( Graph g, int resolution )
+    {
+        if (resolution < 0)
+            resolution = 500000;
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
+    }
+
+    @Override
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
-        LocationIndexTreeSC idx = new LocationIndexTreeSC((LevelGraph) g, dir);
-        idx.setResolution(1000000).prepareIndex();
-        return idx;
+        LocationIndexTree tmpIdx = new LocationIndexTree(g.getBaseGraph(), dir);
+        tmpIdx.setResolution(resolution);
+        return tmpIdx;
     }
 
     @Override
@@ -99,6 +107,7 @@ public void testLevelGraph()
     public void testSortHighLevelFirst()
     {
         final LevelGraph lg = createGraph(new RAMDirectory(), encodingManager, false);
+        lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
         lg.setLevel(3, 20);
@@ -135,7 +144,7 @@ public void testLevelGraphBug()
         na.setNode(2, 0.5, 0.5);
         na.setNode(3, 0.5, 1);
         EdgeIteratorState iter1 = lg.edge(1, 0, 100, true);
-        EdgeIteratorState iter2 = lg.edge(2, 3, 100, true);
+        lg.edge(2, 3, 100, true);
 
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
@@ -147,15 +156,17 @@ public void testLevelGraphBug()
         // disconnect higher 3 from lower 2
         lg.disconnect(lg.createEdgeExplorer(), iter1);
 
-        LocationIndexTreeSC index = new LocationIndexTreeSC(lg, new RAMDirectory());
-        index.setResolution(100000);
-        index.prepareIndex();
+        LocationIndexTree index = createIndex(lg, 100000);
+
         // very close to 2, but should match the edge 0--1
         TIntHashSet set = index.findNetworkEntries(0.51, 0.2, index.maxRegionSearch);
+        assertEquals(0, index.findID(0.51, 0.2));
+        assertEquals(1, index.findID(0.1, 0.1));
+        assertEquals(2, index.findID(0.51, 0.51));
+        assertEquals(3, index.findID(0.51, 1.1));
         TIntSet expectedSet = new TIntHashSet();
-        expectedSet.add(1);
+        expectedSet.add(0);
         expectedSet.add(2);
         assertEquals(expectedSet, set);
-        assertEquals(0, index.findID(0.51, 0.2));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 8fcb543aad..f4a24cfc41 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -42,14 +42,16 @@
     @Override
     public LocationIndexTree createIndex( Graph g, int resolution )
     {
-        return internalCreateIndex(g, 500000);
+        if (resolution < 0)
+            resolution = 500000;        
+        return (LocationIndexTree) createIndexNoPrepare(g, resolution).prepareIndex();
     }
 
-    public LocationIndexTree internalCreateIndex( Graph g, int minMeter )
+    public LocationIndexTree createIndexNoPrepare( Graph g, int resolution )
     {
         Directory dir = new RAMDirectory(location);
         LocationIndexTree tmpIDX = new LocationIndexTree(g, dir);
-        tmpIDX.setResolution(minMeter).prepareIndex();
+        tmpIDX.setResolution(resolution);
         return tmpIDX;
     }
 
@@ -87,7 +89,7 @@ Graph createTestGraph()
     public void testSnappedPointAndGeometry()
     {
         Graph graph = createTestGraph();
-        LocationIndex index = createIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         // query directly the tower node
         QueryResult res = index.findClosest(-0.4, 0.9, EdgeFilter.ALL_EDGES);
         assertEquals(new GHPoint(-0.4, 0.9), res.getSnappedPoint());
@@ -103,8 +105,8 @@ public void testSnappedPointAndGeometry()
     public void testInMemIndex()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 50000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
 
@@ -144,8 +146,8 @@ public void testInMemIndex()
     public void testInMemIndex2()
     {
         Graph graph = createTestGraph2();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(500).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(graph, 500);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(4, 4), index.getEntries());
         assertEquals(3, inMemIndex.getEntriesOf(0).size());
@@ -181,9 +183,8 @@ public void testInMemIndex2()
     @Test
     public void testInMemIndex3()
     {
-        Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMinResolutionInMeter(10000).prepareAlgo();
+        LocationIndexTree index = createIndexNoPrepare(createTestGraph(), 10000);
+        index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
         assertEquals(Helper.createTList(64, 4), index.getEntries());
 
@@ -202,8 +203,7 @@ public void testInMemIndex3()
     @Test
     public void testReverseSpatialKey()
     {
-        LocationIndexTree index = new LocationIndexTree(createTestGraph(), new RAMDirectory());
-        index.setMinResolutionInMeter(200).prepareAlgo();
+        LocationIndexTree index = createIndex(createTestGraph(), 200);
         assertEquals(Helper.createTList(64, 64, 64, 4), index.getEntries());
 
         // 10111110111110101010
@@ -224,7 +224,7 @@ public void testMoreReal()
         graph.edge(1, 0, 1000, true);
         graph.edge(0, 2, 1000, true);
         graph.edge(0, 3, 1000, true).setWayGeometry(Helper.createPointList(51.21, 9.43));
-        LocationIndex index = internalCreateIndex(graph, 1000);
+        LocationIndex index = createIndex(graph, -1);
         assertEquals(2, index.findID(51.2, 9.4));
     }
 
@@ -261,7 +261,7 @@ private Graph createTestGraphWithWayGeometry()
     public void testWayGeometry()
     {
         Graph g = createTestGraphWithWayGeometry();
-        LocationIndex index = createIndex(g, 1000);
+        LocationIndex index = createIndex(g, -1);
         assertEquals(1, index.findID(0, 0));
         assertEquals(1, index.findID(0, 0.1));
         assertEquals(1, index.findID(0.1, 0.1));
@@ -289,7 +289,7 @@ public void testFindingWayGeometry()
     public void testEdgeFilter()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = createIndex(graph, 1000);
+        LocationIndexTree index = createIndex(graph, -1);
 
         assertEquals(1, index.findClosest(-.6, -.6, EdgeFilter.ALL_EDGES).getClosestNode());
         assertEquals(2, index.findClosest(-.6, -.6, new EdgeFilter()
@@ -402,9 +402,7 @@ Graph createTestGraph2()
     public void testRMin()
     {
         Graph graph = createTestGraph();
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-        index.setMaxRegionSearch(1);
-        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree index = createIndex(graph, 50000);
 
         //query: 0.05 | -0.3
         DistanceCalc distCalc = new DistancePlaneProjection();
diff --git a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
index 80d19d350a..e47b52da9d 100644
--- a/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
+++ b/core/src/test/java/com/graphhopper/util/AngleCalcTest.java
@@ -52,6 +52,9 @@ public void testCombined()
     {
         double orientation = ac.calcOrientation(52.414918, 13.244221, 52.415333, 13.243595);
         assertEquals(146.5, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
+
+        orientation = ac.calcOrientation(52.414918, 13.244221, 52.414573, 13.243627);
+        assertEquals(-149.7, Math.toDegrees(ac.alignOrientation(0, orientation)), 1);
     }
 
     @Test
@@ -69,7 +72,7 @@ public void testAzimuthCompassPoint()
     {
         assertEquals("S", ac.azimuth2compassPoint(199));
     }
-    
+
     @Test
     public void testAtan2()
     {
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
index 3f12d3d8e3..4c8f3b0928 100644
--- a/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalcEarthTest.java
@@ -130,6 +130,9 @@ public void testValidEdgeDistance()
         assertFalse(dc.validEdgeDistance(49.944482, 11.555446, 49.937964, 11.541824, 49.942272, 11.555643));
         // right bottom of the edge
         assertFalse(dc.validEdgeDistance(49.94085, 11.557356, 49.937964, 11.541824, 49.942272, 11.555643));
+
+        // rounding error
+        // assertFalse(dc.validEdgeDistance(0.001, 0.001, 0.001, 0.002, 0.00099987, 0.00099987));
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index 026f4866c0..a9a8e09991 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -111,7 +111,7 @@ public void testCopyWithSelfRef()
         LevelGraph lg = new GraphBuilder(encodingManager).levelGraphCreate();
         GHUtility.copyTo(g, lg);
 
-        assertEquals(g.getAllEdges().getMaxId(), lg.getAllEdges().getMaxId());
+        assertEquals(g.getAllEdges().getCount(), lg.getAllEdges().getCount());
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index cbb923f8d3..79b9fc9f95 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -25,26 +25,21 @@
 import com.graphhopper.reader.OSMWay;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.ShortestWeighting;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
-import com.graphhopper.storage.NodeAccess;
-import java.io.StringReader;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.storage.*;
+import java.io.*;
 import java.util.*;
 import javax.xml.XMLConstants;
-import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.transform.Source;
-import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
+
+import org.json.JSONObject;
 import org.junit.Test;
 import static org.junit.Assert.*;
-import org.xml.sax.InputSource;
+import org.junit.Before;
 import org.xml.sax.SAXException;
 
 /**
@@ -56,12 +51,19 @@
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation usTR = trMap.getWithFallBack(Locale.US);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+    
+    @Before
+    public void setUp() {
+        carEncoder = new CarFlagEncoder();
+        carManager = new EncodingManager(carEncoder);
+    }
 
     @SuppressWarnings("unchecked")
     @Test
     public void testWayList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {                
         Graph g = new GraphBuilder(carManager).create();
         // 0-1-2
         // | | |
@@ -107,17 +109,13 @@ public void testWayList()
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 10);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 10);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Continue onto 4-7",
                 "Turn left onto 7-8", "Continue onto 8-9", "Turn right", "Finish!"),
                 tmpList);
 
-        List<String> distStrings = wayList.createDistances(true);
-        assertEquals(Arrays.asList("6.21 mi", "6.21 mi", "6.21 mi", "6.21 mi", "12.43 mi", "6.21 mi", "0 ft"),
-                distStrings);
-
         wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Geradeaus auf 0-1", "Rechts abbiegen auf 1-4", "Geradeaus auf 4-7",
@@ -125,9 +123,6 @@ public void testWayList()
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
-        distStrings = wayList.createDistances(false);
-        assertEquals(Arrays.asList("10.0 km", "10.0 km", "10.0 km", "10.0 km", "20.0 km", "10.0 km", "0 m"),
-                distStrings);
 
         List<GPXEntry> gpxes = wayList.createGPXList();
         assertEquals(10, gpxes.size());
@@ -144,7 +139,6 @@ public void testWayList()
                 asL(1.0, 1.2), asL(1.1, 1.3), asL(1.1, 1.4)),
                 wayList.createStartPoints());
 
-        FlagEncoder carEncoder = carManager.getSingle();
         p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
         assertEquals(Helper.createTList(6, 7, 8, 5, 2), p.calcNodes());
@@ -154,10 +148,14 @@ public void testWayList()
         assertEquals(Arrays.asList("Continue onto 6-7", "Continue onto 7-8", "Turn left onto 5-8", "Continue onto 5-2", "Finish!"),
                 tmpList);
 
-        // assertEquals(Arrays.asList(0, 1, 4, 5, 6), wayList.createPointIndices());
-        // tmpList = createList(p.calcPoints(), wayList.createPointIndices());
         compare(Arrays.asList(asL(1d, 1d), asL(1d, 1.1), asL(1d, 1.2), asL(1.1, 1.2), asL(1.2, 1.2)),
                 wayList.createStartPoints());
+
+        // special case of identical start and end
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 0);
+        wayList = p.calcInstructions(usTR);
+        assertEquals(1, wayList.size());
+        assertEquals("Finish!", wayList.get(0).getTurnDescription(usTR));
     }
 
     List<String> pick( String key, List<Map<String, Object>> instructionJson )
@@ -215,7 +213,6 @@ void compare( List<List<Double>> expected, List<List<Double>> was )
     @Test
     public void testWayList2()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -237,14 +234,14 @@ public void testWayList2()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
 
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Finish!"),
                 tmpList);
 
-        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(3, 5);
+        p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(3, 5);
         wayList = p.calcInstructions(usTR);
         tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto 3-4", "Continue onto 4-5", "Finish!"),
@@ -255,7 +252,6 @@ public void testWayList2()
     @Test
     public void testNoInstructionIfSameStreet()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   2
         //    \.  5
@@ -277,7 +273,7 @@ public void testNoInstructionIfSameStreet()
         list.add(10.20, 10.05);
         iter.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(2, 3);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(2, 3);
         InstructionList wayList = p.calcInstructions(usTR);
         List<String> tmpList = pick("text", wayList.createJson());
         assertEquals(Arrays.asList("Continue onto street", "Finish!"), tmpList);
@@ -286,7 +282,6 @@ public void testNoInstructionIfSameStreet()
     @Test
     public void testInstructionsWithTimeAndPlace()
     {
-        EncodingManager carManager = new EncodingManager("CAR");
         Graph g = new GraphBuilder(carManager).create();
         //   4-5
         //   |
@@ -305,7 +300,7 @@ public void testInstructionsWithTimeAndPlace()
         g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
         g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
 
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(1, 5);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(1, 5);
         InstructionList wayList = p.calcInstructions(usTR);
         assertEquals(5, wayList.size());
 
@@ -338,14 +333,66 @@ public void testInstructionsWithTimeAndPlace()
         assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T01:00:00+01:00</time>"));
         assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
         assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
-        assertTrue(gpxStr, gpxStr.contains("<distance>8000.0</distance>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
         assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
 
-        assertTrue(gpxStr, gpxStr.contains("<direction>N</direction>"));
-        assertTrue(gpxStr, gpxStr.contains("<azimuth>0</azimuth>"));
         assertFalse(gpxStr, gpxStr.contains("NaN"));
     }
 
+    @Test
+    public void testRoundaboutJsonIntegrity()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setDirOfRotation(-0.1)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        // assert that all information is present in map for JSON
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
+        assertEquals("2", json.get("exit_number").toString());
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
+    // Roundabout with unknown dir of rotation
+    @Test
+    public void testRoundaboutJsonNaN()
+    {
+        InstructionList il = new InstructionList(usTR);
+
+        PointList pl = new PointList();
+        pl.add(52.514, 13.349);
+        pl.add(52.5135, 13.35);
+        pl.add(52.514, 13.351);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                new InstructionAnnotation(0, ""), pl)
+                .setRadian(-Math.PI + 1)
+                .setExitNumber(2)
+                .setExited();
+        il.add(instr);
+
+        Map<String, Object> json = il.createJson().get(0);
+        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
+        assertNull(json.get("turn_angle"));
+        // assert that a valid JSON object can be written
+        assertNotNull(new JSONObject(json).toString());
+    }
+
     @Test
     public void testCreateGPXWithEle()
     {
@@ -415,26 +462,27 @@ private long flagsForSpeed( EncodingManager encodingManager, int speedKmPerHour
 
     @Test
     public void testEmptyList()
-    {
-        EncodingManager carManager = new EncodingManager("CAR");
+    {        
         Graph g = new GraphBuilder(carManager).create();
-        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), tMode).calcPath(0, 1);
+        Path p = new Dijkstra(g, carEncoder, new ShortestWeighting(), tMode).calcPath(0, 1);
         InstructionList il = p.calcInstructions(usTR);
         assertEquals(0, il.size());
         assertEquals(0, il.createStartPoints().size());
     }
 
     public void verifyGPX( String gpx )
-    {        
+    {
         SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
         Schema schema = null;
         try
         {
             Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
             schema = schemaFactory.newSchema(schemaFile);
+
+            // using more schemas: http://stackoverflow.com/q/1094893/194609
         } catch (SAXException e1)
         {
-            throw new IllegalStateException("There was a problem with the schema supplied for validation.");
+            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
         }
         Validator validator = schema.newValidator();
         try
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index 0e7e4c52ef..f65170813b 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -27,45 +27,48 @@
 public class InstructionTest
 {
     @Test
-    public void testGetAzimuthAndGetDirection()
+    public void testCalcAzimuthAndGetDirection()
     {
         InstructionAnnotation ea = InstructionAnnotation.EMPTY;
         PointList pl = new PointList();
         pl.add(49.942, 11.584);
-        pl.add(49.942, 11.582);
-        Instruction i1 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000);
+        
+        PointList nextPl = new PointList();
+        nextPl.add(49.942, 11.582);
+        Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl);
+        Instruction nextI = new Instruction(Instruction.CONTINUE_ON_STREET, "next", ea, nextPl);
 
-        assertEquals("270", i1.getAzimuth(null));
-        assertEquals("W", i1.getDirection(null));
+        assertEquals(270, currI.calcAzimuth(nextI), .1);
+        assertEquals("W", currI.calcDirection(nextI));
 
         PointList p2 = new PointList();
         p2.add(49.942, 11.580);
         p2.add(49.944, 11.582);
-        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2).setDistance(240).setTime(15000);
+        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2);
 
-        assertEquals("45", i2.getAzimuth(null));
-        assertEquals("NE", i2.getDirection(null));
+        assertEquals(45, i2.calcAzimuth(null), .1);
+        assertEquals("NE", i2.calcDirection(null));
 
         PointList p3 = new PointList();
         p3.add(49.942, 11.580);
         p3.add(49.944, 11.580);
-        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3).setDistance(240).setTime(15000);
+        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3);
 
-        assertEquals("0", i3.getAzimuth(null));
-        assertEquals("N", i3.getDirection(null));
+        assertEquals(0, i3.calcAzimuth(null), .1);
+        assertEquals("N", i3.calcDirection(null));
 
         PointList p4 = new PointList();
         p4.add(49.940, 11.580);
         p4.add(49.920, 11.586);
-        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4).setDistance(240).setTime(15000);
+        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4);
 
-        assertEquals("S", i4.getDirection(null));
+        assertEquals("S", i4.calcDirection(null));
 
         PointList p5 = new PointList();
         p5.add(49.940, 11.580);
-        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5).setDistance(240).setTime(15000);
+        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5);
 
-        assertEquals("", i5.getAzimuth(null));
-        assertEquals("", i5.getDirection(null));
+        assertTrue(Double.isNaN(i5.calcAzimuth(null)));
+        assertEquals("", i5.calcDirection(null));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index 8103d03698..7bd65b5213 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -41,6 +41,9 @@ public void testToString()
 
         Translation ruMap = SINGLETON.getWithFallBack(new Locale("ru"));
         assertEquals("Пешком", ruMap.tr("web.FOOT"));
+        
+        Translation zhMap = SINGLETON.getWithFallBack(new Locale("vi", "VI"));
+        assertEquals("Đi bộ", zhMap.tr("web.FOOT"));
 
         trMap = SINGLETON.get("de_DE");
         assertEquals("Zu Fuß", trMap.tr("web.FOOT"));
diff --git a/core/src/test/resources/com/graphhopper/routing/test-graph.svg b/core/src/test/resources/com/graphhopper/routing/test-graph.svg
index 54ada32f02..c9c1adc45e 100644
--- a/core/src/test/resources/com/graphhopper/routing/test-graph.svg
+++ b/core/src/test/resources/com/graphhopper/routing/test-graph.svg
@@ -13,7 +13,7 @@
    height="297mm"
    id="svg2"
    version="1.1"
-   inkscape:version="0.48.3.1 r9886"
+   inkscape:version="0.48.4 r9939"
    sodipodi:docname="test-graph.svg">
   <defs
      id="defs4" />
@@ -25,15 +25,15 @@
      inkscape:pageopacity="0.0"
      inkscape:pageshadow="2"
      inkscape:zoom="0.98994949"
-     inkscape:cx="184.29981"
+     inkscape:cx="186.32012"
      inkscape:cy="855.76121"
      inkscape:document-units="px"
      inkscape:current-layer="layer1"
      showgrid="false"
      inkscape:window-width="1600"
-     inkscape:window-height="1105"
+     inkscape:window-height="1136"
      inkscape:window-x="0"
-     inkscape:window-y="31"
+     inkscape:window-y="0"
      inkscape:window-maximized="1" />
   <metadata
      id="metadata7">
@@ -191,7 +191,7 @@
          sodipodi:role="line"
          id="tspan3008"
          x="104.04571"
-         y="51.30101">(6)</tspan></text>
+         y="51.30101">(111)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -202,7 +202,7 @@
          sodipodi:role="line"
          id="tspan3012"
          x="47.477169"
-         y="67.463455">(7)</tspan></text>
+         y="67.463455">(111)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -213,7 +213,7 @@
          sodipodi:role="line"
          id="tspan3016"
          x="97.984795"
-         y="81.605591">(2)</tspan></text>
+         y="81.605591">(89)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -224,7 +224,7 @@
          sodipodi:role="line"
          id="tspan3020"
          x="119.19799"
-         y="111.91016">(8)</tspan></text>
+         y="111.91016">(89)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -235,18 +235,18 @@
          sodipodi:role="line"
          id="tspan3024"
          x="86.873123"
-         y="153.32642">(2)</tspan></text>
+         y="153.32642">(89)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
-       x="156.57364"
-       y="160.39749"
+       x="147.48227"
+       y="157.36703"
        id="text3026"
        sodipodi:linespacing="125%"><tspan
          sodipodi:role="line"
          id="tspan3028"
-         x="156.57364"
-         y="160.39749">(5)</tspan></text>
+         x="147.48227"
+         y="157.36703">(22)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -257,7 +257,7 @@
          sodipodi:role="line"
          id="tspan3032"
          x="215.16249"
-         y="180.60054">(2)</tspan></text>
+         y="180.60054">(57)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -268,7 +268,7 @@
          sodipodi:role="line"
          id="tspan3036"
          x="228.29448"
-         y="136.15382">(2)</tspan></text>
+         y="136.15382">(70)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -279,7 +279,7 @@
          sodipodi:role="line"
          id="tspan3040"
          x="309.10669"
-         y="137.16399">(10)</tspan></text>
+         y="137.16399">(70)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -290,40 +290,40 @@
          sodipodi:role="line"
          id="tspan3044"
          x="268.70059"
-         y="105.84925">(1)</tspan></text>
+         y="105.84925">(79)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
-       x="209.10158"
-       y="96.757874"
+       x="208.09143"
+       y="95.747719"
        id="text3046"
        sodipodi:linespacing="125%"><tspan
          sodipodi:role="line"
          id="tspan3048"
-         x="209.10158"
-         y="96.757874">(2)</tspan></text>
+         x="208.09143"
+         y="95.747719">(79)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
-       x="157.58379"
-       y="103.82895"
+       x="153.54318"
+       y="102.81879"
        id="text3050"
        sodipodi:linespacing="125%"><tspan
          sodipodi:role="line"
          id="tspan3052"
-         x="157.58379"
-         y="103.82895">(7)</tspan></text>
+         x="153.54318"
+         y="102.81879">(101)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
-       x="227.28432"
-       y="67.463455"
+       x="221.2234"
+       y="66.4533"
        id="text3054"
        sodipodi:linespacing="125%"><tspan
          sodipodi:role="line"
          id="tspan3056"
-         x="227.28432"
-         y="67.463455">(4)</tspan></text>
+         x="221.2234"
+         y="66.4533">(101)</tspan></text>
     <text
        xml:space="preserve"
        style="font-size:16px;font-style:normal;font-weight:normal;line-height:125%;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;font-family:Sans"
@@ -334,6 +334,6 @@
          sodipodi:role="line"
          id="tspan3060"
          x="307.08636"
-         y="75.544678">(5)</tspan></text>
+         y="75.544678">(103)</tspan></text>
   </g>
 </svg>
diff --git a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd b/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
index 1ede4ba6bf..58cfdeb1ba 100644
--- a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
+++ b/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
@@ -2,7 +2,7 @@
 <xsd:schema
     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
     xmlns="http://www.topografix.com/GPX/1/1"
-    targetNamespace="http://www.topografix.com/GPX/1/1"
+    targetNamespace="http://www.topografix.com/GPX/1/1"    
     elementFormDefault="qualified">
 
     <xsd:annotation>
@@ -478,15 +478,15 @@
                 You can add extend GPX by adding your own elements from another schema here.
             </xsd:documentation>
         </xsd:annotation>
+        <!-- as we need separate namespace 'gh' could not get it working with proper validation :( so ignoring this for now-->
         <xsd:sequence>
-            <xsd:element name="distance" type="xsd:decimal"	minOccurs="0">                
-            </xsd:element>
-            <xsd:element name="time" type="xsd:nonNegativeInteger"	minOccurs="0">
-            </xsd:element>
-            <xsd:element name="direction" type="xsd:string"		minOccurs="0">                
-            </xsd:element>
-            <xsd:element name="azimuth"	type="xsd:string"		minOccurs="0">                
-            </xsd:element>
+            <xsd:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded">
+                <xsd:annotation>
+                    <xsd:documentation>
+                        You can add extend GPX by adding your own elements from another schema here.
+                    </xsd:documentation>
+                </xsd:annotation>
+            </xsd:any>
         </xsd:sequence>
     </xsd:complexType>
 
diff --git a/docs/android/android-studio-setup.md b/docs/android/android-studio-setup.md
new file mode 100644
index 0000000000..2e455b0867
--- /dev/null
+++ b/docs/android/android-studio-setup.md
@@ -0,0 +1,20 @@
+# Open Demo App with Android Studio
+
+Get the [GraphHopper sources and demo](./index.md) before you proceed.
+
+## Setup
+
+[Download](http://developer.android.com/sdk/index.html) and start android studio
+
+Open existing Android studio project and then open 'graphhopper/android' not the parent 'graphhopper'
+
+![Open Existing](./images/android-studio-open-existing.png)
+
+Import project from Gradle, but make sure the 'Gradle project' points to graphhopper/android
+
+![Import project from Gradle](./images/android-studio-import-project-from-gradle.png)
+
+## Start Demo
+
+ 1. Connect your device in development mode (USB debugging)
+ 2. Then hit SHIFT+F10 or click Run->Run 'app' in the menu
diff --git a/docs/android/images/android-studio-import-project-from-gradle.png b/docs/android/images/android-studio-import-project-from-gradle.png
new file mode 100644
index 0000000000..2b4aacf171
Binary files /dev/null and b/docs/android/images/android-studio-import-project-from-gradle.png differ
diff --git a/docs/android/images/android-studio-open-existing.png b/docs/android/images/android-studio-open-existing.png
new file mode 100644
index 0000000000..9e5891ef3f
Binary files /dev/null and b/docs/android/images/android-studio-open-existing.png differ
diff --git a/docs/android/index.md b/docs/android/index.md
index ae02db1b3a..db67b378d7 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -1,11 +1,13 @@
-## Get Demo
+# Get Demo
 
 [Download GraphHopper Demo APK](http://graphhopper.com/#download)
 
-## Set-up Development
-As starting point you can use [the demo project](https://github.com/graphhopper/graphhopper/tree/master/android) which can be used from Eclipse or NetBeans via maven command line.
+# Set-up Development
 
-### Before installation
+As starting point you can use [the demo project](https://github.com/graphhopper/graphhopper/tree/master/android) 
+which can be used from Android Studio, NetBeans, gradle or maven.
+
+Before the installation fetch the source, the OpenStreetMap data and the dependencies:
 
 ```bash
 $ git clone git://github.com/graphhopper/graphhopper.git graphhopper
@@ -13,21 +15,29 @@ $ cd graphhopper
 $ ./graphhopper.sh import your-area.pbf
 ```
 
-And go to the Android SDK Manager and install at least 2.3 (API 9)
+## Android Studio
+
+Please read [here](./android-studio-setup.md) for a detailed instruction.
+
+## None-Android Studio
+
+Download the [Android SDK](http://developer.android.com/sdk/installing/index.html?pkg=tools) and 
+go to the Android SDK Manager and install at least 2.3 (API 9).
 
-**Either via Maven and Command line -> use this for NetBeans**
+### Maven or NetBeans
  1. Download [Maven SDK Deployer](https://github.com/mosabua/maven-android-sdk-deployer) and execute `mvn install -P 2.3` - it uses [Android Maven Plugin](http://code.google.com/p/maven-android-plugin/wiki/GettingStarted) under the hood where you need to set up ANDROID_HOME
  2. Now do `./graphhopper.sh android`
 
-**Or Eclipse**
+### Gradle
 
-Import Sources as Android project. If you want to customize graphhopper itself do:
- 1. `cd graphhopper; ./graphhopper.sh eclipse`
- 2. Refresh your Eclipse project and use it.
-
-See [this](https://lists.openstreetmap.org/pipermail/graphhopper/2013-November/000501.html) for the discussion.
+```bash
+$ cd graphhopper/android
+$ ./gradlew clean build
+# push to device, start manually
+$ gradle installDebug
+```
 
-**Maps**
+## Maps
 
 Now that you have a running android app you need to copy somehow the routing and maps data. 
 
diff --git a/docs/core/ch.md b/docs/core/ch.md
index 32cdbda276..4d55a5c847 100644
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -6,14 +6,6 @@ In GraphHopper CH is enabled by default but can be easily disabled.
 To make CH work in GraphHopper a LevelGraphStorage instead of the normal GraphStorage 
 is necessary which allows to store shortcuts too.
 
-After a graph is prepared it cannot be used for graph exploration anymore, this is
-a limitation of the preparation and storage and is handled in issue #116.
-Due to that limitation a special location index is necessary (LocationIndexTreeSC).
-
-Also at the moment only one vehicle can be used if CH is enabled, see issue #111.
-
-So, if you still need graph exploration for your LevelGraphStorage you can specify 
-graphHopper.doPrepare(false) before you call importOrLoad, which avoids the CH preparation.
-Then do your graph explorations or whatever and store the graph.
-If you call importOrLoad next time without doPrepare(false) the CH-preparation will be done.
+A prepared graph can also be used for normal graph traversal IF you use graph.getBaseGraph().
 
+If CH is enabled multiple vehicles will work but only one works in speed-up mode and is faster, see issue #111.
diff --git a/docs/core/eclipse-setup.md b/docs/core/eclipse-setup.md
new file mode 100644
index 0000000000..eb2093e9a2
--- /dev/null
+++ b/docs/core/eclipse-setup.md
@@ -0,0 +1,153 @@
+Getting started with GraphHopper in Eclipse
+=========
+This manual covers step by step instructions on setting up a development and run environment for GraphHopper (web App only) using Eclipse. The instructions and tools used are platform independent and should be applicable for windows, Linux and Mac operating systems. 
+Instructions for Android branch will be provided in future.
+
+The first part of this document covers configuring Eclipse for cloning and importing GraphHopper repository. Setting up Apache Tomcat server and configuring it to run GraphHopper will be covered in subsequent documents.
+
+###1. Download Eclipse
+
+The first step is to download latest version of Eclipse. We recommend that you download the ["Eclipse IDE for Java EE Developers"](http://www.eclipse.org/downloads/) package, instead of the package "for Java developers", as it includes many of the necessary plugins for webapp and API development.  
+
+**Note:** Make sure you grab the correct 32-bit or 64-bit version, depending on your machine and the version of the java installed in your computer. If for example you have a 32 bit java in your x64 machine, you still need to download a 32 bit version of eclipse or you may get an error while trying to open the eclipse.exe file.
+
+**Note:** GraphHopper is set to run with JRE 1.6. This document is written based on setting Eclipse Luna using JRE 1.6.  It may also work with newer versions of JRE, but it has not been tested yet.
+
+
+###2.	Eclipse Addition al Plugins
+Before getting started, you'll need to have a few Eclipse plugins installed to help with development. GraphHopper is versioned using Git and its build process and dependencies are managed by Maven, so certain additional Eclipse components will be needed to tie everything together:
+
+*	A git plugin, a popular choice is [EGit](http://eclipse.org/egit/) which is an "Eclipse team provider" (i.e. version control system plugin) for Git.
+*	The Eclipse Maven plugin, [m2eclipse](http://www.eclipse.org/m2e/) which adds Maven support to Eclipse, for editing project models and (automatically) running builds
+*	If you want to work on the web interfaces you also need [Web Tools Platform (WTP)](http://www.eclipse.org/webtools/)
+
+**Note**: EGit, WTP, and m2eclipse (as of version 1.0) are hosted by the [Eclipse foundation](http://www.eclipse.org/org/), and they are bundled with some packages of Eclipse.
+
+###3.	Configuring Eclipse with additional plugins
+Depending on the Eclipse package you chose, you may need to install one or more of the Eclipse components mentioned previously. You should be able to add all the needed components using either the "Install new software" dialog or the "Eclipse marketplace" component available under Eclipse's help menu. 
+
+####3.1. Using Eclipse Marketplace
+The Eclipse Marketplace seems to do a good job with EGit, m2eclipse (also referred to as m2e or "Maven Integration for Eclipse"), and m2e-wtp ("Maven Integration for Eclipse WTP").
+
+You should take the below steps to install your needed components:
+
+* In Eclipse, under _help_ menu, choose _Eclipse Marketplace_. 
+
+* In the opened window, search all _markets/all categories_ and in the _find_ dialoge box type the name of the needed component and click on _Go_ button:
+
+ * Search for “egit” if you need “EGIT” and “EGit – Git Team Provider” should be among first items to appear.
+ 
+ * Search for “maven” or “m2eclipse” if you need “m2eclipse” and “m2eclipse – "Maven Integration for Eclipse” should be among first items to appear. 
+   
+ * Search for “wtp” if you need “m2e-wtp” and “m2eclipse – "Maven Integration for Eclipse WTP” should be among first items to appear. 
+
+*   Click on _Install_ button. Please note if the component is already installed then there are two other buttons available instead of _Install_. _Update_ if there is an update for the component and _Uninstall_. For example in picture below the user has tried to install EGit using market place, while it has already been included in the package. 
+
+![](./images/egit.png)
+
+*	The Web Tools components can in fact be installed via the Eclipse Marketplace system, but they will not be found in a search unless you switch to the "EclipseSource Yoxos Marketplace" instead of the "Eclipse marketplace". This is accomplished by clicking on the Orange circle icon next to the purple Eclipse icon at the bottom of the Marketplace dialog box. 
+
+
+####3.2. Using “Install New Software…” Option
+Alternatively, you can use the “Install New Software” option under the _help_ menu to install the needed components. Also if you do happen to miss some web development components try “Install New Software Option” instead of the “Marketplace”. 
+
+Based on needed components take the below steps:
+ 
+*	To install “EGit” in the "Work with:" dialog box, type the EGit server address  at http://download.eclipse.org/egit/updates. Select Eclipse Git Team Provider and JGit form option and click _Next_ and _Finish_ install.
+ 
+![](./images/egit2.png)  
+
+*	To install “m2e” In the "Work with:" dialog box, type the me2eclipse server address at http://download.eclipse.org/technology/m2e/releases. Select Maven Integration for Eclipse form option and click _Next_ and _Finish_ install. 
+
+![](./images/maven.png) 
+
+*	Also if you do happen to miss some web development components,   in the "Work with:" dialog box, type your eclipse server version (e.g. luna) address at http://download.eclipse.org/releases/luna and try  checking the "Web, XML, Java EE, and OSGi Enterprise Development" category, which should include everything you need.  
+
+
+###4.	Clone and import the GraphHopper Source
+At this step you need to clone the GraphHopper GitHub repository locally (get a copy of the GraphHopper source code). Repository cloning can be done using one of the below approaches:
+
+1. EGit Repositories View from within Eclipse
+
+2. Command-line Git tools. Once they are cloned into the local filesystem, the Maven projects in the GraphHopper Git repository can then be imported into Eclipse. 
+
+3. The clone and import operations can be done together using _File -> Import -> Maven -> Import Maven projects from SCM in Eclipse_.
+ 
+**Note:** When the initial clone operation is not done using the clone button in the EGit Repositories View (For example if it is done using command-line Git or "Import Maven projects from SCM"), you  need to inform Eclipse that your project is under Git version control if you want to do pull / push / commit operations from within Eclipse. In any case you can just perform these operations using command-line Git tools.
+
+**Note:**  It is suggested that repositories should be cloned somewhere outside your Eclipse workspace to avoid any misinterpretation or misuse of Git metadata by Eclipse and vice-versa. 
+
+Below we talk more about the first and third approaches of cloning.
+
+
+####4.1. Approach 1: Clone the GraphHopper repository with the EGit Repositories View
+
+* Switch to the "Git Repository Exploring" perspective in Eclipse by selecting:  _Window -> Open Perspective -> Git Repositories_ .
+If you don't see this option under "Open Perspective", choose:  _Window -> Open Perspective -> Other..._ and select "Git Repository Exploring". 
+
+![](./images/clone1.png)
+
+The "Repository Exploring perspective" is preconfigured to contain the Git Repositories view. Alternatively, you can add the Git Repositories view to your main Java perspective: _Window -> Show View -> Other -> Git Repositories_. 
+
+* In the Git Repositories view, click on the "Clone a Git Repository and add clone to this view" button as shown below:
+
+![](./images/clone2.png)
+
+* Enter https://github.com/graphhopper/graphhopper/ for the URI, select "HTTPS" for the protocol. Entering the GitHub username and password is not necessary for cloning the repository. However, if you want to contribute edits back, you'll need to enter your GitHub username and password here too.
+
+![](./images/clone3.png)
+
+* Click _Next_, then select all branches (the “master” branch is probably what need).
+
+* Click _Next_, then select the directory where you want the code to be checked out to. Then click _Finish_. It will take Eclipse a minute or two to download the source to your computer, and then the GraphHopper repository should appear in the "Git Repositories" panel. 
+
+**Note:** An alternate and easy way to this approach is to manually download the GraphHopper zip file directly from GitHub and save it in a local drive in your machine.
+
+**Note:** You still need to import the GraphHopper Maven projects from the local clone of the repository into Eclipse (see Importing existing GraphHopper Maven projects into Eclipse part).
+
+
+
+####4.2. Importing existing GraphHopper Maven projects into Eclipse
+
+If you used approach 1 or if you have downloaded the GraphHopper zip file directly form GitHub, you have cloned the GraphHopper repository but the GraphHopper Maven projects are not yet visible in Eclipse. To make the projects visible,cover the below steps:
+
+* Choose the menu option _File -> Import, and then browse to the Maven / Existing Maven Projects element_.
+
+![](./images/import1.png)
+
+* Browse to the local directory where you cloned the GraphHopper Git repository, and then select all the projects of interest.
+
+![](./images/import2.png)
+
+* Click _Finish_. It may take a while to initially build all the projects in your workspace. In the background, the Maven plugin is downloading all the project dependencies. If everything works fine you should be able to see each GraphHopper maven module checked out as an individual Eclipse project in your workspace.
+
+####4.3. Approach 2: Clone the GraphHopper repository and import Maven projects all at once
+To use this method follow the below steps:
+* In Eclipse, choose _File -> Import..._ then choose _Maven / Check out Maven projects from SCM_ in the dialog box, as shown below:
+
+![](./images/clone4.png)
+
+* Click _Next_, then confirm that you are using the Git version control sytstem using the dropdown box next to the label "SCM URL". 
+
+**Note:** The first time you use this option, this "git" option will probably not be available because an m2e/git connector must be installed. Use the blue "m2e marketplace" link in the lower right corner of this dialog box to find and install the m2e Maven SCM handler for Egit,  and the 'git' option should become available in the drop-down box.
+
+* specify the "Target Location" (in this case, the URL of the remote Github repository that you want to clone locally), as shown in below figure. This URL should be https://github.com/graphhopper/graphhopper/
+
+![](./images/clone5.png)
+
+* Click _Next_, then uncheck "Use default workspace location" and specify a directory outside your Eclipse workspace (e.g. ~/git). Your cloned copy of the repository will be placed in a subdirectory of the specified directory, with a rather uninformative name (e.g. ~/git/ maven.1424033308371).
+
+* Click _Finish_, and m2eclipse should both clone the repository and import the Maven projects into your workspace. The Graphhopper top-level maven module, as well as all the other sub-modules, should then appear in your project explorer view. 
+
+####4.4 Making Eclipse aware of your local GraphHopper Git repository
+
+If you use approach 2 or a command-line method, EGit will not be aware of the Git metadata in the new local repository. Therefore operations on the local Git repository will not automatically be possible from within Eclipse.You can choose to do all Git operations on the command line, or make EGit aware of the repository as follows: 
+
+*	Right-click the top-level GraphHopper project in the Project Explorer view and choose _Team -> Share Project_.
+
+*	Specify Git as the repository type and check Use or create repository in parent folder of project on the next page. The .git metadata directory should be found and indicated in the dialog box. At this point you can click the _Finish_ button. An orange cylinder should appear on the GraphHopper folder icon in the "Package Explorer", indicating that it is under version control.
+
+Now, you should be able to open the Git repositories view: _Window -> Show View -> Other -> Git Repositories_, and do push, pull, and commit operations in Eclipse. The advantage of this method over the command line is using EGit's graphical diff window which allows you to review changes and select files to commit.
+
+
+
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
new file mode 100644
index 0000000000..d973969aa5
--- /dev/null
+++ b/docs/core/elevation.md
@@ -0,0 +1,40 @@
+# Elevation
+
+Per default elevation is disabled. But you can easily enable it:
+`graph.elevation.provider=cgiar`
+or
+`graph.elevation.provider=srtm`
+
+then GraphHopper will automatically download the necessary data for the area and include elevation 
+for all vehicles - making also the distances a bit more precise. 
+
+The default cache directory (/tmp/srtm) will be used. For large areas it is highly recommended to 
+use a SSD disc, thus you need to specify the cache directory:
+`graph.elevation.cachedir=/myssd/ele_cache/`
+
+## What to download and where to store it? 
+
+All should work automatically. Another setting is to specify the location where the files are 
+downloaded - e.g. if the servers are not reachable, then you set:
+`graph.elevation.baseurl`
+
+E.g. for CGIAR there are two URLs you can use: `http://droppr.org/srtm/v4.1/6_5x5_TIFs` and
+`http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/`
+where the last one is only accessibly if you specify the 
+[full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
+
+If the area is small and you need a faster import you can change the default MMAP setting to:
+`graph.elevation.dataaccess=RAM_STORE`
+
+## CGIAR vs. SRTM
+
+The CGIAR data is preferred because of the quality but is in general not public domain. 
+But we got a license for our and our users' usage: https://graphhopper.com/public/license/CGIAR.txt
+
+Using SRTM instead CGIAR has the minor advantage of a faster download, especially for smaller areas.
+
+## Custom Elevation Data
+
+Integrating your own elevation data is easy and just requires you to implement the
+ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
diff --git a/docs/core/images/clone1.png b/docs/core/images/clone1.png
new file mode 100644
index 0000000000..b05ec6fc9f
Binary files /dev/null and b/docs/core/images/clone1.png differ
diff --git a/docs/core/images/clone2.png b/docs/core/images/clone2.png
new file mode 100644
index 0000000000..7a8297f4a1
Binary files /dev/null and b/docs/core/images/clone2.png differ
diff --git a/docs/core/images/clone3.png b/docs/core/images/clone3.png
new file mode 100644
index 0000000000..d5a76bfe93
Binary files /dev/null and b/docs/core/images/clone3.png differ
diff --git a/docs/core/images/clone4.png b/docs/core/images/clone4.png
new file mode 100644
index 0000000000..b89d2a0ee3
Binary files /dev/null and b/docs/core/images/clone4.png differ
diff --git a/docs/core/images/clone5.png b/docs/core/images/clone5.png
new file mode 100644
index 0000000000..abef84335e
Binary files /dev/null and b/docs/core/images/clone5.png differ
diff --git a/docs/core/images/egit.png b/docs/core/images/egit.png
new file mode 100644
index 0000000000..b7b9ab7a61
Binary files /dev/null and b/docs/core/images/egit.png differ
diff --git a/docs/core/images/egit2.png b/docs/core/images/egit2.png
new file mode 100644
index 0000000000..1fad659389
Binary files /dev/null and b/docs/core/images/egit2.png differ
diff --git a/docs/core/images/import1.png b/docs/core/images/import1.png
new file mode 100644
index 0000000000..76c746f7ba
Binary files /dev/null and b/docs/core/images/import1.png differ
diff --git a/docs/core/images/import2.png b/docs/core/images/import2.png
new file mode 100644
index 0000000000..a384664bb6
Binary files /dev/null and b/docs/core/images/import2.png differ
diff --git a/docs/core/images/maven.png b/docs/core/images/maven.png
new file mode 100644
index 0000000000..2177c5296f
Binary files /dev/null and b/docs/core/images/maven.png differ
diff --git a/docs/core/location-index.md b/docs/core/location-index.md
index 9fa25b7c7a..69a18b839a 100644
--- a/docs/core/location-index.md
+++ b/docs/core/location-index.md
@@ -12,19 +12,12 @@ QueryResult qr = findClosest(lat, lon, EdgeFilter.ALL_EDGES );
 EdgeIteratorState edge = qr.getClosestEdge();
 ```
 
-If you don't use the GraphHopper class you have to handle every case on your own to build a location index.
-E.g. if it is a LevelGraph you need LocationIndexTreeSC otherwise LocationIndexTree:
+If you don't use the GraphHopper class you have to use the low level API:
 
 ```java
-LocationIndexTree tmpIndex;
-if (graph instanceof LevelGraph)
-   tmpIndex = new LocationIndexTreeSC((LevelGraph) graph, dir);
-else
-   tmpIndex = new LocationIndexTree(graph, dir);
-
-tmpIndex.setResolution(preciseIndexResolution);
-tmpIndex.setSearchRegion(searchRegion);
-// now build the index if it cannot be loaded
-if (!tmpIndex.loadExisting())
-   tmpIndex.prepareIndex();
+LocationIndexTree index = new LocationIndexTree(graph.getBaseGraph(), dir);
+index.setResolution(preciseIndexResolution);
+index.setMaxRegionSearch(maxRegionSearch);
+if (!index.loadExisting())
+    index.prepareIndex();
 ```
\ No newline at end of file
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index f4f37617b2..3fb61ae58e 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -4,6 +4,21 @@ If you just start to use GraphHopper please refer to [routing docs](./routing.md
 or [the quickstart for developers](./quickstart-from-source.md)
 and come back here later if the higher level API does not suit your needs.
 
+### What are pillar and tower nodes?
+
+From road network sources like OpenStreetMap we fetch all nodes and create the routing graph but 
+only a sub-set of them are actual junctions, which are the ones we are interested in while routing.
+
+Those junction nodes (and end-standing nodes of dead alleys) we call *tower nodes* which also 
+have a graphhopper node ID associated, going from 0 to graph.getNodes(). 
+The helper nodes between the junctions we call 'pillar nodes' which can be fetched via
+`edgeIteratorState.fetchWayGeometry(0)`. Avoiding the traversal of pillar nodes while routing makes 
+routing a lot faster (~8 times).
+
+That splitting into pillar and tower nodes is also the reason why there can't be a unique mapping from 
+one OSM node ID to exactly one GraphHopper node ID. And as one OSM Way is often splitted into multiple 
+edges the same applies for edge IDs too.
+
 ### Create and save the graph
 
 ```java
@@ -25,7 +40,7 @@ graph.flush();
 ...
 GraphStorage graph = gb.load();
 // Load index
-LocationIndex index = new LocationIndexTree(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location index cannot be loaded!");
 ```
@@ -69,7 +84,7 @@ graph.flush();
 GraphStorage graph = gb.load();
 
  // Load index
-Location2IDIndex index = new LocationIndexTreeSC(graph, new RAMDirectory("graphhopper-folder", true));
+LocationIndex index = new LocationIndexTree(graph.getBaseGraph(), new RAMDirectory("graphhopper-folder", true));
 if (!index.loadExisting())
     throw new IllegalStateException("location2id index cannot be loaded!");
 
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index 2070687b2f..f6cab16714 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -76,7 +76,7 @@ For simplicity you could just start jetty from maven and schedule it as backgrou
 Then the service will be accessible on port 11111.
 
 For production usage you can install the latest jetty (8 or 9) as a service but we prefer to have it bundled as a 
-simple jar. Tomcat should work too. To create a war file do `mvn clean war:war` and copy it from the target/ 
+simple jar. Tomcat should work too. To create a war file do `mvn clean install war:war` and copy it from the target/ 
 folder to your jetty installation. Then copy web/config.properties also there and change this properties 
 file to point to the required graphhopper folder. Increase the Xmx/Xms values of your jetty server e.g. 
 for world wide coverage with a hierarchical graph I do the following in bin/jetty.sh
@@ -128,4 +128,4 @@ Have a look in the more [technical documentation](./technical.md) or the [low le
 Further Links
 ---------------
  * [Spatial Key](http://karussell.wordpress.com/2012/05/23/spatial-keys-memory-efficient-geohashes/)
- * [Author@Twitter](https://twitter.com/timetabling)
\ No newline at end of file
+ * [Author@Twitter](https://twitter.com/timetabling)
diff --git a/docs/core/routing.md b/docs/core/routing.md
index 9239980a41..5c6da786bd 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -46,9 +46,16 @@ List<String> iList = il.createDescription(tr);
 List<GPXEntry> list = il.createGPXList();
 ```
 
-If you want a more flexible routing (but slower) you can disable contraction hierarchies
-and import multiple vehicles. Then pick one vehicle and optionally the algorithm like
-astar as algorithm:
+If you want to support multiple profiles you have to specify the default vehicle in order
+to pick the vehicle where contraction hierarchies will be enabled:
+```java
+GraphHopper hopper = new GraphHopper().forServer();
+hopper.setDefaultVehicle("car");
+...
+```
+
+If you want a more flexible routing (but slower) you can disable contraction hierarchies. 
+Then pick one vehicle to route on and optionally the algorithm like 'bidirectional astar' as algorithm:
 
 ```java
 GraphHopper hopper = new GraphHopper().forServer();
@@ -60,14 +67,20 @@ hopper.setEncodingManager(new EncodingManager("car,bike"));
 
 hopper.importOrLoad();
 
-GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).setVehicle("bike").setAlgorithm("astar");
+GHRequest req = new GHRequest(latFrom, lonFrom, latTo, lonTo).
+    setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR_BI);
 GHResponse res = hopper.route(req);
 ```
 
-In case you need the online routing API in a Java or Android application the GraphHopperWeb comes handy - see the 'web' sub module.
+In case you need a web access in a Java or an Android application the GraphHopperWeb class comes handy,
+ see the 'web' sub module.
 
 ```java
 GraphHopperAPI gh = new GraphHopperWeb();
 gh.load("http://your-graphhopper-service.com");
+
+// or for the GraphHopper Directions API https://graphhopper.com/#directions-api
+// gh.load("https://graphhopper.com/api/1/route");
+
 GHResponse rsp = gh.route(new GHRequest(...));
 ```
\ No newline at end of file
diff --git a/docs/core/technical.md b/docs/core/technical.md
index 5cc0ea1372..4b45a58200 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -54,14 +54,12 @@ For [_Contraction Hierarchies_](http://ad-wiki.informatik.uni-freiburg.de/teachi
  we use the _LevelGraph_ which additionally holds shortcuts. While path extraction we need to identify those
  shortcuts and get the edges recursivly, this is done in Path4CH.
 
-## 3.1 OriginalGraph
-
-See issue [#116](https://github.com/graphhopper/graphhopper/issues/116) for the progress of this feature.
+## 3.1 Base Graph
 
 In order to traverse the _LevelGraph_ like a normal _Graph_ one needs to hide the shortcuts, which
-is done automatically for you if you call graph.getOriginalGraph(). This is necessary in a 
-_LocationIndex_ and partially in the _Path_ class in order to identify how many streets leave a junction
-or similar. See #116 for more information.
+is done automatically for you if you call graph.getBaseGraph(). This is necessary in a 
+_LocationIndex_ and in the _Path_ class in order to identify how many streets leave a junction
+or similar. See issue #116 for more information.
 
 
 ### 4. Connecting the Real World to the Graph
diff --git a/docs/core/translations.md b/docs/core/translations.md
index 30b9265a18..4f7d6eb502 100644
--- a/docs/core/translations.md
+++ b/docs/core/translations.md
@@ -3,7 +3,11 @@
 You can help improve GraphHopper by adding your language!
 
 See [this spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AmukcXek0JP6dGM4R1VTV2d3TkRSUFVQakhVeVBQRHc#gid=0)
-and add a column for your language. Revisit it regularly to update or add new items.
+and add a column for your language. Revisit it regularly to update or add new items. And see your language live at GraphHopper Maps e.g. explicitely specify the locale via:
+
+[https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de](https://graphhopper.com/maps/?point=40.979898%2C-3.164062&point=39.909736%2C-2.8125&locale=de) 
+
+de -> German, en -> Englisch, zh -> Simplified Chinese, ...
 
 ## Questions
 
@@ -33,4 +37,4 @@ want to try your changes or want to speed up the integration you can do the foll
 
 ## License Agreement
 
-Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
\ No newline at end of file
+Please sign the <a href="http://www.clahub.com/agreements/graphhopper/graphhopper">GraphHopper License Agreement</a>.
diff --git a/docs/index.md b/docs/index.md
index a170ce92c4..587a244dfe 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -1,17 +1,40 @@
-Users
----------------
+# Users
+
  * [Read Overview](http://graphhopper.com/#overview)
- * [Add GraphHopper Maps to your Browser](./web/open-search.md)
- * [GraphHopper on Twitter](https://twitter.com/graphhopp)
  * [Quickstart](./web/quickstart.md) for users
+ * [Add GraphHopper Maps to your Browser](./web/open-search.md)
+ * [GraphHopper on Twitter](https://twitter.com/graphhopper)
+
+# Translators
+
+* [Translations](./core/translations.md)
+
+
+# Developers
 
-Developers
---------------- 
  * [Quickstart](./core/quickstart-from-source.md) for developers with git checkout and IDE setup etc
-   * [Android](./android/index.md)
-   * [Windows](./core/windows-setup.md)
- * [Translations](./core/translations.md)
- * [Slides from FOSDEM 2014](http://graphhopper.com/public/slides/)
+ * [Android](./android/index.md)
+ * [Windows](./core/windows-setup.md)
+ * [Set up and run GraphHopper in Eclipse](./core/eclipse-setup.md)
+ * [iOS](https://github.com/graphhopper/graphhopper-ios/)
+
+## Core
+
+ * [Simple routing](./core/routing.md) to integrate GraphHopper in your Java application (or pick any JVM language)
+ * [Create custom weighting](./core/weighting.md)
+ * [Elevation](./core/elevation.md)
+ * [Technical overview](./core/technical.md)
+ * [Slides from 2014](http://graphhopper.com/public/slides/)
+ * [Contraction Hierarchies](./core/ch.md)
+
+## Web
+
+ * [Routing API](./web/api-doc.md)
+ 
+## Advanced Topics
+
+ * [Low level API](./core/low-level-api.md)
+ * [Create new FlagEncoder](./core/create-new-flagencoder.md)
+ * [LocationIndex](./core/location-index.md)
  * [World-Wide-Road-Network](./core/world-wide.md)
  * [Changelog](https://github.com/graphhopper/graphhopper/blob/master/core/files/changelog.txt)
-
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index dc9733d0a9..328585b83d 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -116,14 +116,16 @@ paths[0].instructions[0].text                 | A description what the user has
 paths[0].instructions[0].distance             | The distance for this instruction, in meter
 paths[0].instructions[0].time                 | The duration for this instruction, in ms
 paths[0].instructions[0].interval             | An array containing the first and the last index (relative to paths[0].points) of the points for this instruction. This is useful to know for which part of the route the instructions are valid.
-paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5
+paths[0].instructions[0].sign                 | A number which specifies the sign to show e.g. for right turn etc <br>TURN_SHARP_LEFT = -3<br>TURN_LEFT = -2<br>TURN_SLIGHT_LEFT = -1<br>CONTINUE_ON_STREET = 0<br>TURN_SLIGHT_RIGHT = 1<br>TURN_RIGHT = 2<br>TURN_SHARP_RIGHT = 3<br>FINISH = 4<br>VIA_REACHED = 5<br>USE_ROUNDABOUT = 6
 paths[0].instructions[0].annotationText       | [optional] A text describing the instruction in more detail, e.g. like surface of the way, warnings or involved costs
 paths[0].instructions[0].annotationImportance | [optional] 0 stands for INFO, 1 for warning, 2 for costs, 3 for costs and warning
+paths[0].instructions[0].exit_number          | [optional] Only available for USE_ROUNDABOUT instructions. The count of exits at which the route leaves the roundabout.
+paths[0].instructions[0].turn_angle           | [optional] Only available for USE_ROUNDABOUT instructions. The radian of the route within the roundabout: 0<r<2*PI for clockwise and -2PI<r<0 for counterclockwise transit. Is null the direction of rotation is undefined.
 
 
 ## Area information
 
-If you need to find out defails about the area or need to ping the service use '/info'
+If you need to find out details about the area or need to ping the service use '/info'
 
 [http://localhost:8989/info](http://localhost:8989/info)
 
@@ -171,6 +173,6 @@ info.errors[0].message | Not intended to be displayed to the user as it is curre
 
 HTTP error code | Reason
 :---------------|:------------
-500             | Internal server error. It is strongely recommended to send us the message and the link to it, as it is very likely a bug in our system.
+500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
diff --git a/graphhopper.sh b/graphhopper.sh
index 216f73529c..fa3141ed0f 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -3,13 +3,13 @@
 GH_CLASS=com.graphhopper.tools.Import
 GH_HOME=$(dirname "$0")
 JAVA=$JAVA_HOME/bin/java
-if [ "x$JAVA_HOME" = "x" ]; then
-JAVA=java
+if [ "$JAVA_HOME" = "" ]; then
+ JAVA=java
 fi
 
 vers=$($JAVA -version 2>&1 | grep "java version" | awk '{print $3}' | tr -d \")
 bit64=$($JAVA -version 2>&1 | grep "64-Bit")
-if [ "x$bit64" != "x" ]; then
+if [ "$bit64" != "" ]; then
   vers="$vers (64bit)"
 fi
 echo "## using java $vers from $JAVA_HOME"
@@ -22,13 +22,29 @@ fi
 ACTION=$1
 FILE=$2
 
-USAGE="./graphhopper.sh import|ui|test|measurement|miniui|extract|build <your-osm-file>"
-if [ "x$ACTION" = "x" ]; then
-echo -e "## action $ACTION not found. try \n$USAGE"
+function printUsage {
+ echo
+ echo "./graphhopper.sh import|web <your-osm-file>"
+ echo "./graphhopper.sh clean|build|help"
+ echo
+ echo "  help        this message"
+ echo "  import      creates the graphhopper files used for later (faster) starts"
+ echo "  web         starts a local server for user access at localhost:8989 and developer access at localhost:8989/route"
+ echo "  build       creates the graphhopper JAR (without the web module)"
+ echo "  clean       removes all JARs, necessary if you need to use the latest source (e.g. after switching the branch etc)"
+ echo "  measurement does performance analysis of the current source version via artificial, random routes (Measurement class)"
+ echo "  torture     can be used to test real world routes via feeding graphhopper logs into a graphhopper system (Torture class)"
+ echo "  miniui      is a simple Java/Swing application used for debugging purposes only (MiniGraphUI class)"
+ echo "  extract     calls the overpass API to easily grab any area as .osm file"
+}
+
+if [ "$ACTION" = "" ]; then
+ echo "## action $ACTION not found. try" 
+ printUsage
 fi
 
 function ensureOsmXml { 
-  if [ "x$OSM_FILE" = "x" ]; then
+  if [ "$OSM_FILE" = "" ]; then
     # skip
    return
   elif [ ! -s "$OSM_FILE" ]; then
@@ -61,17 +77,17 @@ function ensureOsmXml {
 
 function ensureMaven {
   # maven home existent?
-  if [ "x$MAVEN_HOME" = "x" ]; then
+  if [ "$MAVEN_HOME" = "" ]; then
     # not existent but probably is maven in the path?
     MAVEN_HOME=$(mvn -v | grep "Maven home" | cut -d' ' -f3)
-    if [ "x$MAVEN_HOME" = "x" ]; then
+    if [ "$MAVEN_HOME" = "" ]; then
       # try to detect previous downloaded version
       MAVEN_HOME="$GH_HOME/maven"
       if [ ! -f "$MAVEN_HOME/bin/mvn" ]; then
         echo "No Maven found in the PATH. Now downloading+installing it to $MAVEN_HOME"
         cd "$GH_HOME"
-        MVN_PACKAGE=apache-maven-3.2.3
-        wget -O maven.zip http://www.eu.apache.org/dist/maven/maven-3/3.2.3/binaries/$MVN_PACKAGE-bin.zip
+        MVN_PACKAGE=apache-maven-3.2.5
+        wget -O maven.zip http://archive.apache.org/dist/maven/maven-3/3.2.5/binaries/$MVN_PACKAGE-bin.zip
         unzip maven.zip
         mv $MVN_PACKAGE maven
         rm maven.zip
@@ -111,45 +127,46 @@ function packageCoreJar {
 function prepareEclipse {
 ensureMaven   
  packageCoreJar
-cp core/target/graphhopper-*-android.jar android/libs/   
+ # cp core/target/graphhopper-*-android.jar android/libs/   
 }
 
 
 ## now handle actions which do not take an OSM file
-if [ "x$ACTION" = "xclean" ]; then
-rm -rf ./*/target
-exit
+if [ "$ACTION" = "clean" ]; then
+ rm -rf ./*/target
+ exit
 
-elif [ "x$ACTION" = "xeclipse" ]; then
-prepareEclipse
-exit
+elif [ "$ACTION" = "eclipse" ]; then
+ prepareEclipse
+ exit
 
-elif [ "x$ACTION" = "xbuild" ]; then
-prepareEclipse
-exit  
+elif [ "$ACTION" = "build" ]; then
+ prepareEclipse
+ exit  
+ 
+elif [ "$ACTION" = "extract" ]; then
+ echo use "./graphhopper.sh extract \"left,bottom,right,top\""
+ URL="http://overpass-api.de/api/map?bbox=$2"
+ #echo "$URL"
+ wget -O extract.osm "$URL"
+ exit
  
-elif [ "x$ACTION" = "xextract" ]; then
-echo use "./graphhopper.sh extract \"left,bottom,right,top\""
-URL="http://overpass-api.de/api/map?bbox=$2"
-#echo "$URL"
-wget -O extract.osm "$URL"
-exit
-
-elif [ "x$ACTION" = "xandroid" ]; then
-prepareEclipse
-"$MAVEN_HOME/bin/mvn" -P include-android --projects android install android:deploy android:run
-exit
+elif [ "$ACTION" = "android" ]; then
+ prepareEclipse
+ "$MAVEN_HOME/bin/mvn" -P include-android --projects android install android:deploy android:run
+ exit
 fi
 
-if [ "x$FILE" = "x" ]; then
-  echo -e "no file specified? try \n$USAGE"
+if [ "$FILE" = "" ]; then
+  echo -e "no file specified? try"
+  printUsage
   exit
 fi
 
 # NAME = file without extension if any
 NAME="${FILE%.*}"
 
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    OSM_FILE=
 elif [ ${FILE: -4} == ".osm" ]; then
    OSM_FILE="$FILE"
@@ -179,7 +196,7 @@ VERSION=$(grep  "<name>" -A 1 pom.xml | grep version | cut -d'>' -f2 | cut -d'<'
 JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar
 
 LINK=$(echo $NAME | tr '_' '/')
-if [ "x$FILE" == "x-" ]; then
+if [ "$FILE" == "-" ]; then
    LINK=
 elif [ ${FILE: -4} == ".osm" ]; then 
    LINK="http://download.geofabrik.de/$LINK-latest.osm.bz2"
@@ -192,7 +209,7 @@ else
    LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 fi
 
-if [ "x$JAVA_OPTS" = "x" ]; then
+if [ "$JAVA_OPTS" = "" ]; then
   JAVA_OPTS="-Xmx1000m -Xms1000m -server"
 fi
 
@@ -203,9 +220,9 @@ packageCoreJar
 
 echo "## now $ACTION. JAVA_OPTS=$JAVA_OPTS"
 
-if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
+if [ "$ACTION" = "ui" ] || [ "$ACTION" = "web" ]; then
   export MAVEN_OPTS="$MAVEN_OPTS $JAVA_OPTS"
-  if [ "x$JETTY_PORT" = "x" ]; then  
+  if [ "$JETTY_PORT" = "" ]; then  
     JETTY_PORT=8989
   fi
   WEB_JAR="$GH_HOME/web/target/graphhopper-web-$VERSION-with-dep.jar"
@@ -221,54 +238,48 @@ if [ "x$ACTION" = "xui" ] || [ "x$ACTION" = "xweb" ]; then
 
   RC_BASE=./web/src/main/webapp
 
-  if [ "x$GH_FOREGROUND" = "x" ]; then
+  if [ "$GH_FOREGROUND" = "" ]; then
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
                 jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
                 config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
     # foreground => we never reach this here
   else
     exec "$JAVA" $JAVA_OPTS -jar "$WEB_JAR" jetty.resourcebase=$RC_BASE \
-                jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
-                config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE" <&- &
-    if [ "x$GH_PID_FILE" != "x" ]; then
+    	jetty.port=$JETTY_PORT jetty.host=$JETTY_HOST \
+    	config=$CONFIG $GH_WEB_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE" <&- &
+    if [ "$GH_PID_FILE" != "" ]; then
        echo $! > $GH_PID_FILE
     fi
     exit $?                    
   fi
 
-elif [ "x$ACTION" = "ximport" ]; then
-"$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true \
+elif [ "$ACTION" = "import" ]; then
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true \
       config=$CONFIG \
       $GH_IMPORT_OPTS graph.location="$GRAPH" osmreader.osm="$OSM_FILE"
 
 
-elif [ "x$ACTION" = "xtest" ]; then
-"$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS printVersion=true config=$CONFIG \
-               osmreader.wayPointMaxDistance=0 graph.location="$GRAPH" osmreader.osm="$OSM_FILE" prepare.chWeighting=false \
-                graph.testIT=true
-
-
-elif [ "x$ACTION" = "xtorture" ]; then
-"$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.QueryTorture $3 $4 $5 $6 $7 $8 $9
+elif [ "$ACTION" = "torture" ]; then
+ "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.tools.QueryTorture $3 $4 $5 $6 $7 $8 $9
 
 
-elif [ "x$ACTION" = "xminiui" ]; then
-"$MAVEN_HOME/bin/mvn" -f "$GH_HOME/tools/pom.xml" -DskipTests clean install assembly:single
-JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
+elif [ "$ACTION" = "xminiui" ]; then
+ "$MAVEN_HOME/bin/mvn" --projects tools -DskipTests clean install assembly:single
+ JAR=tools/target/graphhopper-tools-$VERSION-jar-with-dependencies.jar   
  "$JAVA" $JAVA_OPTS -cp "$JAR" com.graphhopper.ui.MiniGraphUI osmreader.osm="$OSM_FILE" printVersion=true config=$CONFIG \
               graph.location="$GRAPH"
 
 
-elif [ "x$ACTION" = "xmeasurement" ]; then
-ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=fastest graph.flagEncoders=CAR"
-# graph.doSort=true"
-echo -e "\ncreate graph via $ARGS, $JAR"
-START=$(date +%s)
-"$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false
-END=$(date +%s)
-IMPORT_TIME=$(($END - $START))
+elif [ "$ACTION" = "measurement" ]; then
+ ARGS="config=$CONFIG graph.location=$GRAPH osmreader.osm=$OSM_FILE prepare.chWeighting=fastest graph.flagEncoders=CAR"
+ echo -e "\ncreate graph via $ARGS, $JAR"
+ START=$(date +%s)
+ # avoid islands for measurement at all costs
+ "$JAVA" $JAVA_OPTS -cp "$JAR" $GH_CLASS $ARGS prepare.doPrepare=false prepare.minNetworkSize=10000 prepare.minOnewayNetworkSize=10000
+ END=$(date +%s)
+ IMPORT_TIME=$(($END - $START))
 
-function startMeasurement {
+ function startMeasurement {
     COUNT=5000
     commit_info=$(git log -n 1 --pretty=oneline)
     echo -e "\nperform measurement via jar=> $JAR and ARGS=> $ARGS"
@@ -280,9 +291,9 @@ function startMeasurement {
  # use all <last_commits> versions starting from HEAD
 last_commits=$3
   
- if [ "x$last_commits" = "x" ]; then
+ if [ "$last_commits" = "" ]; then
    # use current version
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    exit
 fi
@@ -295,7 +306,7 @@ for commit in $commits; do
    M_FILE_NAME="measurement$M_FILE_NAME.properties"
    echo -e "\nusing commit $commit and $M_FILE_NAME"
    
-   "$MAVEN_HOME/bin/mvn" -f "$GH_HOME/core/pom.xml" -DskipTests clean install assembly:single
+   "$MAVEN_HOME/bin/mvn" --projects core,tools -DskipTests clean install assembly:single
    startMeasurement
    echo -e "\nmeasurement.commit=$commit\n" >> "$M_FILE_NAME"
 done
diff --git a/pom.xml b/pom.xml
index e5894ad941..361a8e2ade 100644
--- a/pom.xml
+++ b/pom.xml
@@ -23,7 +23,7 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.7</slf4j.version>
+        <slf4j.version>1.7.10</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
         
         <!-- netbeans formatting rules -->
@@ -90,7 +90,7 @@
         <module>core</module>
         <module>tools</module>
         <module>web</module>
-	<module>acceptancetesting</module>
+	<!--<module>acceptancetesting</module>-->
     </modules>
         
     <build>        
@@ -107,6 +107,8 @@
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
                     -->
+                    
+                    <!-- suppress warning about Unsafe functionality -->
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
                 </configuration>
@@ -116,7 +118,7 @@
             <plugin>                
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.17</version>
+                <version>2.18.1</version>
                 <configuration>
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
@@ -125,7 +127,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.17</version>
+                <version>2.18.1</version>
                 <executions>
                     <execution>
                         <goals>
@@ -144,13 +146,27 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-javadoc-plugin</artifactId>
-                <version>2.10</version>
+                <version>2.10.1</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-source-plugin</artifactId>
-                <version>2.3</version>
+                <version>2.4</version>
             </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-assembly-plugin</artifactId>
+                <version>2.5.3</version>                    
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-jar-plugin</artifactId>
+                <version>2.5</version>
+            </plugin>
+            <plugin>
+                <artifactId>maven-war-plugin</artifactId>
+                <version>2.6</version>                
+            </plugin>            
         </plugins>
     </build>    
     
@@ -158,7 +174,7 @@
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
-            <version>4.11</version>
+            <version>4.12</version>
             <scope>test</scope>
         </dependency>        
     </dependencies>
@@ -199,7 +215,7 @@
                 <activeByDefault>false</activeByDefault>
             </activation>
             <modules>
-                <module>android</module>
+                <module>android/app</module>
             </modules>
         </profile>
     </profiles>
diff --git a/tools/pom.xml b/tools/pom.xml
index e0e2d7902c..594e6dc9f9 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -41,7 +41,7 @@
         <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-compress</artifactId>
-            <version>1.8.1</version>
+            <version>1.9</version>
         </dependency>
         <dependency>
         	<groupId>org.slf4j</groupId>
@@ -53,8 +53,7 @@
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-assembly-plugin</artifactId>
-                <version>2.4.1</version>
+                <artifactId>maven-assembly-plugin</artifactId>                
                 <configuration>
                     <archive>
                         <manifest>
diff --git a/tools/src/main/java/com/graphhopper/tools/Import.java b/tools/src/main/java/com/graphhopper/tools/Import.java
index c9b5a98195..1627869017 100644
--- a/tools/src/main/java/com/graphhopper/tools/Import.java
+++ b/tools/src/main/java/com/graphhopper/tools/Import.java
@@ -1,7 +1,6 @@
 package com.graphhopper.tools;
 
 import com.graphhopper.GraphHopper;
-import com.graphhopper.routing.util.RoutingAlgorithmSpecialAreaTests;
 import com.graphhopper.util.CmdArgs;
 
 /**
@@ -14,12 +13,6 @@ public static void main( String[] strs ) throws Exception
         CmdArgs args = CmdArgs.read(strs);
         GraphHopper hopper = new GraphHopper().init(args);
         hopper.importOrLoad();
-        if (args.getBool("graph.testIT", false))
-        {
-            // important: use osmreader.wayPointMaxDistance=0
-            RoutingAlgorithmSpecialAreaTests tests = new RoutingAlgorithmSpecialAreaTests(hopper);
-            tests.start();
-        }
         hopper.close();
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 9041b3f8e7..48fd784f85 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -79,12 +79,12 @@ public void doPostProcessing()
         {
             // re-create index to avoid bug as pickNode in locationIndex.prepare could be wrong while indexing if level is not taken into account and assumed to be 0 for pre-initialized graph            
             StopWatch sw = new StopWatch().start();
-            int edges = getGraph().getAllEdges().getMaxId();
-            initCHPrepare();
+            int edges = getGraph().getAllEdges().getCount();
+            setAlgorithmFactory(createPrepare());
             super.prepare();
             setLocationIndex(createLocationIndex(new RAMDirectory()));
             put("prepare.time", sw.stop().getTime());
-            put("prepare.shortcuts", getGraph().getAllEdges().getMaxId() - edges);
+            put("prepare.shortcuts", getGraph().getAllEdges().getCount() - edges);
         }
     }
 
@@ -108,7 +108,7 @@ void start( CmdArgs args )
         int count = args.getInt("measurement.count", 5000);
 
         MeasureHopper hopper = new MeasureHopper();
-        hopper.forDesktop().setEnableInstructions(false);
+        hopper.forDesktop();
         if (!hopper.load(graphLocation))
             throw new IllegalStateException("Cannot load existing levelgraph at " + graphLocation);
 
@@ -121,20 +121,21 @@ void start( CmdArgs args )
         try
         {
             maxNode = g.getNodes();
-            printGraphDetails(g);
+            printGraphDetails(g, vehicleStr);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
 
             // Route via dijkstrabi. Normal routing takes a lot of time => smaller query number than CH
             // => values are not really comparable to routingCH as e.g. the mean distance etc is different            
             hopper.setCHEnable(false);
-            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr);
+            printTimeOfRouteQuery(hopper, count / 20, "routing", vehicleStr, true);
 
             System.gc();
 
             // route via CH. do preparation before                        
             hopper.setCHEnable(true);
             hopper.doPostProcessing();
-            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr);
+            printTimeOfRouteQuery(hopper, count, "routingCH", vehicleStr, true);
+            printTimeOfRouteQuery(hopper, count, "routingCH_no_instr", vehicleStr, false);
             logger.info("store into " + propLocation);
         } catch (Exception ex)
         {
@@ -160,13 +161,13 @@ void start( CmdArgs args )
         }
     }
 
-    private void printGraphDetails( GraphStorage g )
+    private void printGraphDetails( GraphStorage g, String vehicleStr )
     {
         // graph size (edge, node and storage size)
         put("graph.nodes", g.getNodes());
-        put("graph.edges", g.getAllEdges().getMaxId());
+        put("graph.edges", g.getAllEdges().getCount());
         put("graph.sizeInMB", g.getCapacity() / Helper.MB);
-        put("graph.encoder", g.getEncodingManager().getSingle().toString());
+        put("graph.encoder", vehicleStr);
     }
 
     private void printLocationIndexQuery( Graph g, final LocationIndex idx, int count )
@@ -194,7 +195,8 @@ public int doCalc( boolean warmup, int run )
         print("location2id", miniPerf);
     }
 
-    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix, final String vehicle )
+    private void printTimeOfRouteQuery( final GraphHopper hopper, int count, String prefix,
+            final String vehicle, final boolean withInstructions )
     {
         final Graph g = hopper.getGraph();
         final AtomicLong maxDistance = new AtomicLong(0);
@@ -224,28 +226,32 @@ public int doCalc( boolean warmup, int run )
                 GHRequest req = new GHRequest(fromLat, fromLon, toLat, toLon).
                         setWeighting("fastest").
                         setVehicle(vehicle);
+                req.getHints().put("instructions", withInstructions);
                 GHResponse res;
                 try
                 {
                     res = hopper.route(req);
                 } catch (Exception ex)
                 {
+                    // 'not found' can happen if import creates more than one subnetwork
                     throw new RuntimeException("Error while calculating route! "
                             + "nodes:" + from + " -> " + to + ", request:" + req, ex);
                 }
 
                 if (res.hasErrors())
-                    throw new IllegalStateException("errors should NOT happen in Measurement! " + res.getErrors());
+                {
+                    if (!warmup)
+                        failedCount.incrementAndGet();
+
+                    if (!res.getErrors().get(0).getMessage().toLowerCase().contains("not found"))
+                        logger.error("errors should NOT happen in Measurement! " + req + " => " + res.getErrors());
+
+                    return 0;
+                }
 
                 if (!warmup)
                 {
                     long dist = (long) res.getDistance();
-                    if (dist < 1)
-                    {
-                        failedCount.incrementAndGet();
-                        return 0;
-                    }
-
                     distSum.addAndGet(dist);
 
                     airDistSum.addAndGet((long) distCalc.calcDist(fromLat, fromLon, toLat, toLon));
diff --git a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
index e15a43fc5a..521d7cd83c 100644
--- a/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
+++ b/tools/src/main/java/com/graphhopper/tools/QueryTorture.java
@@ -25,14 +25,14 @@
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.*;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
+import java.net.URLEncoder;
+import java.util.*;
+import java.util.Map.Entry;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import sun.security.x509.CRLDistributionPointsExtension;
 
 /**
  * Reads log files and queries the live service
@@ -59,6 +59,7 @@ public static void main( String[] args )
     private int readQueries;
     private int maxQueries;
     private int timeout;
+    private int statusUpdateCnt;
 
     public QueryTorture()
     {
@@ -71,6 +72,7 @@ public void start( CmdArgs read )
         baseUrl = read.get("baseurl", "");
         maxQueries = read.getInt("maxqueries", 1000);
         timeout = read.getInt("timeout", 3000);
+        statusUpdateCnt = maxQueries / 10;
         if (Helper.isEmpty(baseUrl))
             throw new IllegalArgumentException("baseUrl cannot be empty!?");
 
@@ -173,12 +175,17 @@ void execute( int workerNo ) throws InterruptedException
         Query query = queryQueue.take();
         try
         {
-            String url = baseUrl + query.queryString;
+            String url = baseUrl + query.createQueryString();
             String res = new Downloader("QueryTorture!").setTimeout(timeout).downloadAsString(url);
             if (res.contains("errors"))
                 routingErrorCounter.incrementAndGet();
             else
                 successfullQueries.incrementAndGet();
+
+            if (successfullQueries.get() % statusUpdateCnt == 0)
+            {
+                logger.info("progress: " + (int) (successfullQueries.get() * 100 / maxQueries) + "%");
+            }
         } catch (IOException ex)
         {
             // logger.error("Error while querying " + query.queryString, ex);
@@ -199,11 +206,9 @@ public void run()
                     BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(logFile), Helper.UTF_CS));
                     try
                     {
-                        int logLineNo = 0;
                         String logLine;
                         while ((logLine = reader.readLine()) != null)
                         {
-                            logLineNo++;
                             Query q = Query.parse(logLine);
                             if (q == null)
                                 continue;
@@ -234,7 +239,8 @@ public void run()
                 {
                     logger.error("Stopped reading logs", ex);
                     // do not wait, just shut down
-                    service.shutdownNow();
+                    if (service != null)
+                        service.shutdownNow();
                 }
             }
         }.start();
@@ -242,9 +248,10 @@ public void run()
 
     static class Query
     {
-        String queryString;
         GHPoint start;
         GHPoint end;
+        List<String> points = new ArrayList<String>();
+        Map<String, String> params = new HashMap<String, String>();
 
         static Query parse( String logLine )
         {
@@ -259,25 +266,32 @@ static Query parse( String logLine )
                 return null;
 
             Query q = new Query();
-            q.queryString = logLine.substring(0, index);
-
-            for (String param : q.queryString.split("\\&"))
+            String queryString = logLine.substring(0, index);
+            String[] tmpStrings = queryString.split("\\&");
+            for (String paramStr : tmpStrings)
             {
-                if (!param.startsWith("point="))
+                int equalIndex = paramStr.indexOf("=");
+                if (equalIndex <= 0)
                     continue;
 
-                param = param.replace("%2C", ",");
-                GHPoint point = GHPoint.parse(param.substring(6));
+                String key = paramStr.substring(0, equalIndex);
+                String value = paramStr.substring(equalIndex + 1);
+                if (!paramStr.startsWith("point="))
+                {
+                    q.params.put(key, value);
+                    continue;
+                }
+
+                value = value.replace("%2C", ",");
+                GHPoint point = GHPoint.parse(value);
                 if (point == null)
                     continue;
 
+                q.points.add(value);
                 if (q.start == null)
                     q.start = point;
                 else if (q.end == null)
-                {
                     q.end = point;
-                    break;
-                }
             }
             if (q.start != null && q.end != null)
                 return q;
@@ -285,31 +299,47 @@ else if (q.end == null)
             return null;
         }
 
-        @Override
-        public int hashCode()
+        public void put( String key, String value )
         {
-            int hash = 5;
-            hash = 47 * hash + (this.queryString != null ? this.queryString.hashCode() : 0);
-            return hash;
+            params.put(key, value);
         }
 
-        @Override
-        public boolean equals( Object obj )
+        public String createQueryString()
         {
-            if (obj == null)
-                return false;
-            if (getClass() != obj.getClass())
-                return false;
-            final Query other = (Query) obj;
-            if ((this.queryString == null) ? (other.queryString != null) : !this.queryString.equals(other.queryString))
-                return false;
-            return true;
+            String qStr = "";
+            for (String pointStr : points)
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += "point=" + pointStr;
+            }
+            for (Entry<String, String> e : params.entrySet())
+            {
+                if (!qStr.isEmpty())
+                    qStr += "&";
+
+                qStr += e.getKey() + "=" + encodeURL(e.getValue());
+            }
+
+            return qStr;
+        }
+
+        static String encodeURL( String str )
+        {
+            try
+            {
+                return URLEncoder.encode(str, "UTF-8");
+            } catch (Exception _ignore)
+            {
+                return str;
+            }
         }
 
         @Override
         public String toString()
         {
-            return queryString;
+            return createQueryString();
         }
     }
 }
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index 9e992feb2a..0049944ee0 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -20,8 +20,7 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
-import com.graphhopper.routing.Path;
-import com.graphhopper.routing.RoutingAlgorithm;
+import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
@@ -57,7 +56,7 @@ public static void main( String[] strs ) throws Exception
     }
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Path path;
-    private AlgorithmPreparation prepare;
+    private RoutingAlgorithmFactory algoFactory;
     private final Graph graph;
     private final NodeAccess na;
     private LocationIndexTree index;
@@ -70,18 +69,18 @@ public static void main( String[] strs ) throws Exception
     private boolean fastPaint = false;
     private final Weighting weighting;
     private final FlagEncoder encoder;
+    private AlgorithmOptions algoOpts;
 
     public MiniGraphUI( GraphHopper hopper, boolean debug )
     {
         this.graph = hopper.getGraph();
         this.na = graph.getNodeAccess();
-        prepare = hopper.getPreparation();
-        encoder = hopper.getEncodingManager().getSingle();
+        algoFactory = hopper.getAlgorithmFactory();
+        encoder = hopper.getEncodingManager().getEncoder("car");
         weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
-        if (prepare == null)
-            prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, "dijkstrabi", encoder, weighting, TraversalMode.NODE_BASED);
+        algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
-        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algo:" + prepare.createAlgo().getName());
+        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algoOpts:" + algoOpts);
         mg = new GraphicsWrapper(graph);
 
         // prepare node quadtree to 'enter' the graph. create a 313*313 grid => <3km
@@ -192,7 +191,8 @@ public void paintComponent( Graphics2D g2 )
                     return;
 
                 makeTransparent(g2);
-                RoutingAlgorithm algo = prepare.createAlgo();
+                QueryGraph qGraph = new QueryGraph(graph).lookup(fromRes, toRes);
+                RoutingAlgorithm algo = algoFactory.createAlgo(qGraph, algoOpts);
                 if (algo instanceof DebugAlgo)
                 {
                     ((DebugAlgo) algo).setGraphics2D(g2);
@@ -215,7 +215,7 @@ public void paintComponent( Graphics2D g2 )
 //                    mg.plotText(g2, lat, lon, nodeId + ": " + dist);
 //                    mg.plotNode(g2, nodeId, Color.red);
 //                }
-                path = algo.calcPath(fromRes, toRes);
+                path = algo.calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
                 sw.stop();
 
                 // if directed edges
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniItnGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniItnGraphUI.java
index ab812b8864..a406270ebf 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniItnGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniItnGraphUI.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -42,13 +42,13 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHTBitSet;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.Path;
+import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.RoutingAlgorithm;
-import com.graphhopper.routing.util.AlgorithmPreparation;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.NoOpAlgorithmPreparation;
-import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.util.Weighting;
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.storage.Graph;
@@ -83,7 +83,7 @@ public static void main( String[] strs ) throws Exception
     }
     private Logger logger = LoggerFactory.getLogger(getClass());
     private Path path;
-    private AlgorithmPreparation prepare;
+    private RoutingAlgorithmFactory algoFactory;
     private final Graph graph;
     private final NodeAccess na;
     private LocationIndexTree index;
@@ -96,29 +96,29 @@ public static void main( String[] strs ) throws Exception
     private boolean fastPaint = false;
     private final Weighting weighting;
     private final FlagEncoder encoder;
+    private AlgorithmOptions algoOpts;
 
     public MiniItnGraphUI( GraphHopper hopper, boolean debug )
     {
         this.graph = hopper.getGraph();
         this.na = graph.getNodeAccess();
-        prepare = hopper.getPreparation();
-        encoder = hopper.getEncodingManager().getSingle();
+        algoFactory = hopper.getAlgorithmFactory();
+        encoder = hopper.getEncodingManager().getEncoder("car");
         weighting = hopper.createWeighting(new WeightingMap("fastest"), encoder);
-        if (prepare == null)
-            prepare = NoOpAlgorithmPreparation.createAlgoPrepare(graph, "dijkstrabi", encoder, weighting, TraversalMode.NODE_BASED);
+        algoOpts = new AlgorithmOptions(AlgorithmOptions.DIJKSTRA_BI, encoder, weighting);
 
-        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algo:" + prepare.createAlgo().getName());
+        logger.info("locations:" + graph.getNodes() + ", debug:" + debug + ", algoOpts:" + algoOpts);
         mg = new GraphicsWrapper(graph);
 
         // prepare node quadtree to 'enter' the graph. create a 313*313 grid => <3km
-//         this.index = new DebugLocation2IDQuadtree(roadGraph, mg);
+        //         this.index = new DebugLocation2IDQuadtree(roadGraph, mg);
         this.index = (LocationIndexTree) hopper.getLocationIndex();
-//        this.algo = new DebugDijkstraBidirection(graph, mg);
+        //        this.algo = new DebugDijkstraBidirection(graph, mg);
         // this.algo = new DijkstraBidirection(graph);
-//        this.algo = new DebugAStar(graph, mg);
-//        this.algo = new AStar(graph);
-//        this.algo = new DijkstraSimple(graph);
-//        this.algo = new DebugDijkstraSimple(graph, mg);
+        //        this.algo = new DebugAStar(graph, mg);
+        //        this.algo = new AStar(graph);
+        //        this.algo = new DijkstraSimple(graph);
+        //        this.algo = new DebugDijkstraSimple(graph, mg);
         infoPanel = new JPanel()
         {
             @Override
@@ -158,18 +158,18 @@ public void paintComponent( Graphics2D g2 )
                     bitset.clear();
                 }
 
-//                g2.setColor(Color.BLUE);
-//                double fromLat = 42.56819, fromLon = 1.603231;
-//                mg.plotText(g2, fromLat, fromLon, "from");
-//                QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
-//                double toLat = 42.571034, toLon = 1.520662;
-//                mg.plotText(g2, toLat, toLon, "to");
-//                QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
-//
-//                g2.setColor(Color.RED.brighter().brighter());
-//                path = prepare.createAlgo().calcPath(from, to);
-//                System.out.println("now: " + path.toDetailsString());
-//                plotPath(path, g2, 1);
+                //                g2.setColor(Color.BLUE);
+                //                double fromLat = 42.56819, fromLon = 1.603231;
+                //                mg.plotText(g2, fromLat, fromLon, "from");
+                //                QueryResult from = index.findClosest(fromLat, fromLon, EdgeFilter.ALL_EDGES);
+                //                double toLat = 42.571034, toLon = 1.520662;
+                //                mg.plotText(g2, toLat, toLon, "to");
+                //                QueryResult to = index.findClosest(toLat, toLon, EdgeFilter.ALL_EDGES);
+                //
+                //                g2.setColor(Color.RED.brighter().brighter());
+                //                path = prepare.createAlgo().calcPath(from, to);
+                //                System.out.println("now: " + path.toDetailsString());
+                //                plotPath(path, g2, 1);
                 g2.setColor(Color.black);
 
                 EdgeExplorer explorer = graph.createEdgeExplorer(EdgeFilter.ALL_EDGES);
@@ -201,7 +201,7 @@ public void paintComponent( Graphics2D g2 )
 
                         // mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, iter.getName());
                         //mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, "s:" + (int) encoder.getSpeed(iter.getFlags()));
-                        //g2.setColor(Color.BLACK);                        
+                        //g2.setColor(Color.BLACK);
                         mg.plotEdge(g2, lat, lon, lat2, lon2);
                         g2.setColor(Color.BLACK);
                     }
@@ -218,7 +218,8 @@ public void paintComponent( Graphics2D g2 )
                     return;
 
                 makeTransparent(g2);
-                RoutingAlgorithm algo = prepare.createAlgo();
+                QueryGraph qGraph = new QueryGraph(graph).lookup(fromRes, toRes);
+                RoutingAlgorithm algo = algoFactory.createAlgo(qGraph, algoOpts);
                 if (algo instanceof DebugAlgo)
                 {
                     ((DebugAlgo) algo).setGraphics2D(g2);
@@ -227,21 +228,21 @@ public void paintComponent( Graphics2D g2 )
                 StopWatch sw = new StopWatch().start();
                 logger.info("start searching from:" + fromRes + " to:" + toRes + " " + weighting);
 
-//                GHPoint qp = fromRes.getQueryPoint();
-//                TIntHashSet set = index.findNetworkEntries(qp.lat, qp.lon, 1);
-//                TIntIterator nodeIter = set.iterator();
-//                DistanceCalc distCalc = new DistancePlaneProjection();
-//                System.out.println("set:" + set.size());
-//                while (nodeIter.hasNext())
-//                {
-//                    int nodeId = nodeIter.next();
-//                    double lat = graph.getNodeAccess().getLat(nodeId);
-//                    double lon = graph.getNodeAccess().getLon(nodeId);
-//                    int dist = (int) Math.round(distCalc.calcDist(qp.lat, qp.lon, lat, lon));
-//                    mg.plotText(g2, lat, lon, nodeId + ": " + dist);
-//                    mg.plotNode(g2, nodeId, Color.red);
-//                }
-                path = algo.calcPath(fromRes, toRes);
+                //                GHPoint qp = fromRes.getQueryPoint();
+                //                TIntHashSet set = index.findNetworkEntries(qp.lat, qp.lon, 1);
+                //                TIntIterator nodeIter = set.iterator();
+                //                DistanceCalc distCalc = new DistancePlaneProjection();
+                //                System.out.println("set:" + set.size());
+                //                while (nodeIter.hasNext())
+                //                {
+                //                    int nodeId = nodeIter.next();
+                //                    double lat = graph.getNodeAccess().getLat(nodeId);
+                //                    double lon = graph.getNodeAccess().getLon(nodeId);
+                //                    int dist = (int) Math.round(distCalc.calcDist(qp.lat, qp.lon, lat, lon));
+                //                    mg.plotText(g2, lat, lon, nodeId + ": " + dist);
+                //                    mg.plotNode(g2, nodeId, Color.red);
+                //                }
+                path = algo.calcPath(fromRes.getClosestNode(), toRes.getClosestNode());
                 sw.stop();
 
                 // if directed edges
@@ -270,14 +271,14 @@ public void paintComponent( Graphics2D g2 )
     // for debugging
     private Path calcPath( RoutingAlgorithm algo )
     {
-//        int from = index.findID(50.042, 10.19);
-//        int to = index.findID(50.049, 10.23);
-//
-////        System.out.println("path " + from + "->" + to);
-//        return algo.calcPath(from, to);
+        //        int from = index.findID(50.042, 10.19);
+        //        int to = index.findID(50.049, 10.23);
+        //
+        ////        System.out.println("path " + from + "->" + to);
+        //        return algo.calcPath(from, to);
         // System.out.println(GraphUtility.getNodeInfo(graph, 60139, new DefaultEdgeFilter(new CarFlagEncoder()).direction(false, true)));
         // System.out.println(((GraphStorage) graph).debug(202947, 10));
-//        GraphUtility.printInfo(graph, 106511, 10);
+        //        GraphUtility.printInfo(graph, 106511, 10);
         return algo.calcPath(162810, 35120);
     }
 
@@ -358,23 +359,23 @@ public void mouseWheelMoved( MouseWheelEvent e )
                     });
 
                     // listener to investigate findID behavior
-//                    MouseAdapter ml = new MouseAdapter() {
-//
-//                        @Override public void mouseClicked(MouseEvent e) {
-//                            findIDLat = mg.getLat(e.getY());
-//                            findIDLon = mg.getLon(e.getX());
-//                            findIdLayer.repaint();
-//                            mainPanel.repaint();
-//                        }
-//
-//                        @Override public void mouseMoved(MouseEvent e) {
-//                            updateLatLon(e);
-//                        }
-//
-//                        @Override public void mousePressed(MouseEvent e) {
-//                            updateLatLon(e);
-//                        }
-//                    };
+                    //                    MouseAdapter ml = new MouseAdapter() {
+                    //
+                    //                        @Override public void mouseClicked(MouseEvent e) {
+                    //                            findIDLat = mg.getLat(e.getY());
+                    //                            findIDLon = mg.getLon(e.getX());
+                    //                            findIdLayer.repaint();
+                    //                            mainPanel.repaint();
+                    //                        }
+                    //
+                    //                        @Override public void mouseMoved(MouseEvent e) {
+                    //                            updateLatLon(e);
+                    //                        }
+                    //
+                    //                        @Override public void mousePressed(MouseEvent e) {
+                    //                            updateLatLon(e);
+                    //                        }
+                    //                    };
                     MouseAdapter ml = new MouseAdapter()
                     {
                         // for routing:
@@ -450,21 +451,21 @@ public void mousePressed( MouseEvent e )
                     mainPanel.addMouseMotionListener(ml);
 
                     // just for fun
-//                    mainPanel.getInputMap().put(KeyStroke.getKeyStroke("DELETE"), "removedNodes");
-//                    mainPanel.getActionMap().put("removedNodes", new AbstractAction() {
-//                        @Override public void actionPerformed(ActionEvent e) {
-//                            int counter = 0;
-//                            for (CoordTrig<Long> coord : quadTreeNodes) {
-//                                int ret = quadTree.remove(coord.lat, coord.lon);
-//                                if (ret < 1) {
-////                                    logger.info("cannot remove " + coord + " " + ret);
-////                                    ret = quadTree.remove(coord.getLatitude(), coord.getLongitude());
-//                                } else
-//                                    counter += ret;
-//                            }
-//                            logger.info("Removed " + counter + " of " + quadTreeNodes.size() + " nodes");
-//                        }
-//                    });
+                    //                    mainPanel.getInputMap().put(KeyStroke.getKeyStroke("DELETE"), "removedNodes");
+                    //                    mainPanel.getActionMap().put("removedNodes", new AbstractAction() {
+                    //                        @Override public void actionPerformed(ActionEvent e) {
+                    //                            int counter = 0;
+                    //                            for (CoordTrig<Long> coord : quadTreeNodes) {
+                    //                                int ret = quadTree.remove(coord.lat, coord.lon);
+                    //                                if (ret < 1) {
+                    ////                                    logger.info("cannot remove " + coord + " " + ret);
+                    ////                                    ret = quadTree.remove(coord.getLatitude(), coord.getLongitude());
+                    //                                } else
+                    //                                    counter += ret;
+                    //                            }
+                    //                            logger.info("Removed " + counter + " of " + quadTreeNodes.size() + " nodes");
+                    //                        }
+                    //                    });
                     frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                     frame.setSize(frameWidth + 10, frameHeight + 30);
                     frame.setVisible(true);
@@ -482,8 +483,8 @@ public void mousePressed( MouseEvent e )
     void updateLatLon( MouseEvent e )
     {
         double lat = mg.getLat(e.getY());
-		double lon = mg.getLon(e.getX());
-		latLon = lat + "," + lon;
+        double lon = mg.getLon(e.getX());
+        latLon = lat + "," + lon;
         infoPanel.repaint();
         currentPosX = e.getX();
         currentPosY = e.getY();
@@ -497,7 +498,7 @@ void repaintPaths()
 
     void repaintRoads()
     {
-        // avoid threading as there should be no updated to scale or offset while painting 
+        // avoid threading as there should be no updated to scale or offset while painting
         // (would to lead to artifacts)
         StopWatch sw = new StopWatch().start();
         pathLayer.repaint();
diff --git a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
index 708bb57c52..fa5d018259 100644
--- a/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
+++ b/tools/src/test/java/com/graphhopper/tools/QueryTortureTest.java
@@ -31,7 +31,7 @@
     public void testGetQuery()
     {
         Query result = Query.parse("2013-08-07 18:06:50,905 [qtp1329318374-81] INFO  graphhopper.http.GraphHopperServlet - point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp 46.4.67.134 en_US Wget/1.13.4 (linux-gnu) 51.076329, 13.738409->52.517037, 13.38886, distance: 189.4806800000001, time:123min, points:907, took:0.007393159, debug - idLookup:0.002483692s, algoInit:1.20837E-4s, dijkstraCH-routing:0.003138361s, extract time:1.66755E-4, simplify (1219->907):0.001040086s, instructions:2.26986E-4s, dijkstrabi, fastest, CAR");
-        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.queryString);
+        assertEquals("point=51.076329,13.738409&point=52.517037,13.38886&type=jsonp", result.createQueryString());
         assertEquals(51.076329, result.start.lat, 1e-5);
         assertEquals(13.38886, result.end.lon, 1e-5);
     }
diff --git a/web/.classpath b/web/.classpath
index 7f989422e4..af6acd2e07 100644
--- a/web/.classpath
+++ b/web/.classpath
@@ -56,6 +56,7 @@
 	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
 		<attributes>
 			<attribute name="maven.pomderived" value="true"/>
+			<attribute name="org.eclipse.jst.component.dependency" value="/WEB-INF/lib"/>
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="output" path="target/classes"/>
diff --git a/web/.project b/web/.project
index f82a748613..7af14ce51c 100644
--- a/web/.project
+++ b/web/.project
@@ -6,6 +6,16 @@
 		<project>graphhopper</project>
 	</projects>
 	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.wst.jsdt.core.javascriptValidator</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.wst.common.project.facet.core.builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 		<buildCommand>
 			<name>org.eclipse.jdt.core.javabuilder</name>
 			<arguments>
@@ -16,9 +26,18 @@
 			<arguments>
 			</arguments>
 		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.wst.validation.validationbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
 	</buildSpec>
 	<natures>
+		<nature>org.eclipse.jem.workbench.JavaEMFNature</nature>
+		<nature>org.eclipse.wst.common.modulecore.ModuleCoreNature</nature>
 		<nature>org.eclipse.m2e.core.maven2Nature</nature>
 		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.wst.common.project.facet.core.nature</nature>
+		<nature>org.eclipse.wst.jsdt.core.jsNature</nature>
 	</natures>
 </projectDescription>
diff --git a/web/.settings/.jsdtscope b/web/.settings/.jsdtscope
new file mode 100644
index 0000000000..b72a6a47b2
--- /dev/null
+++ b/web/.settings/.jsdtscope
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src/main/webapp"/>
+	<classpathentry kind="src" path="target/m2e-wtp/web-resources"/>
+	<classpathentry kind="con" path="org.eclipse.wst.jsdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="con" path="org.eclipse.wst.jsdt.launching.WebProject">
+		<attributes>
+			<attribute name="hide" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.wst.jsdt.launching.baseBrowserLibrary"/>
+	<classpathentry kind="output" path=""/>
+</classpath>
diff --git a/web/.settings/org.eclipse.jdt.core.prefs b/web/.settings/org.eclipse.jdt.core.prefs
index ec4300d5d0..443e08599a 100644
--- a/web/.settings/org.eclipse.jdt.core.prefs
+++ b/web/.settings/org.eclipse.jdt.core.prefs
@@ -1,5 +1,8 @@
 eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7
 org.eclipse.jdt.core.compiler.compliance=1.7
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
 org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
 org.eclipse.jdt.core.compiler.source=1.7
diff --git a/web/.settings/org.eclipse.wst.common.component b/web/.settings/org.eclipse.wst.common.component
new file mode 100644
index 0000000000..c13475d235
--- /dev/null
+++ b/web/.settings/org.eclipse.wst.common.component
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?><project-modules id="moduleCoreId" project-version="1.5.0">
+    <wb-module deploy-name="graphhopper-web">
+        <wb-resource deploy-path="/" source-path="/target/m2e-wtp/web-resources"/>
+        <wb-resource deploy-path="/" source-path="/src/main/webapp" tag="defaultRootSource"/>
+        <wb-resource deploy-path="/WEB-INF/classes" source-path="/src/main/java"/>
+        <wb-resource deploy-path="/WEB-INF/classes" source-path="/src/main/resources"/>
+        <dependent-module archiveName="graphhopper-0.4-SNAPSHOT.jar" deploy-path="/WEB-INF/lib" handle="module:/resource/graphhopper/graphhopper">
+            <dependency-type>uses</dependency-type>
+        </dependent-module>
+        <property name="context-root" value="graphhopper-web"/>
+        <property name="java-output-path" value="/graphhopper-web/target/classes"/>
+    </wb-module>
+</project-modules>
diff --git a/web/.settings/org.eclipse.wst.common.project.facet.core.xml b/web/.settings/org.eclipse.wst.common.project.facet.core.xml
new file mode 100644
index 0000000000..5302da19c7
--- /dev/null
+++ b/web/.settings/org.eclipse.wst.common.project.facet.core.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<faceted-project>
+  <fixed facet="wst.jsdt.web"/>
+  <installed facet="java" version="1.7"/>
+  <installed facet="jst.web" version="2.5"/>
+  <installed facet="wst.jsdt.web" version="1.0"/>
+</faceted-project>
diff --git a/web/.settings/org.eclipse.wst.jsdt.ui.superType.container b/web/.settings/org.eclipse.wst.jsdt.ui.superType.container
new file mode 100644
index 0000000000..3bd5d0a480
--- /dev/null
+++ b/web/.settings/org.eclipse.wst.jsdt.ui.superType.container
@@ -0,0 +1 @@
+org.eclipse.wst.jsdt.launching.baseBrowserLibrary
\ No newline at end of file
diff --git a/web/.settings/org.eclipse.wst.jsdt.ui.superType.name b/web/.settings/org.eclipse.wst.jsdt.ui.superType.name
new file mode 100644
index 0000000000..05bd71b6ec
--- /dev/null
+++ b/web/.settings/org.eclipse.wst.jsdt.ui.superType.name
@@ -0,0 +1 @@
+Window
\ No newline at end of file
diff --git a/web/.settings/org.eclipse.wst.validation.prefs b/web/.settings/org.eclipse.wst.validation.prefs
new file mode 100644
index 0000000000..04cad8cb75
--- /dev/null
+++ b/web/.settings/org.eclipse.wst.validation.prefs
@@ -0,0 +1,2 @@
+disabled=06target
+eclipse.preferences.version=1
diff --git a/web/Readme.md b/web/Readme.md
deleted file mode 100644
index 498ba0e605..0000000000
--- a/web/Readme.md
+++ /dev/null
@@ -1,6 +0,0 @@
-This application uses jQuery and Leaflet to display the calculated route from GraphHopper.
-Execute `./graphhopper.sh web europe_germany_berlin.osm` in the parent folder. 
-Then go to [http://localhost:8989/](http://localhost:8989/).
-Get the raw json query [here](http://localhost:8989/route?from=52.439688,13.276863&to=52.532932,13.479424)
-
-[![GraphHopper Maps image](http://karussell.files.wordpress.com/2013/07/maps-preview1.png)](http://graphhopper.com/maps/?point=new%20york&point=los%20angeles)
\ No newline at end of file
diff --git a/web/src/main/java/com/graphhopper/http/DefaultModule.java b/web/src/main/java/com/graphhopper/http/DefaultModule.java
index e7d44c7433..7829d78286 100644
--- a/web/src/main/java/com/graphhopper/http/DefaultModule.java
+++ b/web/src/main/java/com/graphhopper/http/DefaultModule.java
@@ -31,7 +31,7 @@
 public class DefaultModule extends AbstractModule
 {
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final CmdArgs args;
+    protected final CmdArgs args;
     private GraphHopper graphHopper;
 
     public DefaultModule( CmdArgs args )
diff --git a/web/src/main/java/com/graphhopper/http/GHServletModule.java b/web/src/main/java/com/graphhopper/http/GHServletModule.java
index 31df6a3806..96273a8d83 100644
--- a/web/src/main/java/com/graphhopper/http/GHServletModule.java
+++ b/web/src/main/java/com/graphhopper/http/GHServletModule.java
@@ -29,7 +29,7 @@
 public class GHServletModule extends ServletModule
 {
     protected Map<String, String> params = new HashMap<String, String>();
-    private final CmdArgs args;
+    protected final CmdArgs args;
 
     public GHServletModule( CmdArgs args )
     {
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
index 5ba54048bd..e4dd2bc3f1 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServlet.java
@@ -24,6 +24,7 @@
 import com.graphhopper.routing.util.WeightingMap;
 import com.graphhopper.util.*;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import java.io.IOException;
 import java.io.StringWriter;
@@ -72,20 +73,20 @@ public void doGet( HttpServletRequest req, HttpServletResponse res ) throws Serv
         }
     }
 
-    void writePath( HttpServletRequest req, HttpServletResponse res ) throws Exception
+    void writePath( HttpServletRequest httpReq, HttpServletResponse res ) throws Exception
     {
-        List<GHPoint> infoPoints = getPoints(req);
+        List<GHPoint> infoPoints = getPoints(httpReq, "point");
 
         // we can reduce the path length based on the maximum differences to the original coordinates
-        double minPathPrecision = getDoubleParam(req, "way_point_max_distance", 1d);
-        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(req, "type", "json"));
-        boolean enableInstructions = writeGPX || getBooleanParam(req, "instructions", true);
-        boolean calcPoints = getBooleanParam(req, "calc_points", true);
-        boolean elevation = getBooleanParam(req, "elevation", false);
-        String vehicleStr = getParam(req, "vehicle", "CAR").toUpperCase();
-        String weighting = getParam(req, "weighting", "fastest");
-        String algoStr = getParam(req, "algorithm", "");
-        String localeStr = getParam(req, "locale", "en");
+        double minPathPrecision = getDoubleParam(httpReq, "way_point_max_distance", 1d);
+        boolean writeGPX = "gpx".equalsIgnoreCase(getParam(httpReq, "type", "json"));
+        boolean enableInstructions = writeGPX || getBooleanParam(httpReq, "instructions", true);
+        boolean calcPoints = getBooleanParam(httpReq, "calc_points", true);
+        boolean elevation = getBooleanParam(httpReq, "elevation", false);
+        String vehicleStr = getParam(httpReq, "vehicle", "car");
+        String weighting = getParam(httpReq, "weighting", "fastest");
+        String algoStr = getParam(httpReq, "algorithm", "");
+        String localeStr = getParam(httpReq, "locale", "en");
 
         StopWatch sw = new StopWatch().start();
         GHResponse ghRsp;
@@ -100,7 +101,7 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
             FlagEncoder algoVehicle = hopper.getEncodingManager().getEncoder(vehicleStr);
             GHRequest request = new GHRequest(infoPoints);
 
-            initHints(request, req.getParameterMap());
+            initHints(request, httpReq.getParameterMap());
             request.setVehicle(algoVehicle.toString()).
                     setWeighting(weighting).
                     setAlgorithm(algoStr).
@@ -114,23 +115,21 @@ void writePath( HttpServletRequest req, HttpServletResponse res ) throws Excepti
         }
 
         float took = sw.stop().getSeconds();
-        String infoStr = req.getRemoteAddr() + " " + req.getLocale() + " " + req.getHeader("User-Agent");
-        PointList points = ghRsp.getPoints();
-        String logStr = req.getQueryString() + " " + infoStr + " " + infoPoints
-                + ", distance: " + ghRsp.getDistance() + ", time:" + Math.round(ghRsp.getMillis() / 60000f)
-                + "min, points:" + points.getSize() + ", took:" + took
-                + ", debug - " + ghRsp.getDebugInfo() + ", " + algoStr + ", "
-                + weighting + ", " + vehicleStr;
+        String infoStr = httpReq.getRemoteAddr() + " " + httpReq.getLocale() + " " + httpReq.getHeader("User-Agent");
+        String logStr = httpReq.getQueryString() + " " + infoStr + " " + infoPoints + ", took:"
+                + took + ", " + algoStr + ", " + weighting + ", " + vehicleStr;
 
         if (ghRsp.hasErrors())
             logger.error(logStr + ", errors:" + ghRsp.getErrors());
         else
-            logger.info(logStr);
+            logger.info(logStr + ", distance: " + ghRsp.getDistance()
+                    + ", time:" + Math.round(ghRsp.getMillis() / 60000f)
+                    + "min, points:" + ghRsp.getPoints().getSize() + ", debug - " + ghRsp.getDebugInfo());
 
         if (writeGPX)
-            writeResponse(res, createGPXString(req, res, ghRsp));
+            writeResponse(res, createGPXString(httpReq, res, ghRsp));
         else
-            writeJson(req, res, new JSONObject(createJson(req, ghRsp, took)));
+            writeJson(httpReq, res, new JSONObject(createJson(httpReq, ghRsp, took)));
     }
 
     protected String createGPXString( HttpServletRequest req, HttpServletResponse res, GHResponse rsp )
@@ -201,12 +200,6 @@ String errorsToXML( List<Throwable> list ) throws Exception
                 list.add(map);
             }
             jsonInfo.put("errors", list);
-        } else if (!rsp.isFound())
-        {
-            Map<String, String> map = new HashMap<String, String>();
-            map.put("message", "Not found");
-            map.put("details", "");
-            jsonInfo.put("errors", Collections.singletonList(map));
         } else
         {
             jsonInfo.put("took", Math.round(took * 1000));
@@ -221,7 +214,11 @@ String errorsToXML( List<Throwable> list ) throws Exception
 
                 PointList points = rsp.getPoints();
                 if (points.getSize() >= 2)
-                    jsonPath.put("bbox", rsp.calcRouteBBox(hopper.getGraph().getBounds()).toGeoJson());
+                {
+                    BBox maxBounds = hopper.getGraph().getBounds();
+                    BBox maxBounds2D = new BBox(maxBounds.minLon, maxBounds.maxLon, maxBounds.minLat, maxBounds.maxLat);
+                    jsonPath.put("bbox", rsp.calcRouteBBox(maxBounds2D).toGeoJson());
+                }
 
                 jsonPath.put("points", createPoints(points, pointsEncoded, includeElevation));
 
@@ -247,25 +244,27 @@ protected Object createPoints( PointList points, boolean pointsEncoded, boolean
         return jsonPoints;
     }
 
-    private List<GHPoint> getPoints( HttpServletRequest req ) throws IOException
+    protected List<GHPoint> getPoints( HttpServletRequest req, String key ) throws IOException
     {
-        String[] pointsAsStr = getParams(req, "point");
+        String[] pointsAsStr = getParams(req, key);
         final List<GHPoint> infoPoints = new ArrayList<GHPoint>(pointsAsStr.length);
         for (String str : pointsAsStr)
         {
             String[] fromStrs = str.split(",");
             if (fromStrs.length == 2)
             {
-                GHPoint place = GHPoint.parse(str);
-                if (place != null)
-                    infoPoints.add(place);
+                GHPoint point = GHPoint.parse(str);
+                if (point != null)
+                {
+                    infoPoints.add(point);
+                }
             }
         }
 
         return infoPoints;
     }
 
-    private void initHints( GHRequest request, Map<String, String[]> parameterMap )
+    protected void initHints( GHRequest request, Map<String, String[]> parameterMap )
     {
         WeightingMap m = request.getHints();
         for (Entry<String, String[]> e : parameterMap.entrySet())
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index 4730e231aa..c1445d9616 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -22,6 +22,7 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
+import java.util.Arrays;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.slf4j.Logger;
@@ -36,8 +37,12 @@
 {
     public static void main( String[] args )
     {
-        GraphHopperAPI gh = new GraphHopperWeb();
-        gh.load("http://localhost:8989/route");
+        GraphHopperWeb gh = new GraphHopperWeb();
+        gh.setKey("<your-key>");
+
+        // for local server: gh.load("http://localhost:8989/route");        
+        gh.load("https://graphhopper.com/api/1/route");
+
         //GHResponse ph = gh.route(new GHRequest(53.080827, 9.074707, 50.597186, 11.184082));
         GHResponse ph = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180));
         System.out.println(ph);
diff --git a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
index 9fd057f8e6..b320b38854 100644
--- a/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
+++ b/web/src/main/java/com/graphhopper/http/InvalidRequestServlet.java
@@ -23,7 +23,6 @@
 
 public class InvalidRequestServlet extends GHBaseServlet
 {
-
     @Override
     protected void service( HttpServletRequest req, HttpServletResponse res ) throws ServletException, IOException
     {
diff --git a/web/src/main/webapp/img/roundabout.png b/web/src/main/webapp/img/roundabout.png
new file mode 100644
index 0000000000..1a02efd5b9
Binary files /dev/null and b/web/src/main/webapp/img/roundabout.png differ
diff --git a/web/src/main/webapp/index.html b/web/src/main/webapp/index.html
index b258ce00e3..1125c0618a 100644
--- a/web/src/main/webapp/index.html
+++ b/web/src/main/webapp/index.html
@@ -19,7 +19,6 @@
         <link rel="stylesheet" href="css/leaflet.loading.css" />
         <link rel="stylesheet" href="css/ui-lightness/jquery-ui-1.10.4.css" />
         <script async type="text/javascript" src="js/leaflet.contextmenu.js"></script>
-        <script async type="text/javascript" src="js/leaflet.loading.js"></script>
     
         <script src="js/proj4.js"></script>
         <script src="js/proj4leaflet.js"></script>
@@ -34,6 +33,16 @@
         <!-- Type Ahead -->
         <link rel="stylesheet" type="text/css" href="http://twitter.github.io/typeahead.js/css/examples.css">
         
+        <script type="text/javascript" src="js/leaflet.loading.js"></script>
+        <script type="text/javascript" src="js/jquery-2.1.0.min.js"></script>        
+        <script type="text/javascript" src="js/jquery-ui-1.10.4.custom.min.js"></script>      
+        <script type="text/javascript" src="js/jquery.history.js"></script>
+        <!--
+        <script type="text/javascript" src="js/jquery.autocomplete.min.js"></script>
+        -->
+        <script type="text/javascript" src="js/jquery.autocomplete.js"></script>
+        <script type="text/javascript" src="js/ghrequest.js?v=0.4.4"></script>
+        <script type="text/javascript" src="js/main.js?v=0.4.4"></script>
         <link rel="stylesheet" type="text/css" href="css/style.css" />
 
     </head>
diff --git a/web/src/main/webapp/js/ghrequest.js b/web/src/main/webapp/js/ghrequest.js
index f3609a949d..d1a1265773 100644
--- a/web/src/main/webapp/js/ghrequest.js
+++ b/web/src/main/webapp/js/ghrequest.js
@@ -9,6 +9,33 @@ window.log = function () {
     }
 };
 
+// compatiblity script taken from http://stackoverflow.com/a/11054570/194609
+if (!Function.prototype.bind) {
+    Function.prototype.bind = function (oThis) {
+        if (typeof this !== 'function') {
+            // closest thing possible to the ECMAScript 5
+            // internal IsCallable function
+            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
+        }
+
+        var aArgs = Array.prototype.slice.call(arguments, 1),
+                fToBind = this,
+                fNOP = function () {
+                },
+                fBound = function () {
+                    return fToBind.apply(this instanceof fNOP && oThis
+                            ? this
+                            : oThis,
+                            aArgs.concat(Array.prototype.slice.call(arguments)));
+                };
+
+        fNOP.prototype = this.prototype;
+        fBound.prototype = new fNOP();
+
+        return fBound;
+    };
+}
+
 GHRequest = function (host) {
     this.way_point_max_distance = 1;
     this.host = host;
@@ -26,7 +53,9 @@ GHRequest = function (host) {
     this.do_zoom = true;
     // use jsonp here if host allows CORS
     this.dataType = "json";
-    
+    // all URL parameters starting with "api." will be forwarded to GraphHopper directly    
+    this.api_params = [];
+
     ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     // We know that you love 'free', we love it too :)! And so our entire software stack is free and even Open Source!      
     // Our routing service is also free for certain applications or smaller volume. Be fair, grab an API key and support us:
@@ -152,7 +181,7 @@ GHroute.prototype = {
         }
         return (this[to]);
     },
-    delete: function (value) {
+    removeSingle: function (value) {
         var index = false;
         if (!(isNaN(value) || value >= this.length) && this[value] !== undefined) {
             index = value;
@@ -168,13 +197,13 @@ GHroute.prototype = {
         return (this);
     },
     remove: function (from, to) {
-        var to = to || 1;
-        Array.prototype.splice.call(this, from, to);
+        var tmpTo = to || 1;
+        Array.prototype.splice.call(this, from, tmpTo);
         if (this.length === 1)
             Array.prototype.push.call(this, new GHInput());
         this.fire('route.remove', {
             from: from,
-            to: to
+            to: tmpTo
         });
         return (this);
     },
@@ -239,6 +268,7 @@ GHroute.prototype = {
             this._listeners[type] = [];
         }
         this._listeners[type].push(listener);
+        return this;
     },
     fire: function (event, options) {
         if (typeof event === "string") {
@@ -275,20 +305,26 @@ GHroute.prototype = {
     }
 };
 
-// todo
 GHRequest.prototype.init = function (params) {
-    //    for(var key in params) {
-    //        var val = params[key];
-    //        if(val === "false")
-    //            val = false;
-    //        else if(val === "true")
-    //            val = true;
-    //        else {            
-    //            if(parseFloat(val) != NaN)
-    //                val = parseFloat(val)
-    //        }
-    //        this[key] = val;
-    //    } 
+    for (var key in params) {
+        var val = params[key];
+        if (val === "false")
+            val = false;
+        else if (val === "true")
+            val = true;
+        else {
+            if (parseFloat(val) != NaN)
+                val = parseFloat(val)
+        }
+
+        // todo
+        // this[key] = val;
+
+        if (key.indexOf('api.') === 0) {
+            this.api_params[key.substring(4)] = val;
+        }
+    }
+
     if (params.minPathPrecision)
         this.minPathPrecision = params.minPathPrecision;
     if (params.vehicle)
@@ -357,50 +393,42 @@ GHRequest.prototype.hasElevation = function () {
     return this.elevation;
 };
 
-GHRequest.prototype.createGeocodeURL = function (host) {
+GHRequest.prototype.createGeocodeURL = function (host, prevIndex) {
     var tmpHost = this.host;
     if (host)
         tmpHost = host;
-    return this.createPath(tmpHost + "/geocode?limit=8&type=" + this.dataType + "&key=" + this.key + "&locale=" + this.locale);
+
+    var path = this.createPath(tmpHost + "/geocode?limit=8&type=" + this.dataType + "&key=" + this.key);
+    if (prevIndex >= 0 && prevIndex < this.route.size()) {
+        var point = this.route.getIndex(prevIndex);
+        path += "&lat=" + point.lat + "&lon=" + point.lng;
+    }
+    return path;
 };
 
 GHRequest.prototype.createURL = function () {
-    return this.createPath(this.host + "/route?" + this.createParams() + "&type=" + this.dataType + "&key=" + this.key);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=" + this.dataType + "&key=" + this.key);
 };
 
 GHRequest.prototype.createGPXURL = function () {
-    // use points instead of strings
-    var str = "", point, i, l;
-
-    for (i = 0, l = this.route.size(); i < l; i++) {
-        point = this.route.getIndex(i);
-        if (i > 0)
-            str += "&";
-        str += "point=" + encodeURIComponent(point.toString());
-    }
-    return this.createPath(this.host + "/route?" + str + "&type=gpx&key=" + this.key);
+    return this.createPath(this.host + "/route?" + this.createPointParams(false) + "&type=gpx&key=" + this.key);
 };
 
 GHRequest.prototype.createHistoryURL = function () {
-    var str = "?", point, i, l;
-
-    for (i = 0, l = this.route.size(); i < l; i++) {
-        point = this.route.getIndex(i);
-        if (i > 0)
-            str += "&";
-        str += "point=" + encodeURIComponent(point.input);
-    }
-    return this.createPath(str);
+    return this.createPath("?" + this.createPointParams(true));
 };
 
-GHRequest.prototype.createParams = function () {
+GHRequest.prototype.createPointParams = function (useRawInput) {
     var str = "", point, i, l;
 
     for (i = 0, l = this.route.size(); i < l; i++) {
         point = this.route.getIndex(i);
         if (i > 0)
             str += "&";
-        str += "point=" + encodeURIComponent(point.toString());
+        if (useRawInput)
+            str += "point=" + encodeURIComponent(point.input);
+        else
+            str += "point=" + encodeURIComponent(point.toString());
     }
     return (str);
 };
@@ -427,6 +455,10 @@ GHRequest.prototype.createPath = function (url) {
         url += "&elevation=true";
     if (this.debug)
         url += "&debug=true";
+
+    for (var key in this.api_params) {
+        url += "&" + key + "=" + this.api_params[key];
+    }
     return url;
 };
 
@@ -507,7 +539,10 @@ GHRequest.prototype.doRequest = function (url, callback) {
             // problematic: this callback is not invoked when using JSONP!
             // http://stackoverflow.com/questions/19035557/jsonp-request-error-handling
             var msg = "API did not respond! ";
-            if (err && err.statusText && err.statusText !== "OK")
+            if (err && err.responseText && err.responseText.indexOf('{') >= 0) {
+                var jsonError = JSON.parse(err.responseText);
+                msg += jsonError.message;
+            } else if (err && err.statusText && err.statusText !== "OK")
                 msg += err.statusText;
 
             log(msg + " " + JSON.stringify(err));
diff --git a/web/src/main/webapp/js/main.js b/web/src/main/webapp/js/main.js
index b776690751..9909577d8d 100644
--- a/web/src/main/webapp/js/main.js
+++ b/web/src/main/webapp/js/main.js
@@ -15,7 +15,6 @@ if (!host) {
 }
 
 var ghRequest = new GHRequest(host);
-var tmpArgs = parseUrlWithHisto();
 var bounds = {};
 
 var nominatimURL = "https://nominatim.openstreetmap.org/search";
@@ -197,8 +196,8 @@ function initFromParams(params, doQuery) {
             resolveCoords([params.from, params.to], doQuery);
         else
             resolveCoords(params.point, doQuery);
-    } else if (params.point) {
-        ghRequest.from = new GHInput(params.point);
+    } else if (params.point && params.point.length === 1) {
+        ghRequest.from = new GHInput(params.point[0]);
         resolve("from", ghRequest.from);
         focus(ghRequest.from, 15, true);
     }
@@ -237,10 +236,10 @@ function checkInput() {
     // properly unbind previously click handlers
     $("#locationpoints .pointDelete").off();
 
-    // console.log("#### new checkInput #### ");
+    // console.log("## new checkInput");
     for (var i = 0; i < len; i++) {
         var div = $('#locationpoints > div.pointDiv').eq(i);
-        console.log(div.length + ", index:" + i + ", len:" + len);
+        // console.log(div.length + ", index:" + i + ", len:" + len);
         if (div.length === 0) {
             $('#locationpoints > div.pointAdd').before(nanoTemplate(template, {id: i}));
             div = $('#locationpoints > div.pointDiv').eq(i);
@@ -254,7 +253,7 @@ function checkInput() {
         if (len > 2) {
             div.find(".pointDelete").click(function () {
                 var index = $(this).parent().data('index');
-                ghRequest.route.delete(index);
+                ghRequest.route.removeSingle(index);
                 routingLayer.clearLayers();
                 routeLatLng(ghRequest, false);
             }).show();
@@ -330,7 +329,7 @@ function initMap(selectLayer) {
         subdomains: ['otile1', 'otile2', 'otile3', 'otile4']
     });
 
-    var openMapsSurfer = L.tileLayer('http://openmapsurfer.uni-hd.de/tiles/roads/x={x}&y={y}&z={z}', {
+    var openMapSurfer = L.tileLayer('http://openmapsurfer.uni-hd.de/tiles/roads/x={x}&y={y}&z={z}', {
         attribution: osmAttr + ', <a href="http://openmapsurfer.uni-hd.de/contact.html">GIScience Heidelberg</a>'
     });
 
@@ -363,11 +362,19 @@ function initMap(selectLayer) {
         subdomains: ['a', 'b', 'c']
     });
 
+    var mapLink = '<a href="http://www.esri.com/">Esri</a>';
+    var wholink = 'i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';
+    var esriAerial = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
+        attribution: '&copy; ' + mapLink + ', ' + wholink,
+        maxZoom: 18
+    });
+
     var baseMaps = {
         "Lyrk": lyrk,
         "MapQuest": mapquest,
         "MapQuest Aerial": mapquestAerial,
-        "OpenMapsSurfer": openMapsSurfer,
+        "Esri Aerial": esriAerial,
+        "OpenMapSurfer": openMapSurfer,
         "TF Transport": thunderTransport,
         "TF Cycle": thunderCycle,
         "TF Outdoors": thunderOutdoors,
@@ -384,7 +391,7 @@ function initMap(selectLayer) {
     map = L.map('map', {
         layers: [defaultLayer],
         contextmenu: true,
-        contextmenuWidth: 140,
+        contextmenuWidth: 145,
         contextmenuItems: [{
                 separator: true,
                 index: 3,
@@ -546,7 +553,7 @@ function setIntermediateCoord(e) {
 
 function deleteCoord(e) {
     var latlng = e.target.getLatLng();
-    ghRequest.route.delete(latlng);
+    ghRequest.route.removeSingle(latlng);
     routingLayer.clearLayers();
     routeLatLng(ghRequest, false);
 }
@@ -558,9 +565,9 @@ function setEndCoord(e) {
     routeIfAllResolved();
 }
 
-function routeIfAllResolved() {
+function routeIfAllResolved(doQuery) {
     if (ghRequest.route.isResolved()) {
-        routeLatLng(ghRequest);
+        routeLatLng(ghRequest, doQuery);
         return true;
     }
     return false;
@@ -591,7 +598,8 @@ function setFlag(coord, index) {
                     draggable: true,
                     contextmenu: true,
                     contextmenuItems: [{
-                            text: 'Marker ' + ((toFrom === FROM) ? 'Start' : ((toFrom === TO) ? 'End' : 'Intermediate')),
+                            text: 'Marker ' + ((toFrom === FROM) ?
+                                    'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)),
                             disabled: true,
                             index: 0,
                             state: 2
@@ -612,7 +620,8 @@ function setFlag(coord, index) {
                             state: 2
                         }],
                     contextmenuAtiveState: 2
-                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ? 'Start' : ((toFrom === TO) ? 'End' : 'Intermediate')));
+                }).addTo(routingLayer).bindPopup(((toFrom === FROM) ?
+                'Start' : ((toFrom === TO) ? 'End' : 'Intermediate ' + index)));
         // intercept openPopup
         marker._openPopup = marker.openPopup;
         marker.openPopup = function () {
@@ -1138,6 +1147,8 @@ function addInstruction(main, instr, instrIndex, lngLat) {
         sign = "marker-icon-red";
     else if (sign === 5)
         sign = "marker-icon-blue";
+    else if (sign === 6)
+        sign = "roundabout";
     else
         throw "did not found sign " + sign;
     var title = instr.text;
@@ -1197,10 +1208,6 @@ function parseUrlWithHisto() {
     return parseUrl(window.location.search);
 }
 
-function parseUrlAndRequest() {
-    return parseUrl(window.location.search);
-}
-
 function parseUrl(query) {
     var index = query.indexOf('?');
     if (index >= 0)
@@ -1218,24 +1225,26 @@ function parseUrl(query) {
         if (value === "")
             continue;
 
-        if (typeof res[key] === "undefined") {
-            if (value === 'true')
+        if (key === "point" && !res[key]) {
+            res[key] = [value];
+        } else if (typeof res[key] === "string") {
+            var arr = [res[key], value];
+            res[key] = arr;
+        } else if (typeof res[key] === "undefined") {
+            if (value === 'true') {
                 res[key] = true;
-            else if (value === 'false')
+            } else if (value === 'false') {
                 res[key] = false;
-            else {
+            } else {
                 var tmp = Number(value);
                 if (isNaN(tmp))
                     res[key] = value;
                 else
                     res[key] = Number(value);
             }
-        } else if (typeof res[key] === "string") {
-            var arr = [res[key], value];
-            res[key] = arr;
-        } else
+        } else {
             res[key].push(value);
-
+        }
     }
     return res;
 }
@@ -1404,14 +1413,15 @@ function setAutoCompleteList(index) {
         },
         serviceUrl: function () {
             // see https://graphhopper.com/#directions-api
-            return ghRequest.createGeocodeURL(host);
+            return ghRequest.createGeocodeURL(host, index - 1);
         },
         transformResult: function (response, originalQuery) {
             response.suggestions = [];
-            for (var i = 0; i < response.hits.length; i++) {
-                var hit = response.hits[i];
-                response.suggestions.push({value: dataToText(hit), data: hit});
-            }
+            if (response.hits)
+                for (var i = 0; i < response.hits.length; i++) {
+                    var hit = response.hits[i];
+                    response.suggestions.push({value: dataToText(hit), data: hit});
+                }
             return response;
         },
         onSearchError: function (element, q, jqXHR, textStatus, errorThrown) {
@@ -1433,7 +1443,7 @@ function setAutoCompleteList(index) {
             req.setCoord(point.lat, point.lng);
 
             req.input = suggestion.value;
-            if (!routeIfAllResolved())
+            if (!routeIfAllResolved(true))
                 focus(req, 15, index);
 
             myAutoDiv.autocomplete().enable();
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
index a33c669719..a70129ef98 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperServletWithEleIT.java
@@ -65,7 +65,11 @@ public void testElevation() throws Exception
         assertTrue("distance wasn't correct:" + distance, distance < 2700);
 
         JSONObject cson = path.getJSONObject("points");
-        assertTrue("no elevation?", cson.toString().indexOf("[7.421392,43.7307,66]") >= 0);
+        assertTrue("no elevation?", cson.toString().contains("[7.421392,43.7307,66]"));
+
+        // Although we include elevation DO NOT include it in the bbox as bbox.toGeoJSON messes up when reading
+        // or reading with and without elevation would be too complex for the client with no real use
+        assertEquals(4, path.getJSONArray("bbox").length());
     }
 
     @Test
