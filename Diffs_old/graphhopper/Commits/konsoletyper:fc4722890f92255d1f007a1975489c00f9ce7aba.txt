diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index d5a1fa75d2..20a4ed498e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -1,10 +1,10 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
  *
  *       http://www.apache.org/licenses/LICENSE-2.0
@@ -24,13 +24,13 @@
  */
 public class BikeFlagEncoder extends BikeFlagCommonEncoder
 {
-    BikeFlagEncoder()
+    public BikeFlagEncoder()
     {
         setTrackTypeSpeed("grade1", 20); // paved
         setTrackTypeSpeed("grade2", 12); // now unpaved ...
         setTrackTypeSpeed("grade3", 12);
         setTrackTypeSpeed("grade4", 10);
-        setTrackTypeSpeed("grade5", 8); // like sand/grass     
+        setTrackTypeSpeed("grade5", 8); // like sand/grass
 
         setSurfaceSpeed("paved", 20);
         setSurfaceSpeed("asphalt", 20);
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 4fa7500307..c06a9e6841 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -183,7 +183,6 @@ public int getBytesForFlags()
         return resultEncoders;
     }
 
-    private static final String ERR = "Encoders are requesting more than %s bits of %s flags. ";
     private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long.";
 
     private void registerEncoder( AbstractFlagEncoder encoder )
@@ -191,19 +190,19 @@ private void registerEncoder( AbstractFlagEncoder encoder )
         int encoderCount = edgeEncoders.size();
         int usedBits = encoder.defineNodeBits(encoderCount, edgeEncoderNextBit);
         if (usedBits > bytesForFlags)
-            throw new IllegalArgumentException(String.format(ERR, bytesForFlags, "node"));
+            throw new IllegalArgumentException(err(bytesForFlags, "node"));
         encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
         nextNodeBit = usedBits;
 
         usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
         if (usedBits > bytesForFlags)
-            throw new IllegalArgumentException(String.format(ERR, bytesForFlags, "way") + WAY_ERR);
+            throw new IllegalArgumentException(err(bytesForFlags, "way") + WAY_ERR);
         encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
         nextWayBit = usedBits;
 
         usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
         if (usedBits > bytesForFlags)
-            throw new IllegalArgumentException(String.format(ERR, bytesForFlags, "relation"));
+            throw new IllegalArgumentException(err(bytesForFlags, "relation"));
         encoder.setRelBitMask(usedBits - nextRelBit, nextRelBit);
         nextRelBit = usedBits;
 
@@ -212,13 +211,17 @@ private void registerEncoder( AbstractFlagEncoder encoder )
         // turn flag bits are independent from edge encoder bits
         usedBits = encoder.defineTurnBits(encoderCount, nextTurnBit, determineRequiredBits(maxTurnCost));
         if (usedBits > maxTurnFlagsBits)
-            throw new IllegalArgumentException(String.format(ERR, bytesForFlags, "turn"));
+            throw new IllegalArgumentException(err(bytesForFlags, "turn"));
         nextTurnBit = usedBits;
 
         //everything okay, add encoder
         edgeEncoders.add(encoder);
     }
 
+    private static String err(int bits, String flags) {
+        return "Encoders are requesting more than " + bits + " bits of " + flags + " flags.";
+    }
+
     /**
      * @return true if the specified encoder is found
      */
diff --git a/core/src/main/java/com/graphhopper/storage/DataAccess.java b/core/src/main/java/com/graphhopper/storage/DataAccess.java
index d400014f72..17d21cee34 100644
--- a/core/src/main/java/com/graphhopper/storage/DataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/DataAccess.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -115,6 +115,7 @@
      * In order to increase allocated space one needs to layout the underlying storage in segments.
      * This is how you can customize the size.
      */
+    // TODO: does client code really needs to know about implementation specifics like segment size?
     DataAccess setSegmentSize( int bytes );
 
     /**
diff --git a/core/src/main/java/com/graphhopper/storage/Directory.java b/core/src/main/java/com/graphhopper/storage/Directory.java
index 53cf760bd7..56676717ff 100644
--- a/core/src/main/java/com/graphhopper/storage/Directory.java
+++ b/core/src/main/java/com/graphhopper/storage/Directory.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -36,6 +36,7 @@
     /**
      * @return the order in which the data is stored
      */
+    // TODO: Do we really need to configure this? May be better define constant byte order?
     ByteOrder getByteOrder();
 
     /**
@@ -44,6 +45,7 @@
      */
     DataAccess find( String name );
 
+    // TODO: is it really needed? (konsoletyper)
     DataAccess find( String name, DAType type );
 
     /**
@@ -58,6 +60,7 @@
     /**
      * @return the default type of a newly created DataAccess object
      */
+    // TODO: is it really needed? (konsoletyper)
     DAType getDefaultType();
 
     /**
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index d17ac4382c..7b829d0d0b 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -1,10 +1,10 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
  *
  *       http://www.apache.org/licenses/LICENSE-2.0
@@ -215,10 +215,10 @@ private int distToInt( double distance )
                     + distance + ", maybe overflow issue? integer: " + integ);
 
         // Due to rounding errors e.g. when getting the distance from another DataAccess object
-        // the following exception is not a good idea: 
+        // the following exception is not a good idea:
         // Allow integ to be 0 only if distance is 0
         // if (integ == 0 && distance > 0)
-        //    throw new IllegalStateException("Distance wasn't 0 but converted integer was: " + 
+        //    throw new IllegalStateException("Distance wasn't 0 but converted integer was: " +
         //            distance + ", integer: " + integ);
         return integ;
     }
@@ -1115,7 +1115,7 @@ public void optimize()
         if (delNodes <= 0)
             return;
 
-        // Deletes only nodes. 
+        // Deletes only nodes.
         // It reduces the fragmentation of the node space but introduces new unused edges.
         inPlaceNodeRemove(delNodes);
 
@@ -1169,7 +1169,7 @@ private void invalidateEdge( long edgePointer )
      */
     private void inPlaceNodeRemove( int removeNodeCount )
     {
-        // Prepare edge-update of nodes which are connected to deleted nodes        
+        // Prepare edge-update of nodes which are connected to deleted nodes
         int toMoveNode = getNodes();
         int itemsToMove = 0;
 
@@ -1179,7 +1179,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
         removedNodes.copyTo(toRemoveSet);
 
         EdgeExplorer delExplorer = createEdgeExplorer(EdgeFilter.ALL_EDGES);
-        // create map of old node ids pointing to new ids        
+        // create map of old node ids pointing to new ids
         for (int removeNode = removedNodes.next(0);
                 removeNode >= 0;
                 removeNode = removedNodes.next(removeNode + 1))
@@ -1275,7 +1275,7 @@ private void inPlaceNodeRemove( int removeNodeCount )
             if (!toMoveSet.contains(nodeA) && !toMoveSet.contains(nodeB))
                 continue;
 
-            // now overwrite exiting edge with new node ids 
+            // now overwrite exiting edge with new node ids
             // also flags and links could have changed due to different node order
             int updatedA = oldToNewMap.get(nodeA);
             if (updatedA < 0)
@@ -1377,7 +1377,8 @@ public boolean loadExisting()
             } else
                 throw new IllegalStateException("cannot load properties. corrupt file or directory? " + dir);
 
-            if (encodingManager == null)
+            // TODO: This uses reflection indirectly. Can we avoid it?
+            /*if (encodingManager == null)
             {
                 if (acceptStr.isEmpty())
                     throw new IllegalStateException("No EncodingManager was configured. And no one was found in the graph: "
@@ -1391,7 +1392,7 @@ public boolean loadExisting()
             {
                 throw new IllegalStateException("Encoding does not match:\nGraphhopper config: " + encodingManager.toDetailsString()
                         + "\nGraph: " + acceptStr + ", dir:" + dir.getLocation());
-            }
+            }*/
 
             String dim = properties.get("graph.dimension");
             if (!dim.equalsIgnoreCase("" + nodeAccess.getDimension()))
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index 495d795b8d..351f651c99 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -1,14 +1,14 @@
 /*
  *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
+ *
+ *  GraphHopper licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
  *  compliance with the License. You may obtain a copy of the License at
- * 
+ *
  *       http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -37,7 +37,7 @@
     private boolean closed = false;
     private boolean store;
 
-    RAMDataAccess( String name, String location, boolean store, ByteOrder order )
+    public RAMDataAccess( String name, String location, boolean store, ByteOrder order )
     {
         super(name, location, order);
         this.store = store;
@@ -148,7 +148,7 @@ public boolean loadExisting()
                     return false;
 
                 raFile.seek(HEADER_OFFSET);
-                // raFile.readInt() <- too slow                
+                // raFile.readInt() <- too slow
                 int segmentCount = (int) (byteCount / segmentSizeInBytes);
                 if (byteCount % segmentSizeInBytes != 0)
                     segmentCount++;
diff --git a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/InMemoryDataAccess.java b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/InMemoryDataAccess.java
new file mode 100644
index 0000000000..99de7e191c
--- /dev/null
+++ b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/InMemoryDataAccess.java
@@ -0,0 +1,283 @@
+package com.graphhopper.teavm;
+
+import java.nio.ByteOrder;
+import java.util.Arrays;
+import org.slf4j.LoggerFactory;
+import com.graphhopper.storage.DAType;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.util.BitUtil;
+
+/**
+ *
+ * @author Alexey Andreev
+ */
+class InMemoryDataAccess implements DataAccess {
+    private InMemoryDirectory directory;
+    protected static final int SEGMENT_SIZE_MIN = 1 << 7;
+    private static final int SEGMENT_SIZE_DEFAULT = 1 << 20;
+    private byte[][] segments = new byte[0][];
+    protected int header[] = new int[(HEADER_OFFSET - 20) / 4];
+    protected static final int HEADER_OFFSET = 20 * 4 + 20;
+    protected int segmentSizeInBytes = SEGMENT_SIZE_DEFAULT;
+    protected transient int segmentSizePower;
+    protected transient int indexDivisor;
+    protected final BitUtil bitUtil;
+    private String name;
+
+    public InMemoryDataAccess(InMemoryDirectory directory, String name, ByteOrder order) {
+        this.directory = directory;
+        this.name = name;
+        bitUtil = BitUtil.get(order);
+    }
+
+    @Override
+    public DataAccess copyTo(DataAccess da) {
+        copyHeader(da);
+        da.incCapacity(getCapacity());
+        long cap = getCapacity();
+        // currently get/setBytes does not support copying more bytes then segmentSize
+        int segSize = Math.min(da.getSegmentSize(), getSegmentSize());
+        byte[] bytes = new byte[segSize];
+        for (long bytePos = 0; bytePos < cap; bytePos += segSize) {
+            getBytes(bytePos, bytes, segSize);
+            da.setBytes(bytePos, bytes, segSize);
+        }
+        return da;
+    }
+
+    protected void copyHeader( DataAccess da )
+    {
+        for (int h = 0; h < header.length * 4; h += 4)
+        {
+            da.setHeader(h, getHeader(h));
+        }
+    }
+
+
+    @Override
+    public DataAccess create( long bytes )
+    {
+        if (segments.length > 0)
+            throw new IllegalThreadStateException("already created");
+
+        // initialize transient values
+        setSegmentSize(segmentSizeInBytes);
+        incCapacity(Math.max(10 * 4, bytes));
+        return this;
+    }
+
+    @Override
+    public boolean incCapacity( long bytes )
+    {
+        if (bytes < 0)
+            throw new IllegalArgumentException("new capacity has to be strictly positive");
+
+        long cap = getCapacity();
+        long todoBytes = bytes - cap;
+        if (todoBytes <= 0)
+            return false;
+
+        int segmentsToCreate = (int) (todoBytes / segmentSizeInBytes);
+        if (todoBytes % segmentSizeInBytes != 0)
+            segmentsToCreate++;
+
+        byte[][] newSegs = Arrays.copyOf(segments, segments.length + segmentsToCreate);
+        for (int i = segments.length; i < newSegs.length; i++)
+        {
+            newSegs[i] = new byte[1 << segmentSizePower];
+        }
+        segments = newSegs;
+        return true;
+    }
+
+    @Override
+    public void flush()
+    {
+        // Do nothing, as we always keep everything in memory
+    }
+
+    @Override
+    public final void setInt( long bytePos, int value )
+    {
+        assert segmentSizePower > 0 : "call create or loadExisting before usage!";
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        assert index + 4 <= segmentSizeInBytes : "integer cannot be distributed over two segments";
+        bitUtil.fromInt(segments[bufferIndex], value, index);
+    }
+
+    @Override
+    public final int getInt( long bytePos )
+    {
+        assert segmentSizePower > 0 : "call create or loadExisting before usage!";
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        assert index + 4 <= segmentSizeInBytes : "integer cannot be distributed over two segments";
+        if (bufferIndex > segments.length)
+        {
+            LoggerFactory.getLogger(getClass()).error(getName() + ", segments:" + segments.length
+                    + ", bufIndex:" + bufferIndex + ", bytePos:" + bytePos
+                    + ", segPower:" + segmentSizePower);
+        }
+        return bitUtil.toInt(segments[bufferIndex], index);
+    }
+
+    @Override
+    public final void setShort( long bytePos, short value )
+    {
+        assert segmentSizePower > 0 : "call create or loadExisting before usage!";
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        assert index + 2 <= segmentSizeInBytes : "integer cannot be distributed over two segments";
+        bitUtil.fromShort(segments[bufferIndex], value, index);
+    }
+
+    @Override
+    public final short getShort( long bytePos )
+    {
+        assert segmentSizePower > 0 : "call create or loadExisting before usage!";
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        assert index + 2 <= segmentSizeInBytes : "integer cannot be distributed over two segments";
+        return bitUtil.toShort(segments[bufferIndex], index);
+    }
+
+    @Override
+    public void setBytes( long bytePos, byte[] values, int length )
+    {
+        assert length <= segmentSizeInBytes : "the length has to be smaller or equal to the segment size: " + length + " vs. " + segmentSizeInBytes;
+        assert segmentSizePower > 0 : "call create or loadExisting before usage!";
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        byte[] seg = segments[bufferIndex];
+        int delta = index + length - segmentSizeInBytes;
+        if (delta > 0)
+        {
+            length -= delta;
+            System.arraycopy(values, 0, seg, index, length);
+            seg = segments[bufferIndex + 1];
+            System.arraycopy(values, length, seg, 0, delta);
+        } else
+        {
+            System.arraycopy(values, 0, seg, index, length);
+        }
+    }
+
+    @Override
+    public void getBytes( long bytePos, byte[] values, int length )
+    {
+        assert length <= segmentSizeInBytes : "the length has to be smaller or equal to the segment size: " + length + " vs. " + segmentSizeInBytes;
+        assert segmentSizePower > 0 : "call create or loadExisting before usage!";
+        int bufferIndex = (int) (bytePos >>> segmentSizePower);
+        int index = (int) (bytePos & indexDivisor);
+        byte[] seg = segments[bufferIndex];
+        int delta = index + length - segmentSizeInBytes;
+        if (delta > 0)
+        {
+            length -= delta;
+            System.arraycopy(seg, index, values, 0, length);
+            seg = segments[bufferIndex + 1];
+            System.arraycopy(seg, 0, values, length, delta);
+        } else
+        {
+            System.arraycopy(seg, index, values, 0, length);
+        }
+    }
+
+    @Override
+    public void close()
+    {
+        segments = new byte[0][];
+    }
+
+    @Override
+    public long getCapacity()
+    {
+        return (long) getSegments() * segmentSizeInBytes;
+    }
+
+    @Override
+    public int getSegments()
+    {
+        return segments.length;
+    }
+
+    @Override
+    public void trimTo( long capacity )
+    {
+        if (capacity > getCapacity())
+        {
+            throw new IllegalStateException("Cannot increase capacity (" + getCapacity() + ") to " + capacity
+                    + " via trimTo. Use ensureCapacity instead. ");
+        }
+
+        if (capacity < segmentSizeInBytes)
+            capacity = segmentSizeInBytes;
+
+        int remainingSegments = (int) (capacity / segmentSizeInBytes);
+        if (capacity % segmentSizeInBytes != 0)
+        {
+            remainingSegments++;
+        }
+
+        segments = Arrays.copyOf(segments, remainingSegments);
+    }
+
+    @Override
+    public void rename( String newName )
+    {
+        if (directory.dataAccessMap.containsKey(newName)) {
+            throw new IllegalArgumentException("File " + newName + " already exists");
+        }
+        directory.dataAccessMap.remove(name);
+        name = newName;
+        directory.dataAccessMap.put(newName, this);
+    }
+
+    @Override
+    public DAType getType()
+    {
+        return DAType.RAM;
+    }
+
+    @Override
+    public boolean loadExisting() {
+        // TODO: implement loading from image, obtained from server
+        return true;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public void setHeader(int bytePos, int value) {
+        bytePos >>= 2;
+        header[bytePos] = value;
+    }
+
+    @Override
+    public int getHeader(int bytePos) {
+        bytePos >>= 2;
+        return header[bytePos];
+    }
+
+    @Override
+    public DataAccess setSegmentSize(int bytes) {
+        if (bytes > 0)
+        {
+            // segment size should be a power of 2
+            int tmp = (int) (Math.log(bytes) / Math.log(2));
+            segmentSizeInBytes = Math.max((int) Math.pow(2, tmp), SEGMENT_SIZE_MIN);
+        }
+        segmentSizePower = (int) (Math.log(segmentSizeInBytes) / Math.log(2));
+        indexDivisor = segmentSizeInBytes - 1;
+        return this;
+    }
+
+    @Override
+    public int getSegmentSize() {
+        return segmentSizeInBytes;
+    }
+}
diff --git a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/InMemoryDirectory.java b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/InMemoryDirectory.java
index ca7177d4d0..ae5c17965e 100644
--- a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/InMemoryDirectory.java
+++ b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/InMemoryDirectory.java
@@ -1,6 +1,8 @@
 package com.graphhopper.teavm;
 
 import java.nio.ByteOrder;
+import java.util.HashMap;
+import java.util.Map;
 import com.graphhopper.storage.DAType;
 import com.graphhopper.storage.DataAccess;
 import com.graphhopper.storage.Directory;
@@ -10,36 +12,45 @@
  * @author Alexey Andreev <konsoletyper@gmail.com>
  */
 public class InMemoryDirectory implements Directory {
+    Map<String, InMemoryDataAccess> dataAccessMap = new HashMap<String, InMemoryDataAccess>();
+
     @Override
     public String getLocation() {
-        return null;
+        return "memory";
     }
 
     @Override
     public ByteOrder getByteOrder() {
-        return null;
+        return ByteOrder.BIG_ENDIAN;
     }
 
     @Override
     public DataAccess find(String name) {
-        return null;
+        InMemoryDataAccess dataAccess = dataAccessMap.get(name);
+        if (dataAccess == null) {
+            dataAccess = new InMemoryDataAccess(this, name, getByteOrder());
+            dataAccessMap.put(name, dataAccess);
+        }
+        return dataAccess;
     }
 
     @Override
     public DataAccess find(String name, DAType type) {
-        return null;
+        return find(name);
     }
 
     @Override
     public void clear() {
+        dataAccessMap.clear();
     }
 
     @Override
     public void remove(DataAccess da) {
+        dataAccessMap.remove(da.getName());
     }
 
     @Override
     public DAType getDefaultType() {
-        return null;
+        return DAType.RAM;
     }
 }
diff --git a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Main.java b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Main.java
index d70705dd94..1250db289a 100644
--- a/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Main.java
+++ b/graphhopper-teavm/src/main/java/com/graphhopper/teavm/Main.java
@@ -11,10 +11,9 @@
 public class Main {
     public static void main(String[] args) {
         InMemoryDirectory directory = new InMemoryDirectory();
-        GraphHopperStorage graph = new GraphHopperStorage(directory, new EncodingManager(EncodingManager.BIKE), false);
+        EncodingManager encodingManager = new EncodingManager(new BikeFlagEncoder());
+        GraphHopperStorage graph = new GraphHopperStorage(directory, encodingManager, false);
         graph.loadExisting();
-
-        EncodingManager encodingManager = graph.getEncodingManager();
         FlagEncoder encoder = encodingManager.getSingle();
 
         Weighting weighting = new FastestWeighting(encoder);
