diff --git a/.gitignore b/.gitignore
index fd877b1f67..9cb83438ce 100644
--- a/.gitignore
+++ b/.gitignore
@@ -41,3 +41,4 @@ local.properties
 .DS_Store
 /core/nbproject/
 /reader-overlay-data/nbproject/
+!malta-latest.osm.pbf 
\ No newline at end of file
diff --git a/reader-shp/.gitignore b/reader-shp/.gitignore
deleted file mode 100644
index cf1ecc509d..0000000000
--- a/reader-shp/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-#Don't ignore my Malta test data used in the automated test!!
-!malta-latest.osm.pbf 
\ No newline at end of file
diff --git a/reader-shp/pom.xml b/reader-shp/pom.xml
index 049d5744ee..2019f8be66 100644
--- a/reader-shp/pom.xml
+++ b/reader-shp/pom.xml
@@ -10,7 +10,7 @@
     <name>GraphHopper Reader for Shapefile Data</name>
 	
     <properties>      
-        <geotools.version>13.2</geotools.version>
+        <geotools.version>15.2</geotools.version>
     </properties>
     	
     <parent>
@@ -58,7 +58,7 @@
         </dependency>
         
         <dependency>
-        	<!--  Inlucde the pbf reader for test purposes -->
+        	<!--  Include the pbf reader for test purposes -->
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-reader-osm</artifactId>
             <version>${project.parent.version}</version>
@@ -74,24 +74,4 @@
         </repository>
     </repositories>
 	
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-assembly-plugin</artifactId>                
-                <configuration>
-                    <archive>
-                        <manifest>
-                            <mainClass>com.graphhopper.import.osm.Import</mainClass>
-                        </manifest>
-                    </archive>
-                        	                    
-                    <!-- for standalone usage -->
-                    <descriptorRefs>
-                        <descriptorRef>jar-with-dependencies</descriptorRef>
-                    </descriptorRefs>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
 </project>
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
index 7a21c3149c..3e3621f3a7 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
@@ -1,7 +1,23 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package com.graphhopper.reader.shp;
 
 import java.io.File;
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashSet;
@@ -30,300 +46,312 @@
 import gnu.trove.map.hash.TObjectIntHashMap;
 
 /**
- * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It extracts the data as per the structure of
- * shape files
+ * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It
+ * extracts the data as per the structure of shape files
  *
- * @author Vikas Veshishth, Philip Welch
+ * @author Vikas Veshishth
+ * @author Philip Welch
  */
 public class OSMShapeFileReader extends ShapeFileReader {
-	private static final int COORD_STATE_UNKNOWN = -1;
-	private static final int COORD_STATE_PILLAR = -2;
-	private static final int FIRST_NODE_ID = 1;
-	private static final String[] DIRECT_COPY_TAGS = new String[] { "name" };
-	private File roadsFile;
-	private TObjectIntHashMap<Coordinate> coordState = new TObjectIntHashMap<>(Constants.DEFAULT_CAPACITY, Constants.DEFAULT_LOAD_FACTOR,
-			COORD_STATE_UNKNOWN);
-	private final DistanceCalc distCalc = Helper.DIST_EARTH;
-	private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
-	private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
-	private int nextNodeId = FIRST_NODE_ID;
-
-	public OSMShapeFileReader(GraphHopperStorage ghStorage) {
-		super(ghStorage);
-	}
-
-	private List<Coordinate[]> getCoords(Object o) {
-		ArrayList<Coordinate[]> ret = new ArrayList<>();
-		if (o == null) {
-			return ret;
-		}
-
-		if (o instanceof LineString) {
-			ret.add(((LineString) o).getCoordinates());
-		} else if (o instanceof MultiLineString) {
-			MultiLineString mls = (MultiLineString) o;
-			int n = mls.getNumGeometries();
-			for (int i = 0; i < n; i++) {
-				ret.add(mls.getGeometryN(i).getCoordinates());
-			}
-		}
-
-		return ret;
-	}
-
-	@Override
-	void processJunctions() throws IOException {
-		{
-			DataStore dataStore = null;
-			FeatureIterator<SimpleFeature> roads = null;
-
-			try {
-				dataStore = openShapefileDataStore(roadsFile);
-				roads = getFeatureIerator(dataStore);
-
-				HashSet<Coordinate> tmpSet = new HashSet<>();
-				while (roads.hasNext()) {
-					SimpleFeature road = roads.next();
-
-					for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
-						tmpSet.clear();
-						for (int i = 0; i < points.length; i++) {
-							Coordinate c = points[i];
-
-							// don't add the same coord twice for the same edge - happens with bad geometry, i.e.
-							// duplicate coords or a road which forms a circle (e.g. roundabout)
-							if (tmpSet.contains(c)) {
-								continue;
-							}
-							tmpSet.add(c);
-
-							// skip if its already a node
-							int state = coordState.get(c);
-							if (state >= FIRST_NODE_ID) {
-								continue;
-							}
-
-							if (i == 0 || i == points.length - 1 || state == COORD_STATE_PILLAR) {
-								// turn into a node if its the first or last point, or already appeared in another edge
-								int nodeId = nextNodeId++;
-								coordState.put(c, nodeId);
-								saveTowerPosition(nodeId, c);
-							} else if (state == COORD_STATE_UNKNOWN) {
-								// mark it as a pillar (which may get upgraded to an edge later)
-								coordState.put(c, COORD_STATE_PILLAR);
-							}
-						}
-					}
-
-				}
-			} finally {
-				if (roads != null) {
-					roads.close();
-				}
-				if (dataStore != null) {
-					dataStore.dispose();
-				}
-			}
-
-			LOGGER.info("Number of junction points : " + (nextNodeId - FIRST_NODE_ID));
-
-		}
-	}
-
-	@Override
-	void processRoads() throws IOException {
-
-		DataStore dataStore = null;
-		FeatureIterator<SimpleFeature> roads = null;
-
-		try {
-			dataStore = openShapefileDataStore(roadsFile);
-			roads = getFeatureIerator(dataStore);
-
-			while (roads.hasNext()) {
-				SimpleFeature road = roads.next();
-
-				for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
-
-					// Parse all points in the geometry, splitting into individual graphhopper edges
-					// whenever we find a node in the list of points
-					Coordinate startTowerPnt = null;
-					List<Coordinate> pillars = new ArrayList<Coordinate>();
-					for (Coordinate point : points) {
-						if (startTowerPnt == null) {
-							startTowerPnt = point;
-						} else {
-							int state = coordState.get(point);
-							if (state >= FIRST_NODE_ID) {
-								int fromTowerNodeId = coordState.get(startTowerPnt);
-								int toTowerNodeId = state;
-
-								// get distance and estimated centres
-								double distance = getWayLength(startTowerPnt, pillars, point);
-								GHPoint estmCentre = new GHPoint(0.5 * (lat(startTowerPnt) + lat(point)),
-										0.5 * (lng(startTowerPnt) + lng(point)));
-								PointList pillarNodes = new PointList(pillars.size(), false);
-
-								for (Coordinate pillar : pillars) {
-									pillarNodes.add(lat(pillar), lng(pillar));
-								}
-
-								addEdge(fromTowerNodeId, toTowerNodeId, road, distance, estmCentre, pillarNodes);
-								startTowerPnt = point;
-								pillars.clear();
-							} else {
-								pillars.add(point);
-							}
-						}
-					}
-				}
-
-			}
-		} catch (Exception e) {
-			LOGGER.error("Exception while processing for roads: ", e);
-		} finally {
-			if (roads != null) {
-				roads.close();
-			}
-
-			if (dataStore != null) {
-				dataStore.dispose();
-			}
-		}
-	}
-
-	private double getWayLength(Coordinate start, List<Coordinate> pillars, Coordinate end) {
-		double distance = 0;
-
-		Coordinate previous = start;
-		for (Coordinate point : pillars) {
-			distance += distCalc.calcDist(lat(previous), lng(previous), lat(point), lng(point));
-			previous = point;
-		}
-		distance += distCalc.calcDist(lat(previous), lng(previous), lat(end), lng(end));
-
-		return distance;
-	}
-
-	@Override
-	public DataReader setFile(File file) {
-		this.roadsFile = file;
-		return this;
-	}
-
-	@Override
-	public DataReader setElevationProvider(ElevationProvider ep) {
-		// Elevation not supported
-		return this;
-	}
-
-	@Override
-	public DataReader setWorkerThreads(int workerThreads) {
-		// Its only single-threaded
-		return this;
-	}
-
-	@Override
-	public DataReader setWayPointMaxDistance(double wayPointMaxDistance) {
-		// TODO Auto-generated method stub
-		return this;
-	}
-
-	@Override
-	public Date getDataDate() {
-		return null;
-	}
-
-	public static interface EdgeAddedListener {
-		void edgeAdded(ReaderWay way, EdgeIteratorState edge);
-	}
-
-	private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance, GHPoint estmCentre, PointList pillarNodes) {
-		EdgeIteratorState edge = graph.edge(fromTower, toTower);
-
-		// read the OSM id, should never be null
-		long id = getOSMId(road);
-
-		// Make a temporary ReaderWay object with the properties we need so we can use the enocding manager
-		// We (hopefully don't need the node structure on here as we're only calling the flag
-		// encoders, which don't use this...
-		ReaderWay way = new ReaderWay(id);
-
-		way.setTag("estimated_distance", distance);
-		way.setTag("estimated_center", estmCentre);
-
-		// read the highway type
-		Object type = road.getAttribute("fclass");
-		if (type != null) {
-			way.setTag("highway", type.toString());
-		}
-
-		// read maxspeed filtering for 0 which for Geofabrik shapefiles appears to correspond to no tag
-		Object maxSpeed = road.getAttribute("maxspeed");
-		if (maxSpeed != null && !maxSpeed.toString().trim().equals("0")) {
-			way.setTag("maxspeed", maxSpeed.toString());
-		}
-
-		for (String tag : DIRECT_COPY_TAGS) {
-			Object val = road.getAttribute(tag);
-			if (val != null) {
-				way.setTag(tag, val.toString());
-			}
-		}
-
-		// read oneway
-		Object oneway = road.getAttribute("oneway");
-		if (oneway != null) {
-			// Geofabrik is using an odd convention for oneway field in shapefile.
-			// We map back to the standard convention so that tag can be dealt with correctly by the flag encoder.
-			String val = oneway.toString().trim().toLowerCase();
-			if (val.equals("b")) {
-				// both ways
-				val = "no";
-			} else if (val.equals("t")) {
-				// one way against the direction of digitisation
-				val = "-1";
-			} else if (val.equals("f")) {
-				// one way Forward in the direction of digitisation
-				val = "yes";
-			} else {
-				throw new RuntimeException("Unrecognised value of oneway field \"" + val + "\" found in road with OSM id " + id);
-			}
-
-			way.setTag("oneway", val);
-		}
-
-		// Process the flags using the encoders
-		long includeWay = encodingManager.acceptWay(way);
-		if (includeWay == 0) {
-			return;
-		}
-
-		// TODO we're not using the relation flags
-		long relationFlags = 0;
-
-		long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
-		if (wayFlags == 0)
-			return;
-
-		edge.setDistance(distance);
-		edge.setFlags(wayFlags);
-		edge.setWayGeometry(pillarNodes);
-
-		if (edgeAddedListeners.size() > 0) {
-			// check size first so we only allocate the iterator if we have listeners
-			for (EdgeAddedListener l : edgeAddedListeners) {
-				l.edgeAdded(way, edge);
-			}
-		}
-	}
-
-	private long getOSMId(SimpleFeature road) {
-		long id = Long.parseLong(road.getAttribute("osm_id").toString());
-		return id;
-	}
-
-	public void addListener(EdgeAddedListener l) {
-		edgeAddedListeners.add(l);
-	}
+    private static final int COORD_STATE_UNKNOWN = -1;
+    private static final int COORD_STATE_PILLAR = -2;
+    private static final int FIRST_NODE_ID = 1;
+    private static final String[] DIRECT_COPY_TAGS = new String[] { "name" };
+    private File roadsFile;
+    private TObjectIntHashMap<Coordinate> coordState = new TObjectIntHashMap<>(
+                    Constants.DEFAULT_CAPACITY, Constants.DEFAULT_LOAD_FACTOR, COORD_STATE_UNKNOWN);
+    private final DistanceCalc distCalc = Helper.DIST_EARTH;
+    private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
+    private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
+    private int nextNodeId = FIRST_NODE_ID;
+
+    public OSMShapeFileReader(GraphHopperStorage ghStorage) {
+        super(ghStorage);
+    }
+
+    private List<Coordinate[]> getCoords(Object o) {
+        ArrayList<Coordinate[]> ret = new ArrayList<>();
+        if (o == null) {
+            return ret;
+        }
+
+        if (o instanceof LineString) {
+            ret.add(((LineString) o).getCoordinates());
+        } else if (o instanceof MultiLineString) {
+            MultiLineString mls = (MultiLineString) o;
+            int n = mls.getNumGeometries();
+            for (int i = 0; i < n; i++) {
+                ret.add(mls.getGeometryN(i).getCoordinates());
+            }
+        }
+
+        return ret;
+    }
+
+    @Override
+    void processJunctions() {
+        DataStore dataStore = null;
+        FeatureIterator<SimpleFeature> roads = null;
+
+        try {
+            dataStore = openShapefileDataStore(roadsFile);
+            roads = getFeatureIterator(dataStore);
+
+            HashSet<Coordinate> tmpSet = new HashSet<>();
+            while (roads.hasNext()) {
+                SimpleFeature road = roads.next();
+
+                for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
+                    tmpSet.clear();
+                    for (int i = 0; i < points.length; i++) {
+                        Coordinate c = points[i];
+
+                        // don't add the same coord twice for the same edge
+                        // - happens with bad geometry, i.e.
+                        // duplicate coords or a road which forms a circle
+                        // (e.g. roundabout)
+                        if (tmpSet.contains(c)) {
+                            continue;
+                        }
+                        tmpSet.add(c);
+
+                        // skip if its already a node
+                        int state = coordState.get(c);
+                        if (state >= FIRST_NODE_ID) {
+                            continue;
+                        }
+
+                        if (i == 0 || i == points.length - 1 || state == COORD_STATE_PILLAR) {
+                            // turn into a node if its the first or last
+                            // point, or already appeared in another edge
+                            int nodeId = nextNodeId++;
+                            coordState.put(c, nodeId);
+                            saveTowerPosition(nodeId, c);
+                        } else if (state == COORD_STATE_UNKNOWN) {
+                            // mark it as a pillar (which may get upgraded
+                            // to an edge later)
+                            coordState.put(c, COORD_STATE_PILLAR);
+                        }
+                    }
+                }
+
+            }
+        } finally {
+            if (roads != null) {
+                roads.close();
+            }
+            if (dataStore != null) {
+                dataStore.dispose();
+            }
+        }
+
+        LOGGER.info("Number of junction points : " + (nextNodeId - FIRST_NODE_ID));
+
+    }
+
+    @Override
+    void processRoads() {
+
+        DataStore dataStore = null;
+        FeatureIterator<SimpleFeature> roads = null;
+
+        try {
+            dataStore = openShapefileDataStore(roadsFile);
+            roads = getFeatureIterator(dataStore);
+
+            while (roads.hasNext()) {
+                SimpleFeature road = roads.next();
+
+                for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
+
+                    // Parse all points in the geometry, splitting into
+                    // individual graphhopper edges
+                    // whenever we find a node in the list of points
+                    Coordinate startTowerPnt = null;
+                    List<Coordinate> pillars = new ArrayList<Coordinate>();
+                    for (Coordinate point : points) {
+                        if (startTowerPnt == null) {
+                            startTowerPnt = point;
+                        } else {
+                            int state = coordState.get(point);
+                            if (state >= FIRST_NODE_ID) {
+                                int fromTowerNodeId = coordState.get(startTowerPnt);
+                                int toTowerNodeId = state;
+
+                                // get distance and estimated centres
+                                double distance = getWayLength(startTowerPnt, pillars, point);
+                                GHPoint estmCentre = new GHPoint(
+                                                0.5 * (lat(startTowerPnt) + lat(point)),
+                                                0.5 * (lng(startTowerPnt) + lng(point)));
+                                PointList pillarNodes = new PointList(pillars.size(), false);
+
+                                for (Coordinate pillar : pillars) {
+                                    pillarNodes.add(lat(pillar), lng(pillar));
+                                }
+
+                                addEdge(fromTowerNodeId, toTowerNodeId, road, distance, estmCentre,
+                                                pillarNodes);
+                                startTowerPnt = point;
+                                pillars.clear();
+                            } else {
+                                pillars.add(point);
+                            }
+                        }
+                    }
+                }
+
+            }
+        } finally {
+            if (roads != null) {
+                roads.close();
+            }
+
+            if (dataStore != null) {
+                dataStore.dispose();
+            }
+        }
+    }
+
+    private double getWayLength(Coordinate start, List<Coordinate> pillars, Coordinate end) {
+        double distance = 0;
+
+        Coordinate previous = start;
+        for (Coordinate point : pillars) {
+            distance += distCalc.calcDist(lat(previous), lng(previous), lat(point), lng(point));
+            previous = point;
+        }
+        distance += distCalc.calcDist(lat(previous), lng(previous), lat(end), lng(end));
+
+        return distance;
+    }
+
+    @Override
+    public DataReader setFile(File file) {
+        this.roadsFile = file;
+        return this;
+    }
+
+    @Override
+    public DataReader setElevationProvider(ElevationProvider ep) {
+        // Elevation not supported
+        return this;
+    }
+
+    @Override
+    public DataReader setWorkerThreads(int workerThreads) {
+        // Its only single-threaded
+        return this;
+    }
+
+    @Override
+    public DataReader setWayPointMaxDistance(double wayPointMaxDistance) {
+        // TODO Auto-generated method stub
+        return this;
+    }
+
+    @Override
+    public Date getDataDate() {
+        return null;
+    }
+
+    public static interface EdgeAddedListener {
+        void edgeAdded(ReaderWay way, EdgeIteratorState edge);
+    }
+
+    private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance,
+                    GHPoint estmCentre, PointList pillarNodes) {
+        EdgeIteratorState edge = graph.edge(fromTower, toTower);
+
+        // read the OSM id, should never be null
+        long id = getOSMId(road);
+
+        // Make a temporary ReaderWay object with the properties we need so we
+        // can use the enocding manager
+        // We (hopefully don't need the node structure on here as we're only
+        // calling the flag
+        // encoders, which don't use this...
+        ReaderWay way = new ReaderWay(id);
+
+        way.setTag("estimated_distance", distance);
+        way.setTag("estimated_center", estmCentre);
+
+        // read the highway type
+        Object type = road.getAttribute("fclass");
+        if (type != null) {
+            way.setTag("highway", type.toString());
+        }
+
+        // read maxspeed filtering for 0 which for Geofabrik shapefiles appears
+        // to correspond to no tag
+        Object maxSpeed = road.getAttribute("maxspeed");
+        if (maxSpeed != null && !maxSpeed.toString().trim().equals("0")) {
+            way.setTag("maxspeed", maxSpeed.toString());
+        }
+
+        for (String tag : DIRECT_COPY_TAGS) {
+            Object val = road.getAttribute(tag);
+            if (val != null) {
+                way.setTag(tag, val.toString());
+            }
+        }
+
+        // read oneway
+        Object oneway = road.getAttribute("oneway");
+        if (oneway != null) {
+            // Geofabrik is using an odd convention for oneway field in
+            // shapefile.
+            // We map back to the standard convention so that tag can be dealt
+            // with correctly by the flag encoder.
+            String val = oneway.toString().trim().toLowerCase();
+            if (val.equals("b")) {
+                // both ways
+                val = "no";
+            } else if (val.equals("t")) {
+                // one way against the direction of digitisation
+                val = "-1";
+            } else if (val.equals("f")) {
+                // one way Forward in the direction of digitisation
+                val = "yes";
+            } else {
+                throw new RuntimeException("Unrecognised value of oneway field \"" + val
+                                + "\" found in road with OSM id " + id);
+            }
+
+            way.setTag("oneway", val);
+        }
+
+        // Process the flags using the encoders
+        long includeWay = encodingManager.acceptWay(way);
+        if (includeWay == 0) {
+            return;
+        }
+
+        // TODO we're not using the relation flags
+        long relationFlags = 0;
+
+        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
+        if (wayFlags == 0)
+            return;
+
+        edge.setDistance(distance);
+        edge.setFlags(wayFlags);
+        edge.setWayGeometry(pillarNodes);
+
+        if (edgeAddedListeners.size() > 0) {
+            // check size first so we only allocate the iterator if we have
+            // listeners
+            for (EdgeAddedListener l : edgeAddedListeners) {
+                l.edgeAdded(way, edge);
+            }
+        }
+    }
+
+    private long getOSMId(SimpleFeature road) {
+        long id = Long.parseLong(road.getAttribute("osm_id").toString());
+        return id;
+    }
+
+    public void addListener(EdgeAddedListener l) {
+        edgeAddedListeners.add(l);
+    }
 }
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
index 5d012ef9d9..ddd8866421 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
@@ -1,7 +1,23 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package com.graphhopper.reader.shp;
 
 import java.io.File;
-import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -26,6 +42,7 @@
  * ShapeFileReader takes care of reading a shape file and writing it to a road network graph
  *
  * @author Vikas Veshishth
+ * @author Philip Welch
  */
 public abstract class ShapeFileReader implements DataReader {
 
@@ -41,31 +58,40 @@ public ShapeFileReader(GraphHopperStorage ghStorage) {
 	}
 
 	@Override
-	public void readGraph() throws IOException {
-		// TODO why 1000?
+	public void readGraph()  {
 		graphStorage.create(1000);
 		processJunctions();
 		processRoads();
 	}
 
-	abstract void processJunctions() throws IOException;
+	abstract void processJunctions() ;
 
-	abstract void processRoads() throws IOException;
+	abstract void processRoads() ;
 
-	protected FeatureIterator<SimpleFeature> getFeatureIerator(DataStore dataStore) throws IOException {
-		String typeName = dataStore.getTypeNames()[0];
-		FeatureSource<SimpleFeatureType, SimpleFeature> source = dataStore.getFeatureSource(typeName);
-		Filter filter = Filter.INCLUDE;
-		FeatureCollection<SimpleFeatureType, SimpleFeature> collection = source.getFeatures(filter);
+	protected FeatureIterator<SimpleFeature> getFeatureIterator(DataStore dataStore) {
+	    try {
+	        String typeName = dataStore.getTypeNames()[0];
+	        FeatureSource<SimpleFeatureType, SimpleFeature> source = dataStore.getFeatureSource(typeName);
+	        Filter filter = Filter.INCLUDE;
+	        FeatureCollection<SimpleFeatureType, SimpleFeature> collection = source.getFeatures(filter);
 
-		FeatureIterator<SimpleFeature> features = collection.features();
-		return features;
+	        FeatureIterator<SimpleFeature> features = collection.features();
+	        return features;
+            
+        } catch (Exception e) {
+            throw Utils.asUnchecked(e);
+        }
 	}
 
-	protected DataStore openShapefileDataStore(File file) throws IOException {
-		Map<String, Object> map = new HashMap<String, Object>();
-		map.put("url", file.toURI().toURL());
-		return DataStoreFinder.getDataStore(map);
+    protected DataStore openShapefileDataStore(File file) {
+        try {
+            Map<String, Object> map = new HashMap<String, Object>();
+            map.put("url", file.toURI().toURL());
+            return DataStoreFinder.getDataStore(map);
+            
+        } catch (Exception e) {
+            throw Utils.asUnchecked(e);
+        }
 	}
 
 	/*
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
index 2a36a51499..340702d66b 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
+++ b/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
@@ -1,17 +1,47 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package com.graphhopper.reader.shp;
 
 import com.graphhopper.util.PointList;
 import com.vividsolutions.jts.geom.Coordinate;
 import com.vividsolutions.jts.geom.GeometryFactory;
 
+/**
+ * 
+ * @author Phil
+ *
+ */
 public class Utils {
-	public static String toWKT(PointList list) {
-		int n = list.size();
-		GeometryFactory factory = new GeometryFactory();
-		Coordinate[] coords = new Coordinate[n];
-		for (int i = 0; i < coords.length; i++) {
-			coords[i] = new Coordinate(list.getLon(i), list.getLat(i));
-		}
-		return factory.createLineString(coords).toText();
-	}
+    public static String toWKT(PointList list) {
+        int n = list.size();
+        GeometryFactory factory = new GeometryFactory();
+        Coordinate[] coords = new Coordinate[n];
+        for (int i = 0; i < coords.length; i++) {
+            coords[i] = new Coordinate(list.getLon(i), list.getLat(i));
+        }
+        return factory.createLineString(coords).toText();
+    }
+    
+    public static RuntimeException asUnchecked(Throwable e){
+        if(RuntimeException.class.isInstance(e)){
+            return (RuntimeException)e;
+        }
+        return new RuntimeException(e);
+    }
+
 }
diff --git a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
index 4c6c6c57d9..cceb3df8ee 100644
--- a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
+++ b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
@@ -1,3 +1,20 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for 
+ *  additional information regarding copyright ownership.
+ * 
+ *  GraphHopper GmbH licenses this file to you under the Apache License, 
+ *  Version 2.0 (the "License"); you may not use this file except in 
+ *  compliance with the License. You may obtain a copy of the License at
+ * 
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package com.graphhopper.reader.shp;
 
 import static org.junit.Assert.assertEquals;
@@ -28,262 +45,271 @@
 import com.graphhopper.util.shapes.GHPoint;
 
 /**
-
+ * 
+ * @author Vikas Veshishth
  * @author Philip Welch
  */
 public class ShapeFileReaderTest {
 
-	private static final String shapefile = "/data/gis.osm_roads_free_1.shp";
-	private static final String pbf = "/data/malta-latest.osm.pbf";
-	private static final String tempOutputDirFromShp = "target/test-db-shp";
-	private static final String tempOutputDirFromPbf = "target/test-db-pbf";
-	private static GraphHopper hopperShp;
-	private static GraphHopper hopperPbf;
+    private static final String shapefile = "/data/gis.osm_roads_free_1.shp";
+    private static final String pbf = "/data/malta-latest.osm.pbf";
+    private static final String tempOutputDirFromShp = "target/test-db-shp";
+    private static final String tempOutputDirFromPbf = "target/test-db-pbf";
+    private static GraphHopper hopperShp;
+    private static GraphHopper hopperPbf;
     private final DistanceCalc distCalc = Helper.DIST_EARTH;
-    private static Exception BEFORE_CLASS_EXCEPTION=null;
-
-	private static class FromToPair{
-		final GHPoint from;
-		final GHPoint to;	
-		
-		FromToPair(double fromLat, double fromLng, double toLat, double toLng) {
-			this( new GHPoint(fromLat, fromLng), new GHPoint(toLat, toLng));
-		}
-
-		FromToPair(GHPoint from, GHPoint to) {
-			this.from = from;
-			this.to = to;
-		}
-
-		
-		PathWrapper getPath( GraphHopper hopper, boolean assertNoErrors) {
-			GHRequest request = new GHRequest(from, to).setVehicle("car");
-			GHResponse response = hopper.route(request);
-			
-			if(assertNoErrors){
-				assertFalse(response.hasErrors());				
-			}
-	
-			if(!response.hasErrors()){
-				return response.getBest();
-			}
-			return null;
-		}
-		
-	}
-	
-	private static class ExpectedDuration extends FromToPair {
-		final double minSecs;
-		final double maxSecs;
-
-		private ExpectedDuration(double fromLat, double fromLng, double toLat, double toLng, double minSecs, double maxSecs) {
-			super(fromLat, fromLng, toLat, toLng);
-			this.minSecs = minSecs;
-			this.maxSecs = maxSecs;
-		}
-	}
-
-	private static GraphHopper initHopper(GraphHopper gh, String inputFile, String outDir) {
-		URL resourceURL = ShapeFileReaderTest.class.getResource(inputFile);
-		try {
-			inputFile = new File(resourceURL.toURI()).getAbsolutePath();
-		} catch (Exception e) {
-			throw new RuntimeException(e);
-		}
-
-		// turn off geometry simplification so geometry should be the same between pbf and shapefile readers
-		gh.setWayPointMaxDistance(0);
-		return gh.setStoreOnFlush(false).setDataReaderFile(inputFile).setGraphHopperLocation(new File(outDir).getAbsolutePath())
-				.setEncodingManager(new EncodingManager(new CarFlagEncoder())).setCHEnabled(false).importOrLoad();
-
-	}
-
-	/**
-	 * Build the graphs once only for the various tests
-	 */
-	@BeforeClass
-	public static void setupBeforeClass() {
-		try {
-			new File(tempOutputDirFromShp).mkdirs();
-			new File(tempOutputDirFromPbf).mkdirs();
-			
-			System.out.println("Building from shapefile");
-			hopperShp = initHopper(new GraphhopperShp(), shapefile, tempOutputDirFromShp);
-
-			System.out.println("Building from pbf");
-			hopperPbf = initHopper(new GraphHopperOSM(), pbf, tempOutputDirFromPbf);
-
-			System.out.println("Finished building");			
-		} catch (Exception e) {
-			// Junit silently fails if we get an exception in the setup before class,
-			// so we record it here and explicitly rethrow it
-			BEFORE_CLASS_EXCEPTION = e;
-		}
-
-
-	}
-
-	@AfterClass
-	public static void teardownAfterClass() {
-		try {
-			hopperShp.close();
-			hopperShp.clean();
-		} catch (Exception e) {
-		}
-
-		try {
-			hopperPbf.close();
-			hopperPbf.clean();
-		} catch (Exception e) {
-		}
-
-	}
-
-	@Before
-	public void beforeTest()throws Exception{
-		// Rethrow the exception from @BeforeClass here so it doesn't silently fail.
-		// (Junit silently fails on exceptions thrown in @BeforeClass but not for 
-		// exceptions thrown in @Before)
-		if(BEFORE_CLASS_EXCEPTION!=null){
-			throw BEFORE_CLASS_EXCEPTION;
-		}
-	}
-	
-	@Test
-	public void testOneWay(){
-		// We setup 2 points very close together on a one-way street.
-		// As its a one way street, the ordering of the start and end requires going around the block to serve them.
-		// As the scenario is simple, we should get the same results from both shapefile and pbf.
-		// We should also get route distance to be many times physical distance
-		FromToPair pair = new FromToPair(35.898324,14.510729,35.898328,14.510681);
-		PathWrapper shp = pair.getPath(hopperShp,true);
-		PathWrapper pbf = pair.getPath(hopperPbf,true);
-		System.out.println("SHP:"+System.lineSeparator() +Utils.toWKT(shp.getPoints())+System.lineSeparator());
-		System.out.println("PBF:"+System.lineSeparator() +Utils.toWKT(pbf.getPoints())+System.lineSeparator());
-		double metresShp =shp.getDistance();
-		double metresPbf = pbf.getDistance();
-
-		// should be many times the physical separation between the points (as we had to go round the block)
-		double straightLineDistMetres = distCalc.calcDist(pair.from.lat, pair.from.lon,pair.to.lat, pair.to.lon);
-		assertTrue(metresShp > straightLineDistMetres * 25);
-		
-		// should be the same to within 1 cm
-		assertEquals(metresShp, metresPbf, 0.01);
-
-	}
-	
-	@Test
-	public void testGeometrySingleEdgePath()  {
-		// We choose a path along a single edge with a couple of minor bends,
-		// which we expect to give identical results...
-		FromToPair pair = new FromToPair(35.911694,14.492303, 35.911494,14.490489);
-		PointList shp = pair.getPath(hopperShp,true).getPoints();
-		PointList pbf = pair.getPath(hopperPbf,true).getPoints();
-		
-		assertTrue("The chosen edge had a couple of bends!", shp.getSize()>=2);
-		assertSameGeometry(shp, pbf);
-	}
-
-	private void assertSameGeometry(PointList shp, PointList pbf) {
-		assertEquals(shp.getSize(), pbf.getSize());
-		
-		for(int i=0;i<shp.getSize();  i++){
-			assertEquals(shp.getLat(i), pbf.getLat(i), 0.0000001);
-			assertEquals(shp.getLon(i), pbf.getLon(i), 0.0000001);
-		}
-	}
-
-	@Test
-	public void testTravelTimesBetweenRandomLocations(){
-		int nTests = 200;
-		final Random random = new Random(123);
-		final GHPoint min = new GHPoint(35.882931, 14.403076);
-		final GHPoint max = new GHPoint(35.913523, 14.448566);
-		
-		class RandPointGenerator{
-			double rand(double min, double max){
-				return min + random.nextDouble() * (max-min);
-			}
-			
-			GHPoint randPoint(){
-				return new GHPoint(rand(min.lat, max.lat), rand(min.lon, max.lon));
-			}
-			
-
-		}
-		RandPointGenerator pointGenerator = new RandPointGenerator();
-		
-		int nbFails =0;
-		DoubleSummaryStatistics stats = new DoubleSummaryStatistics();
-		for(int i =0 ; i < nTests ; i++){
-			FromToPair pair = new FromToPair(pointGenerator.randPoint(), pointGenerator.randPoint());
-			
-			// paths from random points can fail to don't assert on failure
-			PathWrapper shpPath = pair.getPath(hopperShp,false);
-			PathWrapper pbfPath = pair.getPath(hopperPbf,false);
-			
-			// paths between random points can fail to find a route (i.e. be off the road network)
-			if(shpPath==null || pbfPath==null){
-				nbFails++;
-				continue;
-			}
-			double shpSecs = getSecondsTravel(shpPath);
-			double pbfSecs = getSecondsTravel(pbfPath);
-
-			double frac = shpSecs / pbfSecs;
-			double percentageDeviation = Math.abs(1.0 - frac) * 100;
-			stats.accept(percentageDeviation);
-			System.out.println( "" + (i+1) + " from " + pair.from + " to " + pair.to + " pbfSecs=" + pbfSecs + " shpSecs=" + shpSecs + " % deviation=" + percentageDeviation);
-		}
-		
-		assertTrue("Number of fails should be small for the chosen box",nbFails < nTests /3);
-		
-		// Test mean fraction. There will be some deviation as not all tags are considered etc,
-		// but we expect it to be small for a large number of tests
-		double mean = stats.getAverage();
-		System.out.println("Mean % deviation between times " +mean);
-		assertTrue(mean < 1.0);
-	}
-	
-	
-	@Test
-	public void testTravelTimesBetweenPredefinedLocations() throws URISyntaxException {
-
-		// try a couple of test points, with an expected time range that will only fail if something is really bad...
-		ExpectedDuration[] expected = new ExpectedDuration[] { new ExpectedDuration(35.899167, 14.515171, 35.894126, 14.502983, 60, 60 * 6),
-				new ExpectedDuration(35.899167, 14.515171, 35.877645, 14.398956, 8 * 60, 25 * 60),
-				new ExpectedDuration(35.85817, 14.561348, 35.877645, 14.398956, 10 * 60, 30 * 60),
-				new ExpectedDuration(35.812802, 14.528732, 35.979673, 14.335785, 20 * 60, 50 * 60),
-
-		};
-
-		// The chosen locations should have small deviations in travel times
-		double tolDiffFromPbf = 0.01;
-
-		for (ExpectedDuration ed : expected) {
-			double secsShp = getSecondsTravel(ed.getPath(hopperShp,true));
-			double secsPbf = getSecondsTravel(ed.getPath(hopperPbf,true));
-			double frac = secsShp / secsPbf;
-
-			String message = "From (" + ed.from + ") to (" + ed.to + ") expected " + ed.minSecs + " <= travelsecs <= " + ed.maxSecs
-					+ ", found " + secsShp + " secs, pbf was " + secsPbf + " secs, frac diff=" + frac;
-			assertTrue(message, secsShp >= ed.minSecs);
-			assertTrue(message, secsShp <= ed.maxSecs);
-
-			// we also use a tolerance difference with the pbf
-			assertTrue(frac > 1 - tolDiffFromPbf);
-			assertTrue(frac < 1 + tolDiffFromPbf);
-
-			System.out.println(message);
-		}
-
-	}
-
-	private static double getSecondsTravel(PathWrapper pw) {
-		long millis = pw.getTime();
-		double secs = 0.001 * millis;
-		return secs;
-	}
-
+    private static Exception BEFORE_CLASS_EXCEPTION = null;
+
+    private static class FromToPair {
+        final GHPoint from;
+        final GHPoint to;
+
+        FromToPair(double fromLat, double fromLng, double toLat, double toLng) {
+            this(new GHPoint(fromLat, fromLng), new GHPoint(toLat, toLng));
+        }
+
+        FromToPair(GHPoint from, GHPoint to) {
+            this.from = from;
+            this.to = to;
+        }
+
+        PathWrapper getPath(GraphHopper hopper, boolean assertNoErrors) {
+            GHRequest request = new GHRequest(from, to).setVehicle("car");
+            GHResponse response = hopper.route(request);
+
+            if (assertNoErrors) {
+                assertFalse(response.hasErrors());
+            }
+
+            if (!response.hasErrors()) {
+                return response.getBest();
+            }
+            return null;
+        }
+
+    }
+
+    private static class ExpectedDuration extends FromToPair {
+        final double minSecs;
+        final double maxSecs;
+
+        private ExpectedDuration(double fromLat, double fromLng, double toLat, double toLng,
+                        double minSecs, double maxSecs) {
+            super(fromLat, fromLng, toLat, toLng);
+            this.minSecs = minSecs;
+            this.maxSecs = maxSecs;
+        }
+    }
+
+    private static GraphHopper initHopper(GraphHopper gh, String inputFile, String outDir) {
+        URL resourceURL = ShapeFileReaderTest.class.getResource(inputFile);
+        try {
+            inputFile = new File(resourceURL.toURI()).getAbsolutePath();
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+
+        // turn off geometry simplification so geometry should be the same
+        // between pbf and shapefile readers
+        gh.setWayPointMaxDistance(0);
+        return gh.setStoreOnFlush(false).setDataReaderFile(inputFile)
+                        .setGraphHopperLocation(new File(outDir).getAbsolutePath())
+                        .setEncodingManager(new EncodingManager(new CarFlagEncoder()))
+                        .setCHEnabled(false).importOrLoad();
+
+    }
+
+    /**
+     * Build the graphs once only for the various tests
+     */
+    @BeforeClass
+    public static void setupBeforeClass() {
+        try {
+            new File(tempOutputDirFromShp).mkdirs();
+            new File(tempOutputDirFromPbf).mkdirs();
+
+            hopperShp = initHopper(new GraphhopperSHP(), shapefile, tempOutputDirFromShp);
+
+            hopperPbf = initHopper(new GraphHopperOSM(), pbf, tempOutputDirFromPbf);
+
+        } catch (Exception e) {
+            // Junit silently fails if we get an exception in the setup before
+            // class,
+            // so we record it here and explicitly rethrow it
+            BEFORE_CLASS_EXCEPTION = e;
+        }
+
+    }
+
+    @AfterClass
+    public static void teardownAfterClass() {
+        try {
+            hopperShp.close();
+            hopperShp.clean();
+        } catch (Exception e) {
+        }
+
+        try {
+            hopperPbf.close();
+            hopperPbf.clean();
+        } catch (Exception e) {
+        }
+
+    }
+
+    @Before
+    public void beforeTest() throws Exception {
+        // Rethrow the exception from @BeforeClass here so it doesn't silently
+        // fail.
+        // (Junit silently fails on exceptions thrown in @BeforeClass but not
+        // for
+        // exceptions thrown in @Before)
+        if (BEFORE_CLASS_EXCEPTION != null) {
+            throw BEFORE_CLASS_EXCEPTION;
+        }
+    }
+
+    @Test
+    public void testOneWay() {
+        // We setup 2 points very close together on a one-way street.
+        // As its a one way street, the ordering of the start and end requires
+        // going around the block to serve them.
+        // As the scenario is simple, we should get the same results from both
+        // shapefile and pbf.
+        // We should also get route distance to be many times physical distance
+        FromToPair pair = new FromToPair(35.898324, 14.510729, 35.898328, 14.510681);
+        PathWrapper shp = pair.getPath(hopperShp, true);
+        PathWrapper pbf = pair.getPath(hopperPbf, true);
+        double metresShp = shp.getDistance();
+        double metresPbf = pbf.getDistance();
+
+        // should be many times the physical separation between the points (as
+        // we had to go round the block)
+        double straightLineDistMetres = distCalc.calcDist(pair.from.lat, pair.from.lon, pair.to.lat,
+                        pair.to.lon);
+        assertTrue(metresShp > straightLineDistMetres * 25);
+
+        // should be the same to within 1 cm
+        assertEquals(metresShp, metresPbf, 0.01);
+
+    }
+
+    @Test
+    public void testGeometrySingleEdgePath() {
+        // We choose a path along a single edge with a couple of minor bends,
+        // which we expect to give identical results...
+        FromToPair pair = new FromToPair(35.911694, 14.492303, 35.911494, 14.490489);
+        PointList shp = pair.getPath(hopperShp, true).getPoints();
+        PointList pbf = pair.getPath(hopperPbf, true).getPoints();
+
+        assertTrue("The chosen edge had a couple of bends!", shp.getSize() >= 2);
+        assertSameGeometry(shp, pbf);
+    }
+
+    private void assertSameGeometry(PointList shp, PointList pbf) {
+        assertEquals(shp.getSize(), pbf.getSize());
+
+        for (int i = 0; i < shp.getSize(); i++) {
+            assertEquals(shp.getLat(i), pbf.getLat(i), 0.0000001);
+            assertEquals(shp.getLon(i), pbf.getLon(i), 0.0000001);
+        }
+    }
+
+    @Test
+    public void testTravelTimesBetweenRandomLocations() {
+        int nTests = 200;
+        final Random random = new Random(123);
+        final GHPoint min = new GHPoint(35.882931, 14.403076);
+        final GHPoint max = new GHPoint(35.913523, 14.448566);
+
+        class RandPointGenerator {
+            double rand(double min, double max) {
+                return min + random.nextDouble() * (max - min);
+            }
+
+            GHPoint randPoint() {
+                return new GHPoint(rand(min.lat, max.lat), rand(min.lon, max.lon));
+            }
+
+        }
+        RandPointGenerator pointGenerator = new RandPointGenerator();
+
+        int nbFails = 0;
+        DoubleSummaryStatistics stats = new DoubleSummaryStatistics();
+        for (int i = 0; i < nTests; i++) {
+            FromToPair pair = new FromToPair(pointGenerator.randPoint(),
+                            pointGenerator.randPoint());
+
+            // paths from random points can fail to don't assert on failure
+            PathWrapper shpPath = pair.getPath(hopperShp, false);
+            PathWrapper pbfPath = pair.getPath(hopperPbf, false);
+
+            // paths between random points can fail to find a route (i.e. be off
+            // the road network)
+            if (shpPath == null || pbfPath == null) {
+                nbFails++;
+                continue;
+            }
+            double shpSecs = getSecondsTravel(shpPath);
+            double pbfSecs = getSecondsTravel(pbfPath);
+
+            double frac = shpSecs / pbfSecs;
+            double percentageDeviation = Math.abs(1.0 - frac) * 100;
+            stats.accept(percentageDeviation);
+        }
+
+        assertTrue("Number of fails should be small for the chosen box", nbFails < nTests / 3);
+
+        // Test mean fraction. There will be some deviation as not all tags are
+        // considered etc,
+        // but we expect it to be small for a large number of tests
+        double mean = stats.getAverage();
+        assertTrue("Should have a mean deviation in travel times of less than 1%",mean < 1.0);
+    }
+
+    @Test
+    public void testTravelTimesBetweenPredefinedLocations() throws URISyntaxException {
+
+        // try a couple of test points, with an expected time range that will
+        // only fail if something is really bad...
+        ExpectedDuration[] expected = new ExpectedDuration[] {
+                        new ExpectedDuration(35.899167, 14.515171, 35.894126, 14.502983, 60,
+                                        60 * 6),
+                        new ExpectedDuration(35.899167, 14.515171, 35.877645, 14.398956, 8 * 60,
+                                        25 * 60),
+                        new ExpectedDuration(35.85817, 14.561348, 35.877645, 14.398956, 10 * 60,
+                                        30 * 60),
+                        new ExpectedDuration(35.812802, 14.528732, 35.979673, 14.335785, 20 * 60,
+                                        50 * 60),
+
+        };
+
+        // The chosen locations should have small deviations in travel times
+        double tolDiffFromPbf = 0.01;
+
+        for (ExpectedDuration ed : expected) {
+            double secsShp = getSecondsTravel(ed.getPath(hopperShp, true));
+            double secsPbf = getSecondsTravel(ed.getPath(hopperPbf, true));
+            double frac = secsShp / secsPbf;
+
+            String message = "From (" + ed.from + ") to (" + ed.to + ") expected " + ed.minSecs
+                            + " <= travelsecs <= " + ed.maxSecs + ", found " + secsShp
+                            + " secs, pbf was " + secsPbf + " secs, frac diff=" + frac;
+            assertTrue(message, secsShp >= ed.minSecs);
+            assertTrue(message, secsShp <= ed.maxSecs);
+
+            // we also use a tolerance difference with the pbf
+            assertTrue(frac > 1 - tolDiffFromPbf);
+            assertTrue(frac < 1 + tolDiffFromPbf);
+
+        }
+
+    }
+
+    private static double getSecondsTravel(PathWrapper pw) {
+        long millis = pw.getTime();
+        double secs = 0.001 * millis;
+        return secs;
+    }
 
 }
