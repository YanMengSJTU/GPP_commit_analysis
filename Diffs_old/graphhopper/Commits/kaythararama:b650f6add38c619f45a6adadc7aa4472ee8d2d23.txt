diff --git a/.github/CONTRIBUTING.md b/.github/CONTRIBUTING.md
index 8bc8ffc674..b84f185f82 100644
--- a/.github/CONTRIBUTING.md
+++ b/.github/CONTRIBUTING.md
@@ -1,4 +1,5 @@
-Submit a new issue only if you are sure it is a missing feature or a bug. Otherwise, [discuss the topic](https://discuss.graphhopper.com/c/graphhopper) first. 
+Submit a new issue only if you are sure it is a missing feature or a bug. For questions or if you are unsure [discuss the topic in our forum](https://discuss.graphhopper.com/c/graphhopper). 
+
 For new translations or fixes to existing translations,
 please refer to [this documentation](https://github.com/graphhopper/graphhopper/blob/master/docs/core/translations.md).
 
diff --git a/.github/ISSUE_TEMPLATE.md b/.github/ISSUE_TEMPLATE.md
index a6c26c54f4..869b3a9fe9 100644
--- a/.github/ISSUE_TEMPLATE.md
+++ b/.github/ISSUE_TEMPLATE.md
@@ -1,6 +1,4 @@
-For general questions or discussion about GraphHopper, please use our [forum](https://discuss.graphhopper.com).
-
-Before creating an issue make sure to read our [contributing guide](https://github.com/graphhopper/graphhopper/blob/master/.github/CONTRIBUTING.md).
+For questions or discussion please always use our [forum](https://discuss.graphhopper.com) first and make sure you read our [contributing guide](https://github.com/graphhopper/graphhopper/blob/master/.github/CONTRIBUTING.md). Please be friendly and avoid the hassle to close your issue without an answer.
 
 The best way to get help about an GraphHopper issue is to create a valid and detailed issue content, preferable with a unit or integration test reproducing the issue. Please include the version of GraphHopper, the JVM and the operating system are you using and in case of a routing problem include a link to [GraphHopper Maps](https://graphhopper.com/maps/). Also tell us your expected routing result via additional markers and screenshots.
 
diff --git a/.gitignore b/.gitignore
index f8fcaf5a78..d656ebd9a6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -18,7 +18,7 @@ android/libs/graphhopper-*-android.jar
 .idea/
 *iml
 debug.sh
-/web/src/main/webapp/js/config/options_prod.js
+/web/src/main/resources/assets/js/main.js
 /web/src/main/resources/assets/js/config/options_prod.js
 /web/dependency-reduced-pom.xml
 *.pbf
diff --git a/.travis.yml b/.travis.yml
index 4e8bf60288..4e3dffb9cd 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,5 +1,5 @@
 language: java
-sudo: false
+sudo: true
 dist: trusty
 
 env:
@@ -8,14 +8,15 @@ env:
     # TODO move this into the travis settings
     - secure: "j6a61/qnfFcSjx5XxmxO2hqBOwtVx5HWrD1+4Atl7WG/pRKz9+jSga1Y7oDAFb2SIl8S65kDmPQB/vC8aHxUDj/Wizjxnxn1FhPqoe9yO6Ztft+984FKFyvj7s6tsBJKcehGec+chTOwZQpH4oI4rU6IlepDHnGLHiOd0Iviryg="
     - secure: "GiFr+v2lTQk/sTQB7CYjju1/mupS8LSJupmizLqY454utiZkabDMBOZQnF9ukpy7WhveB9hKQyEKf9iP2w7HSYEjgvogT26vZ5f2MeLnR4SWvqEtf/WBvvh+W+k/rb2f6YgitkB4Jlxn2izemBEDuKplGJphzGW41lf8XZ2IxVI="
+    - NODE_VERSION="10.16.0"
 
 matrix:
   include:
     - jdk: openjdk8
-    - env: JDK='OpenJDK 10'
-      install: . ./install-jdk.sh -F 10 -C
-    - env: JDK='OpenJDK 11'
-      install: . ./install-jdk.sh -F 11 -C
+    - env: JDK='OpenJDK 12'
+      install: . ./install-jdk.sh -F 12 -C
+    - env: JDK='OpenJDK 13' SKIP_EXT_TESTS=true
+      install: . ./install-jdk.sh -F 13 -C
     
 # avoid default dependency command for maven, 'true' means 'return true' and continue
 install: true
@@ -27,7 +28,8 @@ before_install:
   - if [ ! -z "$GPG_SECRET_KEYS" ]; then echo $GPG_SECRET_KEYS | base64 --decode | $GPG_EXECUTABLE --import; fi
   - if [ ! -z "$GPG_OWNERTRUST" ]; then echo $GPG_OWNERTRUST | base64 --decode | $GPG_EXECUTABLE --import-ownertrust; fi
   - 'wget https://raw.githubusercontent.com/sormuras/bach/master/install-jdk.sh'
-  
+  - nvm install $NODE_VERSION
+
 # avoid increase of memory via travis https://github.com/travis-ci/travis-ci/issues/8408
 before_script:
   - _JAVA_OPTIONS=
@@ -37,17 +39,23 @@ before_script:
   - _JAVA_OPTIONS=
   - "mvn --version"
   - "if [ -z \"$API_KEY\" ]; then API_KEY=78da6e9a-273e-43d1-bdda-8f24e007a1fa; fi" # change in GraphHopperWebIT too
+  - cd web && npm install && BROWSERIFYSWAP_ENV='development' npm run bundleProduction && cd ..
+
 script:
-  - "mvn -Dkey=$API_KEY clean test verify checkstyle:check findbugs:check forbiddenapis:check -B"
+  - "mvn -Dkey=$API_KEY clean test verify -B"
 
 after_success:
-  # deploy snapshot artifacts to sonatype and if tagged deploy then release to maven central
-  - if [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_BRANCH" == "master" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ]; then
-        mvn deploy --settings core/files/settings.xml -DskipTests=true -B;
-    elif [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_TAG" != "" ]; then
+  # often spotbugs etc take long to be compatible with a future JDK version so skip them
+  - if [ "$SKIP_EXT_TESTS" != "true" ]; then
+        mvn checkstyle:check spotbugs:check forbiddenapis:check;
+    fi
+  # if tagged deploy then release to maven central or deploy snapshot artifacts to sonatype 
+  - if [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_TAG" != "" ]; then
         echo "release to maven central";
         mvn versions:set -DnewVersion=$TRAVIS_TAG -DgenerateBackupPoms=false;
         mvn deploy -P release --settings core/files/settings.xml -DskipTests=true -B;
+    elif [ "$TRAVIS_JDK_VERSION" == "openjdk8" ] && [ "$TRAVIS_BRANCH" == "master" ] && [ "$TRAVIS_PULL_REQUEST" == "false" ]; then
+        mvn deploy --settings core/files/settings.xml -DskipTests=true -B;
     else
         echo "Not deploying artifacts for $TRAVIS_BRANCH";
     fi
diff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md
index 3f26531b71..0a1e6b68e0 100644
--- a/CONTRIBUTORS.md
+++ b/CONTRIBUTORS.md
@@ -7,11 +7,12 @@ state this as a comment via a separate, signed commit.
 
 Here is an overview:
 
- * ammagamma, improvements like #700, #703
  * AnahitaS, docs for Android, Android, Tomcat
  * andreaswolf, flag encoder versioning and more
+ * andreylh, polygon for blocked area #1306
  * agouge, discussion and API refactoring
  * b3nn0, Android improvements
+ * baumboi, path detail and landmark improvements
  * boldtrn, one of the core developers with motorcycle knowledge :)
  * cgarreau, increase of routing success rate via subnetwork cleanup
  * ChristianSeitzer, motorcycle improvements
@@ -23,6 +24,7 @@ Here is an overview:
  * dos65, bug fixes in routing algo
  * drnextgis, ru translation and JS fixes
  * duongnt, fixes in storage
+ * easbar, several improvements on core algorithms
  * edy, improvements regarding docker #849
  * elibar, fix for alternative route calculation
  * fbonzon, several UI improvements like #615
diff --git a/Dockerfile b/Dockerfile
index fb274b8fcc..a7dfea1c9f 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,19 +1,26 @@
 FROM openjdk:8-jdk
 
-ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M -Ddw.server.applicationConnectors[0].bindHost=0.0.0.0 -Ddw.server.applicationConnectors[0].port=11111"
+ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -Ddw.server.applicationConnectors[0].bindHost=0.0.0.0 -Ddw.server.applicationConnectors[0].port=8989"
 
-RUN mkdir -p /data && \
-    mkdir -p /graphhopper
+RUN mkdir -p /data && mkdir -p /graphhopper
+
+# install node - only required for JS UI
+RUN apt-get install -y wget \
+       && curl -sL https://deb.nodesource.com/setup_11.x | bash - \
+       && apt-get install -y nodejs
 
 COPY . /graphhopper/
 
 WORKDIR /graphhopper
 
+# create main.js - only required for JS UI
+RUN cd web && npm install && npm run bundleProduction && cd ..
+
 RUN ./graphhopper.sh build
 
 VOLUME [ "/data" ]
 
-EXPOSE 11111
+EXPOSE 8989
 
 ENTRYPOINT [ "./graphhopper.sh", "web" ]
 
diff --git a/NOTICE.md b/NOTICE.md
index b1033dbaf0..d834568aab 100644
--- a/NOTICE.md
+++ b/NOTICE.md
@@ -15,7 +15,7 @@ The core module includes the following software:
  * Apache Commons Collections - we copied parts of the BinaryHeap (Apache License)
  * java-string-similarity - we copied the implementation of JaroWinkler (MIT license)
  * com.fasterxml.jackson.core:jackson-annotations (Apache License)
- * com.vividsolutions:jts (LGPL), see #1039
+ * org.locationtech:jts (EDL), see #1039
 
 reader-osm:
 
@@ -25,7 +25,7 @@ reader-osm:
 
 reader-gtfs:
  
- * com.conveyal:gtfs-lib (BSD 2-clause license)
+ * some files from com.conveyal:gtfs-lib (BSD 2-clause license)
  * com.google.transit:gtfs-realtime-bindings (Apache license)
 
 reader-shp:
diff --git a/README.md b/README.md
index b46b315cfb..a7e076ad4f 100644
--- a/README.md
+++ b/README.md
@@ -11,13 +11,30 @@ We have a prospering community and welcome everyone. Let us know your problems,
 
 ## Get Started
 
-To get started, read through our documentation and install the GraphHopper Web Service locally:
+To get started, read through our documentation and install the GraphHopper Web Service locally.
 
- * unstable: [docs](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), [zip](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.11-SNAPSHOT/), [Android APK](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-android/0.11-SNAPSHOT/)
- * 0.10.0 latest stable: [announcement](https://www.graphhopper.com/blog/2018/03/08/graphhopper-routing-engine-0-10-released/), [docs](https://github.com/graphhopper/graphhopper/blob/0.10/docs/index.md), [zip](https://graphhopper.com/public/releases/graphhopper-web-0.10.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.10.0.apk)
- * 0.9.0: [announcement](https://www.graphhopper.com/blog/2017/05/31/graphhopper-routing-engine-0-9-released/), [docs](https://github.com/graphhopper/graphhopper/blob/0.9/docs/index.md), [zip](https://graphhopper.com/public/releases/graphhopper-web-0.9.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.9.0.apk)
- * 0.8.2: [announcement](https://www.graphhopper.com/blog/2016/10/18/graphhopper-routing-engine-0-8-released/), [docs](https://github.com/graphhopper/graphhopper/blob/0.8/docs/index.md), [zip](https://graphhopper.com/public/releases/graphhopper-web-0.8.2-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.8.2.apk)
- * 0.7.0: [announcement](https://www.graphhopper.com/blog/2016/06/15/graphhopper-routing-engine-0-7-released/), [docs](https://github.com/graphhopper/graphhopper/blob/0.7/docs/index.md), [zip](https://graphhopper.com/public/releases/graphhopper-web-0.7.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.7.0.apk)
+ * unstable: [documentation](https://github.com/graphhopper/graphhopper/blob/master/docs/index.md), [web service jar](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-web/0.13-SNAPSHOT/), [Android APK](https://oss.sonatype.org/content/groups/public/com/graphhopper/graphhopper-android/0.13-SNAPSHOT/)
+ * 0.12.0: [announcement](https://www.graphhopper.com/blog/2019/03/26/graphhopper-routing-engine-0-12-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.12/docs/index.md), [web service jar](https://graphhopper.com/public/releases/graphhopper-web-0.12.0.jar), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.12.0.apk)
+ * 0.11.0: [announcement](https://www.graphhopper.com/blog/2018/09/17/graphhopper-routing-engine-0-11-release-open-sourcing-the-isochrone-module/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.11/docs/index.md), [web service jar](https://graphhopper.com/public/releases/graphhopper-web-0.11.0.jar), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.11.0.apk)
+ * 0.10.0: [announcement](https://www.graphhopper.com/blog/2018/03/08/graphhopper-routing-engine-0-10-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.10/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.10.3-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.10.3.apk)
+ * 0.9.0: [announcement](https://www.graphhopper.com/blog/2017/05/31/graphhopper-routing-engine-0-9-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.9/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.9.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.9.0.apk)
+ * 0.8.2: [announcement](https://www.graphhopper.com/blog/2016/10/18/graphhopper-routing-engine-0-8-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.8/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.8.2-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.8.2.apk)
+ * 0.7.0: [announcement](https://www.graphhopper.com/blog/2016/06/15/graphhopper-routing-engine-0-7-released/), [documentation](https://github.com/graphhopper/graphhopper/blob/0.7/docs/index.md), [web service zip](https://graphhopper.com/public/releases/graphhopper-web-0.7.0-bin.zip), [Android APK](https://graphhopper.com/public/releases/graphhopper-android-0.7.0.apk)
+
+### Docker
+
+Run a dockerized GraphHopper from sources:
+
+```bash
+docker build -t graphhopper:master .
+docker run -d --name graphhopper -v <path_data_directory>/data:/data -p 8989:8989 graphhopper:master
+```
+
+See also the builds at [Docker Hub](https://hub.docker.com/r/graphhopper/graphhopper)
+
+### DEB or RPM package
+
+[There is an experimental step by step guide](https://github.com/graphhopper/graphhopper/issues/561#issuecomment-473567727) that creates a debian or rpm package from the cloned and compiled repository. Before we can recommend this we need some more testers and feedback :)
 
 ## Questions
 
@@ -39,13 +56,20 @@ a Routing API via GraphHopper, a Route Optimization API via [jsprit](http://jspr
 and an address search via [Photon](https://github.com/komoot/photon). Additionally, map tiles from various providers are used 
 where the default is [Omniscale](http://omniscale.com/). All of these are available for free, via encrypted connections and from German servers for a nice and private route planning experience!
 
+## For Public Transit
+
+[Get started](./reader-gtfs/README.md#quick-start)
+
+[![Realtime Demo](https://www.graphhopper.com/wp-content/uploads/2018/05/Screen-Shot-2018-05-16-at-21.23.25-600x538.png)](./reader-gtfs/README.md#quick-start)
 
 ## For Mobile Apps
 
 There are subprojects to make GraphHopper working offline
-on [Android](https://github.com/graphhopper/graphhopper/tree/master/android)
+on [Android](./android/README.md)
 and [iOS](http://github.com/graphhopper/graphhopper-ios)
 
+[![simple routing](https://www.graphhopper.com/wp-content/uploads/2016/10/android-demo-screenshot-2.png)](./android/README.md)
+
 ## For Analysis
 
 There is the isochrone subproject to calculate and visualize the reachable area for a certain travel mode
@@ -54,10 +78,13 @@ There is the isochrone subproject to calculate and visualize the reachable area
 
 [![Isochrone API image](./docs/isochrone/images/isochrone.png)](./docs/web/api-doc.md#isochrone)
 
-**[Isochrone Experiments](//www.graphhopper.com/blog/2018/07/04/high-precision-reachability/)**
+**[Shortest Path Tree API](//www.graphhopper.com/blog/2018/07/04/high-precision-reachability/)**
 
 [![high precision reachability image](https://www.graphhopper.com/wp-content/uploads/2018/06/berlin-reachability-768x401.png)](https://www.graphhopper.com/blog/2018/07/04/high-precision-reachability/)
 
+To support these high precision reachability approaches there is a special /spt
+endpoint (shortest path tree). [See #1577](https://github.com/graphhopper/graphhopper/pull/1577)
+
 # Technical Overview
 
 GraphHopper supports several routing algorithms, such as 
@@ -90,7 +117,7 @@ but of course this is not necessary.
 OpenStreetMap is directly supported from GraphHopper. Without the amazing data from
 OpenStreetMap, GraphHopper wouldn't be possible at all.
 Other map data will need a custom import procedure, see e.g. <a href="https://github.com/graphhopper/graphhopper/issues/277">Ordnance Survey</a>,
-<a href="https://github.com/graphhopper/graphhopper/tree/master/reader-shp">Shapefile like ESRI</a> or <a href="https://github.com/knowname/morituri">Navteq</a>.
+<a href="https://github.com/graphhopper/graphhopper-reader-shp">Shapefile like ESRI</a> or <a href="https://github.com/knowname/morituri">Navteq</a>.
 
 ## Written in Java
 
@@ -105,7 +132,7 @@ Embed GraphHopper with OpenStreetMap support into your Java application via the
 <dependency>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-osm</artifactId>
-    <version>[LATEST-VERSION]/version>
+    <version>[LATEST-VERSION]</version>
 </dependency>
 ```
 
@@ -145,51 +172,34 @@ visualize the routes.
 ### Desktop
 
 GraphHopper also runs on the Desktop in a Java application without internet access.
-E.g. you could use the rough user interface called MiniGraphUI provided in the tools module, see some
+For debugging purposes GraphHopper can produce vector tiles, i.e. a visualization of the road network in the browser (see #1572). Also a more low level Swing-based UI is provided via MiniGraphUI in the tools module, see some
 visualizations done with it [here](https://graphhopper.com/blog/2016/01/19/alternative-roads-to-rome/).
-A fast and production ready map visualization for the Desktop can be easily implemented via mapsforge.
-
-### Docker
-
-Install GraphHopper via [Docker](https://github.com/graphhopper/graphhopper/pull/849).
-You only need to change the docker-compose.yml entrypoint in core/files/ to run whatever map you like.
-Then just type:
-```bash
-cd core/files/
-docker-compose up -d
-```
-
-If you don't want to use docker-compose you can do the following:
-```bash
-docker build -t graphhopper:master .
-docker run -d --name graphhopper -v <path_data_directory>/data:/data -p 11111:11111 graphhopper:master
-```
-
+A fast and production ready map visualization for the Desktop can be implemented via [mapsforge](https://github.com/mapsforge/mapsforge) or [mapsforge vtm](https://github.com/mapsforge/vtm).
 
 # Features
 
 Here is a list of the more detailed features including a link to the documentation:
 
- * [Simple start for users](./docs/web/quickstart.md) - just Java necessary! [Simple start for developers](./docs/core/quickstart-from-source.md) due to Maven.
- * Works out of the box with OpenStreetMap (osm/xml and pbf) but can be adapted to use your own data
- * OpenStreetMap integration: Takes care of the road type, the surface, barriers, access restrictions, ferries, [conditional access restrictions](https://github.com/graphhopper/graphhopper/pull/621), ...
+ * [Quick installation and start for users](./docs/web/quickstart.md) - just Java necessary! [Simple start for developers](./docs/core/quickstart-from-source.md) due to Maven.
+ * Works out of the box with OpenStreetMap (osm/xml and pbf) and can be adapted to custom data
+ * OpenStreetMap integration: Takes care of the road type, speed limit, the surface, barriers, access restrictions, ferries, [conditional access restrictions](https://github.com/graphhopper/graphhopper/pull/621), ...
  * GraphHopper is fast. And with the so called "Contraction Hierarchies" it can be even faster (enabled by default).
  * Memory efficient data structures, algorithms and [the low and high level API](./docs/core/low-level-api.md) is tuned towards ease of use and efficiency
  * Provides a simple [web API](./docs/web/api-doc.md) including JavaScript and Java clients
  * Multiple weightings (fastest/shortest/...) and pre-built routing profiles: car, bike, racingbike, mountain bike, foot, motorcycle, ...
- * Support for public transit routing and [GTFS support](./reader-gtfs/README.md).
+ * Supports public transit routing and [GTFS](./reader-gtfs/README.md).
  * Offers turn instructions in more than 35 languages, contribute or improve [here](./docs/core/translations.md)
  * Displays and takes into account [elevation data](./docs/core/elevation.md) (per default disabled)
  * Can apply [real time changes to edge weights](https://graphhopper.com/blog/2015/04/08/visualize-and-handle-traffic-information-with-graphhopper-in-real-time-for-cologne-germany-koln/) (flexible and hybrid mode only)
- * Customize vehicle profiles per request (flexible and hybrid mode only)
+ * Customization of vehicle profiles per request are possible (flexible and hybrid mode only)
  * Possibility to specify a [heading parameter](./docs/core/routing.md) of the vehicle for start, end and via points for navigation applications via `pass_through` or `heading` parameters (flexible and hybrid mode only)
  * [Alternative routes](https://discuss.graphhopper.com/t/alternative-routes/424) (flexible and hybrid mode only)
- * [Turn costs and restrictions](https://github.com/graphhopper/graphhopper/pull/55#issuecomment-31089096) (flexible and hybrid mode only)
+ * [Turn costs and restrictions](./docs/core/turn-restrictions.md)
  * Country specific routing via SpatialRules
- * Multiple profiles and weightings
- * Several pre-built routing profiles: car, bike, racingbike, mountain bike, foot, motorcycle, ...
  * The core uses only a few dependencies (hppc, jts and slf4j)
  * Scales from small indoor-sized to world-wide-sized graphs
- * Find nearest point on street e.g. to get elevation or 'snapp to road'
- * Do [map matching](https://github.com/graphhopper/map-matching) with GraphHopper
- * Calculate [isochrones](./docs/web/api-doc.md#isochrone) with GraphHopper
+ * Finds nearest point on street e.g. to get elevation or 'snap to road' or being used as spatial index (see [#1485](https://github.com/graphhopper/graphhopper/pull/1485))
+ * Does [map matching](https://github.com/graphhopper/map-matching) with GraphHopper
+ * Calculates [isochrones](./docs/web/api-doc.md#isochrone) with GraphHopper
+ * Shows details along a route ("path details") [#1142](https://github.com/graphhopper/graphhopper/pull/1142)
+ * Shows the whole road network in the browser for debugging purposes ("vector tile support") [#1572](https://github.com/graphhopper/graphhopper/pull/1572)
diff --git a/android/app/build.gradle b/android/app/build.gradle
index 5a04ef81f7..84be98bc17 100644
--- a/android/app/build.gradle
+++ b/android/app/build.gradle
@@ -1,22 +1,23 @@
 apply plugin: 'com.android.application'
 
 android {
-    compileSdkVersion 27
-    buildToolsVersion "27.0.3"
+    compileSdkVersion 28
+    buildToolsVersion "28.0.3"
 
     defaultConfig {
         applicationId "com.graphhopper.android"
         minSdkVersion 10
+        //noinspection ExpiredTargetSdkVersion
         targetSdkVersion 22
     }
 
-    buildTypes {
+    /*buildTypes {
         all {
             minifyEnabled true
             useProguard false
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
-    }
+    }*/
 
     lintOptions {
         /* CGIARProvider refers to java.awt
@@ -35,24 +36,21 @@ configurations.all {
  **/
 
 dependencies {
-    implementation(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.11-SNAPSHOT') {
+    implementation(group: 'com.graphhopper', name: 'graphhopper-core', version: '0.13-SNAPSHOT') {
        exclude group: 'com.google.protobuf', module: 'protobuf-java'
        exclude group: 'org.openstreetmap.osmosis', module: 'osmosis-osm-binary'
        exclude group: 'org.apache.xmlgraphics', module: 'xmlgraphics-commons'
     }
 
-    implementation 'org.mapsforge:vtm:0.9.2'
-    implementation 'org.mapsforge:vtm-android:0.9.2'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-armeabi'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-armeabi-v7a'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-arm64-v8a'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-x86'
-    implementation 'org.mapsforge:vtm-android:0.9.2:natives-x86_64'
-    implementation('org.mapsforge:vtm-jts:0.9.2') {
-      exclude group: 'com.vividsolutions', module: 'jts'
-    }
-    implementation 'org.mapsforge:vtm-themes:0.9.2'
-    implementation 'com.caverock:androidsvg:1.2.2-beta-1'
+    implementation 'org.mapsforge:vtm:0.11.1'
+    implementation 'org.mapsforge:vtm-android:0.11.1'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-armeabi-v7a'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-arm64-v8a'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-x86'
+    implementation 'org.mapsforge:vtm-android:0.11.1:natives-x86_64'
+    implementation 'org.mapsforge:vtm-jts:0.11.1'
+    implementation 'org.mapsforge:vtm-themes:0.11.1'
+    implementation 'com.caverock:androidsvg:1.3'
 
     implementation 'org.slf4j:slf4j-api:1.7.25'
     implementation 'org.slf4j:slf4j-android:1.7.25'
diff --git a/android/app/pom.xml b/android/app/pom.xml
index af79e68c23..de30b700e4 100644
--- a/android/app/pom.xml
+++ b/android/app/pom.xml
@@ -4,7 +4,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-android</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <name>GraphHopper Android</name>
     <packaging>apk</packaging>    
     <organization>
@@ -16,10 +16,10 @@
         <relativePath>../..</relativePath>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
     <properties>
-        <vtm.version>0.9.2</vtm.version>
+        <vtm.version>0.11.1</vtm.version>
         <!-- do not put the properties here as it differs from dev to dev <android.sdk.path>/home/peterk/Programme/android-sdk-linux_x86</android.sdk.path>
         instead use your IDE to set it up or specify android sdk via command line
         using -Dandroid.sdk.path=... or by setting environment variable ANDROID_HOME
@@ -55,12 +55,6 @@
             <version>${vtm.version}</version>
         </dependency>
         
-        <dependency>
-            <groupId>org.mapsforge</groupId>            
-            <artifactId>vtm-android</artifactId>
-            <version>${vtm.version}</version>
-            <classifier>natives-armeabi</classifier>
-        </dependency>  
          <dependency>
             <groupId>org.mapsforge</groupId>            
             <artifactId>vtm-android</artifactId>
@@ -90,12 +84,6 @@
             <groupId>org.mapsforge</groupId>            
             <artifactId>vtm-jts</artifactId>
             <version>${vtm.version}</version>
-            <exclusions>
-              <exclusion>
-                <groupId>com.vividsolutions</groupId>
-                <artifactId>jts</artifactId>
-              </exclusion>
-            </exclusions>
         </dependency>
         <dependency>
             <groupId>org.mapsforge</groupId>            
@@ -105,7 +93,7 @@
         <dependency>
             <groupId>com.caverock</groupId>            
             <artifactId>androidsvg</artifactId>
-            <version>1.2.2-beta-1</version>
+            <version>1.3</version>
         </dependency> 
         
         <dependency>
@@ -150,7 +138,7 @@
                 <!-- See http://simpligility.github.io/android-maven-plugin/ -->
                 <groupId>com.simpligility.maven.plugins</groupId>
                 <artifactId>android-maven-plugin</artifactId>
-                <version>4.4.3</version>
+                <version>4.5.0</version>
                 <extensions>true</extensions>
                 <configuration>
                     <sdk>
diff --git a/android/app/src/main/AndroidManifest.xml b/android/app/src/main/AndroidManifest.xml
index c407c842d2..32f48265cc 100644
--- a/android/app/src/main/AndroidManifest.xml
+++ b/android/app/src/main/AndroidManifest.xml
@@ -10,10 +10,6 @@
     <uses-permission android:name="android.permission.INTERNET" />
     <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
 
-    <uses-sdk
-        android:minSdkVersion="10"
-        android:targetSdkVersion="22" />
-
     <application
         android:allowBackup="true"
         android:icon="@drawable/logo"
diff --git a/android/app/src/main/java/com/graphhopper/android/MainActivity.java b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
index 8dc3e82782..0c50791cba 100644
--- a/android/app/src/main/java/com/graphhopper/android/MainActivity.java
+++ b/android/app/src/main/java/com/graphhopper/android/MainActivity.java
@@ -184,7 +184,7 @@ boolean isReady() {
             logUser("Preparation still in progress");
             return false;
         }
-        logUser("Prepare finished but hopper not ready. This happens when there was an error while loading the files");
+        logUser("Prepare finished but GraphHopper not ready. This happens when there was an error while loading the files");
         return false;
     }
 
diff --git a/android/build.gradle b/android/build.gradle
index 7105f5a2dd..6b199027f8 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -5,7 +5,7 @@ buildscript {
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.0.1'
+        classpath 'com.android.tools.build:gradle:3.4.0'
     }
 }
 
diff --git a/android/gradle/wrapper/gradle-wrapper.jar b/android/gradle/wrapper/gradle-wrapper.jar
index 13372aef5e..f6b961fd5a 100644
Binary files a/android/gradle/wrapper/gradle-wrapper.jar and b/android/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/android/gradle/wrapper/gradle-wrapper.properties b/android/gradle/wrapper/gradle-wrapper.properties
index cd201a3dc2..c4486d47dc 100644
--- a/android/gradle/wrapper/gradle-wrapper.properties
+++ b/android/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,5 @@
-#Thu Oct 26 11:57:58 EEST 2017
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.1.1-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip
diff --git a/android/gradlew b/android/gradlew
index 9d82f78915..cccdd3d517 100755
--- a/android/gradlew
+++ b/android/gradlew
@@ -1,4 +1,4 @@
-#!/usr/bin/env bash
+#!/usr/bin/env sh
 
 ##############################################################################
 ##
@@ -6,20 +6,38 @@
 ##
 ##############################################################################
 
-# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-DEFAULT_JVM_OPTS=""
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >/dev/null
+APP_HOME="`pwd -P`"
+cd "$SAVED" >/dev/null
 
 APP_NAME="Gradle"
 APP_BASE_NAME=`basename "$0"`
 
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
 # Use the maximum available, or set MAX_FD != -1 to use that value.
 MAX_FD="maximum"
 
-warn ( ) {
+warn () {
     echo "$*"
 }
 
-die ( ) {
+die () {
     echo
     echo "$*"
     echo
@@ -30,6 +48,7 @@ die ( ) {
 cygwin=false
 msys=false
 darwin=false
+nonstop=false
 case "`uname`" in
   CYGWIN* )
     cygwin=true
@@ -40,26 +59,11 @@ case "`uname`" in
   MINGW* )
     msys=true
     ;;
+  NONSTOP* )
+    nonstop=true
+    ;;
 esac
 
-# Attempt to set APP_HOME
-# Resolve links: $0 may be a link
-PRG="$0"
-# Need this for relative symlinks.
-while [ -h "$PRG" ] ; do
-    ls=`ls -ld "$PRG"`
-    link=`expr "$ls" : '.*-> \(.*\)$'`
-    if expr "$link" : '/.*' > /dev/null; then
-        PRG="$link"
-    else
-        PRG=`dirname "$PRG"`"/$link"
-    fi
-done
-SAVED="`pwd`"
-cd "`dirname \"$PRG\"`/" >/dev/null
-APP_HOME="`pwd -P`"
-cd "$SAVED" >/dev/null
-
 CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
 
 # Determine the Java command to use to start the JVM.
@@ -85,7 +89,7 @@ location of your Java installation."
 fi
 
 # Increase the maximum file descriptors if we can.
-if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
     MAX_FD_LIMIT=`ulimit -H -n`
     if [ $? -eq 0 ] ; then
         if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
@@ -150,11 +154,19 @@ if $cygwin ; then
     esac
 fi
 
-# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
-function splitJvmOpts() {
-    JVM_OPTS=("$@")
+# Escape application args
+save () {
+    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
+    echo " "
 }
-eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
-JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+APP_ARGS=$(save "$@")
+
+# Collect all arguments for the java command, following the shell quoting and substitution rules
+eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"
+
+# by default we should be in the correct project dir, but when run from Finder on Mac, the cwd is wrong
+if [ "$(uname)" = "Darwin" ] && [ "$HOME" = "$PWD" ]; then
+  cd "$(dirname "$0")"
+fi
 
-exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
+exec "$JAVACMD" "$@"
diff --git a/android/gradlew.bat b/android/gradlew.bat
index 8a0b282aa6..f9553162f1 100644
--- a/android/gradlew.bat
+++ b/android/gradlew.bat
@@ -8,14 +8,14 @@
 @rem Set local scope for the variables with windows NT shell
 if "%OS%"=="Windows_NT" setlocal
 
-@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
-set DEFAULT_JVM_OPTS=
-
 set DIRNAME=%~dp0
 if "%DIRNAME%" == "" set DIRNAME=.
 set APP_BASE_NAME=%~n0
 set APP_HOME=%DIRNAME%
 
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
 @rem Find java.exe
 if defined JAVA_HOME goto findJavaFromJavaHome
 
@@ -46,10 +46,9 @@ echo location of your Java installation.
 goto fail
 
 :init
-@rem Get command-line arguments, handling Windowz variants
+@rem Get command-line arguments, handling Windows variants
 
 if not "%OS%" == "Windows_NT" goto win9xME_args
-if "%@eval[2+2]" == "4" goto 4NT_args
 
 :win9xME_args
 @rem Slurp the command line arguments.
@@ -60,11 +59,6 @@ set _SKIP=2
 if "x%~1" == "x" goto execute
 
 set CMD_LINE_ARGS=%*
-goto execute
-
-:4NT_args
-@rem Get arguments from the 4NT Shell from JP Software
-set CMD_LINE_ARGS=%$
 
 :execute
 @rem Setup the command line
diff --git a/api/pom.xml b/api/pom.xml
index 47bd25a5b2..f1c2cdde48 100644
--- a/api/pom.xml
+++ b/api/pom.xml
@@ -6,21 +6,21 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-api</artifactId>
     <packaging>jar</packaging>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <name>GraphHopper API</name>
     <description>Use the GraphHopper routing engine as a web-service</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
 
     <dependencies>
         <dependency>
-            <groupId>com.vividsolutions</groupId>
+            <groupId>org.locationtech.jts</groupId>
             <artifactId>jts-core</artifactId>
-            <version>1.14.0</version>
+            <version>1.15.1</version>
         </dependency>
         <dependency>
             <groupId>junit</groupId>
@@ -35,7 +35,6 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
                 <configuration>
                     <source>1.8</source>
                     <target>1.8</target>
diff --git a/api/src/main/java/com/graphhopper/GHRequest.java b/api/src/main/java/com/graphhopper/GHRequest.java
index 38b40c2529..cff736a291 100644
--- a/api/src/main/java/com/graphhopper/GHRequest.java
+++ b/api/src/main/java/com/graphhopper/GHRequest.java
@@ -39,6 +39,7 @@
     // Headings are north based azimuth (clockwise) in (0, 360) or NaN for equal preference
     private final List<Double> favoredHeadings;
     private List<String> pointHints = new ArrayList<>();
+    private List<String> snapPreventions = new ArrayList<>();
     private List<String> pathDetails = new ArrayList<>();
     private String algo = "";
     private boolean possibleToAdd = false;
@@ -254,6 +255,19 @@ public boolean hasPointHints() {
         return pointHints.size() == points.size() && !points.isEmpty();
     }
 
+    public GHRequest setSnapPreventions(List<String> snapPreventions) {
+        this.snapPreventions = snapPreventions;
+        return this;
+    }
+
+    public boolean hasSnapPreventions() {
+        return !snapPreventions.isEmpty();
+    }
+
+    public List<String> getSnapPreventions() {
+        return snapPreventions;
+    }
+
     public GHRequest setPathDetails(List<String> pathDetails) {
         this.pathDetails = pathDetails;
         return this;
diff --git a/api/src/main/java/com/graphhopper/PathWrapper.java b/api/src/main/java/com/graphhopper/PathWrapper.java
index d74dbb3e7a..4b148a647d 100644
--- a/api/src/main/java/com/graphhopper/PathWrapper.java
+++ b/api/src/main/java/com/graphhopper/PathWrapper.java
@@ -44,8 +44,9 @@
     private PointList waypointList = PointList.EMPTY;
     private PointList pointList = PointList.EMPTY;
     private int numChanges;
-    private final List<Trip.Leg> legs = new ArrayList<>();
-    private Map<String, List<PathDetail>> pathDetails = new HashMap<>();
+    private final List<Trip.Leg> legs = new ArrayList<>(5);
+    private final List<Integer> pointsOrder = new ArrayList<>(5);
+    private final Map<String, List<PathDetail>> pathDetails = new HashMap<>();
     private BigDecimal fare;
     private boolean impossible = false;
 
@@ -79,6 +80,16 @@ public String getDebugInfo() {
         return debugInfo;
     }
 
+    public PathWrapper setPointsOrder(List<Integer> list) {
+        pointsOrder.clear();
+        pointsOrder.addAll(list);
+        return this;
+    }
+
+    public List<Integer> getPointsOrder() {
+        return pointsOrder;
+    }
+
     /**
      * This method returns all points on the path. Keep in mind that calculating the distance from
      * these points might yield different results compared to getDistance as points could have been
@@ -262,7 +273,10 @@ public static void merge(List<PathDetail> pathDetails, List<PathDetail> otherDet
         // Make sure that the PathDetail list is merged correctly at via points
         if (!pathDetails.isEmpty() && !otherDetails.isEmpty()) {
             PathDetail lastDetail = pathDetails.get(pathDetails.size() - 1);
-            if (lastDetail.getValue().equals(otherDetails.get(0).getValue())) {
+            boolean extend = lastDetail.getValue() != null
+                    ? lastDetail.getValue().equals(otherDetails.get(0).getValue())
+                    : otherDetails.get(0).getValue() != null;
+            if (extend) {
                 lastDetail.setLast(otherDetails.get(0).getLast());
                 otherDetails.remove(0);
             }
diff --git a/api/src/main/java/com/graphhopper/Trip.java b/api/src/main/java/com/graphhopper/Trip.java
index 43805069b5..fdd6ef4d75 100644
--- a/api/src/main/java/com/graphhopper/Trip.java
+++ b/api/src/main/java/com/graphhopper/Trip.java
@@ -1,8 +1,8 @@
 package com.graphhopper;
 
 import com.graphhopper.util.InstructionList;
-import com.vividsolutions.jts.geom.Geometry;
-import com.vividsolutions.jts.geom.Point;
+import org.locationtech.jts.geom.Geometry;
+import org.locationtech.jts.geom.Point;
 
 import java.util.Date;
 import java.util.List;
diff --git a/api/src/main/java/com/graphhopper/json/geo/JsonFeature.java b/api/src/main/java/com/graphhopper/json/geo/JsonFeature.java
index 1cfd11916b..9ce4c4790b 100644
--- a/api/src/main/java/com/graphhopper/json/geo/JsonFeature.java
+++ b/api/src/main/java/com/graphhopper/json/geo/JsonFeature.java
@@ -18,7 +18,7 @@
 package com.graphhopper.json.geo;
 
 import com.graphhopper.util.shapes.BBox;
-import com.vividsolutions.jts.geom.Geometry;
+import org.locationtech.jts.geom.Geometry;
 
 import java.util.Map;
 
@@ -29,7 +29,7 @@
  */
 public class JsonFeature {
     private String id;
-    private String type;
+    private String type = "Feature";
     private BBox bbox;
     private Geometry geometry;
     private Map<String, Object> properties;
@@ -81,10 +81,6 @@ public void setId(String id) {
         this.id = id;
     }
 
-    public void setType(String type) {
-        this.type = type;
-    }
-
     public void setBbox(BBox bbox) {
         this.bbox = bbox;
     }
diff --git a/api/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java b/api/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
index 39541f09b4..55d8a42187 100644
--- a/api/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
+++ b/api/src/main/java/com/graphhopper/json/geo/JsonFeatureCollection.java
@@ -17,14 +17,15 @@
  */
 package com.graphhopper.json.geo;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
  * @author Peter Karich
  */
 public class JsonFeatureCollection {
-    String type;
-    List<JsonFeature> features;
+    String type = "FeatureCollection";
+    List<JsonFeature> features = new ArrayList<>();
 
     public String getType() {
         return type;
diff --git a/api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java b/api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
index 6e0ebe8354..4c7bdbac5a 100644
--- a/api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
+++ b/api/src/main/java/com/graphhopper/util/DistanceCalcEarth.java
@@ -17,11 +17,11 @@
  */
 package com.graphhopper.util;
 
+import static java.lang.Math.*;
+
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 
-import static java.lang.Math.*;
-
 /**
  * @author Peter Karich
  */
@@ -155,7 +155,7 @@ else if (factor < 0)
         return calcNormalizedDist(c_lat, c_lon / shrinkFactor, r_lat_deg, r_lon_deg);
     }
 
-    private double calcShrinkFactor(double a_lat_deg, double b_lat_deg) {
+    double calcShrinkFactor(double a_lat_deg, double b_lat_deg) {
         return cos(toRadians((a_lat_deg + b_lat_deg) / 2));
     }
 
diff --git a/api/src/main/java/com/graphhopper/util/Helper.java b/api/src/main/java/com/graphhopper/util/Helper.java
index de08e73101..e7ed1df51e 100644
--- a/api/src/main/java/com/graphhopper/util/Helper.java
+++ b/api/src/main/java/com/graphhopper/util/Helper.java
@@ -20,6 +20,8 @@
 import com.graphhopper.util.shapes.BBox;
 
 import java.io.*;
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
 import java.nio.ByteBuffer;
 import java.nio.MappedByteBuffer;
 import java.nio.charset.Charset;
@@ -30,7 +32,6 @@
 import java.util.Map.Entry;
 
 /**
- *
  * @author Peter Karich
  */
 public class Helper {
@@ -62,11 +63,11 @@ public static Locale getLocale(String param) {
         return new Locale(param.substring(0, index), param.substring(index + 1));
     }
 
-    public static String toLowerCase(String string){
+    public static String toLowerCase(String string) {
         return string.toLowerCase(Locale.ROOT);
     }
 
-    public static String toUpperCase(String string){
+    public static String toUpperCase(String string) {
         return string.toUpperCase(Locale.ROOT);
     }
 
@@ -174,6 +175,29 @@ public static String getMemInfo() {
         return "totalMB:" + getTotalMB() + ", usedMB:" + getUsedMB();
     }
 
+    public static int getUsedMBAfterGC() {
+        long before = getTotalGcCount();
+        // trigger gc
+        System.gc();
+        while (getTotalGcCount() == before) {
+            // wait for the gc to have completed
+        }
+        long result = (ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed() +
+                ManagementFactory.getMemoryMXBean().getNonHeapMemoryUsage().getUsed()) / (1024 * 1024);
+        return (int) result;
+    }
+
+    private static long getTotalGcCount() {
+        long sum = 0;
+        for (GarbageCollectorMXBean b : ManagementFactory.getGarbageCollectorMXBeans()) {
+            long count = b.getCollectionCount();
+            if (count != -1) {
+                sum += count;
+            }
+        }
+        return sum;
+    }
+
     public static int getSizeOfObjectRef(int factor) {
         // pointer to class, flags, lock
         return factor * (4 + 4 + 4);
@@ -433,4 +457,18 @@ public static final String underScoreToCamelCase(String key) {
 
         return sb.toString();
     }
+
+    /**
+     * Equivalent to java 8 String#join
+     */
+    public static String join(String delimiter, List<String> strings) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < strings.size(); i++) {
+            if (i > 0) {
+                sb.append(delimiter);
+            }
+            sb.append(strings.get(i));
+        }
+        return sb.toString();
+    }
 }
diff --git a/api/src/main/java/com/graphhopper/util/Instruction.java b/api/src/main/java/com/graphhopper/util/Instruction.java
index 921d2e3383..8e7612b951 100644
--- a/api/src/main/java/com/graphhopper/util/Instruction.java
+++ b/api/src/main/java/com/graphhopper/util/Instruction.java
@@ -18,7 +18,6 @@
 package com.graphhopper.util;
 
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 
 public class Instruction {
@@ -127,24 +126,6 @@ public Instruction setTime(long time) {
         return this;
     }
 
-    /**
-     * Latitude of the location where this instruction should take place.
-     */
-    double getFirstLat() {
-        return points.getLatitude(0);
-    }
-
-    /**
-     * Longitude of the location where this instruction should take place.
-     */
-    double getFirstLon() {
-        return points.getLongitude(0);
-    }
-
-    double getFirstEle() {
-        return points.getElevation(0);
-    }
-
     /* This method returns the points associated to this instruction. Please note that it will not include the last point,
      * i.e. the first point of the next instruction object.
      */
@@ -156,43 +137,6 @@ public void setPoints(PointList points) {
         this.points = points;
     }
 
-    /**
-     * This method returns a list of gpx entries where the time (in time) is relative to the first
-     * which is 0. It does NOT contain the last point which is the first of the next instruction.
-     *
-     * @return the time offset to add for the next instruction
-     */
-    long fillGPXList(List<GPXEntry> list, long time,
-                     Instruction prevInstr, Instruction nextInstr, boolean firstInstr) {
-        checkOne();
-        int len = points.size();
-        long prevTime = time;
-        double lat = points.getLatitude(0);
-        double lon = points.getLongitude(0);
-        double ele = Double.NaN;
-        boolean is3D = points.is3D();
-        if (is3D)
-            ele = points.getElevation(0);
-
-        for (int i = 0; i < len; i++) {
-            list.add(new GPXEntry(lat, lon, ele, prevTime));
-
-            boolean last = i + 1 == len;
-            double nextLat = last ? nextInstr.getFirstLat() : points.getLatitude(i + 1);
-            double nextLon = last ? nextInstr.getFirstLon() : points.getLongitude(i + 1);
-            double nextEle = is3D ? (last ? nextInstr.getFirstEle() : points.getElevation(i + 1)) : Double.NaN;
-            if (is3D)
-                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, nextEle, lat, lon, ele) / distance);
-            else
-                prevTime = Math.round(prevTime + this.time * Helper.DIST_3D.calcDist(nextLat, nextLon, lat, lon) / distance);
-
-            lat = nextLat;
-            lon = nextLon;
-            ele = nextEle;
-        }
-        return time + this.time;
-    }
-
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder();
@@ -209,7 +153,7 @@ public String toString() {
      * Return the direction like 'NE' based on the first tracksegment of the instruction. If
      * Instruction does not contain enough coordinate points, an empty string will be returned.
      */
-    String calcDirection(Instruction nextI) {
+    public String calcDirection(Instruction nextI) {
         double azimuth = calcAzimuth(nextI);
         if (Double.isNaN(azimuth))
             return "";
@@ -241,11 +185,6 @@ public double calcAzimuth(Instruction nextI) {
         return AC.calcAzimuth(lat, lon, nextLat, nextLon);
     }
 
-    void checkOne() {
-        if (points.size() < 1)
-            throw new IllegalStateException("Instruction must contain at least one point " + toString());
-    }
-
     /**
      * This method returns the length of an Instruction. The length of an instruction is defined by [the
      * index of the first point of the next instruction] - [the index of the first point of this instruction].
diff --git a/api/src/main/java/com/graphhopper/util/InstructionList.java b/api/src/main/java/com/graphhopper/util/InstructionList.java
index 5d9192e6be..69aafcad97 100644
--- a/api/src/main/java/com/graphhopper/util/InstructionList.java
+++ b/api/src/main/java/com/graphhopper/util/InstructionList.java
@@ -17,9 +17,6 @@
  */
 package com.graphhopper.util;
 
-import java.text.DateFormat;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
 import java.util.*;
 
 /**
@@ -27,13 +24,6 @@
  */
 public class InstructionList extends AbstractList<Instruction> {
 
-    static String simpleXMLEscape(String str) {
-        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
-        return str.replaceAll("&", "&amp;").
-                // but do not care for:
-                        replaceAll("[\\<\\>]", "_");
-    }
-
     private final List<Instruction> instructions;
     private final Translation tr;
 
@@ -71,211 +61,6 @@ public Instruction remove(int index) {
         return instructions.remove(index);
     }
 
-    public void replaceLast(Instruction instr) {
-        if (instructions.isEmpty())
-            throw new IllegalStateException("Cannot replace last instruction as list is empty");
-
-        instructions.set(instructions.size() - 1, instr);
-    }
-
-    public List<Map<String, Object>> createJson() {
-        List<Map<String, Object>> instrList = new ArrayList<>(instructions.size());
-        int pointsIndex = 0;
-        int counter = 0;
-        for (Instruction instruction : instructions) {
-            Map<String, Object> instrJson = new HashMap<>();
-            instrList.add(instrJson);
-
-            InstructionAnnotation ia = instruction.getAnnotation();
-            String text = instruction.getTurnDescription(tr);
-            if (Helper.isEmpty(text))
-                text = ia.getMessage();
-            instrJson.put("text", Helper.firstBig(text));
-            if (!ia.isEmpty()) {
-                instrJson.put("annotation_text", ia.getMessage());
-                instrJson.put("annotation_importance", ia.getImportance());
-            }
-
-            instrJson.put("street_name", instruction.getName());
-            instrJson.put("time", instruction.getTime());
-            instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
-            instrJson.put("sign", instruction.getSign());
-            instrJson.putAll(instruction.getExtraInfoJSON());
-
-            int tmpIndex = pointsIndex + instruction.getLength();
-            instrJson.put("interval", Arrays.asList(pointsIndex, tmpIndex));
-            pointsIndex = tmpIndex;
-
-            counter++;
-        }
-        return instrList;
-    }
-
-    /**
-     * @return This method returns a list of gpx entries where the time (in millis) is relative to
-     * the first which is 0.
-     */
-    public List<GPXEntry> createGPXList() {
-        if (isEmpty())
-            return Collections.emptyList();
-
-        List<GPXEntry> gpxList = new ArrayList<>();
-        long timeOffset = 0;
-        for (int i = 0; i < size() - 1; i++) {
-            Instruction prevInstr = (i > 0) ? get(i - 1) : null;
-            boolean instrIsFirst = prevInstr == null;
-            Instruction nextInstr = get(i + 1);
-            nextInstr.checkOne();
-            // current instruction does not contain last point which is equals to first point of next instruction:
-            timeOffset = get(i).fillGPXList(gpxList, timeOffset, prevInstr, nextInstr, instrIsFirst);
-        }
-        Instruction lastI = get(size() - 1);
-        if (lastI.points.size() != 1)
-            throw new IllegalStateException("Last instruction must have exactly one point but was " + lastI.points.size());
-        double lastLat = lastI.getFirstLat(), lastLon = lastI.getFirstLon(),
-                lastEle = lastI.getPoints().is3D() ? lastI.getFirstEle() : Double.NaN;
-        gpxList.add(new GPXEntry(lastLat, lastLon, lastEle, timeOffset));
-        return gpxList;
-    }
-
-    /**
-     * Creates the standard GPX string out of the points according to the schema found here:
-     * https://graphhopper.com/public/schema/gpx-1.1.xsd
-     * <p>
-     *
-     * @return string to be stored as gpx file
-     */
-    public String createGPX(String version) {
-        return createGPX("GraphHopper", new Date().getTime(), version);
-    }
-
-    public String createGPX(String trackName, long startTimeMillis, String version) {
-        boolean includeElevation = size() > 0 && get(0).getPoints().is3D();
-        return createGPX(trackName, startTimeMillis, includeElevation, true, true, true, version);
-    }
-
-    private void createWayPointBlock(StringBuilder output, Instruction instruction, DecimalFormat decimalFormat) {
-        output.append("\n<wpt ");
-        output.append("lat=\"").append(decimalFormat.format(instruction.getFirstLat()));
-        output.append("\" lon=\"").append(decimalFormat.format(instruction.getFirstLon())).append("\">");
-        String name;
-        if (instruction.getName().isEmpty())
-            name = instruction.getTurnDescription(tr);
-        else
-            name = instruction.getName();
-
-        output.append(" <name>").append(simpleXMLEscape(name)).append("</name>");
-        output.append("</wpt>");
-    }
-
-    public String createGPX(String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
-        DateFormat formatter = Helper.createFormatter();
-
-        DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
-        decimalFormat.setMinimumFractionDigits(1);
-        decimalFormat.setMaximumFractionDigits(6);
-        decimalFormat.setMinimumIntegerDigits(1);
-
-        String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
-                + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
-                + " creator=\"Graphhopper version " + version + "\" version=\"1.1\""
-                // This xmlns:gh acts only as ID, no valid URL necessary.
-                // Use a separate namespace for custom extensions to make basecamp happy.
-                + " xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">"
-                + "\n<metadata>"
-                + "<copyright author=\"OpenStreetMap contributors\"/>"
-                + "<link href=\"http://graphhopper.com\">"
-                + "<text>GraphHopper GPX</text>"
-                + "</link>"
-                + "<time>" + formatter.format(startTimeMillis) + "</time>"
-                + "</metadata>";
-        StringBuilder gpxOutput = new StringBuilder(header);
-        if (!isEmpty()) {
-            if (withWayPoints) {
-                createWayPointBlock(gpxOutput, instructions.get(0), decimalFormat);   // Start
-                for (Instruction currInstr : instructions) {
-                    if ((currInstr.getSign() == Instruction.REACHED_VIA) // Via
-                            || (currInstr.getSign() == Instruction.FINISH)) // End
-                    {
-                        createWayPointBlock(gpxOutput, currInstr, decimalFormat);
-                    }
-                }
-            }
-            if (withRoute) {
-                gpxOutput.append("\n<rte>");
-                Instruction nextInstr = null;
-                for (Instruction currInstr : instructions) {
-                    if (null != nextInstr)
-                        createRteptBlock(gpxOutput, nextInstr, currInstr, decimalFormat);
-
-                    nextInstr = currInstr;
-                }
-                createRteptBlock(gpxOutput, nextInstr, null, decimalFormat);
-                gpxOutput.append("\n</rte>");
-            }
-        }
-        if (withTrack) {
-            gpxOutput.append("\n<trk><name>").append(trackName).append("</name>");
-
-            gpxOutput.append("<trkseg>");
-            for (GPXEntry entry : createGPXList()) {
-                gpxOutput.append("\n<trkpt lat=\"").append(decimalFormat.format(entry.getLat()));
-                gpxOutput.append("\" lon=\"").append(decimalFormat.format(entry.getLon())).append("\">");
-                if (includeElevation)
-                    gpxOutput.append("<ele>").append(Helper.round2(entry.getEle())).append("</ele>");
-                gpxOutput.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
-                gpxOutput.append("</trkpt>");
-            }
-            gpxOutput.append("\n</trkseg>");
-            gpxOutput.append("\n</trk>");
-        }
-
-        // we could now use 'wpt' for via points
-        gpxOutput.append("\n</gpx>");
-        return gpxOutput.toString();
-    }
-
-    public void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI, DecimalFormat decimalFormat) {
-        output.append("\n<rtept lat=\"").append(decimalFormat.format(instruction.getFirstLat())).
-                append("\" lon=\"").append(decimalFormat.format(instruction.getFirstLon())).append("\">");
-
-        if (!instruction.getName().isEmpty())
-            output.append("<desc>").append(simpleXMLEscape(instruction.getTurnDescription(tr))).append("</desc>");
-
-        output.append("<extensions>");
-        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
-        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
-
-        String direction = instruction.calcDirection(nextI);
-        if (!direction.isEmpty())
-            output.append("<gh:direction>").append(direction).append("</gh:direction>");
-
-        double azimuth = instruction.calcAzimuth(nextI);
-        if (!Double.isNaN(azimuth))
-            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
-
-        if (instruction instanceof RoundaboutInstruction) {
-            RoundaboutInstruction ri = (RoundaboutInstruction) instruction;
-
-            output.append("<gh:exit_number>").append(ri.getExitNumber()).append("</gh:exit_number>");
-        }
-
-        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
-        output.append("</extensions>");
-        output.append("</rtept>");
-    }
-
-    /**
-     * @return list of lat lon
-     */
-    List<List<Double>> createStartPoints() {
-        List<List<Double>> res = new ArrayList<>(instructions.size());
-        for (Instruction instruction : instructions) {
-            res.add(Arrays.asList(instruction.getFirstLat(), instruction.getFirstLon()));
-        }
-        return res;
-    }
-
     /**
      * This method is useful for navigation devices to find the next instruction for the specified
      * coordinate (e.g. the current position).
@@ -339,4 +124,8 @@ public Instruction find(double lat, double lon, double maxDistance) {
         return get(foundInstruction);
     }
 
+    public Translation getTr() {
+        return tr;
+    }
+
 }
diff --git a/api/src/main/java/com/graphhopper/util/PMap.java b/api/src/main/java/com/graphhopper/util/PMap.java
index 2590258393..c40ce658cb 100644
--- a/api/src/main/java/com/graphhopper/util/PMap.java
+++ b/api/src/main/java/com/graphhopper/util/PMap.java
@@ -34,7 +34,7 @@ public PMap() {
     }
 
     public PMap(int capacity) {
-        this(new HashMap<String, String>(capacity));
+        this(new HashMap<>(capacity));
     }
 
     public PMap(Map<String, String> map) {
@@ -128,6 +128,17 @@ public double getDouble(String key, double _default) {
         return _default;
     }
 
+    public float getFloat(String key, float _default) {
+        String str = get(key);
+        if (!Helper.isEmpty(str)) {
+            try {
+                return Float.parseFloat(str);
+            } catch (Exception ex) {
+            }
+        }
+        return _default;
+    }
+
     public String get(String key, String _default) {
         String str = get(key);
         if (Helper.isEmpty(str))
diff --git a/api/src/main/java/com/graphhopper/util/Parameters.java b/api/src/main/java/com/graphhopper/util/Parameters.java
index 0ec9de5fc3..5692c988da 100644
--- a/api/src/main/java/com/graphhopper/util/Parameters.java
+++ b/api/src/main/java/com/graphhopper/util/Parameters.java
@@ -114,6 +114,7 @@
          */
         public static final String PASS_THROUGH = "pass_through";
         public static final String POINT_HINT = "point_hint";
+        public static final String SNAP_PREVENTION = "snap_prevention";
         /**
          * default heading penalty in seconds
          */
@@ -189,7 +190,7 @@
     /**
      * Properties for the details response
      */
-    public static final class DETAILS {
+    public static final class Details {
 
         public static final String PATH_DETAILS = "details";
 
diff --git a/api/src/main/java/com/graphhopper/util/PointList.java b/api/src/main/java/com/graphhopper/util/PointList.java
index 2dca1d6f65..92b347dd2d 100644
--- a/api/src/main/java/com/graphhopper/util/PointList.java
+++ b/api/src/main/java/com/graphhopper/util/PointList.java
@@ -19,9 +19,9 @@
 
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.GHPoint3D;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.GeometryFactory;
-import com.vividsolutions.jts.geom.LineString;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
 
 import java.util.Arrays;
 import java.util.Iterator;
@@ -136,7 +136,7 @@ public int size() {
         }
 
         @Override
-        public GHPoint3D toGHPoint(int index) {
+        public GHPoint3D get(int index) {
             throw new UnsupportedOperationException("cannot access EMPTY PointList");
         }
 
@@ -571,7 +571,7 @@ public void parse2DJSON(String str) {
         }
     }
 
-    public GHPoint3D toGHPoint(int index) {
+    public GHPoint3D get(int index) {
         return new GHPoint3D(getLatitude(index), getLongitude(index), getElevation(index));
     }
 
@@ -594,7 +594,7 @@ public GHPoint3D next() {
                 if (counter >= getSize())
                     throw new NoSuchElementException();
 
-                GHPoint3D point = PointList.this.toGHPoint(counter);
+                GHPoint3D point = PointList.this.get(counter);
                 counter++;
                 return point;
             }
diff --git a/api/src/main/java/com/graphhopper/util/details/PathDetail.java b/api/src/main/java/com/graphhopper/util/details/PathDetail.java
index 9f091da6c7..4a801f3e90 100644
--- a/api/src/main/java/com/graphhopper/util/details/PathDetail.java
+++ b/api/src/main/java/com/graphhopper/util/details/PathDetail.java
@@ -1,3 +1,20 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package com.graphhopper.util.details;
 
 /**
@@ -31,6 +48,9 @@ public PathDetail(String value) {
         this.value = value;
     }
 
+    /**
+     * @return the value of this PathDetail. Can be null
+     */
     public Object getValue() {
         return value;
     }
diff --git a/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java b/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
index 5e01d77e27..40e62e4bfc 100644
--- a/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
+++ b/api/src/main/java/com/graphhopper/util/exceptions/DetailedIllegalArgumentException.java
@@ -24,8 +24,8 @@
 
     private final Map<String, Object> details;
 
-    public DetailedIllegalArgumentException(String var1, Map<String, Object> details) {
-        super(var1);
+    public DetailedIllegalArgumentException(String message, Map<String, Object> details) {
+        super(message);
         this.details = details;
     }
 
diff --git a/api/src/main/java/com/graphhopper/util/shapes/BBox.java b/api/src/main/java/com/graphhopper/util/shapes/BBox.java
index ed716f56d1..9a73055f9c 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/BBox.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/BBox.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.NumHelper;
+import org.locationtech.jts.geom.Envelope;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -46,7 +47,7 @@
     public double maxEle;
 
     public BBox(double[] coords) {
-        this(coords[0],coords[2],coords[1],coords[3]);
+        this(coords[0], coords[2], coords[1], coords[3]);
     }
 
     public BBox(double minLon, double maxLon, double minLat, double maxLat) {
@@ -122,7 +123,7 @@ public void update(double lat, double lon, double elev) {
      * @return the intersecting BBox or null if not intersecting
      */
     public BBox calculateIntersection(BBox bBox) {
-        if (!this.intersect(bBox))
+        if (!this.intersects(bBox))
             return null;
 
         double minLon = Math.max(this.minLon, bBox.minLon);
@@ -139,11 +140,11 @@ public BBox clone() {
     }
 
     @Override
-    public boolean intersect(Shape s) {
+    public boolean intersects(Shape s) {
         if (s instanceof BBox) {
-            return intersect((BBox) s);
+            return intersects((BBox) s);
         } else if (s instanceof Circle) {
-            return ((Circle) s).intersect(this);
+            return ((Circle) s).intersects(this);
         }
 
         throw new UnsupportedOperationException("unsupported shape");
@@ -160,14 +161,24 @@ public boolean contains(Shape s) {
         throw new UnsupportedOperationException("unsupported shape");
     }
 
-    public boolean intersect(Circle s) {
-        return ((Circle) s).intersect(this);
+    public boolean intersects(Circle s) {
+        return s.intersects(this);
     }
 
-    public boolean intersect(BBox o) {
+    /**
+     * This method calculates if this BBox intersects with the specified BBox
+     */
+    public boolean intersects(double minLon, double maxLon, double minLat, double maxLat) {
+        return this.minLon < maxLon && this.minLat < maxLat && minLon < this.maxLon && minLat < this.maxLat;
+    }
+
+    /**
+     * This method calculates if this BBox intersects with the specified BBox
+     */
+    public boolean intersects(BBox o) {
         // return (o.minLon < minLon && o.maxLon > minLon || o.minLon < maxLon && o.minLon >= minLon)
         //  && (o.maxLat < maxLat && o.maxLat >= minLat || o.maxLat >= maxLat && o.minLat < maxLat);
-        return minLon < o.maxLon && minLat < o.maxLat && o.minLon < maxLon && o.minLat < maxLat;
+        return this.minLon < o.maxLon && this.minLat < o.maxLat && o.minLon < this.maxLon && o.minLat < this.maxLat;
     }
 
     @Override
@@ -272,6 +283,10 @@ public boolean isValid() {
         return list;
     }
 
+    public static BBox fromEnvelope(Envelope envelope) {
+        return new BBox(envelope.getMinX(), envelope.getMaxX(), envelope.getMinY(), envelope.getMaxY());
+    }
+
     /**
      * @return an estimated area in m^2 using the mean value of latitudes for longitude distance
      */
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Circle.java b/api/src/main/java/com/graphhopper/util/shapes/Circle.java
index 0bf6a57b80..bbb38ee334 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Circle.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Circle.java
@@ -73,14 +73,14 @@ private double normDist(double lat1, double lon1) {
     }
 
     @Override
-    public boolean intersect(Shape o) {
+    public boolean intersects(Shape o) {
         if (o instanceof Circle) {
-            return intersect((Circle) o);
+            return intersects((Circle) o);
         } else if (o instanceof BBox) {
-            return intersect((BBox) o);
+            return intersects((BBox) o);
         }
 
-        return o.intersect(this);
+        return o.intersects(this);
     }
 
     @Override
@@ -94,8 +94,8 @@ public boolean contains(Shape o) {
         throw new UnsupportedOperationException("unsupported shape");
     }
 
-    public boolean intersect(BBox b) {
-        // test top intersect
+    public boolean intersects(BBox b) {
+        // test top intersects
         if (lat > b.maxLat) {
             if (lon < b.minLon) {
                 return normDist(b.maxLat, b.minLon) <= normedDist;
@@ -106,7 +106,7 @@ public boolean intersect(BBox b) {
             return b.maxLat - bbox.minLat > 0;
         }
 
-        // test bottom intersect
+        // test bottom intersects
         if (lat < b.minLat) {
             if (lon < b.minLon) {
                 return normDist(b.minLat, b.minLon) <= normedDist;
@@ -117,7 +117,7 @@ public boolean intersect(BBox b) {
             return bbox.maxLat - b.minLat > 0;
         }
 
-        // test middle intersect
+        // test middle intersects
         if (lon < b.minLon) {
             return bbox.maxLon - b.minLon > 0;
         }
@@ -127,9 +127,9 @@ public boolean intersect(BBox b) {
         return true;
     }
 
-    public boolean intersect(Circle c) {
+    public boolean intersects(Circle c) {
         // necessary to improve speed?
-        if (!getBounds().intersect(c.getBounds())) {
+        if (!getBounds().intersects(c.getBounds())) {
             return false;
         }
 
diff --git a/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 38f435675d..6e0e6256f6 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -18,7 +18,9 @@
 package com.graphhopper.util.shapes;
 
 import com.graphhopper.util.NumHelper;
-import com.vividsolutions.jts.geom.Point;
+import org.locationtech.jts.geom.Point;
+
+import java.util.Locale;
 
 /**
  * @author Peter Karich
@@ -103,6 +105,10 @@ public String toString() {
         return lat + "," + lon;
     }
 
+    public String toShortString() {
+        return String.format(Locale.ROOT, "%.8f,%.8f", lat, lon);
+    }
+
     /**
      * Attention: geoJson is LON,LAT
      */
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
index e3c8e256bb..abf7c731cb 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Polygon.java
@@ -82,7 +82,7 @@ public Polygon(double[] lat, double[] lon) {
     /**
      * Lossy conversion to a GraphHopper Polygon.
      */
-    public static Polygon create(com.vividsolutions.jts.geom.Polygon polygon) {
+    public static Polygon create(org.locationtech.jts.geom.Polygon polygon) {
         double[] lats = new double[polygon.getNumPoints()];
         double[] lons = new double[polygon.getNumPoints()];
         for (int i = 0; i < polygon.getNumPoints(); i++) {
@@ -100,7 +100,7 @@ public boolean contains(GHPoint point) {
     }
 
     @Override
-    public boolean intersect(Shape o) {
+    public boolean intersects(Shape o) {
         throw new UnsupportedOperationException("Not supported yet.");
     }
 
diff --git a/api/src/main/java/com/graphhopper/util/shapes/Shape.java b/api/src/main/java/com/graphhopper/util/shapes/Shape.java
index dd0f71e5f3..7962c67610 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/Shape.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/Shape.java
@@ -27,7 +27,7 @@
     /**
      * @return true if edges or areas of this and the specified shapes overlap
      */
-    boolean intersect(Shape o);
+    boolean intersects(Shape o);
 
     /**
      * @return true only if lat and lon are inside (or on the edge) of this shape
diff --git a/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java b/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
index dc77fb80d1..321e473b5f 100644
--- a/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
+++ b/api/src/test/java/com/graphhopper/util/shapes/BBoxTest.java
@@ -71,18 +71,18 @@ public void testIntersect() {
         //
 
         // use ISO 19115 standard (minLon, maxLon followed by minLat(south!),maxLat)
-        assertTrue(new BBox(12, 15, 12, 15).intersect(new BBox(13, 14, 11, 16)));
-        // assertFalse(new BBox(15, 12, 12, 15).intersect(new BBox(16, 15, 11, 14)));
+        assertTrue(new BBox(12, 15, 12, 15).intersects(new BBox(13, 14, 11, 16)));
+        // assertFalse(new BBox(15, 12, 12, 15).intersects(new BBox(16, 15, 11, 14)));
 
         // DOES NOT WORK: use bottom to top coord for lat
-        // assertFalse(new BBox(6, 2, 11, 6).intersect(new BBox(5, 3, 12, 5)));
+        // assertFalse(new BBox(6, 2, 11, 6).intersects(new BBox(5, 3, 12, 5)));
         // so, use bottom-left and top-right corner!
-        assertTrue(new BBox(2, 6, 6, 11).intersect(new BBox(3, 5, 5, 12)));
+        assertTrue(new BBox(2, 6, 6, 11).intersects(new BBox(3, 5, 5, 12)));
 
         // DOES NOT WORK: use bottom to top coord for lat and right to left for lon
-        // assertFalse(new BBox(6, 11, 11, 6).intersect(new BBox(5, 10, 12, 7)));
+        // assertFalse(new BBox(6, 11, 11, 6).intersects(new BBox(5, 10, 12, 7)));
         // so, use bottom-right and top-left corner
-        assertTrue(new BBox(6, 11, 6, 11).intersect(new BBox(7, 10, 5, 12)));
+        assertTrue(new BBox(6, 11, 6, 11).intersects(new BBox(7, 10, 5, 12)));
     }
 
     @Test
@@ -109,37 +109,37 @@ public void testCalculateIntersection() {
     public void testBasicJavaOverload() {
         new BBox(2, 4, 0, 1) {
             @Override
-            public boolean intersect(Circle c) {
+            public boolean intersects(Circle c) {
                 assertTrue(true);
-                return super.intersect(c);
+                return super.intersects(c);
             }
 
             @Override
-            public boolean intersect(Shape c) {
+            public boolean intersects(Shape c) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(BBox c) {
+            public boolean intersects(BBox c) {
                 assertTrue(false);
                 return true;
             }
-        }.intersect(new Circle(1, 2, 3) {
+        }.intersects(new Circle(1, 2, 3) {
             @Override
-            public boolean intersect(Circle c) {
+            public boolean intersects(Circle c) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(Shape b) {
+            public boolean intersects(Shape b) {
                 assertTrue(false);
                 return true;
             }
 
             @Override
-            public boolean intersect(BBox b) {
+            public boolean intersects(BBox b) {
                 assertTrue(true);
                 return true;
             }
diff --git a/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java b/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
index 819a944be4..eaf6e18092 100644
--- a/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
+++ b/api/src/test/java/com/graphhopper/util/shapes/CircleTest.java
@@ -29,17 +29,17 @@
 public class CircleTest {
     @Test
     public void testIntersectCircleCircle() {
-        assertTrue(new Circle(0, 0, 80000).intersect(new Circle(1, 1, 80000)));
-        assertFalse(new Circle(0, 0, 75000).intersect(new Circle(1, 1, 80000)));
+        assertTrue(new Circle(0, 0, 80000).intersects(new Circle(1, 1, 80000)));
+        assertFalse(new Circle(0, 0, 75000).intersects(new Circle(1, 1, 80000)));
     }
 
     @Test
     public void testIntersectCircleBBox() {
-        assertTrue(new Circle(10, 10, 120000).intersect(new BBox(9, 11, 8, 9)));
-        assertTrue(new BBox(9, 11, 8, 9).intersect(new Circle(10, 10, 120000)));
+        assertTrue(new Circle(10, 10, 120000).intersects(new BBox(9, 11, 8, 9)));
+        assertTrue(new BBox(9, 11, 8, 9).intersects(new Circle(10, 10, 120000)));
 
-        assertFalse(new Circle(10, 10, 110000).intersect(new BBox(9, 11, 8, 9)));
-        assertFalse(new BBox(9, 11, 8, 9).intersect(new Circle(10, 10, 110000)));
+        assertFalse(new Circle(10, 10, 110000).intersects(new BBox(9, 11, 8, 9)));
+        assertFalse(new BBox(9, 11, 8, 9).intersects(new Circle(10, 10, 110000)));
     }
 
     @Test
diff --git a/appveyor.yml b/appveyor.yml
index a55cd20df4..0348495fdc 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -24,7 +24,7 @@ install:
 build_script:
   - mvn clean install -DskipTests=true -B
 test_script:
-  - mvn test verify -B && mvn checkstyle:check findbugs:check forbiddenapis:check -B
+  - mvn test verify -B && mvn checkstyle:check spotbugs:check forbiddenapis:check -B
 cache:
   - C:\maven\
   - C:\Users\appveyor\.m2
diff --git a/client-hc/pom.xml b/client-hc/pom.xml
index dfea2f2887..8bbc4b30d9 100644
--- a/client-hc/pom.xml
+++ b/client-hc/pom.xml
@@ -23,14 +23,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>directions-api-client-hc</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Directions API hand-crafted Java Client.</name>
      
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>  
     
     <dependencies>
@@ -42,7 +42,7 @@
         <dependency>
             <groupId>com.squareup.okhttp3</groupId>
             <artifactId>okhttp</artifactId>
-            <version>3.8.0</version>
+            <version>3.14.2</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
@@ -74,7 +74,6 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.3</version>
                 <configuration>
                     <compilerArgument>-XDignore.symbol.file</compilerArgument>
                     <fork>true</fork>
@@ -83,19 +82,6 @@
                 </configuration>
             </plugin>
             
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.19.1</version>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>integration-test</goal>
-                            <goal>verify</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>
         </plugins>        
     </build>
         
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
index 469e460722..243c867e8e 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMRequest.java
@@ -1,5 +1,6 @@
 package com.graphhopper.api;
 
+import com.fasterxml.jackson.annotation.JsonProperty;
 import com.graphhopper.GHRequest;
 import com.graphhopper.util.shapes.GHPoint;
 
@@ -17,8 +18,10 @@
     private List<GHPoint> toPoints;
     private List<String> fromPointHints;
     private List<String> toPointHints;
+    private int called = 0;
     boolean identicalLists = true;
     private final Set<String> outArrays = new HashSet<>(5);
+    private boolean failFast = true;
 
     public GHMRequest() {
         this(10);
@@ -130,7 +133,6 @@ public GHRequest setToPointHints(List<String> pointHints) {
 
     @Override
     public GHRequest setPointHints(List<String> pointHints) {
-        super.setPointHints(pointHints);
         this.fromPointHints = pointHints;
         this.toPointHints = pointHints;
         return this;
@@ -146,4 +148,45 @@ public boolean hasPointHints() {
         return this.fromPointHints.size() == this.fromPoints.size() && !fromPoints.isEmpty() &&
                 this.toPointHints.size() == this.toPoints.size() && !toPoints.isEmpty();
     }
+
+    /**
+     * @param failFast if false the matrix calculation will be continued even when some points are not connected
+     */
+    @JsonProperty("fail_fast")
+    public void setFailFast(boolean failFast) {
+        this.failFast = failFast;
+    }
+
+    public boolean getFailFast() {
+        return failFast;
+    }
+
+    /**
+     * This method makes it more likely that hasPointHints returns true as often point hints are added although the
+     * strings are empty. But because they could be used as placeholder we do not know earlier if they are meaningless.
+     */
+    void compactPointHints() {
+        if (called > 0)
+            throw new IllegalStateException("cannot call more than once");
+        called++;
+        boolean clear = true;
+        for (String hint : toPointHints) {
+            if (!hint.isEmpty()) {
+                clear = false;
+                break;
+            }
+        }
+        if (clear)
+            toPointHints.clear();
+
+        clear = true;
+        for (String hint : fromPointHints) {
+            if (!hint.isEmpty()) {
+                clear = false;
+                break;
+            }
+        }
+        if (clear)
+            fromPointHints.clear();
+    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
index 070a32eac2..d87e5aeab8 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
@@ -20,7 +20,6 @@
  */
 public abstract class GHMatrixAbstractRequester {
 
-    private GraphHopperWeb web = new GraphHopperWeb();
     protected final ObjectMapper objectMapper;
     protected final Set<String> ignoreSet = new HashSet<>(10);
     protected final String serviceUrl;
@@ -61,18 +60,24 @@ public OkHttpClient getDownloader() {
 
     protected String getJson(String url) throws IOException {
         Request okRequest = new Request.Builder().url(url).build();
-        ResponseBody body = downloader.newCall(okRequest).execute().body();
-        String str = body.string();
-        body.close();
-        return str;
+        ResponseBody body = null;
+        try {
+            body = downloader.newCall(okRequest).execute().body();
+            return body.string();
+        } finally {
+            Helper.close(body);
+        }
     }
 
     protected String postJson(String url, JsonNode data) throws IOException {
         Request okRequest = new Request.Builder().url(url).post(RequestBody.create(MT_JSON, data.toString())).build();
-        ResponseBody body = downloader.newCall(okRequest).execute().body();
-        String str = body.string();
-        body.close();
-        return str;
+        ResponseBody body = null;
+        try {
+            body = downloader.newCall(okRequest).execute().body();
+            return body.string();
+        } finally {
+            Helper.close(body);
+        }
     }
 
     protected JsonNode toJSON(String url, String str) {
@@ -95,11 +100,18 @@ protected JsonNode toJSON(String url, String str) {
         }
     }
 
-    public void fillResponseFromJson(MatrixResponse matrixResponse, String responseAsString) throws IOException {
-        fillResponseFromJson(matrixResponse, objectMapper.reader().readTree(responseAsString));
+    public void fillResponseFromJson(MatrixResponse matrixResponse, String responseAsString, boolean failFast) throws IOException {
+        fillResponseFromJson(matrixResponse, objectMapper.reader().readTree(responseAsString), failFast);
     }
 
-    protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solution) {
+    /**
+     * @param failFast If false weights/distances/times that are null are interpreted as disconnected points and are
+     *                 thus set to their respective maximum values. Furthermore, the indices of the disconnected points
+     *                 are added to {@link MatrixResponse#getDisconnectedPoints()} and the indices of the points that
+     *                 could not be found are added to {@link MatrixResponse#getInvalidFromPoints()} and/or
+     *                 {@link MatrixResponse#getInvalidToPoints()}.
+     */
+    protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solution, boolean failFast) {
         final boolean readWeights = solution.has("weights");
         final boolean readDistances = solution.has("distances");
         final boolean readTimes = solution.has("times");
@@ -149,15 +161,27 @@ protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solu
 
             for (int toIndex = 0; toIndex < toCount; toIndex++) {
                 if (readWeights) {
-                    weights[toIndex] = weightsFromArray.get(toIndex).asDouble();
+                    if (weightsFromArray.get(toIndex).isNull() && !failFast) {
+                        weights[toIndex] = Double.MAX_VALUE;
+                    } else {
+                        weights[toIndex] = weightsFromArray.get(toIndex).asDouble();
+                    }
                 }
 
                 if (readTimes) {
-                    times[toIndex] = timesFromArray.get(toIndex).asLong() * 1000;
+                    if (timesFromArray.get(toIndex).isNull() && !failFast) {
+                        times[toIndex] = Long.MAX_VALUE;
+                    } else {
+                        times[toIndex] = timesFromArray.get(toIndex).asLong() * 1000;
+                    }
                 }
 
                 if (readDistances) {
-                    distances[toIndex] = (int) Math.round(distancesFromArray.get(toIndex).asDouble());
+                    if (distancesFromArray.get(toIndex).isNull() && !failFast) {
+                        distances[toIndex] = Integer.MAX_VALUE;
+                    } else {
+                        distances[toIndex] = (int) Math.round(distancesFromArray.get(toIndex).asDouble());
+                    }
                 }
             }
 
@@ -173,6 +197,43 @@ protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode solu
                 matrixResponse.setDistanceRow(fromIndex, distances);
             }
         }
+        if (!failFast && solution.has("hints")) {
+            addProblems(matrixResponse, solution.get("hints"));
+        }
+    }
+
+    private void addProblems(MatrixResponse matrixResponse, JsonNode hints) {
+        for (JsonNode hint : hints) {
+            if (hint.has("point_pairs")) {
+                matrixResponse.setDisconnectedPoints(readDisconnectedPoints(hint.get("point_pairs")));
+            }
+            if (hint.has("invalid_from_points")) {
+                matrixResponse.setInvalidFromPoints(readInvalidPoints(hint.get("invalid_from_points")));
+                matrixResponse.setInvalidToPoints(readInvalidPoints(hint.get("invalid_to_points")));
+            }
+        }
+    }
+
+    private List<MatrixResponse.PointPair> readDisconnectedPoints(JsonNode pointPairsArray) {
+        List<MatrixResponse.PointPair> disconnectedPoints = new ArrayList<>(pointPairsArray.size());
+        for (int i = 0; i < pointPairsArray.size(); i++) {
+            if (pointPairsArray.get(i).size() != 2) {
+                throw new IllegalArgumentException("all point_pairs are expected to contain two elements");
+            }
+            disconnectedPoints.add(new MatrixResponse.PointPair(
+                    pointPairsArray.get(i).get(0).asInt(),
+                    pointPairsArray.get(i).get(1).asInt()
+            ));
+        }
+        return disconnectedPoints;
+    }
+
+    private List<Integer> readInvalidPoints(JsonNode pointsArray) {
+        List<Integer> result = new ArrayList<>(pointsArray.size());
+        for (int i = 0; i < pointsArray.size(); i++) {
+            result.add(pointsArray.get(i).asInt());
+        }
+        return result;
     }
 
     private static int checkArraySizes(String msg, int len, JsonNode... arrays) {
@@ -219,7 +280,4 @@ protected static String encode(String str) {
         }
     }
 
-    public List<Throwable> readErrors(JsonNode json) {
-        return web.readErrors(json);
-    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
index 43a219b736..6083ff2140 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixBatchRequester.java
@@ -4,6 +4,7 @@
 import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
 import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
 import org.slf4j.Logger;
@@ -82,6 +83,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
         requestJson.putArray("out_arrays").addAll(outArrayListJson);
         requestJson.put("vehicle", ghRequest.getVehicle());
         requestJson.put("elevation", hasElevation);
+        requestJson.put("fail_fast", ghRequest.getFailFast());
 
         Map<String, String> hintsMap = ghRequest.getHints().toMap();
         for (String hintKey : hintsMap.keySet()) {
@@ -110,7 +112,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
 
             JsonNode responseJson = toJSON(postUrl, postResponseStr);
             if (responseJson.has("message")) {
-                matrixResponse.addErrors(readErrors(responseJson));
+                matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, responseJson));
                 return matrixResponse;
             }
             if (!responseJson.has("job_id")) {
@@ -139,7 +141,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
                 if (debug) {
                     logger.info(i + " GET URL:" + getUrl + ", response: " + getResponseStr);
                 }
-                matrixResponse.addErrors(readErrors(getResponseJson));
+                matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, getResponseJson));
                 if (matrixResponse.hasErrors()) {
                     break;
                 }
@@ -153,7 +155,7 @@ public MatrixResponse route(GHMRequest ghRequest) {
                     JsonNode solution = getResponseJson.get("solution");
                     matrixResponse.addErrors(readUsableEntityError(outArraysList, solution));
                     if (!matrixResponse.hasErrors())
-                        fillResponseFromJson(matrixResponse, solution);
+                        fillResponseFromJson(matrixResponse, solution, ghRequest.getFailFast());
 
                     break;
                 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
index 1761f05c59..b1ade00fab 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixSyncRequester.java
@@ -1,6 +1,7 @@
 package com.graphhopper.api;
 
 import com.fasterxml.jackson.databind.JsonNode;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
@@ -86,7 +87,11 @@ public MatrixResponse route(GHMRequest ghRequest) {
         }
 
         String url = buildURL("", ghRequest);
-        url += "&" + pointsStr + "&" + pointHintsStr + "&" + outArrayStr + "&vehicle=" + ghRequest.getVehicle();
+        url += "&" + pointsStr + "&" + pointHintsStr + "&" + outArrayStr;
+        if (!Helper.isEmpty(ghRequest.getVehicle())) {
+            url += "&vehicle=" + ghRequest.getVehicle();
+        }
+        url += "&fail_fast=" + ghRequest.getFailFast();
 
         boolean withTimes = outArraysList.contains("times");
         boolean withDistances = outArraysList.contains("distances");
@@ -99,13 +104,13 @@ public MatrixResponse route(GHMRequest ghRequest) {
             String str = getJson(url);
             JsonNode getResponseJson = objectMapper.reader().readTree(str);
 
-            matrixResponse.addErrors(readErrors(getResponseJson));
+            matrixResponse.addErrors(PathWrapperDeserializer.readErrors(objectMapper, getResponseJson));
             if (!matrixResponse.hasErrors()) {
                 matrixResponse.addErrors(readUsableEntityError(outArraysList, getResponseJson));
             }
 
             if (!matrixResponse.hasErrors())
-                fillResponseFromJson(matrixResponse, getResponseJson);
+                fillResponseFromJson(matrixResponse, getResponseJson, ghRequest.getFailFast());
 
         } catch (IOException ex) {
             throw new RuntimeException(ex);
diff --git a/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java b/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java
deleted file mode 100644
index 9291593b89..0000000000
--- a/client-hc/src/main/java/com/graphhopper/api/GoogleMatrixSyncRequester.java
+++ /dev/null
@@ -1,131 +0,0 @@
-package com.graphhopper.api;
-
-import com.fasterxml.jackson.databind.JsonNode;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.shapes.GHPoint;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author Peter Karich
- */
-public class GoogleMatrixSyncRequester extends GHMatrixAbstractRequester {
-
-    public GoogleMatrixSyncRequester(String serviceUrl) {
-        super(serviceUrl);
-        initIgnore();
-    }
-
-    private void initIgnore() {
-        ignoreSet.add("mode");
-        ignoreSet.add("units");
-        ignoreSet.add("destinations");
-        ignoreSet.add("origins");
-        ignoreSet.add("mode");
-    }
-
-    @Override
-    public MatrixResponse route(GHMRequest ghRequest) {
-        String pointsStr;
-
-        pointsStr = createGoogleQuery(ghRequest.getFromPoints(), "origins");
-        pointsStr += "&" + createGoogleQuery(ghRequest.getToPoints(), "destinations");
-
-        List<String> outArraysList = new ArrayList<>(ghRequest.getOutArrays());
-        if (outArraysList.isEmpty()) {
-            // different default as google does not support weights
-            outArraysList.add("distances");
-            outArraysList.add("times");
-        }
-
-        // do not do the mapping here!
-        // bicycling -> bike, car -> car, walking -> foot
-        //
-        String url = buildURL("", ghRequest);
-        url += "&" + pointsStr + "&mode=" + ghRequest.getVehicle();
-
-        boolean withTimes = outArraysList.contains("times");
-        boolean withDistances = outArraysList.contains("distances");
-        boolean withWeights = outArraysList.contains("weights");
-        if (withWeights) {
-            throw new UnsupportedOperationException("Google Matrix API does not include weights");
-        }
-
-        MatrixResponse matrixResponse = new MatrixResponse(
-                ghRequest.getFromPoints().size(),
-                ghRequest.getToPoints().size(), withTimes, withDistances, false);
-
-        try {
-            String str = getJson(url);
-            JsonNode getResponseJson = objectMapper.reader().readTree(str);
-            fillResponseFromJson(matrixResponse, getResponseJson);
-
-        } catch (IOException ex) {
-            throw new RuntimeException(ex);
-        }
-
-        return matrixResponse;
-    }
-
-    private String createGoogleQuery(List<GHPoint> list, String pointName) {
-        String pointsStr = "";
-        for (GHPoint p : list) {
-            if (!pointsStr.isEmpty()) {
-                pointsStr += "|";
-            }
-
-            pointsStr += encode(Helper.round6(p.lat) + "," + Helper.round6(p.lon));
-        }
-        return pointName + "=" + pointsStr;
-    }
-
-    @Override
-    public void fillResponseFromJson(MatrixResponse matrixResponse, String responseAsString) throws IOException {
-        fillResponseFromJson(matrixResponse, objectMapper.reader().readTree(responseAsString));
-    }
-
-    @Override
-    protected void fillResponseFromJson(MatrixResponse matrixResponse, JsonNode responseJson) {
-        String status = responseJson.get("status").asText();
-        if ("OK".equals(status)) {
-            if (!responseJson.has("rows")) {
-                matrixResponse.addError(new RuntimeException("No 'rows' entry found in Google Matrix response. status:OK"));
-                return;
-            }
-
-            JsonNode rows = responseJson.get("rows");
-            int fromCount = rows.size();
-
-            for (int fromIndex = 0; fromIndex < fromCount; fromIndex++) {
-                JsonNode elementsObj = rows.get(fromIndex);
-                JsonNode elements = elementsObj.get("elements");
-                int toCount = elements.size();
-                long[] times = new long[toCount];
-                int[] distances = new int[toCount];
-
-                for (int toIndex = 0; toIndex < toCount; toIndex++) {
-                    JsonNode element = elements.get(toIndex);
-
-                    if ("OK".equals(element.get("status").asText())) {
-                        JsonNode distance = element.get("distance");
-                        JsonNode duration = element.get("duration");
-
-                        times[toIndex] = duration.get("value").asLong() * 1000;
-                        distances[toIndex] = Math.round(distance.get("value").asLong());
-                    } else {
-                        matrixResponse.addError(new IllegalArgumentException("Cannot find route " + fromIndex + "->" + toIndex));
-                    }
-                }
-
-                matrixResponse.setTimeRow(fromIndex, times);
-                matrixResponse.setDistanceRow(fromIndex, distances);
-            }
-        } else if (responseJson.has("error_message")) {
-            matrixResponse.addError(new RuntimeException(responseJson.get("error_message").asText()));
-        } else {
-            matrixResponse.addError(new RuntimeException("Something went wrong with Google Matrix response. status:" + status));
-        }
-    }
-}
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java
index a72432c580..85117966e2 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperMatrixWeb.java
@@ -41,6 +41,7 @@ public MatrixResponse route(GHMRequest request) {
             request.getHints().put(KEY, key);
         }
 
+        request.compactPointHints();
         return requester.route(request);
     }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index 7253f480d9..cd2f8fb64b 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.api;
 
-import com.fasterxml.jackson.core.type.TypeReference;
 import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.GHRequest;
@@ -26,15 +25,17 @@
 import com.graphhopper.PathWrapper;
 import com.graphhopper.http.WebHelper;
 import com.graphhopper.jackson.Jackson;
-import com.graphhopper.util.*;
-import com.graphhopper.util.details.PathDetail;
-import com.graphhopper.util.exceptions.*;
+import com.graphhopper.jackson.PathWrapperDeserializer;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
 import com.graphhopper.util.shapes.GHPoint;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
 
-import java.util.*;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 import static com.graphhopper.util.Helper.round6;
@@ -103,197 +104,6 @@ public OkHttpClient getDownloader() {
         return downloader;
     }
 
-    PathWrapper createPathWrapper(JsonNode path, boolean tmpElevation, boolean turnDescription) {
-        PathWrapper pathWrapper = new PathWrapper();
-        pathWrapper.addErrors(readErrors(path));
-        if (pathWrapper.hasErrors())
-            return pathWrapper;
-
-        if (path.has("snapped_waypoints")) {
-            String snappedPointStr = path.get("snapped_waypoints").asText();
-            PointList snappedPoints = WebHelper.decodePolyline(snappedPointStr, 5, tmpElevation);
-            pathWrapper.setWaypoints(snappedPoints);
-        }
-
-        if (path.has("ascend")) {
-            pathWrapper.setAscend(path.get("ascend").asDouble());
-        }
-        if (path.has("descend")) {
-            pathWrapper.setDescend(path.get("descend").asDouble());
-        }
-        if (path.has("weight")) {
-            pathWrapper.setRouteWeight(path.get("weight").asDouble());
-        }
-        if (path.has("description")) {
-            JsonNode descriptionNode = path.get("description");
-            if (descriptionNode.isArray()) {
-                List<String> description = new ArrayList<>(descriptionNode.size());
-                for (JsonNode descNode : descriptionNode) {
-                    description.add(descNode.asText());
-                }
-                pathWrapper.setDescription(description);
-            } else {
-                throw new IllegalStateException("Description has to be an array");
-            }
-        }
-
-        if (path.has("points")) {
-            String pointStr = path.get("points").asText();
-            PointList pointList = WebHelper.decodePolyline(pointStr, 100, tmpElevation);
-            pathWrapper.setPoints(pointList);
-
-            if (path.has("instructions")) {
-                JsonNode instrArr = path.get("instructions");
-
-                InstructionList il = new InstructionList(null);
-                int viaCount = 1;
-                for (JsonNode jsonObj : instrArr) {
-                    double instDist = jsonObj.get("distance").asDouble();
-                    String text = turnDescription ? jsonObj.get("text").asText() : jsonObj.get("street_name").asText();
-                    long instTime = jsonObj.get("time").asLong();
-                    int sign = jsonObj.get("sign").asInt();
-                    JsonNode iv = jsonObj.get("interval");
-                    int from = iv.get(0).asInt();
-                    int to = iv.get(1).asInt();
-                    PointList instPL = new PointList(to - from, tmpElevation);
-                    for (int j = from; j <= to; j++) {
-                        instPL.add(pointList, j);
-                    }
-
-                    InstructionAnnotation ia = InstructionAnnotation.EMPTY;
-                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text")) {
-                        ia = new InstructionAnnotation(jsonObj.get("annotation_importance").asInt(), jsonObj.get("annotation_text").asText());
-                    }
-
-                    Instruction instr;
-                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT) {
-                        RoundaboutInstruction ri = new RoundaboutInstruction(sign, text, ia, instPL);
-
-                        if (jsonObj.has("exit_number")) {
-                            ri.setExitNumber(jsonObj.get("exit_number").asInt());
-                        }
-
-                        if (jsonObj.has("exited")) {
-                            if (jsonObj.get("exited").asBoolean())
-                                ri.setExited();
-                        }
-
-                        if (jsonObj.has("turn_angle")) {
-                            // TODO provide setTurnAngle setter
-                            double angle = jsonObj.get("turn_angle").asDouble();
-                            ri.setDirOfRotation(angle);
-                            ri.setRadian((angle < 0 ? -Math.PI : Math.PI) - angle);
-                        }
-
-                        instr = ri;
-                    } else if (sign == Instruction.REACHED_VIA) {
-                        ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
-                        tmpInstr.setViaCount(viaCount);
-                        viaCount++;
-                        instr = tmpInstr;
-                    } else if (sign == Instruction.FINISH) {
-                        instr = new FinishInstruction(text, instPL, 0);
-                    } else {
-                        instr = new Instruction(sign, text, ia, instPL);
-                        if (sign == Instruction.CONTINUE_ON_STREET) {
-                            if (jsonObj.has("heading")) {
-                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
-                            }
-                        }
-                    }
-
-                    // Usually, the translation is done from the routing service so just use the provided string
-                    // instead of creating a combination with sign and name etc.
-                    // This is called the turn description.
-                    // This can be changed by passing <code>turn_description=false</code>.
-                    if (turnDescription)
-                        instr.setUseRawName();
-
-                    instr.setDistance(instDist).setTime(instTime);
-                    il.add(instr);
-                }
-                pathWrapper.setInstructions(il);
-            }
-
-            if (path.has("details")) {
-                JsonNode details = path.get("details");
-                Map<String, List<PathDetail>> pathDetails = new HashMap<>(details.size());
-                Iterator<Map.Entry<String, JsonNode>> detailIterator = details.fields();
-                while (detailIterator.hasNext()) {
-                    Map.Entry<String, JsonNode> detailEntry = detailIterator.next();
-                    List<PathDetail> pathDetailList = new ArrayList<>();
-                    for (JsonNode pathDetail : detailEntry.getValue()) {
-                        PathDetail pd = objectMapper.convertValue(pathDetail, PathDetail.class);
-                        pathDetailList.add(pd);
-                    }
-                    pathDetails.put(detailEntry.getKey(), pathDetailList);
-                }
-                pathWrapper.addPathDetails(pathDetails);
-            }
-        }
-
-        double distance = path.get("distance").asDouble();
-        long time = path.get("time").asLong();
-        pathWrapper.setDistance(distance).setTime(time);
-        return pathWrapper;
-    }
-
-    // Credits to: http://stackoverflow.com/a/24012023/194609
-    private Map<String, Object> toMap(JsonNode object) {
-        return objectMapper.convertValue(object, new TypeReference<Map<String, Object>>() {
-        });
-    }
-
-    public List<Throwable> readErrors(JsonNode json) {
-        List<Throwable> errors = new ArrayList<>();
-        JsonNode errorJson;
-
-        if (json.has("message")) {
-            if (json.has("hints")) {
-                errorJson = json.get("hints");
-            } else {
-                // should not happen
-                errors.add(new RuntimeException(json.get("message").asText()));
-                return errors;
-            }
-        } else
-            return errors;
-
-        for (JsonNode error : errorJson) {
-            String exClass = "";
-            if (error.has("details"))
-                exClass = error.get("details").asText();
-
-            String exMessage = error.get("message").asText();
-
-            if (exClass.equals(UnsupportedOperationException.class.getName()))
-                errors.add(new UnsupportedOperationException(exMessage));
-            else if (exClass.equals(IllegalStateException.class.getName()))
-                errors.add(new IllegalStateException(exMessage));
-            else if (exClass.equals(RuntimeException.class.getName()))
-                errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
-            else if (exClass.equals(IllegalArgumentException.class.getName()))
-                errors.add(new DetailedIllegalArgumentException(exMessage, toMap(error)));
-            else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
-                errors.add(new ConnectionNotFoundException(exMessage, toMap(error)));
-            } else if (exClass.equals(PointNotFoundException.class.getName())) {
-                int pointIndex = error.get("point_index").asInt();
-                errors.add(new PointNotFoundException(exMessage, pointIndex));
-            } else if (exClass.equals(PointOutOfBoundsException.class.getName())) {
-                int pointIndex = error.get("point_index").asInt();
-                errors.add(new PointOutOfBoundsException(exMessage, pointIndex));
-            } else if (exClass.isEmpty())
-                errors.add(new DetailedRuntimeException(exMessage, toMap(error)));
-            else
-                errors.add(new DetailedRuntimeException(exClass + " " + exMessage, toMap(error)));
-        }
-
-        if (json.has("message") && errors.isEmpty())
-            errors.add(new RuntimeException(json.get("message").asText()));
-
-        return errors;
-    }
-
     @Override
     public boolean load(String serviceUrl) {
         this.routeServiceUrl = serviceUrl;
@@ -351,14 +161,14 @@ public GraphHopperWeb setOptimize(String optimize) {
 
     @Override
     public GHResponse route(GHRequest request) {
+        ResponseBody rspBody = null;
         try {
             Request okRequest = createRequest(request);
-            ResponseBody rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
+            rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
             JsonNode json = objectMapper.reader().readTree(rspBody.byteStream());
-            rspBody.close();
 
             GHResponse res = new GHResponse();
-            res.addErrors(readErrors(json));
+            res.addErrors(PathWrapperDeserializer.readErrors(objectMapper, json));
             if (res.hasErrors())
                 return res;
 
@@ -368,7 +178,7 @@ public GHResponse route(GHRequest request) {
             boolean tmpTurnDescription = request.getHints().getBool("turn_description", true);
 
             for (JsonNode path : paths) {
-                PathWrapper altRsp = createPathWrapper(path, tmpElevation, tmpTurnDescription);
+                PathWrapper altRsp = PathWrapperDeserializer.createPathWrapper(objectMapper, path, tmpElevation, tmpTurnDescription);
                 res.add(altRsp);
             }
 
@@ -376,6 +186,8 @@ public GHResponse route(GHRequest request) {
 
         } catch (Exception ex) {
             throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
+        } finally {
+            Helper.close(rspBody);
         }
     }
 
@@ -428,11 +240,21 @@ private Request createRequest(GHRequest request) {
         }
 
         for (String details : request.getPathDetails()) {
-            url += "&" + Parameters.DETAILS.PATH_DETAILS + "=" + details;
+            url += "&" + Parameters.Details.PATH_DETAILS + "=" + details;
+        }
+
+        // append *all* point hints only if at least *one* is not empty
+        for (String checkEmptyHint : request.getPointHints()) {
+            if (!checkEmptyHint.isEmpty()) {
+                for (String hint : request.getPointHints()) {
+                    url += "&" + Parameters.Routing.POINT_HINT + "=" + WebHelper.encodeURL(hint);
+                }
+                break;
+            }
         }
 
-        for (String hint : request.getPointHints()) {
-            url += "&point_hint=" + WebHelper.encodeURL(hint);
+        for (String snapPrevention : request.getSnapPreventions()) {
+            url += "&" + Parameters.Routing.SNAP_PREVENTION + "=" + WebHelper.encodeURL(snapPrevention);
         }
 
         if (!key.isEmpty()) {
diff --git a/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java b/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
index c2ed446885..1e079fca4b 100644
--- a/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
+++ b/client-hc/src/main/java/com/graphhopper/api/MatrixResponse.java
@@ -3,6 +3,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
+import java.util.Objects;
 
 /**
  * This class defines the response for a M-to-N requests.
@@ -13,6 +14,9 @@
 
     private String debugInfo = "";
     private final List<Throwable> errors = new ArrayList<>(4);
+    private final List<PointPair> disconnectedPoints = new ArrayList<>(0);
+    private final List<Integer> invalidFromPoints = new ArrayList<>(0);
+    private final List<Integer> invalidToPoints = new ArrayList<>(0);
     private long[][] times = new long[0][];
     private int[][] distances = new int[0][];
     private double[][] weights = new double[0][];
@@ -45,7 +49,7 @@ public MatrixResponse(int fromCap, int toCap, boolean withTimes, boolean withDis
             throw new IllegalArgumentException("Please specify times, distances or weights that should be calculated by the matrix");
     }
 
-    public void setFromRow(int row, long timeRow[], int distanceRow[], double weightRow[]) {
+    public void setFromRow(int row, long[] timeRow, int[] distanceRow, double[] weightRow) {
         if (times.length > 0) {
             check(timeRow.length, toCount, "to times");
             times[row] = timeRow;
@@ -68,7 +72,7 @@ private void check(int currentLength, int expectedLength, String times) {
                     "Expected " + expectedLength + " was: " + currentLength + ". Matrix: " + fromCount + "x" + toCount);
     }
 
-    public void setTimeRow(int row, long timeRow[]) {
+    public void setTimeRow(int row, long[] timeRow) {
         if (times.length > 0) {
             check(timeRow.length, toCount, "to times");
             times[row] = timeRow;
@@ -77,7 +81,7 @@ public void setTimeRow(int row, long timeRow[]) {
         }
     }
 
-    public void setDistanceRow(int row, int distanceRow[]) {
+    public void setDistanceRow(int row, int[] distanceRow) {
         if (distances.length > 0) {
             check(distanceRow.length, toCount, "to distances");
             distances[row] = distanceRow;
@@ -86,7 +90,7 @@ public void setDistanceRow(int row, int distanceRow[]) {
         }
     }
 
-    public void setWeightRow(int row, double weightRow[]) {
+    public void setWeightRow(int row, double[] weightRow) {
         if (weights.length > 0) {
             check(weightRow.length, toCount, "to weights");
             weights[row] = weightRow;
@@ -95,12 +99,20 @@ public void setWeightRow(int row, double weightRow[]) {
         }
     }
 
+    public boolean isConnected(int from, int to) {
+        if (hasErrors()) {
+            return false;
+        }
+        return getWeight(from, to) < Double.MAX_VALUE;
+    }
+
     /**
-     * Returns the time for the specific entry (from -&gt; to) in milliseconds.
+     * Returns the time for the specific entry (from -&gt; to) in milliseconds or {@link Long#MAX_VALUE} in case
+     * no connection was found (and {@link GHMRequest#setFailFast(boolean)} was set to true).
      */
     public long getTime(int from, int to) {
         if (hasErrors()) {
-            throw new IllegalStateException("Cannot return time (" + from + "," + to + ") if errors occured " + getErrors());
+            throw new IllegalStateException("Cannot return time (" + from + "," + to + ") if errors occurred " + getErrors());
         }
 
         if (from >= times.length) {
@@ -112,7 +124,8 @@ public long getTime(int from, int to) {
     }
 
     /**
-     * Returns the distance for the specific entry (from -&gt; to) in meter.
+     * Returns the distance for the specific entry (from -&gt; to) in meter or {@link Double#MAX_VALUE} in case
+     * no connection was found (and {@link GHMRequest#setFailFast(boolean)} was set to true).
      */
     public double getDistance(int from, int to) {
         if (hasErrors()) {
@@ -124,12 +137,13 @@ public double getDistance(int from, int to) {
         } else if (to >= distances[from].length) {
             throw new IllegalStateException("Cannot get 'to' " + to + " from distances with size " + distances[from].length);
         }
-        return distances[from][to];
+        return distances[from][to] == Integer.MAX_VALUE ? Double.MAX_VALUE : distances[from][to];
     }
 
     /**
-     * Returns the weight for the specific entry (from -&gt; to) in arbitrary units
-     * ('costs').
+     * Returns the weight for the specific entry (from -&gt; to) in arbitrary units ('costs'), or
+     * {@link Double#MAX_VALUE} in case no connection was found (and {@link GHMRequest#setFailFast(boolean)} was set
+     * to true).
      */
     public double getWeight(int from, int to) {
         if (hasErrors()) {
@@ -176,6 +190,44 @@ public MatrixResponse addErrors(Collection<Throwable> errorList) {
         return this;
     }
 
+    /**
+     * @return true if there are invalid or disconnected points (which both do not yield an error in case we do not fail fast).
+     * @see GHMRequest#setFailFast(boolean)
+     */
+    public boolean hasProblems() {
+        return !disconnectedPoints.isEmpty() || !invalidFromPoints.isEmpty() || !invalidToPoints.isEmpty();
+    }
+
+    public MatrixResponse setDisconnectedPoints(List<PointPair> disconnectedPoints) {
+        this.disconnectedPoints.clear();
+        this.disconnectedPoints.addAll(disconnectedPoints);
+        return this;
+    }
+
+    public List<PointPair> getDisconnectedPoints() {
+        return disconnectedPoints;
+    }
+
+    public MatrixResponse setInvalidFromPoints(List<Integer> invalidFromPoints) {
+        this.invalidFromPoints.clear();
+        this.invalidFromPoints.addAll(invalidFromPoints);
+        return this;
+    }
+
+    public MatrixResponse setInvalidToPoints(List<Integer> invalidToPoints) {
+        this.invalidToPoints.clear();
+        this.invalidToPoints.addAll(invalidToPoints);
+        return this;
+    }
+
+    public List<Integer> getInvalidFromPoints() {
+        return invalidFromPoints;
+    }
+
+    public List<Integer> getInvalidToPoints() {
+        return invalidToPoints;
+    }
+
     @Override
     public String toString() {
         String addInfo = "";
@@ -188,6 +240,45 @@ public String toString() {
             addInfo += ", distances: " + distances.length + "x" + distances[0].length;
         }
 
-        return "[" + addInfo + "] errors:" + errors.toString();
+        String result = "[" + addInfo + "] errors:" + errors.toString();
+        if (!disconnectedPoints.isEmpty()) {
+            result += ", disconnectedPoints: " + disconnectedPoints.size();
+        }
+        if (!invalidFromPoints.isEmpty()) {
+            result += ", invalidFromPoints: " + invalidFromPoints.size();
+        }
+        if (!invalidToPoints.isEmpty()) {
+            result += ", invalidToPoints: " + invalidToPoints.size();
+        }
+        return result;
+    }
+
+    public static class PointPair {
+        public final int sourceIndex;
+        public final int targetIndex;
+
+        public PointPair(int sourceIndex, int targetIndex) {
+            this.sourceIndex = sourceIndex;
+            this.targetIndex = targetIndex;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            PointPair pointPair = (PointPair) o;
+            return sourceIndex == pointPair.sourceIndex &&
+                    targetIndex == pointPair.targetIndex;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(sourceIndex, targetIndex);
+        }
+
+        @Override
+        public String toString() {
+            return "[" + sourceIndex + ", " + targetIndex + "]";
+        }
     }
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java
index c232e99673..7a80c34ac8 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGHMatrixWebTester.java
@@ -8,6 +8,7 @@
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.Reader;
+import java.util.Collections;
 
 import static org.junit.Assert.*;
 
@@ -54,11 +55,96 @@ public void testReadingWeights() throws IOException {
 
         try {
             assertEquals(0., rsp.getDistance(0, 1), .1);
-            assertTrue(false);
+            fail("there should have been an exception");
         } catch (Exception ex) {
         }
     }
 
+    @Test
+    public void testReadingMatrixConnectionsNotFound_noFailFast() throws IOException {
+        String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("matrix-connection-not-found-fail-fast.json")));
+        GraphHopperMatrixWeb matrixWeb = createMatrixClient(ghMatrix);
+
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(0, 1));
+        req.addPoint(new GHPoint(2, 3));
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        req.setFailFast(false);
+
+        MatrixResponse rsp = matrixWeb.route(req);
+        assertFalse(rsp.hasErrors());
+        assertTrue(rsp.hasProblems());
+
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(0, 1), 1.e-3);
+        assertEquals(0, rsp.getWeight(0, 0), 1.e-3);
+
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(0, 1), 1.e-3);
+        assertEquals(1, rsp.getDistance(0, 0), 1.e-3);
+
+        assertEquals(Long.MAX_VALUE, rsp.getTime(0, 1));
+        assertEquals(2 * 1000, rsp.getTime(0, 0));
+
+        assertEquals("[[0, 1], [1, 0]]", rsp.getDisconnectedPoints().toString());
+    }
+
+    @Test
+    public void testReadingMatrixPointsNotFound_noFailFast() throws IOException {
+        String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("matrix-point-not-found-fail-fast.json")));
+        GraphHopperMatrixWeb matrixWeb = createMatrixClient(ghMatrix);
+
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(0, 1));
+        req.addPoint(new GHPoint(2, 3));
+        req.addPoint(new GHPoint(4, 5));
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        req.setFailFast(false);
+
+        MatrixResponse rsp = matrixWeb.route(req);
+        assertFalse(rsp.hasErrors());
+        assertTrue(rsp.hasProblems());
+
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(1, 0), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(1, 1), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(1, 2), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(0, 1), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getWeight(2, 1), 1.e-3);
+
+        assertEquals(0, rsp.getWeight(0, 0), 1.e-3);
+        assertEquals(1, rsp.getWeight(0, 2), 1.e-3);
+        assertEquals(2, rsp.getWeight(2, 0), 1.e-3);
+        assertEquals(3, rsp.getWeight(2, 2), 1.e-3);
+
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(1, 0), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(1, 1), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(1, 2), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(0, 1), 1.e-3);
+        assertEquals(Double.MAX_VALUE, rsp.getDistance(2, 1), 1.e-3);
+
+        assertEquals(4, rsp.getDistance(0, 0), 1.e-3);
+        assertEquals(5, rsp.getDistance(0, 2), 1.e-3);
+        assertEquals(6, rsp.getDistance(2, 0), 1.e-3);
+        assertEquals(7, rsp.getDistance(2, 2), 1.e-3);
+
+        assertEquals(Long.MAX_VALUE, rsp.getTime(1, 0));
+        assertEquals(Long.MAX_VALUE, rsp.getTime(1, 1));
+        assertEquals(Long.MAX_VALUE, rsp.getTime(1, 2));
+        assertEquals(Long.MAX_VALUE, rsp.getTime(0, 1));
+        assertEquals(Long.MAX_VALUE, rsp.getTime(2, 1));
+
+        assertEquals(8 * 1000, rsp.getTime(0, 0));
+        assertEquals(9 * 1000, rsp.getTime(0, 2));
+        assertEquals(10 * 1000, rsp.getTime(2, 0));
+        assertEquals(11 * 1000, rsp.getTime(2, 2));
+
+        assertEquals("[[0, 1], [1, 0], [1, 1], [1, 2], [2, 1]]", rsp.getDisconnectedPoints().toString());
+        assertEquals(Collections.singletonList(1), rsp.getInvalidFromPoints());
+        assertEquals(Collections.singletonList(1), rsp.getInvalidToPoints());
+    }
+
     @Test
     public void testReadingGoogleThrowsException() throws IOException {
         String ghMatrix = readFile(new InputStreamReader(getClass().getResourceAsStream("google-matrix1.json")));
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index 3f8de6f3ea..b88526ff85 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -6,9 +6,7 @@
 
 import java.util.Arrays;
 
-import static com.graphhopper.api.GraphHopperMatrixWeb.SERVICE_URL;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
@@ -34,12 +32,12 @@ public void testMatrix() {
         // no distances available
         try {
             assertEquals(0, res.getDistance(1, 2), 1);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
         }
 
         // ... only weight:
-        assertEquals(1690, res.getWeight(1, 2), 10);
+        assertEquals(1840, res.getWeight(1, 2), 10);
 
         req = AbstractGHMatrixWebTester.createRequest();
         req.addOutArray("weights");
@@ -47,7 +45,7 @@ public void testMatrix() {
         res = ghMatrix.route(req);
 
         assertEquals(9800, res.getDistance(1, 2), 50);
-        assertEquals(1695, res.getWeight(1, 2), 10);
+        assertEquals(1840, res.getWeight(1, 2), 10);
     }
 
     @Test
@@ -62,6 +60,7 @@ public void testBikeMatrix() {
 
     @Test
     public void testNxM_issue45() {
+        // https://github.com/graphhopper/directions-api-java-client/issues/45
         GHMRequest ghmRequest = new GHMRequest();
         ghmRequest.addOutArray("distances");
         ghmRequest.addOutArray("times");
@@ -70,7 +69,7 @@ public void testNxM_issue45() {
                 .setToPoints(Arrays.asList(new GHPoint(52.557151, 13.515244), new GHPoint(52.454545, 13.295517)));
 
         MatrixResponse res = ghMatrix.route(ghmRequest);
-        assertEquals(2437, res.getTime(0, 1) / 1000, 30);
+        assertEquals(2480, res.getTime(0, 1) / 1000, 30);
     }
 
     @Test
@@ -104,4 +103,173 @@ public void testPOSTMatrixQueryWithPointHints() {
         assertTrue(res.hasErrors());
         assertEquals("Array length of point_hints must match length of points (or from/to equivalent)", res.getErrors().get(0).getMessage());
     }
+
+    @Test
+    public void testConnectionNotFound() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(-7.126486, -34.833741));
+        req.addPoint(new GHPoint(9.657616, -13.565369));
+        req.addPoint(new GHPoint(18.928696, -70.400047));
+        req.addPoint(new GHPoint(-7.323564, -35.32774));
+
+        MatrixResponse matrix = ghMatrix.route(req);
+        assertTrue(matrix.hasErrors());
+        assertEquals(1, matrix.getErrors().size());
+        assertTrue(matrix.getErrors().get(0).getMessage().contains("0->1"));
+        assertFalse(matrix.isConnected(0, 1));
+        try {
+            matrix.getWeight(0, 1);
+            fail("getWeight should throw an exception if errors were found");
+        } catch (Exception e) {
+            // ok
+        }
+    }
+
+    @Test
+    public void testConnectionNotFound_doNotFailFast() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(-7.126486, -34.833741));
+        req.addPoint(new GHPoint(9.657616, -13.565369));
+        req.addPoint(new GHPoint(18.928696, -70.400047));
+        req.addPoint(new GHPoint(-7.323564, -35.32774));
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        req.setFailFast(false);
+
+        MatrixResponse matrix = ghMatrix.route(req);
+
+        // if fail_fast is false we do not consider disconnected points to be errors and instead we expect the full
+        // matrix to be returned where disconnected points yield weight = Double.MAX_VALUE
+        assertFalse(matrix.hasErrors());
+        assertTrue(matrix.hasProblems());
+        for (int i = 0; i < 4; i++) {
+            for (int j = 0; j < 4; j++) {
+                double weight = matrix.getWeight(i, j);
+                double distance = matrix.getDistance(i, j);
+                long time = matrix.getTime(i, j);
+                boolean connected = matrix.isConnected(i, j);
+                if (i == j) {
+                    assertTrue(connected);
+                    assertEquals(0, weight, 1.e-3);
+                    assertEquals(0, distance, 1.e-3);
+                    assertEquals(0, time);
+                } else if (i == 0 && j == 3) {
+                    assertTrue(connected);
+                    assertEquals(4931, weight, 100);
+                    assertEquals(78643, distance, 100);
+                    assertEquals(3752000, time, 100000);
+                } else if (i == 3 && j == 0) {
+                    assertTrue(connected);
+                    assertEquals(4745, weight, 100);
+                    assertEquals(75480, distance, 100);
+                    assertEquals(3613000, time, 100000);
+                } else {
+                    assertFalse(connected);
+                    assertEquals("expected maximum weight for matrix element (" + i + ", " + j + "), but was: " + weight, Double.MAX_VALUE, weight, 1.e-3);
+                    assertEquals("expected maximum distance for matrix element (" + i + ", " + j + "), but was: " + distance, Double.MAX_VALUE, weight, 1.e-3);
+                    assertEquals("expected maximum time for matrix element (" + i + ", " + j + "), but was: " + time, Long.MAX_VALUE, time);
+                }
+            }
+        }
+        assertEquals(10, matrix.getDisconnectedPoints().size());
+        assertEquals("[[0, 1], [0, 2], [1, 0], [1, 2], [1, 3], [2, 0], [2, 1], [2, 3], [3, 1], [3, 2]]", matrix.getDisconnectedPoints().toString());
+    }
+
+    @Test
+    public void testPointsNotFound() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(42.506021, 1.643829));
+        req.addPoint(new GHPoint(42.541382, 1.516349));
+        req.addPoint(new GHPoint(42.497289, 1.762276));
+        req.addPoint(new GHPoint(42.566293, 1.597867));
+
+        MatrixResponse matrix = ghMatrix.route(req);
+        assertTrue(matrix.hasErrors());
+        assertEquals(2, matrix.getErrors().size());
+        assertTrue(matrix.getErrors().get(0).getMessage().contains("Cannot find from_points: 0, 2"));
+        assertTrue(matrix.getErrors().get(1).getMessage().contains("Cannot find to_points: 0, 2"));
+        assertFalse(matrix.isConnected(0, 1));
+        try {
+            matrix.getWeight(0, 1);
+            fail("getWeight should throw an exception if errors were found");
+        } catch (Exception e) {
+            // ok
+        }
+    }
+
+    @Test
+    public void testPointsNotFound_doNotFailFast() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(42.506021, 1.643829));
+        req.addPoint(new GHPoint(42.541382, 1.516349));
+        req.addPoint(new GHPoint(42.497289, 1.762276));
+        req.addPoint(new GHPoint(42.566293, 1.597867));
+        req.addOutArray("weights");
+        req.addOutArray("distances");
+        req.addOutArray("times");
+        req.setFailFast(false);
+
+        MatrixResponse matrix = ghMatrix.route(req);
+        assertFalse(matrix.hasErrors());
+        assertTrue(matrix.hasProblems());
+        assertEquals(0, matrix.getErrors().size());
+        assertEquals(Arrays.asList(0, 2), matrix.getInvalidFromPoints());
+        assertEquals(Arrays.asList(0, 2), matrix.getInvalidToPoints());
+        assertEquals("[[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 2], [2, 0], [2, 1], [2, 2], [2, 3], [3, 0], [3, 2]]",
+                matrix.getDisconnectedPoints().toString());
+        for (int i = 0; i < 4; i++) {
+            for (int j = 0; j < 4; j++) {
+                double weight = matrix.getWeight(i, j);
+                double distance = matrix.getDistance(i, j);
+                long time = matrix.getTime(i, j);
+                boolean connected = matrix.isConnected(i, j);
+                if (i == 1 && j == 1 || i == 3 && j == 3) {
+                    assertEquals(0, weight, 1.e-3);
+                    assertEquals(0, distance, 1.e-3);
+                    assertEquals(0, time);
+                    assertTrue(connected);
+                } else if (i == 1 && j == 3) {
+                    assertEquals(1087, weight, 10);
+                    assertEquals(13926, distance, 100);
+                    assertEquals(878000, time, 10000);
+                    assertTrue(connected);
+                } else if (i == 3 && j == 1) {
+                    assertEquals(1083, weight, 10);
+                    assertEquals(13856, distance, 100);
+                    assertEquals(875000, time, 1000);
+                    assertTrue(connected);
+                } else {
+                    assertEquals(Double.MAX_VALUE, weight, 1.e-3);
+                    assertEquals(Double.MAX_VALUE, distance, 1.e-3);
+                    assertEquals(Long.MAX_VALUE, time);
+                    assertFalse(connected);
+                }
+            }
+        }
+    }
+
+    @Test
+    public void testPointsNotFound_doNotFailFast_noPointsFound() {
+        GHMRequest req = new GHMRequest();
+        req.addPoint(new GHPoint(42.506021, 1.643829));
+        req.addPoint(new GHPoint(42.497289, 1.762276));
+        req.setFailFast(false);
+
+        MatrixResponse matrix = ghMatrix.route(req);
+        assertFalse(matrix.hasErrors());
+        assertTrue(matrix.hasProblems());
+        assertEquals(0, matrix.getErrors().size());
+        assertEquals(Arrays.asList(0, 1), matrix.getInvalidFromPoints());
+        assertEquals(Arrays.asList(0, 1), matrix.getInvalidToPoints());
+        assertEquals("[[0, 0], [0, 1], [1, 0], [1, 1]]", matrix.getDisconnectedPoints().toString());
+        for (int i = 0; i < 2; i++) {
+            for (int j = 0; j < 2; j++) {
+                double weight = matrix.getWeight(i, j);
+                assertFalse(matrix.isConnected(i, j));
+                assertEquals(Double.MAX_VALUE, weight, 1.e-3);
+            }
+        }
+    }
+
 }
diff --git a/client-hc/src/test/java/com/graphhopper/api/GHMRequestTest.java b/client-hc/src/test/java/com/graphhopper/api/GHMRequestTest.java
new file mode 100644
index 0000000000..b993c9d697
--- /dev/null
+++ b/client-hc/src/test/java/com/graphhopper/api/GHMRequestTest.java
@@ -0,0 +1,41 @@
+package com.graphhopper.api;
+
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Test;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertFalse;
+
+public class GHMRequestTest {
+    @Test
+    public void testCompact() {
+        GHMRequest request = new GHMRequest();
+        for (int i = 0; i < 3; i++) {
+            request.addFromPoint(new GHPoint());
+            request.addFromPointHint("");
+        }
+
+        request.addToPoint(new GHPoint());
+        request.addToPointHint("");
+
+        request.compactPointHints();
+        assertTrue(request.getToPointHints().isEmpty());
+        assertTrue(request.getFromPointHints().isEmpty());
+    }
+
+    @Test
+    public void testCompact2() {
+        GHMRequest request = new GHMRequest();
+        for (int i = 0; i < 3; i++) {
+            request.addFromPoint(new GHPoint());
+            request.addFromPointHint("");
+        }
+
+        request.addToPoint(new GHPoint());
+        request.addToPointHint("x");
+
+        request.compactPointHints();
+        assertFalse(request.getToPointHints().isEmpty());
+        assertTrue(request.getFromPointHints().isEmpty());
+    }
+}
\ No newline at end of file
diff --git a/client-hc/src/test/java/com/graphhopper/api/GoogleMatrixSyncRequesterTest.java b/client-hc/src/test/java/com/graphhopper/api/GoogleMatrixSyncRequesterTest.java
deleted file mode 100644
index 3c39c75d72..0000000000
--- a/client-hc/src/test/java/com/graphhopper/api/GoogleMatrixSyncRequesterTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-package com.graphhopper.api;
-
-import com.fasterxml.jackson.databind.JsonNode;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.graphhopper.util.shapes.GHPoint;
-import org.junit.Test;
-
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-import static com.graphhopper.api.AbstractGHMatrixWebTester.createRequest;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-/**
- * @author Peter Karich
- */
-public class GoogleMatrixSyncRequesterTest {
-    final ObjectMapper objectMapper = new ObjectMapper();
-
-    GraphHopperMatrixWeb createMatrixClient(String jsonStr) throws IOException {
-        JsonNode json = objectMapper.readTree(jsonStr);
-        final String finalJsonStr = json.toString();
-        return new GraphHopperMatrixWeb(new GoogleMatrixSyncRequester("") {
-
-            @Override
-            protected String postJson(String url, JsonNode data) throws IOException {
-                return "{\"job_id\": \"1\"}";
-            }
-
-            @Override
-            protected String getJson(String url) throws IOException {
-                return finalJsonStr;
-            }
-        });
-    }
-
-    @Test
-    public void testMatrix() throws IOException {
-        GHMRequest req = new GHMRequest();
-        req.addFromPoint(new GHPoint(51.534377, -0.087891));
-        req.addFromPoint(new GHPoint(51.467697, -0.090637));
-
-        req.addToPoint(new GHPoint(51.521241, -0.171833));
-        req.addToPoint(new GHPoint(51.467697, -0.090637));
-        req.addToPoint(new GHPoint(51.534377, -0.087891));
-
-        GraphHopperMatrixWeb matrix = createMatrixClient(AbstractGHMatrixWebTester.readFile(
-                new InputStreamReader(getClass().getResourceAsStream("google-matrix1.json"))));
-        MatrixResponse rsp = matrix.route(req);
-
-        assertEquals(712692, rsp.getDistance(0, 1), .1);
-        assertEquals(25995, rsp.getTime(0, 1) / 1000);
-
-        assertEquals(806813, rsp.getDistance(1, 2), .1);
-        assertEquals(28737, rsp.getTime(1, 2) / 1000);
-    }
-
-    @Test
-    public void testMatrixWithError() throws IOException {
-        GHMRequest req = createRequest();
-
-        GraphHopperMatrixWeb matrix = createMatrixClient(AbstractGHMatrixWebTester.readFile(
-                new InputStreamReader(getClass().getResourceAsStream("google-error1.json"))));
-        MatrixResponse rsp = matrix.route(req);
-        assertTrue(rsp.hasErrors());
-    }
-}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
index 1a9dc33afd..e9071606ee 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperGeocodingIT.java
@@ -35,19 +35,20 @@ public void testForwardGeocoding() {
 
     @Test
     public void testExtent() {
-        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest("new york", "en", 7));
+        GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest("seattle", "en", 7));
         BBox extent = response.getHits().get(0).getExtendBBox();
         assertTrue(extent.isValid());
-        assertTrue(extent.minLon < -79);
-        assertTrue(extent.maxLon > -72);
-        assertTrue(extent.minLat < 40.5);
-        assertTrue(extent.maxLat > 45);
+        assertTrue(extent.minLon > -123.00 && extent.minLon < -122.00);
+        assertTrue(extent.maxLon > -123.00 && extent.maxLon < -122.00);
+        assertTrue(extent.minLat > 47.00 && extent.minLat < 48.00);
+        assertTrue(extent.maxLat > 47.00 && extent.maxLat < 48.00);
     }
 
     @Test
     public void testForwardGeocodingNominatim() {
         GHGeocodingResponse response = geocoding.geocode(new GHGeocodingRequest(false, null, "Berlin", "en", 5, "nominatim", 5000));
-        assertEquals(5, response.getHits().size());
+        int size = response.getHits().size();
+        assertTrue("Unexpected response hit count " + size, size == 4 || size == 5);
         assertTrue(response.getHits().get(0).getName().contains("Berlin"));
     }
 
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
deleted file mode 100644
index 0b664d271a..0000000000
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperMatrixGoogleIT.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package com.graphhopper.api;
-
-import org.junit.Before;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * @author Peter Karich
- */
-public class GraphHopperMatrixGoogleIT {
-
-    private static String GOOGK = "AIzaSyD82yk4uSmNcruqtue1lFTyuWAtEiLiJbs";
-    protected GraphHopperMatrixWeb ghMatrix;
-
-    @Before
-    public void setUp() {
-        ghMatrix = createMatrixWeb();
-        String key = System.getProperty("google.key", GOOGK);
-        ghMatrix.setKey(key);
-    }
-
-    GraphHopperMatrixWeb createMatrixWeb() {
-        return new GraphHopperMatrixWeb(new GoogleMatrixSyncRequester("https://maps.googleapis.com/maps/api/distancematrix/json"));
-    }
-
-    @Test
-    public void testMatrix() {
-        GHMRequest req = AbstractGHMatrixWebTester.createRequest();
-        MatrixResponse res = ghMatrix.route(req);
-
-        assertEquals(11000, res.getDistance(1, 2), 2000);
-        assertEquals(2500, res.getTime(1, 2) / 1000, 1000);
-    }
-
-    @Test
-    public void testPOSTMatrixQueryWithPointHints() {
-        // for now ignore
-    }
-}
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index 82a9261c05..3f912aeb76 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -5,6 +5,8 @@
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
 import com.graphhopper.PathWrapper;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.jackson.PathWrapperDeserializer;
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.RoundaboutInstruction;
@@ -51,7 +53,7 @@ public void testSimpleRoute() {
         assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
         PathWrapper alt = res.getBest();
         isBetween(200, 250, alt.getPoints().size());
-        isBetween(11000, 12000, alt.getDistance());
+        isBetween(10500, 12000, alt.getDistance());
         isBetween(240, 270, alt.getAscend());
         isBetween(180, 200, alt.getDescend());
         isBetween(1000, 1500, alt.getRouteWeight());
@@ -62,6 +64,8 @@ public void testSimpleRoute() {
         alt = res.getBest();
         assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
         isBetween(9000, 9500, alt.getDistance());
+
+        assertEquals("[0, 1]", alt.getPointsOrder().toString());
     }
 
     @Test
@@ -79,15 +83,15 @@ public void testAlternativeRoute() {
         List<PathWrapper> paths = res.getAll();
         assertEquals(2, paths.size());
 
-        PathWrapper path = paths.get(0);
+        PathWrapper path = paths.get(1);
         isBetween(5, 20, path.getPoints().size());
         isBetween(1000, 1100, path.getDistance());
         assertTrue("expected: " + path.getDescription().get(0), Arrays.asList("Wiesenstraße", "Hasenspringweg").contains(path.getDescription().get(0)));
 
-        path = paths.get(1);
+        path = paths.get(0);
         isBetween(20, 30, path.getPoints().size());
         isBetween(800, 900, path.getDistance());
-        assertTrue("expected: " + path.getDescription().get(0), Arrays.asList("Jacobistraße", "Ludwig-Gercke-Straße").contains(path.getDescription().get(0)));
+        assertTrue("expected: " + path.getDescription().get(0), Arrays.asList("Jacobistraße", "Bismarckstraße", "Ludwig-Gercke-Straße", "Eichendorffplatz").contains(path.getDescription().get(0)));
     }
 
     @Test
@@ -119,7 +123,7 @@ public void testNoPoints() {
         assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
         PathWrapper alt = res.getBest();
         assertEquals(0, alt.getPoints().size());
-        isBetween(11000, 12000, alt.getDistance());
+        isBetween(10500, 12000, alt.getDistance());
     }
 
     @Test
@@ -235,27 +239,26 @@ public void testExportWithoutTrack() {
         assertTrue(res.endsWith("</gpx>"));
     }
 
-    @Test
-    public void testCreateGPXFromInstructionList() {
-        GHRequest req = new GHRequest().
-                addPoint(new GHPoint(49.6724, 11.3494)).
-                addPoint(new GHPoint(49.6550, 11.4180));
-        req.getHints().put("elevation", false);
-        req.getHints().put("instructions", true);
-        req.getHints().put("calc_points", true);
-        GHResponse ghResponse = gh.route(req);
-        String gpx = ghResponse.getBest().getInstructions().createGPX("wurst");
-        assertTrue(gpx.contains("<gpx"));
-        assertTrue(gpx.contains("<rtept lat="));
-        assertTrue(gpx.contains("<trk><name>"));
-        assertTrue(gpx.endsWith("</gpx>"));
-    }
-
     void isBetween(double from, double to, double expected) {
         assertTrue("expected value " + expected + " was smaller than limit " + from, expected >= from);
         assertTrue("expected value " + expected + " was bigger than limit " + to, expected <= to);
     }
 
+    @Test
+    public void testOptimize() {
+        // https://graphhopper.com/maps/?point=49.664184%2C11.345444&point=49.661072%2C11.384068&point=49.670628%2C11.352997&point=49.667128%2C11.404753
+        GHRequest req = new GHRequest().
+                addPoint(new GHPoint(49.664184, 11.345444)).
+                addPoint(new GHPoint(49.661072, 11.384068)).
+                addPoint(new GHPoint(49.670628, 11.352997)).
+                addPoint(new GHPoint(49.667128, 11.404753));
+        GHResponse res = gh.setOptimize("true").route(req);
+        assertFalse("errors:" + res.getErrors().toString(), res.hasErrors());
+        PathWrapper alt = res.getBest();
+        isBetween(850, 1050, alt.getRouteWeight());
+        assertEquals("[0, 2, 1, 3]", alt.getPointsOrder().toString());
+    }
+
     @Test
     public void testMatrix() {
         GHMRequest req = AbstractGHMatrixWebTester.createRequest();
@@ -264,12 +267,12 @@ public void testMatrix() {
         // no distances available
         try {
             assertEquals(0, res.getDistance(1, 2), 1);
-            assertTrue(false);
+            fail("there should be an exception when trying to get distances");
         } catch (Exception ex) {
         }
 
         // ... only weight:
-        assertEquals(1695, res.getWeight(1, 2), 5);
+        assertEquals(1840, res.getWeight(1, 2), 5);
 
         req = AbstractGHMatrixWebTester.createRequest();
         req.addOutArray("weights");
@@ -277,7 +280,7 @@ public void testMatrix() {
         res = ghMatrix.route(req);
 
         assertEquals(9834, res.getDistance(1, 2), 20);
-        assertEquals(1695, res.getWeight(1, 2), 10);
+        assertEquals(1840, res.getWeight(1, 2), 10);
     }
 
     @Test
@@ -307,8 +310,9 @@ protected String postJson(String url, JsonNode data) throws IOException {
     public void testUnknownInstructionSign() throws IOException {
         // Actual path for the request: point=48.354413%2C8.676335&point=48.35442%2C8.676345
         // Modified the sign though
-        JsonNode json = new ObjectMapper().readTree("{\"instructions\":[{\"distance\":1.073,\"sign\":741,\"interval\":[0,1],\"text\":\"Continue onto A 81\",\"time\":32,\"street_name\":\"A 81\"},{\"distance\":0,\"sign\":4,\"interval\":[1,1],\"text\":\"Finish!\",\"time\":0,\"street_name\":\"\"}],\"descend\":0,\"ascend\":0,\"distance\":1.073,\"bbox\":[8.676286,48.354446,8.676297,48.354453],\"weight\":0.032179,\"time\":32,\"points_encoded\":true,\"points\":\"gfcfHwq}s@}c~AAA?\",\"snapped_waypoints\":\"gfcfHwq}s@}c~AAA?\"}");
-        PathWrapper wrapper = new GraphHopperWeb().createPathWrapper(json, true, true);
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
+        JsonNode json = objectMapper.readTree("{\"instructions\":[{\"distance\":1.073,\"sign\":741,\"interval\":[0,1],\"text\":\"Continue onto A 81\",\"time\":32,\"street_name\":\"A 81\"},{\"distance\":0,\"sign\":4,\"interval\":[1,1],\"text\":\"Finish!\",\"time\":0,\"street_name\":\"\"}],\"descend\":0,\"ascend\":0,\"distance\":1.073,\"bbox\":[8.676286,48.354446,8.676297,48.354453],\"weight\":0.032179,\"time\":32,\"points_encoded\":true,\"points\":\"gfcfHwq}s@}c~AAA?\",\"snapped_waypoints\":\"gfcfHwq}s@}c~AAA?\"}");
+        PathWrapper wrapper = PathWrapperDeserializer.createPathWrapper(objectMapper, json, true, true);
 
         assertEquals(741, wrapper.getInstructions().get(0).getSign());
         assertEquals("Continue onto A 81", wrapper.getInstructions().get(0).getName());
diff --git a/client-hc/src/test/resources/com/graphhopper/api/matrix-connection-not-found-fail-fast.json b/client-hc/src/test/resources/com/graphhopper/api/matrix-connection-not-found-fail-fast.json
new file mode 100644
index 0000000000..df8f76a614
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/matrix-connection-not-found-fail-fast.json
@@ -0,0 +1,34 @@
+{
+  "status": "finished",
+  "solution": {
+    "info": {
+      "took": 0.049935993,
+      "copyrights": [
+        "GraphHopper",
+        "OpenStreetMap contributors"
+      ]
+    },
+    "weights": [
+      [0, null],
+      [null, 0]
+    ],
+    "distances": [
+      [1, null],
+      [null, 1]
+    ],
+    "times": [
+      [2, null],
+      [null, 2]
+    ],
+    "hints": [
+      {
+        "message": "There were 2 connections that could not be found, see point_pairs for details",
+        "details": "com.graphhopper.util.exceptions.ConnectionNotFoundException",
+        "point_pairs": [
+          [0, 1],
+          [1, 0]
+        ]
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/client-hc/src/test/resources/com/graphhopper/api/matrix-point-not-found-fail-fast.json b/client-hc/src/test/resources/com/graphhopper/api/matrix-point-not-found-fail-fast.json
new file mode 100644
index 0000000000..4d6fec5ef6
--- /dev/null
+++ b/client-hc/src/test/resources/com/graphhopper/api/matrix-point-not-found-fail-fast.json
@@ -0,0 +1,42 @@
+{
+  "status": "finished",
+  "solution": {
+    "info": {
+      "took": 0.049935993,
+      "copyrights": [
+        "GraphHopper",
+        "OpenStreetMap contributors"
+      ]
+    },
+    "weights": [
+      [0, null, 1],
+      [null, null, null],
+      [2, null, 3]
+    ],
+    "distances": [
+      [4, null, 5],
+      [null, null, null],
+      [6, null, 7]
+    ],
+    "times": [
+      [8, null, 9],
+      [null, null, null],
+      [10, null, 11]
+    ],
+    "hints": [
+      {
+        "message": "There were 5 connections that could not be found, see point_pairs for details",
+        "details": "com.graphhopper.util.exceptions.ConnectionNotFoundException",
+        "point_pairs": [
+          [0, 1],[1, 0], [1, 1], [1, 2], [2, 1]
+        ]
+      },
+      {
+        "message": "There were 1 from_points and 1 to_points that could not be found, see invalid_from/to_points for details",
+        "details": "com.graphhopper.util.exceptions.PointsNotFoundException",
+        "invalid_from_points": [1],
+        "invalid_to_points": [1]
+      }
+    ]
+  }
+}
\ No newline at end of file
diff --git a/config-example.yml b/config-example.yml
index ebebcccd84..37eaa99ee4 100644
--- a/config-example.yml
+++ b/config-example.yml
@@ -6,14 +6,19 @@ graphhopper:
   ##### Vehicles #####
 
 
-  # Possible options: car,foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
-  # bike2 takes elevation data into account (like up-hill is slower than down-hill) and requires enabling graph.elevation.provider below
+  # More options: foot,bike,bike2,mtb,racingbike,motorcycle (comma separated)
+  # bike2 takes elevation data into account (like up-hill is slower than down-hill) and requires enabling graph.elevation.provider below.
   graph.flag_encoders: car
 
-
   # Enable turn restrictions for car or motorcycle.
   # graph.flag_encoders: car|turn_costs=true
 
+  # Add additional information to every edge. Used for path details.
+  # If road_environment is added and elevation is enabled then also a tunnel and bridge interpolation is done, see #798.
+  # More options are: surface,max_width,max_height,max_weight,toll
+  graph.encoded_values: road_class,road_class_link,road_environment,max_speed,road_access
+  # If many flag_encoders or encoded_values are used you need to increase bytes_for_flags to 8 or more (multiple of 4)
+  graph.bytes_for_flags: 4
 
   ##### Elevation #####
 
@@ -39,6 +44,13 @@ graphhopper:
   # graph but less for every request. You can also setup multiple weightings, by providing a comma separated list.
   prepare.ch.weightings: fastest
 
+  # To enable turn-costs in speed mode (contraction hierarchies) edge-based graph traversal and a more elaborate
+  # pre-processing is required. Using this option you can either turn off the edge-based pre-processing (choose 'off'),
+  # use edge-based pre-processing for all encoders/vehicles with turn_costs=true (choose 'edge_or_node') or use node-based
+  # pre-processing for all encoders/vehicles and additional edge-based pre-processing for all encoders/vehicles with
+  # turn_costs=true (choose 'edge_and_node').
+  prepare.ch.edge_based: off
+
 
   # Disable the speed mode. Should be used only with routing.max_visited_nodes or when the hybrid mode is enabled instead
   # prepare.ch.weightings: no
@@ -73,7 +85,7 @@ graphhopper:
   # routing.max_visited_nodes: 1000000
 
 
-  # If enabled, allows a user to run flexibility requests even if speed mode is enabled. Every request then has to include a hint routing.ch.disable=true.
+  # If enabled, allows a user to run flexibility requests even if speed mode is enabled. Every request then has to include a hint ch.disable=true.
   # Attention, non-CH route calculations take way more time and resources, compared to CH routing.
   # A possible attacker might exploit this to slow down your service. Only enable it if you need it and with routing.maxVisitedNodes
   # routing.ch.disabling_allowed: true
@@ -142,3 +154,17 @@ server:
   - type: http
     port: 8990
     bindHost: localhost
+# See https://www.dropwizard.io/1.3.8/docs/manual/configuration.html#logging
+logging:
+  appenders:
+  - type: file
+    timeZone: UTC
+    currentLogFilename: logs/graphhopper.log
+    logFormat: "%d{YYYY-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
+    archive: true
+    archivedLogFilenamePattern: ./logs/graphhopper-%d.log.gz
+    archivedFileCount: 30
+    neverBlock: true
+  - type: console
+    timeZone: UTC
+    logFormat: "%d{YYYY-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
diff --git a/core/files/changelog.txt b/core/files/changelog.txt
index 9f1c60c386..76eb529d22 100644
--- a/core/files/changelog.txt
+++ b/core/files/changelog.txt
@@ -1,7 +1,41 @@
+0.13
+    removed docker compose file
+    PathDetails return null instead of -1 for Infinity by default
+    replaced AverageSpeedDetails by DecimalDetails
+    moved TagParser into new package: com.graphhopper.routing.util.parsers
+    removed FlagEncoderFactory.DEFAULT
+    removed forestry and motorroad from RoadClass
+    SpatialRule.AccessValue replaced by RoadAccess
+    removed EncodedValueLookup.hasEncoder, use hasEncodedValue instead
+    removed MappedDecimalEncodedValue: should be replaced with FactoredDecimalEncodedValue
+    DataFlagEncoder: it is now required to add EncodedValues before. graph.encoded_values: max_speed,road_class,road_environment,road_access
+    instead of EncodingManager.ROUNDABOUT use Roundabout.KEY
+    changed output format of result=pointlist and moved it into separate endpoint /spt
+    removed TraversalMode.EDGE_BASED_1DIR and TraversalMode.EDGE_BASED_2DIR_UTURN, renamed TraversalMode.EDGE_BASED_2DIR to TraversalMode.EDGE_BASED
+    to prevent u-turns when using edge-based algorithms it is now required to use TurnWeighting, #1640
+    GraphHopperStorage.getGraph(Class) was replaced by GraphHopperStorage.getBase/CHGraph(), #1669
+
+0.12
+    renamed VirtualEdgeIteratorState.getOriginalEdgeKey to more precise getOriginalEdgeKey #1549
+    access refactoring #1436 that moves AccessValue into SpatialRule.Access
+    refactoring of EncodingManager to use builder pattern. Migration should be simple. Replace new EncodingManager with EncodingManager.create
+	The methods GraphHopper.setEnableInstructions/setPreferredLanguage is now in EncodingManager.Builder
+    EncodingManager.supports renames to hasEncoder
+    big refactoring #1447: to increase 64bit limit of flags, make reverse direction handling easier, to allow shared EncodedValues,
+        remove reverseFlags method, much simpler property access, simplify FlagEncoder (maybe even deprecate this interface at a later stage)
+    moved shp-reader into separate repository: https://github.com/graphhopper/graphhopper-reader-shp    
+
 0.11
-    web resources for dropwizard web framework (no servlets anymore)
+    web resources for dropwizard web framework (no servlets anymore) #1108
     prefix -Dgraphhopper. for command line arguments necessary, see docs/web/quickstart.md or docs/core/quickstart-from-source.md#running--debbuging-with-intellij for details
     delegated reading properties to dropwizard, i.e. the new format yml is not read again in GraphHopper.init
+    changed file format for landmarks #1376
+    convert properties into new yml format via: https://gist.github.com/karussell/dbc9b4c455bca98b6a38e4a160e23bf8
+
+0.10
+    introduce path details
+    added handcoded API java client to this repository
+
 0.9
     remove war bundling support #297
     rename of DefaultModule to GraphHopperModule and GHServletModule to GraphHopperServletModule
@@ -139,7 +173,7 @@
         mapsforge: use mapsforge-map dependency; merged #461; avoid duplicates otherwise mapsforge-core would be duplicate (?)
     refactored/renamed classes and methods:
         refactor 'flags' from int to long (still only int is stored)
-        replacing Graph.edge(a,b,dist,flags) by Graph.edge(a,b).setDistance().setFlags()
+        replacing Graph.edge(a,b,dist,edgeFlags) by Graph.edge(a,b).setDistance().setFlags()
         FlagEncoder.flags => use FlagEncoder.setProperties or separate setAccess and setSpeed method
         renamed LocationIDResult to QueryResult and Location2NodesNtree to LocationIndexTree
         renamed Location2IDIndex to LocationIndex
diff --git a/core/files/docker-compose.yml b/core/files/docker-compose.yml
deleted file mode 100644
index 0a88726ecb..0000000000
--- a/core/files/docker-compose.yml
+++ /dev/null
@@ -1,12 +0,0 @@
-version: '2'
-services:
-    graph-hopper:
-        container_name: osm-graph-hopper
-        build: ../../
-        volumes:
-            - ../../data:/data
-        environment:
-            JAVA_OPTS: "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M -Ddw.server.applicationConnectors[0].bindHost=0.0.0.0 -Ddw.server.applicationConnectors[0].port=11111"
-        ports:
-            - "11111:11111"
-        command: /data/europe_germany_berlin.pbf
diff --git a/core/files/findbugs-exclude.xml b/core/files/spotbugs-exclude.xml
similarity index 100%
rename from core/files/findbugs-exclude.xml
rename to core/files/spotbugs-exclude.xml
diff --git a/core/files/test_simple_pturn.osm.xml b/core/files/test_simple_pturn.osm.xml
new file mode 100644
index 0000000000..de8ae8ad92
--- /dev/null
+++ b/core/files/test_simple_pturn.osm.xml
@@ -0,0 +1,71 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<osm version="0.6" generator="Manual" copyright="" attribution="" license="">
+    <bounds minlat="-1." minlon="-1.0" maxlat="1.0" maxlon="1.0"/>
+    <node id="1" lat="0" lon="0.001"/>
+    <node id="2" lat="0.0" lon="0.0"/>
+    <node id="3" lat="0.0" lon="-0.001"/>
+    <node id="4" lat="0.001" lon="-0.001"/>
+    <node id="5" lat="0.001" lon="0"/>
+    <node id="6" lat="-0.001" lon="0"/>
+
+    <!-- dummy node to create more pillars -->
+    <node id="7" lat="0.9" lon="-0.9"/>
+
+    <way id="1">
+        <nd ref="1"/>
+        <nd ref="2"/>
+        <tag k="name" v="str1"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+    <way id="2">
+        <nd ref="2"/>
+        <nd ref="3"/>
+        <tag k="name" v="str2"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+    <way id="3">
+        <nd ref="3"/>
+        <nd ref="4"/>
+        <nd ref="5"/>
+        <tag k="name" v="str3"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+    <way id="4">
+        <nd ref="5"/>
+        <nd ref="2"/>
+        <tag k="name" v="str4"/>
+        <tag k="highway" v="primary"/>
+        <tag k="oneway" v="yes"/>
+    </way>
+
+    <way id="5">
+        <nd ref="2"/>
+        <nd ref="6"/>
+        <tag k="name" v="str5"/>
+        <tag k="highway" v="primary"/>
+        <tag k="oneway" v="yes"/>
+    </way>
+
+    <!-- dummy way to create more pillars -->
+    <way id="6">
+        <nd ref="4"/>
+        <nd ref="7"/>
+        <tag k="highway" v="secondary"/>
+        <tag k="name" v="dummy"/>
+        <tag k="oneway" v="true"/>
+    </way>
+
+
+    <relation id="1">
+        <member type="way" ref="1" role="from"/>
+        <member type="way" ref="5" role="to"/>
+        <member type="node" ref="2" role="via"/>
+        <tag k="restriction" v="no_left_turn"/>
+        <tag k="type" v="restriction"/>
+    </relation>
+
+
+</osm>
diff --git a/core/files/test_simple_turncosts.osm.xml b/core/files/test_simple_turncosts.osm.xml
new file mode 100644
index 0000000000..5828110eda
--- /dev/null
+++ b/core/files/test_simple_turncosts.osm.xml
@@ -0,0 +1,56 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<osm version="0.6" generator="Manual" copyright="" attribution="" license="">
+    <bounds minlat="-1." minlon="-1.0" maxlat="1.0" maxlon="1.0"/>
+    <node id="1" lat="-0.5" lon="0.0"/>
+    <node id="2" lat="0.0" lon="0.0"/>
+    <node id="3" lat="0.5" lon="0.0"/>
+    <node id="4" lat="0.0" lon="0.5"/>
+    <node id="6" lat="0.0" lon="-0.5"/>
+    <node id="7" lat="0.0" lon="-1"/>
+    <node id="8" lat="-0.5" lon="-1"/>
+
+    <way id="1">
+        <nd ref="1"/>
+        <nd ref="2"/>
+        <nd ref="3"/>
+        <nd ref="4"/>
+        <tag k="name" v="str"/>
+        <tag k="highway" v="secondary"/>
+        <tag k="oneway" v="yes"/>
+    </way>
+
+    <way id="2">
+        <nd ref="4"/>
+        <nd ref="2"/>
+        <tag k="name" v="str2"/>
+        <tag k="highway" v="secondary"/>
+        <tag k="oneway" v="yes"/>
+    </way>
+
+    <way id="3">
+        <nd ref="2"/>
+        <nd ref="6"/>
+        <nd ref="7"/>
+        <tag k="name" v="str3"/>
+        <tag k="highway" v="secondary"/>
+        <tag k="oneway" v="yes"/>
+    </way>
+    <way id="4">
+        <nd ref="6"/>
+        <nd ref="8"/>
+        <tag k="name" v="str4"/>
+        <tag k="highway" v="secondary"/>
+        <tag k="oneway" v="yes"/>
+    </way>
+
+
+    <relation id="1">
+        <member type="way" ref="1" role="from"/>
+        <member type="way" ref="3" role="to"/>
+        <member type="node" ref="2" role="via"/>
+        <tag k="restriction" v="no_left_turn"/>
+        <tag k="type" v="restriction"/>
+    </relation>
+
+
+</osm>
diff --git a/core/files/update-translations.sh b/core/files/update-translations.sh
index 24496ac1b3..550f28c812 100755
--- a/core/files/update-translations.sh
+++ b/core/files/update-translations.sh
@@ -3,7 +3,7 @@ cd $HOME/..
 
 destination=src/main/resources/com/graphhopper/util/
 
-translations="en_US SKIP SKIP ar ast bg ca cs_CZ da_DK de_DE el eo es fa fil fi fr_FR fr_CH gl he hr_HR hsb hu_HU it ja ko lt_LT ne nl pl_PL pt_BR pt_PT ro ru sk sl_SI sr_RS sv_SE tr uk vi_VI zh_CN zh_HK"
+translations="en_US SKIP SKIP ar ast bg ca cs_CZ da_DK de_DE el eo es fa fil fi fr_FR fr_CH gl he hr_HR hsb hu_HU in_ID it ja ko lt_LT ne nl pl_PL pt_BR pt_PT ro ru sk sl_SI sr_RS sv_SE tr uk vi_VN zh_CN zh_HK zh_TW"
 file=$1
 
 # You can execute the following
diff --git a/core/pom.xml b/core/pom.xml
index 2c7f3cbe8e..97201d6b5b 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-core</artifactId>
     <name>GraphHopper Core</name>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <packaging>jar</packaging>
     <description>
         GraphHopper is a fast and memory efficient Java road routing engine
@@ -15,7 +15,7 @@
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
 
     <properties>
@@ -44,7 +44,7 @@
         <dependency>
             <groupId>com.carrotsearch</groupId>
             <artifactId>hppc</artifactId>
-            <version>0.7.2</version>
+            <version>0.8.1</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
@@ -56,7 +56,7 @@
         <dependency>
             <groupId>org.apache.xmlgraphics</groupId>
             <artifactId>xmlgraphics-commons</artifactId>
-            <version>2.1</version>
+            <version>2.3</version>
             <exclusions>
                 <exclusion>
                     <groupId>commons-logging</groupId>
@@ -98,7 +98,7 @@
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
-                    <version>3.1.0</version>
+                    <version>3.1.2</version>
                     <executions>
                         <execution>
                             <goals>
@@ -108,9 +108,34 @@
                     </executions>
                 </plugin>
 
+                <plugin>
+                    <groupId>pl.project13.maven</groupId>
+                    <artifactId>git-commit-id-plugin</artifactId>
+                    <version>3.0.0</version>
+                </plugin>
             </plugins>
         </pluginManagement>
 
+        <plugins>
+            <plugin>
+                <groupId>pl.project13.maven</groupId>
+                <artifactId>git-commit-id-plugin</artifactId>
+                <executions>
+                    <execution>
+                        <goals>
+                            <goal>revision</goal>
+                        </goals>
+                    </execution>
+                </executions>
+
+                <configuration>
+                    <dotGitDirectory>${parent.basedir}/.git</dotGitDirectory>
+                    <failOnNoGitDirectory>false</failOnNoGitDirectory>
+                    <failOnUnableToExtractRepoInfo>false</failOnUnableToExtractRepoInfo>
+                </configuration>
+            </plugin>
+        </plugins>
+
         <!-- make version available at runtime via version file -->
         <resources>
             <resource>
@@ -119,6 +144,7 @@
                 <includes>
                     <include>**/version</include>
                     <include>**/builddate</include>
+                    <include>**/gitinfo</include>
                 </includes>
             </resource>
             <resource>
@@ -127,8 +153,9 @@
                 <excludes>
                     <exclude>**/version</exclude>
                     <exclude>**/builddate</exclude>
+                    <exclude>**/gitinfo</exclude>
                 </excludes>
             </resource>
         </resources>
     </build>
-</project>
+</project>
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index d027d726a9..e570036eb8 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -24,12 +24,18 @@
 import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.lm.LMAlgoFactoryDecorator;
+import com.graphhopper.routing.profiles.DefaultEncodedValueFactory;
+import com.graphhopper.routing.profiles.EncodedValueFactory;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadEnvironment;
 import com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks;
 import com.graphhopper.routing.template.AlternativeRoutingTemplate;
 import com.graphhopper.routing.template.RoundTripRoutingTemplate;
 import com.graphhopper.routing.template.RoutingTemplate;
 import com.graphhopper.routing.template.ViaRoutingTemplate;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.parsers.DefaultTagParserFactory;
+import com.graphhopper.routing.util.parsers.TagParserFactory;
 import com.graphhopper.routing.weighting.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.change.ChangeGraphHelper;
@@ -57,6 +63,8 @@
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
+import static com.graphhopper.routing.ch.CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE;
+import static com.graphhopper.routing.ch.CHAlgoFactoryDecorator.EdgeBasedCHMode.OFF;
 import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.Algorithms.*;
 
@@ -73,7 +81,6 @@
     // utils
     private final TranslationMap trMap = new TranslationMap().doImport();
     boolean removeZipped = true;
-    boolean enableInstructions = true;
     // for graph:
     private GraphHopperStorage ghStorage;
     private EncodingManager encodingManager;
@@ -84,7 +91,6 @@
     private boolean elevation = false;
     private LockFactory lockFactory = new NativeFSLockFactory();
     private boolean allowWrites = true;
-    private String preferredLanguage = "";
     private boolean fullyLoaded = false;
     private boolean smoothElevation = false;
     // for routing
@@ -114,7 +120,9 @@
     private int dataReaderWorkerThreads = 2;
     private boolean calcPoints = true;
     private ElevationProvider eleProvider = ElevationProvider.NOOP;
-    private FlagEncoderFactory flagEncoderFactory = FlagEncoderFactory.DEFAULT;
+    private FlagEncoderFactory flagEncoderFactory = new DefaultFlagEncoderFactory();
+    private EncodedValueFactory encodedValueFactory = new DefaultEncodedValueFactory();
+    private TagParserFactory tagParserFactory = new DefaultTagParserFactory();
     private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
     private PathDetailsBuilderFactory pathBuilderFactory = new PathDetailsBuilderFactory();
 
@@ -159,7 +167,7 @@ public GraphHopper setEncodingManager(EncodingManager em) {
         ensureNotLoaded();
         this.encodingManager = em;
         if (em.needsTurnCostsSupport())
-            traversalMode = TraversalMode.EDGE_BASED_2DIR;
+            traversalMode = TraversalMode.EDGE_BASED;
 
         return this;
     }
@@ -357,44 +365,6 @@ public GraphHopper setElevation(boolean includeElevation) {
         return this;
     }
 
-    public boolean isEnableInstructions() {
-        return enableInstructions;
-    }
-
-    /**
-     * This method specifies if the import should include way names to be able to return
-     * instructions for a route.
-     */
-    public GraphHopper setEnableInstructions(boolean b) {
-        ensureNotLoaded();
-        enableInstructions = b;
-        return this;
-    }
-
-    public String getPreferredLanguage() {
-        return preferredLanguage;
-    }
-
-    /**
-     * This method specifies the preferred language for way names during import.
-     * <p>
-     * Language code as defined in ISO 639-1 or ISO 639-2.
-     * <ul>
-     * <li>If no preferred language is specified, only the default language with no tag will be
-     * imported.</li>
-     * <li>If a language is specified, it will be imported if its tag is found, otherwise fall back
-     * to default language.</li>
-     * </ul>
-     */
-    public GraphHopper setPreferredLanguage(String preferredLanguage) {
-        ensureNotLoaded();
-        if (preferredLanguage == null)
-            throw new IllegalArgumentException("preferred language cannot be null");
-
-        this.preferredLanguage = preferredLanguage;
-        return this;
-    }
-
     /**
      * This methods enables gps point calculation. If disabled only distance will be calculated.
      */
@@ -509,14 +479,27 @@ public GraphHopper setFlagEncoderFactory(FlagEncoderFactory factory) {
         return this;
     }
 
-    public FlagEncoderFactory getFlagEncoderFactory() {
-        return this.flagEncoderFactory;
+    public EncodedValueFactory getEncodedValueFactory() {
+        return this.encodedValueFactory;
+    }
+
+    public GraphHopper setEncodedValueFactory(EncodedValueFactory factory) {
+        this.encodedValueFactory = factory;
+        return this;
+    }
+
+    public TagParserFactory getTagParserFactory() {
+        return this.tagParserFactory;
+    }
+
+    public GraphHopper setTagParserFactory(TagParserFactory factory) {
+        this.tagParserFactory = factory;
+        return this;
     }
 
     /**
-     * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
-     * args) ala CmdArgs.read(args) or via configuration file ala
-     * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
+     * Reads the configuration from a CmdArgs object which can be manually filled, or via
+     * CmdArgs.read(String[] args)
      */
     public GraphHopper init(CmdArgs args) {
         args.merge(CmdArgs.readFromSystemProperties());
@@ -545,9 +528,19 @@ public GraphHopper init(CmdArgs args) {
         sortGraph = args.getBool("graph.do_sort", sortGraph);
         removeZipped = args.getBool("graph.remove_zipped", removeZipped);
         int bytesForFlags = args.getInt("graph.bytes_for_flags", 4);
+        EncodingManager.Builder emBuilder = new EncodingManager.Builder(bytesForFlags);
         String flagEncodersStr = args.get("graph.flag_encoders", "");
-        if (!flagEncodersStr.isEmpty())
-            setEncodingManager(new EncodingManager(flagEncoderFactory, flagEncodersStr, bytesForFlags));
+        String encodedValueStr = args.get("graph.encoded_values", "");
+        if (!flagEncodersStr.isEmpty() || !encodedValueStr.isEmpty()) {
+            if (!encodedValueStr.isEmpty())
+                emBuilder.addAll(tagParserFactory, encodedValueStr);
+            if (!flagEncodersStr.isEmpty())
+                emBuilder.addAll(flagEncoderFactory, flagEncodersStr);
+            emBuilder.setEnableInstructions(args.getBool("datareader.instructions", true));
+            emBuilder.setPreferredLanguage(args.get("datareader.preferred_language", ""));
+            // overwrite EncodingManager object from configuration file
+            setEncodingManager(emBuilder.build());
+        }
 
         if (args.get("graph.locktype", "native").equals("simple"))
             lockFactory = new SimpleFSLockFactory();
@@ -608,8 +601,6 @@ public GraphHopper init(CmdArgs args) {
         dataReaderWayPointMaxDistance = args.getDouble(Routing.INIT_WAY_POINT_MAX_DISTANCE, dataReaderWayPointMaxDistance);
 
         dataReaderWorkerThreads = args.getInt("datareader.worker_threads", dataReaderWorkerThreads);
-        enableInstructions = args.getBool("datareader.instructions", enableInstructions);
-        preferredLanguage = args.get("datareader.preferred_language", preferredLanguage);
 
         // index
         preciseIndexResolution = args.getInt("index.high_resolution", preciseIndexResolution);
@@ -686,8 +677,6 @@ protected DataReader importData() throws IOException {
             throw new IllegalStateException("Couldn't load from existing folder: " + ghLocation
                     + " but also cannot use file for DataReader as it wasn't specified!");
 
-        encodingManager.setEnableInstructions(enableInstructions);
-        encodingManager.setPreferredLanguage(preferredLanguage);
         DataReader reader = createReader(ghStorage);
         logger.info("using " + ghStorage.toString() + ", memory:" + getMemInfo());
         reader.readGraph();
@@ -744,7 +733,7 @@ public boolean load(String graphHopperFolder) {
         setGraphHopperLocation(graphHopperFolder);
 
         if (encodingManager == null)
-            setEncodingManager(EncodingManager.create(flagEncoderFactory, ghLocation));
+            setEncodingManager(EncodingManager.create(encodedValueFactory, flagEncoderFactory, ghLocation));
 
         if (!allowWrites && dataAccessType.isMMap())
             dataAccessType = DAType.MMAP_RO;
@@ -758,7 +747,8 @@ public boolean load(String graphHopperFolder) {
 
         if (chFactoryDecorator.isEnabled()) {
             initCHAlgoFactoryDecorator();
-            ghStorage = new GraphHopperStorage(chFactoryDecorator.getWeightings(), dir, encodingManager, hasElevation(), ext);
+            ghStorage = new GraphHopperStorage(chFactoryDecorator.getNodeBasedWeightings(), chFactoryDecorator.getEdgeBasedWeightings(),
+                    dir, encodingManager, hasElevation(), ext);
         } else {
             ghStorage = new GraphHopperStorage(dir, encodingManager, hasElevation(), ext);
         }
@@ -817,8 +807,13 @@ private void initCHAlgoFactoryDecorator() {
             for (FlagEncoder encoder : encodingManager.fetchEdgeEncoders()) {
                 for (String chWeightingStr : chFactoryDecorator.getWeightingsAsStrings()) {
                     // ghStorage is null at this point
-                    Weighting weighting = createWeighting(new HintsMap(chWeightingStr), encoder, null);
-                    chFactoryDecorator.addWeighting(weighting);
+                    CHAlgoFactoryDecorator.EdgeBasedCHMode edgeBasedCHMode = chFactoryDecorator.getEdgeBasedCHMode();
+                    if (!(edgeBasedCHMode == EDGE_OR_NODE && encoder.supports(TurnWeighting.class))) {
+                        chFactoryDecorator.addNodeBasedWeighting(createWeighting(new HintsMap(chWeightingStr), encoder, null));
+                    }
+                    if (edgeBasedCHMode != OFF && encoder.supports(TurnWeighting.class)) {
+                        chFactoryDecorator.addEdgeBasedWeighting(createWeighting(new HintsMap(chWeightingStr), encoder, null));
+                    }
                 }
             }
         }
@@ -857,14 +852,14 @@ public void postProcessing() {
             ghStorage = newGraph;
         }
 
-        if (hasElevation()) {
+        if (!hasInterpolated() && hasElevation()) {
             interpolateBridgesAndOrTunnels();
         }
 
         initLocationIndex();
 
         if (chFactoryDecorator.isEnabled())
-            chFactoryDecorator.createPreparations(ghStorage, traversalMode);
+            chFactoryDecorator.createPreparations(ghStorage);
         if (!isCHPrepared())
             prepareCH();
 
@@ -873,23 +868,22 @@ public void postProcessing() {
         loadOrPrepareLM();
     }
 
-    private void interpolateBridgesAndOrTunnels() {
-        if (ghStorage.getEncodingManager().supports("generic")) {
-            final FlagEncoder genericFlagEncoder = ghStorage.getEncodingManager()
-                    .getEncoder("generic");
-            if (!(genericFlagEncoder instanceof DataFlagEncoder)) {
-                throw new IllegalStateException("'generic' flag encoder for elevation interpolation of "
-                        + "bridges and tunnels is enabled but does not have the expected type "
-                        + DataFlagEncoder.class.getName() + ".");
-            }
-            final DataFlagEncoder dataFlagEncoder = (DataFlagEncoder) genericFlagEncoder;
+    private static final String INTERPOLATION_KEY = "prepare.elevation_interpolation.done";
+
+    private boolean hasInterpolated() {
+        return "true".equals(ghStorage.getProperties().get(INTERPOLATION_KEY));
+    }
+
+    void interpolateBridgesAndOrTunnels() {
+        if (ghStorage.getEncodingManager().hasEncodedValue(RoadEnvironment.KEY)) {
+            EnumEncodedValue<RoadEnvironment> roadEnvEnc = ghStorage.getEncodingManager().getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class);
             StopWatch sw = new StopWatch().start();
-            new TunnelElevationInterpolator(ghStorage, dataFlagEncoder).execute();
+            new EdgeElevationInterpolator(ghStorage, roadEnvEnc, RoadEnvironment.TUNNEL).execute();
             float tunnel = sw.stop().getSeconds();
             sw = new StopWatch().start();
-            new BridgeElevationInterpolator(ghStorage, dataFlagEncoder).execute();
-            logger.info("Bridge interpolation " + (int) sw.stop().getSeconds() + "s, "
-                    + "tunnel interpolation " + (int) tunnel + "s");
+            new EdgeElevationInterpolator(ghStorage, roadEnvEnc, RoadEnvironment.BRIDGE).execute();
+            ghStorage.getProperties().put(INTERPOLATION_KEY, true);
+            logger.info("Bridge interpolation " + (int) sw.stop().getSeconds() + "s, " + "tunnel interpolation " + (int) tunnel + "s");
         }
     }
 
@@ -944,7 +938,7 @@ public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph g
      */
     public Weighting createTurnWeighting(Graph graph, Weighting weighting, TraversalMode tMode) {
         FlagEncoder encoder = weighting.getFlagEncoder();
-        if (encoder.supports(TurnWeighting.class) && !tMode.equals(TraversalMode.NODE_BASED))
+        if (encoder.supports(TurnWeighting.class) && tMode.isEdgeBased())
             return new TurnWeighting(weighting, (TurnCostExtension) graph.getExtension());
         return weighting;
     }
@@ -976,14 +970,14 @@ public GHResponse route(GHRequest request) {
         Lock readLock = readWriteLock.readLock();
         readLock.lock();
         try {
-            if (!encodingManager.supports(vehicle))
+            if (!encodingManager.hasEncoder(vehicle))
                 throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
 
             HintsMap hints = request.getHints();
             String tModeStr = hints.get("traversal_mode", traversalMode.toString());
             TraversalMode tMode = TraversalMode.fromString(tModeStr);
             if (hints.has(Routing.EDGE_BASED))
-                tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED_2DIR : TraversalMode.NODE_BASED;
+                tMode = hints.getBool(Routing.EDGE_BASED, false) ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
 
             FlagEncoder encoder = encodingManager.getEncoder(vehicle);
 
@@ -1006,11 +1000,11 @@ public GHResponse route(GHRequest request) {
 
             RoutingTemplate routingTemplate;
             if (ROUND_TRIP.equalsIgnoreCase(algoStr))
-                routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, maxRoundTripRetries);
+                routingTemplate = new RoundTripRoutingTemplate(request, ghRsp, locationIndex, encodingManager, maxRoundTripRetries);
             else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
-                routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex);
+                routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
             else
-                routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex);
+                routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
 
             List<Path> altPaths = null;
             int maxRetries = routingTemplate.getMaxRetries();
@@ -1042,16 +1036,15 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                     else
                         throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
 
-                    tMode = getCHFactoryDecorator().getNodeBase();
-                    queryGraph = new QueryGraph(ghStorage.getGraph(CHGraph.class, weighting));
+                    queryGraph = new QueryGraph(ghStorage.getCHGraph(weighting));
                     queryGraph.lookup(qResults);
                 } else {
                     checkNonChMaxWaypointDistance(points);
                     queryGraph = new QueryGraph(ghStorage);
                     queryGraph.lookup(qResults);
                     weighting = createWeighting(hints, encoder, queryGraph);
-                    ghRsp.addDebugInfo("tmode:" + tMode.toString());
                 }
+                ghRsp.addDebugInfo("tmode:" + tMode.toString());
 
                 int maxVisitedNodesForRequest = hints.getInt(Routing.MAX_VISITED_NODES, maxVisitedNodes);
                 if (maxVisitedNodesForRequest > maxVisitedNodes)
@@ -1068,7 +1061,7 @@ else if (ALT_ROUTE.equalsIgnoreCase(algoStr))
                 // do the actual route calculation !
                 altPaths = routingTemplate.calcPaths(queryGraph, tmpAlgoFactory, algoOpts);
 
-                boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, enableInstructions);
+                boolean tmpEnableInstructions = hints.getBool(Routing.INSTRUCTIONS, getEncodingManager().isEnableInstructions());
                 boolean tmpCalcPoints = hints.getBool(Routing.CALC_POINTS, calcPoints);
                 double wayPointMaxDistance = hints.getDouble(Routing.WAY_POINT_MAX_DISTANCE, 1d);
 
diff --git a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
index febffdccd7..db9c9e01ff 100644
--- a/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
+++ b/core/src/main/java/com/graphhopper/coll/GHBitSetImpl.java
@@ -20,6 +20,10 @@
 import java.util.BitSet;
 
 /**
+ * This implementation stores the bits inside the values of a long-array. Be aware that the size of this array grows
+ * depending on the values you pass into this set. If you only want to add a few (possibly large) integers you should
+ * use {@link GHTBitSet} instead.
+ *
  * @author Peter Karich
  */
 public class GHBitSetImpl extends BitSet implements GHBitSet {
diff --git a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
index e1e66b21eb..2088d8b42a 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/CGIARProvider.java
@@ -54,7 +54,7 @@ public CGIARProvider() {
 
     public CGIARProvider(String cacheDir) {
         // Alternative URLs for the CGIAR data can be found in #346
-        super("http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff",
+        super("http://srtm.csi.cgiar.org/wp-content/uploads/files/srtm_5x5/TIFF/",
                 cacheDir.isEmpty() ? "/tmp/cgiar" : cacheDir,
                 "GraphHopper CGIARReader",
                 6000, 6000,
diff --git a/core/src/main/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolator.java b/core/src/main/java/com/graphhopper/reader/dem/EdgeElevationInterpolator.java
similarity index 83%
rename from core/src/main/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolator.java
rename to core/src/main/java/com/graphhopper/reader/dem/EdgeElevationInterpolator.java
index 87db8564d6..feb7608866 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolator.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/EdgeElevationInterpolator.java
@@ -21,15 +21,13 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.coll.GHIntHashSet;
+import com.graphhopper.coll.GHTBitSet;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadEnvironment;
 import com.graphhopper.routing.util.AllEdgesIterator;
-import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.util.BreadthFirstSearch;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.PointList;
+import com.graphhopper.util.*;
 
 /**
  * Abstract base class for tunnel/bridge edge elevation interpolators. This
@@ -54,21 +52,24 @@
  *
  * @author Alexey Valikov
  */
-public abstract class AbstractEdgeElevationInterpolator {
+public class EdgeElevationInterpolator {
 
     private final GraphHopperStorage storage;
-    protected final DataFlagEncoder dataFlagEncoder;
+    protected final EnumEncodedValue<RoadEnvironment> roadEnvironmentEnc;
     private final NodeElevationInterpolator nodeElevationInterpolator;
+    private final RoadEnvironment interpolateKey;
     private final ElevationInterpolator elevationInterpolator = new ElevationInterpolator();
 
-    public AbstractEdgeElevationInterpolator(GraphHopperStorage storage,
-                                             DataFlagEncoder dataFlagEncoder) {
+    public EdgeElevationInterpolator(GraphHopperStorage storage, EnumEncodedValue<RoadEnvironment> roadEnvironmentEnc, RoadEnvironment interpolateKey) {
         this.storage = storage;
-        this.dataFlagEncoder = dataFlagEncoder;
+        this.roadEnvironmentEnc = roadEnvironmentEnc;
+        this.interpolateKey = interpolateKey;
         this.nodeElevationInterpolator = new NodeElevationInterpolator(storage);
     }
 
-    protected abstract boolean isInterpolatableEdge(EdgeIteratorState edge);
+    protected boolean isInterpolatableEdge(EdgeIteratorState edge) {
+        return edge.get(roadEnvironmentEnc) == interpolateKey;
+    }
 
     public GraphHopperStorage getStorage() {
         return storage;
@@ -99,16 +100,19 @@ private void interpolateEdge(final EdgeIteratorState interpolatableEdge,
                                  final GHBitSet visitedEdgeIds, final EdgeExplorer edgeExplorer) {
         final IntSet outerNodeIds = new GHIntHashSet();
         final GHIntHashSet innerNodeIds = new GHIntHashSet();
-        gatherOuterAndInnerNodeIds(edgeExplorer, interpolatableEdge, visitedEdgeIds, outerNodeIds,
-                innerNodeIds);
-        nodeElevationInterpolator.interpolateElevationsOfInnerNodes(outerNodeIds.toArray(),
-                innerNodeIds.toArray());
+        gatherOuterAndInnerNodeIds(edgeExplorer, interpolatableEdge, visitedEdgeIds, outerNodeIds, innerNodeIds);
+        nodeElevationInterpolator.interpolateElevationsOfInnerNodes(outerNodeIds.toArray(), innerNodeIds.toArray());
     }
 
     public void gatherOuterAndInnerNodeIds(final EdgeExplorer edgeExplorer,
                                            final EdgeIteratorState interpolatableEdge, final GHBitSet visitedEdgesIds,
                                            final IntSet outerNodeIds, final GHIntHashSet innerNodeIds) {
         final BreadthFirstSearch gatherOuterAndInnerNodeIdsSearch = new BreadthFirstSearch() {
+            @Override
+            protected GHBitSet createBitSet() {
+                return new GHTBitSet();
+            }
+
             @Override
             protected boolean checkAdjacent(EdgeIteratorState edge) {
                 visitedEdgesIds.add(edge.getEdge());
@@ -142,16 +146,18 @@ private void interpolateElevationsOfPillarNodes() {
                 double lon1 = nodeAccess.getLon(secondNodeId);
                 double ele1 = nodeAccess.getEle(secondNodeId);
 
-                final PointList pointList = edge.fetchWayGeometry(0);
+                final PointList pointList = edge.fetchWayGeometry(3);
                 final int count = pointList.size();
-                for (int index = 0; index < count; index++) {
+                for (int index = 1; index < count - 1; index++) {
                     double lat = pointList.getLat(index);
                     double lon = pointList.getLon(index);
                     double ele = elevationInterpolator.calculateElevationBasedOnTwoPoints(lat, lon,
                             lat0, lon0, ele0, lat1, lon1, ele1);
                     pointList.set(index, lat, lon, ele);
                 }
-                edge.setWayGeometry(pointList);
+                if (count > 2)
+                    edge.setWayGeometry(pointList.shallowCopy(1, count - 1, false));
+                edge.setDistance(pointList.calcDistance(Helper.DIST_3D));
             }
         }
     }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/ElevationInterpolator.java b/core/src/main/java/com/graphhopper/reader/dem/ElevationInterpolator.java
index 67a27b52b6..75bb97cc19 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/ElevationInterpolator.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/ElevationInterpolator.java
@@ -25,7 +25,6 @@
  * Elevation interpolator calculates elevation for the given lat/lon coordinates
  * based on lat/lon/ele coordinates of the given points.
  * <p>
- * <p>
  * In case of two points, elevation is calculated using linear interpolation
  * (see
  * {@link #calculateElevationBasedOnTwoPoints(double, double, double, double, double, double, double, double)}).
diff --git a/core/src/main/java/com/graphhopper/reader/dem/NodeElevationInterpolator.java b/core/src/main/java/com/graphhopper/reader/dem/NodeElevationInterpolator.java
index 5574d638d9..efed1f3309 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/NodeElevationInterpolator.java
+++ b/core/src/main/java/com/graphhopper/reader/dem/NodeElevationInterpolator.java
@@ -22,7 +22,7 @@
 import com.graphhopper.util.PointList;
 
 /**
- * Interpolates elevations of inner nodes based on elevations of outer nodes.
+ * Interpolates elevations of pillar nodes based on elevations of tower nodes.
  *
  * @author Alexey Valikov
  */
@@ -42,18 +42,15 @@ public void interpolateElevationsOfInnerNodes(int[] outerNodeIds, int[] innerNod
         } else if (numberOfOuterNodes == 1) {
             interpolateElevationsOfInnerNodesForOneOuterNode(outerNodeIds[0], innerNodeIds);
         } else if (numberOfOuterNodes == 2) {
-            interpolateElevationsOfInnerNodesForTwoOuterNodes(outerNodeIds[0], outerNodeIds[1],
-                    innerNodeIds);
+            interpolateElevationsOfInnerNodesForTwoOuterNodes(outerNodeIds[0], outerNodeIds[1], innerNodeIds);
         } else if (numberOfOuterNodes == 3) {
-            interpolateElevationsOfInnerNodesForThreeOuterNodes(outerNodeIds[0], outerNodeIds[1],
-                    outerNodeIds[2], innerNodeIds);
+            interpolateElevationsOfInnerNodesForThreeOuterNodes(outerNodeIds[0], outerNodeIds[1], outerNodeIds[2], innerNodeIds);
         } else if (numberOfOuterNodes > 3) {
             interpolateElevationsOfInnerNodesForNOuterNodes(outerNodeIds, innerNodeIds);
         }
     }
 
-    private void interpolateElevationsOfInnerNodesForOneOuterNode(int outerNodeId,
-                                                                  int[] innerNodeIds) {
+    private void interpolateElevationsOfInnerNodesForOneOuterNode(int outerNodeId, int[] innerNodeIds) {
         NodeAccess nodeAccess = storage.getNodeAccess();
         double ele = nodeAccess.getEle(outerNodeId);
         for (int innerNodeId : innerNodeIds) {
@@ -77,14 +74,14 @@ private void interpolateElevationsOfInnerNodesForTwoOuterNodes(int firstOuterNod
         for (int innerNodeId : innerNodeIds) {
             double lat = nodeAccess.getLat(innerNodeId);
             double lon = nodeAccess.getLon(innerNodeId);
-            double ele = elevationInterpolator.calculateElevationBasedOnTwoPoints(lat, lon, lat0,
-                    lon0, ele0, lat1, lon1, ele1);
+            double ele = elevationInterpolator.calculateElevationBasedOnTwoPoints(lat, lon, lat0, lon0, ele0,
+                    lat1, lon1, ele1);
             nodeAccess.setNode(innerNodeId, lat, lon, ele);
         }
     }
 
-    private void interpolateElevationsOfInnerNodesForThreeOuterNodes(int firstOuterNodeId,
-                                                                     int secondOuterNodeId, int thirdOuterNodeId, int[] innerNodeIds) {
+    private void interpolateElevationsOfInnerNodesForThreeOuterNodes(int firstOuterNodeId, int secondOuterNodeId,
+                                                                     int thirdOuterNodeId, int[] innerNodeIds) {
         NodeAccess nodeAccess = storage.getNodeAccess();
         double lat0 = nodeAccess.getLat(firstOuterNodeId);
         double lon0 = nodeAccess.getLon(firstOuterNodeId);
@@ -118,8 +115,7 @@ private void interpolateElevationsOfInnerNodesForNOuterNodes(int[] outerNodeIds,
         for (int innerNodeId : innerNodeIds) {
             double lat = nodeAccess.getLat(innerNodeId);
             double lon = nodeAccess.getLon(innerNodeId);
-            double ele = elevationInterpolator.calculateElevationBasedOnPointList(lat, lon,
-                    pointList);
+            double ele = elevationInterpolator.calculateElevationBasedOnPointList(lat, lon, pointList);
             nodeAccess.setNode(innerNodeId, lat, lon, ele);
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
index b01d70f4af..ec5fd13594 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirection.java
@@ -74,13 +74,13 @@ void init(int from, double fromWeight, int to, double toWeight) {
     }
 
     @Override
-    protected AStarEntry createStartEntry(int node, double weight, boolean reverse) {
+    protected SPTEntry createStartEntry(int node, double weight, boolean reverse) {
         double heapWeight = weight + weightApprox.approximate(node, reverse);
         return new AStarEntry(EdgeIterator.NO_EDGE, node, heapWeight, weight);
     }
 
     @Override
-    protected SPTEntry createEntry(EdgeIteratorState edge, double weight, SPTEntry parent, boolean reverse) {
+    protected SPTEntry createEntry(EdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse) {
         int neighborNode = edge.getAdjNode();
         double heapWeight = weight + weightApprox.approximate(neighborNode, reverse);
         AStarEntry entry = new AStarEntry(edge.getEdge(), neighborNode, heapWeight, weight);
@@ -89,7 +89,7 @@ protected SPTEntry createEntry(EdgeIteratorState edge, double weight, SPTEntry p
     }
 
     @Override
-    protected void updateEntry(SPTEntry entry, EdgeIteratorState edge, double weight, SPTEntry parent, boolean reverse) {
+    protected void updateEntry(SPTEntry entry, EdgeIteratorState edge, int edgeId, double weight, SPTEntry parent, boolean reverse) {
         entry.edge = edge.getEdge();
         entry.weight = weight + weightApprox.approximate(edge.getAdjNode(), reverse);
         ((AStarEntry) entry).weightOfVisitedPath = weight;
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java b/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java
index 6e7b7beb0c..a2958b795c 100644
--- a/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirectionCH.java
@@ -23,12 +23,8 @@
 import com.graphhopper.storage.Graph;
 
 public class AStarBidirectionCH extends AStarBidirection {
-    public AStarBidirectionCH(Graph graph, Weighting weighting, TraversalMode traversalMode) {
-        super(graph, weighting, traversalMode);
-        if (traversalMode.isEdgeBased()) {
-            throw new IllegalArgumentException("Edge based traversal is not supported" +
-                    "for CH");
-        }
+    public AStarBidirectionCH(Graph graph, Weighting weighting) {
+        super(graph, weighting, TraversalMode.NODE_BASED);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/AStarBidirectionEdgeCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/AStarBidirectionEdgeCHNoSOD.java
new file mode 100644
index 0000000000..4c712e9246
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/AStarBidirectionEdgeCHNoSOD.java
@@ -0,0 +1,115 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.AStarCHEntry;
+import com.graphhopper.routing.weighting.*;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
+
+/**
+ * @author easbar
+ */
+public class AStarBidirectionEdgeCHNoSOD extends AbstractBidirectionEdgeCHNoSOD {
+    private final boolean useHeuristicForNodeOrder = false;
+    private ConsistentWeightApproximator weightApprox;
+
+    public AStarBidirectionEdgeCHNoSOD(Graph graph, TurnWeighting weighting) {
+        super(graph, weighting);
+        setApproximation(new BeelineWeightApproximator(nodeAccess, weighting).setDistanceCalc(Helper.DIST_PLANE));
+    }
+
+    @Override
+    public void init(int from, double fromWeight, int to, double toWeight) {
+        weightApprox.setFrom(from);
+        weightApprox.setTo(to);
+        super.init(from, fromWeight, to, toWeight);
+    }
+
+    @Override
+    protected boolean fwdSearchCanBeStopped() {
+        return getMinCurrFromPathWeight() > bestPath.getWeight();
+    }
+
+    @Override
+    protected boolean bwdSearchCanBeStopped() {
+        return getMinCurrToPathWeight() > bestPath.getWeight();
+    }
+
+    @Override
+    protected AStarCHEntry createStartEntry(int node, double weight, boolean reverse) {
+        final double heapWeight = getHeapWeight(node, reverse, weight);
+        return new AStarCHEntry(node, heapWeight, weight);
+    }
+
+    @Override
+    protected SPTEntry createEntry(EdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse) {
+        int neighborNode = edge.getAdjNode();
+        double heapWeight = getHeapWeight(neighborNode, reverse, weight);
+        AStarCHEntry entry = new AStarCHEntry(edge.getEdge(), incEdge, neighborNode, heapWeight, weight);
+        entry.parent = parent;
+        return entry;
+    }
+
+    @Override
+    protected void updateEntry(SPTEntry entry, EdgeIteratorState edge, int edgeId, double weight, SPTEntry parent, boolean reverse) {
+        entry.edge = edge.getEdge();
+        ((AStarCHEntry) entry).incEdge = edgeId;
+        entry.weight = getHeapWeight(edge.getAdjNode(), reverse, weight);
+        ((AStarCHEntry) entry).weightOfVisitedPath = weight;
+        entry.parent = parent;
+    }
+
+    public WeightApproximator getApproximation() {
+        return weightApprox.getApproximation();
+    }
+
+    public AStarBidirectionEdgeCHNoSOD setApproximation(WeightApproximator weightApproximator) {
+        weightApprox = new ConsistentWeightApproximator(weightApproximator);
+        return this;
+    }
+
+    private double getHeapWeight(int node, boolean reverse, double weightOfVisitedPath) {
+        if (useHeuristicForNodeOrder) {
+            return weightOfVisitedPath + weightApprox.approximate(node, reverse);
+        }
+        return weightOfVisitedPath;
+    }
+
+    private double getMinCurrFromPathWeight() {
+        if (useHeuristicForNodeOrder) {
+            return currFrom.weight;
+        }
+        return currFrom.weight + weightApprox.approximate(currFrom.adjNode, false);
+    }
+
+    private double getMinCurrToPathWeight() {
+        if (useHeuristicForNodeOrder) {
+            return currTo.weight;
+        }
+        return currTo.weight + weightApprox.approximate(currTo.adjNode, true);
+    }
+
+
+    @Override
+    public String getName() {
+        return "astarbi|ch|edge_based|no_sod";
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
index e660c7244a..d97852661f 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java
@@ -37,6 +37,8 @@
  * @author Peter Karich
  */
 public abstract class AbstractBidirAlgo extends AbstractRoutingAlgorithm {
+    protected int from;
+    protected int to;
     protected IntObjectMap<SPTEntry> bestWeightMapFrom;
     protected IntObjectMap<SPTEntry> bestWeightMapTo;
     protected IntObjectMap<SPTEntry> bestWeightMapOther;
@@ -65,9 +67,24 @@ protected void initCollections(int size) {
         bestWeightMapTo = new GHIntObjectHashMap<>(size);
     }
 
+    /**
+     * Creates the root shortest path tree entry for the forward or backward search.
+     */
     protected abstract SPTEntry createStartEntry(int node, double weight, boolean reverse);
 
-    protected abstract SPTEntry createEntry(EdgeIteratorState edge, double weight, SPTEntry parent, boolean reverse);
+    /**
+     * Creates a new entry of the shortest path tree (a {@link SPTEntry} or one of its subclasses) during a dijkstra
+     * expansion.
+     *
+     * @param edge    the edge that is currently processed for the expansion
+     * @param incEdge the id of the edge that is incoming to the node the edge is pointed at. usually this is the same as
+     *                edge.getEdge(), but for edge-based CH and in case edge is a shortcut incEdge is the original edge
+     *                that is incoming to the node
+     * @param weight  the weight the shortest path three entry should carry
+     * @param parent  the parent entry of in the shortest path tree
+     * @param reverse true if we are currently looking at the backward search, false otherwise
+     */
+    protected abstract SPTEntry createEntry(EdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse);
 
     @Override
     public Path calcPath(int from, int to) {
@@ -90,6 +107,7 @@ void init(int from, double fromWeight, int to, double toWeight) {
     }
 
     protected void initFrom(int from, double weight) {
+        this.from = from;
         currFrom = createStartEntry(from, weight, false);
         pqOpenSetFrom.add(currFrom);
         if (!traversalMode.isEdgeBased()) {
@@ -98,6 +116,7 @@ protected void initFrom(int from, double weight) {
     }
 
     protected void initTo(int to, double weight) {
+        this.to = to;
         currTo = createStartEntry(to, weight, true);
         pqOpenSetTo.add(currTo);
         if (!traversalMode.isEdgeBased()) {
@@ -113,11 +132,24 @@ protected void postInit(int from, int to) {
             }
         } else if (from == to) {
             // special case of identical start and end
+            if (currFrom.weight != 0 || currTo.weight != 0) {
+                throw new IllegalStateException("If from=to, the starting weight must be zero for from and to");
+            }
             bestPath.sptEntry = currFrom;
             bestPath.edgeTo = currTo;
+            bestPath.setWeight(0);
             finishedFrom = true;
             finishedTo = true;
+            return;
         }
+        postInitFrom();
+        postInitTo();
+    }
+
+    protected void postInitFrom() {
+    }
+
+    protected void postInitTo() {
     }
 
     protected void runAlgo() {
@@ -183,19 +215,20 @@ private void fillEdges(SPTEntry currEdge, PriorityQueue<SPTEntry> prioQueue,
             if (!accept(iter, currEdge, reverse))
                 continue;
 
-            final int origEdgeId = getOrigEdgeId(iter, reverse);
-            final int traversalId = getTraversalId(iter, origEdgeId, reverse);
             final double weight = calcWeight(iter, currEdge, reverse);
-            if (Double.isInfinite(weight))
+            if (Double.isInfinite(weight)) {
                 continue;
+            }
+            final int origEdgeId = getOrigEdgeId(iter, reverse);
+            final int traversalId = getTraversalId(iter, origEdgeId, reverse);
             SPTEntry entry = bestWeightMap.get(traversalId);
             if (entry == null) {
-                entry = createEntry(iter, weight, currEdge, reverse);
+                entry = createEntry(iter, origEdgeId, weight, currEdge, reverse);
                 bestWeightMap.put(traversalId, entry);
                 prioQueue.add(entry);
             } else if (entry.getWeightOfVisitedPath() > weight) {
                 prioQueue.remove(entry);
-                updateEntry(entry, iter, weight, currEdge, reverse);
+                updateEntry(entry, iter, origEdgeId, weight, currEdge, reverse);
                 prioQueue.add(entry);
             } else
                 continue;
@@ -213,16 +246,12 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
         // update μ
         double weight = entry.getWeightOfVisitedPath() + entryOther.getWeightOfVisitedPath();
         if (traversalMode.isEdgeBased()) {
-            if (entryOther.edge != entry.edge)
+            if (getIncomingEdge(entryOther) != getIncomingEdge(entry))
                 throw new IllegalStateException("cannot happen for edge based execution of " + getName());
 
-            if (entryOther.adjNode != entry.adjNode) {
-                // prevents the path to contain the edge at the meeting point twice and subtracts the weight (excluding turn weight => no previous edge)
-                entry = entry.getParent();
-                weight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
-            } else if (!traversalMode.hasUTurnSupport())
-                // we detected a u-turn at meeting point, skip if not supported
-                return;
+            // prevents the path to contain the edge at the meeting point twice and subtracts the weight (excluding turn weight => no previous edge)
+            entry = entry.getParent();
+            weight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
         }
 
         if (weight < bestPath.getWeight()) {
@@ -233,26 +262,30 @@ protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int t
         }
     }
 
-    protected void updateEntry(SPTEntry entry, EdgeIteratorState edge, double weight, SPTEntry parent, boolean reverse) {
+    protected void updateEntry(SPTEntry entry, EdgeIteratorState edge, int edgeId, double weight, SPTEntry parent, boolean reverse) {
         entry.edge = edge.getEdge();
         entry.weight = weight;
         entry.parent = parent;
     }
 
     protected boolean accept(EdgeIteratorState edge, SPTEntry currEdge, boolean reverse) {
-        return accept(edge, currEdge.edge);
+        return accept(edge, getIncomingEdge(currEdge));
     }
 
     protected int getOrigEdgeId(EdgeIteratorState edge, boolean reverse) {
         return edge.getEdge();
     }
 
+    protected int getIncomingEdge(SPTEntry entry) {
+        return entry.edge;
+    }
+
     protected int getTraversalId(EdgeIteratorState edge, int origEdgeId, boolean reverse) {
         return traversalMode.createTraversalId(edge, reverse);
     }
 
     protected double calcWeight(EdgeIteratorState iter, SPTEntry currEdge, boolean reverse) {
-        return weighting.calcWeight(iter, reverse, currEdge.edge) + currEdge.getWeightOfVisitedPath();
+        return weighting.calcWeight(iter, reverse, getIncomingEdge(currEdge)) + currEdge.getWeightOfVisitedPath();
     }
 
     @Override
@@ -313,6 +346,7 @@ public int getVisitedNodes() {
     }
 
     void setFromDataStructures(AbstractBidirAlgo other) {
+        from = other.from;
         pqOpenSetFrom = other.pqOpenSetFrom;
         bestWeightMapFrom = other.bestWeightMapFrom;
         finishedFrom = other.finishedFrom;
@@ -322,6 +356,7 @@ void setFromDataStructures(AbstractBidirAlgo other) {
     }
 
     void setToDataStructures(AbstractBidirAlgo other) {
+        to = other.to;
         pqOpenSetTo = other.pqOpenSetTo;
         bestWeightMapTo = other.bestWeightMapTo;
         finishedTo = other.finishedTo;
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
new file mode 100644
index 0000000000..6e98c7cee6
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/AbstractBidirectionEdgeCHNoSOD.java
@@ -0,0 +1,171 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.CHEntry;
+import com.graphhopper.routing.ch.EdgeBasedPathCH;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+
+/**
+ * @author easbar
+ */
+public abstract class AbstractBidirectionEdgeCHNoSOD extends AbstractBidirAlgo {
+    private final EdgeExplorer innerInExplorer;
+    private final EdgeExplorer innerOutExplorer;
+    private final TurnWeighting turnWeighting;
+
+    public AbstractBidirectionEdgeCHNoSOD(Graph graph, TurnWeighting weighting) {
+        super(graph, weighting, TraversalMode.EDGE_BASED);
+        this.turnWeighting = weighting;
+        // we need extra edge explorers, because they get called inside a loop that already iterates over edges
+        // important: we have to use different filter ids, otherwise this will not work with QueryGraph's edge explorer
+        // cache, see #1623.
+        innerInExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder).setFilterId(1));
+        innerOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder).setFilterId(1));
+        if (!Double.isInfinite(turnWeighting.getUTurnCost())) {
+            throw new IllegalArgumentException("edge-based CH does not support finite u-turn costs at the moment");
+        }
+    }
+
+    @Override
+    protected void postInitFrom() {
+        EdgeFilter filter = additionalEdgeFilter;
+        setEdgeFilter(EdgeFilter.ALL_EDGES);
+        fillEdgesFrom();
+        setEdgeFilter(filter);
+    }
+
+    @Override
+    protected void postInitTo() {
+        EdgeFilter filter = additionalEdgeFilter;
+        setEdgeFilter(EdgeFilter.ALL_EDGES);
+        fillEdgesTo();
+        setEdgeFilter(filter);
+    }
+
+    @Override
+    protected void initCollections(int size) {
+        super.initCollections(Math.min(size, 2000));
+    }
+
+    @Override
+    public boolean finished() {
+        // we need to finish BOTH searches for CH!
+        if (finishedFrom && finishedTo)
+            return true;
+
+        // changed also the final finish condition for CH
+        return currFrom.weight >= bestPath.getWeight() && currTo.weight >= bestPath.getWeight();
+    }
+
+    @Override
+    protected void updateBestPath(EdgeIteratorState edgeState, SPTEntry entry, int traversalId, boolean reverse) {
+        // special case where the fwd/bwd search runs directly into the opposite node, for example if the highest level
+        // node of the shortest path matches the source or target. in this case one of the searches does not contribute
+        // anything to the shortest path.
+        int oppositeNode = reverse ? from : to;
+        if (edgeState.getAdjNode() == oppositeNode) {
+            if (entry.getWeightOfVisitedPath() < bestPath.getWeight()) {
+                bestPath.setSwitchToFrom(reverse);
+                bestPath.setSPTEntry(entry);
+                bestPath.setSPTEntryTo(new CHEntry(oppositeNode, 0));
+                bestPath.setWeight(entry.getWeightOfVisitedPath());
+                return;
+            }
+        }
+
+        // todo: it would be sufficient (and maybe more efficient) to use an original edge explorer here ?
+        EdgeIterator iter = reverse ?
+                innerInExplorer.setBaseNode(edgeState.getAdjNode()) :
+                innerOutExplorer.setBaseNode(edgeState.getAdjNode());
+
+        // todo: for a-star it should be possible to skip bridge node check at the beginning of the search as long as
+        // minimum source-target distance lies above total sum of fwd+bwd path candidates.
+        while (iter.next()) {
+            final int edgeId = getOrigEdgeId(iter, !reverse);
+            final int prevOrNextOrigEdgeId = getOrigEdgeId(edgeState, reverse);
+            int key = GHUtility.getEdgeKey(graph, edgeId, iter.getBaseNode(), !reverse);
+            SPTEntry entryOther = bestWeightMapOther.get(key);
+            if (entryOther == null) {
+                continue;
+            }
+
+            double turnCostsAtBridgeNode = reverse ?
+                    turnWeighting.calcTurnWeight(edgeId, iter.getBaseNode(), prevOrNextOrigEdgeId) :
+                    turnWeighting.calcTurnWeight(prevOrNextOrigEdgeId, iter.getBaseNode(), edgeId);
+
+            double newWeight = entry.getWeightOfVisitedPath() + entryOther.getWeightOfVisitedPath() + turnCostsAtBridgeNode;
+            if (newWeight < bestPath.getWeight()) {
+                bestPath.setSwitchToFrom(reverse);
+                bestPath.setSPTEntry(entry);
+                bestPath.setSPTEntryTo(entryOther);
+                bestPath.setWeight(newWeight);
+            }
+        }
+    }
+
+    @Override
+    protected Path createAndInitPath() {
+        bestPath = new EdgeBasedPathCH(graph, graph.getBaseGraph(), weighting);
+        return bestPath;
+    }
+
+    @Override
+    protected int getOrigEdgeId(EdgeIteratorState edge, boolean reverse) {
+        return reverse ? edge.getOrigEdgeFirst() : edge.getOrigEdgeLast();
+    }
+
+    @Override
+    protected int getIncomingEdge(SPTEntry entry) {
+        return ((CHEntry) entry).incEdge;
+    }
+
+    @Override
+    protected int getTraversalId(EdgeIteratorState edge, int origEdgeId, boolean reverse) {
+        int baseNode = graph.getOtherNode(origEdgeId, edge.getAdjNode());
+        return GHUtility.createEdgeKey(baseNode, edge.getAdjNode(), origEdgeId, reverse);
+    }
+
+    @Override
+    protected boolean accept(EdgeIteratorState edge, SPTEntry currEdge, boolean reverse) {
+        final int incEdge = getIncomingEdge(currEdge);
+        final int prevOrNextEdgeId = getOrigEdgeId(edge, !reverse);
+        double turnWeight = reverse
+                ? turnWeighting.calcTurnWeight(prevOrNextEdgeId, edge.getBaseNode(), incEdge)
+                : turnWeighting.calcTurnWeight(incEdge, edge.getBaseNode(), prevOrNextEdgeId);
+        if (Double.isInfinite(turnWeight)) {
+            return false;
+        }
+        return additionalEdgeFilter == null || additionalEdgeFilter.accept(edge);
+    }
+
+    @Override
+    public String toString() {
+        return getName() + "|" + weighting;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
index 25b7559996..3fa2a68c44 100644
--- a/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
+++ b/core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java
@@ -71,7 +71,9 @@ public RoutingAlgorithm setEdgeFilter(EdgeFilter additionalEdgeFilter) {
     }
 
     protected boolean accept(EdgeIteratorState iter, int prevOrNextEdgeId) {
-        if (!traversalMode.hasUTurnSupport() && iter.getEdge() == prevOrNextEdgeId)
+        // for edge-based traversal we leave it for TurnWeighting to decide whether or not a u-turn is acceptable,
+        // but for node-based traversal we exclude such a turn for performance reasons already here
+        if (!traversalMode.isEdgeBased() && iter.getEdge() == prevOrNextEdgeId)
             return false;
 
         return additionalEdgeFilter == null || additionalEdgeFilter.accept(iter);
diff --git a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
index 38c8097628..145fb56228 100644
--- a/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
+++ b/core/src/main/java/com/graphhopper/routing/AlternativeRoute.java
@@ -17,12 +17,10 @@
  */
 package com.graphhopper.routing;
 
-import com.carrotsearch.hppc.IntObjectMap;
 import com.carrotsearch.hppc.IntSet;
 import com.carrotsearch.hppc.predicates.IntObjectPredicate;
 import com.graphhopper.coll.GHIntHashSet;
 import com.graphhopper.coll.GHIntObjectHashMap;
-import com.graphhopper.routing.AStar.AStarEntry;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.WeightApproximator;
 import com.graphhopper.routing.weighting.Weighting;
@@ -159,7 +157,7 @@ public void setMaxExplorationFactor(double explorationFactor) {
     public void setMaxPaths(int maxPaths) {
         this.maxPaths = maxPaths;
         if (this.maxPaths < 2)
-            throw new IllegalStateException("Use normal algorithm with less overhead instead if no alternatives are required");
+            throw new IllegalArgumentException("Use normal algorithm with less overhead instead if no alternatives are required");
     }
 
     /**
@@ -302,8 +300,8 @@ public Path searchBest(int from, int to) {
                                                       final double maxShareFactor, final double shareInfluence,
                                                       final double minPlateauFactor, final double plateauInfluence) {
             final double maxWeight = maxWeightFactor * bestPath.getWeight();
-            final GHIntObjectHashMap<IntSet> traversalIDMap = new GHIntObjectHashMap<>();
-            final AtomicInteger startTID = addToMap(traversalIDMap, bestPath);
+            final GHIntObjectHashMap<IntSet> traversalIdMap = new GHIntObjectHashMap<>();
+            final AtomicInteger startTID = addToMap(traversalIdMap, bestPath);
 
             // find all 'good' alternatives from forward-SPT matching the backward-SPT and optimize by
             // small total weight (1), small share and big plateau (3a+b) and do these expensive calculations
@@ -467,7 +465,7 @@ SPTEntry getFirstShareEE(SPTEntry startEE, boolean reverse) {
                  */
                 boolean isAlreadyExisting(final int tid) {
                     final AtomicBoolean exists = new AtomicBoolean(false);
-                    traversalIDMap.forEach(new IntObjectPredicate<IntSet>() {
+                    traversalIdMap.forEach(new IntObjectPredicate<IntSet>() {
                         @Override
                         public boolean apply(int key, IntSet set) {
                             if (set.contains(tid)) {
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
index 93a5abb25b..a61eab1061 100644
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
@@ -80,10 +80,11 @@ protected void runAlgo() {
                 if (!accept(iter, currEdge.edge))
                     continue;
 
-                int traversalId = traversalMode.createTraversalId(iter, false);
                 double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;
-                if (Double.isInfinite(tmpWeight))
+                if (Double.isInfinite(tmpWeight)) {
                     continue;
+                }
+                int traversalId = traversalMode.createTraversalId(iter, false);
 
                 SPTEntry nEdge = fromMap.get(traversalId);
                 if (nEdge == null) {
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
index dfca89aef2..a91e137ce1 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java
@@ -18,7 +18,6 @@
 package com.graphhopper.routing;
 
 import com.carrotsearch.hppc.IntObjectMap;
-import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.SPTEntry;
@@ -27,14 +26,16 @@
 
 /**
  * Uses a very simple version of stall-on-demand (SOD) for CH queries to prevent exploring nodes that can not be part
- * of a shortest path. When a node that is about to be settled is stallable it is not expanded, but no further search
- * for neighboring stallable nodes is performed.
+ * of a shortest path. When a node that is about to be settled is stallable it is not expanded. However, no further search
+ * for neighboring stallable nodes is performed (sometimes called 'aggressive' stalling in the literature). Some experimenting
+ * showed that due to the overhead for such aggressive stalling the routing does not become faster, see #240.
  *
- * @author ammagamma
+ * @author easbar
  */
 public class DijkstraBidirectionCH extends DijkstraBidirectionCHNoSOD {
-    public DijkstraBidirectionCH(Graph graph, Weighting weighting, TraversalMode traversalMode) {
-        super(graph, weighting, traversalMode);
+
+    public DijkstraBidirectionCH(Graph graph, Weighting weighting) {
+        super(graph, weighting);
     }
 
     @Override
@@ -63,10 +64,16 @@ private boolean entryIsStallable(SPTEntry entry, IntObjectMap<SPTEntry> bestWeig
         // reached via a suboptimal path. We do this regardless of the CH level of the adjacent nodes.
         EdgeIterator iter = edgeExplorer.setBaseNode(entry.adjNode);
         while (iter.next()) {
+            // no need to inspect the edge we are coming from
+            if (iter.getEdge() == entry.edge) {
+                continue;
+            }
             int traversalId = traversalMode.createTraversalId(iter, reverse);
             SPTEntry adjNode = bestWeightMap.get(traversalId);
+            // we have to be careful because of rounded shortcut weights in combination with virtual via nodes, see #1574
+            final double precision = 0.001;
             if (adjNode != null &&
-                    adjNode.weight + weighting.calcWeight(iter, !reverse, entry.edge) < entry.weight) {
+                    adjNode.weight + weighting.calcWeight(iter, !reverse, getIncomingEdge(entry)) - entry.weight < -precision) {
                 return true;
             }
         }
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java
index 7a5f0499f2..307f1cfe5e 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionCHNoSOD.java
@@ -23,11 +23,8 @@
 import com.graphhopper.storage.Graph;
 
 public class DijkstraBidirectionCHNoSOD extends DijkstraBidirectionRef {
-    public DijkstraBidirectionCHNoSOD(Graph graph, Weighting weighting, TraversalMode traversalMode) {
-        super(graph, weighting, traversalMode);
-        if (traversalMode.isEdgeBased()) {
-            throw new IllegalArgumentException("Edge based traversal is not supported for CH");
-        }
+    public DijkstraBidirectionCHNoSOD(Graph graph, Weighting weighting) {
+        super(graph, weighting, TraversalMode.NODE_BASED);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHNoSOD.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHNoSOD.java
new file mode 100644
index 0000000000..48c705571b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHNoSOD.java
@@ -0,0 +1,59 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.CHEntry;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.EdgeIteratorState;
+
+/**
+ * @author easbar
+ */
+public class DijkstraBidirectionEdgeCHNoSOD extends AbstractBidirectionEdgeCHNoSOD {
+    public DijkstraBidirectionEdgeCHNoSOD(Graph graph, TurnWeighting weighting) {
+        super(graph, weighting);
+    }
+
+    @Override
+    protected CHEntry createStartEntry(int node, double weight, boolean reverse) {
+        return new CHEntry(node, weight);
+    }
+
+    @Override
+    protected CHEntry createEntry(EdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse) {
+        CHEntry entry = new CHEntry(edge.getEdge(), incEdge, edge.getAdjNode(), weight);
+        entry.parent = parent;
+        return entry;
+    }
+
+    @Override
+    protected void updateEntry(SPTEntry entry, EdgeIteratorState edge, int edgeId, double weight, SPTEntry parent, boolean reverse) {
+        entry.edge = edge.getEdge();
+        ((CHEntry) entry).incEdge = edgeId;
+        entry.weight = weight;
+        entry.parent = parent;
+    }
+
+    @Override
+    public String getName() {
+        return "dijkstrabi|ch|edge_based|no_sod";
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
index 96906fd877..11af29cab0 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
@@ -42,7 +42,7 @@ protected SPTEntry createStartEntry(int node, double weight, boolean reverse) {
     }
 
     @Override
-    protected SPTEntry createEntry(EdgeIteratorState edge, double weight, SPTEntry parent, boolean reverse) {
+    protected SPTEntry createEntry(EdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse) {
         SPTEntry entry = new SPTEntry(edge.getEdge(), edge.getAdjNode(), weight);
         entry.parent = parent;
         return entry;
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
index 94ca342dc7..2315fb1a2e 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsFromEdges.java
@@ -17,10 +17,13 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
@@ -40,6 +43,10 @@
 
     private final Translation tr;
     private final InstructionList ways;
+    private final EdgeExplorer outEdgeExplorer;
+    private final EdgeExplorer crossingExplorer;
+    private final BooleanEncodedValue roundaboutEnc;
+    private final BooleanEncodedValue accessEnc;
     /*
      * We need three points to make directions
      *
@@ -72,14 +79,16 @@
     private String prevName;
     private String prevInstructionName;
     private InstructionAnnotation prevAnnotation;
-    private EdgeExplorer outEdgeExplorer;
-    private EdgeExplorer crossingExplorer;
 
     private final int MAX_U_TURN_DISTANCE = 35;
 
-    public InstructionsFromEdges(int tmpNode, Graph graph, Weighting weighting, FlagEncoder encoder, NodeAccess nodeAccess, Translation tr, InstructionList ways) {
+    public InstructionsFromEdges(int tmpNode, Graph graph, Weighting weighting, FlagEncoder encoder,
+                                 BooleanEncodedValue roundaboutEnc, NodeAccess nodeAccess,
+                                 Translation tr, InstructionList ways) {
         this.weighting = weighting;
         this.encoder = encoder;
+        this.accessEnc = encoder.getAccessEnc();
+        this.roundaboutEnc = roundaboutEnc;
         this.nodeAccess = nodeAccess;
         this.tr = tr;
         this.ways = ways;
@@ -98,13 +107,13 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
         // baseNode is the current node and adjNode is the next
         int adjNode = edge.getAdjNode();
         int baseNode = edge.getBaseNode();
-        long flags = edge.getFlags();
+        IntsRef flags = edge.getFlags();
         double adjLat = nodeAccess.getLatitude(adjNode);
         double adjLon = nodeAccess.getLongitude(adjNode);
         double latitude, longitude;
 
         PointList wayGeo = edge.fetchWayGeometry(3);
-        boolean isRoundabout = encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT);
+        boolean isRoundabout = roundaboutEnc.getBool(false, flags);
 
         if (wayGeo.getSize() <= 2) {
             latitude = adjLat;
@@ -144,7 +153,7 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
                     EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(baseNode);
                     while (edgeIter.next()) {
                         if ((edgeIter.getAdjNode() != prevNode)
-                                && !encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT)) {
+                                && !roundaboutEnc.getBool(false, edgeIter.getFlags())) {
                             roundaboutInstruction.increaseExitNumber();
                             break;
                         }
@@ -174,7 +183,7 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
             // out of the roundabout
             EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(edge.getAdjNode());
             while (edgeIter.next()) {
-                if (!encoder.isBool(edgeIter.getFlags(), FlagEncoder.K_ROUNDABOUT)) {
+                if (!roundaboutEnc.getBool(false, edgeIter.getFlags())) {
                     ((RoundaboutInstruction) prevInstruction).increaseExitNumber();
                     break;
                 }
@@ -228,7 +237,7 @@ public void next(EdgeIteratorState edge, int index, int prevEdgeId) {
                         && (sign < 0) == (prevInstruction.getSign() < 0)
                         && (Math.abs(sign) == Instruction.TURN_SLIGHT_RIGHT || Math.abs(sign) == Instruction.TURN_RIGHT || Math.abs(sign) == Instruction.TURN_SHARP_RIGHT)
                         && (Math.abs(prevInstruction.getSign()) == Instruction.TURN_SLIGHT_RIGHT || Math.abs(prevInstruction.getSign()) == Instruction.TURN_RIGHT || Math.abs(prevInstruction.getSign()) == Instruction.TURN_SHARP_RIGHT)
-                        && edge.isForward(encoder) != edge.isBackward(encoder)
+                        && edge.get(accessEnc) != edge.getReverse(accessEnc)
                         && InstructionsHelper.isNameSimilar(prevInstructionName, name)) {
                     // Chances are good that this is a u-turn, we only need to check if the orientation matches
                     GHPoint point = InstructionsHelper.getPointForOrientationCalculation(edge, nodeAccess);
@@ -330,10 +339,10 @@ private int getTurn(EdgeIteratorState edge, int baseNode, int prevNode, int adjN
 
         // Very certain, this is a turn
         if (Math.abs(sign) > 1) {
-                        /*
-                         * Don't show an instruction if the user is following a street, even though the street is
-                         * bending. We should only do this, if following the street is the obvious choice.
-                         */
+            /*
+             * Don't show an instruction if the user is following a street, even though the street is
+             * bending. We should only do this, if following the street is the obvious choice.
+             */
             if (InstructionsHelper.isNameSimilar(name, prevName) && outgoingEdges.outgoingEdgesAreSlowerByFactor(2)) {
                 return returnForcedInstructionOrIgnore(forceInstruction, sign);
             }
@@ -352,8 +361,8 @@ private int getTurn(EdgeIteratorState edge, int baseNode, int prevNode, int adjN
             return sign;
         }
 
-        long flag = edge.getFlags();
-        long prevFlag = prevEdge.getFlags();
+        IntsRef flag = edge.getFlags();
+        IntsRef prevFlag = prevEdge.getFlags();
 
         boolean outgoingEdgesAreSlower = outgoingEdges.outgoingEdgesAreSlowerByFactor(1);
 
@@ -372,8 +381,8 @@ private int getTurn(EdgeIteratorState edge, int baseNode, int prevNode, int adjN
             //We are at a fork
             if (!InstructionsHelper.isNameSimilar(name, prevName)
                     || InstructionsHelper.isNameSimilar(otherContinue.getName(), prevName)
-                    || prevFlag != flag
-                    || prevFlag == otherContinue.getFlags()
+                    || !prevFlag.equals(flag)
+                    || prevFlag.equals(otherContinue.getFlags())
                     || !outgoingEdgesAreSlower) {
                 GHPoint tmpPoint = InstructionsHelper.getPointForOrientationCalculation(otherContinue, nodeAccess);
                 double otherDelta = InstructionsHelper.calculateOrientationDelta(prevLat, prevLon, tmpPoint.getLat(), tmpPoint.getLon(), prevOrientation);
diff --git a/core/src/main/java/com/graphhopper/routing/InstructionsOutgoingEdges.java b/core/src/main/java/com/graphhopper/routing/InstructionsOutgoingEdges.java
index 023567bad5..cbd03f0ea3 100644
--- a/core/src/main/java/com/graphhopper/routing/InstructionsOutgoingEdges.java
+++ b/core/src/main/java/com/graphhopper/routing/InstructionsOutgoingEdges.java
@@ -17,8 +17,12 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.MaxSpeed;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
@@ -30,22 +34,19 @@
 
 /**
  * This class handles the outgoing edges for a single turn instruction.
- *
  * There are different sets of edges.
  * The previous edge is the edge we are coming from.
  * The current edge is the edge we turn on.
  * The allowedOutgoingEdges contains all edges that the current vehicle is allowed(*) to turn on to, excluding the prev edge and the current edge.
  * The allOutgoingEdges contains all edges surrounding this turn instruction, without the prev edge and the current edge.
- *
  * (*): This might not consider turn restrictions, but only simple access values.
- *
  * Here is an example:
- *
+ * <pre>
  * A --> B --> C
  *       ^
  *       |
  *       X
- *
+ * </pre>
  * For the route from A->B->C and baseNode=B, adjacentNode=C:
  * - the previous edge is A->B
  * - the current edge is B->C
@@ -66,6 +67,8 @@
     final List<EdgeIteratorState> allOutgoingEdges;
 
     final FlagEncoder encoder;
+    final BooleanEncodedValue accessEnc;
+    final DecimalEncodedValue speedEnc;
     final NodeAccess nodeAccess;
 
     public InstructionsOutgoingEdges(EdgeIteratorState prevEdge,
@@ -79,6 +82,8 @@ public InstructionsOutgoingEdges(EdgeIteratorState prevEdge,
         this.prevEdge = prevEdge;
         this.currentEdge = currentEdge;
         this.encoder = encoder;
+        this.accessEnc = encoder.getAccessEnc();
+        this.speedEnc = (encoder instanceof DataFlagEncoder) ? encoder.getDecimalEncodedValue(MaxSpeed.KEY) : encoder.getAverageSpeedEnc();
         this.nodeAccess = nodeAccess;
 
         EdgeIteratorState tmpEdge;
@@ -90,7 +95,7 @@ public InstructionsOutgoingEdges(EdgeIteratorState prevEdge,
             if (edgeIter.getAdjNode() != prevNode && edgeIter.getAdjNode() != adjNode) {
                 tmpEdge = edgeIter.detach(false);
                 allOutgoingEdges.add(tmpEdge);
-                if (encoder.isForward(tmpEdge.getFlags())) {
+                if (tmpEdge.get(accessEnc)) {
                     allowedOutgoingEdges.add(tmpEdge);
                 }
             }
@@ -145,11 +150,7 @@ public boolean outgoingEdgesAreSlowerByFactor(double factor) {
     }
 
     private double getSpeed(EdgeIteratorState edge) {
-        if (encoder instanceof DataFlagEncoder) {
-            return ((DataFlagEncoder) encoder).getMaxspeed(edge, 0, false);
-        } else {
-            return encoder.getSpeed(edge.getFlags());
-        }
+        return edge.get(speedEnc);
     }
 
     /**
@@ -183,7 +184,7 @@ public boolean isLeavingCurrentStreet(String prevName, String name) {
         boolean checkFlag = currentEdge.getFlags() != prevEdge.getFlags();
         for (EdgeIteratorState edge : allowedOutgoingEdges) {
             String edgeName = edge.getName();
-            long edgeFlag = edge.getFlags();
+            IntsRef edgeFlag = edge.getFlags();
             // leave the current street || enter a different street
             if (isTheSameStreet(prevName, prevEdge.getFlags(), edgeName, edgeFlag, checkFlag)
                     || isTheSameStreet(name, currentEdge.getFlags(), edgeName, edgeFlag, checkFlag)) {
@@ -193,9 +194,9 @@ public boolean isLeavingCurrentStreet(String prevName, String name) {
         return false;
     }
 
-    private boolean isTheSameStreet(String name1, long flags1, String name2, long flags2, boolean checkFlag) {
+    private boolean isTheSameStreet(String name1, IntsRef flags1, String name2, IntsRef flags2, boolean checkFlag) {
         if (InstructionsHelper.isNameSimilar(name1, name2)) {
-            if (!checkFlag || flags1 == flags2) {
+            if (!checkFlag || flags1.equals(flags2)) {
                 return true;
             }
         }
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index b8e1bd8fac..f3fe8c9855 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -20,6 +20,7 @@
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.coll.GHIntArrayList;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
@@ -233,8 +234,7 @@ public String getDebugInfo() {
     /**
      * Calculates the distance and time of the specified edgeId. Also it adds the edgeId to the path list.
      *
-     * @param prevEdgeId here the edge that comes before edgeId is necessary. I.e. for the reverse search we need the
-     *                   next edge.
+     * @param prevEdgeId the edge that comes before edgeId: --prevEdgeId-x-edgeId-->adjNode
      */
     protected void processEdge(int edgeId, int adjNode, int prevEdgeId) {
         EdgeIteratorState iter = graph.getEdgeIteratorState(edgeId, adjNode);
@@ -358,7 +358,7 @@ public void finish() {
     /**
      * @return the list of instructions for this path.
      */
-    public InstructionList calcInstructions(final Translation tr) {
+    public InstructionList calcInstructions(BooleanEncodedValue roundaboutEnc, final Translation tr) {
         final InstructionList ways = new InstructionList(edgeIds.size() / 4, tr);
         if (edgeIds.isEmpty()) {
             if (isFound()) {
@@ -366,7 +366,7 @@ public InstructionList calcInstructions(final Translation tr) {
             }
             return ways;
         }
-        forEveryEdge(new InstructionsFromEdges(getFromNode(), graph, weighting, encoder, nodeAccess, tr, ways));
+        forEveryEdge(new InstructionsFromEdges(getFromNode(), graph, weighting, encoder, roundaboutEnc, nodeAccess, tr, ways));
         return ways;
     }
 
@@ -378,10 +378,10 @@ public InstructionList calcInstructions(final Translation tr) {
      */
     public Map<String, List<PathDetail>> calcDetails(List<String> requestedPathDetails, PathDetailsBuilderFactory pathBuilderFactory, int previousIndex) {
         if (!isFound() || requestedPathDetails.isEmpty())
-            return Collections.EMPTY_MAP;
+            return Collections.emptyMap();
         List<PathDetailsBuilder> pathBuilders = pathBuilderFactory.createPathDetailsBuilders(requestedPathDetails, encoder, weighting);
         if (pathBuilders.isEmpty())
-            return Collections.EMPTY_MAP;
+            return Collections.emptyMap();
 
         forEveryEdge(new PathDetailsFromEdges(pathBuilders, previousIndex));
 
@@ -398,7 +398,7 @@ public InstructionList calcInstructions(final Translation tr) {
 
     @Override
     public String toString() {
-        return "distance:" + getDistance() + ", edges:" + edgeIds.size();
+        return "found: " + found + ", weight: " + weight + ", time: " + time + ", distance: " + distance + ", edges: " + edgeIds.size();
     }
 
     public String toDetailsString() {
diff --git a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
index 684ecc9dd5..cc5dc96c48 100644
--- a/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
+++ b/core/src/main/java/com/graphhopper/routing/PathBidirRef.java
@@ -17,10 +17,12 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * This class creates a DijkstraPath from two Edge's resulting from a BidirectionalDijkstra
@@ -69,30 +71,65 @@ public Path extract() {
             sptEntry = edgeTo;
             edgeTo = ee;
         }
+        extractFwdPath();
+        processTurnAtMeetingPoint();
+        extractBwdPath();
+        extractSW.stop();
+        return setFound(true);
+    }
+
+    private void extractFwdPath() {
+        // we take the 'edgeFrom'/sptEntry that points at the meeting node and follow its parent pointers back to
+        // the source
         SPTEntry currEdge = sptEntry;
-        boolean nextEdgeValid = EdgeIterator.Edge.isValid(currEdge.edge);
-        int nextEdge;
-        while (nextEdgeValid) {
-            // the reverse search needs the next edge
-            nextEdgeValid = EdgeIterator.Edge.isValid(currEdge.parent.edge);
-            nextEdge = nextEdgeValid ? currEdge.parent.edge : EdgeIterator.NO_EDGE;
-            processEdge(currEdge.edge, currEdge.adjNode, nextEdge);
-            currEdge = currEdge.parent;
+        SPTEntry prevEdge = currEdge.parent;
+        while (EdgeIterator.Edge.isValid(currEdge.edge)) {
+            processEdge(currEdge.edge, currEdge.adjNode, getIncEdge(prevEdge));
+            currEdge = prevEdge;
+            prevEdge = currEdge.parent;
         }
-
         setFromNode(currEdge.adjNode);
+        // since we followed the fwd path in backward direction we need to reverse the edge ids
         reverseOrder();
-        currEdge = edgeTo;
-        int prevEdge = nextEdgeValid ? sptEntry.edge : EdgeIterator.NO_EDGE;
-        int tmpEdge = currEdge.edge;
-        while (EdgeIterator.Edge.isValid(tmpEdge)) {
-            currEdge = currEdge.parent;
-            processEdge(tmpEdge, currEdge.adjNode, prevEdge);
-            prevEdge = tmpEdge;
-            tmpEdge = currEdge.edge;
+    }
+
+    private void extractBwdPath() {
+        // we take the edgeTo at the meeting node and follow its parent pointers to the target
+        SPTEntry currEdge = edgeTo;
+        SPTEntry nextEdge = currEdge.parent;
+        while (EdgeIterator.Edge.isValid(currEdge.edge)) {
+            processEdgeBwd(currEdge.edge, currEdge.adjNode, getIncEdge(nextEdge));
+            currEdge = nextEdge;
+            nextEdge = nextEdge.parent;
         }
         setEndNode(currEdge.adjNode);
-        extractSW.stop();
-        return setFound(true);
+    }
+
+    private void processTurnAtMeetingPoint() {
+        processTurn(getIncEdge(sptEntry), sptEntry.adjNode, getIncEdge(edgeTo));
+    }
+
+    /**
+     * Similar to {@link #processEdge(int, int, int)}, but with the situation we encounter when doing a backward
+     * search: nextEdgeId--x<--edgeId--adjNode
+     */
+    protected void processEdgeBwd(int edgeId, int adjNode, int nextEdgeId) {
+        EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, adjNode);
+        distance += edge.getDistance();
+        time += weighting.calcMillis(edge, true, nextEdgeId);
+        addEdge(edgeId);
+    }
+
+    private void processTurn(int inEdge, int viaNode, int outEdge) {
+        if (!EdgeIterator.Edge.isValid(inEdge) || !EdgeIterator.Edge.isValid(outEdge)) {
+            return;
+        }
+        if (weighting instanceof TurnWeighting) {
+            time += ((TurnWeighting) weighting).calcTurnWeight(inEdge, viaNode, outEdge) * 1000;
+        }
+    }
+
+    protected int getIncEdge(SPTEntry entry) {
+        return entry.edge;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/QueryGraph.java b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
index ae484a4d38..09f4ac8d93 100644
--- a/core/src/main/java/com/graphhopper/routing/QueryGraph.java
+++ b/core/src/main/java/com/graphhopper/routing/QueryGraph.java
@@ -24,12 +24,8 @@
 import com.graphhopper.coll.GHIntHashSet;
 import com.graphhopper.coll.GHIntObjectHashMap;
 import com.graphhopper.routing.util.AllEdgesIterator;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphExtension;
-import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -60,8 +56,7 @@
     private final int mainEdges;
     private final QueryGraph baseGraph;
     private final GraphExtension wrappedExtension;
-    // TODO when spreading it on different threads we need multiple independent explorers
-    private final Map<Integer, EdgeExplorer> cacheMap = new HashMap<>(4);
+    private final Map<EdgeFilter, EdgeExplorer> cacheMap = new HashMap<>(4);
 
     // For every virtual node there are 4 edges: base-snap, snap-base, snap-adj, adj-snap.
     List<VirtualEdgeIteratorState> virtualEdges;
@@ -276,34 +271,28 @@ public boolean apply(int edgeId, List<QueryResult> results) {
                 EdgeIteratorState closestEdge = results.get(0).getClosestEdge();
                 final PointList fullPL = closestEdge.fetchWayGeometry(3);
                 int baseNode = closestEdge.getBaseNode();
-                // sort results on the same edge by the wayIndex and if equal by distance to pillar node
                 Collections.sort(results, new Comparator<QueryResult>() {
                     @Override
                     public int compare(QueryResult o1, QueryResult o2) {
-                        int diff = o1.getWayIndex() - o2.getWayIndex();
+                        int diff = Integer.compare(o1.getWayIndex(), o2.getWayIndex());
                         if (diff == 0) {
-                            // sort by distance from snappedPoint to fullPL.get(wayIndex) if wayIndex is identical
-                            GHPoint p1 = o1.getSnappedPoint();
-                            GHPoint p2 = o2.getSnappedPoint();
-                            if (p1.equals(p2))
-                                return 0;
-
-                            double fromLat = fullPL.getLatitude(o1.getWayIndex());
-                            double fromLon = fullPL.getLongitude(o1.getWayIndex());
-                            if (Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p1.lat, p1.lon)
-                                    > Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, p2.lat, p2.lon))
-                                return 1;
-                            return -1;
+                            return Double.compare(distanceOfSnappedPointToPillarNode(o1), distanceOfSnappedPointToPillarNode(o2));
+                        } else {
+                            return diff;
                         }
-                        return diff;
+                    }
+                    private double distanceOfSnappedPointToPillarNode(QueryResult o) {
+                        GHPoint snappedPoint = o.getSnappedPoint();
+                        double fromLat = fullPL.getLatitude(o.getWayIndex());
+                        double fromLon = fullPL.getLongitude(o.getWayIndex());
+                        return Helper.DIST_PLANE.calcNormalizedDist(fromLat, fromLon, snappedPoint.lat, snappedPoint.lon);
                     }
                 });
 
-                GHPoint3D prevPoint = fullPL.toGHPoint(0);
+                GHPoint3D prevPoint = fullPL.get(0);
                 int adjNode = closestEdge.getAdjNode();
-                int origTraversalKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), false);
-                int origRevTraversalKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), true);
-                long reverseFlags = closestEdge.detach(true).getFlags();
+                int origEdgeKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), false);
+                int origRevEdgeKey = GHUtility.createEdgeKey(baseNode, adjNode, closestEdge.getEdge(), true);
                 int prevWayIndex = 1;
                 int prevNodeId = baseNode;
                 int virtNodeId = virtualNodes.getSize() + mainNodes;
@@ -312,8 +301,7 @@ public int compare(QueryResult o1, QueryResult o2) {
                 // Create base and adjacent PointLists for all none-equal virtual nodes.
                 // We do so via inserting them at the correct position of fullPL and cutting the
                 // fullPL into the right pieces.
-                for (int counter = 0; counter < results.size(); counter++) {
-                    QueryResult res = results.get(counter);
+                for (QueryResult res : results) {
                     if (res.getClosestEdge().getBaseNode() != baseNode)
                         throw new IllegalStateException("Base nodes have to be identical but were not: " + closestEdge + " vs " + res.getClosestEdge());
 
@@ -326,10 +314,11 @@ public int compare(QueryResult o1, QueryResult o2) {
                     }
 
                     queryResults.add(res);
-                    createEdges(origTraversalKey, origRevTraversalKey,
-                            prevPoint, prevWayIndex,
+                    boolean isPillar = res.getSnappedPosition() == QueryResult.Position.PILLAR;
+                    createEdges(origEdgeKey, origRevEdgeKey,
+                            prevPoint, prevWayIndex, isPillar,
                             res.getSnappedPoint(), res.getWayIndex(),
-                            fullPL, closestEdge, prevNodeId, virtNodeId, reverseFlags);
+                            fullPL, closestEdge, prevNodeId, virtNodeId);
 
                     virtualNodes.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
 
@@ -349,10 +338,10 @@ public int compare(QueryResult o1, QueryResult o2) {
 
                 // two edges between last result and adjacent node are still missing if not all points skipped
                 if (addedEdges)
-                    createEdges(origTraversalKey, origRevTraversalKey,
-                            prevPoint, prevWayIndex,
-                            fullPL.toGHPoint(fullPL.getSize() - 1), fullPL.getSize() - 2,
-                            fullPL, closestEdge, virtNodeId - 1, adjNode, reverseFlags);
+                    createEdges(origEdgeKey, origRevEdgeKey,
+                            prevPoint, prevWayIndex, false,
+                            fullPL.get(fullPL.getSize() - 1), fullPL.getSize() - 2,
+                            fullPL, closestEdge, virtNodeId - 1, adjNode);
 
                 return true;
             }
@@ -381,11 +370,11 @@ public boolean isVirtualNode(int nodeId) {
 
     /**
      * This method is an experimental feature to reduce memory and CPU resources if there are many
-     * locations ("hundreds") for one QueryGraph. It can make problems for custom or threaded
-     * algorithms or when using custom EdgeFilters for EdgeExplorer creation. Another limitation is
-     * that the same edge explorer is used even if a different vehicle/flagEncoder is chosen.
-     * Currently we can cache only the ALL_EDGES filter or instances of the DefaultEdgeFilter where
-     * three edge explorers will be created: forward OR backward OR both.
+     * locations ("hundreds") for one QueryGraph. EdgeExplorer instances are cached based on the {@link EdgeFilter}
+     * passed into {@link #createEdgeExplorer(EdgeFilter)}. For equal (in the java sense) {@link EdgeFilter}s always
+     * the same {@link EdgeExplorer} will be returned when caching is enabled. Care has to be taken for example for
+     * custom or threaded algorithms, when using custom {@link EdgeFilter}s, or when the same edge explorer is used
+     * with different vehicles/encoders.
      */
     public QueryGraph setUseEdgeExplorerCache(boolean useEECache) {
         this.useEdgeExplorerCache = useEECache;
@@ -393,28 +382,33 @@ public QueryGraph setUseEdgeExplorerCache(boolean useEECache) {
         return this;
     }
 
-    private void createEdges(int origTraversalKey, int origRevTraversalKey,
-                             GHPoint3D prevSnapped, int prevWayIndex, GHPoint3D currSnapped, int wayIndex,
+    private void createEdges(int origEdgeKey, int origRevEdgeKey,
+                             GHPoint3D prevSnapped, int prevWayIndex, boolean isPillar, GHPoint3D currSnapped, int wayIndex,
                              PointList fullPL, EdgeIteratorState closestEdge,
-                             int prevNodeId, int nodeId, long reverseFlags) {
+                             int prevNodeId, int nodeId) {
         int max = wayIndex + 1;
-        // basePoints must have at least the size of 2 to make sure fetchWayGeometry(3) returns at least 2
         PointList basePoints = new PointList(max - prevWayIndex + 1, mainNodeAccess.is3D());
         basePoints.add(prevSnapped.lat, prevSnapped.lon, prevSnapped.ele);
         for (int i = prevWayIndex; i < max; i++) {
             basePoints.add(fullPL, i);
         }
-        basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
+        if (!isPillar) {
+            basePoints.add(currSnapped.lat, currSnapped.lon, currSnapped.ele);
+        }
+        // basePoints must have at least the size of 2 to make sure fetchWayGeometry(3) returns at least 2
+        assert basePoints.size() >= 2 : "basePoints must have at least two points";
 
         PointList baseReversePoints = basePoints.clone(true);
         double baseDistance = basePoints.calcDistance(Helper.DIST_PLANE);
         int virtEdgeId = mainEdges + virtualEdges.size();
 
+        boolean reverse = closestEdge.get(EdgeIteratorState.REVERSE_STATE);
         // edges between base and snapped point
-        VirtualEdgeIteratorState baseEdge = new VirtualEdgeIteratorState(origTraversalKey,
-                virtEdgeId, prevNodeId, nodeId, baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints);
-        VirtualEdgeIteratorState baseReverseEdge = new VirtualEdgeIteratorState(origRevTraversalKey,
-                virtEdgeId, nodeId, prevNodeId, baseDistance, reverseFlags, closestEdge.getName(), baseReversePoints);
+        VirtualEdgeIteratorState baseEdge = new VirtualEdgeIteratorState(origEdgeKey,
+                virtEdgeId, prevNodeId, nodeId, baseDistance, closestEdge.getFlags(), closestEdge.getName(), basePoints, reverse);
+        VirtualEdgeIteratorState baseReverseEdge = new VirtualEdgeIteratorState(origRevEdgeKey,
+                virtEdgeId, nodeId, prevNodeId, baseDistance, IntsRef.deepCopyOf(closestEdge.getFlags()), closestEdge.getName(), baseReversePoints, !reverse);
+
         baseEdge.setReverseEdge(baseReverseEdge);
         baseReverseEdge.setReverseEdge(baseEdge);
         virtualEdges.add(baseEdge);
@@ -486,8 +480,8 @@ public boolean enforceHeading(int nodeId, double favoredHeading, boolean incomin
      * the other adjacent node of virtualNodeId.
      * <p>
      *
-     * @param virtualNodeId  virtual node at which edges get unfavored
-     * @param virtualEdgeId  this edge and the reverse virtual edge become unfavored
+     * @param virtualNodeId virtual node at which edges get unfavored
+     * @param virtualEdgeId this edge and the reverse virtual edge become unfavored
      */
     public void unfavorVirtualEdgePair(int virtualNodeId, int virtualEdgeId) {
         if (!isVirtualNode(virtualNodeId)) {
@@ -530,6 +524,11 @@ public int getNodes() {
         return virtualNodes.getSize() + mainNodes;
     }
 
+    @Override
+    public int getEdges() {
+        return virtualEdges.size() + mainEdges;
+    }
+
     @Override
     public NodeAccess getNodeAccess() {
         return nodeAccess;
@@ -574,32 +573,15 @@ public EdgeExplorer createEdgeExplorer(final EdgeFilter edgeFilter) {
             throw new IllegalStateException("Call lookup before using this graph");
 
         if (useEdgeExplorerCache) {
-            int counter = -1;
-            if (edgeFilter instanceof DefaultEdgeFilter) {
-                DefaultEdgeFilter dee = (DefaultEdgeFilter) edgeFilter;
-                counter = 0;
-                if (dee.acceptsBackward())
-                    counter = 1;
-                if (dee.acceptsForward())
-                    counter += 2;
-
-                if (counter == 0)
-                    throw new IllegalStateException("You tried to use an edge filter blocking every access");
-
-            } else if (edgeFilter == EdgeFilter.ALL_EDGES) {
-                counter = 4;
-            }
-
-            if (counter >= 0) {
-                EdgeExplorer cached = cacheMap.get(counter);
-                if (cached == null) {
-                    cached = createUncachedEdgeExplorer(edgeFilter);
-                    cacheMap.put(counter, cached);
-                }
-                return cached;
+            EdgeExplorer cached = cacheMap.get(edgeFilter);
+            if (cached == null) {
+                cached = createUncachedEdgeExplorer(edgeFilter);
+                cacheMap.put(edgeFilter, cached);
             }
+            return cached;
+        } else {
+            return createUncachedEdgeExplorer(edgeFilter);
         }
-        return createUncachedEdgeExplorer(edgeFilter);
     }
 
     private EdgeExplorer createUncachedEdgeExplorer(EdgeFilter edgeFilter) {
@@ -707,9 +689,6 @@ private boolean isInitialized() {
     }
 
     @Override
-    /**
-     * @see QueryGraph
-     */
     public EdgeExplorer createEdgeExplorer() {
         return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
@@ -743,6 +722,23 @@ public GraphExtension getExtension() {
         return wrappedExtension;
     }
 
+    @Override
+    public int getOtherNode(int edge, int node) {
+        if (isVirtualEdge(edge)) {
+            return getEdgeIteratorState(edge, node).getBaseNode();
+        }
+        return mainGraph.getOtherNode(edge, node);
+    }
+
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        if (isVirtualEdge(edge)) {
+            EdgeIteratorState virtualEdge = getEdgeIteratorState(edge, node);
+            return virtualEdge.getBaseNode() == node || virtualEdge.getAdjNode() == node;
+        }
+        return mainGraph.isAdjacentToNode(edge, node);
+    }
+
     private UnsupportedOperationException exc() {
         return new UnsupportedOperationException("QueryGraph cannot be modified.");
     }
@@ -760,16 +756,32 @@ public long getTurnCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
                 return 0;
             } else if (isVirtualEdge(edgeFrom) || isVirtualEdge(edgeTo)) {
                 if (isVirtualEdge(edgeFrom)) {
-                    edgeFrom = queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+                    edgeFrom = getOriginalEdge(edgeFrom);
                 }
                 if (isVirtualEdge(edgeTo)) {
-                    edgeTo = queryResults.get((edgeTo - mainEdges) / 4).getClosestEdge().getEdge();
+                    edgeTo = getOriginalEdge(edgeTo);
                 }
                 return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
-
             } else {
                 return mainTurnExtension.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
             }
         }
+
+        @Override
+        public boolean isUTurn(int edgeFrom, int edgeTo) {
+            // detecting a u-turn from a virtual to a non-virtual edge requires looking at the original edge of the
+            // virtual edge. however when we are turning between virtual edges we need to compare the virtual edge ids
+            // see #1593
+            if (isVirtualEdge(edgeFrom) && !isVirtualEdge(edgeTo)) {
+                edgeFrom = getOriginalEdge(edgeFrom);
+            } else if (!isVirtualEdge(edgeFrom) && isVirtualEdge(edgeTo)) {
+                edgeTo = getOriginalEdge(edgeTo);
+            }
+            return mainTurnExtension.isUTurn(edgeFrom, edgeTo);
+        }
+
+        private int getOriginalEdge(int edgeFrom) {
+            return queryResults.get((edgeFrom - mainEdges) / 4).getClosestEdge().getEdge();
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
index 70e5d87e29..0393696503 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIterator.java
@@ -17,7 +17,11 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.IntEncodedValue;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -100,58 +104,135 @@ public EdgeIteratorState setDistance(double dist) {
     }
 
     @Override
-    public long getFlags() {
+    public IntsRef getFlags() {
         return edges.get(current).getFlags();
     }
 
     @Override
-    public EdgeIteratorState setFlags(long flags) {
+    public EdgeIteratorState setFlags(IntsRef flags) {
         return edges.get(current).setFlags(flags);
     }
 
     @Override
-    public String getName() {
-        return edges.get(current).getName();
+    public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
+        edges.get(current).set(property, value);
+        return this;
     }
 
     @Override
-    public EdgeIteratorState setName(String name) {
-        return edges.get(current).setName(name);
+    public boolean get(BooleanEncodedValue property) {
+        return edges.get(current).get(property);
     }
 
     @Override
-    public boolean getBool(int key, boolean _default) {
-        return edges.get(current).getBool(key, _default);
+    public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+        edges.get(current).setReverse(property, value);
+        return this;
     }
 
     @Override
-    public String toString() {
-        return edges.toString();
+    public boolean getReverse(BooleanEncodedValue property) {
+        return edges.get(current).getReverse(property);
     }
 
     @Override
-    public int getAdditionalField() {
-        return edges.get(current).getAdditionalField();
+    public EdgeIteratorState set(IntEncodedValue property, int value) {
+        edges.get(current).set(property, value);
+        return this;
     }
 
     @Override
-    public EdgeIteratorState setAdditionalField(int value) {
-        return edges.get(current).setAdditionalField(value);
+    public int get(IntEncodedValue property) {
+        return edges.get(current).get(property);
+    }
+
+    @Override
+    public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+        edges.get(current).setReverse(property, value);
+        return this;
+    }
+
+    @Override
+    public int getReverse(IntEncodedValue property) {
+        return edges.get(current).getReverse(property);
+    }
+
+    @Override
+    public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+        edges.get(current).set(property, value);
+        return this;
+    }
+
+    @Override
+    public double get(DecimalEncodedValue property) {
+        return edges.get(current).get(property);
+    }
+
+    @Override
+    public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+        edges.get(current).setReverse(property, value);
+        return this;
+    }
+
+    @Override
+    public double getReverse(DecimalEncodedValue property) {
+        return edges.get(current).getReverse(property);
+    }
+
+    @Override
+    public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+        edges.get(current).set(property, value);
+        return this;
+    }
+
+    @Override
+    public <T extends Enum> T get(EnumEncodedValue<T> property) {
+        return edges.get(current).get(property);
+    }
+
+    @Override
+    public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
+        edges.get(current).setReverse(property, value);
+        return this;
+    }
+
+    @Override
+    public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+        return edges.get(current).getReverse(property);
+    }
+
+    @Override
+    public String getName() {
+        return edges.get(current).getName();
     }
 
     @Override
-    public EdgeIteratorState copyPropertiesTo(EdgeIteratorState edge) {
-        return edges.get(current).copyPropertiesTo(edge);
+    public EdgeIteratorState setName(String name) {
+        return edges.get(current).setName(name);
     }
 
     @Override
-    public boolean isBackward(FlagEncoder encoder) {
-        return edges.get(current).isBackward(encoder);
+    public String toString() {
+        if (current >= 0 && current < edges.size()) {
+            return "virtual edge: " + edges.get(current) + ", all: " + edges.toString();
+        } else {
+            return "virtual edge: (invalid)" + ", all: " + edges.toString();
+        }
     }
 
     @Override
-    public boolean isForward(FlagEncoder encoder) {
-        return edges.get(current).isForward(encoder);
+    public int getAdditionalField() {
+        return edges.get(current).getAdditionalField();
+    }
+
+    @Override
+    public EdgeIteratorState setAdditionalField(int value) {
+        return edges.get(current).setAdditionalField(value);
+    }
+
+    @Override
+    public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState edge) {
+        return edges.get(current).copyPropertiesFrom(edge);
     }
 
     @Override
@@ -171,6 +252,11 @@ public CHEdgeIteratorState setWeight(double weight) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    @Override
+    public void setFlagsAndWeight(int flags, double weight) {
+        throw new UnsupportedOperationException("Not supported");
+    }
+
     @Override
     public int getSkippedEdge1() {
         throw new UnsupportedOperationException("Not supported.");
@@ -182,12 +268,27 @@ public int getSkippedEdge2() {
     }
 
     @Override
-    public void setSkippedEdges(int edge1, int edge2) {
+    public CHEdgeIteratorState setSkippedEdges(int edge1, int edge2) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getMergeStatus(long flags) {
+    public CHEdgeIteratorState setFirstAndLastOrigEdges(int firstOrigEdge, int lastOrigEdge) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public int getOrigEdgeFirst() {
+        return edges.get(current).getOrigEdgeFirst();
+    }
+
+    @Override
+    public int getOrigEdgeLast() {
+        return edges.get(current).getOrigEdgeLast();
+    }
+
+    @Override
+    public int getMergeStatus(int flags) {
         throw new UnsupportedOperationException("Not supported.");
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
index b080c72333..318c277502 100644
--- a/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/routing/VirtualEdgeIteratorState.java
@@ -17,7 +17,11 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.IntEncodedValue;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
@@ -34,34 +38,36 @@
     private final int edgeId;
     private final int baseNode;
     private final int adjNode;
-    private final int originalTraversalKey;
+    private final int originalEdgeKey;
     private double distance;
-    private long flags;
+    private IntsRef edgeFlags;
     private String name;
-    // indication if edges are dispreferred as start/stop edge 
+    // true if edge should be avoided as start/stop
     private boolean unfavored;
     private EdgeIteratorState reverseEdge;
+    private final boolean reverse;
 
-    public VirtualEdgeIteratorState(int originalTraversalKey, int edgeId, int baseNode, int adjNode, double distance, long flags, String name, PointList pointList) {
-        this.originalTraversalKey = originalTraversalKey;
+    public VirtualEdgeIteratorState(int originalEdgeKey, int edgeId, int baseNode, int adjNode, double distance,
+                                    IntsRef edgeFlags, String name, PointList pointList, boolean reverse) {
+        this.originalEdgeKey = originalEdgeKey;
         this.edgeId = edgeId;
         this.baseNode = baseNode;
         this.adjNode = adjNode;
         this.distance = distance;
-        this.flags = flags;
+        this.edgeFlags = edgeFlags;
         this.name = name;
         this.pointList = pointList;
+        this.reverse = reverse;
     }
 
     /**
-     * This method returns the original edge via its traversal key. I.e. also the direction is
+     * This method returns the original edge via its key. I.e. also the direction is
      * already correctly encoded.
-     * <p>
      *
      * @see GHUtility#createEdgeKey(int, int, int, boolean)
      */
-    public int getOriginalTraversalKey() {
-        return originalTraversalKey;
+    public int getOriginalEdgeKey() {
+        return originalEdgeKey;
     }
 
     @Override
@@ -115,38 +121,122 @@ public EdgeIteratorState setDistance(double dist) {
     }
 
     @Override
-    public long getFlags() {
-        return flags;
+    public IntsRef getFlags() {
+        return edgeFlags;
     }
 
     @Override
-    public EdgeIteratorState setFlags(long flags) {
-        this.flags = flags;
+    public EdgeIteratorState setFlags(IntsRef flags) {
+        this.edgeFlags = flags;
         return this;
     }
 
     @Override
-    public String getName() {
-        return name;
+    public boolean get(BooleanEncodedValue property) {
+        if (property == EdgeIteratorState.UNFAVORED_EDGE)
+            return unfavored;
+
+        return property.getBool(reverse, edgeFlags);
     }
 
     @Override
-    public EdgeIteratorState setName(String name) {
-        this.name = name;
+    public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
+        property.setBool(reverse, edgeFlags, value);
         return this;
     }
 
     @Override
-    public boolean getBool(int key, boolean _default) {
-        if (key == EdgeIteratorState.K_UNFAVORED_EDGE)
+    public boolean getReverse(BooleanEncodedValue property) {
+        if (property == EdgeIteratorState.UNFAVORED_EDGE)
             return unfavored;
+        return property.getBool(!reverse, edgeFlags);
+    }
+
+    @Override
+    public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+        property.setBool(!reverse, edgeFlags, value);
+        return this;
+    }
+
+    @Override
+    public int get(IntEncodedValue property) {
+        return property.getInt(reverse, edgeFlags);
+    }
+
+    @Override
+    public EdgeIteratorState set(IntEncodedValue property, int value) {
+        property.setInt(reverse, edgeFlags, value);
+        return this;
+    }
+
+    @Override
+    public int getReverse(IntEncodedValue property) {
+        return property.getInt(!reverse, edgeFlags);
+    }
+
+    @Override
+    public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+        property.setInt(!reverse, edgeFlags, value);
+        return this;
+    }
+
+    @Override
+    public double get(DecimalEncodedValue property) {
+        return property.getDecimal(reverse, edgeFlags);
+    }
+
+    @Override
+    public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+        property.setDecimal(reverse, edgeFlags, value);
+        return this;
+    }
+
+    @Override
+    public double getReverse(DecimalEncodedValue property) {
+        return property.getDecimal(!reverse, edgeFlags);
+    }
 
-        // for non-existent keys return default
-        return _default;
+    @Override
+    public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+        property.setDecimal(!reverse, edgeFlags, value);
+        return this;
+    }
+
+    @Override
+    public <T extends Enum> T get(EnumEncodedValue<T> property) {
+        return property.getEnum(reverse, edgeFlags);
+    }
+
+    @Override
+    public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+        property.setEnum(reverse, edgeFlags, value);
+        return this;
+    }
+
+    @Override
+    public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+        return property.getEnum(!reverse, edgeFlags);
+    }
+
+    @Override
+    public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
+        property.setEnum(!reverse, edgeFlags, value);
+        return this;
+    }
+
+    @Override
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public EdgeIteratorState setName(String name) {
+        this.name = name;
+        return this;
     }
 
     /**
-     * This method sets edge to unfavored status for routing from or to the start/stop points.
+     * This method sets edge to unfavored status for routing from the start or to the stop location.
      */
     public void setUnfavored(boolean unfavored) {
         this.unfavored = unfavored;
@@ -163,43 +253,50 @@ public boolean isShortcut() {
     }
 
     @Override
-    public boolean isForward(FlagEncoder encoder) {
-        return encoder.isForward(getFlags());
+    public int getAdditionalField() {
+        throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public boolean isBackward(FlagEncoder encoder) {
-        return encoder.isBackward(getFlags());
+    public int getMergeStatus(int flags) {
+        throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getAdditionalField() {
+    public int getSkippedEdge1() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getMergeStatus(long flags) {
+    public int getSkippedEdge2() {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getSkippedEdge1() {
+    public CHEdgeIteratorState setSkippedEdges(int edge1, int edge2) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public int getSkippedEdge2() {
+    public CHEdgeIteratorState setFirstAndLastOrigEdges(int firstOrigEdge, int lastOrigEdge) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public void setSkippedEdges(int edge1, int edge2) {
-        throw new UnsupportedOperationException("Not supported.");
+    public int getOrigEdgeFirst() {
+        return getEdge();
+    }
+
+    @Override
+    public int getOrigEdgeLast() {
+        return getEdge();
     }
 
     @Override
     public EdgeIteratorState detach(boolean reverse) {
         if (reverse) {
+            // update properties of reverse edge
+            // TODO copy wayGeometry too
             reverseEdge.setFlags(getFlags());
             reverseEdge.setName(getName());
             reverseEdge.setDistance(getDistance());
@@ -209,14 +306,15 @@ public EdgeIteratorState detach(boolean reverse) {
         }
     }
 
+
     @Override
     public EdgeIteratorState setAdditionalField(int value) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
     @Override
-    public EdgeIteratorState copyPropertiesTo(EdgeIteratorState edge) {
-        throw new UnsupportedOperationException("Not supported.");
+    public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState fromEdge) {
+        throw new RuntimeException("Not supported.");
     }
 
     @Override
@@ -224,6 +322,11 @@ public CHEdgeIteratorState setWeight(double weight) {
         throw new UnsupportedOperationException("Not supported.");
     }
 
+    @Override
+    public void setFlagsAndWeight(int flags, double weight) {
+        throw new UnsupportedOperationException("Not supported");
+    }
+
     @Override
     public double getWeight() {
         throw new UnsupportedOperationException("Not supported.");
diff --git a/core/src/main/java/com/graphhopper/routing/ch/AStarCHEntry.java b/core/src/main/java/com/graphhopper/routing/ch/AStarCHEntry.java
new file mode 100644
index 0000000000..6f8859047f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/AStarCHEntry.java
@@ -0,0 +1,44 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.util.EdgeIterator;
+
+public class AStarCHEntry extends CHEntry {
+    public double weightOfVisitedPath;
+
+    public AStarCHEntry(int edge, int incEdge, int adjNode, double heapWeight, double weightOfVisitedPath) {
+        super(edge, incEdge, adjNode, heapWeight);
+        this.weightOfVisitedPath = weightOfVisitedPath;
+    }
+
+    public AStarCHEntry(int node, double heapWeight, double weightOfVisitedPath) {
+        this(EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE, node, heapWeight, weightOfVisitedPath);
+    }
+
+    @Override
+    public AStarCHEntry getParent() {
+        return (AStarCHEntry) super.getParent();
+    }
+
+    @Override
+    public double getWeightOfVisitedPath() {
+        return weightOfVisitedPath;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java
index 9ce66debd0..e506b7c9de 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java
@@ -20,16 +20,11 @@
 
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.weighting.AbstractWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.CHGraph;
-import com.graphhopper.storage.DataAccess;
-import com.graphhopper.storage.Directory;
-import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.CHEdgeExplorer;
 
 abstract class AbstractNodeContractor implements NodeContractor {
-    private final GraphHopperStorage ghStorage;
     final CHGraph prepareGraph;
     final FlagEncoder encoder;
     CHEdgeExplorer inEdgeExplorer;
@@ -38,11 +33,10 @@
     int maxLevel;
     private int maxEdgesCount;
 
-    public AbstractNodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting) {
-        this.ghStorage = ghStorage;
+    public AbstractNodeContractor(CHGraph prepareGraph, Weighting weighting) {
         this.prepareGraph = prepareGraph;
         this.encoder = weighting.getFlagEncoder();
-        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
+        originalEdges = new GHDirectory("", DAType.RAM_INT).find("");
         originalEdges.create(1000);
     }
 
@@ -51,7 +45,7 @@ public void initFromGraph() {
         inEdgeExplorer = prepareGraph.createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder));
         outEdgeExplorer = prepareGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder));
         maxLevel = prepareGraph.getNodes();
-        maxEdgesCount = ghStorage.getAllEdges().length();
+        maxEdgesCount = prepareGraph.getOriginalEdges();
     }
 
     @Override
@@ -70,7 +64,7 @@ void setOrigEdgeCount(int edgeId, int value) {
             if (value != 1)
                 throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
                         + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" +
-                        prepareGraph.getAllEdges().length());
+                        prepareGraph.getEdges());
             return;
         }
 
@@ -88,4 +82,6 @@ int getOrigEdgeCount(int edgeId) {
         originalEdges.ensureCapacity(tmp + 4);
         return originalEdges.getInt(tmp);
     }
+
+    abstract boolean isEdgeBased();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
index 3c714bcc0c..719d50deba 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHAlgoFactoryDecorator.java
@@ -22,18 +22,19 @@
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.AbstractWeighting;
-import com.graphhopper.routing.weighting.BlockAreaWeighting;
-import com.graphhopper.routing.weighting.GenericWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
+import com.graphhopper.util.Parameters;
 import com.graphhopper.util.Parameters.CH;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.util.*;
-import java.util.concurrent.*;
+import java.util.concurrent.ExecutorCompletionService;
+import java.util.concurrent.ExecutorService;
 
 import static com.graphhopper.util.Helper.*;
 import static com.graphhopper.util.Parameters.CH.DISABLE;
@@ -49,18 +50,16 @@
     private final List<PrepareContractionHierarchies> preparations = new ArrayList<>();
     // we need to decouple weighting objects from the weighting list of strings 
     // as we need the strings to create the GraphHopperStorage and the GraphHopperStorage to create the preparations from the Weighting objects currently requiring the encoders
-    private final List<Weighting> weightings = new ArrayList<>();
+    private final List<Weighting> nodeBasedWeightings = new ArrayList<>();
+    private final List<Weighting> edgeBasedWeightings = new ArrayList<>();
     private final Set<String> weightingsAsStrings = new LinkedHashSet<>();
     private boolean disablingAllowed = false;
     // for backward compatibility enable CH by default.
     private boolean enabled = true;
+    private EdgeBasedCHMode edgeBasedCHMode = EdgeBasedCHMode.OFF;
     private int preparationThreads;
     private ExecutorService threadPool;
-    private int preparationPeriodicUpdates = -1;
-    private int preparationLazyUpdates = -1;
-    private int preparationNeighborUpdates = -1;
-    private int preparationContractedNodes = -1;
-    private double preparationLogMessages = -1;
+    private PMap pMap = new PMap();
 
     public CHAlgoFactoryDecorator() {
         setPreparationThreads(1);
@@ -81,7 +80,7 @@ public void init(CmdArgs args) {
         String chWeightingsStr = args.get(CH.PREPARE + "weightings", "");
 
         if ("no".equals(chWeightingsStr) || "false".equals(chWeightingsStr)) {
-            // default is fastest and we need to clear this explicitely
+            // default is fastest and we need to clear this explicitly
             weightingsAsStrings.clear();
         } else if (!chWeightingsStr.isEmpty()) {
             List<String> tmpCHWeightingList = Arrays.asList(chWeightingsStr.split(","));
@@ -93,56 +92,11 @@ public void init(CmdArgs args) {
         if (enableThis)
             setDisablingAllowed(args.getBool(CH.INIT_DISABLING_ALLOWED, isDisablingAllowed()));
 
-        setPreparationPeriodicUpdates(args.getInt(CH.PREPARE + "updates.periodic", getPreparationPeriodicUpdates()));
-        setPreparationLazyUpdates(args.getInt(CH.PREPARE + "updates.lazy", getPreparationLazyUpdates()));
-        setPreparationNeighborUpdates(args.getInt(CH.PREPARE + "updates.neighbor", getPreparationNeighborUpdates()));
-        setPreparationContractedNodes(args.getInt(CH.PREPARE + "contracted_nodes", getPreparationContractedNodes()));
-        setPreparationLogMessages(args.getDouble(CH.PREPARE + "log_messages", getPreparationLogMessages()));
-    }
-
-    public int getPreparationPeriodicUpdates() {
-        return preparationPeriodicUpdates;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationPeriodicUpdates(int preparePeriodicUpdates) {
-        this.preparationPeriodicUpdates = preparePeriodicUpdates;
-        return this;
-    }
-
-    public int getPreparationContractedNodes() {
-        return preparationContractedNodes;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationContractedNodes(int prepareContractedNodes) {
-        this.preparationContractedNodes = prepareContractedNodes;
-        return this;
-    }
-
-    public int getPreparationLazyUpdates() {
-        return preparationLazyUpdates;
-    }
+        String edgeBasedCHStr = args.get(CH.PREPARE + "edge_based", "off").trim();
+        edgeBasedCHStr = edgeBasedCHStr.equals("false") ? "off" : edgeBasedCHStr;
+        edgeBasedCHMode = EdgeBasedCHMode.valueOf(edgeBasedCHStr.toUpperCase(Locale.ROOT));
 
-    public CHAlgoFactoryDecorator setPreparationLazyUpdates(int prepareLazyUpdates) {
-        this.preparationLazyUpdates = prepareLazyUpdates;
-        return this;
-    }
-
-    public double getPreparationLogMessages() {
-        return preparationLogMessages;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationLogMessages(double prepareLogMessages) {
-        this.preparationLogMessages = prepareLogMessages;
-        return this;
-    }
-
-    public int getPreparationNeighborUpdates() {
-        return preparationNeighborUpdates;
-    }
-
-    public CHAlgoFactoryDecorator setPreparationNeighborUpdates(int prepareNeighborUpdates) {
-        this.preparationNeighborUpdates = prepareNeighborUpdates;
-        return this;
+        pMap = args;
     }
 
     @Override
@@ -170,12 +124,27 @@ public final CHAlgoFactoryDecorator setDisablingAllowed(boolean disablingAllowed
         return this;
     }
 
+    /**
+     * This method specifies whether or not edge-based CH preparation (needed for turn costs) should be performed.
+     *
+     * @see EdgeBasedCHMode
+     */
+    public final CHAlgoFactoryDecorator setEdgeBasedCHMode(EdgeBasedCHMode edgeBasedCHMode) {
+        this.edgeBasedCHMode = edgeBasedCHMode;
+        return this;
+    }
+
     /**
      * Decouple weightings from PrepareContractionHierarchies as we need weightings for the
      * graphstorage and the graphstorage for the preparation.
      */
-    public CHAlgoFactoryDecorator addWeighting(Weighting weighting) {
-        weightings.add(weighting);
+    public CHAlgoFactoryDecorator addNodeBasedWeighting(Weighting weighting) {
+        nodeBasedWeightings.add(weighting);
+        return this;
+    }
+
+    public CHAlgoFactoryDecorator addEdgeBasedWeighting(Weighting weighting) {
+        edgeBasedWeightings.add(weighting);
         return this;
     }
 
@@ -185,24 +154,42 @@ public CHAlgoFactoryDecorator addWeighting(String weighting) {
     }
 
     public CHAlgoFactoryDecorator addPreparation(PrepareContractionHierarchies pch) {
-        preparations.add(pch);
-        int lastIndex = preparations.size() - 1;
-        if (lastIndex >= weightings.size())
+        // we want to make sure that edge- and node-based preparations are added in the same order as their corresponding
+        // weightings, but changing the order between edge- and node-based preparations is accepted
+        int index = 0;
+        for (PrepareContractionHierarchies p : preparations) {
+            if (p.isEdgeBased() == pch.isEdgeBased()) {
+                index++;
+            }
+        }
+        List<Weighting> weightings = pch.isEdgeBased() ? edgeBasedWeightings : nodeBasedWeightings;
+        if (index >= weightings.size())
             throw new IllegalStateException("Cannot access weighting for PrepareContractionHierarchies with " + pch.getWeighting()
                     + ". Call add(Weighting) before");
 
-        if (preparations.get(lastIndex).getWeighting() != weightings.get(lastIndex))
-            throw new IllegalArgumentException("Weighting of PrepareContractionHierarchies " + preparations.get(lastIndex).getWeighting()
-                    + " needs to be identical to previously added " + weightings.get(lastIndex));
+        Weighting expectedWeighting = weightings.get(index);
+        if (pch.getWeighting() != expectedWeighting)
+            throw new IllegalArgumentException("Weighting of PrepareContractionHierarchies " + pch
+                    + " needs to be identical to previously added " + expectedWeighting);
+
+        preparations.add(pch);
         return this;
     }
 
     public final boolean hasWeightings() {
-        return !weightings.isEmpty();
+        return !nodeBasedWeightings.isEmpty() || !edgeBasedWeightings.isEmpty();
     }
 
-    public final List<Weighting> getWeightings() {
-        return weightings;
+    public final List<Weighting> getNodeBasedWeightings() {
+        return nodeBasedWeightings;
+    }
+
+    public final List<Weighting> getEdgeBasedWeightings() {
+        return edgeBasedWeightings;
+    }
+
+    public EdgeBasedCHMode getEdgeBasedCHMode() {
+        return edgeBasedCHMode;
     }
 
     public CHAlgoFactoryDecorator setWeightingsAsStrings(String... weightingNames) {
@@ -249,21 +236,34 @@ public RoutingAlgorithmFactory getDecoratedAlgorithmFactory(RoutingAlgorithmFact
         if (!isEnabled() || disablingAllowed && disableCH)
             return defaultAlgoFactory;
 
-        if (preparations.isEmpty())
+        List<PrepareContractionHierarchies> allPreparations = getPreparations();
+        if (allPreparations.isEmpty())
             throw new IllegalStateException("No preparations added to this decorator");
 
         if (map.getWeighting().isEmpty())
             map.setWeighting(getDefaultWeighting());
 
-        String entriesStr = "";
-        for (PrepareContractionHierarchies p : preparations) {
-            if (p.getWeighting().matches(map))
+        return getPreparation(map);
+    }
+
+    public PrepareContractionHierarchies getPreparation(HintsMap map) {
+        boolean edgeBased = map.getBool(Parameters.Routing.EDGE_BASED, false);
+        List<String> entriesStrs = new ArrayList<>();
+        boolean weightingMatchesButNotEdgeBased = false;
+        for (PrepareContractionHierarchies p : getPreparations()) {
+            boolean weightingMatches = p.getWeighting().matches(map);
+            if (p.isEdgeBased() == edgeBased && weightingMatches)
                 return p;
+            else if (weightingMatches)
+                weightingMatchesButNotEdgeBased = true;
 
-            entriesStr += p.getWeighting() + ", ";
+            entriesStrs.add(p.getWeighting() + "|" + (p.isEdgeBased() ? "edge" : "node"));
         }
 
-        throw new IllegalArgumentException("Cannot find CH RoutingAlgorithmFactory for weighting map " + map + " in entries " + entriesStr);
+        String hint = weightingMatchesButNotEdgeBased
+                ? " The '" + Parameters.Routing.EDGE_BASED + "' url parameter is missing or does not fit the weightings. Its value was: '" + edgeBased + "'"
+                : "";
+        throw new IllegalArgumentException("Cannot find CH RoutingAlgorithmFactory for weighting map " + map + " in entries: " + entriesStrs + "." + hint);
     }
 
     public int getPreparationThreads() {
@@ -283,8 +283,9 @@ public void prepare(final StorableProperties properties) {
         ExecutorCompletionService completionService = new ExecutorCompletionService<>(threadPool);
         int counter = 0;
         for (final PrepareContractionHierarchies prepare : getPreparations()) {
-            LOGGER.info((++counter) + "/" + getPreparations().size() + " calling CH prepare.doWork for " + prepare.getWeighting() + " ... (" + getMemInfo() + ")");
-            final String name = AbstractWeighting.weightingToFileName(prepare.getWeighting());
+            LOGGER.info((++counter) + "/" + getPreparations().size() + " calling " +
+                    (prepare.isEdgeBased() ? "edge" : "node") + "-based CH prepare.doWork for " + prepare.getWeighting() + " ... (" + getMemInfo() + ")");
+            final String name = AbstractWeighting.weightingToFileName(prepare.getWeighting(), prepare.isEdgeBased());
             completionService.submit(new Runnable() {
                 @Override
                 public void run() {
@@ -309,32 +310,44 @@ public void run() {
         }
     }
 
-    public void createPreparations(GraphHopperStorage ghStorage, TraversalMode traversalMode) {
-        if (!isEnabled() || !preparations.isEmpty())
+    public void createPreparations(GraphHopperStorage ghStorage) {
+        if (!isEnabled() || !getPreparations().isEmpty())
             return;
-        if (weightings.isEmpty())
+        if (!hasWeightings())
             throw new IllegalStateException("No CH weightings found");
 
-        traversalMode = getNodeBase();
-
-        for (Weighting weighting : getWeightings()) {
-            PrepareContractionHierarchies tmpPrepareCH = new PrepareContractionHierarchies(
-                    new GHDirectory("", DAType.RAM_INT), ghStorage, ghStorage.getGraph(CHGraph.class, weighting),
-                    weighting, traversalMode);
-            tmpPrepareCH.setPeriodicUpdates(preparationPeriodicUpdates).
-                    setLazyUpdates(preparationLazyUpdates).
-                    setNeighborUpdates(preparationNeighborUpdates).
-                    setLogMessages(preparationLogMessages);
-
-            addPreparation(tmpPrepareCH);
+        for (Weighting weighting : nodeBasedWeightings) {
+            addPreparation(createCHPreparation(ghStorage, weighting, TraversalMode.NODE_BASED));
         }
+        for (Weighting weighting : edgeBasedWeightings) {
+            addPreparation(createCHPreparation(ghStorage, weighting, TraversalMode.EDGE_BASED));
+        }
+    }
+
+    private PrepareContractionHierarchies createCHPreparation(GraphHopperStorage ghStorage, Weighting weighting,
+                                                              TraversalMode traversalMode) {
+        PrepareContractionHierarchies tmpPrepareCH = PrepareContractionHierarchies.fromGraphHopperStorage(
+                ghStorage, weighting, traversalMode);
+        tmpPrepareCH.setParams(pMap);
+        return tmpPrepareCH;
     }
 
     /**
-     * For now only node based will work, later on we can easily find usage of this method to remove
-     * it.
+     * Determines whether or not edge-based CH will be prepared for the different weightings/encoders.
      */
-    public TraversalMode getNodeBase() {
-        return TraversalMode.NODE_BASED;
+    public enum EdgeBasedCHMode {
+        /**
+         * no edge-based CH preparation will be performed
+         */
+        OFF,
+        /**
+         * for encoders with enabled turn costs edge-based CH and otherwise node-based CH preparation will be performed
+         */
+        EDGE_OR_NODE,
+        /**
+         * for encoders with enabled turn costs edge-based CH will be performed and node-based CH preparation will be
+         * performed for all encoders
+         */
+        EDGE_AND_NODE
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHEntry.java b/core/src/main/java/com/graphhopper/routing/ch/CHEntry.java
new file mode 100644
index 0000000000..38cea65ee0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHEntry.java
@@ -0,0 +1,52 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+
+public class CHEntry extends SPTEntry {
+    /**
+     * The id of the incoming original edge at this shortest path tree entry. For original edges this is the same
+     * as the edge id, but for shortcuts this is the id of the last original edge of the shortcut.
+     *
+     * @see CHEdgeIteratorState#setFirstAndLastOrigEdges(int, int)
+     * @see EdgeIteratorState#getOrigEdgeLast()
+     */
+    public int incEdge;
+
+    public CHEntry(int edge, int incEdge, int adjNode, double weight) {
+        super(edge, adjNode, weight);
+        this.incEdge = incEdge;
+    }
+
+    public CHEntry(int node, double weight) {
+        this(EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE, node, weight);
+    }
+
+    public CHEntry getParent() {
+        return (CHEntry) super.parent;
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + ", incEdge: " + incEdge;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/CHParameters.java b/core/src/main/java/com/graphhopper/routing/ch/CHParameters.java
new file mode 100644
index 0000000000..205a87d32f
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/CHParameters.java
@@ -0,0 +1,26 @@
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.util.Parameters;
+
+public final class CHParameters {
+    // graph contraction order etc. 
+    public static final String PERIODIC_UPDATES = Parameters.CH.PREPARE + "updates.periodic";
+    public static final String LAST_LAZY_NODES_UPDATES = Parameters.CH.PREPARE + "updates.lazy";
+    public static final String NEIGHBOR_UPDATES = Parameters.CH.PREPARE + "updates.neighbor";
+    public static final String CONTRACTED_NODES = Parameters.CH.PREPARE + "contracted_nodes";
+    public static final String LOG_MESSAGES = Parameters.CH.PREPARE + "log_messages";
+    // node contraction, node-based
+    public static final String EDGE_DIFFERENCE_WEIGHT = Parameters.CH.PREPARE + "node.edge_difference_weight";
+    public static final String ORIGINAL_EDGE_COUNT_WEIGHT = Parameters.CH.PREPARE + "node.original_edge_count_weight";
+    public static final String CONTRACTED_NEIGHBORS_WEIGHT = Parameters.CH.PREPARE + "node.contracted_neighbors_weight";
+    // node contraction, edge-based
+    public static final String EDGE_QUOTIENT_WEIGHT = Parameters.CH.PREPARE + "edge.edge_quotient_weight";
+    public static final String ORIGINAL_EDGE_QUOTIENT_WEIGHT = Parameters.CH.PREPARE + "edge.original_edge_quotient_weight";
+    public static final String HIERARCHY_DEPTH_WEIGHT = Parameters.CH.PREPARE + "edge.hierarchy_depth_weight";
+    public static final String SIGMA_FACTOR = Parameters.CH.PREPARE + "edge.witness_search.sigma_factor";
+    public static final String MIN_MAX_SETTLED_EDGES = Parameters.CH.PREPARE + "edge.witness_search.min_max_settled_edges";
+    public static final String SETTLED_EDGES_RESET_INTERVAL = Parameters.CH.PREPARE + "edge.witness_search.reset_interval";
+
+    private CHParameters() {
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java
new file mode 100644
index 0000000000..31c53a5116
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedNodeContractor.java
@@ -0,0 +1,547 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.carrotsearch.hppc.IntHashSet;
+import com.carrotsearch.hppc.IntSet;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.util.*;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Objects;
+import java.util.Set;
+
+import static com.graphhopper.routing.ch.CHParameters.*;
+import static com.graphhopper.util.Helper.nf;
+
+/**
+ * This class is used to calculate the priority of or contract a given node in edge-based Contraction Hierarchies as it
+ * is required to support turn-costs. This implementation follows the 'aggressive' variant described in
+ * 'Efficient Routing in Road Networks with Turn Costs' by R. Geisberger and C. Vetter. Here, we do not store the center
+ * node for each shortcut, but introduce helper shortcuts when a loop shortcut is encountered.
+ * <p>
+ * This class is mostly concerned with triggering the required local searches and introducing the necessary shortcuts
+ * or calculating the node priority, while the actual searches for witness paths are delegated to
+ * {@link WitnessPathSearcher}.
+ *
+ * @author easbar
+ */
+class EdgeBasedNodeContractor extends AbstractNodeContractor {
+    private static final Logger LOGGER = LoggerFactory.getLogger(EdgeBasedNodeContractor.class);
+    private final TurnWeighting turnWeighting;
+    private final FlagEncoder encoder;
+    private final ShortcutHandler addingShortcutHandler = new AddingShortcutHandler();
+    private final ShortcutHandler countingShortcutHandler = new CountingShortcutHandler();
+    private final Params params = new Params();
+    private final PMap pMap;
+    private ShortcutHandler activeShortcutHandler;
+    private final StopWatch dijkstraSW = new StopWatch();
+    private final SearchStrategy activeStrategy = new AggressiveStrategy();
+    private int[] hierarchyDepths;
+    private WitnessPathSearcher witnessPathSearcher;
+    private CHEdgeExplorer existingShortcutExplorer;
+    private CHEdgeExplorer allEdgeExplorer;
+    private EdgeExplorer sourceNodeOrigInEdgeExplorer;
+    private EdgeExplorer targetNodeOrigOutEdgeExplorer;
+    private EdgeExplorer loopAvoidanceInEdgeExplorer;
+    private EdgeExplorer loopAvoidanceOutEdgeExplorer;
+
+    // counts the total number of added shortcuts
+    private int addedShortcutsCount;
+
+    // edge counts used to calculate priority
+    private int numShortcuts;
+    private int numPrevEdges;
+    private int numOrigEdges;
+    private int numPrevOrigEdges;
+
+    // counters used for performance analysis
+    private int numPolledEdges;
+
+    public EdgeBasedNodeContractor(CHGraph prepareGraph,
+                                   TurnWeighting turnWeighting, PMap pMap) {
+        super(prepareGraph, turnWeighting);
+        this.turnWeighting = turnWeighting;
+        this.encoder = turnWeighting.getFlagEncoder();
+        this.pMap = pMap;
+        extractParams(pMap);
+        if (!Double.isInfinite(turnWeighting.getUTurnCost())) {
+            throw new IllegalArgumentException("edge-based CH currently does not support finite u-turn costs");
+        }
+    }
+
+    private void extractParams(PMap pMap) {
+        params.edgeQuotientWeight = pMap.getFloat(EDGE_QUOTIENT_WEIGHT, params.edgeQuotientWeight);
+        params.originalEdgeQuotientWeight = pMap.getFloat(ORIGINAL_EDGE_QUOTIENT_WEIGHT, params.originalEdgeQuotientWeight);
+        params.hierarchyDepthWeight = pMap.getFloat(HIERARCHY_DEPTH_WEIGHT, params.hierarchyDepthWeight);
+    }
+
+    @Override
+    public void initFromGraph() {
+        super.initFromGraph();
+        witnessPathSearcher = new WitnessPathSearcher(prepareGraph, turnWeighting, pMap);
+        DefaultEdgeFilter inEdgeFilter = DefaultEdgeFilter.inEdges(encoder);
+        DefaultEdgeFilter outEdgeFilter = DefaultEdgeFilter.outEdges(encoder);
+        DefaultEdgeFilter allEdgeFilter = DefaultEdgeFilter.allEdges(encoder);
+        inEdgeExplorer = prepareGraph.createEdgeExplorer(inEdgeFilter);
+        outEdgeExplorer = prepareGraph.createEdgeExplorer(outEdgeFilter);
+        allEdgeExplorer = prepareGraph.createEdgeExplorer(allEdgeFilter);
+        existingShortcutExplorer = prepareGraph.createEdgeExplorer(outEdgeFilter);
+        sourceNodeOrigInEdgeExplorer = prepareGraph.createOriginalEdgeExplorer(inEdgeFilter);
+        targetNodeOrigOutEdgeExplorer = prepareGraph.createOriginalEdgeExplorer(outEdgeFilter);
+        loopAvoidanceInEdgeExplorer = prepareGraph.createOriginalEdgeExplorer(inEdgeFilter);
+        loopAvoidanceOutEdgeExplorer = prepareGraph.createOriginalEdgeExplorer(outEdgeFilter);
+        hierarchyDepths = new int[prepareGraph.getNodes()];
+    }
+
+    @Override
+    public void prepareContraction() {
+        // not needed 
+    }
+
+    @Override
+    public float calculatePriority(int node) {
+        activeShortcutHandler = countingShortcutHandler;
+        stats().stopWatch.start();
+        findAndHandleShortcuts(node);
+        stats().stopWatch.stop();
+        countPreviousEdges(node);
+        // the higher the priority the later (!) this node will be contracted
+        float edgeQuotient = numShortcuts / (float) numPrevEdges;
+        float origEdgeQuotient = numOrigEdges / (float) numPrevOrigEdges;
+        int hierarchyDepth = hierarchyDepths[node];
+        float priority = params.edgeQuotientWeight * edgeQuotient +
+                params.originalEdgeQuotientWeight * origEdgeQuotient +
+                params.hierarchyDepthWeight * hierarchyDepth;
+        LOGGER.trace(String.format(Locale.ROOT, "node: %d, eq: %d / %d = %f, oeq: %d / %d = %f, depth: %d --> %f\n",
+                node,
+                numShortcuts, numPrevEdges, edgeQuotient,
+                numOrigEdges, numPrevOrigEdges, origEdgeQuotient,
+                hierarchyDepth, priority));
+        return priority;
+    }
+
+    @Override
+    public void contractNode(int node) {
+        activeShortcutHandler = addingShortcutHandler;
+        stats().stopWatch.start();
+        findAndHandleShortcuts(node);
+        updateHierarchyDepthsOfNeighbors(node);
+        stats().stopWatch.stop();
+    }
+
+    @Override
+    public long getAddedShortcutsCount() {
+        return addedShortcutsCount;
+    }
+
+    @Override
+    public long getDijkstraCount() {
+        return witnessPathSearcher.getTotalNumSearches();
+    }
+
+    @Override
+    public float getDijkstraSeconds() {
+        return dijkstraSW.getCurrentSeconds();
+    }
+
+    @Override
+    public String getStatisticsString() {
+        String result =
+                "sc-handler-count: " + countingShortcutHandler.getStats() + ", " +
+                        "sc-handler-contract: " + addingShortcutHandler.getStats() + ", " +
+                        activeStrategy.getStatisticsString();
+        activeStrategy.resetStats();
+        return result;
+    }
+
+    public int getNumPolledEdges() {
+        return numPolledEdges;
+    }
+
+    @Override
+    boolean isEdgeBased() {
+        return true;
+    }
+
+    private void findAndHandleShortcuts(int node) {
+        numPolledEdges = 0;
+        activeStrategy.findAndHandleShortcuts(node);
+    }
+
+    private void countPreviousEdges(int node) {
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+        CHEdgeIterator iter = allEdgeExplorer.setBaseNode(node);
+        while (iter.next()) {
+            if (isContracted(iter.getAdjNode()))
+                continue;
+            if (iter.get(accessEnc)) {
+                numPrevEdges++;
+            }
+            if (iter.getReverse(accessEnc)) {
+                numPrevEdges++;
+            }
+            if (!iter.isShortcut()) {
+                if (iter.get(accessEnc)) {
+                    numPrevOrigEdges++;
+                }
+                if (iter.getReverse(accessEnc)) {
+                    numPrevOrigEdges++;
+                }
+            } else {
+                numPrevOrigEdges += getOrigEdgeCount(iter.getEdge());
+            }
+        }
+    }
+
+    private void updateHierarchyDepthsOfNeighbors(int node) {
+        CHEdgeIterator iter = allEdgeExplorer.setBaseNode(node);
+        while (iter.next()) {
+            if (isContracted(iter.getAdjNode()) || iter.getAdjNode() == node)
+                continue;
+            hierarchyDepths[iter.getAdjNode()] = Math.max(hierarchyDepths[iter.getAdjNode()], hierarchyDepths[node] + 1);
+        }
+    }
+
+    private void handleShortcuts(CHEntry chEntry, CHEntry root) {
+        LOGGER.trace("Adding shortcuts for target entry {}", chEntry);
+        if (root.parent.adjNode == chEntry.adjNode &&
+                //here we misuse root.parent.incEdge as first orig edge of the potential shortcut
+                !loopShortcutNecessary(
+                        chEntry.adjNode, root.getParent().incEdge, chEntry.incEdge, chEntry.weight)) {
+            stats().loopsAvoided++;
+            return;
+        }
+        activeShortcutHandler.handleShortcut(root, chEntry);
+    }
+
+    /**
+     * A given potential loop shortcut is only necessary if there is at least one pair of original in- & out-edges for
+     * which taking the loop is cheaper than doing the direct turn. However this is almost always the case, because
+     * doing a u-turn at any of the incoming edges is forbidden, i.e. the costs of the direct turn will be infinite.
+     */
+    private boolean loopShortcutNecessary(int node, int firstOrigEdge, int lastOrigEdge, double loopWeight) {
+        EdgeIterator inIter = loopAvoidanceInEdgeExplorer.setBaseNode(node);
+        while (inIter.next()) {
+            EdgeIterator outIter = loopAvoidanceOutEdgeExplorer.setBaseNode(node);
+            double inTurnCost = getTurnCost(inIter.getEdge(), node, firstOrigEdge);
+            while (outIter.next()) {
+                double totalLoopCost = inTurnCost + loopWeight +
+                        getTurnCost(lastOrigEdge, node, outIter.getEdge());
+                double directTurnCost = getTurnCost(inIter.getEdge(), node, outIter.getEdge());
+                if (totalLoopCost < directTurnCost) {
+                    return true;
+                }
+            }
+        }
+        LOGGER.trace("Loop avoidance -> no shortcut");
+        return false;
+    }
+
+    private CHEntry addShortcut(CHEntry edgeFrom, CHEntry edgeTo) {
+        if (edgeTo.parent.edge != edgeFrom.edge) {
+            CHEntry prev = addShortcut(edgeFrom, edgeTo.getParent());
+            return doAddShortcut(prev, edgeTo);
+        } else {
+            return doAddShortcut(edgeFrom, edgeTo);
+        }
+    }
+
+    private CHEntry doAddShortcut(CHEntry edgeFrom, CHEntry edgeTo) {
+        int from = edgeFrom.parent.adjNode;
+        int adjNode = edgeTo.adjNode;
+
+        final CHEdgeIterator iter = existingShortcutExplorer.setBaseNode(from);
+        while (iter.next()) {
+            if (!isSameShortcut(iter, adjNode, edgeFrom.getParent().incEdge, edgeTo.incEdge)) {
+                // this is some other (shortcut) edge, we do not care
+                continue;
+            }
+            final double existingWeight = turnWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE);
+            if (existingWeight <= edgeTo.weight) {
+                // our shortcut already exists with lower weight --> do nothing
+                CHEntry entry = new CHEntry(iter.getEdge(), iter.getOrigEdgeLast(), adjNode, existingWeight);
+                entry.parent = edgeFrom.parent;
+                return entry;
+            } else {
+                // update weight
+                iter.setSkippedEdges(edgeFrom.edge, edgeTo.edge);
+                iter.setWeight(edgeTo.weight);
+                CHEntry entry = new CHEntry(iter.getEdge(), iter.getOrigEdgeLast(), adjNode, edgeTo.weight);
+                entry.parent = edgeFrom.parent;
+                return entry;
+            }
+        }
+
+        // our shortcut is new --> add it
+        // this is a bit of a hack, we misuse incEdge of edgeFrom's parent to store the first orig edge
+        int origFirst = edgeFrom.getParent().incEdge;
+        LOGGER.trace("Adding shortcut from {} to {}, weight: {}, firstOrigEdge: {}, lastOrigEdge: {}",
+                from, adjNode, edgeTo.weight, edgeFrom.getParent().incEdge, edgeTo.incEdge);
+        // todo: so far we are not using the distance in edge based CH
+        double distance = 0.0;
+        int accessFlags = PrepareEncoder.getScFwdDir();
+        int shortcutId = prepareGraph.shortcutEdgeBased(from, adjNode, accessFlags, edgeTo.weight, distance, edgeFrom.edge, edgeTo.edge, origFirst, edgeTo.incEdge);
+        final int origEdgeCount = getOrigEdgeCount(edgeFrom.edge) + getOrigEdgeCount(edgeTo.edge);
+        setOrigEdgeCount(shortcutId, origEdgeCount);
+        addedShortcutsCount++;
+        CHEntry entry = new CHEntry(shortcutId, shortcutId, edgeTo.adjNode, edgeTo.weight);
+        entry.parent = edgeFrom.parent;
+        return entry;
+    }
+
+    private boolean isSameShortcut(CHEdgeIteratorState iter, int adjNode, int firstOrigEdge, int lastOrigEdge) {
+        return iter.isShortcut()
+                && (iter.getAdjNode() == adjNode)
+                && (iter.getOrigEdgeFirst() == firstOrigEdge)
+                && (iter.getOrigEdgeLast() == lastOrigEdge);
+    }
+
+    private double getTurnCost(int inEdge, int node, int outEdge) {
+        return turnWeighting.calcTurnWeight(inEdge, node, outEdge);
+    }
+
+    private void resetEdgeCounters() {
+        numShortcuts = 0;
+        numPrevEdges = 0;
+        numOrigEdges = 0;
+        numPrevOrigEdges = 0;
+    }
+
+    private Stats stats() {
+        return activeShortcutHandler.getStats();
+    }
+
+    private interface ShortcutHandler {
+
+        void handleShortcut(CHEntry edgeFrom, CHEntry edgeTo);
+
+        Stats getStats();
+
+        String getAction();
+    }
+
+    private class AddingShortcutHandler implements ShortcutHandler {
+        private Stats stats = new Stats();
+
+        @Override
+        public void handleShortcut(CHEntry edgeFrom, CHEntry edgeTo) {
+            addShortcut(edgeFrom, edgeTo);
+        }
+
+        @Override
+        public Stats getStats() {
+            return stats;
+        }
+
+        @Override
+        public String getAction() {
+            return "add";
+        }
+    }
+
+    private class CountingShortcutHandler implements ShortcutHandler {
+        private Stats stats = new Stats();
+
+        @Override
+        public void handleShortcut(CHEntry edgeFrom, CHEntry edgeTo) {
+            int fromNode = edgeFrom.parent.adjNode;
+            int toNode = edgeTo.adjNode;
+            int firstOrigEdge = edgeFrom.getParent().incEdge;
+            int lastOrigEdge = edgeTo.incEdge;
+
+            // check if this shortcut already exists
+            final CHEdgeIterator iter = existingShortcutExplorer.setBaseNode(fromNode);
+            while (iter.next()) {
+                if (isSameShortcut(iter, toNode, firstOrigEdge, lastOrigEdge)) {
+                    // this shortcut exists already, maybe its weight will be updated but we should not count it as
+                    // a new edge
+                    return;
+                }
+            }
+
+            // this shortcut is new --> increase counts
+            numShortcuts++;
+            numOrigEdges += getOrigEdgeCount(edgeFrom.edge) + getOrigEdgeCount(edgeTo.edge);
+        }
+
+        @Override
+        public Stats getStats() {
+            return stats;
+        }
+
+        @Override
+        public String getAction() {
+            return "count";
+        }
+    }
+
+    public static class Params {
+        // todo: optimize
+        private float edgeQuotientWeight = 1;
+        private float originalEdgeQuotientWeight = 3;
+        private float hierarchyDepthWeight = 2;
+    }
+
+    private static class Stats {
+        int nodes;
+        long loopsAvoided;
+        StopWatch stopWatch = new StopWatch();
+
+        @Override
+        public String toString() {
+            return String.format(Locale.ROOT,
+                    "time: %7.2fs, nodes-handled: %10s, loopsAvoided: %10s",
+                    stopWatch.getCurrentSeconds(), nf(nodes), nf(loopsAvoided));
+        }
+    }
+
+    private interface SearchStrategy {
+        void findAndHandleShortcuts(int node);
+
+        String getStatisticsString();
+
+        void resetStats();
+
+    }
+
+    private class AggressiveStrategy implements SearchStrategy {
+        @Override
+        public String getStatisticsString() {
+            return witnessPathSearcher.getStatisticsString();
+        }
+
+        @Override
+        public void resetStats() {
+            witnessPathSearcher.resetStats();
+        }
+
+        @Override
+        public void findAndHandleShortcuts(int node) {
+            LOGGER.trace("Finding shortcuts (aggressive) for node {}, required shortcuts will be {}ed", node, activeShortcutHandler.getAction());
+            stats().nodes++;
+            resetEdgeCounters();
+            Set<AddedShortcut> addedShortcuts = new HashSet<>();
+
+            // first we need to identify the possible source nodes from which we can reach the center node
+            // todo: optimize collection size
+            IntSet sourceNodes = new IntHashSet(100);
+            EdgeIterator incomingEdges = inEdgeExplorer.setBaseNode(node);
+            while (incomingEdges.next()) {
+                int sourceNode = incomingEdges.getAdjNode();
+                if (isContracted(sourceNode) || sourceNode == node) {
+                    continue;
+                }
+                boolean isNewSourceNode = sourceNodes.add(sourceNode);
+                if (!isNewSourceNode) {
+                    continue;
+                }
+                // for each source node we need to look at every incoming original edge and find the initial entries
+                EdgeIterator origInIter = sourceNodeOrigInEdgeExplorer.setBaseNode(sourceNode);
+                while (origInIter.next()) {
+                    int numInitialEntries = witnessPathSearcher.initSearch(node, sourceNode, origInIter.getOrigEdgeLast());
+                    if (numInitialEntries < 1) {
+                        continue;
+                    }
+
+                    // now we need to identify all target nodes that can be reached from the center node
+                    // todo: optimize collection size
+                    IntSet toNodes = new IntHashSet(100);
+                    EdgeIterator outgoingEdges = outEdgeExplorer.setBaseNode(node);
+                    while (outgoingEdges.next()) {
+                        int targetNode = outgoingEdges.getAdjNode();
+                        if (isContracted(targetNode) || targetNode == node) {
+                            continue;
+                        }
+                        boolean isNewTargetNode = toNodes.add(targetNode);
+                        if (!isNewTargetNode) {
+                            continue;
+                        }
+                        // for each target edge outgoing from a target node we need to check if reaching it requires
+                        // a 'bridge-path'
+                        EdgeIterator targetEdgeIter = targetNodeOrigOutEdgeExplorer.setBaseNode(targetNode);
+                        while (targetEdgeIter.next()) {
+                            int targetEdge = targetEdgeIter.getOrigEdgeFirst();
+                            dijkstraSW.start();
+                            CHEntry entry = witnessPathSearcher.runSearch(targetNode, targetEdge);
+                            dijkstraSW.stop();
+                            if (entry == null || Double.isInfinite(entry.weight)) {
+                                continue;
+                            }
+                            CHEntry root = entry.getParent();
+                            while (EdgeIterator.Edge.isValid(root.parent.edge)) {
+                                root = root.getParent();
+                            }
+                            // todo: removing this 'optimization' improves contraction time significantly, but introduces 
+                            // more shortcuts (makes slower queries). why is this so ? any 'duplicate' shortcuts should be detected at time of
+                            // insertion !??
+                            AddedShortcut addedShortcut = new AddedShortcut(sourceNode, root.getParent().incEdge, targetNode, entry.incEdge);
+                            if (addedShortcuts.contains(addedShortcut)) {
+                                continue;
+                            }
+                            // root parent weight was misused to store initial turn cost here
+                            double initialTurnCost = root.getParent().weight;
+                            entry.weight -= initialTurnCost;
+                            handleShortcuts(entry, root);
+                            addedShortcuts.add(addedShortcut);
+                        }
+                    }
+                    numPolledEdges += witnessPathSearcher.getNumPolledEdges();
+                }
+            }
+        }
+    }
+
+    private static class AddedShortcut {
+        int startNode;
+        int startEdge;
+        int endNode;
+        int targetEdge;
+
+        public AddedShortcut(int startNode, int startEdge, int endNode, int targetEdge) {
+            this.startNode = startNode;
+            this.startEdge = startEdge;
+            this.endNode = endNode;
+            this.targetEdge = targetEdge;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            AddedShortcut that = (AddedShortcut) o;
+            return startNode == that.startNode &&
+                    startEdge == that.startEdge &&
+                    endNode == that.endNode &&
+                    targetEdge == that.targetEdge;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(startNode, startEdge, endNode, targetEdge);
+        }
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java
new file mode 100644
index 0000000000..0574ae359a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/EdgeBasedPathCH.java
@@ -0,0 +1,39 @@
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.storage.ShortcutUnpacker;
+import com.graphhopper.util.EdgeIteratorState;
+
+
+public class EdgeBasedPathCH extends Path4CH {
+
+    private final TurnWeighting turnWeighting;
+
+    public EdgeBasedPathCH(Graph routingGraph, Graph baseGraph, final Weighting weighting) {
+        super(routingGraph, baseGraph, weighting);
+        if (!(weighting instanceof TurnWeighting)) {
+            throw new IllegalArgumentException("Need a TurnWeighting for edge-based CH");
+        }
+        turnWeighting = (TurnWeighting) weighting;
+    }
+
+    @Override
+    protected ShortcutUnpacker getShortcutUnpacker(Graph routingGraph, final Weighting weighting) {
+        return new ShortcutUnpacker(routingGraph, new ShortcutUnpacker.Visitor() {
+            @Override
+            public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+                distance += edge.getDistance();
+                time += turnWeighting.calcMillis(edge, reverse, prevOrNextEdgeId);
+                addEdge(edge.getEdge());
+            }
+        }, true);
+    }
+
+    @Override
+    protected int getIncEdge(SPTEntry entry) {
+        return ((CHEntry) entry).incEdge;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
index 44c7a59d44..cbefc3d8d1 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
@@ -28,6 +28,7 @@
 import java.util.Locale;
 import java.util.Map;
 
+import static com.graphhopper.routing.ch.CHParameters.*;
 import static com.graphhopper.util.Helper.nf;
 
 class NodeBasedNodeContractor extends AbstractNodeContractor {
@@ -35,6 +36,7 @@
     private final Map<Shortcut, Shortcut> shortcuts = new HashMap<>();
     private final AddShortcutHandler addScHandler = new AddShortcutHandler();
     private final CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
+    private final Params params = new Params();
     private CHEdgeExplorer remainingEdgeExplorer;
     private IgnoreNodeFilter ignoreNodeFilter;
     private DijkstraOneToMany prepareAlgo;
@@ -45,9 +47,16 @@
     // each edge can exist in both directions
     private double meanDegree;
 
-    NodeBasedNodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting) {
-        super(dir, ghStorage, prepareGraph, weighting);
+    NodeBasedNodeContractor(CHGraph prepareGraph, Weighting weighting, PMap pMap) {
+        super(prepareGraph, weighting);
         this.prepareWeighting = new PreparationWeighting(weighting);
+        extractParams(pMap);
+    }
+
+    private void extractParams(PMap pMap) {
+        params.edgeDifferenceWeight = pMap.getFloat(EDGE_DIFFERENCE_WEIGHT, params.edgeDifferenceWeight);
+        params.originalEdgesCountWeight = pMap.getFloat(ORIGINAL_EDGE_COUNT_WEIGHT, params.originalEdgesCountWeight);
+        params.contractedNeighborsWeight = pMap.getFloat(CONTRACTED_NEIGHBORS_WEIGHT, params.contractedNeighborsWeight);
     }
 
     @Override
@@ -72,7 +81,7 @@ public void prepareContraction() {
         // no witness path can be found. this is not really what we want, but changing it requires re-optimizing the
         // graph contraction parameters, because it affects the node contraction order.
         // when this is done there should be no need for this method any longer.
-        meanDegree = prepareGraph.getAllEdges().length() / prepareGraph.getNodes();
+        meanDegree = prepareGraph.getEdges() / prepareGraph.getNodes();
     }
 
     @Override
@@ -120,8 +129,9 @@ public float calculatePriority(int node) {
         int edgeDifference = calcShortcutsResult.shortcutsCount - degree;
 
         // according to the paper do a simple linear combination of the properties to get the priority.
-        // this is the current optimum for unterfranken:
-        return 10 * edgeDifference + originalEdgesCount + contractedNeighbors;
+        return params.edgeDifferenceWeight * edgeDifference +
+                params.originalEdgesCountWeight * originalEdgesCount +
+                params.contractedNeighborsWeight * contractedNeighbors;
     }
 
     @Override
@@ -139,6 +149,11 @@ public String getStatisticsString() {
                 meanDegree, nf(dijkstraCount), prepareAlgo.getMemoryUsageAsString());
     }
 
+    @Override
+    boolean isEdgeBased() {
+        return false;
+    }
+
     /**
      * Searches for shortcuts and calls the given handler on each shortcut that is found. The graph is not directly
      * changed by this method.
@@ -152,12 +167,16 @@ private long findShortcuts(ShortcutHandler sch) {
         // collect outgoing nodes (goal-nodes) only once
         while (incomingEdges.next()) {
             int fromNode = incomingEdges.getAdjNode();
-            // accept only uncontracted nodes
-            if (isContracted(fromNode))
+            // accept only not-contracted nodes, do not consider loops at the node that is being contracted
+            if (fromNode == sch.getNode() || isContracted(fromNode))
                 continue;
 
+            final double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
+            // this check is important to prevent calling calcMillis on inaccessible edges and also allows early exit
+            if (Double.isInfinite(incomingEdgeWeight)) {
+                continue;
+            }
             final double incomingEdgeDistance = incomingEdges.getDistance();
-            double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
             int incomingEdge = incomingEdges.getEdge();
             int inOrigEdgeCount = getOrigEdgeCount(incomingEdge);
             // collect outgoing nodes (goal-nodes) only once
@@ -167,8 +186,8 @@ private long findShortcuts(ShortcutHandler sch) {
             degree++;
             while (outgoingEdges.next()) {
                 int toNode = outgoingEdges.getAdjNode();
-                // add only uncontracted nodes
-                if (isContracted(toNode) || fromNode == toNode)
+                // add only not-contracted nodes, do not consider loops at the node that is being contracted
+                if (toNode == sch.getNode() || isContracted(toNode) || fromNode == toNode)
                     continue;
 
                 // Limit weight as ferries or forbidden edges can increase local search too much.
@@ -244,9 +263,7 @@ private int addShortcuts(Collection<Shortcut> shortcuts) {
                                 + ", neighbors:" + GHUtility.getNeighbors(iter));
                     }
 
-                    // note: flags overwrite weight => call first
-                    iter.setFlags(sc.flags);
-                    iter.setWeight(sc.weight);
+                    iter.setFlagsAndWeight(sc.flags, sc.weight);
                     iter.setDistance(sc.dist);
                     iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
                     setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
@@ -256,13 +273,9 @@ private int addShortcuts(Collection<Shortcut> shortcuts) {
             }
 
             if (!updatedInGraph) {
-                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
-                // note: flags overwrite weight => call first
-                edgeState.setFlags(sc.flags);
-                edgeState.setWeight(sc.weight);
-                edgeState.setDistance(sc.dist);
-                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
+                int scId = prepareGraph.shortcut(sc.from, sc.to, sc.flags, sc.weight, sc.dist, sc.skippedEdge1, sc.skippedEdge2);
+                setOrigEdgeCount(scId, sc.originalEdges);
+
                 tmpNewShortcuts++;
             }
         }
@@ -311,7 +324,7 @@ private int getMaxVisitedNodesEstimate() {
         double dist;
         double weight;
         int originalEdges;
-        long flags = PrepareEncoder.getScFwdDir();
+        int flags = PrepareEncoder.getScFwdDir();
 
         public Shortcut(int from, int to, double weight, double dist) {
             this.from = from;
@@ -348,7 +361,7 @@ public String toString() {
             else
                 str = from + "->";
 
-            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + "), dist: " + dist;
         }
     }
 
@@ -438,4 +451,11 @@ public void foundShortcut(int fromNode, int toNode,
         int shortcutsCount;
     }
 
+    public static class Params {
+        // default values were optimized for Unterfranken
+        private float edgeDifferenceWeight = 10;
+        private float originalEdgesCountWeight = 1;
+        private float contractedNeighborsWeight = 1;
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeOrderingProvider.java b/core/src/main/java/com/graphhopper/routing/ch/NodeOrderingProvider.java
new file mode 100644
index 0000000000..da5377c187
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeOrderingProvider.java
@@ -0,0 +1,7 @@
+package com.graphhopper.routing.ch;
+
+public interface NodeOrderingProvider {
+    int getNodeIdForLevel(int level);
+
+    int getNumNodes();
+}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java b/core/src/main/java/com/graphhopper/routing/ch/OnFlyStatisticsCalculator.java
similarity index 51%
rename from reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
rename to core/src/main/java/com/graphhopper/routing/ch/OnFlyStatisticsCalculator.java
index e434b1e66e..988e5b2cda 100644
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/Utils.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/OnFlyStatisticsCalculator.java
@@ -15,31 +15,42 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.reader.shp;
-
-import com.graphhopper.util.PointList;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.GeometryFactory;
+package com.graphhopper.routing.ch;
 
 /**
- * @author Phil
+ * Helper class for mean and variance calculation of a running sample
+ * For reference see:
+ * https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
  */
-public class Utils {
-    public static String toWKT(PointList list) {
-        int n = list.size();
-        GeometryFactory factory = new GeometryFactory();
-        Coordinate[] coords = new Coordinate[n];
-        for (int i = 0; i < coords.length; i++) {
-            coords[i] = new Coordinate(list.getLon(i), list.getLat(i));
-        }
-        return factory.createLineString(coords).toText();
+class OnFlyStatisticsCalculator {
+
+    private long count;
+    private double mean;
+    private double varianceHelper;
+
+    void addObservation(long value) {
+        count++;
+        double delta = value - mean;
+        mean += delta / count;
+        double newDelta = value - mean;
+        varianceHelper += delta * newDelta;
+    }
+
+    public long getCount() {
+        return count;
+    }
+
+    double getMean() {
+        return mean;
     }
 
-    public static RuntimeException asUnchecked(Throwable e) {
-        if (RuntimeException.class.isInstance(e)) {
-            return (RuntimeException) e;
-        }
-        return new RuntimeException(e);
+    double getVariance() {
+        return varianceHelper / count;
     }
 
+    void reset() {
+        count = 0;
+        mean = 0;
+        varianceHelper = 0;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 8988b4fdde..e77cadf5d0 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -18,82 +18,41 @@
 package com.graphhopper.routing.ch;
 
 import com.graphhopper.routing.PathBidirRef;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.util.CHEdgeIteratorState;
-import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.storage.ShortcutUnpacker;
+import com.graphhopper.util.EdgeIteratorState;
+
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
 
-/**
- * Recursively unpack shortcuts.
- * <p>
- *
- * @author Peter Karich
- * @see PrepareContractionHierarchies
- */
 public class Path4CH extends PathBidirRef {
-    private final Graph routingGraph;
+    private final ShortcutUnpacker shortcutUnpacker;
 
-    public Path4CH(Graph routingGraph, Graph baseGraph, Weighting weighting) {
+    public Path4CH(Graph routingGraph, Graph baseGraph, final Weighting weighting) {
         super(baseGraph, weighting);
-        this.routingGraph = routingGraph;
+        this.shortcutUnpacker = getShortcutUnpacker(routingGraph, weighting);
     }
 
     @Override
-    protected final void processEdge(int tmpEdge, int endNode, int prevEdgeId) {
+    protected final void processEdge(int edgeId, int adjNode, int prevEdgeId) {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((CHEdgeIteratorState) routingGraph.getEdgeIteratorState(tmpEdge, endNode), false);
+        shortcutUnpacker.visitOriginalEdgesFwd(edgeId, adjNode, true, prevEdgeId);
     }
 
-    private void expandEdge(CHEdgeIteratorState mainEdgeState, boolean reverse) {
-        if (!mainEdgeState.isShortcut()) {
-            distance += mainEdgeState.getDistance();
-            time += weighting.calcMillis(mainEdgeState, reverse, EdgeIterator.NO_EDGE);
-            addEdge(mainEdgeState.getEdge());
-            return;
-        }
-
-        int skippedEdge1 = mainEdgeState.getSkippedEdge1();
-        int skippedEdge2 = mainEdgeState.getSkippedEdge2();
-        int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
-
-        // get properties like speed of the edge in the correct direction
-        if (reverse) {
-            int tmp = from;
-            from = to;
-            to = tmp;
-        }
-
-        // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
-        if (reverseOrder) {
-            CHEdgeIteratorState edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
-            boolean empty = edgeState == null;
-            if (empty)
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
-
-            expandEdge(edgeState, false);
-
-            if (empty)
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
-            else
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
-
-            expandEdge(edgeState, true);
-        } else {
-            CHEdgeIteratorState iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
-            boolean empty = iter == null;
-            if (empty)
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
-
-            expandEdge(iter, true);
-
-            if (empty)
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
-            else
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
+    @Override
+    protected void processEdgeBwd(int edgeId, int adjNode, int nextEdgeId) {
+        shortcutUnpacker.visitOriginalEdgesBwd(edgeId, adjNode, true, nextEdgeId);
+    }
 
-            expandEdge(iter, false);
-        }
+    protected ShortcutUnpacker getShortcutUnpacker(Graph routingGraph, final Weighting weighting) {
+        return new ShortcutUnpacker(routingGraph, new ShortcutUnpacker.Visitor() {
+            @Override
+            public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+                distance += edge.getDistance();
+                time += weighting.calcMillis(edge, reverse, NO_EDGE);
+                addEdge(edge.getEdge());
+            }
+        }, false);
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
index b64e478faf..36226f28aa 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PreparationWeighting.java
@@ -54,6 +54,9 @@ public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevO
 
     @Override
     public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+        if (edgeState instanceof CHEdgeIteratorState && ((CHEdgeIteratorState) edgeState).isShortcut()) {
+            throw new IllegalStateException("calcMillis should only be called on original edges");
+        }
         return userWeighting.calcMillis(edgeState, reverse, prevOrNextEdgeId);
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 31b993fc8c..edaa39feb2 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -17,21 +17,22 @@
  */
 package com.graphhopper.routing.ch;
 
+import com.carrotsearch.hppc.IntHashSet;
+import com.carrotsearch.hppc.IntSet;
 import com.graphhopper.coll.GHTreeMapComposed;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.CHEdgeExplorer;
-import com.graphhopper.util.CHEdgeIterator;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.util.Locale;
 import java.util.Random;
 
+import static com.graphhopper.routing.ch.CHParameters.*;
 import static com.graphhopper.util.Helper.nf;
 import static com.graphhopper.util.Parameters.Algorithms.ASTAR_BI;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
@@ -51,141 +52,93 @@
  */
 public class PrepareContractionHierarchies extends AbstractAlgoPreparation implements RoutingAlgorithmFactory {
     private final Logger logger = LoggerFactory.getLogger(getClass());
-    private final Directory dir;
     private final PreparationWeighting prepareWeighting;
     private final Weighting weighting;
     private final TraversalMode traversalMode;
-    private final GraphHopperStorage ghStorage;
-    private final CHGraphImpl prepareGraph;
+    private final CHGraph prepareGraph;
     private final Random rand = new Random(123);
     private final StopWatch allSW = new StopWatch();
     private final StopWatch periodicUpdateSW = new StopWatch();
     private final StopWatch lazyUpdateSW = new StopWatch();
     private final StopWatch neighborUpdateSW = new StopWatch();
     private final StopWatch contractionSW = new StopWatch();
+    private final Params params;
     private NodeContractor nodeContractor;
+    private NodeOrderingProvider nodeOrderingProvider;
     private CHEdgeExplorer vehicleAllExplorer;
     private CHEdgeExplorer vehicleAllTmpExplorer;
     private int maxLevel;
     // nodes with highest priority come last
     private GHTreeMapComposed sortedNodes;
-    private float oldPriorities[];
-    private int periodicUpdatesPercentage = 20;
-    private int lastNodesLazyUpdatePercentage = 10;
-    private int neighborUpdatePercentage = 20;
-    private double nodesContractedPercentage = 100;
-    private double logMessagesPercentage = 20;
-    private int initSize;
+    private float[] oldPriorities;
+    private PMap pMap = new PMap();
     private int checkCounter;
 
-    public PrepareContractionHierarchies(Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
-                                         Weighting weighting, TraversalMode traversalMode) {
-        this.dir = dir;
-        this.ghStorage = ghStorage;
-        this.prepareGraph = (CHGraphImpl) chGraph;
+    public PrepareContractionHierarchies(CHGraph chGraph, Weighting weighting, TraversalMode traversalMode) {
+        this.prepareGraph = chGraph;
         this.traversalMode = traversalMode;
         this.weighting = weighting;
         prepareWeighting = new PreparationWeighting(weighting);
+        this.params = Params.forTraversalMode(traversalMode);
     }
 
-    /**
-     * The higher the values are the longer the preparation takes but the less shortcuts are
-     * produced.
-     * <p>
-     *
-     * @param periodicUpdates specifies how often periodic updates will happen. Use something less
-     *                        than 10.
-     */
-    public PrepareContractionHierarchies setPeriodicUpdates(int periodicUpdates) {
-        if (periodicUpdates < 0)
-            return this;
-        if (periodicUpdates > 100)
-            throw new IllegalArgumentException("periodicUpdates has to be in [0, 100], to disable it use 0");
-
-        this.periodicUpdatesPercentage = periodicUpdates;
-        return this;
-    }
-
-    /**
-     * @param lazyUpdates specifies when lazy updates will happen, measured relative to all existing
-     *                    nodes. 100 means always.
-     */
-    public PrepareContractionHierarchies setLazyUpdates(int lazyUpdates) {
-        if (lazyUpdates < 0)
-            return this;
-
-        if (lazyUpdates > 100)
-            throw new IllegalArgumentException("lazyUpdates has to be in [0, 100], to disable it use 0");
-
-        this.lastNodesLazyUpdatePercentage = lazyUpdates;
-        return this;
-    }
-
-    /**
-     * @param neighborUpdates specifies how often neighbor updates will happen. 100 means always.
-     */
-    public PrepareContractionHierarchies setNeighborUpdates(int neighborUpdates) {
-        if (neighborUpdates < 0)
-            return this;
-
-        if (neighborUpdates > 100)
-            throw new IllegalArgumentException("neighborUpdates has to be in [0, 100], to disable it use 0");
-
-        this.neighborUpdatePercentage = neighborUpdates;
-        return this;
+    public static PrepareContractionHierarchies fromGraphHopperStorage(GraphHopperStorage ghStorage, Weighting weighting, TraversalMode traversalMode) {
+        return new PrepareContractionHierarchies(ghStorage.getCHGraph(weighting), weighting, traversalMode);
     }
 
-    /**
-     * Specifies how often a log message should be printed. Specify something around 20 (20% of the
-     * start nodes).
-     */
-    public PrepareContractionHierarchies setLogMessages(double logMessages) {
-        if (logMessages >= 0)
-            this.logMessagesPercentage = logMessages;
+    public PrepareContractionHierarchies setParams(PMap pMap) {
+        this.pMap = pMap;
+        params.setPeriodicUpdatesPercentage(pMap.getInt(PERIODIC_UPDATES, params.getPeriodicUpdatesPercentage()));
+        params.setLastNodesLazyUpdatePercentage(pMap.getInt(LAST_LAZY_NODES_UPDATES, params.getLastNodesLazyUpdatePercentage()));
+        params.setNeighborUpdatePercentage(pMap.getInt(NEIGHBOR_UPDATES, params.getNeighborUpdatePercentage()));
+        params.setNodesContractedPercentage(pMap.getInt(CONTRACTED_NODES, params.getNodesContractedPercentage()));
+        params.setLogMessagesPercentage(pMap.getInt(LOG_MESSAGES, params.getLogMessagesPercentage()));
         return this;
     }
 
     /**
-     * Define how many nodes (percentage) should be contracted. Less nodes means slower query but
-     * faster contraction duration.
+     * Instead of heuristically determining a node ordering for the graph contraction it is also possible
+     * to use a fixed ordering. For example this allows re-using a previously calculated node ordering.
+     * This will speed up CH preparation, but might lead to slower queries.
      */
-    public PrepareContractionHierarchies setContractedNodes(double nodesContracted) {
-        if (nodesContracted < 0)
-            return this;
-
-        if (nodesContracted > 100)
-            throw new IllegalArgumentException("setNodesContracted can be 100% maximum");
-
-        this.nodesContractedPercentage = nodesContracted;
+    public PrepareContractionHierarchies useFixedNodeOrdering(NodeOrderingProvider nodeOrderingProvider) {
+        if (nodeOrderingProvider.getNumNodes() != prepareGraph.getNodes()) {
+            throw new IllegalArgumentException(
+                    "contraction order size (" + nodeOrderingProvider.getNumNodes() + ")" +
+                            " must be equal to number of nodes in graph (" + prepareGraph.getNodes() + ").");
+        }
+        this.nodeOrderingProvider = nodeOrderingProvider;
         return this;
     }
 
     @Override
     public void doSpecificWork() {
+        if (!prepareGraph.isReadyForContraction()) {
+            throw new IllegalStateException("Given CHGraph has not been frozen yet");
+        }
         allSW.start();
         initFromGraph();
         runGraphContraction();
+        allSW.stop();
+        logFinalGraphStats();
+    }
 
-        logger.info("took:" + (int) allSW.stop().getSeconds() + "s "
-                + ", new shortcuts: " + nf(nodeContractor.getAddedShortcutsCount())
-                + ", initSize:" + nf(initSize)
-                + ", " + prepareWeighting
-                + ", periodic:" + periodicUpdatesPercentage
-                + ", lazy:" + lastNodesLazyUpdatePercentage
-                + ", neighbor:" + neighborUpdatePercentage
-                + ", " + getTimesAsString()
-                + ", lazy-overhead: " + (int) (100 * ((checkCounter / (double) initSize) - 1)) + "%"
-                + ", " + Helper.getMemInfo());
-
-        int edgeCount = ghStorage.getAllEdges().length();
-        logger.info("graph now - num edges: {}, num nodes: {}, num shortcuts: {}",
-                nf(edgeCount), nf(ghStorage.getNodes()), nf(prepareGraph.getAllEdges().length() - edgeCount));
+    private void logFinalGraphStats() {
+        int edgeCount = prepareGraph.getOriginalEdges();
+        logger.info("took: {}s, graph now - num edges: {}, num nodes: {}, num shortcuts: {}",
+                (int) allSW.getSeconds(), nf(edgeCount), nf(prepareGraph.getNodes()), nf(prepareGraph.getEdges() - edgeCount));
     }
 
-    protected void runGraphContraction() {
-        if (!prepareNodes())
+    private void runGraphContraction() {
+        if (prepareGraph.getNodes() < 1)
             return;
-        contractNodes();
+        setMaxLevelOnAllNodes();
+        if (nodeOrderingProvider != null) {
+            contractNodesUsingFixedNodeOrdering();
+        } else {
+            contractNodesUsingHeuristicNodeOrdering();
+        }
+
     }
 
     @Override
@@ -197,22 +150,44 @@ public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
     }
 
     private AbstractBidirAlgo doCreateAlgo(Graph graph, AlgorithmOptions opts) {
+        if (traversalMode.isEdgeBased()) {
+            return createAlgoEdgeBased(graph, opts);
+        } else {
+            return createAlgoNodeBased(graph, opts);
+        }
+    }
+
+    private AbstractBidirAlgo createAlgoEdgeBased(Graph graph, AlgorithmOptions opts) {
         if (ASTAR_BI.equals(opts.getAlgorithm())) {
-            return new AStarBidirectionCH(graph, prepareWeighting, traversalMode)
+            return new AStarBidirectionEdgeCHNoSOD(graph, createTurnWeightingForEdgeBased(graph))
+                    .setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
+        } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
+            return new DijkstraBidirectionEdgeCHNoSOD(graph, createTurnWeightingForEdgeBased(graph));
+        } else {
+            throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for edge-based Contraction Hierarchies. Try with ch.disable=true");
+        }
+    }
+
+    private AbstractBidirAlgo createAlgoNodeBased(Graph graph, AlgorithmOptions opts) {
+        if (ASTAR_BI.equals(opts.getAlgorithm())) {
+            return new AStarBidirectionCH(graph, prepareWeighting)
                     .setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
         } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
             if (opts.getHints().getBool("stall_on_demand", true)) {
-                return new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
+                return new DijkstraBidirectionCH(graph, prepareWeighting);
             } else {
-                return new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
+                return new DijkstraBidirectionCHNoSOD(graph, prepareWeighting);
             }
         } else {
-            throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
+            throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for node-based Contraction Hierarchies. Try with ch.disable=true");
         }
     }
 
+    public boolean isEdgeBased() {
+        return traversalMode.isEdgeBased();
+    }
+
     private void initFromGraph() {
-        ghStorage.freeze();
         FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
         final EdgeFilter allFilter = DefaultEdgeFilter.allEdges(prepareFlagEncoder);
         maxLevel = prepareGraph.getNodes();
@@ -226,77 +201,76 @@ private void initFromGraph() {
         //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
         oldPriorities = new float[prepareGraph.getNodes()];
-        nodeContractor = new NodeBasedNodeContractor(dir, ghStorage, prepareGraph, weighting);
+        nodeContractor = createNodeContractor(prepareGraph, traversalMode);
         nodeContractor.initFromGraph();
     }
 
-    private boolean prepareNodes() {
-        int nodes = prepareGraph.getNodes();
+    private void setMaxLevelOnAllNodes() {
+        final int nodes = prepareGraph.getNodes();
         for (int node = 0; node < nodes; node++) {
             prepareGraph.setLevel(node, maxLevel);
         }
+    }
+
+    private void updatePrioritiesOfRemainingNodes() {
         periodicUpdateSW.start();
+        sortedNodes.clear();
+        final int nodes = prepareGraph.getNodes();
         for (int node = 0; node < nodes; node++) {
+            if (prepareGraph.getLevel(node) != maxLevel)
+                continue;
             float priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
         }
         periodicUpdateSW.stop();
-
-        return !sortedNodes.isEmpty();
     }
 
-    private void contractNodes() {
+    private void contractNodesUsingHeuristicNodeOrdering() {
+        // note that we update the priorities before preparing the node contractor. this does not make much sense,
+        // but has always been like that and changing it would possibly require retuning the contraction parameters
+        updatePrioritiesOfRemainingNodes();
         nodeContractor.prepareContraction();
-        initSize = sortedNodes.getSize();
+        int initSize = sortedNodes.getSize();
         int level = 0;
         checkCounter = 0;
-        long logSize = Math.round(Math.max(10, initSize / 100d * logMessagesPercentage));
-        if (logMessagesPercentage == 0)
+        long logSize = Math.round(Math.max(10, initSize / 100d * params.getLogMessagesPercentage()));
+        if (params.getLogMessagesPercentage() == 0)
             logSize = Integer.MAX_VALUE;
 
         // preparation takes longer but queries are slightly faster with preparation
         // => enable it but call not so often
         boolean periodicUpdate = true;
         int updateCounter = 0;
-        long periodicUpdatesCount = Math.round(Math.max(10, sortedNodes.getSize() / 100d * periodicUpdatesPercentage));
-        if (periodicUpdatesPercentage == 0)
+        long periodicUpdatesCount = Math.round(Math.max(10, sortedNodes.getSize() / 100d * params.getPeriodicUpdatesPercentage()));
+        if (params.getPeriodicUpdatesPercentage() == 0)
             periodicUpdate = false;
 
         // disable lazy updates for last x percentage of nodes as preparation is then a lot slower
         // and query time does not really benefit
-        long lastNodesLazyUpdates = Math.round(sortedNodes.getSize() / 100d * lastNodesLazyUpdatePercentage);
+        long lastNodesLazyUpdates = Math.round(sortedNodes.getSize() / 100d * params.getLastNodesLazyUpdatePercentage());
 
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
         // we don't need to wait for all nodes to be contracted
-        long nodesToAvoidContract = Math.round((100 - nodesContractedPercentage) / 100d * sortedNodes.getSize());
+        long nodesToAvoidContract = Math.round((100 - params.getNodesContractedPercentage()) / 100d * sortedNodes.getSize());
 
         // Recompute priority of uncontracted neighbors.
         // Without neighbor updates preparation is faster but we need them
         // to slightly improve query time. Also if not applied too often it decreases the shortcut number.
         boolean neighborUpdate = true;
-        if (neighborUpdatePercentage == 0)
+        if (params.getNeighborUpdatePercentage() == 0)
             neighborUpdate = false;
 
         while (!sortedNodes.isEmpty()) {
             // periodically update priorities of ALL nodes
             if (periodicUpdate && checkCounter > 0 && checkCounter % periodicUpdatesCount == 0) {
-                periodicUpdateSW.start();
-                sortedNodes.clear();
-                for (int node = 0; node < prepareGraph.getNodes(); node++) {
-                    if (prepareGraph.getLevel(node) != maxLevel)
-                        continue;
-
-                    float priority = oldPriorities[node] = calculatePriority(node);
-                    sortedNodes.insert(node, priority);
-                }
-                periodicUpdateSW.stop();
+                updatePrioritiesOfRemainingNodes();
                 updateCounter++;
                 if (sortedNodes.isEmpty())
                     throw new IllegalStateException("Cannot prepare as no unprepared nodes where found. Called preparation twice?");
             }
 
             if (checkCounter % logSize == 0) {
-                logStats(updateCounter);
+                logHeuristicStats(updateCounter);
             }
 
             checkCounter++;
@@ -315,16 +289,15 @@ private void contractNodes() {
             }
 
             // contract node v!
-            contractionSW.start();
-            nodeContractor.contractNode(polledNode);
-            prepareGraph.setLevel(polledNode, level);
+            contractNode(polledNode, level);
             level++;
-            contractionSW.stop();
 
             if (sortedNodes.getSize() < nodesToAvoidContract)
                 // skipped nodes are already set to maxLevel
                 break;
 
+            // there might be multiple edges going to the same neighbor nodes -> only calculate priority once per node
+            IntSet updatedNeighors = new IntHashSet(10);
             CHEdgeIterator iter = vehicleAllExplorer.setBaseNode(polledNode);
             while (iter.next()) {
 
@@ -336,13 +309,14 @@ private void contractNodes() {
                 if (prepareGraph.getLevel(nn) != maxLevel)
                     continue;
 
-                if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage) {
+                if (neighborUpdate && !updatedNeighors.contains(nn) && rand.nextInt(100) < params.getNeighborUpdatePercentage()) {
                     neighborUpdateSW.start();
                     float oldPrio = oldPriorities[nn];
                     float priority = oldPriorities[nn] = calculatePriority(nn);
-                    if (priority != oldPrio)
+                    if (priority != oldPrio) {
                         sortedNodes.update(nn, oldPrio, priority);
-
+                        updatedNeighors.add(nn);
+                    }
                     neighborUpdateSW.stop();
                 }
 
@@ -350,13 +324,81 @@ private void contractNodes() {
             }
         }
 
-        logStats(updateCounter);
+        logHeuristicStats(updateCounter);
+
+        logger.info(
+                "new shortcuts: " + nf(nodeContractor.getAddedShortcutsCount())
+                        + ", initSize:" + nf(initSize)
+                        + ", " + prepareWeighting
+                        + ", periodic:" + params.getPeriodicUpdatesPercentage()
+                        + ", lazy:" + params.getLastNodesLazyUpdatePercentage()
+                        + ", neighbor:" + params.getNeighborUpdatePercentage()
+                        + ", " + getTimesAsString()
+                        + ", lazy-overhead: " + (int) (100 * ((checkCounter / (double) initSize) - 1)) + "%"
+                        + ", " + Helper.getMemInfo());
 
         // Preparation works only once so we can release temporary data.
         // The preparation object itself has to be intact to create the algorithm.
         close();
     }
 
+    private void contractNodesUsingFixedNodeOrdering() {
+        nodeContractor.prepareContraction();
+        final int nodesToContract = nodeOrderingProvider.getNumNodes();
+        final int logSize = Math.max(10, (int) (params.getLogMessagesPercentage() / 100.0 * nodesToContract));
+        StopWatch stopWatch = new StopWatch();
+        stopWatch.start();
+        for (int i = 0; i < nodesToContract; ++i) {
+            int node = nodeOrderingProvider.getNodeIdForLevel(i);
+            contractNode(node, i);
+
+            // disconnect neighbors
+            CHEdgeIterator iter = vehicleAllExplorer.setBaseNode(node);
+            while (iter.next()) {
+                if (prepareGraph.getLevel(iter.getAdjNode()) != maxLevel)
+                    continue;
+                prepareGraph.disconnect(vehicleAllTmpExplorer, iter);
+            }
+            if (i % logSize == 0) {
+                stopWatch.stop();
+                logFixedNodeOrderingStats(i, logSize, stopWatch);
+                stopWatch.start();
+            }
+        }
+    }
+
+    private void contractNode(int node, int level) {
+        contractionSW.start();
+        nodeContractor.contractNode(node);
+        prepareGraph.setLevel(node, level);
+        contractionSW.stop();
+    }
+
+    private void logHeuristicStats(int updateCounter) {
+        logger.info(String.format(Locale.ROOT,
+                "nodes: %10s, shortcuts: %10s, updates: %2d, checked-nodes: %10s, %s, %s, %s",
+                nf(sortedNodes.getSize()),
+                nf(nodeContractor.getAddedShortcutsCount()),
+                updateCounter,
+                nf(checkCounter),
+                getTimesAsString(),
+                nodeContractor.getStatisticsString(),
+                Helper.getMemInfo()));
+    }
+
+    private void logFixedNodeOrderingStats(int nodesContracted, int logSize, StopWatch stopWatch) {
+        logger.info(String.format(Locale.ROOT,
+                "nodes: %10s / %10s (%6.2f%%), shortcuts: %10s, speed = %6.2f nodes/ms, %s, %s",
+                nf(nodesContracted),
+                nf(prepareGraph.getNodes()),
+                (100.0 * nodesContracted / prepareGraph.getNodes()),
+                nf(nodeContractor.getAddedShortcutsCount()),
+                nodesContracted == 0 ? 0 : logSize / (double) stopWatch.getMillis(),
+                nodeContractor.getStatisticsString(),
+                Helper.getMemInfo())
+        );
+    }
+
     private void close() {
         nodeContractor.close();
         sortedNodes = null;
@@ -384,7 +426,7 @@ public double getNeighborTime() {
     }
 
     public Weighting getWeighting() {
-        return prepareGraph.getWeighting();
+        return weighting;
     }
 
     private String getTimesAsString() {
@@ -397,8 +439,8 @@ private String getTimesAsString() {
         // dijkstra time is included in the others
         float dijkstraTime = nodeContractor.getDijkstraSeconds();
         return String.format(Locale.ROOT,
-                "t(total): %6.2f,  t(period): %6.2f, t(lazy): %6.2f, t(neighbor): %6.2f, t(contr): %6.2f, t(other) : %6.2f, t(dijk): %6.2f",
-                totalTime, periodicUpdateTime, lazyUpdateTime, neighborUpdateTime, contractionTime, otherTime, dijkstraTime);
+                "t(total): %6.2f,  t(period): %6.2f, t(lazy): %6.2f, t(neighbor): %6.2f, t(contr): %6.2f, t(other) : %6.2f, dijkstra-ratio: %6.2f%%",
+                totalTime, periodicUpdateTime, lazyUpdateTime, neighborUpdateTime, contractionTime, otherTime, dijkstraTime / totalTime * 100);
     }
 
     private float calculatePriority(int node) {
@@ -407,18 +449,121 @@ private float calculatePriority(int node) {
 
     @Override
     public String toString() {
-        return "prepare|dijkstrabi|ch";
+        return traversalMode.isEdgeBased() ? "prepare|dijkstrabi|edge|ch" : "prepare|dijkstrabi|ch";
     }
 
-    private void logStats(int updateCounter) {
-        logger.info(String.format(Locale.ROOT,
-                "nodes: %10s, shortcuts: %10s, updates: %2d, checked-nodes: %10s, %s, %s, %s",
-                nf(sortedNodes.getSize()),
-                nf(nodeContractor.getAddedShortcutsCount()),
-                updateCounter,
-                nf(checkCounter),
-                getTimesAsString(),
-                nodeContractor.getStatisticsString(),
-                Helper.getMemInfo()));
+    private NodeContractor createNodeContractor(Graph graph, TraversalMode traversalMode) {
+        if (traversalMode.isEdgeBased()) {
+            TurnWeighting chTurnWeighting = createTurnWeightingForEdgeBased(graph);
+            return new EdgeBasedNodeContractor(prepareGraph, chTurnWeighting, pMap);
+        } else {
+            return new NodeBasedNodeContractor(prepareGraph, weighting, pMap);
+        }
+    }
+
+    private TurnWeighting createTurnWeightingForEdgeBased(Graph graph) {
+        // important: do not simply take the extension from ghStorage, because we need the wrapped extension from
+        // query graph!
+        GraphExtension extension = graph.getExtension();
+        if (!(extension instanceof TurnCostExtension)) {
+            throw new IllegalArgumentException("For edge-based CH you need a turn cost extension");
+        }
+        TurnCostExtension turnCostExtension = (TurnCostExtension) extension;
+        return new TurnWeighting(prepareWeighting, turnCostExtension);
+    }
+
+    private static class Params {
+        /**
+         * Specifies how often periodic updates will happen. The higher the value the longer the preparation takes
+         * but the less shortcuts are produced.
+         */
+        private int periodicUpdatesPercentage;
+        /**
+         * Specifies when lazy updates will happen, measured relative to all existing nodes. 100 means always.
+         */
+        private int lastNodesLazyUpdatePercentage;
+        /**
+         * Specifies how often neighbor updates will happen. 100 means always.
+         */
+        private int neighborUpdatePercentage;
+        /**
+         * Defines how many nodes (percentage) should be contracted. Less nodes means slower query but
+         * faster contraction.
+         */
+        private int nodesContractedPercentage;
+        /**
+         * Specifies how often a log message should be printed. Specify something around 20 (20% of the
+         * start nodes).
+         */
+        private int logMessagesPercentage;
+
+        static Params forTraversalMode(TraversalMode traversalMode) {
+            if (traversalMode.isEdgeBased()) {
+                // todo: optimize
+                return new Params(0, 100, 0, 100, 5);
+            } else {
+                return new Params(20, 10, 20, 100, 20);
+            }
+        }
+
+        private Params(int periodicUpdatesPercentage, int lastNodesLazyUpdatePercentage, int neighborUpdatePercentage,
+                       int nodesContractedPercentage, int logMessagesPercentage) {
+            setPeriodicUpdatesPercentage(periodicUpdatesPercentage);
+            setLastNodesLazyUpdatePercentage(lastNodesLazyUpdatePercentage);
+            setNeighborUpdatePercentage(neighborUpdatePercentage);
+            setNodesContractedPercentage(nodesContractedPercentage);
+            setLogMessagesPercentage(logMessagesPercentage);
+        }
+
+        int getPeriodicUpdatesPercentage() {
+            return periodicUpdatesPercentage;
+        }
+
+        void setPeriodicUpdatesPercentage(int periodicUpdatesPercentage) {
+            checkPercentage(PERIODIC_UPDATES, periodicUpdatesPercentage);
+            this.periodicUpdatesPercentage = periodicUpdatesPercentage;
+        }
+
+        int getLastNodesLazyUpdatePercentage() {
+            return lastNodesLazyUpdatePercentage;
+        }
+
+        void setLastNodesLazyUpdatePercentage(int lastNodesLazyUpdatePercentage) {
+            checkPercentage(LAST_LAZY_NODES_UPDATES, lastNodesLazyUpdatePercentage);
+            this.lastNodesLazyUpdatePercentage = lastNodesLazyUpdatePercentage;
+        }
+
+        int getNeighborUpdatePercentage() {
+            return neighborUpdatePercentage;
+        }
+
+        void setNeighborUpdatePercentage(int neighborUpdatePercentage) {
+            checkPercentage(NEIGHBOR_UPDATES, neighborUpdatePercentage);
+            this.neighborUpdatePercentage = neighborUpdatePercentage;
+        }
+
+        int getNodesContractedPercentage() {
+            return nodesContractedPercentage;
+        }
+
+        void setNodesContractedPercentage(int nodesContractedPercentage) {
+            checkPercentage(CONTRACTED_NODES, nodesContractedPercentage);
+            this.nodesContractedPercentage = nodesContractedPercentage;
+        }
+
+        int getLogMessagesPercentage() {
+            return logMessagesPercentage;
+        }
+
+        void setLogMessagesPercentage(int logMessagesPercentage) {
+            checkPercentage(LOG_MESSAGES, logMessagesPercentage);
+            this.logMessagesPercentage = logMessagesPercentage;
+        }
+
+        private void checkPercentage(String name, int value) {
+            if (value < 0 || value > 100) {
+                throw new IllegalArgumentException(name + " has to be in [0, 100], to disable it use 0");
+            }
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
index b9c8c56b97..9726d8ae2d 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareEncoder.java
@@ -25,28 +25,28 @@
  */
 public class PrepareEncoder {
     // shortcut goes in one or both directions is also possible if weight is identical    
-    private static final long scFwdDir = 0x1;
-    private static final long scBwdDir = 0x2;
-    private static final long scDirMask = 0x3;
+    private static final int scFwdDir = 0x1;
+    private static final int scBwdDir = 0x2;
+    private static final int scDirMask = 0x3;
 
     /**
      * A bitmask for two directions
      */
-    public static final long getScDirMask() {
+    public static final int getScDirMask() {
         return scDirMask;
     }
 
     /**
      * The bit for forward direction
      */
-    public static final long getScFwdDir() {
+    public static final int getScFwdDir() {
         return scFwdDir;
     }
 
     /**
      * The bit for backward direction
      */
-    public static final long getScBwdDir() {
+    public static final int getScBwdDir() {
         return scBwdDir;
     }
 
@@ -66,7 +66,7 @@ public static final long getScBwdDir() {
      * @return 1 if newScFlags is identical to existingScFlags for the two direction bits and 0 otherwise.
      * There are two special cases when it returns 2.
      */
-    public static final int getScMergeStatus(long existingScFlags, long newScFlags) {
+    public static final int getScMergeStatus(int existingScFlags, int newScFlags) {
         if ((existingScFlags & scDirMask) == (newScFlags & scDirMask))
             return 1;
         else if ((newScFlags & scDirMask) == scDirMask)
diff --git a/core/src/main/java/com/graphhopper/routing/ch/WitnessPathSearcher.java b/core/src/main/java/com/graphhopper/routing/ch/WitnessPathSearcher.java
new file mode 100644
index 0000000000..f47a0175e7
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/WitnessPathSearcher.java
@@ -0,0 +1,525 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.carrotsearch.hppc.IntObjectHashMap;
+import com.carrotsearch.hppc.IntObjectMap;
+import com.graphhopper.apache.commons.collections.IntDoubleBinaryHeap;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.util.*;
+
+import java.util.Arrays;
+import java.util.Locale;
+
+import static com.graphhopper.routing.ch.CHParameters.*;
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+import static java.lang.Double.isInfinite;
+
+/**
+ * Helper class used to perform local witness path searches for graph preparation in edge-based Contraction Hierarchies.
+ * <p>
+ * (source edge) -- s -- x -- t -- (target edge)
+ * Let x be a node to be contracted (the 'center node') and s and t neighboring un-contracted nodes of x that are
+ * directly connected with x (via a normal edge or a shortcut). This class is used to examine the optimal path
+ * between s and t in the graph of not yet contracted nodes. More precisely it looks at the minimal-weight-path from an
+ * original edge incoming to s (the 'source edge') to an arbitrary original edge incoming to t where the turn-costs at t
+ * onto a given original edge outgoing from t (the 'target edge') are also considered. This class is mainly used to
+ * differentiate between the following two cases:
+ * <p>
+ * 1) The optimal path described above has finite weight and only consists of one edge from s to x, an arbitrary number
+ * of loops at x, and one edge from x to t. This is called a 'bridge-path' here.
+ * 2) The optimal path has infinite weight or it includes an edge from s to another node than x or an edge from another
+ * node than x to t. This is called a 'witness-path'.
+ * <p>
+ * To find the optimal path an edge-based unidirectional Dijkstra algorithm is used that takes into account turn-costs.
+ * The search can be initialized for a given source edge and node to be contracted x. Subsequent searches for different
+ * target edges will keep on building the shortest path tree from previous searches. For the performance of edge-based
+ * CH graph preparation it is crucial to limit the local witness path searches. However the search always needs to at
+ * least find the best bridge-path if one exists. Therefore we may stop expanding edges when a certain amount of settled
+ * edges is exceeded, but even then we still need to expand edges that could possibly yield a bridge-path and we may
+ * only stop this when it is guaranteed that no bridge-path exists. Here we limit the maximum number of settled
+ * edges during the search and determine this maximum number based on the statistics we collected during previous
+ * searches.
+ *
+ * @author easbar
+ */
+public class WitnessPathSearcher {
+    private static final int NO_NODE = -1;
+    private static final double MAX_ZERO_WEIGHT_LOOP = 1.e-3;
+
+    // graph variables
+    private final CHGraph chGraph;
+    private final TurnWeighting turnWeighting;
+    private final EdgeExplorer outEdgeExplorer;
+    private final EdgeExplorer origInEdgeExplorer;
+    private final int maxLevel;
+
+    // general parameters affecting the number of found witnesses and the search time
+    private final Params params = new Params();
+
+    // variables of the current search
+    private int sourceEdge;
+    private int sourceNode;
+    private int centerNode;
+    private double bestPathWeight;
+    private int bestPathIncEdge;
+    private boolean bestPathIsBridgePath;
+    private int numPathsToCenter;
+    private int numSettledEdges;
+    private int numPolledEdges;
+
+    // data structures used to build the shortest path tree
+    // we allocate memory for all possible edge keys and keep track which ones have been discovered so far
+    private double[] weights;
+    private int[] edges;
+    private int[] incEdges;
+    private int[] parents;
+    private int[] adjNodes;
+    private boolean[] isPathToCenters;
+    private IntObjectMap<CHEntry> initialEntryParents;
+    private IntArrayList changedEdges;
+    private IntDoubleBinaryHeap dijkstraHeap;
+
+    // we keep track of the average number and distribution width of settled edges during the last searches to estimate
+    // an appropriate maximum of settled edges for the next searches
+    private int maxSettledEdges;
+    private final OnFlyStatisticsCalculator settledEdgesStats = new OnFlyStatisticsCalculator();
+
+    // statistics to analyze performance
+    private final Stats currentBatchStats = new Stats();
+    private final Stats totalStats = new Stats();
+
+    public WitnessPathSearcher(CHGraph chGraph, TurnWeighting turnWeighting, PMap pMap) {
+        this.chGraph = chGraph;
+        this.turnWeighting = turnWeighting;
+        extractParams(pMap);
+
+        DefaultEdgeFilter inEdgeFilter = DefaultEdgeFilter.inEdges(turnWeighting.getFlagEncoder());
+        DefaultEdgeFilter outEdgeFilter = DefaultEdgeFilter.outEdges(turnWeighting.getFlagEncoder());
+        outEdgeExplorer = chGraph.createEdgeExplorer(outEdgeFilter);
+        origInEdgeExplorer = chGraph.createOriginalEdgeExplorer(inEdgeFilter);
+        maxLevel = chGraph.getNodes();
+
+        maxSettledEdges = params.minimumMaxSettledEdges;
+        int numOriginalEdges = chGraph.getOriginalEdges();
+        initStorage(2 * numOriginalEdges);
+        initCollections();
+    }
+
+    private void extractParams(PMap pMap) {
+        params.sigmaFactor = pMap.getDouble(SIGMA_FACTOR, params.sigmaFactor);
+        params.minimumMaxSettledEdges = pMap.getInt(MIN_MAX_SETTLED_EDGES, params.minimumMaxSettledEdges);
+        params.settledEdgeStatsResetInterval = pMap.getInt(SETTLED_EDGES_RESET_INTERVAL, params.settledEdgeStatsResetInterval);
+    }
+
+    /**
+     * Deletes the shortest path tree that has been found so far and initializes a new witness path search for a given
+     * node to be contracted and search edge.
+     *
+     * @param centerNode the node to be contracted (x)
+     * @param sourceNode the neighbor node from which the search starts (s)
+     * @param sourceEdge the original edge incoming to s from which the search starts
+     * @return the number of initial entries and always 0 if we can not directly reach the center node from the given
+     * source edge, e.g. when turn costs at s do not allow this.
+     */
+    public int initSearch(int centerNode, int sourceNode, int sourceEdge) {
+        reset();
+        this.sourceEdge = sourceEdge;
+        this.sourceNode = sourceNode;
+        this.centerNode = centerNode;
+        setInitialEntries(sourceNode, sourceEdge, centerNode);
+        // if there is no entry that reaches the center node we won't need to search for any witnesses
+        if (numPathsToCenter < 1) {
+            reset();
+            return 0;
+        }
+        currentBatchStats.numSearches++;
+        currentBatchStats.maxNumSettledEdges += maxSettledEdges;
+        totalStats.numSearches++;
+        totalStats.maxNumSettledEdges += maxSettledEdges;
+        return dijkstraHeap.getSize();
+    }
+
+    /**
+     * Runs a witness path search for a given target edge. Results of previous searches (the shortest path tree) are
+     * reused and the previous search is extended if necessary. Note that you need to call
+     * {@link #initSearch(int, int, int)} before calling this method to initialize the search.
+     *
+     * @param targetNode the neighbor node that should be reached by the path (t)
+     * @param targetEdge the original edge outgoing from t where the search ends
+     * @return the leaf shortest path tree entry (including all ancestor entries) ending in an edge incoming in t if a
+     * 'bridge-path' (see above) has been found to be the optimal path or null if the optimal path is either a witness
+     * path or no finite weight path starting with the search edge and leading to the target edge could be found at all.
+     */
+    public CHEntry runSearch(int targetNode, int targetEdge) {
+        // if source and target are equal we already have a candidate for the best path: a simple turn from the source
+        // to the target edge
+        bestPathWeight = sourceNode == targetNode
+                ? calcTurnWeight(sourceEdge, sourceNode, targetEdge)
+                : Double.POSITIVE_INFINITY;
+        bestPathIncEdge = NO_EDGE;
+        bestPathIsBridgePath = false;
+
+        // check if we can already reach the target from the shortest path tree we discovered so far
+        EdgeIterator inIter = origInEdgeExplorer.setBaseNode(targetNode);
+        while (inIter.next()) {
+            final int incEdge = inIter.getOrigEdgeLast();
+            final int edgeKey = getEdgeKey(incEdge, targetNode);
+            if (EdgeIterator.Edge.isValid(edges[edgeKey])) {
+                boolean isZeroWeightLoop = parents[edgeKey] >= 0 && targetNode == adjNodes[parents[edgeKey]] &&
+                        weights[edgeKey] - weights[parents[edgeKey]] <= MAX_ZERO_WEIGHT_LOOP;
+                if (!isZeroWeightLoop) {
+                    // we may not update the best path if we are dealing with a zero weight loop here, because when a
+                    // zero weight loop updates the best path to be no longer a bridge path we cannot trust that there
+                    // will be a shortcut leading to the zero weight loop in case there are multiple zero weight loops.
+                    updateBestPath(targetNode, targetEdge, edgeKey);
+                }
+            }
+        }
+
+        // run dijkstra to find the optimal path
+        while (!dijkstraHeap.isEmpty()) {
+            if (numPathsToCenter < 1 && (!bestPathIsBridgePath || isInfinite(bestPathWeight))) {
+                // we have not found a connection to the target edge yet and there are no entries on the heap anymore 
+                // that could yield a bridge-path
+                break;
+            }
+            final int currKey = dijkstraHeap.peek_element();
+            if (weights[currKey] > bestPathWeight) {
+                // just reaching this edge is more expensive than the best path found so far including the turn costs
+                // to reach the target edge -> we can stop
+                // important: we only peeked so far, so we keep the entry for future searches
+                break;
+            }
+            dijkstraHeap.poll_element();
+            numPolledEdges++;
+            currentBatchStats.numPolledEdges++;
+            totalStats.numPolledEdges++;
+
+            if (isPathToCenters[currKey]) {
+                numPathsToCenter--;
+            }
+
+            // after a certain amount of edges has been settled we only expand entries that might yield a bridge-path
+            if (numSettledEdges > maxSettledEdges && !isPathToCenters[currKey]) {
+                continue;
+            }
+
+            final int fromNode = adjNodes[currKey];
+            EdgeIterator iter = outEdgeExplorer.setBaseNode(fromNode);
+            while (iter.next()) {
+                if (isContracted(iter.getAdjNode())) {
+                    continue;
+                }
+                double edgeWeight = turnWeighting.calcWeight(iter, false, incEdges[currKey]);
+                double weight = edgeWeight + weights[currKey];
+                if (isInfinite(weight)) {
+                    continue;
+                }
+                boolean isPathToCenter = this.isPathToCenters[currKey] && iter.getAdjNode() == centerNode;
+                boolean isZeroWeightLoop = fromNode == targetNode && edgeWeight <= MAX_ZERO_WEIGHT_LOOP;
+
+                // dijkstra expansion: add or update current entries
+                int key = getEdgeKey(iter.getOrigEdgeLast(), iter.getAdjNode());
+                if (!EdgeIterator.Edge.isValid(edges[key])) {
+                    setEntry(key, iter, weight, currKey, isPathToCenter);
+                    changedEdges.add(key);
+                    dijkstraHeap.insert_(weight, key);
+                    if (!isZeroWeightLoop) {
+                        updateBestPath(targetNode, targetEdge, key);
+                    }
+                } else if (weight < weights[key]) {
+                    updateEntry(key, iter, weight, currKey, isPathToCenter);
+                    dijkstraHeap.update_(weight, key);
+                    if (!isZeroWeightLoop) {
+                        updateBestPath(targetNode, targetEdge, key);
+                    }
+                }
+            }
+            numSettledEdges++;
+            currentBatchStats.numSettledEdges++;
+            totalStats.numSettledEdges++;
+            // do not keep searching after target node has been expanded first time, should speed up contraction a bit but
+            // leads to less witnesses being found.
+//            if (adjNodes[currKey] == targetNode) {
+//                break;
+//            }
+        }
+
+        if (bestPathIsBridgePath) {
+            int edgeKey = getEdgeKey(bestPathIncEdge, targetNode);
+            CHEntry result = getEntryForKey(edgeKey);
+            // prepend all ancestors
+            CHEntry entry = result;
+            while (parents[edgeKey] >= 0) {
+                edgeKey = parents[edgeKey];
+                CHEntry parent = getEntryForKey(edgeKey);
+                entry.parent = parent;
+                entry = parent;
+            }
+            entry.parent = initialEntryParents.get(parents[edgeKey]);
+            return result;
+        } else {
+            return null;
+        }
+    }
+
+    public String getStatisticsString() {
+        return "last batch: " + currentBatchStats.toString() + " total: " + totalStats.toString();
+    }
+
+    public long getNumPolledEdges() {
+        return numPolledEdges;
+    }
+
+
+    public long getTotalNumSearches() {
+        return totalStats.numSearches;
+    }
+
+    public void resetStats() {
+        currentBatchStats.reset();
+    }
+
+    private void initStorage(int numEntries) {
+        weights = new double[numEntries];
+        Arrays.fill(weights, Double.POSITIVE_INFINITY);
+
+        edges = new int[numEntries];
+        Arrays.fill(edges, NO_EDGE);
+
+        incEdges = new int[numEntries];
+        Arrays.fill(incEdges, NO_EDGE);
+
+        parents = new int[numEntries];
+        Arrays.fill(parents, NO_NODE);
+
+        adjNodes = new int[numEntries];
+        Arrays.fill(adjNodes, NO_NODE);
+
+        isPathToCenters = new boolean[numEntries];
+        Arrays.fill(isPathToCenters, false);
+    }
+
+    private void initCollections() {
+        initialEntryParents = new IntObjectHashMap<>(10);
+        changedEdges = new IntArrayList(1000);
+        dijkstraHeap = new IntDoubleBinaryHeap(1000);
+    }
+
+    private void setInitialEntries(int sourceNode, int sourceEdge, int centerNode) {
+        EdgeIterator outIter = outEdgeExplorer.setBaseNode(sourceNode);
+        while (outIter.next()) {
+            if (isContracted(outIter.getAdjNode())) {
+                continue;
+            }
+            double turnWeight = calcTurnWeight(sourceEdge, sourceNode, outIter.getOrigEdgeFirst());
+            if (isInfinite(turnWeight)) {
+                continue;
+            }
+            double edgeWeight = turnWeighting.calcWeight(outIter, false, NO_EDGE);
+            double weight = turnWeight + edgeWeight;
+            boolean isPathToCenter = outIter.getAdjNode() == centerNode;
+            int incEdge = outIter.getOrigEdgeLast();
+            int adjNode = outIter.getAdjNode();
+            int key = getEdgeKey(incEdge, adjNode);
+            int parentKey = -key - 1;
+            // note that we 'misuse' the parent also to store initial turncost and the first original edge of this 
+            // initial entry
+            CHEntry parent = new CHEntry(
+                    NO_EDGE,
+                    outIter.getOrigEdgeFirst(),
+                    sourceNode, turnWeight);
+            if (!EdgeIterator.Edge.isValid(edges[key])) {
+                // add new initial entry
+                edges[key] = outIter.getEdge();
+                incEdges[key] = incEdge;
+                adjNodes[key] = adjNode;
+                weights[key] = weight;
+                parents[key] = parentKey;
+                isPathToCenters[key] = isPathToCenter;
+                initialEntryParents.put(parentKey, parent);
+                changedEdges.add(key);
+            } else if (weight < weights[key]) {
+                // update existing entry, there may be entries with the same adjNode and last original edge,
+                // but we only need the one with the lowest weight
+                edges[key] = outIter.getEdge();
+                weights[key] = weight;
+                parents[key] = parentKey;
+                isPathToCenters[key] = isPathToCenter;
+                initialEntryParents.put(parentKey, parent);
+            }
+        }
+
+        // now that we know which entries are actually needed we add them to the heap
+        for (int i = 0; i < changedEdges.size(); ++i) {
+            int key = changedEdges.get(i);
+            if (isPathToCenters[key]) {
+                numPathsToCenter++;
+            }
+            dijkstraHeap.insert_(weights[key], key);
+        }
+    }
+
+    private void reset() {
+        updateMaxSettledEdges();
+        numSettledEdges = 0;
+        numPolledEdges = 0;
+        numPathsToCenter = 0;
+        resetShortestPathTree();
+    }
+
+    private void updateMaxSettledEdges() {
+        // we use the statistics of settled edges of a batch of previous witness path searches to dynamically 
+        // approximate the number of settled edges in the next batch
+        settledEdgesStats.addObservation(numSettledEdges);
+        if (settledEdgesStats.getCount() == params.settledEdgeStatsResetInterval) {
+            maxSettledEdges = Math.max(
+                    params.minimumMaxSettledEdges,
+                    (int) (settledEdgesStats.getMean() +
+                            params.sigmaFactor * Math.sqrt(settledEdgesStats.getVariance()))
+            );
+            settledEdgesStats.reset();
+        }
+    }
+
+    private void resetShortestPathTree() {
+        for (int i = 0; i < changedEdges.size(); ++i) {
+            resetEntry(changedEdges.get(i));
+        }
+        changedEdges.elementsCount = 0;
+        initialEntryParents.clear();
+        dijkstraHeap.clear();
+    }
+
+    private void updateBestPath(int targetNode, int targetEdge, int edgeKey) {
+        // whenever we hit the target node we update the best path
+        if (adjNodes[edgeKey] == targetNode) {
+            double totalWeight = weights[edgeKey] + calcTurnWeight(incEdges[edgeKey], targetNode, targetEdge);
+            // there is a path to the target so we know that there must be some parent. therefore a negative parent key
+            // means that the parent is a root parent (a parent of an initial entry) and we did not go via the center
+            // node.
+            boolean isBridgePath = parents[edgeKey] >= 0 && isPathToCenters[parents[edgeKey]];
+            // in case of equal weights we always prefer a witness path over a bridge-path
+            double tolerance = isBridgePath ? 0 : 1.e-6;
+            if (totalWeight - tolerance < bestPathWeight) {
+                bestPathWeight = totalWeight;
+                bestPathIncEdge = incEdges[edgeKey];
+                bestPathIsBridgePath = isBridgePath;
+            }
+        }
+    }
+
+    private void setEntry(int key, EdgeIteratorState edge, double weight, int parent, boolean isPathToCenter) {
+        edges[key] = edge.getEdge();
+        incEdges[key] = edge.getOrigEdgeLast();
+        adjNodes[key] = edge.getAdjNode();
+        weights[key] = weight;
+        parents[key] = parent;
+        if (isPathToCenter) {
+            isPathToCenters[key] = true;
+            numPathsToCenter++;
+        }
+    }
+
+    private void updateEntry(int key, EdgeIteratorState edge, double weight, int currKey, boolean isPathToCenter) {
+        edges[key] = edge.getEdge();
+        weights[key] = weight;
+        parents[key] = currKey;
+        if (isPathToCenter) {
+            if (!isPathToCenters[key]) {
+                numPathsToCenter++;
+            }
+        } else {
+            if (isPathToCenters[key]) {
+                numPathsToCenter--;
+            }
+        }
+        isPathToCenters[key] = isPathToCenter;
+    }
+
+    private void resetEntry(int key) {
+        weights[key] = Double.POSITIVE_INFINITY;
+        edges[key] = NO_EDGE;
+        incEdges[key] = NO_EDGE;
+        parents[key] = NO_NODE;
+        adjNodes[key] = NO_NODE;
+        isPathToCenters[key] = false;
+    }
+
+    private CHEntry getEntryForKey(int edgeKey) {
+        return new CHEntry(edges[edgeKey], incEdges[edgeKey], adjNodes[edgeKey], weights[edgeKey]);
+    }
+
+    private int getEdgeKey(int edge, int adjNode) {
+        int baseNode = chGraph.getOtherNode(edge, adjNode);
+        return GHUtility.createEdgeKey(baseNode, adjNode, edge, false);
+    }
+
+    private double calcTurnWeight(int inEdge, int viaNode, int outEdge) {
+        return turnWeighting.calcTurnWeight(inEdge, viaNode, outEdge);
+    }
+
+    private boolean isContracted(int node) {
+        return chGraph.getLevel(node) != maxLevel;
+    }
+
+    static class Params {
+        /**
+         * Determines the maximum number of settled edges for the next search based on the mean number of settled edges and
+         * the fluctuation in the previous searches. The higher this number the longer the search will last and the more
+         * witness paths will be found. Assuming a normal distribution for example sigmaFactor = 2 means that about 95% of
+         * the searches will be within the limit.
+         */
+        private double sigmaFactor = 3.0;
+        private int minimumMaxSettledEdges = 100;
+        private int settledEdgeStatsResetInterval = 10_000;
+    }
+
+    static class Stats {
+        private long numSearches;
+        private long numPolledEdges;
+        private long numSettledEdges;
+        private long maxNumSettledEdges;
+
+        @Override
+        public String toString() {
+            return String.format(Locale.ROOT,
+                    "limit-exhaustion: %s %%, avg-settled: %s, avg-max-settled: %s, avg-polled-edges: %s",
+                    quotient(numSettledEdges * 100, maxNumSettledEdges),
+                    quotient(numSettledEdges, numSearches),
+                    quotient(maxNumSettledEdges, numSearches),
+                    quotient(numPolledEdges, numSearches));
+        }
+
+        private String quotient(long a, long b) {
+            return b == 0 ? "NaN" : String.format(Locale.ROOT, "%5.1f", a / ((double) b));
+        }
+
+        void reset() {
+            numSearches = 0;
+            numPolledEdges = 0;
+            numSettledEdges = 0;
+            maxNumSettledEdges = 0;
+        }
+
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
index 6144840d5f..b93eae331d 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LMAlgoFactoryDecorator.java
@@ -31,7 +31,6 @@
 import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.Parameters.Landmark;
@@ -88,7 +87,7 @@ public void init(CmdArgs args) {
                 lmSuggestionsLocations.add(loc.trim());
         }
         String lmWeightingsStr = args.get(Landmark.PREPARE + "weightings", "");
-        if (!lmWeightingsStr.isEmpty() && !lmWeightingsStr.equalsIgnoreCase("no")) {
+        if (!lmWeightingsStr.isEmpty() && !lmWeightingsStr.equalsIgnoreCase("no") && !lmWeightingsStr.equalsIgnoreCase("false")) {
             List<String> tmpLMWeightingList = Arrays.asList(lmWeightingsStr.split(","));
             setWeightingsAsStrings(tmpLMWeightingList);
         }
@@ -277,7 +276,7 @@ public boolean loadOrDoWork(final StorableProperties properties) {
         for (final PrepareLandmarks plm : preparations) {
             counter++;
             final int tmpCounter = counter;
-            final String name = AbstractWeighting.weightingToFileName(plm.getWeighting());
+            final String name = AbstractWeighting.weightingToFileName(plm.getWeighting(), false);
             completionService.submit(new Runnable() {
                 @Override
                 public void run() {
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
index 826b979359..2ca516593d 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
@@ -24,6 +24,7 @@
 import com.carrotsearch.hppc.procedures.IntObjectProcedure;
 import com.graphhopper.coll.MapEntry;
 import com.graphhopper.routing.DijkstraBidirectionRef;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.subnetwork.SubnetworkStorage;
 import com.graphhopper.routing.subnetwork.TarjansSCCAlgorithm;
 import com.graphhopper.routing.util.*;
@@ -61,8 +62,6 @@
     // one node has an associated landmark information ('one landmark row'): the forward and backward weight
     private long LM_ROW_LENGTH;
     private int landmarks;
-    private final int FROM_OFFSET;
-    private final int TO_OFFSET;
     private final DataAccess landmarkWeightDA;
     /* every subnetwork has its own landmark mapping but the count of landmarks is always the same */
     private final List<int[]> landmarkIDs;
@@ -74,15 +73,11 @@
     private Weighting lmSelectionWeighting;
     private final TraversalMode traversalMode;
     private boolean initialized;
-    private int minimumNodes = 500_000;
+    private int minimumNodes;
     private final SubnetworkStorage subnetworkStorage;
     private List<LandmarkSuggestion> landmarkSuggestions = Collections.emptyList();
     private SpatialRuleLookup ruleLookup;
     private boolean logDetails = false;
-    /**
-     * 'to' and 'from' fit into 32 bit => 16 bit for each of them => 65536
-     */
-    static final long PRECISION = 1 << 16;
 
     public LandmarkStorage(GraphHopperStorage graph, Directory dir, final Weighting weighting, int landmarks) {
         this.graph = graph;
@@ -111,18 +106,20 @@ public String toString() {
         // Edge based is not really necessary because when adding turn costs while routing we can still
         // use the node based traversal as this is a smaller weight approximation and will still produce correct results
         this.traversalMode = TraversalMode.NODE_BASED;
-        final String name = AbstractWeighting.weightingToFileName(weighting);
+        final String name = AbstractWeighting.weightingToFileName(weighting, false);
         this.landmarkWeightDA = dir.find("landmarks_" + name);
 
         this.landmarks = landmarks;
         // one short per landmark and two directions => 2*2 byte
         this.LM_ROW_LENGTH = landmarks * 4;
-        this.FROM_OFFSET = 0;
-        this.TO_OFFSET = 2;
         this.landmarkIDs = new ArrayList<>();
         this.subnetworkStorage = new SubnetworkStorage(dir, "landmarks_" + name);
     }
 
+    public int getVersion() {
+        return 1;
+    }
+
     /**
      * Specify the maximum possible value for your used area. With this maximum weight value you can influence the storage
      * precision for your weights that help A* finding its way to the goal. The same value is used for all subnetworks.
@@ -214,8 +211,8 @@ public void createLandmarks() {
         this.landmarkWeightDA.create(2000);
         this.landmarkWeightDA.ensureCapacity(maxBytes);
 
-        for (long pointer = 0; pointer < maxBytes; pointer += 2) {
-            landmarkWeightDA.setShort(pointer, (short) SHORT_INFINITY);
+        for (long pointer = 0; pointer < maxBytes; pointer += 4) {
+            landmarkWeightDA.setInt(pointer, (DELTA_INF << FROM_WEIGHT_BITS) | FROM_WEIGHT_INF);
         }
 
         String additionalInfo = "";
@@ -253,7 +250,8 @@ public void createLandmarks() {
         if (ruleLookup != null && ruleLookup.size() > 0) {
             StopWatch sw = new StopWatch().start();
             blockedEdges = findBorderEdgeIds(ruleLookup);
-            tarjanFilter = new BlockedEdgesFilter(encoder, false, true, blockedEdges);
+            tarjanFilter = new BlockedEdgesFilter(encoder.getAccessEnc(), false, true, blockedEdges);
+
             if (logDetails)
                 LOGGER.info("Made " + blockedEdges.size() + " edges inaccessible. Calculated country cut in " + sw.stop().getSeconds() + "s, " + Helper.getMemInfo());
         }
@@ -308,12 +306,14 @@ public void createLandmarks() {
             }
         }
 
-        landmarkWeightDA.setHeader(0 * 4, graph.getNodes());
+        // make backward incompatible to force rebuilt (pre 0.11 releases had nodes count at 0)
+        landmarkWeightDA.setHeader(0 * 4, getVersion());
         landmarkWeightDA.setHeader(1 * 4, landmarks);
         landmarkWeightDA.setHeader(2 * 4, subnetworkCount);
         if (factor * DOUBLE_MLTPL > Integer.MAX_VALUE)
             throw new UnsupportedOperationException("landmark weight factor cannot be bigger than Integer.MAX_VALUE " + factor * DOUBLE_MLTPL);
         landmarkWeightDA.setHeader(3 * 4, (int) Math.round(factor * DOUBLE_MLTPL));
+        landmarkWeightDA.setHeader(4 * 4, graph.getNodes());
 
         // serialize fast byte[] into DataAccess
         subnetworkStorage.create(graph.getNodes());
@@ -407,9 +407,9 @@ private boolean createLandmarksForSubnetwork(final int startNode, final byte[] s
             int lmNodeId = tmpLandmarkNodeIds[lmIdx];
             LandmarkExplorer explorer = new LandmarkExplorer(graph, this, weighting, traversalMode, true);
             explorer.setStartNode(lmNodeId);
-            explorer.setFilter(blockedEdges, false, true);
+            explorer.setFilter(blockedEdges, true, false);
             explorer.runAlgo();
-            explorer.initLandmarkWeights(lmIdx, lmNodeId, LM_ROW_LENGTH, FROM_OFFSET);
+            explorer.initLandmarkWeights(lmIdx, lmNodeId, LM_ROW_LENGTH);
 
             // set subnetwork id to all explored nodes, but do this only for the first landmark
             if (lmIdx == 0) {
@@ -419,9 +419,9 @@ private boolean createLandmarksForSubnetwork(final int startNode, final byte[] s
 
             explorer = new LandmarkExplorer(graph, this, weighting, traversalMode, false);
             explorer.setStartNode(lmNodeId);
-            explorer.setFilter(blockedEdges, true, false);
+            explorer.setFilter(blockedEdges, false, true);
             explorer.runAlgo();
-            explorer.initLandmarkWeights(lmIdx, lmNodeId, LM_ROW_LENGTH, TO_OFFSET);
+            explorer.initLandmarkWeights(lmIdx, lmNodeId, LM_ROW_LENGTH);
 
             if (lmIdx == 0) {
                 if (explorer.setSubnetworks(subnetworks, subnetworkId))
@@ -479,17 +479,14 @@ protected IntHashSet findBorderEdgeIds(SpatialRuleLookup ruleLookup) {
      * a node ID but the internal index of the landmark array.
      */
     int getFromWeight(int landmarkIndex, int node) {
-        int res = (int) landmarkWeightDA.getShort((long) node * LM_ROW_LENGTH + landmarkIndex * 4 + FROM_OFFSET)
-                & 0x0000FFFF;
-        assert res >= 0 : "Negative to weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
-        if (res == SHORT_INFINITY)
-            // TODO can happen if endstanding oneway
-            // we should set a 'from' value to SHORT_MAX if the 'to' value was already set to find real bugs
-            // and what to return? Integer.MAX_VALUE i.e. convert to Double.pos_infinity upstream?
-            return SHORT_MAX;
+        //only the right bits of this integer store the backward value
+        int res = landmarkWeightDA.getInt((long) node * LM_ROW_LENGTH + landmarkIndex * 4) & FROM_WEIGHT_INF;
+
+        if (res == FROM_WEIGHT_INF)
+            return Integer.MAX_VALUE;
         // throw new IllegalStateException("Do not call getFromWeight for wrong landmark[" + landmarkIndex + "]=" + landmarkIDs[landmarkIndex] + " and node " + node);
-        // TODO if(res == MAX) fallback to beeline approximation!?
 
+        assert res >= 0 : "Negative backward weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
         return res;
     }
 
@@ -497,40 +494,87 @@ int getFromWeight(int landmarkIndex, int node) {
      * @return the weight from the specified node to the landmark (specified *as index*)
      */
     int getToWeight(int landmarkIndex, int node) {
-        int res = (int) landmarkWeightDA.getShort((long) node * LM_ROW_LENGTH + landmarkIndex * 4 + TO_OFFSET)
-                & 0x0000FFFF;
-        assert res >= 0 : "Negative to weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
-        if (res == SHORT_INFINITY)
-            return SHORT_MAX;
-//            throw new IllegalStateException("Do not call getToWeight for wrong landmark[" + landmarkIndex + "]=" + landmarkIDs[landmarkIndex] + " and node " + node);
+        int res = landmarkWeightDA.getInt((long) node * LM_ROW_LENGTH + landmarkIndex * 4);
+
+        //the left bits of "res" store the difference between forward and backward value
+        int delta = res >> FROM_WEIGHT_BITS;
 
+        if (delta == DELTA_INF)
+            return Integer.MAX_VALUE;
+        // throw new IllegalStateException("Do not call getToWeight for wrong landmark[" + landmarkIndex + "]=" + landmarkIDs[landmarkIndex] + " and node " + node);
+
+        //the right bits of "res" store the backward value
+        int from = res & FROM_WEIGHT_INF;
+
+        if (from == FROM_WEIGHT_INF) {
+            from = DELTA_INF + 1;
+        }
+
+        //to get the forward value you have to add the backward to the delta value
+        res = from + delta;
+
+        assert res >= 0 : "Negative forward weight " + res + ", landmark index:" + landmarkIndex + ", node:" + node;
         return res;
     }
 
-    // Short.MAX_VALUE = 2^15-1 but we have unsigned short so we need 2^16-1
-    private static final int SHORT_INFINITY = Short.MAX_VALUE * 2 + 1;
-    // We have large values that do not fit into a short, use a specific maximum value
-    private static final int SHORT_MAX = SHORT_INFINITY - 1;
+    // 'to' and 'from' fit into 32 bit => 16 bit for each of them => 65536
+    static final long PRECISION = 1 << 16;
+    /* This value sets the amount of bits used to store the backward weight.
+    The rest of overall 32 bits stores the difference between forward and backward weight*/
+    private static final int FROM_WEIGHT_BITS = 18;
+    // The backward weight is unsigned --> 2^x - 1
+    private static final int FROM_WEIGHT_INF = (int) Math.pow(2, FROM_WEIGHT_BITS) - 1;
+    // This value will be used if the backward weight is too large
+    private static final int FROM_WEIGHT_MAX = FROM_WEIGHT_INF - 1;
+    /* The difference between forward and backward weight is signed
+    --> 2^(31-x) - 1 instead of 2^(32-x) - 1*/
+    private static final int DELTA_INF = (int) Math.pow(2, 31 - FROM_WEIGHT_BITS) - 1;
+    // This value will be used if the difference between these weights is too large and forward > backward
+    private static final int DELTA_MAX = DELTA_INF - 1;
+    // This value will be used if the difference between these weights is too large and forward < backward
+    private static final int DELTA_MIN = -DELTA_INF - 1;
 
     /**
-     * @return false if the value capacity was reached and instead of the real value the SHORT_MAX was stored.
+     * @return false if the value capacity was reached and instead of the real value the MAX was stored.
      */
-    final boolean setWeight(long pointer, double value) {
+    final boolean setWeight(int lmIdx, int nodeId, long rowSize, double value, boolean from) {
         double tmpVal = value / factor;
         if (tmpVal > Integer.MAX_VALUE)
-            throw new UnsupportedOperationException("Cannot store infinity explicitely, pointer=" + pointer + ", value: " + value);
+            throw new UnsupportedOperationException("Cannot store infinity explicitly, landmark: " + lmIdx + ", node: " + nodeId + ", value: " + value);
 
-        if (tmpVal >= SHORT_MAX) {
-            landmarkWeightDA.setShort(pointer, (short) SHORT_MAX);
-            return false;
+        if (from) {
+            if (tmpVal >= FROM_WEIGHT_MAX) {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (DELTA_INF << FROM_WEIGHT_BITS) | FROM_WEIGHT_MAX);
+                return false;
+            } else {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (DELTA_INF << FROM_WEIGHT_BITS) | (int) tmpVal);
+                return true;
+            }
         } else {
-            landmarkWeightDA.setShort(pointer, (short) tmpVal);
-            return true;
+            int fromWeight = getFromWeight(lmIdx, nodeId);
+            int delta;
+            if (fromWeight == Integer.MAX_VALUE) {
+                fromWeight = FROM_WEIGHT_INF;
+                delta = (int) tmpVal - DELTA_INF + 1;
+            } else {
+                delta = (int) tmpVal - fromWeight;
+            }
+
+            if (delta >= DELTA_MAX) {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (DELTA_MAX << FROM_WEIGHT_BITS) | fromWeight);
+                return false;
+            } else if (delta <= DELTA_MIN) {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (DELTA_MIN << FROM_WEIGHT_BITS) | fromWeight);
+                return false;
+            } else {
+                landmarkWeightDA.setInt(nodeId * rowSize + lmIdx * 4, (delta << FROM_WEIGHT_BITS) | fromWeight);
+                return true;
+            }
         }
     }
 
     boolean isInfinity(long pointer) {
-        return ((int) landmarkWeightDA.getShort(pointer) & 0x0000FFFF) == SHORT_INFINITY;
+        return (landmarkWeightDA.getInt(pointer) & FROM_WEIGHT_INF) == FROM_WEIGHT_INF;
     }
 
     int calcWeight(EdgeIteratorState edge, boolean reverse) {
@@ -661,9 +705,13 @@ public boolean loadExisting() {
             if (!subnetworkStorage.loadExisting())
                 throw new IllegalStateException("landmark weights loaded but not the subnetworks!?");
 
-            int nodes = landmarkWeightDA.getHeader(0 * 4);
+            int version = landmarkWeightDA.getHeader(0 * 4);
+            if (version != getVersion())
+                throw new IllegalArgumentException("Cannot load landmark data due to incompatible version. Storage used version: " + version + ", expected: " + getVersion());
+            int nodes = landmarkWeightDA.getHeader(4 * 4);
             if (nodes != graph.getNodes())
                 throw new IllegalArgumentException("Cannot load landmark data as written for different graph storage with " + nodes + " nodes, not " + graph.getNodes());
+
             landmarks = landmarkWeightDA.getHeader(1 * 4);
             int subnetworks = landmarkWeightDA.getHeader(2 * 4);
             factor = landmarkWeightDA.getHeader(3 * 4) / DOUBLE_MLTPL;
@@ -728,7 +776,7 @@ public LandmarkExplorer(Graph g, LandmarkStorage lms, Weighting weighting, Trave
             super(g, weighting, tMode);
             this.lms = lms;
             this.from = from;
-            // set one of the bi directions as already finished            
+            // set one of the bi directions as already finished
             if (from)
                 finishedTo = true;
             else
@@ -737,12 +785,19 @@ public LandmarkExplorer(Graph g, LandmarkStorage lms, Weighting weighting, Trave
             setUpdateBestPath(false);
         }
 
-        public void setFilter(IntHashSet set, boolean bwd, boolean fwd) {
-            EdgeFilter ef = new BlockedEdgesFilter(flagEncoder, bwd, fwd, set);
+        public void setFilter(IntHashSet set, boolean fwd, boolean bwd) {
+            EdgeFilter ef = new BlockedEdgesFilter(flagEncoder.getAccessEnc(), fwd, bwd, set);
             outEdgeExplorer = graph.createEdgeExplorer(ef);
             inEdgeExplorer = graph.createEdgeExplorer(ef);
         }
 
+        public void setStartNode(int startNode) {
+            if (from)
+                initFrom(startNode, 0);
+            else
+                initTo(startNode, 0);
+        }
+
         int getFromCount() {
             return bestWeightMapFrom.size();
         }
@@ -755,13 +810,6 @@ public int getLastNode() {
             return lastNode;
         }
 
-        public void setStartNode(int startNode) {
-            if (from)
-                initFrom(startNode, 0);
-            else
-                initTo(startNode, 0);
-        }
-
         public void runAlgo() {
             super.runAlgo();
         }
@@ -777,7 +825,7 @@ public boolean finished() {
             }
         }
 
-        public boolean setSubnetworks(final byte[] subnetworks, final int subnetworkId) {
+        boolean setSubnetworks(final byte[] subnetworks, final int subnetworkId) {
             if (subnetworkId > 127)
                 throw new IllegalStateException("Too many subnetworks " + subnetworkId);
 
@@ -805,7 +853,7 @@ public boolean apply(int nodeId, SPTEntry value) {
             return failed.get();
         }
 
-        public void initLandmarkWeights(final int lmIdx, int lmNodeId, final long rowSize, final int offset) {
+        public void initLandmarkWeights(final int lmIdx, int lmNodeId, final long rowSize) {
             IntObjectMap<SPTEntry> map = from ? bestWeightMapFrom : bestWeightMapTo;
             final AtomicInteger maxedout = new AtomicInteger(0);
             final Map.Entry<Double, Double> finalMaxWeight = new MapEntry<>(0d, 0d);
@@ -813,7 +861,7 @@ public void initLandmarkWeights(final int lmIdx, int lmNodeId, final long rowSiz
             map.forEach(new IntObjectProcedure<SPTEntry>() {
                 @Override
                 public void apply(int nodeId, SPTEntry b) {
-                    if (!lms.setWeight(nodeId * rowSize + lmIdx * 4 + offset, b.weight)) {
+                    if (!lms.setWeight(lmIdx, nodeId, rowSize, b.weight, from)) {
                         maxedout.incrementAndGet();
                         finalMaxWeight.setValue(Math.max(b.weight, finalMaxWeight.getValue()));
                     }
@@ -822,8 +870,8 @@ public void apply(int nodeId, SPTEntry b) {
 
             if ((double) maxedout.get() / map.size() > 0.1) {
                 LOGGER.warn("landmark " + lmIdx + " (" + nodeAccess.getLatitude(lmNodeId) + "," + nodeAccess.getLongitude(lmNodeId) + "): " +
-                        "too many weights were maxed out (" + maxedout.get() + "/" + map.size() + "). Use a bigger factor than " + lms.factor
-                        + ". For example use the following in the config.properties: weighting=" + weighting.getName() + "|maximum=" + finalMaxWeight.getValue() * 1.2);
+                        "too many " + (from ? "backward" : "delta") + " weights were maxed out (" + maxedout.get() + "/" + map.size() + "). Factor is too small " + lms.factor
+                        + ". To fix this increase maximum in config.yml: prepare.lm.weighting: " + weighting.getName() + "|maximum=" + finalMaxWeight.getValue() * 1.2);
             }
         }
     }
@@ -838,41 +886,41 @@ public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o
         }
     };
 
-    static GHPoint createPoint(Graph graph, int nodeId) {
+    private static GHPoint createPoint(Graph graph, int nodeId) {
         return new GHPoint(graph.getNodeAccess().getLatitude(nodeId), graph.getNodeAccess().getLongitude(nodeId));
     }
 
     final static class RequireBothDirectionsEdgeFilter implements EdgeFilter {
 
-        private FlagEncoder flagEncoder;
+        private BooleanEncodedValue accessEnc;
 
         public RequireBothDirectionsEdgeFilter(FlagEncoder flagEncoder) {
-            this.flagEncoder = flagEncoder;
+            this.accessEnc = flagEncoder.getAccessEnc();
         }
 
         @Override
         public boolean accept(EdgeIteratorState edgeState) {
-            return flagEncoder.isForward(edgeState.getFlags()) && flagEncoder.isBackward(edgeState.getFlags());
+            return edgeState.get(accessEnc) && edgeState.getReverse(accessEnc);
         }
     }
 
     private static class BlockedEdgesFilter implements EdgeFilter {
         private final IntHashSet blockedEdges;
-        private final FlagEncoder encoder;
+        private final BooleanEncodedValue accessEnc;
         private final boolean fwd;
         private final boolean bwd;
 
-        public BlockedEdgesFilter(FlagEncoder encoder, boolean bwd, boolean fwd, IntHashSet blockedEdges) {
-            this.encoder = encoder;
-            this.bwd = bwd;
+        public BlockedEdgesFilter(BooleanEncodedValue accessEnc, boolean fwd, boolean bwd, IntHashSet blockedEdges) {
+            this.accessEnc = accessEnc;
             this.fwd = fwd;
+            this.bwd = bwd;
             this.blockedEdges = blockedEdges;
         }
 
         @Override
         public final boolean accept(EdgeIteratorState iter) {
             boolean blocked = blockedEdges.contains(iter.getEdge());
-            return fwd && iter.isForward(encoder) && !blocked || bwd && iter.isBackward(encoder) && !blocked;
+            return fwd && iter.get(accessEnc) && !blocked || bwd && iter.getReverse(accessEnc) && !blocked;
         }
 
         public boolean acceptsBackward() {
@@ -885,7 +933,7 @@ public boolean acceptsForward() {
 
         @Override
         public String toString() {
-            return encoder.toString() + ", bwd:" + bwd + ", fwd:" + fwd;
+            return accessEnc + ", bwd:" + bwd + ", fwd:" + fwd;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java b/core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java
index afec484f93..785bd91fbe 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/PrepareLandmarks.java
@@ -130,7 +130,7 @@ public void doSpecificWork() {
         lms.createLandmarks();
         lms.flush();
 
-        LOGGER.info("Calculating landmarks for " + (lms.getSubnetworksWithLandmarks() - 1) + " subnetworks took:" + sw.stop().getSeconds() + " => "
+        LOGGER.info("Calculated landmarks for " + (lms.getSubnetworksWithLandmarks() - 1) + " subnetworks, took:" + sw.stop().getSeconds() + " => "
                 + lms.getLandmarksAsGeoJSON() + ", stored weights:" + lms.getLandmarkCount()
                 + ", nodes:" + graph.getNodes() + ", " + Helper.getMemInfo());
     }
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/BooleanEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/BooleanEncodedValue.java
new file mode 100644
index 0000000000..7afd07c418
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/BooleanEncodedValue.java
@@ -0,0 +1,12 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+
+/**
+ * This interface defines access to an edge property of type boolean. The default value is false.
+ */
+public interface BooleanEncodedValue extends EncodedValue {
+    void setBool(boolean reverse, IntsRef ref, boolean value);
+
+    boolean getBool(boolean reverse, IntsRef ref);
+}
diff --git a/core/src/main/java/com/graphhopper/reader/dem/TunnelElevationInterpolator.java b/core/src/main/java/com/graphhopper/routing/profiles/Country.java
similarity index 52%
rename from core/src/main/java/com/graphhopper/reader/dem/TunnelElevationInterpolator.java
rename to core/src/main/java/com/graphhopper/routing/profiles/Country.java
index 466f47face..d89b54954f 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/TunnelElevationInterpolator.java
+++ b/core/src/main/java/com/graphhopper/routing/profiles/Country.java
@@ -15,27 +15,23 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.reader.dem;
-
-import com.graphhopper.routing.util.DataFlagEncoder;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.util.EdgeIteratorState;
+package com.graphhopper.routing.profiles;
 
 /**
- * Elevation interpolator for tunnels. Estimates elevations of inner nodes of
- * the tunnel based on elevations of entry/exit nodes of the tunnel.
- *
- * @author Alexey Valikov
+ * This enum defines a country value that can be stored per edge.
  */
-public class TunnelElevationInterpolator extends AbstractEdgeElevationInterpolator {
+public enum Country {
+    DEFAULT("default"), DEU("deu"), AUT("aut");
+    public static final String KEY = "country";
+
+    private final String name;
 
-    public TunnelElevationInterpolator(GraphHopperStorage storage,
-                                       DataFlagEncoder dataFlagEncoder) {
-        super(storage, dataFlagEncoder);
+    Country(String name) {
+        this.name = name;
     }
 
     @Override
-    protected boolean isInterpolatableEdge(EdgeIteratorState edge) {
-        return dataFlagEncoder.isTransportModeTunnel(edge);
+    public String toString() {
+        return name;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/DecimalEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/DecimalEncodedValue.java
new file mode 100644
index 0000000000..97f938c538
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/DecimalEncodedValue.java
@@ -0,0 +1,33 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+
+/**
+ * This class defines how and where to store an unsigned decimal value. It is important to note that:
+ * 1. the range of the number is highly limited (unlike the Java 32bit float or 64bit double values)
+ * so that the storable part of it fits into the specified number of bits (maximum 32 at the moment
+ * for all implementations) and 2. the default value is always 0.
+ *
+ * @see UnsignedDecimalEncodedValue
+ */
+public interface DecimalEncodedValue extends EncodedValue {
+
+    /**
+     * This method stores the specified double value (rounding with a previously defined factor) into the IntsRef.
+     *
+     * @see #getMaxDecimal()
+     */
+    void setDecimal(boolean reverse, IntsRef ref, double value);
+
+    double getDecimal(boolean reverse, IntsRef ref);
+
+    /**
+     * The double value this EncodedValue accepts for setDecimal without throwing an exception.
+     */
+    double getMaxDecimal();
+
+    /**
+     * @return true if this EncodedValue can store a different value for its reverse direction
+     */
+    boolean isStoreTwoDirections();
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactory.java b/core/src/main/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactory.java
new file mode 100644
index 0000000000..a2a4dda666
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactory.java
@@ -0,0 +1,61 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.util.Helper;
+
+public class DefaultEncodedValueFactory implements EncodedValueFactory {
+    @Override
+    public EncodedValue create(String string) {
+        if (Helper.isEmpty(string))
+            throw new IllegalArgumentException("No string provided to load EncodedValue");
+
+        final EncodedValue enc;
+        String name = string.split("\\|")[0];
+        if (name.isEmpty())
+            throw new IllegalArgumentException("To load EncodedValue a name is required. " + string);
+
+        // creating the Country EV is done while SpatialRuleIndex is created and not here
+        if (Roundabout.KEY.equals(name)) {
+            enc = Roundabout.create();
+        } else if (RoadClass.KEY.equals(name)) {
+            enc = new EnumEncodedValue<>(RoadClass.KEY, RoadClass.class);
+        } else if (RoadClassLink.KEY.equals(name)) {
+            enc = new SimpleBooleanEncodedValue(RoadClassLink.KEY);
+        } else if (RoadEnvironment.KEY.equals(name)) {
+            enc = new EnumEncodedValue<>(RoadEnvironment.KEY, RoadEnvironment.class);
+        } else if (RoadAccess.KEY.equals(name)) {
+            enc = new EnumEncodedValue<>(RoadAccess.KEY, RoadAccess.class);
+        } else if (MaxSpeed.KEY.equals(name)) {
+            enc = MaxSpeed.create();
+        } else if (MaxWeight.KEY.equals(name)) {
+            enc = MaxWeight.create();
+        } else if (MaxHeight.KEY.equals(name)) {
+            enc = MaxHeight.create();
+        } else if (MaxWidth.KEY.equals(name)) {
+            enc = MaxWidth.create();
+        } else if (Surface.KEY.equals(name)) {
+            enc = new EnumEncodedValue<>(Surface.KEY, Surface.class);
+        } else if (Toll.KEY.equals(name)) {
+            enc = new EnumEncodedValue<>(Toll.KEY, Toll.class);
+        } else {
+            throw new IllegalArgumentException("DefaultEncodedValueFactory cannot find EncodedValue " + name);
+        }
+        return enc;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/EncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/EncodedValue.java
new file mode 100644
index 0000000000..defe23201d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/EncodedValue.java
@@ -0,0 +1,76 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+/**
+ * This interface defines how to store and read values from a list of integers
+ *
+ * @see com.graphhopper.storage.IntsRef
+ */
+public interface EncodedValue {
+
+    /**
+     * This method sets the dataIndex and shift of this EncodedValue object and potentially changes the submitted init
+     * object afterwards via calling next
+     *
+     * @return used bits
+     * @see InitializerConfig#next(int)
+     */
+    int init(InitializerConfig init);
+
+    /**
+     * This method returns the hierarchical name like vehicle.type of this EncodedValue
+     */
+    String getName();
+
+    /**
+     * The return value represents the state of this EncodedValue and it can be assumed that two JVMs return the
+     * same version when the EncodedValue has the same state unlike the hashCode method. Same version ensures
+     * compatibility when reading values.
+     */
+    int getVersion();
+
+    class InitializerConfig {
+        int dataIndex = -1;
+        int shift = 32;
+        int nextShift = 32;
+        int bitMask = 0;
+
+        /**
+         * This method determines a space of the specified bits and sets shift and dataIndex accordingly
+         *
+         * @param usedBits
+         */
+        void next(int usedBits) {
+            shift = nextShift;
+            if ((shift - 1 + usedBits) / 32 > (shift - 1) / 32) {
+                dataIndex++;
+                shift = 0;
+            }
+
+            // we need 1L as otherwise it'll fail for usedBits==32
+            bitMask = (int) ((1L << usedBits) - 1);
+            bitMask <<= shift;
+            nextShift = shift + usedBits;
+        }
+
+        public int getRequiredBits() {
+            return (dataIndex) * 32 + nextShift;
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/EncodedValueFactory.java b/core/src/main/java/com/graphhopper/routing/profiles/EncodedValueFactory.java
new file mode 100644
index 0000000000..2e28d8e379
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/EncodedValueFactory.java
@@ -0,0 +1,26 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+public interface EncodedValueFactory {
+    /**
+     * This method assumes a string value with the key of an EncodedValue like "road_class" and returns an instance
+     * of it.
+     */
+    EncodedValue create(String encodedValueString);
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/EncodedValueLookup.java b/core/src/main/java/com/graphhopper/routing/profiles/EncodedValueLookup.java
new file mode 100644
index 0000000000..041f4b0c88
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/EncodedValueLookup.java
@@ -0,0 +1,33 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+public interface EncodedValueLookup {
+
+    <T extends EncodedValue> T getEncodedValue(String key, Class<T> encodedValueType);
+
+    BooleanEncodedValue getBooleanEncodedValue(String key);
+
+    IntEncodedValue getIntEncodedValue(String key);
+
+    DecimalEncodedValue getDecimalEncodedValue(String key);
+
+    <T extends Enum> EnumEncodedValue<T> getEnumEncodedValue(String key, Class<T> enumType);
+
+    boolean hasEncodedValue(String key);
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/EnumEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/EnumEncodedValue.java
new file mode 100644
index 0000000000..6f689ae3ff
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/EnumEncodedValue.java
@@ -0,0 +1,61 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.Helper;
+
+import java.util.Arrays;
+
+/**
+ * This class allows to store distinct values via an enum. I.e. it stores just the indices
+ */
+public final class EnumEncodedValue<E extends Enum> extends UnsignedIntEncodedValue {
+    private final E[] arr;
+
+    public EnumEncodedValue(String name, Class<E> enumType) {
+        this(name, enumType, false);
+    }
+
+    public EnumEncodedValue(String name, Class<E> enumType, boolean storeTwoDirections) {
+        super(name, 32 - Integer.numberOfLeadingZeros(enumType.getEnumConstants().length), storeTwoDirections);
+        arr = enumType.getEnumConstants();
+    }
+
+    public final void setEnum(boolean reverse, IntsRef ref, E value) {
+        int intValue = value.ordinal();
+        super.setInt(reverse, ref, intValue);
+    }
+
+    public final E getEnum(boolean reverse, IntsRef ref) {
+        int value = super.getInt(reverse, ref);
+        return arr[value];
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (!super.equals(o)) return false;
+        EnumEncodedValue that = (EnumEncodedValue) o;
+        return Arrays.equals(arr, that.arr);
+    }
+
+    @Override
+    public int getVersion() {
+        return 31 * super.getVersion() + staticHashCode(arr);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/IntEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/IntEncodedValue.java
new file mode 100644
index 0000000000..8c6d01672b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/IntEncodedValue.java
@@ -0,0 +1,33 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+
+/**
+ * This class defines how and where to store an unsigned integer. It is important to note that: 1. the range of the
+ * integer is highly limited (unlike the Java 32bit integer values) so that the storable part of it fits into the
+ * specified number of bits (maximum 32) and 2. the default value is always 0.
+ *
+ * @see UnsignedIntEncodedValue
+ */
+public interface IntEncodedValue extends EncodedValue {
+
+    /**
+     * This method restores the integer value from the specified 'flags' taken from the storage.
+     */
+    int getInt(boolean reverse, IntsRef ref);
+
+    /**
+     * This method stores the specified integer value in the specified IntsRef.
+     */
+    void setInt(boolean reverse, IntsRef ref, int value);
+
+    /**
+     * The int value this EncodedValue accepts for setInt without throwing an exception.
+     */
+    int getMaxInt();
+
+    /**
+     * @return true if this EncodedValue can store a different value for its reverse direction
+     */
+    boolean isStoreTwoDirections();
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxHeight.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxHeight.java
new file mode 100644
index 0000000000..bdaa46eb03
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxHeight.java
@@ -0,0 +1,36 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+/**
+ * One of the three logistic attributes that can be stored per edge.
+ *
+ * @see MaxWidth
+ * @see MaxWeight
+ */
+public class MaxHeight {
+    public static final String KEY = "max_height";
+
+    /**
+     * Currently enables to store 0.1 to max=0.1*2⁷m and infinity. If a value is between the maximum and infinity
+     * it is assumed to use the maximum value.
+     */
+    public static DecimalEncodedValue create() {
+        return new UnsignedDecimalEncodedValue(KEY, 7, 0.1, Double.POSITIVE_INFINITY, false);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxSpeed.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxSpeed.java
new file mode 100644
index 0000000000..ab07b10325
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxSpeed.java
@@ -0,0 +1,40 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+/**
+ * This EncodedValue stores maximum speed values for car. If not initialized it returns UNSET_SPEED.
+ */
+public class MaxSpeed {
+    public static final String KEY = "max_speed";
+
+    /**
+     * The speed value used for "none" speed limit on German Autobahn is 150=30*5 as this is the biggest value
+     * not explicitly used in OSM and can be precisely returned for a factor of 5, 3, 2 and 1. It is fixed and
+     * not DecimalEncodedValue.getMaxInt to allow special case handling.
+     */
+    public static final double UNLIMITED_SIGN_SPEED = 150;
+    /**
+     * The speed value used for road sections without known speed limit.
+     */
+    public static final double UNSET_SPEED = Double.POSITIVE_INFINITY;
+
+    public static DecimalEncodedValue create() {
+        return new UnsignedDecimalEncodedValue(KEY, 5, 5, UNSET_SPEED, true);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxWeight.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxWeight.java
new file mode 100644
index 0000000000..caad9a337e
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxWeight.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+/**
+ * One of the three logistic attributes that can be stored per edge.
+ *
+ * @see MaxHeight
+ * @see MaxWidth
+ */
+public class MaxWeight {
+    public static final String KEY = "max_weight";
+
+    /**
+     * Currently enables to store 0.1 to max=0.1*2⁸ tons and infinity. If a value is between the maximum and infinity
+     * it is assumed to use the maximum value. To save bits it might make more sense to store only a few values like
+     * it was done with the MappedDecimalEncodedValue still handling (or rounding) of unknown values is unclear.
+     */
+    public static DecimalEncodedValue create() {
+        return new UnsignedDecimalEncodedValue(KEY, 8, 0.1, Double.POSITIVE_INFINITY, false);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/MaxWidth.java b/core/src/main/java/com/graphhopper/routing/profiles/MaxWidth.java
new file mode 100644
index 0000000000..02d0c6a71e
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/MaxWidth.java
@@ -0,0 +1,36 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+/**
+ * One of the three logistic attributes that can be stored per edge.
+ *
+ * @see MaxHeight
+ * @see MaxWeight
+ */
+public class MaxWidth {
+    public static final String KEY = "max_width";
+
+    /**
+     * Currently enables to store 0.1 to max=0.1*2⁷m and infinity. If a value is between the maximum and infinity
+     * it is assumed to use the maximum value.
+     */
+    public static DecimalEncodedValue create() {
+        return new UnsignedDecimalEncodedValue(KEY, 7, 0.1, Double.POSITIVE_INFINITY, false);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/RoadAccess.java b/core/src/main/java/com/graphhopper/routing/profiles/RoadAccess.java
new file mode 100644
index 0000000000..3a6808cb31
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/RoadAccess.java
@@ -0,0 +1,55 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.util.Helper;
+
+/**
+ * This enum defines the road access of an edge. Most edges are accessible from everyone but certain have restrictions
+ * like accessible only for customers or when delivering.
+ */
+public enum RoadAccess {
+    // order is important here as we assume "smaller index" means "broader access"
+    YES("yes"), DESTINATION("destination"), CUSTOMERS("customers"), DELIVERY("delivery"),
+    FORESTRY("forestry"), AGRICULTURAL("agricultural"),
+    PRIVATE("private"), OTHER("other"), NO("no");
+
+    public static final String KEY = "road_access";
+
+    private final String name;
+
+    RoadAccess(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+
+    public static RoadAccess find(String name) {
+        if (name == null)
+            return YES;
+        try {
+            // public and permissive will be converted into "yes"
+            return RoadAccess.valueOf(Helper.toUpperCase(name));
+        } catch (IllegalArgumentException ex) {
+            return YES;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/RoadClass.java b/core/src/main/java/com/graphhopper/routing/profiles/RoadClass.java
new file mode 100644
index 0000000000..80daf7b6a3
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/RoadClass.java
@@ -0,0 +1,56 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.util.Helper;
+
+/**
+ * This enum defines the road class of an edge. It is heavily influenced from the highway tag in OSM that can be
+ * primary, cycleway etc.
+ */
+public enum RoadClass {
+    OTHER("other"), MOTORWAY("motorway"),
+    TRUNK("trunk"), PRIMARY("primary"), SECONDARY("secondary"),
+    TERTIARY("tertiary"), RESIDENTIAL("residential"), UNCLASSIFIED("unclassified"),
+    SERVICE("service"), ROAD("road"), TRACK("track"),
+    BRIDLEWAY("bridleway"), STEPS("steps"), CYCLEWAY("cycleway"),
+    PATH("path"), LIVING_STREET("living_street");
+
+    public static final String KEY = "road_class";
+
+    private final String name;
+
+    RoadClass(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+
+    public static RoadClass find(String name) {
+        if (name == null)
+            return OTHER;
+        try {
+            return RoadClass.valueOf(Helper.toUpperCase(name));
+        } catch (IllegalArgumentException ex) {
+            return OTHER;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/RoadClassLink.java b/core/src/main/java/com/graphhopper/routing/profiles/RoadClassLink.java
new file mode 100644
index 0000000000..82cc46f904
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/RoadClassLink.java
@@ -0,0 +1,22 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+public class RoadClassLink {
+    public static final String KEY = "road_class_link";
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/RoadEnvironment.java b/core/src/main/java/com/graphhopper/routing/profiles/RoadEnvironment.java
new file mode 100644
index 0000000000..9c1826cdfd
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/RoadEnvironment.java
@@ -0,0 +1,52 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.util.Helper;
+
+/**
+ * This enum the road environment of an edge. Currently road, ferry, tunnel, ford, bridge and shuttle_train. All edges
+ * that do not fit get "other" as value.
+ */
+public enum RoadEnvironment {
+    OTHER("other"), ROAD("road"), FERRY("ferry"),
+    TUNNEL("tunnel"), BRIDGE("bridge"), FORD("ford"), SHUTTLE_TRAIN("shuttle_train");
+
+    public static final String KEY = "road_environment";
+
+    private final String name;
+
+    RoadEnvironment(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+
+    public static RoadEnvironment find(String name) {
+        if (name == null)
+            return OTHER;
+        try {
+            return RoadEnvironment.valueOf(Helper.toUpperCase(name));
+        } catch (IllegalArgumentException ex) {
+            return OTHER;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/Roundabout.java b/core/src/main/java/com/graphhopper/routing/profiles/Roundabout.java
new file mode 100644
index 0000000000..c4ca8c2ec1
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/Roundabout.java
@@ -0,0 +1,26 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+public class Roundabout {
+    public static final String KEY = "roundabout";
+
+    public static BooleanEncodedValue create() {
+        return new SimpleBooleanEncodedValue(KEY, false);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/SimpleBooleanEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/SimpleBooleanEncodedValue.java
new file mode 100644
index 0000000000..5200e08b6a
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/SimpleBooleanEncodedValue.java
@@ -0,0 +1,65 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+
+/**
+ * This class implements a simple boolean storage via an UnsignedIntEncodedValue with 1 bit.
+ */
+public final class SimpleBooleanEncodedValue extends UnsignedIntEncodedValue implements BooleanEncodedValue {
+
+    public SimpleBooleanEncodedValue(String name) {
+        this(name, false);
+    }
+
+    public SimpleBooleanEncodedValue(String name, boolean storeBothDirections) {
+        super(name, 1, storeBothDirections);
+    }
+
+    @Override
+    public final void setBool(boolean reverse, IntsRef ref, boolean value) {
+        if (storeTwoDirections && reverse) {
+            int flags = ref.ints[bwdDataIndex + ref.offset];
+            flags &= ~bwdMask;
+            // set value
+            if (value)
+                flags = flags | (1 << bwdShift);
+            ref.ints[bwdDataIndex + ref.offset] = flags;
+
+        } else {
+            int flags = ref.ints[fwdDataIndex + ref.offset];
+            flags &= ~fwdMask;
+            if (value)
+                flags = flags | (1 << fwdShift);
+            ref.ints[fwdDataIndex + ref.offset] = flags;
+        }
+    }
+
+    @Override
+    public final boolean getBool(boolean reverse, IntsRef ref) {
+        int flags;
+        if (storeTwoDirections && reverse) {
+            flags = ref.ints[bwdDataIndex + ref.offset];
+            return (flags & bwdMask) >>> bwdShift == 1;
+        }
+
+        flags = ref.ints[fwdDataIndex + ref.offset];
+        return (flags & fwdMask) >>> fwdShift == 1;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/Surface.java b/core/src/main/java/com/graphhopper/routing/profiles/Surface.java
new file mode 100644
index 0000000000..9c19fd587d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/Surface.java
@@ -0,0 +1,54 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.util.Helper;
+
+/**
+ * This enum defines the road surface of an edge like unpaved or asphalt. If not tagged it will be "other".
+ */
+public enum Surface {
+    OTHER("other"), COBBLESTONE("cobblestone"),
+    ASPHALT("asphalt"), PAVED("paved"), UNPAVED("unpaved"),
+    GROUND("ground"), GRAVEL("gravel"), CONCRETE("concrete"),
+    PAVING_STONE("paving_stone"), DIRT("dirt"),
+    PARKING("parking"), GRASS("grass"), SAND("sand");
+
+    public static final String KEY = "surface";
+
+    private final String name;
+
+    Surface(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+
+    public static Surface find(String name) {
+        if (name == null)
+            return OTHER;
+        try {
+            return Surface.valueOf(Helper.toUpperCase(name));
+        } catch (IllegalArgumentException ex) {
+            return OTHER;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/Toll.java b/core/src/main/java/com/graphhopper/routing/profiles/Toll.java
new file mode 100644
index 0000000000..29f8684725
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/Toll.java
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+/**
+ * This enum defines the toll value like NO (default), ALL (all vehicles) and HGV (toll for heavy goods vehicles)
+ */
+public enum Toll {
+    NO("no"), ALL("all"), HGV("hgv");
+
+    public static final String KEY = "toll";
+
+    private final String name;
+
+    Toll(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValue.java
new file mode 100644
index 0000000000..8fcc56a80d
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValue.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+
+/**
+ * This class holds a decimal value and stores it as an unsigned integer value via a conversion factor and a maximum number
+ * of bits.
+ */
+public final class UnsignedDecimalEncodedValue extends UnsignedIntEncodedValue implements DecimalEncodedValue {
+    private final double factor;
+    private final double defaultValue;
+
+    public UnsignedDecimalEncodedValue(String name, int bits, double factor, boolean storeTwoDirections) {
+        this(name, bits, factor, 0, storeTwoDirections);
+    }
+
+    /**
+     * @param name               the key to identify this EncodedValue
+     * @param bits               the bits that should be reserved for the storage
+     * @param factor             the precision factor, i.e. store = (int) Math.round(value / factor)
+     * @param defaultValue       the value that should be returned if the stored value is 0.
+     * @param storeTwoDirections true if forward and backward direction of the edge should get two independent values.
+     */
+    public UnsignedDecimalEncodedValue(String name, int bits, double factor, double defaultValue, boolean storeTwoDirections) {
+        super(name, bits, storeTwoDirections);
+        this.factor = factor;
+        this.defaultValue = defaultValue;
+    }
+
+    private int toInt(double val) {
+        return (int) Math.round(val / factor);
+    }
+
+    @Override
+    public final void setDecimal(boolean reverse, IntsRef ints, double value) {
+        if (!isInitialized())
+            throw new IllegalStateException("Call init before usage for EncodedValue " + toString());
+        if (value == defaultValue)
+            value = 0;
+        if (value > maxValue * factor)
+            throw new IllegalArgumentException(getName() + " value " + value + " too large for encoding. maxValue:" + maxValue * factor);
+        if (value < 0)
+            throw new IllegalArgumentException("Negative value for " + getName() + " not allowed! " + value);
+        if (Double.isNaN(value))
+            throw new IllegalArgumentException("NaN value for " + getName() + " not allowed!");
+
+        super.setInt(reverse, ints, toInt(value));
+    }
+
+    @Override
+    public final double getDecimal(boolean reverse, IntsRef ref) {
+        int value = getInt(reverse, ref);
+        if (value == 0)
+            return defaultValue;
+        return value * factor;
+    }
+
+    @Override
+    public double getMaxDecimal() {
+        return maxValue * factor;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (!super.equals(o)) return false;
+        UnsignedDecimalEncodedValue that = (UnsignedDecimalEncodedValue) o;
+        return Double.compare(that.factor, factor) == 0;
+    }
+
+    @Override
+    public int getVersion() {
+        return 31 * (31 * super.getVersion() + staticHashCode(factor)) + staticHashCode(defaultValue);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/profiles/UnsignedIntEncodedValue.java b/core/src/main/java/com/graphhopper/routing/profiles/UnsignedIntEncodedValue.java
new file mode 100644
index 0000000000..e9a95ac8c6
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/profiles/UnsignedIntEncodedValue.java
@@ -0,0 +1,245 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+
+import java.util.Arrays;
+import java.util.Locale;
+import java.util.Objects;
+
+/**
+ * Implementation of the IntEncodedValue via a limited number of bits and without a sign. It introduces handling
+ * of "backward"- and "forward"-edge information.
+ */
+public class UnsignedIntEncodedValue implements IntEncodedValue {
+
+    private final String name;
+
+    /**
+     * There are multiple int values possible per edge. Here we specify the index into this integer array.
+     */
+    protected int fwdDataIndex;
+    protected int bwdDataIndex;
+    final int bits;
+    int maxValue;
+    int fwdShift = -1;
+    int bwdShift = -1;
+    int fwdMask;
+    int bwdMask;
+    boolean storeTwoDirections;
+
+    /**
+     * This constructor reserves the specified number of bits in the underlying data structure or twice the amount if
+     * storeTwoDirections is true.
+     *
+     * @param storeTwoDirections if true this EncodedValue can store different values for the forward and backward
+     *                           direction.
+     */
+    public UnsignedIntEncodedValue(String name, int bits, boolean storeTwoDirections) {
+        if (!name.toLowerCase(Locale.ROOT).equals(name))
+            throw new IllegalArgumentException("EncodedValue name must be lower case but was " + name);
+        if (bits <= 0)
+            throw new IllegalArgumentException(name + ": bits cannot be zero or negative");
+        if (bits > 31)
+            throw new IllegalArgumentException(name + ": at the moment the number of reserved bits cannot be more than 31");
+        this.bits = bits;
+        this.name = name;
+        this.storeTwoDirections = storeTwoDirections;
+    }
+
+    @Override
+    public final int init(EncodedValue.InitializerConfig init) {
+        if (isInitialized())
+            throw new IllegalStateException("Cannot call init multiple times");
+
+        init.next(bits);
+        this.fwdMask = init.bitMask;
+        this.fwdDataIndex = init.dataIndex;
+        this.fwdShift = init.shift;
+        if (storeTwoDirections) {
+            init.next(bits);
+            this.bwdMask = init.bitMask;
+            this.bwdDataIndex = init.dataIndex;
+            this.bwdShift = init.shift;
+        }
+
+        this.maxValue = (1 << bits) - 1;
+        return storeTwoDirections ? 2 * bits : bits;
+    }
+
+    boolean isInitialized() {
+        return fwdMask != 0;
+    }
+
+    private void checkValue(int value) {
+        if (!isInitialized())
+            throw new IllegalStateException("EncodedValue " + getName() + " not initialized");
+        if (value > maxValue)
+            throw new IllegalArgumentException(name + " value too large for encoding: " + value + ", maxValue:" + maxValue);
+        if (value < 0)
+            throw new IllegalArgumentException("negative value for " + name + " not allowed! " + value);
+    }
+
+    @Override
+    public final void setInt(boolean reverse, IntsRef ref, int value) {
+        checkValue(value);
+        uncheckedSet(reverse, ref, value);
+    }
+
+    final void uncheckedSet(boolean reverse, IntsRef ref, int value) {
+        if (reverse && !storeTwoDirections)
+            throw new IllegalArgumentException(getName() + ": value for reverse direction would overwrite forward direction. Enable storeTwoDirections for this EncodedValue or don't use setReverse");
+
+        if (reverse) {
+            int flags = ref.ints[bwdDataIndex + ref.offset];
+            // clear value bits
+            flags &= ~bwdMask;
+            value <<= bwdShift;
+            // set value
+            ref.ints[bwdDataIndex + ref.offset] = flags | value;
+        } else {
+            int flags = ref.ints[fwdDataIndex + ref.offset];
+            flags &= ~fwdMask;
+            value <<= fwdShift;
+            ref.ints[fwdDataIndex + ref.offset] = flags | value;
+        }
+    }
+
+    @Override
+    public final int getInt(boolean reverse, IntsRef ref) {
+        int flags;
+        // if we do not store both directions ignore reverse == true for convenient reading
+        if (reverse && storeTwoDirections) {
+            flags = ref.ints[bwdDataIndex + ref.offset];
+            return (flags & bwdMask) >>> bwdShift;
+        } else {
+            flags = ref.ints[fwdDataIndex + ref.offset];
+            return (flags & fwdMask) >>> fwdShift;
+        }
+    }
+
+    @Override
+    public int getMaxInt() {
+        return maxValue;
+    }
+
+    @Override
+    public final boolean isStoreTwoDirections() {
+        return storeTwoDirections;
+    }
+
+    @Override
+    public final String getName() {
+        return name;
+    }
+
+    @Override
+    public final String toString() {
+        return getName() + "|version=" + getVersion() + "|bits=" + bits + "|index=" + fwdDataIndex + "|shift=" + fwdShift + "|store_both_directions=" + storeTwoDirections;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        UnsignedIntEncodedValue that = (UnsignedIntEncodedValue) o;
+        return fwdDataIndex == that.fwdDataIndex &&
+                bwdDataIndex == that.bwdDataIndex &&
+                bits == that.bits &&
+                maxValue == that.maxValue &&
+                fwdShift == that.fwdShift &&
+                bwdShift == that.bwdShift &&
+                fwdMask == that.fwdMask &&
+                bwdMask == that.bwdMask &&
+                storeTwoDirections == that.storeTwoDirections &&
+                Objects.equals(name, that.name);
+    }
+
+    @Override
+    public final int hashCode() {
+        return getVersion();
+    }
+
+    @Override
+    public int getVersion() {
+        int val = staticHashCode(name);
+        val = 31 * val + (storeTwoDirections ? 1231 : 1237);
+        return staticHashCode(val, fwdDataIndex, bwdDataIndex, bits, maxValue, fwdShift, bwdShift, fwdMask, bwdMask);
+    }
+
+    /**
+     * Produces a static hashcode for an integer arrays that is platform independent and still compatible to the default
+     * of openjdk.
+     *
+     * @see Arrays#hashCode(int[])
+     */
+    static int staticHashCode(int... vals) {
+        if (vals == null)
+            return 0;
+        int len = vals.length;
+        int val = 1;
+        for (int idx = 0; idx < len; ++idx) {
+            val = 31 * val + vals[idx];
+        }
+
+        return val;
+    }
+
+    /**
+     * Produces a static hashcode for an Enum arrays that is platform independent and still compatible to the default
+     * of openjdk.
+     */
+    static int staticHashCode(Enum... vals) {
+        if (vals == null)
+            return 0;
+        int len = vals.length;
+        int val = 1;
+        for (int idx = 0; idx < len; ++idx) {
+            val = 31 * val + vals[idx].ordinal();
+        }
+
+        return val;
+    }
+
+    /**
+     * Produces a static hashcode for an integer arrays that is platform independent and still compatible to the default
+     * of openjdk
+     *
+     * @see Double#hashCode
+     */
+    static int staticHashCode(double val) {
+        long var2 = Double.doubleToLongBits(val);
+        return (int) (var2 ^ var2 >>> 32);
+    }
+
+    /**
+     * Produces a static hashcode for a string that is platform independent and still compatible to the default
+     * of openjdk. Do not use for performance critical applications.
+     *
+     * @see String#hashCode()
+     */
+    static int staticHashCode(String str) {
+        int len = str.length();
+        int val = 0;
+        for (int idx = 0; idx < len; ++idx) {
+            val = 31 * val + str.charAt(idx);
+        }
+        return val;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java b/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
index 61abc73a61..69b8f0eb75 100644
--- a/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
+++ b/core/src/main/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworks.java
@@ -21,6 +21,7 @@
 import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -46,6 +47,7 @@
     private final GraphHopperStorage ghStorage;
     private final AtomicInteger maxEdgesPerNode = new AtomicInteger(0);
     private final List<FlagEncoder> encoders;
+    private final List<BooleanEncodedValue> accessEncList;
     private int minNetworkSize = 200;
     private int minOneWayNetworkSize = 0;
     private int subnetworks = -1;
@@ -53,6 +55,10 @@
     public PrepareRoutingSubnetworks(GraphHopperStorage ghStorage, List<FlagEncoder> encoders) {
         this.ghStorage = ghStorage;
         this.encoders = encoders;
+        this.accessEncList = new ArrayList<>();
+        for (FlagEncoder flagEncoder : encoders) {
+            accessEncList.add(flagEncoder.getAccessEnc());
+        }
     }
 
     public PrepareRoutingSubnetworks setMinNetworkSize(int minNetworkSize) {
@@ -73,7 +79,7 @@ public void doWork() {
         int unvisitedDeadEnds = 0;
         for (FlagEncoder encoder : encoders) {
             // mark edges for one vehicle as inaccessible
-            PrepEdgeFilter filter = new PrepEdgeFilter(encoder);
+            DefaultEdgeFilter filter = DefaultEdgeFilter.allEdges(encoder);
             if (minOneWayNetworkSize > 0)
                 unvisitedDeadEnds += removeDeadEndUnvisitedNetworks(filter);
 
@@ -98,8 +104,8 @@ public int getMaxSubnetworks() {
     /**
      * This method finds the double linked components according to the specified filter.
      */
-    List<IntArrayList> findSubnetworks(PrepEdgeFilter filter) {
-        final FlagEncoder encoder = filter.getEncoder();
+    List<IntArrayList> findSubnetworks(DefaultEdgeFilter filter) {
+        final BooleanEncodedValue accessEnc = filter.getAccessEnc();
         final EdgeExplorer explorer = ghStorage.createEdgeExplorer(filter);
         int locs = ghStorage.getNodes();
         List<IntArrayList> list = new ArrayList<>(100);
@@ -130,7 +136,7 @@ protected final boolean goFurther(int nodeId) {
 
                 @Override
                 protected final boolean checkAdjacent(EdgeIteratorState edge) {
-                    if (encoder.isForward(edge.getFlags()) || encoder.isBackward(edge.getFlags())) {
+                    if (edge.get(accessEnc) || edge.getReverse(accessEnc)) {
                         tmpCounter++;
                         return true;
                     }
@@ -146,14 +152,14 @@ protected final boolean checkAdjacent(EdgeIteratorState edge) {
     /**
      * Deletes all but the largest subnetworks.
      */
-    int keepLargeNetworks(PrepEdgeFilter filter, List<IntArrayList> components) {
+    int keepLargeNetworks(DefaultEdgeFilter filter, List<IntArrayList> components) {
         if (components.size() <= 1)
             return 0;
 
         int maxCount = -1;
         IntIndexedContainer oldComponent = null;
         int allRemoved = 0;
-        FlagEncoder encoder = filter.getEncoder();
+        BooleanEncodedValue accessEnc = filter.getAccessEnc();
         EdgeExplorer explorer = ghStorage.createEdgeExplorer(filter);
         for (IntArrayList component : components) {
             if (maxCount < 0) {
@@ -165,12 +171,12 @@ int keepLargeNetworks(PrepEdgeFilter filter, List<IntArrayList> components) {
             int removedEdges;
             if (maxCount < component.size()) {
                 // new biggest area found. remove old
-                removedEdges = removeEdges(explorer, encoder, oldComponent, minNetworkSize);
+                removedEdges = removeEdges(explorer, accessEnc, oldComponent, minNetworkSize);
 
                 maxCount = component.size();
                 oldComponent = component;
             } else {
-                removedEdges = removeEdges(explorer, encoder, component, minNetworkSize);
+                removedEdges = removeEdges(explorer, accessEnc, component, minNetworkSize);
             }
 
             allRemoved += removedEdges;
@@ -181,31 +187,17 @@ int keepLargeNetworks(PrepEdgeFilter filter, List<IntArrayList> components) {
         return allRemoved;
     }
 
-    String toString(FlagEncoder encoder, EdgeIterator iter) {
-        String str = "";
-        while (iter.next()) {
-            int adjNode = iter.getAdjNode();
-            str += adjNode + " (" + ghStorage.getNodeAccess().getLat(adjNode) + "," + ghStorage.getNodeAccess().getLon(adjNode) + "), ";
-            str += "speed  (fwd:" + encoder.getSpeed(iter.getFlags()) + ", rev:" + encoder.getReverseSpeed(iter.getFlags()) + "), ";
-            str += "access (fwd:" + encoder.isForward(iter.getFlags()) + ", rev:" + encoder.isBackward(iter.getFlags()) + "), ";
-            str += "distance:" + iter.getDistance();
-            str += ";\n ";
-        }
-        return str;
-    }
-
     /**
      * This method removes networks that will be never be visited by this filter. See #235 for
      * example, small areas like parking lots are sometimes connected to the whole network through a
-     * one-way road. This is clearly an error - but is causes the routing to fail when a point gets
+     * one-way road. This is clearly an error - but it causes the routing to fail when a point gets
      * connected to this small area. This routine removes all these networks from the graph.
-     * <p>
      *
      * @return number of removed edges
      */
-    int removeDeadEndUnvisitedNetworks(final PrepEdgeFilter bothFilter) {
-        StopWatch sw = new StopWatch(bothFilter.getEncoder() + " findComponents").start();
-        final EdgeFilter outFilter = DefaultEdgeFilter.outEdges(bothFilter.getEncoder());
+    int removeDeadEndUnvisitedNetworks(final DefaultEdgeFilter bothFilter) {
+        StopWatch sw = new StopWatch(bothFilter.getAccessEnc() + " findComponents").start();
+        final EdgeFilter outFilter = DefaultEdgeFilter.outEdges(bothFilter.getAccessEnc());
 
         // partition graph into strongly connected components using Tarjan's algorithm        
         TarjansSCCAlgorithm tarjan = new TarjansSCCAlgorithm(ghStorage, outFilter, true);
@@ -218,28 +210,26 @@ int removeDeadEndUnvisitedNetworks(final PrepEdgeFilter bothFilter) {
     /**
      * This method removes the access to edges available from the nodes contained in the components.
      * But only if a components' size is smaller then the specified min value.
-     * <p>
      *
      * @return number of removed edges
      */
-    int removeEdges(final PrepEdgeFilter bothFilter, List<IntArrayList> components, int min) {
+    int removeEdges(final DefaultEdgeFilter bothFilter, List<IntArrayList> components, int min) {
         // remove edges determined from nodes but only if less than minimum size
-        FlagEncoder encoder = bothFilter.getEncoder();
         EdgeExplorer explorer = ghStorage.createEdgeExplorer(bothFilter);
         int removedEdges = 0;
         for (IntArrayList component : components) {
-            removedEdges += removeEdges(explorer, encoder, component, min);
+            removedEdges += removeEdges(explorer, bothFilter.getAccessEnc(), component, min);
         }
         return removedEdges;
     }
 
-    int removeEdges(EdgeExplorer explorer, FlagEncoder encoder, IntIndexedContainer component, int min) {
+    int removeEdges(EdgeExplorer explorer, BooleanEncodedValue accessEnc, IntIndexedContainer component, int min) {
         int removedEdges = 0;
         if (component.size() < min) {
             for (int i = 0; i < component.size(); i++) {
                 EdgeIterator edge = explorer.setBaseNode(component.get(i));
                 while (edge.next()) {
-                    edge.setFlags(encoder.setAccess(edge.getFlags(), false, false));
+                    edge.set(accessEnc, false).setReverse(accessEnc, false);
                     removedEdges++;
                 }
             }
@@ -261,7 +251,6 @@ void markNodesRemovedIfUnreachable() {
 
     /**
      * This method checks if the node is removed or inaccessible for ALL encoders.
-     * <p>
      *
      * @return true if no edges are reachable from the specified nodeIndex for any flag encoder.
      */
@@ -273,27 +262,12 @@ boolean detectNodeRemovedForAllEncoders(EdgeExplorer edgeExplorerAllEdges, int n
         EdgeIterator iter = edgeExplorerAllEdges.setBaseNode(nodeIndex);
         while (iter.next()) {
             // if at least on encoder allows one direction return false
-            for (FlagEncoder encoder : encoders) {
-                if (encoder.isBackward(iter.getFlags())
-                        || encoder.isForward(iter.getFlags()))
+            for (BooleanEncodedValue accessEnc : accessEncList) {
+                if (iter.get(accessEnc) || iter.getReverse(accessEnc))
                     return false;
             }
         }
 
         return true;
     }
-
-    static class PrepEdgeFilter extends DefaultEdgeFilter {
-
-        FlagEncoder encoder;
-
-        public PrepEdgeFilter(FlagEncoder encoder) {
-            super(encoder, true, true);
-            this.encoder = encoder;
-        }
-
-        public FlagEncoder getEncoder() {
-            return encoder;
-        }
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
index 9db9666e0b..ddd3f66bf3 100644
--- a/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/AlternativeRoutingTemplate.java
@@ -24,6 +24,7 @@
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -45,8 +46,8 @@
  * @author Peter Karich
  */
 final public class AlternativeRoutingTemplate extends ViaRoutingTemplate {
-    public AlternativeRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex) {
-        super(ghRequest, ghRsp, locationIndex);
+    public AlternativeRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, EncodingManager encodingManager) {
+        super(ghRequest, ghRsp, locationIndex, encodingManager);
     }
 
     @Override
@@ -75,12 +76,12 @@ public boolean isReady(PathMerger pathMerger, Translation tr) {
         PointList wpList = getWaypoints();
         altResponse.setWaypoints(wpList);
         ghResponse.add(altResponse);
-        pathMerger.doWork(altResponse, Collections.singletonList(pathList.get(0)), tr);
+        pathMerger.doWork(altResponse, Collections.singletonList(pathList.get(0)), encodingManager, tr);
         for (int index = 1; index < pathList.size(); index++) {
             PathWrapper tmpAltRsp = new PathWrapper();
             tmpAltRsp.setWaypoints(wpList);
             ghResponse.add(tmpAltRsp);
-            pathMerger.doWork(tmpAltRsp, Collections.singletonList(pathList.get(index)), tr);
+            pathMerger.doWork(tmpAltRsp, Collections.singletonList(pathList.get(index)), encodingManager, tr);
         }
         return true;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
index d3ca91b2ed..82ad1044a2 100644
--- a/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/RoundTripRoutingTemplate.java
@@ -23,6 +23,7 @@
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.tour.MultiPointTour;
 import com.graphhopper.routing.util.tour.TourStrategy;
@@ -54,14 +55,16 @@
     private final GHRequest ghRequest;
     private final GHResponse ghResponse;
     private final LocationIndex locationIndex;
+    private final EncodingManager encodingManager;
     private PathWrapper altResponse;
     // result from route
     private List<Path> pathList;
 
-    public RoundTripRoutingTemplate(GHRequest request, GHResponse ghRsp, LocationIndex locationIndex, int maxRetries) {
+    public RoundTripRoutingTemplate(GHRequest request, GHResponse ghRsp, LocationIndex locationIndex, EncodingManager encodingManager, int maxRetries) {
         this.ghRequest = request;
         this.ghResponse = ghRsp;
         this.locationIndex = locationIndex;
+        this.encodingManager = encodingManager;
         this.maxRetries = maxRetries;
     }
 
@@ -151,7 +154,7 @@ public boolean isReady(PathMerger pathMerger, Translation tr) {
         altResponse = new PathWrapper();
         altResponse.setWaypoints(getWaypoints());
         ghResponse.add(altResponse);
-        pathMerger.doWork(altResponse, pathList, tr);
+        pathMerger.doWork(altResponse, pathList, encodingManager, tr);
         // with potentially retrying, including generating new route points, for now disabled
         return true;
     }
diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index 9df3034e10..bf6c7cdaab 100644
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -21,6 +21,8 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.PathWrapper;
 import com.graphhopper.routing.*;
+import com.graphhopper.routing.profiles.RoadClass;
+import com.graphhopper.routing.profiles.RoadEnvironment;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
@@ -45,13 +47,15 @@
     protected final GHResponse ghResponse;
     protected final PathWrapper altResponse = new PathWrapper();
     private final LocationIndex locationIndex;
+    protected final EncodingManager encodingManager;
     // result from route
     protected List<Path> pathList;
 
-    public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex) {
+    public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, EncodingManager encodingManager) {
         this.locationIndex = locationIndex;
         this.ghRequest = ghRequest;
         this.ghResponse = ghRsp;
+        this.encodingManager = encodingManager;
     }
 
     @Override
@@ -60,12 +64,17 @@ public ViaRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex l
             throw new IllegalArgumentException("At least 2 points have to be specified, but was:" + points.size());
 
         EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
+        EdgeFilter strictEdgeFilter = !ghRequest.hasSnapPreventions() ? edgeFilter : new SnapPreventionEdgeFilter(edgeFilter,
+                encoder.getEnumEncodedValue(RoadClass.KEY, RoadClass.class),
+                encoder.getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class), ghRequest.getSnapPreventions());
         queryResults = new ArrayList<>(points.size());
         for (int placeIndex = 0; placeIndex < points.size(); placeIndex++) {
             GHPoint point = points.get(placeIndex);
             QueryResult qr = null;
             if (ghRequest.hasPointHints())
-                qr = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(edgeFilter, ghRequest.getPointHints().get(placeIndex)));
+                qr = locationIndex.findClosest(point.lat, point.lon, new NameSimilarityEdgeFilter(strictEdgeFilter, ghRequest.getPointHints().get(placeIndex)));
+            else if (ghRequest.hasSnapPreventions())
+                qr = locationIndex.findClosest(point.lat, point.lon, strictEdgeFilter);
             if (qr == null || !qr.isValid())
                 qr = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
             if (!qr.isValid())
@@ -151,7 +160,7 @@ public boolean isReady(PathMerger pathMerger, Translation tr) {
 
         altResponse.setWaypoints(getWaypoints());
         ghResponse.add(altResponse);
-        pathMerger.doWork(altResponse, pathList, tr);
+        pathMerger.doWork(altResponse, pathList, encodingManager, tr);
         return true;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 9d2d91462c..27ac7ebac3 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -23,7 +23,9 @@
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.reader.osm.conditional.ConditionalOSMTagInspector;
 import com.graphhopper.reader.osm.conditional.DateRangeParser;
+import com.graphhopper.routing.profiles.*;
 import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -37,14 +39,12 @@
  * Abstract class which handles flag decoding and encoding. Every encoder should be registered to a
  * EncodingManager to be usable. If you want the full long to be stored you need to enable this in
  * the GraphHopperStorage.
- * <p>
  *
  * @author Peter Karich
  * @author Nop
  * @see EncodingManager
  */
-public abstract class AbstractFlagEncoder implements FlagEncoder, TurnCostEncoder {
-    protected final static int K_FORWARD = 0, K_BACKWARD = 1;
+public abstract class AbstractFlagEncoder implements FlagEncoder {
     private final static Logger logger = LoggerFactory.getLogger(AbstractFlagEncoder.class);
     /* restriction definitions where order is important */
     protected final List<String> restrictions = new ArrayList<>(5);
@@ -57,28 +57,25 @@
     protected final Set<String> potentialBarriers = new HashSet<>(5);
     protected final int speedBits;
     protected final double speedFactor;
+    protected double speedDefault;
     private final int maxTurnCosts;
-    protected long forwardBit;
-    protected long backwardBit;
-    protected long directionBitMask;
-    protected long roundaboutBit;
-    protected EncodedDoubleValue speedEncoder;
-    // bit to signal that way is accepted
-    protected long acceptBit;
-    protected long ferryBit;
+    private long encoderBit;
+    protected BooleanEncodedValue accessEnc;
+    protected BooleanEncodedValue roundaboutEnc;
+    protected DecimalEncodedValue speedEncoder;
     protected PMap properties;
     // This value determines the maximal possible speed of any road regardless the maxspeed value
     // lower values allow more compact representation of the routing graph
     protected int maxPossibleSpeed;
     /* Edge Flag Encoder fields */
     private long nodeBitMask;
-    private long wayBitMask;
     private long relBitMask;
-    private EncodedValue turnCostEncoder;
+    private EncodedValueOld turnCostEncoder;
     private long turnRestrictionBit;
     private boolean blockByDefault = true;
     private boolean blockFords = true;
     private boolean registered;
+    protected EncodedValueLookup encodedValueLookup;
 
     // Speeds from CarFlagEncoder
     protected static final double UNKNOWN_DURATION_FERRY_SPEED = 5;
@@ -165,31 +162,18 @@ public int defineNodeBits(int index, int shift) {
 
     /**
      * Defines bits used for edge flags used for access, speed etc.
-     * <p>
      *
-     * @param shift bit offset for the first bit used by this encoder
      * @return incremented shift value pointing behind the last used bit
      */
-    public int defineWayBits(int index, int shift) {
+    public void createEncodedValues(List<EncodedValue> registerNewEncodedValue, String prefix, int index) {
         // define the first 2 speedBits in flags for routing
-        forwardBit = 1L << shift;
-        backwardBit = 2L << shift;
-        directionBitMask = 3L << shift;
-        shift += 2;
-        roundaboutBit = 1L << shift;
-        shift++;
-
-        // define internal flags for parsing
-        index *= 2;
-        acceptBit = 1L << index;
-        ferryBit = 2L << index;
-
-        return shift;
+        registerNewEncodedValue.add(accessEnc = new SimpleBooleanEncodedValue(EncodingManager.getKey(prefix, "access"), true));
+        roundaboutEnc = getBooleanEncodedValue(Roundabout.KEY);
+        encoderBit = 1L << index;
     }
 
     /**
      * Defines the bits which are used for relation flags.
-     * <p>
      *
      * @return incremented shift value pointing behind the last used bit
      */
@@ -200,34 +184,34 @@ public int defineRelationBits(int index, int shift) {
     /**
      * Analyze the properties of a relation and create the routing flags for the second read step.
      * In the pre-parsing step this method will be called to determine the useful relation tags.
-     * <p>
      */
-    public abstract long handleRelationTags(ReaderRelation relation, long oldRelationFlags);
+    public abstract long handleRelationTags(long oldRelation, ReaderRelation relation);
 
     /**
      * Decide whether a way is routable for a given mode of travel. This skips some ways before
      * handleWayTags is called.
-     * <p>
      *
      * @return the encoded value to indicate if this encoder allows travel or not.
      */
-    public abstract long acceptWay(ReaderWay way);
+    public abstract EncodingManager.Access getAccess(ReaderWay way);
 
     /**
-     * Analyze properties of a way and create the routing flags. This method is called in the second
+     * Analyze properties of a way and create the edge flags. This method is called in the second
      * parsing step.
      */
-    public abstract long handleWayTags(ReaderWay way, long allowed, long relationFlags);
+    public abstract IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags);
 
     /**
      * Parse tags on nodes. Node tags can add to speed (like traffic_signals) where the value is
-     * strict negative or blocks access (like a barrier), then the value is strict positive.This
+     * strict negative or blocks access (like a barrier), then the value is strictly positive. This
      * method is called in the second parsing step.
+     *
+     * @return encoded values or 0 if not blocking or no value stored
      */
     public long handleNodeTags(ReaderNode node) {
         // absolute barriers always block
         if (node.hasTag("barrier", absoluteBarriers))
-            return directionBitMask;
+            return encoderBit;
 
         // movable barriers block if they are not marked as passable
         if (node.hasTag("barrier", potentialBarriers)) {
@@ -240,11 +224,11 @@ public long handleNodeTags(ReaderNode node) {
                     return 0;
 
                 if (node.hasTag(res, restrictedValues))
-                    return directionBitMask;
+                    return encoderBit;
             }
 
             if (blockByDefault)
-                return directionBitMask;
+                return encoderBit;
         }
 
         // In case explicit flag ford=no, don't block
@@ -252,90 +236,32 @@ public long handleNodeTags(ReaderNode node) {
                 && (node.hasTag("highway", "ford") || node.hasTag("ford"))
                 && !node.hasTag(restrictions, intendedValues)
                 && !node.hasTag("ford", "no")) {
-            return directionBitMask;
-
+            return encoderBit;
         }
 
         return 0;
     }
 
     @Override
-    public InstructionAnnotation getAnnotation(long flags, Translation tr) {
+    public InstructionAnnotation getAnnotation(IntsRef edgeFlags, Translation tr) {
         return InstructionAnnotation.EMPTY;
     }
 
-    /**
-     * Swapping directions means swapping bits which are dependent on the direction of an edge like
-     * the access bits. But also direction dependent speed values should be swapped too. Keep in
-     * mind that this method is performance critical!
-     */
-    public long reverseFlags(long flags) {
-        long dir = flags & directionBitMask;
-        if (dir == directionBitMask || dir == 0)
-            return flags;
-
-        return flags ^ directionBitMask;
-    }
-
     /**
      * Sets default flags with specified access.
      */
-    public long flagsDefault(boolean forward, boolean backward) {
-        long flags = speedEncoder.setDefaultValue(0);
-        return setAccess(flags, forward, backward);
-    }
-
-    @Override
-    public long setAccess(long flags, boolean forward, boolean backward) {
-        return setBool(setBool(flags, K_BACKWARD, backward), K_FORWARD, forward);
-    }
-
-    @Override
-    public long setSpeed(long flags, double speed) {
-        if (speed < 0 || Double.isNaN(speed))
-            throw new IllegalArgumentException("Speed cannot be negative or NaN: " + speed
-                    + ", flags:" + BitUtil.LITTLE.toBitString(flags));
-
-        if (speed < speedEncoder.factor / 2)
-            return setLowSpeed(flags, speed, false);
-
-        if (speed > getMaxSpeed())
-            speed = getMaxSpeed();
-
-        return speedEncoder.setDoubleValue(flags, speed);
-    }
-
-    protected long setLowSpeed(long flags, double speed, boolean reverse) {
-        return setAccess(speedEncoder.setDoubleValue(flags, 0), false, false);
-    }
-
-    @Override
-    public double getSpeed(long flags) {
-        double speedVal = speedEncoder.getDoubleValue(flags);
-        if (speedVal < 0)
-            throw new IllegalStateException("Speed was negative!? " + speedVal);
-
-        return speedVal;
-    }
-
-    @Override
-    public long setReverseSpeed(long flags, double speed) {
-        return setSpeed(flags, speed);
-    }
-
-    @Override
-    public double getReverseSpeed(long flags) {
-        return getSpeed(flags);
-    }
-
-    @Override
-    public long setProperties(double speed, boolean forward, boolean backward) {
-        return setAccess(setSpeed(0, speed), forward, backward);
+    protected void flagsDefault(IntsRef edgeFlags, boolean forward, boolean backward) {
+        if (forward)
+            speedEncoder.setDecimal(false, edgeFlags, speedDefault);
+        if (backward && speedEncoder.isStoreTwoDirections())
+            speedEncoder.setDecimal(true, edgeFlags, speedDefault);
+        accessEnc.setBool(false, edgeFlags, forward);
+        accessEnc.setBool(true, edgeFlags, backward);
     }
 
     @Override
     public double getMaxSpeed() {
-        return speedEncoder.getMaxValue();
+        return maxPossibleSpeed;
     }
 
     /**
@@ -357,7 +283,7 @@ protected double getMaxSpeed(ReaderWay way) {
     @Override
     public int hashCode() {
         int hash = 7;
-        hash = 61 * hash + (int) this.directionBitMask;
+        hash = 61 * hash + this.accessEnc.hashCode();
         hash = 61 * hash + this.toString().hashCode();
         return hash;
     }
@@ -367,26 +293,22 @@ public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
-        // only rely on the string
-        //        if (getClass() != obj.getClass())
-        //            return false;
-        final AbstractFlagEncoder other = (AbstractFlagEncoder) obj;
-        if (this.directionBitMask != other.directionBitMask)
+        if (getClass() != obj.getClass())
             return false;
-
-        return this.toString().equals(other.toString());
+        AbstractFlagEncoder afe = (AbstractFlagEncoder) obj;
+        return toString().equals(afe.toString()) && encoderBit == afe.encoderBit && accessEnc.equals(afe.accessEnc);
     }
 
     /**
      * @return the speed in km/h
      */
-    protected double parseSpeed(String str) {
+    public static double parseSpeed(String str) {
         if (Helper.isEmpty(str))
             return -1;
 
         // on some German autobahns and a very few other places
         if ("none".equals(str))
-            return 140;
+            return MaxSpeed.UNLIMITED_SIGN_SPEED;
 
         if (str.endsWith(":rural") || str.endsWith(":trunk"))
             return 80;
@@ -466,8 +388,8 @@ protected double getFerrySpeed(ReaderWay way) {
                             return getMaxSpeed();
                         }
                         // If the speed is lower than the speed we can store, we have to set it to the minSpeed, but > 0
-                        if (Math.round(calculatedTripSpeed) < speedEncoder.factor / 2) {
-                            return speedEncoder.factor / 2;
+                        if (Math.round(calculatedTripSpeed) < speedFactor / 2) {
+                            return speedFactor / 2;
                         }
 
                         return Math.round(calculatedTripSpeed);
@@ -484,8 +406,8 @@ protected double getFerrySpeed(ReaderWay way) {
             }
 
         if (durationInHours == 0) {
-            if(estimatedLength != null && estimatedLength.doubleValue() <= 300)
-                return speedEncoder.factor / 2;
+            if (estimatedLength != null && estimatedLength.doubleValue() <= 300)
+                return speedFactor / 2;
             // unknown speed -> put penalty on ferry transport
             return UNKNOWN_DURATION_FERRY_SPEED;
         } else if (durationInHours > 1) {
@@ -496,15 +418,6 @@ protected double getFerrySpeed(ReaderWay way) {
         }
     }
 
-    void setWayBitMask(int usedBits, int shift) {
-        wayBitMask = (1L << usedBits) - 1;
-        wayBitMask <<= shift;
-    }
-
-    long getWayBitMask() {
-        return wayBitMask;
-    }
-
     void setRelBitMask(int usedBits, int shift) {
         relBitMask = (1L << usedBits) - 1;
         relBitMask <<= shift;
@@ -541,7 +454,7 @@ else if (maxTurnCosts == 1) {
         }
 
         int turnBits = Helper.countBitValue(maxTurnCosts);
-        turnCostEncoder = new EncodedValue("TurnCost", shift, turnBits, 1, 0, maxTurnCosts) {
+        turnCostEncoder = new EncodedValueOld("TurnCost", shift, turnBits, 1, 0, maxTurnCosts) {
             // override to avoid expensive Math.round
             @Override
             public final long getValue(long flags) {
@@ -606,70 +519,50 @@ else if (maxTurnCosts == 1) {
         return turnCostEncoder.setValue(0L, (int) costs);
     }
 
-    protected boolean isFerry(long internalFlags) {
-        return (internalFlags & ferryBit) != 0;
+    public final DecimalEncodedValue getAverageSpeedEnc() {
+        if (speedEncoder == null)
+            throw new NullPointerException("FlagEncoder " + toString() + " not yet initialized");
+        return speedEncoder;
     }
 
-    protected boolean isAccept(long internalFlags) {
-        return (internalFlags & acceptBit) != 0;
-    }
-
-    @Override
-    public boolean isBackward(long flags) {
-        return (flags & backwardBit) != 0;
+    public final BooleanEncodedValue getAccessEnc() {
+        if (accessEnc == null)
+            throw new NullPointerException("FlagEncoder " + toString() + " not yet initialized");
+        return accessEnc;
     }
 
-    @Override
-    public boolean isForward(long flags) {
-        return (flags & forwardBit) != 0;
-    }
+    /**
+     * Most use cases do not require this method. Will still keep it accessible so that one can disable it
+     * until the averageSpeedEncodedValue is moved out of the FlagEncoder.
+     *
+     * @Deprecated
+     */
+    protected void setSpeed(boolean reverse, IntsRef edgeFlags, double speed) {
+        if (speed < 0 || Double.isNaN(speed))
+            throw new IllegalArgumentException("Speed cannot be negative or NaN: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(edgeFlags));
 
-    @Override
-    public long setBool(long flags, int key, boolean value) {
-        switch (key) {
-            case K_FORWARD:
-                return value ? flags | forwardBit : flags & ~forwardBit;
-            case K_BACKWARD:
-                return value ? flags | backwardBit : flags & ~backwardBit;
-            case K_ROUNDABOUT:
-                return value ? flags | roundaboutBit : flags & ~roundaboutBit;
-            default:
-                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
+        if (speed < speedFactor / 2) {
+            speedEncoder.setDecimal(reverse, edgeFlags, 0);
+            accessEnc.setBool(reverse, edgeFlags, false);
+            return;
         }
-    }
 
-    @Override
-    public boolean isBool(long flags, int key) {
-        switch (key) {
-            case K_FORWARD:
-                return isForward(flags);
-            case K_BACKWARD:
-                return isBackward(flags);
-            case K_ROUNDABOUT:
-                return (flags & roundaboutBit) != 0;
-            default:
-                throw new IllegalArgumentException("Unknown key " + key + " for boolean value");
-        }
-    }
+        if (speed > getMaxSpeed())
+            speed = getMaxSpeed();
 
-    @Override
-    public long setLong(long flags, int key, long value) {
-        throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
+        speedEncoder.setDecimal(reverse, edgeFlags, speed);
     }
 
-    @Override
-    public long getLong(long flags, int key) {
-        throw new UnsupportedOperationException("Unknown key " + key + " for long value.");
+    double getSpeed(IntsRef edgeFlags) {
+        return getSpeed(false, edgeFlags);
     }
 
-    @Override
-    public long setDouble(long flags, int key, double value) {
-        throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
-    }
+    double getSpeed(boolean reverse, IntsRef edgeFlags) {
+        double speedVal = speedEncoder.getDecimal(reverse, edgeFlags);
+        if (speedVal < 0)
+            throw new IllegalStateException("Speed was negative!? " + speedVal);
 
-    @Override
-    public double getDouble(long flags, int key) {
-        throw new UnsupportedOperationException("Unknown key " + key + " for double value.");
+        return speedVal;
     }
 
     /**
@@ -691,6 +584,35 @@ protected String getPropertiesString() {
         return "speed_factor=" + speedFactor + "|speed_bits=" + speedBits + "|turn_costs=" + (maxTurnCosts > 0);
     }
 
+    @Override
+    public <T extends EncodedValue> T getEncodedValue(String key, Class<T> encodedValueType) {
+        return encodedValueLookup.getEncodedValue(key, encodedValueType);
+    }
+
+    @Override
+    public BooleanEncodedValue getBooleanEncodedValue(String key) {
+        return encodedValueLookup.getBooleanEncodedValue(key);
+    }
+
+    @Override
+    public IntEncodedValue getIntEncodedValue(String key) {
+        return encodedValueLookup.getIntEncodedValue(key);
+    }
+
+    @Override
+    public DecimalEncodedValue getDecimalEncodedValue(String key) {
+        return encodedValueLookup.getDecimalEncodedValue(key);
+    }
+
+    @Override
+    public <T extends Enum> EnumEncodedValue<T> getEnumEncodedValue(String key, Class<T> enumType) {
+        return encodedValueLookup.getEnumEncodedValue(key, enumType);
+    }
+
+    public void setEncodedValueLookup(EncodedValueLookup encodedValueLookup) {
+        this.encodedValueLookup = encodedValueLookup;
+    }
+
     @Override
     public boolean supports(Class<?> feature) {
         if (TurnWeighting.class.isAssignableFrom(feature))
@@ -699,4 +621,8 @@ public boolean supports(Class<?> feature) {
         return false;
     }
 
+    @Override
+    public boolean hasEncodedValue(String key) {
+        return encodedValueLookup.hasEncodedValue(key);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
index 88ded4bee2..6d6971f22d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Bike2WeightFlagEncoder.java
@@ -18,7 +18,7 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.util.BitUtil;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.PointList;
@@ -27,110 +27,37 @@
 
 /**
  * Stores two speed values into an edge to support avoiding too much incline
- * <p>
  *
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoder extends BikeFlagEncoder {
-    private EncodedDoubleValue reverseSpeedEncoder;
 
     public Bike2WeightFlagEncoder() {
-        super();
+        this(new PMap());
     }
 
     public Bike2WeightFlagEncoder(String propertiesStr) {
-        super(new PMap(propertiesStr));
+        this(new PMap(propertiesStr));
     }
 
     public Bike2WeightFlagEncoder(PMap properties) {
         super(properties);
+        speedTwoDirections = true;
     }
 
     public Bike2WeightFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
+        speedTwoDirections = true;
     }
 
     @Override
     public int getVersion() {
-        return 2;
+        return 3;
     }
 
-    @Override
-    public int defineWayBits(int index, int shift) {
-        shift = super.defineWayBits(index, shift);
-        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
-                getHighwaySpeed("cycleway"), maxPossibleSpeed);
-        shift += reverseSpeedEncoder.getBits();
-        return shift;
-    }
-
-    @Override
-    public double getReverseSpeed(long flags) {
-        return reverseSpeedEncoder.getDoubleValue(flags);
-    }
-
-    @Override
-    public long setReverseSpeed(long flags, double speed) {
-        if (speed < 0)
-            throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
-
-        if (speed < speedEncoder.factor / 2)
-            return setLowSpeed(flags, speed, true);
-
-        if (speed > getMaxSpeed())
-            speed = getMaxSpeed();
-
-        return reverseSpeedEncoder.setDoubleValue(flags, speed);
-    }
-
-    @Override
-    public long handleSpeed(ReaderWay way, double speed, long flags) {
-        // handle oneways
-        flags = super.handleSpeed(way, speed, flags);
-        if (isBackward(flags))
-            flags = setReverseSpeed(flags, speed);
-
-        if (isForward(flags))
-            flags = setSpeed(flags, speed);
-
-        return flags;
-    }
-
-    @Override
-    protected long setLowSpeed(long flags, double speed, boolean reverse) {
-        if (reverse)
-            return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
-
-        return setBool(speedEncoder.setDoubleValue(flags, 0), K_FORWARD, false);
-    }
-
-    @Override
-    public long flagsDefault(boolean forward, boolean backward) {
-        long flags = super.flagsDefault(forward, backward);
-        if (backward)
-            return reverseSpeedEncoder.setDefaultValue(flags);
-
-        return flags;
-    }
-
-    @Override
-    public long setProperties(double speed, boolean forward, boolean backward) {
-        long flags = super.setProperties(speed, forward, backward);
-        if (backward)
-            return setReverseSpeed(flags, speed);
-
-        return flags;
-    }
-
-    @Override
-    public long reverseFlags(long flags) {
-        // swap access
-        flags = super.reverseFlags(flags);
-
-        // swap speeds 
-        double otherValue = reverseSpeedEncoder.getDoubleValue(flags);
-        flags = setReverseSpeed(flags, speedEncoder.getDoubleValue(flags));
-        return setSpeed(flags, otherValue);
+    protected void handleSpeed(IntsRef edgeFlags, ReaderWay way, double speed) {
+        speedEncoder.setDecimal(true, edgeFlags, speed);
+        super.handleSpeed(edgeFlags, way, speed);
     }
 
     @Override
@@ -139,7 +66,7 @@ public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
         if (!pl.is3D())
             throw new IllegalStateException("To support speed calculation based on elevation data it is necessary to enable import of it.");
 
-        long flags = edge.getFlags();
+        IntsRef intsRef = edge.getFlags();
 
         if (way.hasTag("tunnel", "yes") || way.hasTag("bridge", "yes") || way.hasTag("highway", "steps")) {
             // do not change speed
@@ -170,28 +97,6 @@ public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
                 decDist2DSum = fullDist2D;
             }
 
-//            // get a more detailed elevation information, but due to bad SRTM data this does not make sense now.
-//            for (int i = 1; i < pl.size(); i++)
-//            {
-//                double lat = pl.getLatitude(i);
-//                double lon = pl.getLongitude(i);
-//                double ele = pl.getElevation(i);
-//                double eleDelta = ele - prevEle;
-//                double dist2D = distCalc.calcDist(prevLat, prevLon, lat, lon);
-//                if (eleDelta > 0.1)
-//                {
-//                    incEleSum += eleDelta;
-//                    incDist2DSum += dist2D;
-//                } else if (eleDelta < -0.1)
-//                {
-//                    decEleSum += -eleDelta;
-//                    decDist2DSum += dist2D;
-//                }
-//                fullDist2D += dist2D;
-//                prevLat = lat;
-//                prevLon = lon;
-//                prevEle = ele;
-//            }
             // Calculate slop via tan(asin(height/distance)) but for rather smallish angles where we can assume tan a=a and sin a=a.
             // Then calculate a factor which decreases or increases the speed.
             // Do this via a simple quadratic equation where y(0)=1 and y(0.3)=1/4 for incline and y(0.3)=2 for decline        
@@ -199,28 +104,28 @@ public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
             double fwdDecline = decDist2DSum > 1 ? decEleSum / decDist2DSum : 0;
             double restDist2D = fullDist2D - incDist2DSum - decDist2DSum;
             double maxSpeed = getHighwaySpeed("cycleway");
-            if (isForward(flags)) {
+            if (accessEnc.getBool(false, intsRef)) {
                 // use weighted mean so that longer incline influences speed more than shorter
-                double speed = getSpeed(flags);
+                double speed = getSpeed(false, intsRef);
                 double fwdFaster = 1 + 2 * keepIn(fwdDecline, 0, 0.2);
                 fwdFaster = fwdFaster * fwdFaster;
                 double fwdSlower = 1 - 5 * keepIn(fwdIncline, 0, 0.2);
                 fwdSlower = fwdSlower * fwdSlower;
                 speed = speed * (fwdSlower * incDist2DSum + fwdFaster * decDist2DSum + 1 * restDist2D) / fullDist2D;
-                flags = this.setSpeed(flags, keepIn(speed, PUSHING_SECTION_SPEED / 2, maxSpeed));
+                setSpeed(false, intsRef, keepIn(speed, PUSHING_SECTION_SPEED / 2, maxSpeed));
             }
 
-            if (isBackward(flags)) {
-                double speedReverse = getReverseSpeed(flags);
+            if (accessEnc.getBool(true, intsRef)) {
+                double speedReverse = getSpeed(true, intsRef);
                 double bwFaster = 1 + 2 * keepIn(fwdIncline, 0, 0.2);
                 bwFaster = bwFaster * bwFaster;
                 double bwSlower = 1 - 5 * keepIn(fwdDecline, 0, 0.2);
                 bwSlower = bwSlower * bwSlower;
                 speedReverse = speedReverse * (bwFaster * incDist2DSum + bwSlower * decDist2DSum + 1 * restDist2D) / fullDist2D;
-                flags = this.setReverseSpeed(flags, keepIn(speedReverse, PUSHING_SECTION_SPEED / 2, maxSpeed));
+                setSpeed(true, intsRef, keepIn(speedReverse, PUSHING_SECTION_SPEED / 2, maxSpeed));
             }
         }
-        edge.setFlags(flags);
+        edge.setFlags(intsRef);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
index 9e57a52aed..cd4760a063 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeCommonFlagEncoder.java
@@ -19,13 +19,16 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.*;
 import com.graphhopper.routing.weighting.PriorityWeighting;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
 
 import java.util.*;
 
+import static com.graphhopper.routing.util.EncodingManager.getKey;
 import static com.graphhopper.routing.util.PriorityCode.*;
 
 /**
@@ -54,10 +57,11 @@
     private final Map<String, Integer> highwaySpeeds = new HashMap<>();
     // convert network tag of bicycle routes into a way route code
     private final Map<String, Integer> bikeNetworkToCode = new HashMap<>();
-    protected EncodedValue relationCodeEncoder;
-    EncodedValue priorityWayEncoder;
-    private long unpavedBit = 0;
-    private EncodedValue wayTypeEncoder;
+    protected EncodedValueOld relationCodeEncoder;
+    protected boolean speedTwoDirections;
+    DecimalEncodedValue priorityWayEncoder;
+    private BooleanEncodedValue unpavedEncoder;
+    private IntEncodedValue wayTypeEncoder;
     // Car speed limit which switches the preference from UNCHANGED to AVOID_IF_POSSIBLE
     private int avoidSpeedLimit;
 
@@ -87,7 +91,9 @@ protected BikeCommonFlagEncoder(int speedBits, double speedFactor, int maxTurnCo
         potentialBarriers.add("gate");
         // potentialBarriers.add("lift_gate");
         potentialBarriers.add("swing_gate");
+        potentialBarriers.add("cattle_grid");
 
+        absoluteBarriers.add("fence");
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
 
@@ -162,6 +168,7 @@ protected BikeCommonFlagEncoder(int speedBits, double speedFactor, int maxTurnCo
         setHighwaySpeed("cycleway", CYCLEWAY_SPEED);
         setHighwaySpeed("path", 10);
         setHighwaySpeed("footway", 6);
+        setHighwaySpeed("platform", 6);
         setHighwaySpeed("pedestrian", 6);
         setHighwaySpeed("track", 12);
         setHighwaySpeed("service", 14);
@@ -194,105 +201,97 @@ protected BikeCommonFlagEncoder(int speedBits, double speedFactor, int maxTurnCo
 
         setCyclingNetworkPreference("deprecated", AVOID_AT_ALL_COSTS.getValue());
 
+        speedDefault = highwaySpeeds.get("cycleway");
         setAvoidSpeedLimit(71);
     }
 
     @Override
     public int getVersion() {
-        return 2;
+        return 3;
     }
 
     @Override
-    public int defineWayBits(int index, int shift) {
+    public void createEncodedValues(List<EncodedValue> registerNewEncodedValue, String prefix, int index) {
         // first two bits are reserved for route handling in superclass
-        shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, highwaySpeeds.get("cycleway"),
-                maxPossibleSpeed);
-        shift += speedEncoder.getBits();
-
-        unpavedBit = 1L << shift++;
-        // 2 bits
-        wayTypeEncoder = new EncodedValue("WayType", shift, 2, 1, 0, 3, true);
-        shift += wayTypeEncoder.getBits();
-
-        priorityWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
-        shift += priorityWayEncoder.getBits();
-
-        return shift;
+        super.createEncodedValues(registerNewEncodedValue, prefix, index);
+        registerNewEncodedValue.add(speedEncoder = new UnsignedDecimalEncodedValue(getKey(prefix, "average_speed"), speedBits, speedFactor, speedTwoDirections));
+        registerNewEncodedValue.add(unpavedEncoder = new SimpleBooleanEncodedValue(getKey(prefix, "paved"), false));
+        registerNewEncodedValue.add(wayTypeEncoder = new UnsignedIntEncodedValue(getKey(prefix, "waytype"), 2, false));
+        registerNewEncodedValue.add(priorityWayEncoder = new UnsignedDecimalEncodedValue(getKey(prefix, "priority"), 3, PriorityCode.getFactor(1), false));
     }
 
     @Override
     public int defineRelationBits(int index, int shift) {
-        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
+        relationCodeEncoder = new EncodedValueOld("RelationCode", shift, 3, 1, 0, 7);
         return shift + relationCodeEncoder.getBits();
     }
 
     @Override
-    public long acceptWay(ReaderWay way) {
+    public EncodingManager.Access getAccess(ReaderWay way) {
         String highwayValue = way.getTag("highway");
         if (highwayValue == null) {
-            long acceptPotentially = 0;
+            EncodingManager.Access accept = EncodingManager.Access.CAN_SKIP;
 
             if (way.hasTag("route", ferries)) {
                 // if bike is NOT explicitly tagged allow bike but only if foot is not specified
                 String bikeTag = way.getTag("bicycle");
-                if (bikeTag == null && !way.hasTag("foot") || "yes".equals(bikeTag))
-                    acceptPotentially = acceptBit | ferryBit;
+                if (bikeTag == null && !way.hasTag("foot") || intendedValues.contains(bikeTag))
+                    accept = EncodingManager.Access.FERRY;
             }
 
             // special case not for all acceptedRailways, only platform
             if (way.hasTag("railway", "platform"))
-                acceptPotentially = acceptBit;
+                accept = EncodingManager.Access.WAY;
 
             if (way.hasTag("man_made", "pier"))
-                acceptPotentially = acceptBit;
+                accept = EncodingManager.Access.WAY;
 
-            if (acceptPotentially != 0) {
+            if (!accept.canSkip()) {
                 if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-                    return 0;
-                return acceptPotentially;
+                    return EncodingManager.Access.CAN_SKIP;
+                return accept;
             }
 
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         }
 
         if (!highwaySpeeds.containsKey(highwayValue))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         String sacScale = way.getTag("sac_scale");
         if (sacScale != null) {
             if ((way.hasTag("highway", "cycleway"))
                     && (way.hasTag("sac_scale", "hiking")))
-                return acceptBit;
+                return EncodingManager.Access.WAY;
             if (!isSacScaleAllowed(sacScale))
-                return 0;
+                return EncodingManager.Access.CAN_SKIP;
         }
 
         // use the way if it is tagged for bikes
         if (way.hasTag("bicycle", intendedValues) ||
                 way.hasTag("bicycle", "dismount") ||
                 way.hasTag("highway", "cycleway"))
-            return acceptBit;
+            return EncodingManager.Access.WAY;
 
         // accept only if explicitly tagged for bike usage
         if ("motorway".equals(highwayValue) || "motorway_link".equals(highwayValue))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (way.hasTag("motorroad", "yes"))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         // do not use fords with normal bikes, flagged fords are in included above
         if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         // check access restrictions
         if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         else
-            return acceptBit;
+            return EncodingManager.Access.WAY;
     }
 
     boolean isSacScaleAllowed(String sacScale) {
@@ -301,7 +300,7 @@ boolean isSacScaleAllowed(String sacScale) {
     }
 
     @Override
-    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
+    public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
         int code = 0;
         if (relation.hasTag("route", "bicycle")) {
             Integer val = bikeNetworkToCode.get(relation.getTag("network"));
@@ -323,7 +322,6 @@ public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
      * Apply maxspeed: In contrast to the implementation of the AbstractFlagEncoder, we assume that
      * we can reach the maxspeed for bicycles in case that the road type speed is higher and not
      * just only 90%.
-     * <p>
      *
      * @param way   needed to retrieve tags
      * @param speed speed guessed e.g. from the road type or other tags
@@ -333,42 +331,37 @@ public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
     protected double applyMaxSpeed(ReaderWay way, double speed) {
         double maxSpeed = getMaxSpeed(way);
         if (maxSpeed >= 0) {
-            // We strictly obay speed limits, see #600
-            if (maxSpeed < speed) {
+            // We strictly obey speed limits, see #600
+            if (speed > maxSpeed)
                 return maxSpeed;
-            }
         }
+        if (speed > maxPossibleSpeed)
+            return maxPossibleSpeed;
         return speed;
     }
 
     @Override
-    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
-        if (!isAccept(allowed))
-            return 0;
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        if (access.canSkip())
+            return edgeFlags;
 
-        long flags = 0;
         double wayTypeSpeed = getSpeed(way);
-        if (!isFerry(allowed)) {
+        if (!access.isFerry()) {
             wayTypeSpeed = applyMaxSpeed(way, wayTypeSpeed);
-            flags = handleSpeed(way, wayTypeSpeed, flags);
-            flags = handleBikeRelated(way, flags, relationFlags > UNCHANGED.getValue());
-
-            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
-            if (isRoundabout) {
-                flags = setBool(flags, K_ROUNDABOUT, true);
-            }
-
+            handleSpeed(edgeFlags, way, wayTypeSpeed);
+            handleBikeRelated(edgeFlags, way, relationFlags > UNCHANGED.getValue());
         } else {
             double ferrySpeed = getFerrySpeed(way);
-            flags = handleSpeed(way, ferrySpeed, flags);
-            flags |= directionBitMask;
+            handleSpeed(edgeFlags, way, ferrySpeed);
+            accessEnc.setBool(false, edgeFlags, true);
+            accessEnc.setBool(true, edgeFlags, true);
         }
         int priorityFromRelation = 0;
         if (relationFlags != 0)
             priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
 
-        flags = priorityWayEncoder.setValue(flags, handlePriority(way, wayTypeSpeed, priorityFromRelation));
-        return flags;
+        priorityWayEncoder.setDecimal(false, edgeFlags, PriorityCode.getFactor(handlePriority(way, wayTypeSpeed, priorityFromRelation)));
+        return edgeFlags;
     }
 
     int getSpeed(ReaderWay way) {
@@ -429,17 +422,16 @@ int getSpeed(ReaderWay way) {
             if (speed <= PUSHING_SECTION_SPEED && way.hasTag("segregated", "yes"))
                 speed = PUSHING_SECTION_SPEED * 2;
         }
-
         return speed;
     }
 
     @Override
-    public InstructionAnnotation getAnnotation(long flags, Translation tr) {
+    public InstructionAnnotation getAnnotation(IntsRef edgeFlags, Translation tr) {
         int paveType = 0; // paved
-        if (isBool(flags, K_UNPAVED))
-            paveType = 1; // unpaved        
+        if (unpavedEncoder.getBool(false, edgeFlags))
+            paveType = 1; // unpaved
 
-        int wayType = (int) wayTypeEncoder.getValue(flags);
+        int wayType = wayTypeEncoder.getInt(false, edgeFlags);
         String wayName = getWayName(paveType, wayType, tr);
         return new InstructionAnnotation(0, wayName);
     }
@@ -478,7 +470,6 @@ String getWayName(int pavementType, int wayType, Translation tr) {
     /**
      * In this method we prefer cycleways or roads with designated bike access and avoid big roads
      * or roads with trams or pedestrian.
-     * <p>
      *
      * @return new priority based on priorityFromRelation and on the tags in ReaderWay.
      */
@@ -599,7 +590,7 @@ void collect(ReaderWay way, double wayTypeSpeed, TreeMap<Double, Integer> weight
     /**
      * Handle surface and wayType encoding
      */
-    long handleBikeRelated(ReaderWay way, long encoded, boolean partOfCycleRelation) {
+    void handleBikeRelated(IntsRef edgeFlags, ReaderWay way, boolean partOfCycleRelation) {
         String surfaceTag = way.getTag("surface");
         String highway = way.getTag("highway");
         String trackType = way.getTag("tracktype");
@@ -608,7 +599,7 @@ long handleBikeRelated(ReaderWay way, long encoded, boolean partOfCycleRelation)
         if ("track".equals(highway) && (trackType == null || !"grade1".equals(trackType))
                 || "path".equals(highway) && surfaceTag == null
                 || unpavedSurfaceTags.contains(surfaceTag)) {
-            encoded = setBool(encoded, K_UNPAVED, true);
+            unpavedEncoder.setBool(false, edgeFlags, true);
         }
 
         WayType wayType;
@@ -629,45 +620,15 @@ else if (wayType == WayType.OTHER_SMALL_WAY || wayType == WayType.PUSHING_SECTIO
         } else if ("cycleway".equals(highway))
             wayType = WayType.CYCLEWAY;
 
-        return wayTypeEncoder.setValue(encoded, wayType.getValue());
-    }
-
-    @Override
-    public long setBool(long flags, int key, boolean value) {
-        switch (key) {
-            case K_UNPAVED:
-                return value ? flags | unpavedBit : flags & ~unpavedBit;
-            default:
-                return super.setBool(flags, key, value);
-        }
-    }
-
-    @Override
-    public boolean isBool(long flags, int key) {
-        switch (key) {
-            case K_UNPAVED:
-                return (flags & unpavedBit) != 0;
-            default:
-                return super.isBool(flags, key);
-        }
-    }
-
-    @Override
-    public double getDouble(long flags, int key) {
-        switch (key) {
-            case PriorityWeighting.KEY:
-                return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
-            default:
-                return super.getDouble(flags, key);
-        }
+        wayTypeEncoder.setInt(false, edgeFlags, wayType.getValue());
     }
 
     boolean isPushingSection(ReaderWay way) {
         return way.hasTag("highway", pushingSectionsHighways) || way.hasTag("railway", "platform") || way.hasTag("bicycle", "dismount");
     }
 
-    protected long handleSpeed(ReaderWay way, double speed, long encoded) {
-        encoded = setSpeed(encoded, speed);
+    protected void handleSpeed(IntsRef edgeFlags, ReaderWay way, double speed) {
+        speedEncoder.setDecimal(false, edgeFlags, speed);
 
         // handle oneways        
         boolean isOneway = way.hasTag("oneway", oneways)
@@ -676,7 +637,7 @@ protected long handleSpeed(ReaderWay way, double speed, long encoded) {
                 || way.hasTag("vehicle:forward")
                 || way.hasTag("bicycle:forward");
 
-        if ((isOneway || way.hasTag("junction", "roundabout"))
+        if ((isOneway || roundaboutEnc.getBool(false, edgeFlags))
                 && !way.hasTag("oneway:bicycle", "no")
                 && !way.hasTag("bicycle:backward")
                 && !way.hasTag("cycleway", oppositeLanes)
@@ -687,14 +648,14 @@ protected long handleSpeed(ReaderWay way, double speed, long encoded) {
                     || way.hasTag("vehicle:forward", "no")
                     || way.hasTag("bicycle:forward", "no");
             if (isBackward)
-                encoded |= backwardBit;
+                accessEnc.setBool(true, edgeFlags, true);
             else
-                encoded |= forwardBit;
+                accessEnc.setBool(false, edgeFlags, true);
 
         } else {
-            encoded |= directionBitMask;
+            accessEnc.setBool(false, edgeFlags, true);
+            accessEnc.setBool(true, edgeFlags, true);
         }
-        return encoded;
     }
 
     protected void setHighwaySpeed(String highway, int speed) {
diff --git a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
index 6b9501efdd..9e4ed568b1 100644
--- a/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/BikeFlagEncoder.java
@@ -22,7 +22,6 @@
 
 /**
  * Specifies the settings for cycletouring/trekking
- * <p>
  *
  * @author ratrun
  * @author Peter Karich
@@ -50,6 +49,7 @@ public BikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         addPushingSection("footway");
         addPushingSection("pedestrian");
         addPushingSection("steps");
+        addPushingSection("platform");
 
         avoidHighwayTags.add("trunk");
         avoidHighwayTags.add("trunk_link");
diff --git a/core/src/main/java/com/graphhopper/routing/util/Car4WDFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/Car4WDFlagEncoder.java
index 0d9f474eff..754fb84a60 100644
--- a/core/src/main/java/com/graphhopper/routing/util/Car4WDFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/Car4WDFlagEncoder.java
@@ -50,48 +50,48 @@ public Car4WDFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
 
     @Override
     public int getVersion() {
-        return 1;
+        return 2;
     }
 
     @Override
-    public long acceptWay(ReaderWay way) {
+    public EncodingManager.Access getAccess(ReaderWay way) {
         // TODO: Ferries have conditionals, like opening hours or are closed during some time in the year
         String highwayValue = way.getTag("highway");
         String firstValue = way.getFirstPriorityTag(restrictions);
         if (highwayValue == null) {
             if (way.hasTag("route", ferries)) {
                 if (restrictedValues.contains(firstValue))
-                    return 0;
+                    return EncodingManager.Access.CAN_SKIP;
                 if (intendedValues.contains(firstValue) ||
                         // implied default is allowed only if foot and bicycle is not specified:
                         firstValue.isEmpty() && !way.hasTag("foot") && !way.hasTag("bicycle"))
-                    return acceptBit | ferryBit;
+                    return EncodingManager.Access.FERRY;
             }
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         }
 
         if (!defaultSpeedMap.containsKey(highwayValue))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         // multiple restrictions needs special handling compared to foot and bike, see also motorcycle
         if (!firstValue.isEmpty()) {
             if (restrictedValues.contains(firstValue) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-                return 0;
+                return EncodingManager.Access.CAN_SKIP;
             if (intendedValues.contains(firstValue))
-                return acceptBit;
+                return EncodingManager.Access.WAY;
         }
 
         // do not drive street cars into fords
         if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         else
-            return acceptBit;
+            return EncodingManager.Access.WAY;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
index afa6634888..34ec013448 100644
--- a/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/CarFlagEncoder.java
@@ -19,6 +19,9 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.UnsignedDecimalEncodedValue;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
 
@@ -26,7 +29,6 @@
 
 /**
  * Defines bit layout for cars. (speed, access, ferries, ...)
- * <p>
  *
  * @author Peter Karich
  * @author Nop
@@ -40,6 +42,7 @@
 
     // This value determines the speed for roads with access=destination
     protected int destinationSpeed;
+    protected boolean speedTwoDirections;
     /**
      * A map which associates string to speed. Get some impression:
      * http://www.itoworld.com/map/124#fullscreen
@@ -56,6 +59,7 @@ public CarFlagEncoder(PMap properties) {
                 properties.getDouble("speed_factor", 5),
                 properties.getBool("turn_costs", false) ? 1 : 0);
         this.properties = properties;
+        this.speedTwoDirections = properties.getBool("speed_two_directions", false);
         this.setBlockFords(properties.getBool("block_fords", true));
         this.setBlockByDefault(properties.getBool("block_barriers", true));
     }
@@ -83,7 +87,9 @@ public CarFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         potentialBarriers.add("lift_gate");
         potentialBarriers.add("kissing_gate");
         potentialBarriers.add("swing_gate");
+        potentialBarriers.add("cattle_grid");
 
+        absoluteBarriers.add("fence");
         absoluteBarriers.add("bollard");
         absoluteBarriers.add("stile");
         absoluteBarriers.add("turnstile");
@@ -108,13 +114,6 @@ public CarFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         badSurfaceSpeedMap.add("unpaved");
         badSurfaceSpeedMap.add("compacted");
 
-        // limit speed on bad surfaces to 30 km/h
-        badSurfaceSpeed = 30;
-
-        destinationSpeed = 5;
-
-        maxPossibleSpeed = 140;
-
         // autobahn
         defaultSpeedMap.put("motorway", 100);
         defaultSpeedMap.put("motorway_link", 70);
@@ -141,24 +140,28 @@ public CarFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         // forestry stuff
         defaultSpeedMap.put("track", 15);
 
+        // limit speed on bad surfaces to 30 km/h
+        badSurfaceSpeed = 30;
+        destinationSpeed = 5;
+        maxPossibleSpeed = 140;
+        speedDefault = defaultSpeedMap.get("secondary");
+
         init();
     }
 
     @Override
     public int getVersion() {
-        return 1;
+        return 2;
     }
 
     /**
      * Define the place of the speedBits in the edge flags for car.
      */
     @Override
-    public int defineWayBits(int index, int shift) {
+    public void createEncodedValues(List<EncodedValue> registerNewEncodedValue, String prefix, int index) {
         // first two bits are reserved for route handling in superclass
-        shift = super.defineWayBits(index, shift);
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, defaultSpeedMap.get("secondary"),
-                maxPossibleSpeed);
-        return shift + speedEncoder.getBits();
+        super.createEncodedValues(registerNewEncodedValue, prefix, index);
+        registerNewEncodedValue.add(speedEncoder = new UnsignedDecimalEncodedValue(EncodingManager.getKey(prefix, "average_speed"), speedBits, speedFactor, speedTwoDirections));
     }
 
     protected double getSpeed(ReaderWay way) {
@@ -184,99 +187,102 @@ protected double getSpeed(ReaderWay way) {
     }
 
     @Override
-    public long acceptWay(ReaderWay way) {
+    public EncodingManager.Access getAccess(ReaderWay way) {
         // TODO: Ferries have conditionals, like opening hours or are closed during some time in the year
         String highwayValue = way.getTag("highway");
         String firstValue = way.getFirstPriorityTag(restrictions);
         if (highwayValue == null) {
             if (way.hasTag("route", ferries)) {
                 if (restrictedValues.contains(firstValue))
-                    return 0;
+                    return EncodingManager.Access.CAN_SKIP;
                 if (intendedValues.contains(firstValue) ||
                         // implied default is allowed only if foot and bicycle is not specified:
                         firstValue.isEmpty() && !way.hasTag("foot") && !way.hasTag("bicycle"))
-                    return acceptBit | ferryBit;
+                    return EncodingManager.Access.FERRY;
             }
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         }
 
         if ("track".equals(highwayValue)) {
             String tt = way.getTag("tracktype");
             if (tt != null && !tt.equals("grade1") && !tt.equals("grade2") && !tt.equals("grade3"))
-                return 0;
+                return EncodingManager.Access.CAN_SKIP;
         }
 
         if (!defaultSpeedMap.containsKey(highwayValue))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         // multiple restrictions needs special handling compared to foot and bike, see also motorcycle
         if (!firstValue.isEmpty()) {
             if (restrictedValues.contains(firstValue) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-                return 0;
+                return EncodingManager.Access.CAN_SKIP;
             if (intendedValues.contains(firstValue))
-                return acceptBit;
+                return EncodingManager.Access.WAY;
         }
 
         // do not drive street cars into fords
         if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         else
-            return acceptBit;
+            return EncodingManager.Access.WAY;
     }
 
     @Override
-    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
+    public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
         return oldRelationFlags;
     }
 
     @Override
-    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
-        if (!isAccept(allowed))
-            return 0;
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access accept, long relationFlags) {
+        if (accept.canSkip())
+            return edgeFlags;
 
-        long flags = 0;
-        if (!isFerry(allowed)) {
+        if (!accept.isFerry()) {
             // get assumed speed from highway type
             double speed = getSpeed(way);
             speed = applyMaxSpeed(way, speed);
 
             speed = applyBadSurfaceSpeed(way, speed);
 
-            flags = setSpeed(flags, speed);
-
-            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
-            if (isRoundabout)
-                flags = setBool(flags, K_ROUNDABOUT, true);
+            setSpeed(false, edgeFlags, speed);
+            if (speedTwoDirections)
+                setSpeed(true, edgeFlags, speed);
 
+            boolean isRoundabout = roundaboutEnc.getBool(false, edgeFlags);
             if (isOneway(way) || isRoundabout) {
-                if (isBackwardOneway(way))
-                    flags |= backwardBit;
-
                 if (isForwardOneway(way))
-                    flags |= forwardBit;
-            } else
-                flags |= directionBitMask;
+                    accessEnc.setBool(false, edgeFlags, true);
+                if (isBackwardOneway(way))
+                    accessEnc.setBool(true, edgeFlags, true);
+            } else {
+                accessEnc.setBool(false, edgeFlags, true);
+                accessEnc.setBool(true, edgeFlags, true);
+            }
 
         } else {
             double ferrySpeed = getFerrySpeed(way);
-            flags = setSpeed(flags, ferrySpeed);
-            flags |= directionBitMask;
+            accessEnc.setBool(false, edgeFlags, true);
+            accessEnc.setBool(true, edgeFlags, true);
+            setSpeed(false, edgeFlags, ferrySpeed);
+            if (speedTwoDirections)
+                setSpeed(true, edgeFlags, ferrySpeed);
         }
 
         for (String restriction : restrictions) {
             if (way.hasTag(restriction, "destination")) {
                 // This is problematic as Speed != Time
-                flags = setSpeed(flags, destinationSpeed);
+                setSpeed(false, edgeFlags, destinationSpeed);
+                if (speedTwoDirections)
+                    setSpeed(true, edgeFlags, destinationSpeed);
             }
         }
-
-        return flags;
+        return edgeFlags;
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
index 2533bd0056..5d5ce97847 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DataFlagEncoder.java
@@ -19,17 +19,17 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.util.spatialrules.*;
+import com.graphhopper.routing.profiles.*;
 import com.graphhopper.routing.weighting.GenericWeighting;
-import com.graphhopper.util.*;
-import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.InstructionAnnotation;
+import com.graphhopper.util.PMap;
+import com.graphhopper.util.Translation;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.util.*;
-import java.util.Map.Entry;
-
-import static com.graphhopper.util.Helper.*;
 
 /**
  * This encoder tries to store all way information into a 32 or 64bit value. Later extendable to
@@ -66,29 +66,8 @@
             put("track", 15d);
         }
     };
-    private final Map<String, Integer> surfaceMap = new HashMap<>();
-    private final Map<String, Integer> highwayMap = new HashMap<>();
-    private final Map<String, Integer> accessMap = new HashMap<>();
-    private final List<String> transportModeList = new ArrayList<>();
-    private final Map<String, Integer> transportModeMap = new HashMap<>();
-    private final int transportModeTunnelValue;
-    private final int transportModeBridgeValue;
-    private final int transportModeFordValue;
-    private long bit0;
-    private EncodedDoubleValue carFwdMaxspeedEncoder;
-    private EncodedDoubleValue carBwdMaxspeedEncoder;
-    private EncodedDoubleValue heightEncoder;
-    private EncodedDoubleValue weightEncoder;
-    private EncodedDoubleValue widthEncoder;
-    private EncodedValue surfaceEncoder;
-    private EncodedValue highwayEncoder;
-    private EncodedValue transportModeEncoder;
-    private EncodedValue accessEncoder;
-    private boolean storeHeight = false;
-    private boolean storeWeight = false;
-    private boolean storeWidth = false;
-    private EncodedValue spatialEncoder;
-    private SpatialRuleLookup spatialRuleLookup = SpatialRuleLookup.EMPTY;
+
+    private EnumEncodedValue<RoadEnvironment> roadEnvironmentEnc;
 
     public DataFlagEncoder() {
         this(5, 5, 0);
@@ -99,151 +78,60 @@ public DataFlagEncoder(PMap properties) {
                 properties.getDouble("speed_factor", 5),
                 properties.getBool("turn_costs", false) ? 1 : 0);
         this.properties = properties;
-        this.setStoreHeight(properties.getBool("store_height", false));
-        this.setStoreWeight(properties.getBool("store_weight", false));
-        this.setStoreWidth(properties.getBool("store_width", false));
     }
 
     public DataFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         // TODO include turn information
         super(speedBits, speedFactor, maxTurnCosts);
 
-        maxPossibleSpeed = 140;
-        //
-        // TODO restrictions (agricultural, emergency, destination, private, delivery, customers)
-        //
-
-        // highway and certain tags like ferry and shuttle_train which can be used here (no logical overlap)
-        List<String> highwayList = Arrays.asList(
-                /* reserve index=0 for unset roads (not accessible) */
-                "_default",
-                "motorway", "motorway_link", "motorroad", "trunk", "trunk_link",
-                "primary", "primary_link", "secondary", "secondary_link", "tertiary", "tertiary_link",
-                "unclassified", "residential", "living_street", "service", "road", "track",
-                "forestry", "cycleway", "steps", "path", "footway", "pedestrian",
-                "ferry", "shuttle_train");
-        int counter = 0;
-        for (String hw : highwayList) {
-            highwayMap.put(hw, counter++);
-        }
-
-        // We need transport mode additionally to highway e.g. a secondary highway can be a tunnel.
-        // Also 'roundabout' needs a separate bit as a tunnel or a bridge can be a roundabout at the same time.
-        transportModeList.addAll(Arrays.asList("_default", "bridge", "tunnel", "ford", "aerialway"));
-        counter = 0;
-        for (String tm : transportModeList) {
-            transportModeMap.put(tm, counter++);
-        }
-        transportModeTunnelValue = transportModeMap.get("tunnel");
-        transportModeBridgeValue = transportModeMap.get("bridge");
-        transportModeFordValue = transportModeMap.get("ford");
-
-        List<String> surfaceList = Arrays.asList("_default", "asphalt", "unpaved", "paved", "gravel",
-                "ground", "dirt", "grass", "concrete", "paving_stones", "sand", "compacted", "cobblestone", "mud", "ice");
-        counter = 0;
-        for (String s : surfaceList) {
-            surfaceMap.put(s, counter++);
-        }
-
+        maxPossibleSpeed = (int) MaxSpeed.UNLIMITED_SIGN_SPEED;
         restrictions.addAll(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
-
-        // Ordered in increasingly restrictive order
-        // Note: if you update this list you have to update the method getAccessValue too
-        List<String> accessList = Arrays.asList(
-                //"designated", "permissive", "customers", "delivery",
-                "yes", "destination", "private", "no"
-        );
-
-        counter = 0;
-        for (String s : accessList) {
-            accessMap.put(s, counter++);
-        }
-
-        accessMap.put("designated", accessMap.get("yes"));
-        accessMap.put("permissive", accessMap.get("yes"));
-
-        accessMap.put("customers", accessMap.get("destination"));
-        accessMap.put("delivery", accessMap.get("destination"));
-
-        // accessMap.put("forestry", accessMap.get("agricultural"));
     }
 
     @Override
-    public int defineWayBits(int index, int shift) {
-        // TODO use this approach in other flag encoders too then we can do a global swap for all and bit0 can be at position 0!
-        bit0 = 1L << shift;
-        shift++;
-
+    public void createEncodedValues(List<EncodedValue> registerNewEncodedValue, String prefix, int index) {
         // TODO support different vehicle types, currently just roundabout and fwd&bwd for one vehicle type
-        shift = super.defineWayBits(index, shift);
+        super.createEncodedValues(registerNewEncodedValue, prefix, index);
 
-        carFwdMaxspeedEncoder = new EncodedDoubleValue("car fwd maxspeed", shift, speedBits, speedFactor, 0, maxPossibleSpeed, true);
-        shift += carFwdMaxspeedEncoder.getBits();
-
-        carBwdMaxspeedEncoder = new EncodedDoubleValue("car bwd maxspeed", shift, speedBits, speedFactor, 0, maxPossibleSpeed, true);
-        shift += carBwdMaxspeedEncoder.getBits();
-
-        /* Value range: [3.0m, 5.4m] */
-        if (isStoreHeight()) {
-            heightEncoder = new EncodedDoubleValue("height restriction", shift, 7, 0.1, 0, 12, true);
-            shift += heightEncoder.getBits();
-        }
-
-        /* Value range: [1.0t, 59.5t] */
-        if (isStoreWeight()) {
-            weightEncoder = new EncodedDoubleValue("weight restriction", shift, 10, 0.1, 0, 100, true);
-            shift += weightEncoder.getBits();
+        for (String key : Arrays.asList(RoadClass.KEY, RoadEnvironment.KEY, RoadAccess.KEY, MaxSpeed.KEY)) {
+            if (!encodedValueLookup.hasEncodedValue(key))
+                throw new IllegalStateException("To use DataFlagEncoder and the GenericWeighting you need to add " +
+                        "the encoded value " + key + " before this '" + toString() + "' flag encoder. Order is important! " +
+                        "E.g. use the config: graph.encoded_values: " + key);
         }
 
-        /* Value range: [2.5m, 3.5m] */
-        if (isStoreWidth()) {
-            widthEncoder = new EncodedDoubleValue("width restriction", shift, 6, 0.1, 0, 6, true);
-            shift += widthEncoder.getBits();
-        }
-
-        highwayEncoder = new EncodedValue("highway", shift, 5, 1, 0, highwayMap.size(), true);
-        shift += highwayEncoder.getBits();
-
-        surfaceEncoder = new EncodedValue("surface", shift, 4, 1, 0, surfaceMap.size(), true);
-        shift += surfaceEncoder.getBits();
-
-        transportModeEncoder = new EncodedValue("transport mode", shift, 3, 1, 0, transportModeMap.size(), true);
-        shift += transportModeEncoder.getBits();
-
-        accessEncoder = new EncodedValue("access car", shift, 3, 1, 1, 4, true);
-        shift += accessEncoder.getBits();
-
-        int tmpMax = spatialRuleLookup.size() - 1;
-        int bits = 32 - Integer.numberOfLeadingZeros(tmpMax);
-        spatialEncoder = new EncodedValue("spatial_location", shift, bits, 1, 0, tmpMax, true);
-        shift += spatialEncoder.getBits();
+        // workaround to init AbstractWeighting.avSpeedEnc variable that GenericWeighting does not need
+        speedEncoder = new UnsignedDecimalEncodedValue("fake", 1, 1, false);
+        roadEnvironmentEnc = getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class);
+    }
 
-        return shift;
+    protected void flagsDefault(IntsRef edgeFlags, boolean forward, boolean backward) {
+        accessEnc.setBool(false, edgeFlags, forward);
+        accessEnc.setBool(true, edgeFlags, backward);
     }
 
     @Override
-    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
-        return 0;
+    public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
+        return oldRelationFlags;
     }
 
     @Override
-    public long acceptWay(ReaderWay way) {
+    public EncodingManager.Access getAccess(ReaderWay way) {
         // important to skip unsupported highways, otherwise too many have to be removed after graph creation
         // and node removal is not yet designed for that
-        if (getHighwayValue(way) == 0)
-            return 0;
+        if (getRoadClass(way) == RoadClass.OTHER)
+            return EncodingManager.Access.CAN_SKIP;
 
-        return acceptBit;
+        return EncodingManager.Access.WAY;
     }
 
-    int getHighwayValue(ReaderWay way) {
+    RoadClass getRoadClass(ReaderWay way) {
         String highwayValue = way.getTag("highway");
-        Integer hwValue = highwayMap.get(highwayValue);
+        RoadClass rc = RoadClass.find(highwayValue);
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
-            hwValue = 0;
+            return RoadClass.OTHER;
 
-        if (hwValue == null) {
-            hwValue = 0;
+        if (rc == RoadClass.OTHER) {
             if (way.hasTag("route", ferries)) {
                 String motorcarTag = way.getTag("motorcar");
                 if (motorcarTag == null)
@@ -251,138 +139,25 @@ int getHighwayValue(ReaderWay way) {
 
                 if (motorcarTag == null && !way.hasTag("foot") && !way.hasTag("bicycle")
                         || "yes".equals(motorcarTag))
-                    hwValue = highwayMap.get("ferry");
+                    rc = RoadClass.find(way.getTag("ferry"));
             }
         }
-        return hwValue;
-    }
-
-    int getAccessValue(ReaderWay way) {
-        int accessValue = 0;
-        Integer tmpAccessValue;
-        for (String restriction : restrictions) {
-            tmpAccessValue = accessMap.get(way.getTag(restriction, "yes"));
-            if (tmpAccessValue != null && tmpAccessValue > accessValue) {
-                accessValue = tmpAccessValue;
-            }
-        }
-
-        if (accessValue == 0) {
-            // TODO Fix transportation mode when adding other forms of transportation
-            switch (getSpatialRule(way).getAccessValue(way.getTag("highway", ""), TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE)) {
-                case ACCESSIBLE:
-                    accessValue = accessMap.get("yes");
-                    break;
-                case EVENTUALLY_ACCESSIBLE:
-                    accessValue = accessMap.get("destination");
-                    break;
-                case NOT_ACCESSIBLE:
-                    accessValue = accessMap.get("no");
-                    break;
-            }
-        }
-
-        return accessValue;
-    }
-
-    public AccessValue getAccessValue(long flags) {
-        int accessValue = (int) accessEncoder.getValue(flags);
-        switch (accessValue) {
-            case 0:
-                return AccessValue.ACCESSIBLE;
-            // NOT_ACCESSIBLE_KEY
-            case 3:
-                return AccessValue.NOT_ACCESSIBLE;
-            default:
-                return AccessValue.EVENTUALLY_ACCESSIBLE;
-        }
+        return rc;
     }
 
     @Override
-    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
-        if (!isAccept(allowed))
-            return 0;
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        if (access.canSkip())
+            return edgeFlags;
 
         try {
             // HIGHWAY
-            int hwValue = getHighwayValue(way);
+            RoadClass hwValue = getRoadClass(way);
             // exclude any routing like if you have car and need to exclude all rails or ships
-            if (hwValue == 0)
-                return 0;
-
-            long flags = 0;
-            if (isFerry(allowed)) {
-                hwValue = highwayMap.get("ferry");
-            }
-
-            flags = highwayEncoder.setValue(0, hwValue);
-
-            // MAXSPEED
-            double maxSpeed = parseSpeed(way.getTag("maxspeed"));
-            if (maxSpeed < 0) {
-                // TODO What if no maxspeed is set, but only forward and backward, and both are higher than the usually allowed?
-                maxSpeed = getSpatialRule(way).getMaxSpeed(way.getTag("highway", ""), maxSpeed);
-            }
-            double fwdSpeed = parseSpeed(way.getTag("maxspeed:forward"));
-            if (fwdSpeed < 0 && maxSpeed > 0)
-                fwdSpeed = maxSpeed;
-            if (fwdSpeed > getMaxPossibleSpeed())
-                fwdSpeed = getMaxPossibleSpeed();
-
-
-            double bwdSpeed = parseSpeed(way.getTag("maxspeed:backward"));
-            if (bwdSpeed < 0 && maxSpeed > 0)
-                bwdSpeed = maxSpeed;
-            if (bwdSpeed > getMaxPossibleSpeed())
-                bwdSpeed = getMaxPossibleSpeed();
-
-
-            // 0 is reserved for default i.e. no maxspeed sign (does not imply no speed limit)
-            // TODO and 140 should be used for "none" speed limit on German Autobahn
-            if (fwdSpeed > 0)
-                flags = carFwdMaxspeedEncoder.setDoubleValue(flags, fwdSpeed);
-
-            if (bwdSpeed > 0)
-                flags = carBwdMaxspeedEncoder.setDoubleValue(flags, bwdSpeed);
-
-            // Road attributes (height, weight, width)
-            if (isStoreHeight()) {
-                List<String> heightTags = Arrays.asList("maxheight", "maxheight:physical");
-                flags = extractMeter(way, flags, heightEncoder, heightTags);
-            }
-
-            if (isStoreWeight()) {
-                List<String> weightTags = Arrays.asList("maxweight", "maxgcweight");
-                flags = extractTons(way, flags, weightEncoder, weightTags);
-            }
-
-            if (isStoreWidth()) {
-                List<String> widthTags = Arrays.asList("maxwidth", "maxwidth:physical");
-                flags = extractMeter(way, flags, widthEncoder, widthTags);
-            }
-
-            // SURFACE
-            String surfaceValue = way.getTag("surface");
-            Integer sValue = surfaceMap.get(surfaceValue);
-            if (sValue == null)
-                sValue = 0;
-            flags = surfaceEncoder.setValue(flags, sValue);
-
-            // TRANSPORT MODE
-            int tmValue = 0;
-            for (String tm : transportModeList) {
-                if (way.hasTag(tm)) {
-                    tmValue = transportModeMap.get(tm);
-                    break;
-                }
-            }
-            flags = transportModeEncoder.setValue(flags, tmValue);
-
-            // ROUNDABOUT
-            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
-            if (isRoundabout)
-                flags = setBool(flags, K_ROUNDABOUT, true);
+            if (hwValue == RoadClass.OTHER)
+                return edgeFlags;
 
+            boolean isRoundabout = roundaboutEnc.getBool(false, edgeFlags);
             // ONEWAY (currently car only)
             boolean isOneway = way.hasTag("oneway", oneways)
                     || way.hasTag("vehicle:backward")
@@ -395,372 +170,30 @@ public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
                         || way.hasTag("vehicle:forward", "no")
                         || way.hasTag("motor_vehicle:forward", "no");
                 if (isBackward)
-                    flags |= backwardBit;
+                    accessEnc.setBool(true, edgeFlags, true);
                 else
-                    flags |= forwardBit;
-            } else
-                flags |= directionBitMask;
-
-            if (!isBit0Empty(flags))
-                throw new IllegalStateException("bit0 has to be empty on creation");
-
-            flags = accessEncoder.setValue(flags, getAccessValue(way));
-
-            GHPoint estimatedCenter = way.getTag("estimated_center", null);
-            if (estimatedCenter != null) {
-                SpatialRule rule = spatialRuleLookup.lookupRule(estimatedCenter);
-                flags = spatialEncoder.setValue(flags, spatialRuleLookup.getSpatialId(rule));
+                    accessEnc.setBool(false, edgeFlags, true);
+            } else {
+                accessEnc.setBool(false, edgeFlags, true);
+                accessEnc.setBool(true, edgeFlags, true);
             }
 
-            return flags;
+            return edgeFlags;
         } catch (Exception ex) {
             throw new RuntimeException("Error while parsing way " + way.toString(), ex);
         }
     }
 
-    private SpatialRule getSpatialRule(ReaderWay way) {
-        GHPoint estmCentre = way.getTag("estimated_center", null);
-        if (estmCentre != null) {
-            return spatialRuleLookup.lookupRule(estmCentre);
-        }
-        return SpatialRule.EMPTY;
-    }
-
-    private long extractMeter(ReaderWay way, long flags, EncodedDoubleValue valueEncoder, List<String> keys) {
-        String value = way.getFirstPriorityTag(keys);
-        if (isEmpty(value)) return flags;
-
-        double val;
-        try {
-            val = stringToMeter(value);
-        } catch (Exception ex) {
-            LOG.warn("Unable to extract meter from malformed road attribute '{}' for way (OSM_ID = {}).", value, way.getId(), ex);
-            return flags;
-        }
-
-        try {
-            flags = valueEncoder.setDoubleValue(flags, val);
-        } catch (IllegalArgumentException e) {
-            LOG.warn("Unable to process value '{}' for way (OSM_ID = {}).", val, way.getId(), e);
-        }
-
-        return flags;
-    }
-
-    private long extractTons(ReaderWay way, long flags, EncodedDoubleValue valueEncoder, List<String> keys) {
-        String value = way.getFirstPriorityTag(keys);
-        if (isEmpty(value)) return flags;
-
-        double val;
-        try {
-            val = stringToTons(value);
-        } catch (Throwable t) {
-            LOG.warn("Unable to extract tons from malformed road attribute '{}' for way (OSM_ID = {}).", value, way.getId(), t);
-            return flags;
-        }
-
-        try {
-            flags = valueEncoder.setDoubleValue(flags, val);
-        } catch (IllegalArgumentException e) {
-            LOG.warn("Unable to process tons value '{}' for way (OSM_ID = {}).", val, way.getId(), e);
-        }
-
-        return flags;
-    }
-
-    public static double stringToTons(String value) {
-        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(tons|ton)", "t");
-        value = value.replace("mgw", "").trim();
-        double factor = 1;
-        if (value.endsWith("t")) {
-            value = value.substring(0, value.length() - 1);
-        } else if (value.endsWith("lbs")) {
-            value = value.substring(0, value.length() - 3);
-            factor = 0.00045359237;
-        }
-
-        return Double.parseDouble(value) * factor;
-    }
-
-    public static double stringToMeter(String value) {
-        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
-        double factor = 1;
-        double offset = 0;
-        value = value.replaceAll("(\\\"|\'\')", "in").replaceAll("(\'|feet)", "ft");
-        if (value.startsWith("~") || value.contains("approx")) {
-            value = value.replaceAll("(\\~|approx)", "").trim();
-            factor = 0.8;
-        }
-
-        if (value.endsWith("in")) {
-            int startIndex = value.indexOf("ft");
-            String inchValue;
-            if (startIndex < 0) {
-                startIndex = 0;
-            } else {
-                startIndex += 2;
-            }
-
-            inchValue = value.substring(startIndex, value.length() - 2);
-            value = value.substring(0, startIndex);
-            offset = Double.parseDouble(inchValue) * 0.0254;
-        }
-
-        if (value.endsWith("ft")) {
-            value = value.substring(0, value.length() - 2);
-            factor *= 0.3048;
-        } else if (value.endsWith("m")) {
-            value = value.substring(0, value.length() - 1);
-        }
-
-        if (value.isEmpty()) {
-            return offset;
-        } else {
-            return Double.parseDouble(value) * factor + offset;
-        }
-    }
-
-    /**
-     * This method returns the spatialId stored in the specified flags or -1 if not enabled for this encoder.
-     */
-    public int getSpatialId(long flags) {
-        if (spatialEncoder == null)
-            return -1;
-
-        return (int) spatialEncoder.getValue(flags);
-    }
-
-    /**
-     * This method set the spatial ID (e.g. country ID) of the specified flags to the specified id. Fetch the unique
-     * spatial ID via spatialRuleLookup.lookup().getSpatialId
-     */
-    public long setSpatialId(long flags, int id) {
-        return spatialEncoder.setValue(flags, id);
-    }
-
-    @Override
-    public long reverseFlags(long flags) {
-        // see #728 for an explanation
-        return flags ^ bit0;
-    }
-
-    /**
-     * Interpret flags in forward direction if bit0 is empty. This method is used when accessing
-     * direction dependent values and avoid reverse flags, see #728.
-     */
-    private boolean isBit0Empty(long flags) {
-        return (flags & bit0) == 0;
-    }
-
-    public int getHighway(EdgeIteratorState edge) {
-        return (int) highwayEncoder.getValue(edge.getFlags());
-    }
-
-    /**
-     * Do not use within weighting as this is suboptimal from performance point of view.
-     */
-    public String getHighwayAsString(EdgeIteratorState edge) {
-        int val = getHighway(edge);
-        for (Entry<String, Integer> e : highwayMap.entrySet()) {
-            if (e.getValue() == val)
-                return e.getKey();
-        }
-        return null;
-    }
-
-    double[] getHighwaySpeedMap(Map<String, Double> map) {
-        if (map == null)
-            throw new IllegalArgumentException("Map cannot be null when calling getHighwaySpeedMap");
-
-        double[] res = new double[highwayMap.size()];
-        for (Entry<String, Double> e : map.entrySet()) {
-            Integer integ = highwayMap.get(e.getKey());
-            if (integ == null)
-                throw new IllegalArgumentException("Graph not prepared for highway=" + e.getKey());
-
-            if (e.getValue() < 0)
-                throw new IllegalArgumentException("Negative speed " + e.getValue() + " not allowed. highway=" + e.getKey());
-
-            res[integ] = e.getValue();
-        }
-        return res;
-    }
-
-    public int getSurface(EdgeIteratorState edge) {
-        return (int) surfaceEncoder.getValue(edge.getFlags());
-    }
-
-    public String getSurfaceAsString(EdgeIteratorState edge) {
-        int val = getSurface(edge);
-        for (Entry<String, Integer> e : surfaceMap.entrySet()) {
-            if (e.getValue() == val)
-                return e.getKey();
-        }
-        return null;
-    }
-
-    public int getTransportMode(EdgeIteratorState edge) {
-        return (int) transportModeEncoder.getValue(edge.getFlags());
-    }
-
-    public boolean isTransportModeTunnel(EdgeIteratorState edge) {
-        return transportModeEncoder.getValue(edge.getFlags()) == this.transportModeTunnelValue;
-    }
-
-    public boolean isTransportModeBridge(EdgeIteratorState edge) {
-        return transportModeEncoder.getValue(edge.getFlags()) == this.transportModeBridgeValue;
-    }
-
-    public boolean isTransportModeFord(long flags) {
-        return transportModeEncoder.getValue(flags) == this.transportModeFordValue;
-    }
-
-    public String getTransportModeAsString(EdgeIteratorState edge) {
-        int val = getTransportMode(edge);
-        for (Entry<String, Integer> e : transportModeMap.entrySet()) {
-            if (e.getValue() == val)
-                return e.getKey();
-        }
-        return null;
-    }
-
-    public double[] getTransportModeMap(Map<String, Double> map) {
-        double[] res = new double[transportModeMap.size()];
-        for (Entry<String, Double> e : map.entrySet()) {
-            Integer integ = transportModeMap.get(e.getKey());
-            if (integ == null)
-                throw new IllegalArgumentException("Graph not prepared for transport_mode=" + e.getKey());
-
-            if (e.getValue() < 0)
-                throw new IllegalArgumentException("Negative speed " + e.getValue() + " not allowed. transport_mode=" + e.getKey());
-
-            res[integ] = e.getValue();
-        }
-        return res;
-    }
-
-    public boolean isRoundabout(EdgeIteratorState edge) {
-        // use direct call instead of isBool
-        return (edge.getFlags() & roundaboutBit) != 0;
-    }
-
-    public int getAccessType(String accessStr) {
-        // access, motor_vehicle, bike, foot, hgv, bus
-        return 0;
-    }
-
-    public final boolean isForward(EdgeIteratorState edge, int accessType) {
-        // TODO shift dependent on the accessType
-        // use only one bit for foot?
-        long flags = edge.getFlags();
-        return (flags & (isBit0Empty(flags) ? forwardBit : backwardBit)) != 0;
-    }
-
-    @Override
-    public final boolean isForward(long flags) {
-        // TODO remove old method
-        return (flags & (isBit0Empty(flags) ? forwardBit : backwardBit)) != 0;
-    }
-
-    public final boolean isBackward(EdgeIteratorState edge, int accessType) {
-        long flags = edge.getFlags();
-        return (flags & (isBit0Empty(flags) ? backwardBit : forwardBit)) != 0;
-    }
-
-    @Override
-    public final boolean isBackward(long flags) {
-        // TODO remove old method
-        return (flags & (isBit0Empty(flags) ? backwardBit : forwardBit)) != 0;
-    }
-
-    public double getMaxspeed(EdgeIteratorState edge, int accessType, boolean reverse) {
-        long flags = edge.getFlags();
-        if (!isBit0Empty(flags))
-            reverse = !reverse;
-
-        double val;
-        if (reverse)
-            val = carBwdMaxspeedEncoder.getDoubleValue(flags);
-        else
-            val = carFwdMaxspeedEncoder.getDoubleValue(flags);
-
-        if (val < 0)
-            throw new IllegalStateException("maxspeed cannot be negative, edge:" + edge.getEdge() + ", access type" + accessType + ", reverse:" + reverse);
-
-        // default is 0 but return invalid speed explicitely (TODO can we do this at the value encoder level?)
-        if (val == 0)
-            return -1;
-        return val;
-    }
-
-    public double getHeight(EdgeIteratorState edge) {
-        long flags = edge.getFlags();
-        return heightEncoder.getDoubleValue(flags);
-    }
-
-    public double getWeight(EdgeIteratorState edge) {
-        long flags = edge.getFlags();
-        return weightEncoder.getDoubleValue(flags);
-    }
-
-    public double getWidth(EdgeIteratorState edge) {
-        long flags = edge.getFlags();
-        return widthEncoder.getDoubleValue(flags);
-    }
-
-    @Override
-    public long flagsDefault(boolean forward, boolean backward) {
-        // just pick car mode to set access values?
-        // throw new RuntimeException("do not call flagsDefault");
-        return setAccess(0, forward, backward);
-    }
-
-    @Override
-    public long setAccess(long flags, boolean forward, boolean backward) {
-        // TODO we should interpret access for *any* vehicle
-        // TODO in subnetwork we need to remove access for certain weighting profiles (or set of roads?)
-        boolean isForward = isBit0Empty(flags);
-        if (!isForward) {
-            boolean tmp = forward;
-            forward = backward;
-            backward = tmp;
-        }
-
-        flags = forward ? flags | forwardBit : flags & ~forwardBit;
-        flags = backward ? flags | backwardBit : flags & ~backwardBit;
-        return flags;
-    }
-
     @Override
-    public long setSpeed(long flags, double speed) {
+    protected void setSpeed(boolean reverse, IntsRef edgeFlags, double speed) {
         throw new RuntimeException("do not call setSpeed");
     }
 
     @Override
-    protected long setLowSpeed(long flags, double speed, boolean reverse) {
-        throw new RuntimeException("do not call setLowSpeed");
-    }
-
-    @Override
-    public double getSpeed(long flags) {
+    double getSpeed(boolean reverse, IntsRef flags) {
         throw new UnsupportedOperationException("Calculate speed via more customizable Weighting.calcMillis method");
     }
 
-    @Override
-    public long setReverseSpeed(long flags, double speed) {
-        throw new RuntimeException("do not call setReverseSpeed");
-    }
-
-    @Override
-    public double getReverseSpeed(long flags) {
-        throw new RuntimeException("do not call getReverseSpeed");
-    }
-
-    @Override
-    public long setProperties(double speed, boolean forward, boolean backward) {
-        throw new RuntimeException("do not call setProperties");
-    }
-
     @Override
     protected double getMaxSpeed(ReaderWay way) {
         throw new RuntimeException("do not call getMaxSpeed(ReaderWay)");
@@ -784,60 +217,18 @@ public boolean supports(Class<?> feature) {
         return GenericWeighting.class.isAssignableFrom(feature);
     }
 
-    public DataFlagEncoder setStoreHeight(boolean storeHeight) {
-        this.storeHeight = storeHeight;
-        return this;
-    }
-
-    public boolean isStoreHeight() {
-        return storeHeight;
-    }
-
-    public DataFlagEncoder setStoreWeight(boolean storeWeight) {
-        this.storeWeight = storeWeight;
-        return this;
-    }
-
-    public boolean isStoreWeight() {
-        return storeWeight;
-    }
-
-    public DataFlagEncoder setStoreWidth(boolean storeWidth) {
-        this.storeWidth = storeWidth;
-        return this;
-    }
-
-    public boolean isStoreWidth() {
-        return storeWidth;
-    }
-
-
-    public DataFlagEncoder setSpatialRuleLookup(SpatialRuleLookup spatialRuleLookup) {
-        this.spatialRuleLookup = spatialRuleLookup;
-        return this;
-    }
-
     @Override
-    public InstructionAnnotation getAnnotation(long flags, Translation tr) {
-        if (isTransportModeFord(flags)) {
+    public InstructionAnnotation getAnnotation(IntsRef flags, Translation tr) {
+        if (roadEnvironmentEnc.getEnum(false, flags) == RoadEnvironment.FORD) {
             return new InstructionAnnotation(1, tr.tr("way_contains_ford"));
         }
 
         return super.getAnnotation(flags, tr);
     }
 
-
-    @Override
-    protected String getPropertiesString() {
-        return super.getPropertiesString() +
-                "|store_height=" + storeHeight +
-                "|store_weight=" + storeWeight +
-                "|store_width=" + storeWidth;
-    }
-
     @Override
     public int getVersion() {
-        return 3;
+        return 4;
     }
 
     @Override
@@ -850,29 +241,34 @@ public String toString() {
      * necessary when we read JSON.
      */
     public WeightingConfig createWeightingConfig(PMap pMap) {
-        HashMap<String, Double> map = new HashMap<>(DEFAULT_SPEEDS.size());
-        for (Entry<String, Double> e : DEFAULT_SPEEDS.entrySet()) {
-            map.put(e.getKey(), pMap.getDouble(e.getKey(), e.getValue()));
+        HashMap<String, Double> customSpeedMap = new HashMap<>(DEFAULT_SPEEDS.size());
+        double[] speedArray = new double[DEFAULT_SPEEDS.size()];
+        for (Map.Entry<String, Double> e : DEFAULT_SPEEDS.entrySet()) {
+            double val = pMap.getDouble(e.getKey(), e.getValue());
+            customSpeedMap.put(e.getKey(), val);
+            RoadClass rc = RoadClass.find(e.getKey());
+            speedArray[rc.ordinal()] = val;
         }
 
-        return new WeightingConfig(getHighwaySpeedMap(map));
+        // use defaults per road class in the map for average speed estimate
+        return new WeightingConfig(getEnumEncodedValue(RoadClass.KEY, RoadClass.class), speedArray);
     }
 
-    public class WeightingConfig {
+    public static class WeightingConfig {
         private final double[] speedArray;
+        private final EnumEncodedValue<RoadClass> roadClassEnc;
 
-        public WeightingConfig(double[] speedArray) {
+        public WeightingConfig(EnumEncodedValue<RoadClass> roadClassEnc, double[] speedArray) {
+            this.roadClassEnc = roadClassEnc;
             this.speedArray = speedArray;
         }
 
         public double getSpeed(EdgeIteratorState edgeState) {
-            int highwayKey = getHighway(edgeState);
-            // ensure before (in createResult) that all highways that were specified in the request are known
-            double speed = speedArray[highwayKey];
-            if (speed < 0)
-                throw new IllegalStateException("speed was negative? " + edgeState.getEdge()
-                        + ", highway:" + highwayKey);
-            return speed;
+            RoadClass rc = edgeState.get(roadClassEnc);
+            if (rc.ordinal() >= speedArray.length)
+                throw new IllegalStateException("RoadClass not found in speed map " + rc);
+
+            return speedArray[rc.ordinal()];
         }
 
         public double getMaxSpecifiedSpeed() {
diff --git a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
index 29f598fd3c..1ae1fb4020 100644
--- a/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/DefaultEdgeFilter.java
@@ -17,28 +17,35 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * @author Peter Karich
  */
 public class DefaultEdgeFilter implements EdgeFilter {
+    private static int DEFAULT_FILTER_ID = 0;
     private final boolean bwd;
     private final boolean fwd;
-    private FlagEncoder encoder;
+    private final BooleanEncodedValue accessEnc;
+    /**
+     * Used to be able to create non-equal filter instances with equal access encoder and fwd/bwd flags.
+     */
+    private int filterId;
 
-    protected DefaultEdgeFilter(FlagEncoder encoder, boolean fwd, boolean bwd) {
-        this.encoder = encoder;
-        this.bwd = bwd;
+    private DefaultEdgeFilter(BooleanEncodedValue accessEnc, boolean fwd, boolean bwd, int filterId) {
+        this.accessEnc = accessEnc;
         this.fwd = fwd;
+        this.bwd = bwd;
+        this.filterId = filterId;
     }
 
-    public static DefaultEdgeFilter outEdges(FlagEncoder flagEncoder) {
-        return new DefaultEdgeFilter(flagEncoder, true, false);
+    public static DefaultEdgeFilter outEdges(BooleanEncodedValue accessEnc) {
+        return new DefaultEdgeFilter(accessEnc, true, false, DEFAULT_FILTER_ID);
     }
 
-    public static DefaultEdgeFilter inEdges(FlagEncoder flagEncoder) {
-        return new DefaultEdgeFilter(flagEncoder, false, true);
+    public static DefaultEdgeFilter inEdges(BooleanEncodedValue accessEnc) {
+        return new DefaultEdgeFilter(accessEnc, false, true, DEFAULT_FILTER_ID);
     }
 
     /**
@@ -46,25 +53,67 @@ public static DefaultEdgeFilter inEdges(FlagEncoder flagEncoder) {
      * Edges where neither one of the flags is enabled will still not be accepted. If you need to retrieve all edges
      * regardless of their encoding use {@link EdgeFilter#ALL_EDGES} instead.
      */
+    public static DefaultEdgeFilter allEdges(BooleanEncodedValue accessEnc) {
+        return new DefaultEdgeFilter(accessEnc, true, true, DEFAULT_FILTER_ID);
+    }
+
+    public static DefaultEdgeFilter outEdges(FlagEncoder flagEncoder) {
+        return DefaultEdgeFilter.outEdges(flagEncoder.getAccessEnc());
+    }
+
+    public static DefaultEdgeFilter inEdges(FlagEncoder flagEncoder) {
+        return DefaultEdgeFilter.inEdges(flagEncoder.getAccessEnc());
+    }
+
     public static DefaultEdgeFilter allEdges(FlagEncoder flagEncoder) {
-        return new DefaultEdgeFilter(flagEncoder, true, true);
+        return DefaultEdgeFilter.allEdges(flagEncoder.getAccessEnc());
+    }
+
+    public DefaultEdgeFilter setFilterId(int filterId) {
+        this.filterId = filterId;
+        return this;
+    }
+
+    public BooleanEncodedValue getAccessEnc() {
+        return accessEnc;
     }
 
     @Override
     public final boolean accept(EdgeIteratorState iter) {
-        return fwd && iter.isForward(encoder) || bwd && iter.isBackward(encoder);
+        if (iter.getBaseNode() == iter.getAdjNode()) {
+            // this is needed for edge-based CH, see #1525
+            // background: we need to explicitly accept shortcut edges that are loops, because if we insert a loop
+            // shortcut with the fwd flag a DefaultEdgeFilter with bwd=true and fwd=false does not find it, although
+            // it is also an 'incoming' edge.
+            return iter.get(accessEnc) || iter.getReverse(accessEnc);
+        }
+        return fwd && iter.get(accessEnc) || bwd && iter.getReverse(accessEnc);
     }
 
-    public boolean acceptsBackward() {
-        return bwd;
+    @Override
+    public String toString() {
+        return accessEnc.toString() + ", bwd:" + bwd + ", fwd:" + fwd;
     }
 
-    public boolean acceptsForward() {
-        return fwd;
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        DefaultEdgeFilter that = (DefaultEdgeFilter) o;
+
+        if (bwd != that.bwd) return false;
+        if (fwd != that.fwd) return false;
+        if (filterId != that.filterId) return false;
+        return accessEnc.equals(that.accessEnc);
     }
 
     @Override
-    public String toString() {
-        return encoder.toString() + ", bwd:" + bwd + ", fwd:" + fwd;
+    public int hashCode() {
+        int result = (bwd ? 1 : 0);
+        result = 31 * result + (fwd ? 1 : 0);
+        result = 31 * result + accessEnc.hashCode();
+        result = 31 * result + filterId;
+        return result;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
index b64f392f1a..7180a71cfa 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EdgeFilter.java
@@ -21,12 +21,11 @@
 
 /**
  * Class used to traverse a graph.
- * <p>
  *
  * @author Peter Karich
  */
 public interface EdgeFilter {
-    static final EdgeFilter ALL_EDGES = new EdgeFilter() {
+    EdgeFilter ALL_EDGES = new EdgeFilter() {
         @Override
         public final boolean accept(EdgeIteratorState edgeState) {
             return true;
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
deleted file mode 100644
index 95b923b88c..0000000000
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedDoubleValue.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-/**
- * Encapsulates a bit-encoded value.
- * <p>
- *
- * @author Nop
- */
-public class EncodedDoubleValue extends EncodedValue {
-
-    public EncodedDoubleValue(String name, int shift, int bits, double factor, long defaultValue, int maxValue) {
-        this(name, shift, bits, factor, defaultValue, maxValue, true);
-    }
-
-    public EncodedDoubleValue(String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero) {
-        super(name, shift, bits, factor, defaultValue, maxValue, allowZero);
-    }
-
-    @Override
-    public long setValue(long flags, long value) {
-        throw new IllegalStateException("Use setDoubleValue instead");
-    }
-
-    @Override
-    public long getValue(long flags) {
-        throw new IllegalStateException("Use setDoubleValue instead");
-    }
-
-    @Override
-    public long setDefaultValue(long flags) {
-        return setDoubleValue(flags, defaultValue);
-    }
-
-    public long setDoubleValue(long flags, double value) {
-        if (Double.isNaN(value))
-            throw new IllegalArgumentException("Value cannot be NaN");
-
-        // scale value
-        long tmpValue = Math.round(value / factor);
-        checkValue((long) (tmpValue * factor));
-        tmpValue <<= shift;
-
-        // clear value bits
-        flags &= ~mask;
-
-        // set value
-        return flags | tmpValue;
-    }
-
-    public double getDoubleValue(long flags) {
-        // find value
-        flags &= mask;
-        flags >>>= shift;
-        return flags * factor;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java b/core/src/main/java/com/graphhopper/routing/util/EncodedValueOld.java
similarity index 83%
rename from core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
rename to core/src/main/java/com/graphhopper/routing/util/EncodedValueOld.java
index 6d7568cae1..f849854ab4 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodedValue.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodedValueOld.java
@@ -19,11 +19,10 @@
 
 /**
  * Encapsulates a bit-encoded value.
- * <p>
  *
  * @author Nop
  */
-public class EncodedValue {
+public class EncodedValueOld {
     protected final long shift;
     protected final long mask;
     protected final double factor;
@@ -44,11 +43,11 @@
      * @param defaultValue default value
      * @param maxValue     default maximum value
      */
-    public EncodedValue(String name, int shift, int bits, double factor, long defaultValue, int maxValue) {
+    public EncodedValueOld(String name, int shift, int bits, double factor, long defaultValue, int maxValue) {
         this(name, shift, bits, factor, defaultValue, maxValue, true);
     }
 
-    public EncodedValue(String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero) {
+    public EncodedValueOld(String name, int shift, int bits, double factor, long defaultValue, int maxValue, boolean allowZero) {
         this.name = name;
         this.shift = shift;
         this.factor = factor;
@@ -112,20 +111,4 @@ public double getFactor() {
     public long setDefaultValue(long flags) {
         return setValue(flags, defaultValue);
     }
-
-    public long getMaxValue() {
-        return maxValue;
-    }
-
-    /**
-     * Swap the contents controlled by this value encoder with the given value.
-     * <p>
-     *
-     * @return the new flags
-     */
-    public long swap(long flags, EncodedValue otherEncoder) {
-        long otherValue = otherEncoder.getValue(flags);
-        flags = otherEncoder.setValue(flags, getValue(flags));
-        return setValue(flags, otherValue);
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
index 90b64a75c7..e74c203623 100644
--- a/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
+++ b/core/src/main/java/com/graphhopper/routing/util/EncodingManager.java
@@ -20,40 +20,45 @@
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.routing.util.parsers.OSMRoundaboutParser;
+import com.graphhopper.routing.util.parsers.TagParser;
+import com.graphhopper.routing.util.parsers.TagParserFactory;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.storage.StorableProperties;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Locale;
+import java.util.*;
 
 import static com.graphhopper.util.Helper.toLowerCase;
 
 /**
  * Manager class to register encoder, assign their flag values and check objects with all encoders
- * during parsing.
+ * during parsing. Create one via:
  * <p>
+ * EncodingManager.start(4).add(new CarFlagEncoder()).build();
  *
  * @author Peter Karich
  * @author Nop
  */
-public class EncodingManager {
+public class EncodingManager implements EncodedValueLookup {
     private static final String ERR = "Encoders are requesting %s bits, more than %s bits of %s flags. ";
-    private static final String WAY_ERR = "Decrease the number of vehicles or increase the flags to take long via graph.bytes_for_flags: 8";
     private final List<AbstractFlagEncoder> edgeEncoders = new ArrayList<>();
+    private final Map<String, EncodedValue> encodedValueMap = new LinkedHashMap<>();
+    private final List<TagParser> tagParserList = new ArrayList<>();
     private final int bitsForEdgeFlags;
     private final int bitsForTurnFlags = 8 * 4;
-    private int nextWayBit = 0;
     private int nextNodeBit = 0;
     private int nextRelBit = 0;
     private int nextTurnBit = 0;
     private boolean enableInstructions = true;
     private String preferredLanguage = "";
+    private EncodedValue.InitializerConfig config;
 
     /**
      * Instantiate manager with the given list of encoders. The manager knows several default
@@ -62,49 +67,202 @@
      *
      * @param flagEncodersStr comma delimited list of encoders. The order does not matter.
      */
-    public EncodingManager(String flagEncodersStr) {
-        this(flagEncodersStr, 4);
+    public static EncodingManager create(String flagEncodersStr) {
+        return create(flagEncodersStr, 4);
     }
 
-    public EncodingManager(String flagEncodersStr, int bytesForEdgeFlags) {
-        this(FlagEncoderFactory.DEFAULT, flagEncodersStr, bytesForEdgeFlags);
+    public static EncodingManager create(String flagEncodersStr, int bytesForEdgeFlags) {
+        return create(new DefaultFlagEncoderFactory(), flagEncodersStr, bytesForEdgeFlags);
     }
 
-    public EncodingManager(FlagEncoderFactory factory, String flagEncodersStr, int bytesForEdgeFlags) {
-        this(parseEncoderString(factory, flagEncodersStr), bytesForEdgeFlags);
+    public static EncodingManager create(FlagEncoderFactory factory, String flagEncodersStr, int bytesForEdgeFlags) {
+        return createBuilder(factory, flagEncodersStr, bytesForEdgeFlags).build();
+    }
+
+    public static EncodingManager.Builder createBuilder(FlagEncoderFactory factory, String flagEncodersStr, int bytesForEdgeFlags) {
+        return createBuilder(parseEncoderString(factory, flagEncodersStr), bytesForEdgeFlags);
     }
 
     /**
      * Instantiate manager with the given list of encoders.
-     * <p>
      *
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
      */
-    public EncodingManager(FlagEncoder... flagEncoders) {
-        this(Arrays.asList(flagEncoders));
+    public static EncodingManager create(FlagEncoder... flagEncoders) {
+        return create(Arrays.asList(flagEncoders));
     }
 
     /**
      * Instantiate manager with the given list of encoders.
-     * <p>
      *
      * @param flagEncoders comma delimited list of encoders. The order does not matter.
      */
-    public EncodingManager(List<? extends FlagEncoder> flagEncoders) {
-        this(flagEncoders, 4);
+    public static EncodingManager create(List<? extends FlagEncoder> flagEncoders) {
+        return create(flagEncoders, 4);
     }
 
-    public EncodingManager(List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags) {
-        if (bytesForEdgeFlags != 4 && bytesForEdgeFlags != 8)
-            throw new IllegalStateException("For 'edge flags' currently only 4 or 8 bytes supported");
+    public static EncodingManager create(List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags) {
+        return createBuilder(flagEncoders, bytesForEdgeFlags).build();
+    }
 
-        this.bitsForEdgeFlags = bytesForEdgeFlags * 8;
+    private static EncodingManager.Builder createBuilder(List<? extends FlagEncoder> flagEncoders, int bytesForEdgeFlags) {
+        Builder builder = new Builder(bytesForEdgeFlags);
         for (FlagEncoder flagEncoder : flagEncoders) {
-            registerEncoder((AbstractFlagEncoder) flagEncoder);
+            builder.add(flagEncoder);
+        }
+        return builder;
+    }
+
+    /**
+     * Create the EncodingManager from the provided GraphHopper location. Throws an
+     * IllegalStateException if it fails. Used if no EncodingManager specified on load.
+     */
+    public static EncodingManager create(EncodedValueFactory evFactory, FlagEncoderFactory flagEncoderFactory, String ghLoc) {
+        Directory dir = new RAMDirectory(ghLoc, true);
+        StorableProperties properties = new StorableProperties(dir);
+        if (!properties.loadExisting())
+            throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
+                    + dir.getLocation());
+
+        int bytesForFlags = 4;
+        try {
+            bytesForFlags = Integer.parseInt(properties.get("graph.bytes_for_flags"));
+        } catch (NumberFormatException ex) {
+        }
+
+        EncodingManager.Builder builder = new EncodingManager.Builder(bytesForFlags, false);
+        String encodedValuesStr = properties.get("graph.encoded_values");
+        if (!Helper.isEmpty(encodedValuesStr))
+            builder.addAll(evFactory, encodedValuesStr);
+        String flagEncoderValuesStr = properties.get("graph.flag_encoders");
+        if (!Helper.isEmpty(flagEncoderValuesStr))
+            builder.addAll(flagEncoderFactory, flagEncoderValuesStr);
+
+        if (Helper.isEmpty(flagEncoderValuesStr) && Helper.isEmpty(encodedValuesStr))
+            throw new IllegalStateException("EncodingManager was not configured. And no one was found in the graph: "
+                    + dir.getLocation());
+
+        return builder.build();
+    }
+
+    /**
+     * Starts the build process of an EncodingManager
+     */
+    public static Builder start() {
+        return new Builder(4);
+    }
+
+    private EncodingManager(int bytes) {
+        if (bytes <= 0 || (bytes / 4) * 4 != bytes)
+            throw new IllegalStateException("bytesForEdgeFlags can be only a multiple of 4");
+
+        this.bitsForEdgeFlags = bytes * 8;
+        this.config = new EncodedValue.InitializerConfig();
+    }
+
+    public static class Builder {
+        private EncodingManager em;
+
+        public Builder(int bytes) {
+            this(bytes, true);
+        }
+
+        private Builder(int bytes, boolean addRoundabout) {
+            em = new EncodingManager(bytes);
+            if (addRoundabout)
+                add(new OSMRoundaboutParser());
+        }
+
+        /**
+         * This method specifies the preferred language for way names during import.
+         * <p>
+         * Language code as defined in ISO 639-1 or ISO 639-2.
+         * <ul>
+         * <li>If no preferred language is specified, only the default language with no tag will be
+         * imported.</li>
+         * <li>If a language is specified, it will be imported if its tag is found, otherwise fall back
+         * to default language.</li>
+         * </ul>
+         */
+        public Builder setPreferredLanguage(String language) {
+            check();
+            em.setPreferredLanguage(language);
+            return this;
+        }
+
+        /**
+         * This method specifies if the import should include way names to be able to return
+         * instructions for a route.
+         */
+        public Builder setEnableInstructions(boolean enable) {
+            check();
+            em.setEnableInstructions(enable);
+            return this;
+        }
+
+        /**
+         * For backward compatibility provide a way to add multiple FlagEncoders
+         */
+        public Builder addAll(FlagEncoderFactory factory, String flagEncodersStr) {
+            for (FlagEncoder fe : parseEncoderString(factory, flagEncodersStr)) {
+                add(fe);
+            }
+            return this;
+        }
+
+        public Builder addAll(EncodedValueFactory factory, String encodedValueString) {
+            em.add(this, factory, encodedValueString);
+            return this;
+        }
+
+        public Builder addAll(TagParserFactory factory, String tagParserString) {
+            em.add(this, factory, tagParserString);
+            return this;
+        }
+
+        public Builder add(FlagEncoder encoder) {
+            check();
+            em.addEncoder((AbstractFlagEncoder) encoder);
+            return this;
         }
 
-        if (edgeEncoders.isEmpty())
-            throw new IllegalStateException("No vehicles found");
+        public Builder add(EncodedValue encodedValue) {
+            check();
+            if (!em.edgeEncoders.isEmpty())
+                throw new IllegalArgumentException("Always add shared EncodedValues before FlagEncoders to ensure they can be loaded first");
+
+            em.addEncodedValue(encodedValue, false);
+            return this;
+        }
+
+        /**
+         * This method adds the specified TagParser and automatically adds EncodedValues as requested in
+         * createEncodedValues.
+         */
+        public Builder add(TagParser tagParser) {
+            List<EncodedValue> list = new ArrayList<>();
+            tagParser.createEncodedValues(em, list);
+            for (EncodedValue ev : list) {
+                em.addEncodedValue(ev, false);
+            }
+            em.tagParserList.add(tagParser);
+            return this;
+        }
+
+        private void check() {
+            if (em == null)
+                throw new IllegalStateException("Cannot call method after Builder.build() was called");
+        }
+
+        public EncodingManager build() {
+            check();
+            if (em.encodedValueMap.isEmpty())
+                throw new IllegalStateException("No EncodedValues found");
+
+            EncodingManager tmp = em;
+            em = null;
+            return tmp;
+        }
     }
 
     static List<FlagEncoder> parseEncoderString(FlagEncoderFactory factory, String encoderList) {
@@ -128,16 +286,41 @@ public EncodingManager(List<? extends FlagEncoder> flagEncoders, int bytesForEdg
                 entry = entry.split("\\|")[0];
             }
             PMap configuration = new PMap(entryVal);
+            resultEncoders.add(factory.createFlagEncoder(entry, configuration));
+        }
+        return resultEncoders;
+    }
 
-            FlagEncoder fe = factory.createFlagEncoder(entry, configuration);
+    private void add(Builder builder, EncodedValueFactory factory, String evList) {
+        if (!evList.equals(toLowerCase(evList)))
+            throw new IllegalArgumentException("Use lower case for EncodedValues: " + evList);
 
-            if (configuration.has("version") && fe.getVersion() != configuration.getInt("version", -1))
-                throw new IllegalArgumentException("Encoder " + entry + " was used in version "
-                        + configuration.getLong("version", -1) + ", but current version is " + fe.getVersion());
+        for (String entry : evList.split(",")) {
+            entry = toLowerCase(entry.trim());
+            if (entry.isEmpty())
+                continue;
 
-            resultEncoders.add(fe);
+            EncodedValue evObject = factory.create(entry);
+            builder.add(evObject);
+            PMap map = new PMap(entry);
+            if (!map.has("version"))
+                throw new IllegalArgumentException("encoded value must have a version specified but it was " + entry);
+        }
+    }
+
+    private void add(Builder builder, TagParserFactory factory, String tpList) {
+        if (!tpList.equals(toLowerCase(tpList)))
+            throw new IllegalArgumentException("Use lower case for TagParser: " + tpList);
+
+        for (String entry : tpList.split(",")) {
+            entry = entry.trim();
+            if (entry.isEmpty())
+                continue;
+
+            PMap map = new PMap(entry);
+            TagParser tp = factory.create(entry, map);
+            builder.add(tp);
         }
-        return resultEncoders;
     }
 
     static String fixWayName(String str) {
@@ -146,36 +329,30 @@ static String fixWayName(String str) {
         return str.replaceAll(";[ ]*", ", ");
     }
 
-    /**
-     * Create the EncodingManager from the provided GraphHopper location. Throws an
-     * IllegalStateException if it fails. Used if no EncodingManager specified on load.
-     */
-    public static EncodingManager create(FlagEncoderFactory factory, String ghLoc) {
-        Directory dir = new RAMDirectory(ghLoc, true);
-        StorableProperties properties = new StorableProperties(dir);
-        if (!properties.loadExisting())
-            throw new IllegalStateException("Cannot load properties to fetch EncodingManager configuration at: "
-                    + dir.getLocation());
+    public int getBytesForFlags() {
+        return bitsForEdgeFlags / 8;
+    }
 
-        // check encoding for compatibility
-        properties.checkVersions(false);
-        String acceptStr = properties.get("graph.flag_encoders");
+    private void setEnableInstructions(boolean enableInstructions) {
+        this.enableInstructions = enableInstructions;
+    }
 
-        if (acceptStr.isEmpty())
-            throw new IllegalStateException("EncodingManager was not configured. And no one was found in the graph: "
-                    + dir.getLocation());
+    public boolean isEnableInstructions() {
+        return enableInstructions;
+    }
 
-        int bytesForFlags = 4;
-        if ("8".equals(properties.get("graph.bytes_for_flags")))
-            bytesForFlags = 8;
-        return new EncodingManager(factory, acceptStr, bytesForFlags);
+    private void setPreferredLanguage(String preferredLanguage) {
+        if (preferredLanguage == null)
+            throw new IllegalArgumentException("preferred language cannot be null");
+
+        this.preferredLanguage = preferredLanguage;
     }
 
-    public int getBytesForFlags() {
-        return bitsForEdgeFlags / 8;
+    public String getPreferredLanguage() {
+        return preferredLanguage;
     }
 
-    private void registerEncoder(AbstractFlagEncoder encoder) {
+    private void addEncoder(AbstractFlagEncoder encoder) {
         if (encoder.isRegistered())
             throw new IllegalStateException("You must not register a FlagEncoder (" + encoder.toString() + ") twice!");
 
@@ -193,11 +370,12 @@ private void registerEncoder(AbstractFlagEncoder encoder) {
         encoder.setNodeBitMask(usedBits - nextNodeBit, nextNodeBit);
         nextNodeBit = usedBits;
 
-        usedBits = encoder.defineWayBits(encoderCount, nextWayBit);
-        if (usedBits > bitsForEdgeFlags)
-            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR, usedBits, bitsForEdgeFlags, "way") + WAY_ERR);
-        encoder.setWayBitMask(usedBits - nextWayBit, nextWayBit);
-        nextWayBit = usedBits;
+        encoder.setEncodedValueLookup(this);
+        List<EncodedValue> list = new ArrayList<>();
+        encoder.createEncodedValues(list, encoder.toString(), encoderCount);
+        for (EncodedValue ev : list) {
+            addEncodedValue(ev, true);
+        }
 
         usedBits = encoder.defineRelationBits(encoderCount, nextRelBit);
         if (usedBits > bitsForEdgeFlags)
@@ -214,10 +392,29 @@ private void registerEncoder(AbstractFlagEncoder encoder) {
         edgeEncoders.add(encoder);
     }
 
+    private void addEncodedValue(EncodedValue ev, boolean encValBoundToFlagEncoder) {
+        if (encodedValueMap.containsKey(ev.getName()))
+            throw new IllegalStateException("EncodedValue " + ev.getName() + " already exists " + encodedValueMap.get(ev.getName()) + " vs " + ev);
+        if (!encValBoundToFlagEncoder && ev.getName().contains(SPECIAL_SEPARATOR))
+            throw new IllegalArgumentException("EncodedValue " + ev.getName() + " must not contain '" + SPECIAL_SEPARATOR + "' as reserved for FlagEncoder");
+
+        ev.init(config);
+        if (config.getRequiredBits() > getBytesForFlags() * 8)
+            throw new IllegalArgumentException(String.format(Locale.ROOT, ERR + "(Attempt to add EncodedValue " + ev.getName() + ") ",
+                    config.getRequiredBits(), bitsForEdgeFlags, "edge") +
+                    "Decrease the number of vehicles or increase the flags to more bytes via graph.bytes_for_flags: " + (config.getRequiredBits() / 32 * 4 + 4));
+
+        encodedValueMap.put(ev.getName(), ev);
+    }
+
+    public boolean hasEncodedValue(String key) {
+        return encodedValueMap.get(key) != null;
+    }
+
     /**
      * @return true if the specified encoder is found
      */
-    public boolean supports(String encoder) {
+    public boolean hasEncoder(String encoder) {
         return getEncoder(encoder, false) != null;
     }
 
@@ -231,26 +428,92 @@ private FlagEncoder getEncoder(String name, boolean throwExc) {
                 return encoder;
         }
         if (throwExc)
-            throw new IllegalArgumentException("Encoder for " + name + " not found. Existing: " + toDetailsString());
+            throw new IllegalArgumentException("Encoder for " + name + " not found. Existing: " + toFlagEncodersAsString());
         return null;
     }
 
     /**
      * Determine whether a way is routable for one of the added encoders.
+     *
+     * @return if at least one encoder consumes the specified way. Additionally the specified acceptWay is changed
+     * to provide more details.
      */
-    public long acceptWay(ReaderWay way) {
-        long includeWay = 0;
+    public boolean acceptWay(ReaderWay way, AcceptWay acceptWay) {
+        if (!acceptWay.isEmpty())
+            throw new IllegalArgumentException("AcceptWay must be empty");
+
         for (AbstractFlagEncoder encoder : edgeEncoders) {
-            includeWay |= encoder.acceptWay(way);
+            acceptWay.put(encoder.toString(), encoder.getAccess(way));
+        }
+        return acceptWay.hasAccepted();
+    }
+
+    public static class AcceptWay {
+        private Map<String, Access> accessMap;
+        boolean hasAccepted = false;
+
+        public AcceptWay() {
+            this.accessMap = new HashMap<>(5);
+        }
+
+        private Access get(String key) {
+            Access res = accessMap.get(key);
+            if (res == null)
+                throw new IllegalArgumentException("Couldn't fetch Access value for encoder key " + key);
+
+            return res;
+        }
+
+        public AcceptWay put(String key, Access access) {
+            accessMap.put(key, access);
+            if (access != Access.CAN_SKIP)
+                hasAccepted = true;
+            return this;
+        }
+
+        public boolean isEmpty() {
+            return accessMap.isEmpty();
+        }
+
+        public boolean hasAccepted() {
+            return hasAccepted;
+        }
+
+        private boolean has(String key) {
+            return accessMap.containsKey(key);
+        }
+
+        public Access getAccess() {
+            if (accessMap.isEmpty())
+                throw new IllegalStateException("Cannot determine Access if map is empty");
+            return accessMap.values().iterator().next();
+        }
+    }
+
+    public enum Access {
+        WAY, FERRY, OTHER, CAN_SKIP;
+
+        public boolean isFerry() {
+            return this.ordinal() == FERRY.ordinal();
         }
 
-        return includeWay;
+        public boolean isWay() {
+            return this.ordinal() == WAY.ordinal();
+        }
+
+        public boolean isOther() {
+            return this.ordinal() == OTHER.ordinal();
+        }
+
+        public boolean canSkip() {
+            return this.ordinal() == CAN_SKIP.ordinal();
+        }
     }
 
-    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
+    public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
         long flags = 0;
         for (AbstractFlagEncoder encoder : edgeEncoders) {
-            flags |= encoder.handleRelationTags(relation, oldRelationFlags);
+            flags |= encoder.handleRelationTags(oldRelationFlags, relation);
         }
 
         return flags;
@@ -259,18 +522,20 @@ public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
     /**
      * Processes way properties of different kind to determine speed and direction. Properties are
      * directly encoded in 8 bytes.
-     * <p>
      *
      * @param relationFlags The preprocessed relation flags is used to influence the way properties.
-     * @return the encoded flags
      */
-    public long handleWayTags(ReaderWay way, long includeWay, long relationFlags) {
-        long flags = 0;
+    public IntsRef handleWayTags(ReaderWay way, AcceptWay acceptWay, long relationFlags) {
+        IntsRef edgeFlags = createEdgeFlags();
+        // return if way or ferry
+        Access access = acceptWay.getAccess();
+        for (TagParser parser : tagParserList) {
+            parser.handleWayTags(edgeFlags, way, access, relationFlags);
+        }
         for (AbstractFlagEncoder encoder : edgeEncoders) {
-            flags |= encoder.handleWayTags(way, includeWay, relationFlags & encoder.getRelBitMask());
+            encoder.handleWayTags(edgeFlags, way, acceptWay.get(encoder.toString()), relationFlags & encoder.getRelBitMask());
         }
-
-        return flags;
+        return edgeFlags;
     }
 
     @Override
@@ -286,7 +551,7 @@ public String toString() {
         return str.toString();
     }
 
-    public String toDetailsString() {
+    public String toFlagEncodersAsString() {
         StringBuilder str = new StringBuilder();
         for (AbstractFlagEncoder encoder : edgeEncoders) {
             if (str.length() > 0)
@@ -302,47 +567,49 @@ public String toDetailsString() {
         return str.toString();
     }
 
-    public long flagsDefault(boolean forward, boolean backward) {
-        long flags = 0;
-        for (AbstractFlagEncoder encoder : edgeEncoders) {
-            flags |= encoder.flagsDefault(forward, backward);
+    public String toEncodedValuesAsString() {
+        StringBuilder str = new StringBuilder();
+        for (EncodedValue ev : encodedValueMap.values()) {
+            if (ev.getName().contains(SPECIAL_SEPARATOR))
+                continue;
+
+            if (str.length() > 0)
+                str.append(",");
+
+            str.append(ev.toString());
         }
-        return flags;
+
+        return str.toString();
     }
 
-    /**
-     * Reverse flags, to do so all encoders are called.
-     */
-    public long reverseFlags(long flags) {
-        // performance critical
-        int len = edgeEncoders.size();
-        for (int i = 0; i < len; i++) {
-            flags = edgeEncoders.get(i).reverseFlags(flags);
+    // TODO hide IntsRef even more in a later version: https://gist.github.com/karussell/f4c2b2b1191be978d7ee9ec8dd2cd48f
+    public IntsRef createEdgeFlags() {
+        return new IntsRef(bitsForEdgeFlags / 32);
+    }
+
+    public IntsRef flagsDefault(boolean forward, boolean backward) {
+        IntsRef intsRef = createEdgeFlags();
+        for (AbstractFlagEncoder encoder : edgeEncoders) {
+            encoder.flagsDefault(intsRef, forward, backward);
         }
-        return flags;
+        return intsRef;
     }
 
     @Override
-    public int hashCode() {
-        int hash = 5;
-        hash = 53 * hash + (this.edgeEncoders != null ? this.edgeEncoders.hashCode() : 0);
-        return hash;
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        EncodingManager that = (EncodingManager) o;
+        return bitsForEdgeFlags == that.bitsForEdgeFlags &&
+                enableInstructions == that.enableInstructions &&
+                edgeEncoders.equals(that.edgeEncoders) &&
+                encodedValueMap.equals(that.encodedValueMap) &&
+                preferredLanguage.equals(that.preferredLanguage);
     }
 
     @Override
-    public boolean equals(Object obj) {
-        if (obj == null)
-            return false;
-
-        if (getClass() != obj.getClass())
-            return false;
-
-        final EncodingManager other = (EncodingManager) obj;
-        if (this.edgeEncoders != other.edgeEncoders
-                && (this.edgeEncoders == null || !this.edgeEncoders.equals(other.edgeEncoders))) {
-            return false;
-        }
-        return true;
+    public int hashCode() {
+        return Objects.hash(edgeEncoders, encodedValueMap, bitsForEdgeFlags, enableInstructions, preferredLanguage);
     }
 
     /**
@@ -357,19 +624,6 @@ public long handleNodeTags(ReaderNode node) {
         return flags;
     }
 
-    public EncodingManager setEnableInstructions(boolean enableInstructions) {
-        this.enableInstructions = enableInstructions;
-        return this;
-    }
-
-    public EncodingManager setPreferredLanguage(String preferredLanguage) {
-        if (preferredLanguage == null)
-            throw new IllegalArgumentException("preferred language cannot be null");
-
-        this.preferredLanguage = preferredLanguage;
-        return this;
-    }
-
     public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
         // storing the road name does not yet depend on the flagEncoder so manage it directly
         if (enableInstructions) {
@@ -397,13 +651,8 @@ public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
         }
     }
 
-    /**
-     * The returned list is never empty.
-     */
     public List<FlagEncoder> fetchEdgeEncoders() {
-        List<FlagEncoder> list = new ArrayList<>();
-        list.addAll(edgeEncoders);
-        return list;
+        return new ArrayList<FlagEncoder>(edgeEncoders);
     }
 
     public boolean needsTurnCostsSupport() {
@@ -413,4 +662,59 @@ public boolean needsTurnCostsSupport() {
         }
         return false;
     }
-}
+
+    public List<BooleanEncodedValue> getAccessEncFromNodeFlags(long importNodeFlags) {
+        List<BooleanEncodedValue> list = new ArrayList<>(edgeEncoders.size());
+        for (int i = 0; i < edgeEncoders.size(); i++) {
+            FlagEncoder encoder = edgeEncoders.get(i);
+            if (((1L << i) & importNodeFlags) != 0)
+                list.add(encoder.getAccessEnc());
+        }
+        return list;
+    }
+
+
+    @Override
+    public BooleanEncodedValue getBooleanEncodedValue(String key) {
+        return getEncodedValue(key, BooleanEncodedValue.class);
+    }
+
+    @Override
+    public IntEncodedValue getIntEncodedValue(String key) {
+        return getEncodedValue(key, IntEncodedValue.class);
+    }
+
+    @Override
+    public DecimalEncodedValue getDecimalEncodedValue(String key) {
+        return getEncodedValue(key, DecimalEncodedValue.class);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T extends Enum> EnumEncodedValue<T> getEnumEncodedValue(String key, Class<T> type) {
+        return (EnumEncodedValue<T>) getEncodedValue(key, EnumEncodedValue.class);
+    }
+
+    @Override
+    public <T extends EncodedValue> T getEncodedValue(String key, Class<T> encodedValueType) {
+        EncodedValue ev = encodedValueMap.get(key);
+        if (ev == null)
+            throw new IllegalArgumentException("Cannot find EncodedValue " + key + " in collection: " + ev);
+        return (T) ev;
+    }
+
+    private static String SPECIAL_SEPARATOR = "-";
+
+    /**
+     * All EncodedValue names that are created from a FlagEncoder should use this method to mark them as
+     * "none-shared" across the other FlagEncoders. E.g. average_speed for the CarFlagEncoder will
+     * be named car-average_speed
+     */
+    public static String getKey(FlagEncoder encoder, String str) {
+        return getKey(encoder.toString(), str);
+    }
+
+    public static String getKey(String prefix, String str) {
+        return prefix + SPECIAL_SEPARATOR + str;
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
index 0854b45e39..3b56c8f19b 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoder.java
@@ -17,21 +17,20 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.Translation;
 
 /**
  * This class provides methods to define how a value (like speed or direction) converts to a flag
- * (currently an integer value), which is stored in an edge .
- * <p>
+ * (currently an integer value), which is stored in an edge.
  *
  * @author Peter Karich
  */
-public interface FlagEncoder extends TurnCostEncoder {
-    /**
-     * Reports whether this edge is part of a roundabout.
-     */
-    static final int K_ROUNDABOUT = 2;
+public interface FlagEncoder extends TurnCostEncoder, EncodedValueLookup {
 
     /**
      * @return the version of this FlagEncoder to enforce none-compatibility when new attributes are
@@ -45,94 +44,25 @@
     double getMaxSpeed();
 
     /**
-     * @return the speed in km/h for this direction, for backward direction use getReverseSpeed
-     */
-    double getSpeed(long flags);
-
-    /**
-     * Sets the speed in km/h.
-     * <p>
-     *
-     * @return modified setProperties
-     */
-    long setSpeed(long flags, double speed);
-
-    /**
-     * @return the speed of the reverse direction in km/h
-     */
-    double getReverseSpeed(long flags);
-
-    /**
-     * Sets the reverse speed in the flags.
-     */
-    long setReverseSpeed(long flags, double speed);
-
-    /**
-     * Sets the access of the edge.
-     * <p>
-     *
-     * @return modified flags
-     */
-    long setAccess(long flags, boolean forward, boolean backward);
-
-    /**
-     * Sets speed and access properties.
-     * <p>
-     *
-     * @return created flags
+     * This method returns the EncodedValue used for the direction-dependent access properties of this encoder.
      */
-    long setProperties(double speed, boolean forward, boolean backward);
+    BooleanEncodedValue getAccessEnc();
 
     /**
-     * Reports whether the edge is available in forward direction (i.e. from base node to adj node)
-     * for a certain vehicle.
+     * This method returns the EncodedValue used for the average speed of this encoder.
      */
-    boolean isForward(long flags);
-
-    /*
-     * Simple rules for every subclass which introduces a new key. It has to use the prefix K_ and
-     * uses a minimum value which is two magnitudes higher than in the super class. 
-     * Currently this means starting from 100, and subclasses of this class start from 10000 and so on.
-     */
-
-    /**
-     * Reports whether the edge is available in backward direction (i.e. from adj node to base node)
-     * for a certain vehicle.
-     */
-    boolean isBackward(long flags);
-
-    /**
-     * Returns arbitrary boolean value identified by the specified key.
-     */
-    boolean isBool(long flags, int key);
-
-    long setBool(long flags, int key, boolean value);
-
-    /**
-     * Returns arbitrary long value identified by the specified key. E.g. can be used to return the
-     * way or surface type of an edge
-     */
-    long getLong(long flags, int key);
-
-    long setLong(long flags, int key, long value);
-
-    /**
-     * Returns arbitrary double value identified by the specified key. E.g. can be used to return
-     * the maximum width or height allowed for an edge.
-     */
-    double getDouble(long flags, int key);
-
-    long setDouble(long flags, int key, double value);
+    DecimalEncodedValue getAverageSpeedEnc();
 
     /**
      * Returns true if the feature class is supported like TurnWeighting or PriorityWeighting.
+     * Use support(String) instead.
      */
     boolean supports(Class<?> feature);
 
     /**
      * @return additional cost or warning information for an instruction like ferry or road charges.
      */
-    InstructionAnnotation getAnnotation(long flags, Translation tr);
+    InstructionAnnotation getAnnotation(IntsRef intsRef, Translation tr);
 
     /**
      * @return true if already registered in an EncodingManager
diff --git a/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java b/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
index 71eb01bca9..a878a7e341 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FlagEncoderFactory.java
@@ -23,17 +23,16 @@
  * @author Peter Karich
  */
 public interface FlagEncoderFactory {
-    final String CAR = "car";
-    final String CAR4WD = "car4wd";
-    final String BIKE = "bike";
-    final String BIKE2 = "bike2";
-    final String RACINGBIKE = "racingbike";
-    final String MOUNTAINBIKE = "mtb";
-    final String FOOT = "foot";
-    final String HIKE = "hike";
-    final String MOTORCYCLE = "motorcycle";
-    final String GENERIC = "generic";
-    final FlagEncoderFactory DEFAULT = new DefaultFlagEncoderFactory();
+    String CAR = "car";
+    String CAR4WD = "car4wd";
+    String BIKE = "bike";
+    String BIKE2 = "bike2";
+    String RACINGBIKE = "racingbike";
+    String MOUNTAINBIKE = "mtb";
+    String FOOT = "foot";
+    String HIKE = "hike";
+    String MOTORCYCLE = "motorcycle";
+    String GENERIC = "generic";
 
     FlagEncoder createFlagEncoder(String name, PMap configuration);
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
index a6162ea6c2..7252242861 100644
--- a/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/FootFlagEncoder.java
@@ -19,11 +19,16 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.UnsignedDecimalEncodedValue;
 import com.graphhopper.routing.weighting.PriorityWeighting;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.PMap;
 
 import java.util.*;
 
+import static com.graphhopper.routing.util.EncodingManager.getKey;
 import static com.graphhopper.routing.util.PriorityCode.*;
 
 /**
@@ -47,8 +52,8 @@
     final Map<String, Integer> hikingNetworkToCode = new HashMap<>();
     protected HashSet<String> sidewalkValues = new HashSet<>(5);
     protected HashSet<String> sidewalksNoValues = new HashSet<>(5);
-    private EncodedValue priorityWayEncoder;
-    private EncodedValue relationCodeEncoder;
+    private DecimalEncodedValue priorityWayEncoder;
+    private EncodedValueOld relationCodeEncoder;
 
     /**
      * Should be only instantiated via EncodingManager
@@ -93,7 +98,9 @@ public FootFlagEncoder(int speedBits, double speedFactor) {
         sidewalkValues.add("right");
 
         setBlockByDefault(false);
+        absoluteBarriers.add("fence");
         potentialBarriers.add("gate");
+        potentialBarriers.add("cattle_grid");
 
         safeHighwayTags.add("footway");
         safeHighwayTags.add("path");
@@ -103,6 +110,7 @@ public FootFlagEncoder(int speedBits, double speedFactor) {
         safeHighwayTags.add("track");
         safeHighwayTags.add("residential");
         safeHighwayTags.add("service");
+        safeHighwayTags.add("platform");
 
         avoidHighwayTags.add("trunk");
         avoidHighwayTags.add("trunk_link");
@@ -129,31 +137,27 @@ public FootFlagEncoder(int speedBits, double speedFactor) {
         hikingNetworkToCode.put("lwn", UNCHANGED.getValue());
 
         maxPossibleSpeed = FERRY_SPEED;
-
+        speedDefault = MEAN_SPEED;
         init();
     }
 
     @Override
     public int getVersion() {
-        return 4;
+        return 5;
     }
 
     @Override
-    public int defineWayBits(int index, int shift) {
+    public void createEncodedValues(List<EncodedValue> registerNewEncodedValue, String prefix, int index) {
         // first two bits are reserved for route handling in superclass
-        shift = super.defineWayBits(index, shift);
+        super.createEncodedValues(registerNewEncodedValue, prefix, index);
         // larger value required - ferries are faster than pedestrians
-        speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, MEAN_SPEED, maxPossibleSpeed);
-        shift += speedEncoder.getBits();
-
-        priorityWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 0, 7);
-        shift += priorityWayEncoder.getBits();
-        return shift;
+        registerNewEncodedValue.add(speedEncoder = new UnsignedDecimalEncodedValue(getKey(prefix, "average_speed"), speedBits, speedFactor, false));
+        registerNewEncodedValue.add(priorityWayEncoder = new UnsignedDecimalEncodedValue(getKey(prefix, "priority"), 3, PriorityCode.getFactor(1), false));
     }
 
     @Override
     public int defineRelationBits(int index, int shift) {
-        relationCodeEncoder = new EncodedValue("RelationCode", shift, 3, 1, 0, 7);
+        relationCodeEncoder = new EncodedValueOld("RelationCode", shift, 3, 1, 0, 7);
         return shift + relationCodeEncoder.getBits();
     }
 
@@ -172,7 +176,7 @@ public int defineTurnBits(int index, int shift) {
      * @return <code>false</code>
      */
     @Override
-    public boolean isTurnRestricted(long flag) {
+    public boolean isTurnRestricted(long flags) {
         return false;
     }
 
@@ -194,34 +198,33 @@ public long getTurnFlags(boolean restricted, double costs) {
 
     /**
      * Some ways are okay but not separate for pedestrians.
-     * <p>
      */
     @Override
-    public long acceptWay(ReaderWay way) {
+    public EncodingManager.Access getAccess(ReaderWay way) {
         String highwayValue = way.getTag("highway");
         if (highwayValue == null) {
-            long acceptPotentially = 0;
+            EncodingManager.Access acceptPotentially = EncodingManager.Access.CAN_SKIP;
 
             if (way.hasTag("route", ferries)) {
                 String footTag = way.getTag("foot");
-                if (footTag == null || "yes".equals(footTag))
-                    acceptPotentially = acceptBit | ferryBit;
+                if (footTag == null || intendedValues.contains(footTag))
+                    acceptPotentially = EncodingManager.Access.FERRY;
             }
 
             // special case not for all acceptedRailways, only platform
             if (way.hasTag("railway", "platform"))
-                acceptPotentially = acceptBit;
+                acceptPotentially = EncodingManager.Access.WAY;
 
             if (way.hasTag("man_made", "pier"))
-                acceptPotentially = acceptBit;
+                acceptPotentially = EncodingManager.Access.WAY;
 
-            if (acceptPotentially != 0) {
+            if (!acceptPotentially.canSkip()) {
                 if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-                    return 0;
+                    return EncodingManager.Access.CAN_SKIP;
                 return acceptPotentially;
             }
 
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         }
 
         String sacScale = way.getTag("sac_scale");
@@ -229,38 +232,38 @@ public long acceptWay(ReaderWay way) {
             if (!"hiking".equals(sacScale) && !"mountain_hiking".equals(sacScale)
                     && !"demanding_mountain_hiking".equals(sacScale) && !"alpine_hiking".equals(sacScale))
                 // other scales are too dangerous, see http://wiki.openstreetmap.org/wiki/Key:sac_scale
-                return 0;
+                return EncodingManager.Access.CAN_SKIP;
         }
 
         // no need to evaluate ferries or fords - already included here
         if (way.hasTag("foot", intendedValues))
-            return acceptBit;
+            return EncodingManager.Access.WAY;
 
         // check access restrictions
         if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (way.hasTag("sidewalk", sidewalkValues))
-            return acceptBit;
+            return EncodingManager.Access.WAY;
 
         if (!allowedHighwayTags.contains(highwayValue))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (way.hasTag("motorroad", "yes"))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         // do not get our feet wet, "yes" is already included above
         if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
-        return acceptBit;
+        return EncodingManager.Access.WAY;
     }
 
     @Override
-    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
+    public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
         int code = 0;
         if (relation.hasTag("route", "hiking") || relation.hasTag("route", "foot")) {
             Integer val = hikingNetworkToCode.get(relation.getTag("network"));
@@ -279,49 +282,35 @@ public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
     }
 
     @Override
-    public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
-        if (!isAccept(allowed))
-            return 0;
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        if (access.canSkip())
+            return edgeFlags;
 
-        long flags = 0;
-        if (!isFerry(allowed)) {
+        if (!access.isFerry()) {
             String sacScale = way.getTag("sac_scale");
             if (sacScale != null) {
                 if ("hiking".equals(sacScale))
-                    flags = speedEncoder.setDoubleValue(flags, MEAN_SPEED);
+                    speedEncoder.setDecimal(false, edgeFlags, MEAN_SPEED);
                 else
-                    flags = speedEncoder.setDoubleValue(flags, SLOW_SPEED);
+                    speedEncoder.setDecimal(false, edgeFlags, SLOW_SPEED);
             } else {
-                flags = speedEncoder.setDoubleValue(flags, MEAN_SPEED);
+                speedEncoder.setDecimal(false, edgeFlags, MEAN_SPEED);
             }
-            flags |= directionBitMask;
-
-            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
-            if (isRoundabout)
-                flags = setBool(flags, K_ROUNDABOUT, true);
-
+            accessEnc.setBool(false, edgeFlags, true);
+            accessEnc.setBool(true, edgeFlags, true);
         } else {
             double ferrySpeed = getFerrySpeed(way);
-            flags = setSpeed(flags, ferrySpeed);
-            flags |= directionBitMask;
+            setSpeed(false, edgeFlags, ferrySpeed);
+            accessEnc.setBool(false, edgeFlags, true);
+            accessEnc.setBool(true, edgeFlags, true);
         }
 
         int priorityFromRelation = 0;
         if (relationFlags != 0)
             priorityFromRelation = (int) relationCodeEncoder.getValue(relationFlags);
 
-        flags = priorityWayEncoder.setValue(flags, handlePriority(way, priorityFromRelation));
-        return flags;
-    }
-
-    @Override
-    public double getDouble(long flags, int key) {
-        switch (key) {
-            case PriorityWeighting.KEY:
-                return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
-            default:
-                return super.getDouble(flags, key);
-        }
+        priorityWayEncoder.setDecimal(false, edgeFlags, PriorityCode.getFactor(handlePriority(way, priorityFromRelation)));
+        return edgeFlags;
     }
 
     protected int handlePriority(ReaderWay way, int priorityFromRelation) {
@@ -381,8 +370,8 @@ public String toString() {
      * This method is a current hack, to allow ferries to be actually faster than our current storable maxSpeed.
      */
     @Override
-    public double getSpeed(long flags) {
-        double speed = super.getSpeed(flags);
+    double getSpeed(boolean reverse, IntsRef edgeFlags) {
+        double speed = super.getSpeed(reverse, edgeFlags);
         if (speed == getMaxSpeed()) {
             // We cannot be sure if it was a long or a short trip
             return SHORT_TRIP_FERRY_SPEED;
diff --git a/core/src/main/java/com/graphhopper/routing/util/HikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/HikeFlagEncoder.java
index 6900f8f98d..a53fa77c8c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/HikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/HikeFlagEncoder.java
@@ -66,60 +66,60 @@ public int getVersion() {
     }
 
     @Override
-    public long acceptWay(ReaderWay way) {
+    public EncodingManager.Access getAccess(ReaderWay way) {
         String highwayValue = way.getTag("highway");
         if (highwayValue == null) {
-            long acceptPotentially = 0;
+            EncodingManager.Access acceptPotentially = EncodingManager.Access.CAN_SKIP;
 
             if (way.hasTag("route", ferries)) {
                 String footTag = way.getTag("foot");
                 if (footTag == null || "yes".equals(footTag))
-                    acceptPotentially = acceptBit | ferryBit;
+                    acceptPotentially = EncodingManager.Access.FERRY;
             }
 
             // special case not for all acceptedRailways, only platform
             if (way.hasTag("railway", "platform"))
-                acceptPotentially = acceptBit;
+                acceptPotentially = EncodingManager.Access.WAY;
 
             if (way.hasTag("man_made", "pier"))
-                acceptPotentially = acceptBit;
+                acceptPotentially = EncodingManager.Access.WAY;
 
-            if (acceptPotentially != 0) {
+            if (!acceptPotentially.canSkip()) {
                 if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-                    return 0;
+                    return EncodingManager.Access.CAN_SKIP;
                 return acceptPotentially;
             }
 
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         }
 
         // no need to evaluate ferries or fords - already included here
         if (way.hasTag("foot", intendedValues))
-            return acceptBit;
+            return EncodingManager.Access.WAY;
 
         // check access restrictions
         if (way.hasTag(restrictions, restrictedValues) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         // hiking allows all sac_scale values
         // String sacScale = way.getTag("sac_scale");
         if (way.hasTag("sidewalk", sidewalkValues))
-            return acceptBit;
+            return EncodingManager.Access.WAY;
 
         if (!allowedHighwayTags.contains(highwayValue))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (way.hasTag("motorroad", "yes"))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         // do not get our feet wet, "yes" is already included above
         if (isBlockFords() && (way.hasTag("highway", "ford") || way.hasTag("ford")))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         else
-            return acceptBit;
+            return EncodingManager.Access.WAY;
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
index 5a7680b8f0..d8f8a9463d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MotorcycleFlagEncoder.java
@@ -18,15 +18,19 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.UnsignedDecimalEncodedValue;
 import com.graphhopper.routing.weighting.CurvatureWeighting;
 import com.graphhopper.routing.weighting.PriorityWeighting;
-import com.graphhopper.util.BitUtil;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 
 import java.util.HashSet;
+import java.util.List;
 
-import static com.graphhopper.routing.util.PriorityCode.BEST;
+import static com.graphhopper.routing.util.EncodingManager.getKey;
 
 /**
  * Defines bit layout for motorbikes
@@ -36,20 +40,17 @@
  * @author boldtrn
  */
 public class MotorcycleFlagEncoder extends CarFlagEncoder {
-    public static final int CURVATURE_KEY = 112;
     private final HashSet<String> avoidSet = new HashSet<>();
     private final HashSet<String> preferSet = new HashSet<>();
-    private EncodedDoubleValue reverseSpeedEncoder;
-    private EncodedValue priorityWayEncoder;
-    private EncodedValue curvatureEncoder;
+    private DecimalEncodedValue priorityWayEncoder;
+    private DecimalEncodedValue curvatureEncoder;
 
     public MotorcycleFlagEncoder() {
         this(5, 5, 0);
     }
 
     public MotorcycleFlagEncoder(PMap properties) {
-        this(
-                (int) properties.getLong("speed_bits", 5),
+        this((int) properties.getLong("speed_bits", 5),
                 properties.getDouble("speed_factor", 5),
                 properties.getBool("turn_costs", false) ? 1 : 0
         );
@@ -63,6 +64,7 @@ public MotorcycleFlagEncoder(String propertiesStr) {
 
     public MotorcycleFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts) {
         super(speedBits, speedFactor, maxTurnCosts);
+        speedTwoDirections = true;
         restrictions.remove("motorcar");
         //  moped, mofa
         restrictions.add("motorcycle");
@@ -121,81 +123,72 @@ public MotorcycleFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts
 
     @Override
     public int getVersion() {
-        return 2;
+        return 3;
     }
 
     /**
      * Define the place of the speedBits in the edge flags for car.
      */
     @Override
-    public int defineWayBits(int index, int shift) {
+    public void createEncodedValues(List<EncodedValue> registerNewEncodedValue, String prefix, int index) {
         // first two bits are reserved for route handling in superclass
-        shift = super.defineWayBits(index, shift);
-        reverseSpeedEncoder = new EncodedDoubleValue("Reverse Speed", shift, speedBits, speedFactor,
-                defaultSpeedMap.get("secondary"), maxPossibleSpeed);
-        shift += reverseSpeedEncoder.getBits();
+        super.createEncodedValues(registerNewEncodedValue, prefix, index);
 
-        priorityWayEncoder = new EncodedValue("PreferWay", shift, 3, 1, 3, 7);
-        shift += priorityWayEncoder.getBits();
-
-        curvatureEncoder = new EncodedValue("Curvature", shift, 4, 1, 10, 10);
-        shift += curvatureEncoder.getBits();
-
-        return shift;
+        registerNewEncodedValue.add(priorityWayEncoder = new UnsignedDecimalEncodedValue(getKey(prefix, "priority"), 3, PriorityCode.getFactor(1), false));
+        registerNewEncodedValue.add(curvatureEncoder = new UnsignedDecimalEncodedValue(getKey(prefix, "curvature"), 4, 0.1, false));
     }
 
     @Override
-    public long acceptWay(ReaderWay way) {
+    public EncodingManager.Access getAccess(ReaderWay way) {
         String highwayValue = way.getTag("highway");
         String firstValue = way.getFirstPriorityTag(restrictions);
         if (highwayValue == null) {
             if (way.hasTag("route", ferries)) {
                 if (restrictedValues.contains(firstValue))
-                    return 0;
+                    return EncodingManager.Access.CAN_SKIP;
                 if (intendedValues.contains(firstValue) ||
                         // implied default is allowed only if foot and bicycle is not specified:
                         firstValue.isEmpty() && !way.hasTag("foot") && !way.hasTag("bicycle"))
-                    return acceptBit | ferryBit;
+                    return EncodingManager.Access.FERRY;
             }
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         }
 
         if ("track".equals(highwayValue)) {
             String tt = way.getTag("tracktype");
             if (tt != null && !tt.equals("grade1"))
-                return 0;
+                return EncodingManager.Access.CAN_SKIP;
         }
 
         if (!defaultSpeedMap.containsKey(highwayValue))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (way.hasTag("impassable", "yes") || way.hasTag("status", "impassable"))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (!firstValue.isEmpty()) {
             if (restrictedValues.contains(firstValue) && !getConditionalTagInspector().isRestrictedWayConditionallyPermitted(way))
-                return 0;
+                return EncodingManager.Access.CAN_SKIP;
             if (intendedValues.contains(firstValue))
-                return acceptBit;
+                return EncodingManager.Access.WAY;
         }
 
         // do not drive street cars into fords
         if (isBlockFords() && ("ford".equals(highwayValue) || way.hasTag("ford")))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
 
         if (getConditionalTagInspector().isPermittedWayConditionallyRestricted(way))
-            return 0;
+            return EncodingManager.Access.CAN_SKIP;
         else
-            return acceptBit;
+            return EncodingManager.Access.WAY;
     }
 
     @Override
-    public long handleWayTags(ReaderWay way, long allowed, long priorityFromRelation) {
-        if (!isAccept(allowed))
-            return 0;
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access accept, long priorityFromRelation) {
+        if (accept.canSkip())
+            return edgeFlags;
 
-        long flags = 0;
-        if (!isFerry(allowed)) {
+        if (!accept.isFerry()) {
             // get assumed speed from highway type
             double speed = getSpeed(way);
             speed = applyMaxSpeed(way, speed);
@@ -208,109 +201,38 @@ public long handleWayTags(ReaderWay way, long allowed, long priorityFromRelation
             if (speed > 30 && way.hasTag("surface", badSurfaceSpeedMap))
                 speed = 30;
 
-            boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
-            if (isRoundabout)
-                flags = setBool(0, K_ROUNDABOUT, true);
-
+            boolean isRoundabout = roundaboutEnc.getBool(false, edgeFlags);
             if (way.hasTag("oneway", oneways) || isRoundabout) {
                 if (way.hasTag("oneway", "-1")) {
-                    flags = setReverseSpeed(flags, speed);
-                    flags |= backwardBit;
+                    accessEnc.setBool(true, edgeFlags, true);
+                    setSpeed(true, edgeFlags, speed);
                 } else {
-                    flags = setSpeed(flags, speed);
-                    flags |= forwardBit;
+                    accessEnc.setBool(false, edgeFlags, true);
+                    setSpeed(false, edgeFlags, speed);
                 }
             } else {
-                flags = setSpeed(flags, speed);
-                flags = setReverseSpeed(flags, speed);
-                flags |= directionBitMask;
+                accessEnc.setBool(false, edgeFlags, true);
+                accessEnc.setBool(true, edgeFlags, true);
+                setSpeed(false, edgeFlags, speed);
+                setSpeed(true, edgeFlags, speed);
             }
 
         } else {
+            accessEnc.setBool(false, edgeFlags, true);
+            accessEnc.setBool(true, edgeFlags, true);
             double ferrySpeed = getFerrySpeed(way);
-            flags = setSpeed(flags, ferrySpeed);
-            flags = setReverseSpeed(flags, ferrySpeed);
-            flags |= directionBitMask;
+            setSpeed(false, edgeFlags, ferrySpeed);
+            setSpeed(true, edgeFlags, ferrySpeed);
         }
 
-        // relations are not yet stored -> see BikeCommonFlagEncoder.defineRelationBits how to do this
-        flags = priorityWayEncoder.setValue(flags, handlePriority(way, priorityFromRelation));
+        priorityWayEncoder.setDecimal(false, edgeFlags, PriorityCode.getFactor(handlePriority(priorityFromRelation, way)));
 
         // Set the curvature to the Maximum
-        flags = curvatureEncoder.setValue(flags, 10);
-
-        return flags;
-    }
-
-    @Override
-    public double getReverseSpeed(long flags) {
-        return reverseSpeedEncoder.getDoubleValue(flags);
-    }
-
-    @Override
-    public long setReverseSpeed(long flags, double speed) {
-        if (speed < 0)
-            throw new IllegalArgumentException("Speed cannot be negative: " + speed + ", flags:" + BitUtil.LITTLE.toBitString(flags));
-
-        if (speed < speedEncoder.factor / 2)
-            return setLowSpeed(flags, speed, true);
-
-        if (speed > getMaxSpeed())
-            speed = getMaxSpeed();
-
-        return reverseSpeedEncoder.setDoubleValue(flags, speed);
-    }
-
-    @Override
-    protected long setLowSpeed(long flags, double speed, boolean reverse) {
-        if (reverse)
-            return setBool(reverseSpeedEncoder.setDoubleValue(flags, 0), K_BACKWARD, false);
-
-        return setBool(speedEncoder.setDoubleValue(flags, 0), K_FORWARD, false);
+        curvatureEncoder.setDecimal(false, edgeFlags, PriorityCode.getFactor(10));
+        return edgeFlags;
     }
 
-    @Override
-    public long flagsDefault(boolean forward, boolean backward) {
-        long flags = super.flagsDefault(forward, backward);
-        if (backward)
-            return reverseSpeedEncoder.setDefaultValue(flags);
-
-        return flags;
-    }
-
-    @Override
-    public long setProperties(double speed, boolean forward, boolean backward) {
-        long flags = super.setProperties(speed, forward, backward);
-        if (backward)
-            return setReverseSpeed(flags, speed);
-
-        return flags;
-    }
-
-    @Override
-    public long reverseFlags(long flags) {
-        // swap access
-        flags = super.reverseFlags(flags);
-
-        // swap speeds 
-        double otherValue = reverseSpeedEncoder.getDoubleValue(flags);
-        flags = setReverseSpeed(flags, speedEncoder.getDoubleValue(flags));
-        return setSpeed(flags, otherValue);
-    }
-
-    @Override
-    public double getDouble(long flags, int key) {
-        switch (key) {
-            case PriorityWeighting.KEY:
-                return (double) priorityWayEncoder.getValue(flags) / BEST.getValue();
-            case MotorcycleFlagEncoder.CURVATURE_KEY:
-                return (double) curvatureEncoder.getValue(flags) / 10;
-            default:
-                return super.getDouble(flags, key);
-        }
-    }
-
-    private int handlePriority(ReaderWay way, long relationFlags) {
+    private int handlePriority(long relationFlags, ReaderWay way) {
         String highway = way.getTag("highway", "");
         if (avoidSet.contains(highway)) {
             return PriorityCode.WORST.getValue();
@@ -323,7 +245,7 @@ private int handlePriority(ReaderWay way, long relationFlags) {
 
     @Override
     public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
-        double speed = this.getSpeed(edge.getFlags());
+        double speed = edge.get(speedEncoder);
         double roadDistance = edge.getDistance();
         double beelineDistance = getBeelineDistance(way);
         double bendiness = beelineDistance / roadDistance;
@@ -332,7 +254,7 @@ public void applyWayTags(ReaderWay way, EdgeIteratorState edge) {
         bendiness = increaseBendinessImpact(bendiness);
         bendiness = correctErrors(bendiness);
 
-        edge.setFlags(this.curvatureEncoder.setValue(edge.getFlags(), convertToInt(bendiness)));
+        edge.set(curvatureEncoder, bendiness);
     }
 
     private double getBeelineDistance(ReaderWay way) {
@@ -382,11 +304,6 @@ public boolean supports(Class<?> feature) {
         return PriorityWeighting.class.isAssignableFrom(feature);
     }
 
-    protected int convertToInt(double bendiness) {
-        bendiness = bendiness * 10;
-        return (int) bendiness;
-    }
-
     @Override
     public String toString() {
         return "motorcycle";
diff --git a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
index 40cc94a0c8..b6f18a451c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/MountainBikeFlagEncoder.java
@@ -19,6 +19,7 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.PMap;
 
 import java.util.TreeMap;
@@ -109,6 +110,7 @@ public MountainBikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCos
         setHighwaySpeed("tertiary_link", 18);
 
         addPushingSection("footway");
+        addPushingSection("platform");
         addPushingSection("pedestrian");
         addPushingSection("steps");
 
@@ -160,15 +162,15 @@ else if (trackType.startsWith("grade"))
     }
 
     @Override
-    public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
-        oldRelationFlags = super.handleRelationTags(relation, oldRelationFlags);
+    public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
+        super.handleRelationTags(oldRelationFlags, relation);
         int code = 0;
         if (relation.hasTag("route", "mtb"))
             code = PREFER.getValue();
 
         int oldCode = (int) relationCodeEncoder.getValue(oldRelationFlags);
         if (oldCode < code)
-            return relationCodeEncoder.setValue(0, code);
+            relationCodeEncoder.setValue(oldRelationFlags, code);
         return oldRelationFlags;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
index 5c4463dbae..65131b1936 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PriorityCode.java
@@ -20,7 +20,6 @@
 /**
  * Used to store a priority value in the way flags of an edge. Used in combination with
  * PriorityWeighting
- * <p>
  *
  * @author Peter Karich
  */
@@ -35,7 +34,7 @@
     BEST(7);
     private final int value;
 
-    private PriorityCode(int value) {
+    PriorityCode(int value) {
         this.value = value;
     }
 
@@ -43,4 +42,11 @@ public int getValue() {
         return value;
     }
 
+    /**
+     * This method returns the PriorityCode.value in a range between 0 and 1 suitable for direct usage in a Weighting.
+     */
+    public static double getFactor(int val) {
+        return (double) val / BEST.getValue();
+    }
+
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
index c2461c75cd..b93e50fbda 100644
--- a/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/RacingBikeFlagEncoder.java
@@ -113,6 +113,7 @@ public RacingBikeFlagEncoder(int speedBits, double speedFactor, int maxTurnCosts
 
         addPushingSection("path");
         addPushingSection("footway");
+        addPushingSection("platform");
         addPushingSection("pedestrian");
         addPushingSection("steps");
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/SnapPreventionEdgeFilter.java b/core/src/main/java/com/graphhopper/routing/util/SnapPreventionEdgeFilter.java
new file mode 100644
index 0000000000..7499dcd5cd
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/SnapPreventionEdgeFilter.java
@@ -0,0 +1,62 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadClass;
+import com.graphhopper.routing.profiles.RoadEnvironment;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.Parameters;
+
+import java.util.List;
+
+import static com.graphhopper.routing.profiles.RoadClass.MOTORWAY;
+import static com.graphhopper.routing.profiles.RoadClass.TRUNK;
+import static com.graphhopper.routing.profiles.RoadEnvironment.*;
+
+public class SnapPreventionEdgeFilter implements EdgeFilter {
+
+    private final EnumEncodedValue<RoadEnvironment> reEnc;
+    private final EnumEncodedValue<RoadClass> rcEnc;
+    private final EdgeFilter filter;
+    private boolean avoidMotorway = false, avoidTrunk;
+    private boolean avoidTunnel, avoidBridge, avoidFerry, avoidFord;
+
+    public SnapPreventionEdgeFilter(EdgeFilter filter, EnumEncodedValue<RoadClass> rcEnc,
+                                    EnumEncodedValue<RoadEnvironment> reEnc, List<String> snapPreventions) {
+        this.filter = filter;
+        this.reEnc = reEnc;
+        this.rcEnc = rcEnc;
+
+        for (String roadClassOrRoadEnv : snapPreventions) {
+            if ("motorway".equals(roadClassOrRoadEnv)) {
+                avoidMotorway = true;
+                continue;
+            } else if ("trunk".equals(roadClassOrRoadEnv)) {
+                avoidTrunk = true;
+                continue;
+            }
+
+            RoadEnvironment rc = RoadEnvironment.find(roadClassOrRoadEnv);
+            if (rc == TUNNEL)
+                avoidTunnel = true;
+            else if (rc == BRIDGE)
+                avoidBridge = true;
+            else if (rc == FERRY)
+                avoidFerry = true;
+            else if (rc == FORD)
+                avoidFord = true;
+            else
+                throw new IllegalArgumentException("Cannot find " + Parameters.Routing.SNAP_PREVENTION + ": " + roadClassOrRoadEnv);
+        }
+    }
+
+    @Override
+    public boolean accept(EdgeIteratorState edgeState) {
+        return filter.accept(edgeState)
+                && !(avoidMotorway && edgeState.get(rcEnc) == MOTORWAY)
+                && !(avoidTrunk && edgeState.get(rcEnc) == TRUNK)
+                && !(avoidTunnel && edgeState.get(reEnc) == TUNNEL)
+                && !(avoidBridge && edgeState.get(reEnc) == BRIDGE)
+                && !(avoidFord && edgeState.get(reEnc) == FORD)
+                && !(avoidFerry && edgeState.get(reEnc) == FERRY);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
index 39d7e88486..c2db769812 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TestAlgoCollector.java
@@ -45,7 +45,7 @@ public TestAlgoCollector(String name) {
         this.name = name;
     }
 
-    public TestAlgoCollector assertDistance(AlgoHelperEntry algoEntry, List<QueryResult> queryList,
+    public TestAlgoCollector assertDistance(EncodingManager encodingManager, AlgoHelperEntry algoEntry, List<QueryResult> queryList,
                                             OneRun oneRun) {
         List<Path> altPaths = new ArrayList<>();
         QueryGraph queryGraph = new QueryGraph(algoEntry.getForQueryGraph());
@@ -54,7 +54,7 @@ public TestAlgoCollector assertDistance(AlgoHelperEntry algoEntry, List<QueryRes
         FlagEncoder encoder = opts.getWeighting().getFlagEncoder();
         if (encoder.supports(TurnWeighting.class)) {
             if (!opts.getTraversalMode().isEdgeBased()) {
-                errors.add("Cannot use TurnWeighting with a node based traversal");
+                errors.add("Cannot use TurnWeighting with node based traversal");
                 return this;
             }
             algoEntry.setAlgorithmOptions(AlgorithmOptions.start(opts).weighting(new TurnWeighting(opts.getWeighting(), (TurnCostExtension) queryGraph.getExtension())).build());
@@ -78,7 +78,7 @@ public TestAlgoCollector assertDistance(AlgoHelperEntry algoEntry, List<QueryRes
                 setSimplifyResponse(false).
                 setEnableInstructions(true);
         PathWrapper rsp = new PathWrapper();
-        pathMerger.doWork(rsp, altPaths, trMap.getWithFallBack(Locale.US));
+        pathMerger.doWork(rsp, altPaths, encodingManager, trMap.getWithFallBack(Locale.US));
 
         if (rsp.hasErrors()) {
             errors.add("response for " + algoEntry + " contains errors. Expected distance: " + oneRun.getDistance()
@@ -97,7 +97,7 @@ public TestAlgoCollector assertDistance(AlgoHelperEntry algoEntry, List<QueryRes
         if (Math.abs(rsp.getDistance() - oneRun.getDistance()) > 2) {
             errors.add(algoEntry + " returns path not matching the expected distance of " + oneRun.getDistance()
                     + "\t Returned was " + rsp.getDistance() + "\t (expected points " + oneRun.getLocs()
-                    + ", was " + pointList.getSize() + ") " + queryList);
+                    + ", was " + pointList.getSize() + ") " + "\t (weight " + rsp.getRouteWeight() + ") " + queryList);
         }
 
         // There are real world instances where A-B-C is identical to A-C (in meter precision).
diff --git a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
index ca6aaceb40..8ed3d56c07 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TraversalMode.java
@@ -37,37 +37,16 @@
     /**
      * The simplest traversal mode but without turn restrictions or cost support.
      */
-    NODE_BASED(false, 1, false),
+    NODE_BASED(false),
     /**
-     * Strictly not recommended as it could lead to 'route not found' for bidirectional algorithms.
-     * An edged-based traversal mode with basic turn restriction and cost support, including the
-     * most scenarios. But without certain turn restrictions and without u-turns. As fast as node
-     * based.
+     * The edged-based traversal mode with turn restriction and cost support. 2 times slower than node based.
      */
-    EDGE_BASED_1DIR(true, 1, false),
-    /**
-     * The bidirectional edged-based traversal mode with turn restriction and cost support. Without
-     * u-turn support. 2 times slower than node based.
-     */
-    EDGE_BASED_2DIR(true, 2, false),
-    /**
-     * Not recommended as it leads to strange routes that outsmart the turn costs. The most feature
-     * rich edged-based traversal mode with turn restriction and cost support, including u-turns. 4
-     * times slower than node based.
-     */
-    EDGE_BASED_2DIR_UTURN(true, 2, true);
+    EDGE_BASED(true);
 
     private final boolean edgeBased;
-    private final int noOfStates;
-    private final boolean uTurnSupport;
 
-    TraversalMode(boolean edgeBased, int noOfStates, boolean uTurnSupport) {
+    TraversalMode(boolean edgeBased) {
         this.edgeBased = edgeBased;
-        this.noOfStates = noOfStates;
-        this.uTurnSupport = uTurnSupport;
-
-        if (noOfStates != 1 && noOfStates != 2)
-            throw new IllegalArgumentException("Currently only 1 or 2 states allowed");
     }
 
     public static TraversalMode fromString(String name) {
@@ -91,14 +70,7 @@ public static TraversalMode fromString(String name) {
      * @return the identifier to access the shortest path tree
      */
     public final int createTraversalId(EdgeIteratorState iterState, boolean reverse) {
-        if (edgeBased) {
-            if (noOfStates == 1)
-                return iterState.getEdge();
-
-            return GHUtility.createEdgeKey(iterState.getBaseNode(), iterState.getAdjNode(), iterState.getEdge(), reverse);
-        }
-
-        return iterState.getAdjNode();
+        return createTraversalId(iterState.getBaseNode(), iterState.getAdjNode(), iterState.getEdge(), reverse);
     }
 
     /**
@@ -106,30 +78,19 @@ public final int createTraversalId(EdgeIteratorState iterState, boolean reverse)
      */
     public final int createTraversalId(int baseNode, int adjNode, int edgeId, boolean reverse) {
         if (edgeBased) {
-            if (noOfStates == 1)
-                return edgeId;
-
             return GHUtility.createEdgeKey(baseNode, adjNode, edgeId, reverse);
         }
-
         return adjNode;
     }
 
     public int reverseEdgeKey(int edgeKey) {
-        if (edgeBased && noOfStates > 1)
+        if (edgeBased)
             return GHUtility.reverseEdgeKey(edgeKey);
         return edgeKey;
     }
 
-    public int getNoOfStates() {
-        return noOfStates;
-    }
-
     public boolean isEdgeBased() {
         return edgeBased;
     }
 
-    public final boolean hasUTurnSupport() {
-        return uTurnSupport;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
index aab7a77235..b745d59bc7 100644
--- a/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/TurnCostEncoder.java
@@ -18,8 +18,7 @@
 package com.graphhopper.routing.util;
 
 /**
- * Encodes and decodes a turn restriction and turn costs within a integer flag
- * <p>
+ * Encodes and decodes a turn restriction or turn costs within an integer flag
  *
  * @author Karl Hübner
  */
@@ -36,8 +35,7 @@
     double getTurnCost(long flags);
 
     /**
-     * @param restricted true if restricted turn, equivalent to specifying of costs
-     *                   Double.POSITIVE_INFINITY
+     * @param restricted true if restricted turn, equivalent to specifying costs = Double.POSITIVE_INFINITY
      * @param costs      the turn costs, specify 0 or Double.POSITIVE_INFINITY if restricted == true.
      *                   Only used if restricted == false.
      * @return the encoded flags
@@ -45,7 +43,7 @@
     long getTurnFlags(boolean restricted, double costs);
 
     /**
-     * No turn costs will be enabled by this encoder, should be used for pedestrians
+     * No turn costs will be enabled by this encoder, should be used for e.g. pedestrians
      */
     class NoTurnCostsEncoder implements TurnCostEncoder {
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/DefaultTagParserFactory.java b/core/src/main/java/com/graphhopper/routing/util/parsers/DefaultTagParserFactory.java
new file mode 100644
index 0000000000..370ba8e8fb
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/DefaultTagParserFactory.java
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.util.PMap;
+
+import static com.graphhopper.util.Helper.toLowerCase;
+
+public class DefaultTagParserFactory implements TagParserFactory {
+    @Override
+    public TagParser create(String name, PMap configuration) {
+        name = name.trim();
+        if (!name.equals(toLowerCase(name)))
+            throw new IllegalArgumentException("Use lower case for TagParsers: " + name);
+
+        // for Country (SpatialRuleParser) see SpatialRuleLookupHelper
+        if (Roundabout.KEY.equals(name))
+            return new OSMRoundaboutParser();
+        else if (name.equals(RoadClass.KEY))
+            return new OSMRoadClassParser();
+        else if (name.equals(RoadClassLink.KEY))
+            return new OSMRoadClassLinkParser();
+        else if (name.equals(RoadEnvironment.KEY))
+            return new OSMRoadEnvironmentParser();
+        else if (name.equals(RoadAccess.KEY))
+            return new OSMRoadAccessParser();
+        else if (name.equals(MaxSpeed.KEY))
+            return new OSMMaxSpeedParser();
+        else if (name.equals(MaxWeight.KEY))
+            return new OSMMaxWeightParser();
+        else if (name.equals(MaxHeight.KEY))
+            return new OSMMaxHeightParser();
+        else if (name.equals(MaxWidth.KEY))
+            return new OSMMaxWidthParser();
+        else if (name.equals(Surface.KEY))
+            return new OSMSurfaceParser();
+        else if (name.equals(Toll.KEY))
+            return new OSMTollParser();
+        throw new IllegalArgumentException("entry in encoder list not supported " + name);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxHeightParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxHeightParser.java
new file mode 100644
index 0000000000..509d1c7021
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxHeightParser.java
@@ -0,0 +1,56 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.MaxHeight;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+import java.util.Arrays;
+import java.util.List;
+
+public class OSMMaxHeightParser implements TagParser {
+
+    private final DecimalEncodedValue heightEncoder;
+    private final boolean enableLog;
+
+    public OSMMaxHeightParser() {
+        this(MaxHeight.create(), false);
+    }
+
+    public OSMMaxHeightParser(DecimalEncodedValue heightEncoder, boolean enableLog) {
+        this.heightEncoder = heightEncoder;
+        this.enableLog = enableLog;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> registerNewEncodedValue) {
+        registerNewEncodedValue.add(heightEncoder);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        List<String> heightTags = Arrays.asList("maxheight", "maxheight:physical"/*, the OSM tag "height" is not used for the height of a road, so omit it here! */);
+        OSMMaxWidthParser.extractMeter(edgeFlags, way, heightEncoder, heightTags, enableLog);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxSpeedParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxSpeedParser.java
new file mode 100644
index 0000000000..085a6bf7d8
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxSpeedParser.java
@@ -0,0 +1,88 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.MaxSpeed;
+import com.graphhopper.routing.util.AbstractFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.List;
+
+import static com.graphhopper.routing.profiles.MaxSpeed.UNSET_SPEED;
+
+public class OSMMaxSpeedParser implements TagParser {
+
+    private final DecimalEncodedValue carMaxSpeedEnc;
+
+    public OSMMaxSpeedParser() {
+        this(MaxSpeed.create());
+    }
+
+    public OSMMaxSpeedParser(DecimalEncodedValue carMaxSpeedEnc) {
+        if (!carMaxSpeedEnc.isStoreTwoDirections())
+            throw new IllegalArgumentException("EncodedValue for maxSpeed must be able to store two directions");
+
+        this.carMaxSpeedEnc = carMaxSpeedEnc;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> list) {
+        list.add(carMaxSpeedEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        double maxSpeed = AbstractFlagEncoder.parseSpeed(way.getTag("maxspeed"));
+
+        if (maxSpeed < 0) {
+            GHPoint estmCentre = way.getTag("estimated_center", null);
+            SpatialRule spatialRule = way.getTag("spatial_rule", null);
+            if (estmCentre != null && spatialRule != null)
+                maxSpeed = spatialRule.getMaxSpeed(way.getTag("highway", ""), maxSpeed);
+        }
+
+        double fwdSpeed = AbstractFlagEncoder.parseSpeed(way.getTag("maxspeed:forward"));
+        if (fwdSpeed < 0 && maxSpeed > 0)
+            fwdSpeed = maxSpeed;
+        double maxPossibleSpeed = MaxSpeed.UNLIMITED_SIGN_SPEED;
+        if (fwdSpeed > maxPossibleSpeed)
+            fwdSpeed = maxPossibleSpeed;
+
+        double bwdSpeed = AbstractFlagEncoder.parseSpeed(way.getTag("maxspeed:backward"));
+        if (bwdSpeed < 0 && maxSpeed > 0)
+            bwdSpeed = maxSpeed;
+        if (bwdSpeed > maxPossibleSpeed)
+            bwdSpeed = maxPossibleSpeed;
+
+        if (fwdSpeed <= 0)
+            fwdSpeed = UNSET_SPEED;
+        carMaxSpeedEnc.setDecimal(false, edgeFlags, fwdSpeed);
+
+        if (bwdSpeed <= 0)
+            bwdSpeed = UNSET_SPEED;
+        carMaxSpeedEnc.setDecimal(true, edgeFlags, bwdSpeed);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParser.java
new file mode 100644
index 0000000000..41f2406467
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParser.java
@@ -0,0 +1,94 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.MaxWeight;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static com.graphhopper.util.Helper.isEmpty;
+import static com.graphhopper.util.Helper.toLowerCase;
+
+public class OSMMaxWeightParser implements TagParser {
+
+    private static Logger LOG = LoggerFactory.getLogger(OSMMaxWeightParser.class);
+    private final DecimalEncodedValue weightEncoder;
+    private final boolean enableLog;
+
+    public OSMMaxWeightParser() {
+        this(MaxWeight.create(), false);
+    }
+
+    public OSMMaxWeightParser(DecimalEncodedValue weightEncoder, boolean enableLog) {
+        this.weightEncoder = weightEncoder;
+        this.enableLog = enableLog;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> registerNewEncodedValue) {
+        registerNewEncodedValue.add(weightEncoder);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        // do not include OSM tag "height" here as it has completely different meaning (height of peak)
+        List<String> weightTags = Arrays.asList("maxweight", "maxgcweight");
+        extractTons(edgeFlags, way, weightEncoder, weightTags, enableLog);
+        return edgeFlags;
+    }
+
+    static void extractTons(IntsRef edgeFlags, ReaderWay way, DecimalEncodedValue valueEncoder, List<String> keys, boolean enableLog) {
+        String value = way.getFirstPriorityTag(keys);
+        if (isEmpty(value))
+            return;
+        try {
+            double val = stringToTons(value);
+            if (val > valueEncoder.getMaxDecimal())
+                val = valueEncoder.getMaxDecimal();
+            valueEncoder.setDecimal(false, edgeFlags, val);
+        } catch (Exception ex) {
+            if (enableLog)
+                LOG.warn("Unable to extract tons from malformed road attribute '{}' for way (OSM_ID = {}).", value, way.getId());
+        }
+    }
+
+    public static double stringToTons(String value) {
+        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(tons|ton)", "t");
+        value = value.replace("mgw", "").trim();
+        double factor = 1;
+        if (value.equals("default") || value.equals("none")) {
+            return -1;
+        } else if (value.endsWith("t")) {
+            value = value.substring(0, value.length() - 1);
+        } else if (value.endsWith("lbs")) {
+            value = value.substring(0, value.length() - 3);
+            factor = 0.00045359237;
+        }
+
+        return Double.parseDouble(value) * factor;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWidthParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWidthParser.java
new file mode 100644
index 0000000000..a1da914777
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMMaxWidthParser.java
@@ -0,0 +1,118 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.MaxWidth;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static com.graphhopper.util.Helper.isEmpty;
+import static com.graphhopper.util.Helper.toLowerCase;
+
+public class OSMMaxWidthParser implements TagParser {
+
+    private static Logger LOG = LoggerFactory.getLogger(OSMMaxWidthParser.class);
+    private final DecimalEncodedValue widthEncoder;
+    private final boolean enableLog;
+
+    public OSMMaxWidthParser() {
+        this(MaxWidth.create(), false);
+    }
+
+    public OSMMaxWidthParser(DecimalEncodedValue widthEncoder, boolean enableLog) {
+        this.widthEncoder = widthEncoder;
+        this.enableLog = enableLog;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> registerNewEncodedValue) {
+        registerNewEncodedValue.add(widthEncoder);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        List<String> widthTags = Arrays.asList("maxwidth", "maxwidth:physical", "width");
+        extractMeter(edgeFlags, way, widthEncoder, widthTags, enableLog);
+        return edgeFlags;
+    }
+
+    static void extractMeter(IntsRef edgeFlags, ReaderWay way, DecimalEncodedValue valueEncoder, List<String> keys, boolean enableLog) {
+        String value = way.getFirstPriorityTag(keys);
+        if (isEmpty(value))
+            return;
+        try {
+            double val = stringToMeter(value);
+            if (val > valueEncoder.getMaxDecimal())
+                val = valueEncoder.getMaxDecimal();
+            valueEncoder.setDecimal(false, edgeFlags, val);
+        } catch (Exception ex) {
+            if (enableLog)
+                LOG.warn("Unable to extract meter from malformed road attribute '{}' for way (OSM_ID = {}).", value, way.getId());
+        }
+    }
+
+    public static double stringToMeter(String value) {
+        value = toLowerCase(value).replaceAll(" ", "").replaceAll("(meters|meter|mtrs|mtr|mt|m\\.)", "m");
+        double factor = 1;
+        double offset = 0;
+        value = value.replaceAll("(\\\"|\'\')", "in").replaceAll("(\'|feet)", "ft");
+        if (value.startsWith("~") || value.contains("approx")) {
+            value = value.replaceAll("(\\~|approx)", "").trim();
+            factor = 0.8;
+        }
+
+        if (value.equals("default") || value.equals("none") || value.equals("unsigned"))
+            return -1;
+
+        if (value.endsWith("in")) {
+            int startIndex = value.indexOf("ft");
+            String inchValue;
+            if (startIndex < 0) {
+                startIndex = 0;
+            } else {
+                startIndex += 2;
+            }
+
+            inchValue = value.substring(startIndex, value.length() - 2);
+            value = value.substring(0, startIndex);
+            offset = Double.parseDouble(inchValue) * 0.0254;
+        }
+
+        if (value.endsWith("ft")) {
+            value = value.substring(0, value.length() - 2);
+            factor *= 0.3048;
+        } else if (value.endsWith("m")) {
+            value = value.substring(0, value.length() - 1);
+        }
+
+        if (value.isEmpty()) {
+            return offset;
+        } else {
+            return Double.parseDouble(value) * factor + offset;
+        }
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadAccessParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadAccessParser.java
new file mode 100644
index 0000000000..0ac62cf3fe
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadAccessParser.java
@@ -0,0 +1,73 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadAccess;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
+import com.graphhopper.routing.util.spatialrules.TransportationMode;
+import com.graphhopper.storage.IntsRef;
+
+import java.util.Arrays;
+import java.util.List;
+
+import static com.graphhopper.routing.profiles.RoadAccess.YES;
+
+public class OSMRoadAccessParser implements TagParser {
+    private final EnumEncodedValue<RoadAccess> roadAccessEnc;
+    private final List<String> restrictions;
+
+    public OSMRoadAccessParser() {
+        this(Arrays.asList("motorcar", "motor_vehicle", "vehicle", "access"));
+    }
+
+    public OSMRoadAccessParser(List<String> restrictions) {
+        this.roadAccessEnc = new EnumEncodedValue<>(RoadAccess.KEY, RoadAccess.class);
+        this.restrictions = restrictions;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> list) {
+        list.add(roadAccessEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
+        RoadAccess accessValue = YES;
+        RoadAccess tmpAccessValue;
+        for (String restriction : restrictions) {
+            tmpAccessValue = RoadAccess.find(readerWay.getTag(restriction, "yes"));
+            if (tmpAccessValue != null && tmpAccessValue.ordinal() > accessValue.ordinal()) {
+                accessValue = tmpAccessValue;
+            }
+        }
+
+        if (accessValue == RoadAccess.YES) {
+            SpatialRule spatialRule = readerWay.getTag("spatial_rule", null);
+            if (spatialRule != null)
+                accessValue = spatialRule.getAccess(readerWay.getTag("highway", ""), TransportationMode.MOTOR_VEHICLE, YES);
+        }
+
+        roadAccessEnc.setEnum(false, edgeFlags, accessValue);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadClassLinkParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadClassLinkParser.java
new file mode 100644
index 0000000000..d2556a6038
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadClassLinkParser.java
@@ -0,0 +1,47 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.Helper;
+
+import java.util.List;
+
+public class OSMRoadClassLinkParser implements TagParser {
+    private final BooleanEncodedValue linkEnc;
+
+    public OSMRoadClassLinkParser() {
+        this.linkEnc = new SimpleBooleanEncodedValue(RoadClassLink.KEY);
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> list) {
+        list.add(linkEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
+        String highwayTag = readerWay.getTag("highway");
+        if (!Helper.isEmpty(highwayTag) && highwayTag.endsWith("_link"))
+            linkEnc.setBool(false, edgeFlags, true);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadClassParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadClassParser.java
new file mode 100644
index 0000000000..155f34bb8b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadClassParser.java
@@ -0,0 +1,61 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadClass;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+import java.util.List;
+
+import static com.graphhopper.routing.profiles.RoadClass.OTHER;
+
+public class OSMRoadClassParser implements TagParser {
+
+    private final EnumEncodedValue<RoadClass> roadClassEnc;
+
+    public OSMRoadClassParser() {
+        this.roadClassEnc = new EnumEncodedValue<>(RoadClass.KEY, RoadClass.class);
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> link) {
+        link.add(roadClassEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
+        if (!access.isWay())
+            return edgeFlags;
+
+        String roadClassTag = readerWay.getTag("highway");
+        if (roadClassTag == null)
+            return edgeFlags;
+        RoadClass roadClass = RoadClass.find(roadClassTag);
+        if (roadClass == OTHER && roadClassTag.endsWith("_link"))
+            roadClass = RoadClass.find(roadClassTag.substring(0, roadClassTag.length() - 5));
+
+        if (roadClass != OTHER)
+            roadClassEnc.setEnum(false, edgeFlags, roadClass);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadEnvironmentParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadEnvironmentParser.java
new file mode 100644
index 0000000000..c2b08a9f7c
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoadEnvironmentParser.java
@@ -0,0 +1,66 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadEnvironment;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+import java.util.List;
+
+import static com.graphhopper.routing.profiles.RoadEnvironment.*;
+
+public class OSMRoadEnvironmentParser implements TagParser {
+
+    private final EnumEncodedValue<RoadEnvironment> roadEnvEnc;
+
+    public OSMRoadEnvironmentParser() {
+        this.roadEnvEnc = new EnumEncodedValue<>(RoadEnvironment.KEY, RoadEnvironment.class);
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> list) {
+        list.add(roadEnvEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
+        RoadEnvironment roadEnvironment = OTHER;
+        if (access.isFerry())
+            roadEnvironment = FERRY;
+        else if (readerWay.hasTag("bridge") && !readerWay.hasTag("bridge", "no"))
+            roadEnvironment = BRIDGE;
+        else if (readerWay.hasTag("tunnel") && !readerWay.hasTag("tunnel", "no"))
+            roadEnvironment = TUNNEL;
+        else if (readerWay.hasTag("ford") || readerWay.hasTag("highway", "ford"))
+            roadEnvironment = FORD;
+        else if (readerWay.hasTag("route", "shuttle_train"))
+            // TODO how to feed this information from a relation like https://www.openstreetmap.org/relation/1932780
+            roadEnvironment = SHUTTLE_TRAIN;
+        else if (readerWay.hasTag("highway"))
+            roadEnvironment = ROAD;
+
+        if (roadEnvironment != OTHER)
+            roadEnvEnc.setEnum(false, edgeFlags, roadEnvironment);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoundaboutParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoundaboutParser.java
new file mode 100644
index 0000000000..0f163f56a4
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMRoundaboutParser.java
@@ -0,0 +1,56 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.Roundabout;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+import java.util.List;
+
+public class OSMRoundaboutParser implements TagParser {
+
+    private final BooleanEncodedValue roundaboutEnc;
+
+    public OSMRoundaboutParser() {
+        this(Roundabout.create());
+    }
+
+    public OSMRoundaboutParser(BooleanEncodedValue roundaboutEnc) {
+        this.roundaboutEnc = roundaboutEnc;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> list) {
+        list.add(roundaboutEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        if (!access.isWay())
+            return edgeFlags;
+        boolean isRoundabout = way.hasTag("junction", "roundabout") || way.hasTag("junction", "circular");
+        if (isRoundabout)
+            roundaboutEnc.setBool(false, edgeFlags, true);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMSurfaceParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMSurfaceParser.java
new file mode 100644
index 0000000000..5ce06d77e3
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMSurfaceParser.java
@@ -0,0 +1,65 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.Surface;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.Helper;
+
+import java.util.List;
+
+import static com.graphhopper.routing.profiles.Surface.*;
+
+public class OSMSurfaceParser implements TagParser {
+
+    private final EnumEncodedValue<Surface> surfaceEnc;
+
+    public OSMSurfaceParser() {
+        this(new EnumEncodedValue<>(KEY, Surface.class));
+    }
+
+    public OSMSurfaceParser(EnumEncodedValue<Surface> surfaceEnc) {
+        this.surfaceEnc = surfaceEnc;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> list) {
+        list.add(surfaceEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
+        String surfaceTag = readerWay.getTag("surface");
+        Surface surface = Surface.find(surfaceTag);
+        if (surface == OTHER && !Helper.isEmpty(surfaceTag)) {
+            if (surfaceTag.equals("paving_stones") || surfaceTag.equals("metal") || surfaceTag.startsWith("concrete"))
+                surface = PAVED;
+            else if (surfaceTag.equals("sett"))
+                surface = COBBLESTONE;
+        }
+
+        if (surface != OTHER)
+            surfaceEnc.setEnum(false, edgeFlags, surface);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTollParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTollParser.java
new file mode 100644
index 0000000000..ad3167bb27
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/OSMTollParser.java
@@ -0,0 +1,51 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.Toll;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+import java.util.List;
+
+public class OSMTollParser implements TagParser {
+
+    private final EnumEncodedValue<Toll> tollEnc;
+
+    public OSMTollParser() {
+        this.tollEnc = new EnumEncodedValue<>(Toll.KEY, Toll.class);
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> list) {
+        list.add(tollEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay readerWay, EncodingManager.Access access, long relationFlags) {
+        if (readerWay.hasTag("toll", "yes"))
+            tollEnc.setEnum(false, edgeFlags, Toll.ALL);
+        else if (readerWay.hasTag("toll:hgv", "yes"))
+            tollEnc.setEnum(false, edgeFlags, Toll.HGV);
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/SpatialRuleParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/SpatialRuleParser.java
new file mode 100644
index 0000000000..9d9b7a974b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/SpatialRuleParser.java
@@ -0,0 +1,61 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.List;
+
+public class SpatialRuleParser implements TagParser {
+
+    private final IntEncodedValue spatialRuleEnc;
+    private SpatialRuleLookup spatialRuleLookup;
+
+    public SpatialRuleParser(SpatialRuleLookup spatialRuleLookup) {
+        this(spatialRuleLookup, new EnumEncodedValue<>(Country.KEY, Country.class));
+    }
+
+    public SpatialRuleParser(SpatialRuleLookup spatialRuleLookup, IntEncodedValue spatialRuleEnc) {
+        this.spatialRuleLookup = spatialRuleLookup;
+        this.spatialRuleEnc = spatialRuleEnc;
+    }
+
+    @Override
+    public void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> registerNewEncodedValue) {
+        if (spatialRuleEnc == null)
+            throw new IllegalStateException("SpatialRuleLookup was not initialized before building the EncodingManager");
+        registerNewEncodedValue.add(spatialRuleEnc);
+    }
+
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        GHPoint estimatedCenter = way.getTag("estimated_center", null);
+        if (estimatedCenter != null) {
+            SpatialRule rule = spatialRuleLookup.lookupRule(estimatedCenter);
+            way.setTag("spatial_rule", rule);
+            spatialRuleEnc.setInt(false, edgeFlags, spatialRuleLookup.getSpatialId(rule));
+        }
+        return edgeFlags;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/TagParser.java b/core/src/main/java/com/graphhopper/routing/util/parsers/TagParser.java
new file mode 100644
index 0000000000..4584f9db1e
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/TagParser.java
@@ -0,0 +1,37 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EncodedValueLookup;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+import java.util.List;
+
+/**
+ * This interface defines how parts of the information from 'way' is converted into IntsRef. A TagParser usually
+ * has one corresponding EncodedValue. Other situations like multiple tags for one EncodedValue are possible too.
+ */
+public interface TagParser {
+
+    void createEncodedValues(EncodedValueLookup lookup, List<EncodedValue> registerNewEncodedValue);
+
+    IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags);
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/parsers/TagParserFactory.java b/core/src/main/java/com/graphhopper/routing/util/parsers/TagParserFactory.java
new file mode 100644
index 0000000000..4c69722281
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/parsers/TagParserFactory.java
@@ -0,0 +1,7 @@
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.util.PMap;
+
+public interface TagParserFactory {
+    TagParser create(String name, PMap configuration);
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
index b1b1b1bed8..137c487568 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/DefaultSpatialRule.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.routing.util.spatialrules;
 
+import com.graphhopper.routing.profiles.RoadAccess;
+
 /**
  * Default implementation for the SpatialRule that contains the current default values
  */
@@ -49,7 +51,7 @@ public double getMaxSpeed(String highwayTag, double _default) {
     }
 
     @Override
-    public AccessValue getAccessValue(String highwayTag, TransportationMode transportationMode, AccessValue _default) {
+    public RoadAccess getAccess(String highwayTag, TransportationMode transportationMode, RoadAccess _default) {
         // As defined in: https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Access-Restriction
         // We tried to find generally forbidden tags
         if (transportationMode == TransportationMode.MOTOR_VEHICLE) {
@@ -59,7 +61,7 @@ public AccessValue getAccessValue(String highwayTag, TransportationMode transpor
                 case "cycleway":
                 case "footway":
                 case "pedestrian":
-                    return AccessValue.NOT_ACCESSIBLE;
+                    return RoadAccess.NO;
                 default:
                     return _default;
             }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
index fd622feb7f..f3e8d72f11 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRule.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util.spatialrules;
 
+import com.graphhopper.routing.profiles.RoadAccess;
 import com.graphhopper.util.shapes.Polygon;
 
 import java.util.List;
@@ -41,14 +42,14 @@
     double getMaxSpeed(String highway, double _default);
 
     /**
-     * Returns the {@link AccessValue} for a certain highway type and transportation mode. If nothing is defined,
+     * Returns the {@link RoadAccess} for a certain highway type and transportation mode. If nothing is defined,
      * _default will be returned.
      *
      * @param highwayTag         The highway type, e.g. primary, secondary
      * @param transportationMode The mode of transportation
      * @param _default           The default AccessValue
      */
-    AccessValue getAccessValue(String highwayTag, TransportationMode transportationMode, AccessValue _default);
+    RoadAccess getAccess(String highwayTag, TransportationMode transportationMode, RoadAccess _default);
 
     /**
      * Returns the borders in which the SpatialRule is valid
@@ -67,10 +68,11 @@ public double getMaxSpeed(String highwayTag, double _default) {
         }
 
         @Override
-        public AccessValue getAccessValue(String highwayTag, TransportationMode transportationMode, AccessValue _default) {
-            return AccessValue.ACCESSIBLE;
+        public RoadAccess getAccess(String highwayTag, TransportationMode transportationMode, RoadAccess _default) {
+            return _default;
         }
 
+        // should we use Country.DEFAULT here?
         @Override
         public String getId() {
             return "SpatialRule.EMPTY";
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
index 4f66a68b31..c5b9ff85f8 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookup.java
@@ -49,6 +49,12 @@
      */
     int getSpatialId(SpatialRule rule);
 
+    /**
+     * This method returns the SpatialRule for a given Spatial Id. This can be used when retrieving SpatialRules from
+     * a Spatial Id stored in the graph.
+     */
+    SpatialRule getSpatialRule(int spatialId);
+
     /**
      * @return the number of rules added to this lookup.
      */
@@ -75,6 +81,11 @@ public int getSpatialId(SpatialRule rule) {
             return 0;
         }
 
+        @Override
+        public SpatialRule getSpatialRule(int spatialId) {
+            return SpatialRule.EMPTY;
+        }
+
         @Override
         public int size() {
             return 1;
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
index d40b57be68..4320767b40 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArray.java
@@ -212,7 +212,7 @@ private void addSingleRule(SpatialRule rule) {
         singleRules.add(rule);
     }
 
-    SpatialRule getSpatialRule(int id) {
+    public SpatialRule getSpatialRule(int id) {
         if (id < 0 || id >= ruleContainers.size())
             throw new IllegalArgumentException("SpatialRuleId " + id + " is illegal");
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
index 3cd31c3e89..07dcbb99a0 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilder.java
@@ -4,7 +4,7 @@
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.Polygon;
-import com.vividsolutions.jts.geom.Geometry;
+import org.locationtech.jts.geom.Geometry;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -51,8 +51,8 @@ public static SpatialRuleLookup buildIndex(JsonFeatureCollection jsonFeatureColl
             List<Polygon> borders = new ArrayList<>();
             for (int i = 0; i < jsonFeature.getGeometry().getNumGeometries(); i++) {
                 Geometry poly = jsonFeature.getGeometry().getGeometryN(i);
-                if (poly instanceof com.vividsolutions.jts.geom.Polygon)
-                    borders.add(Polygon.create((com.vividsolutions.jts.geom.Polygon) poly));
+                if (poly instanceof org.locationtech.jts.geom.Polygon)
+                    borders.add(Polygon.create((org.locationtech.jts.geom.Polygon) poly));
                 else
                     throw new IllegalArgumentException("Geometry for " + id + " (" + i + ") not supported " + poly.getClass().getSimpleName());
             }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupHelper.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupHelper.java
index f6f07184f0..c6aee6412d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupHelper.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupHelper.java
@@ -1,17 +1,36 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package com.graphhopper.routing.util.spatialrules;
 
 import com.graphhopper.GraphHopper;
 import com.graphhopper.json.geo.JsonFeatureCollection;
-import com.graphhopper.routing.util.DataFlagEncoder;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.FlagEncoderFactory;
+import com.graphhopper.routing.profiles.Country;
+import com.graphhopper.routing.util.parsers.TagParserFactory;
+import com.graphhopper.routing.util.parsers.SpatialRuleParser;
+import com.graphhopper.routing.util.parsers.TagParser;
 import com.graphhopper.util.PMap;
 import com.graphhopper.util.shapes.BBox;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Helper class to build the spatial rule index
+ * Helper class to build the spatial rule index. This is kind of an ugly plugin mechanism to avoid requiring a
+ * jackson dependency on the core.
  *
  * @author Robin Boldt
  */
@@ -22,17 +41,16 @@
     public static void buildAndInjectSpatialRuleIntoGH(GraphHopper graphHopper, BBox maxBounds, JsonFeatureCollection jsonFeatureCollection) {
         final SpatialRuleLookup index = SpatialRuleLookupBuilder.buildIndex(jsonFeatureCollection, "ISO_A3", new CountriesSpatialRuleFactory(), .1, maxBounds);
         logger.info("Set spatial rule lookup with " + index.size() + " rules");
-        final FlagEncoderFactory oldFEF = graphHopper.getFlagEncoderFactory();
-        graphHopper.setFlagEncoderFactory(new FlagEncoderFactory() {
+        final TagParserFactory oldTPF = graphHopper.getTagParserFactory();
+        graphHopper.setTagParserFactory(new TagParserFactory() {
+
             @Override
-            public FlagEncoder createFlagEncoder(String name, PMap configuration) {
-                if (name.equals(GENERIC)) {
-                    return new DataFlagEncoder(configuration).setSpatialRuleLookup(index);
-                }
+            public TagParser create(String name, PMap configuration) {
+                if (name.equals(Country.KEY))
+                    return new SpatialRuleParser(index);
 
-                return oldFEF.createFlagEncoder(name, configuration);
+                return oldTPF.create(name, configuration);
             }
         });
     }
-
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
index 3af5b87f03..a5e262af34 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/AustriaSpatialRule.java
@@ -17,7 +17,8 @@
  */
 package com.graphhopper.routing.util.spatialrules.countries;
 
-import com.graphhopper.routing.util.spatialrules.AccessValue;
+import com.graphhopper.routing.profiles.Country;
+import com.graphhopper.routing.profiles.RoadAccess;
 import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
 import com.graphhopper.routing.util.spatialrules.TransportationMode;
 
@@ -30,7 +31,6 @@
 
     @Override
     public double getMaxSpeed(String highwayTag, double _default) {
-
         // As defined in: https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed#Motorcar
         switch (highwayTag) {
             case "trunk":
@@ -43,17 +43,19 @@ public double getMaxSpeed(String highwayTag, double _default) {
     }
 
     @Override
-    public AccessValue getAccessValue(String highwayTag, TransportationMode transportationMode, AccessValue _default) {
+    public RoadAccess getAccess(String highwayTag, TransportationMode transportationMode, RoadAccess _default) {
         if (transportationMode == TransportationMode.MOTOR_VEHICLE) {
             if (highwayTag.equals("living_street"))
-                return AccessValue.EVENTUALLY_ACCESSIBLE;
+                return RoadAccess.DESTINATION;
+            if (highwayTag.equals("track"))
+                return RoadAccess.FORESTRY;
         }
 
-        return super.getAccessValue(highwayTag, transportationMode, _default);
+        return super.getAccess(highwayTag, transportationMode, _default);
     }
 
     @Override
     public String getId() {
-        return "AUT";
+        return Country.AUT.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
index 210ab08706..04f654fc5e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
+++ b/core/src/main/java/com/graphhopper/routing/util/spatialrules/countries/GermanySpatialRule.java
@@ -17,7 +17,8 @@
  */
 package com.graphhopper.routing.util.spatialrules.countries;
 
-import com.graphhopper.routing.util.spatialrules.AccessValue;
+import com.graphhopper.routing.profiles.Country;
+import com.graphhopper.routing.profiles.RoadAccess;
 import com.graphhopper.routing.util.spatialrules.DefaultSpatialRule;
 import com.graphhopper.routing.util.spatialrules.TransportationMode;
 
@@ -37,7 +38,6 @@ public double getMaxSpeed(String highwayTag, double _default) {
         // As defined in: https://wiki.openstreetmap.org/wiki/OSM_tags_for_routing/Maxspeed#Motorcar
         switch (highwayTag) {
             case "motorway":
-                return Integer.MAX_VALUE;
             case "trunk":
                 return Integer.MAX_VALUE;
             case "residential":
@@ -50,17 +50,17 @@ public double getMaxSpeed(String highwayTag, double _default) {
     }
 
     @Override
-    public AccessValue getAccessValue(String highwayTag, TransportationMode transportationMode, AccessValue _default) {
+    public RoadAccess getAccess(String highwayTag, TransportationMode transportationMode, RoadAccess _default) {
         if (transportationMode == TransportationMode.MOTOR_VEHICLE) {
             if (highwayTag.equals("track"))
-                return AccessValue.EVENTUALLY_ACCESSIBLE;
+                return RoadAccess.DESTINATION;
         }
 
-        return super.getAccessValue(highwayTag, transportationMode, _default);
+        return super.getAccess(highwayTag, transportationMode, _default);
     }
 
     @Override
     public String getId() {
-        return "DEU";
+        return Country.DEU.toString();
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
index 2acc6610ad..160921d85a 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/AbstractWeighting.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.EdgeIteratorState;
@@ -28,6 +30,8 @@
  */
 public abstract class AbstractWeighting implements Weighting {
     protected final FlagEncoder flagEncoder;
+    protected final DecimalEncodedValue avSpeedEnc;
+    protected final BooleanEncodedValue accessEnc;
 
     protected AbstractWeighting(FlagEncoder encoder) {
         this.flagEncoder = encoder;
@@ -35,17 +39,26 @@ protected AbstractWeighting(FlagEncoder encoder) {
             throw new IllegalStateException("Make sure you add the FlagEncoder " + flagEncoder + " to an EncodingManager before using it elsewhere");
         if (!isValidName(getName()))
             throw new IllegalStateException("Not a valid name for a Weighting: " + getName());
+
+        avSpeedEnc = encoder.getAverageSpeedEnc();
+        accessEnc = encoder.getAccessEnc();
     }
 
     @Override
     public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
-        long flags = edgeState.getFlags();
-        if (reverse && !flagEncoder.isBackward(flags)
-                || !reverse && !flagEncoder.isForward(flags))
-            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. "
-                    + "Reverse:" + reverse + ", fwd:" + flagEncoder.isForward(flags) + ", bwd:" + flagEncoder.isBackward(flags));
+        // special case for loop edges: since they do not have a meaningful direction we always need to read them in
+        // forward direction
+        if (edgeState.getBaseNode() == edgeState.getAdjNode()) {
+            reverse = false;
+        }
+
+        if (reverse && !edgeState.getReverse(accessEnc) || !reverse && !edgeState.get(accessEnc))
+            throw new IllegalStateException("Calculating time should not require to read speed from edge in wrong direction. " +
+                    "(" + edgeState.getBaseNode() + " - " + edgeState.getAdjNode() + ") "
+                    + edgeState.fetchWayGeometry(3) + ", dist: " + edgeState.getDistance() + " "
+                    + "Reverse:" + reverse + ", fwd:" + edgeState.get(accessEnc) + ", bwd:" + edgeState.getReverse(accessEnc) + ", fwd-speed: " + edgeState.get(avSpeedEnc) + ", bwd-speed: " + edgeState.getReverse(avSpeedEnc));
 
-        double speed = reverse ? flagEncoder.getReverseSpeed(flags) : flagEncoder.getSpeed(flags);
+        double speed = reverse ? edgeState.getReverse(avSpeedEnc) : edgeState.get(avSpeedEnc);
         if (Double.isInfinite(speed) || Double.isNaN(speed) || speed < 0)
             throw new IllegalStateException("Invalid speed stored in edge! " + speed);
         if (speed == 0)
@@ -56,8 +69,7 @@ public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrN
 
     @Override
     public boolean matches(HintsMap reqMap) {
-        return getName().equals(reqMap.getWeighting())
-                && flagEncoder.toString().equals(reqMap.getVehicle());
+        return getName().equals(reqMap.getWeighting()) && flagEncoder.toString().equals(reqMap.getVehicle());
     }
 
     @Override
@@ -92,8 +104,8 @@ static final boolean isValidName(String name) {
     /**
      * Replaces all characters which are not numbers, characters or underscores with underscores
      */
-    public static String weightingToFileName(Weighting w) {
-        return toLowerCase(w.toString()).replaceAll("\\|", "_");
+    public static String weightingToFileName(Weighting w, boolean edgeBased) {
+        return toLowerCase(w.toString()).replaceAll("\\|", "_") + (edgeBased ? "_edge" : "_node");
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/CurvatureWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/CurvatureWeighting.java
index e37fd6422c..17f9f4b063 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/CurvatureWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/CurvatureWeighting.java
@@ -17,8 +17,9 @@
  */
 package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.MotorcycleFlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 
@@ -27,10 +28,16 @@
  */
 public class CurvatureWeighting extends PriorityWeighting {
     private final double minFactor;
+    private final DecimalEncodedValue priorityEnc;
+    private final DecimalEncodedValue curvatureEnc;
+    private final DecimalEncodedValue avSpeedEnc;
 
     public CurvatureWeighting(FlagEncoder flagEncoder, PMap pMap) {
         super(flagEncoder, pMap);
 
+        priorityEnc = flagEncoder.getDecimalEncodedValue(EncodingManager.getKey(flagEncoder, "priority"));
+        curvatureEnc = flagEncoder.getDecimalEncodedValue(EncodingManager.getKey(flagEncoder, "curvature"));
+        avSpeedEnc = flagEncoder.getDecimalEncodedValue(EncodingManager.getKey(flagEncoder, "average_speed"));
         double minBendiness = 1; // see correctErrors
         double maxPriority = 1; // BEST / BEST
         minFactor = minBendiness / Math.log(flagEncoder.getMaxSpeed()) / (0.5 + maxPriority);
@@ -43,8 +50,8 @@ public double getMinWeight(double distance) {
 
     @Override
     public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
-        double priority = flagEncoder.getDouble(edge.getFlags(), KEY);
-        double bendiness = flagEncoder.getDouble(edge.getFlags(), MotorcycleFlagEncoder.CURVATURE_KEY);
+        double priority = priorityEnc.getDecimal(false, edge.getFlags());
+        double bendiness = curvatureEnc.getDecimal(false, edge.getFlags());
         double speed = getRoadSpeed(edge, reverse);
         double roadDistance = edge.getDistance();
 
@@ -55,7 +62,7 @@ public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNext
     }
 
     protected double getRoadSpeed(EdgeIteratorState edge, boolean reverse) {
-        return reverse ? flagEncoder.getReverseSpeed(edge.getFlags()) : flagEncoder.getSpeed(edge.getFlags());
+        return reverse ? edge.getReverse(avSpeedEnc) : edge.get(avSpeedEnc);
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/FastestWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/FastestWeighting.java
index d16e620cfa..6f29938a68 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/FastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/FastestWeighting.java
@@ -58,14 +58,14 @@ public double getMinWeight(double distance) {
 
     @Override
     public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
-        double speed = reverse ? flagEncoder.getReverseSpeed(edge.getFlags()) : flagEncoder.getSpeed(edge.getFlags());
+        double speed = reverse ? edge.getReverse(avSpeedEnc) : edge.get(avSpeedEnc);
         if (speed == 0)
             return Double.POSITIVE_INFINITY;
 
         double time = edge.getDistance() / speed * SPEED_CONV;
 
         // add direction penalties at start/stop/via points
-        boolean unfavoredEdge = edge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        boolean unfavoredEdge = edge.get(EdgeIteratorState.UNFAVORED_EDGE);
         if (unfavoredEdge)
             time += headingPenalty;
 
@@ -74,9 +74,9 @@ public double calcWeight(EdgeIteratorState edge, boolean reverse, int prevOrNext
 
     @Override
     public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
-        // TODO move this to AbstractWeighting?
+        // TODO move this to AbstractWeighting? see #485
         long time = 0;
-        boolean unfavoredEdge = edgeState.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        boolean unfavoredEdge = edgeState.get(EdgeIteratorState.UNFAVORED_EDGE);
         if (unfavoredEdge)
             time += headingPenaltyMillis;
 
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/GenericWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/GenericWeighting.java
index 5f967ccb9f..833156d897 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/GenericWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/GenericWeighting.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.profiles.*;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
@@ -41,13 +42,18 @@
     protected final double maxSpeed;
     protected final DataFlagEncoder gEncoder;
     protected final DataFlagEncoder.WeightingConfig weightingConfig;
-    protected final int accessType;
     protected final int uncertainAccessiblePenalty = 10;
 
     protected final double height;
     protected final double weight;
     protected final double width;
 
+    private final DecimalEncodedValue carMaxSpeedEnc;
+    private final EnumEncodedValue<RoadAccess> roadAccessEnc;
+    private DecimalEncodedValue maxWeightEnc;
+    private DecimalEncodedValue maxHeightEnc;
+    private DecimalEncodedValue maxWidthEnc;
+
     public GenericWeighting(DataFlagEncoder encoder, PMap hintsMap) {
         super(encoder);
         gEncoder = encoder;
@@ -60,10 +66,18 @@ public GenericWeighting(DataFlagEncoder encoder, PMap hintsMap) {
             throw new IllegalArgumentException("Some specified speed value bigger than maximum possible speed: " + maxSpecifiedSpeed + " > " + encoder.getMaxPossibleSpeed());
 
         this.maxSpeed = maxSpecifiedSpeed / SPEED_CONV;
-        accessType = gEncoder.getAccessType("motor_vehicle");
         height = hintsMap.getDouble(HEIGHT_LIMIT, 0d);
         weight = hintsMap.getDouble(WEIGHT_LIMIT, 0d);
         width = hintsMap.getDouble(WIDTH_LIMIT, 0d);
+        roadAccessEnc = encoder.getEnumEncodedValue(RoadAccess.KEY, RoadAccess.class);
+        carMaxSpeedEnc = encoder.getDecimalEncodedValue(MaxSpeed.KEY);
+
+        if (encoder.hasEncodedValue(MaxWeight.KEY))
+            maxWeightEnc = encoder.getDecimalEncodedValue(MaxWeight.KEY);
+        if (encoder.hasEncodedValue(MaxWidth.KEY))
+            maxWidthEnc = encoder.getDecimalEncodedValue(MaxWidth.KEY);
+        if (encoder.hasEncodedValue(MaxHeight.KEY))
+            maxHeightEnc = encoder.getDecimalEncodedValue(MaxHeight.KEY);
     }
 
     @Override
@@ -75,28 +89,26 @@ public double getMinWeight(double distance) {
     public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         // handle oneways and removed edges via subnetwork removal (existing and allowed highway tags but 'island' edges)
         if (reverse) {
-            if (!gEncoder.isBackward(edgeState, accessType))
+            if (!edgeState.getReverse(accessEnc))
                 return Double.POSITIVE_INFINITY;
-        } else if (!gEncoder.isForward(edgeState, accessType)) {
+        } else if (!edgeState.get(accessEnc)) {
             return Double.POSITIVE_INFINITY;
         }
 
-        if (gEncoder.isStoreHeight() && overLimit(height, gEncoder.getHeight(edgeState))
-                || gEncoder.isStoreWeight() && overLimit(weight, gEncoder.getWeight(edgeState))
-                || gEncoder.isStoreWidth() && overLimit(width, gEncoder.getWidth(edgeState)))
+        if (maxHeightEnc != null && overLimit(height, edgeState.get(maxHeightEnc))
+                || maxWidthEnc != null && overLimit(width, edgeState.get(maxWidthEnc))
+                || maxWeightEnc != null && overLimit(weight, edgeState.get(maxWeightEnc)))
             return Double.POSITIVE_INFINITY;
 
         long time = calcMillis(edgeState, reverse, prevOrNextEdgeId);
         if (time == Long.MAX_VALUE)
             return Double.POSITIVE_INFINITY;
 
-        switch (gEncoder.getAccessValue(edgeState.getFlags())) {
-            case NOT_ACCESSIBLE:
-                return Double.POSITIVE_INFINITY;
-            case EVENTUALLY_ACCESSIBLE:
-                time = time * uncertainAccessiblePenalty;
-        }
-
+        RoadAccess roadAccessEV = edgeState.get(roadAccessEnc);
+        if (roadAccessEV == RoadAccess.NO)
+            return Double.POSITIVE_INFINITY;
+        else if (roadAccessEV != RoadAccess.YES)
+            time = time * uncertainAccessiblePenalty;
         return time;
     }
 
@@ -116,7 +128,7 @@ public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrN
         // TODO inner city guessing -> lit, maxspeed <= 50, residential etc => create new encoder.isInnerCity(edge)
         // See #472 use edge.getDouble((encoder), K_MAXSPEED_MOTORVEHICLE_FORWARD, _default) or edge.getMaxSpeed(...) instead?
         // encoder could be made optional via passing to EdgeExplorer
-        double maxspeed = gEncoder.getMaxspeed(edgeState, accessType, reverse);
+        double maxspeed = reverse ? edgeState.get(carMaxSpeedEnc) : edgeState.getReverse(carMaxSpeedEnc);
         if (maxspeed > 0 && speed > maxspeed)
             speed = maxspeed;
 
@@ -124,7 +136,7 @@ public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrN
         long timeInMillis = (long) (edgeState.getDistance() / speed * SPEED_CONV);
 
         // add direction penalties at start/stop/via points
-        boolean unfavoredEdge = edgeState.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, false);
+        boolean unfavoredEdge = edgeState.get(EdgeIteratorState.UNFAVORED_EDGE);
         if (unfavoredEdge)
             timeInMillis += headingPenaltyMillis;
 
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/PriorityWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/PriorityWeighting.java
index 43bfb2b69a..741d6d03af 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/PriorityWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/PriorityWeighting.java
@@ -17,30 +17,29 @@
  */
 package com.graphhopper.routing.weighting;
 
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.PriorityCode;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PMap;
 
+import static com.graphhopper.routing.util.PriorityCode.BEST;
+
 /**
  * Special weighting for (motor)bike
- * <p>
  *
  * @author Peter Karich
  */
 public class PriorityWeighting extends FastestWeighting {
-    /**
-     * For now used only in BikeCommonFlagEncoder, FootEncoder and MotorcycleFlagEncoder
-     */
-    public static final int KEY = 101;
-    private final double minFactor;
 
-    public PriorityWeighting(FlagEncoder encoder) {
-        this(encoder, new PMap(0));
-    }
+    private final double minFactor;
+    private final DecimalEncodedValue priorityEnc;
 
     public PriorityWeighting(FlagEncoder encoder, PMap pMap) {
         super(encoder, pMap);
-        double maxPriority = 1; // BEST / BEST
+        priorityEnc = encoder.getDecimalEncodedValue(EncodingManager.getKey(encoder, "priority"));
+        double maxPriority = PriorityCode.getFactor(BEST.getValue());
         minFactor = 1 / (0.5 + maxPriority);
     }
 
@@ -54,6 +53,6 @@ public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevO
         double weight = super.calcWeight(edgeState, reverse, prevOrNextEdgeId);
         if (Double.isInfinite(weight))
             return Double.POSITIVE_INFINITY;
-        return weight / (0.5 + flagEncoder.getDouble(edgeState.getFlags(), KEY));
+        return weight / (0.5 + edgeState.get(priorityEnc));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
index 6d0449b93b..eb6a8fc1c1 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/ShortFastestWeighting.java
@@ -55,7 +55,6 @@ public ShortFastestWeighting(FlagEncoder encoder, double distanceFactor) {
 
     @Override
     public double getMinWeight(double distance) {
-        // TODO: Should we add the [+ distance * distanceFactor]. It improves the heuristic of the A*.
         return super.getMinWeight(distance) * timeFactor + distance * distanceFactor;
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
index c55d895c81..81bbce0fe2 100644
--- a/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/weighting/TurnWeighting.java
@@ -38,27 +38,34 @@
     private final TurnCostEncoder turnCostEncoder;
     private final TurnCostExtension turnCostExt;
     private final Weighting superWeighting;
-    private double defaultUTurnCost = 40;
+    private final double uTurnCost;
+
+    public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt) {
+        this(superWeighting, turnCostExt, Double.POSITIVE_INFINITY);
+    }
 
     /**
-     * @param turnCostExt the turn cost storage to be used
+     * @param superWeighting the weighting that is wrapped by this {@link TurnWeighting} and used to calculate the
+     *                       edge weights for example
+     * @param turnCostExt    the turn cost storage to be used
+     * @param uTurnCost      the cost of a u-turn in seconds, this value will be applied to all u-turn costs no matter
+     *                       whether or not turnCostExt contains explicit values for these turns.
      */
-    public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt) {
-        this.turnCostEncoder = (TurnCostEncoder) superWeighting.getFlagEncoder();
+    public TurnWeighting(Weighting superWeighting, TurnCostExtension turnCostExt, double uTurnCost) {
+        this.turnCostEncoder = superWeighting.getFlagEncoder();
         this.superWeighting = superWeighting;
         this.turnCostExt = turnCostExt;
+        this.uTurnCost = uTurnCost;
 
         if (turnCostExt == null)
             throw new RuntimeException("No storage set to calculate turn weight");
     }
 
     /**
-     * Set the default cost for an u-turn in seconds. Default is 40s. Should be that high to avoid
-     * 'tricking' other turn costs or restrictions.
+     * @return the default u-turn cost in seconds
      */
-    public TurnWeighting setDefaultUTurnCost(double costInSeconds) {
-        this.defaultUTurnCost = costInSeconds;
-        return this;
+    public double getUTurnCost() {
+        return uTurnCost;
     }
 
     @Override
@@ -69,18 +76,13 @@ public double getMinWeight(double distance) {
     @Override
     public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         double weight = superWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
-        if (prevOrNextEdgeId == EdgeIterator.NO_EDGE)
+        if (!EdgeIterator.Edge.isValid(prevOrNextEdgeId))
             return weight;
 
-        int edgeId = edgeState.getEdge();
-        double turnCosts;
-        if (reverse)
-            turnCosts = calcTurnWeight(edgeId, edgeState.getBaseNode(), prevOrNextEdgeId);
-        else
-            turnCosts = calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), edgeId);
-
-        if (turnCosts == 0 && edgeId == prevOrNextEdgeId)
-            return weight + defaultUTurnCost;
+        final int origEdgeId = reverse ? edgeState.getOrigEdgeLast() : edgeState.getOrigEdgeFirst();
+        double turnCosts = reverse
+                ? calcTurnWeight(origEdgeId, edgeState.getBaseNode(), prevOrNextEdgeId)
+                : calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), origEdgeId);
 
         return weight + turnCosts;
     }
@@ -88,24 +90,29 @@ public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevO
     @Override
     public long calcMillis(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
         long millis = superWeighting.calcMillis(edgeState, reverse, prevOrNextEdgeId);
-        if (prevOrNextEdgeId == EdgeIterator.NO_EDGE)
+        if (!EdgeIterator.Edge.isValid(prevOrNextEdgeId))
             return millis;
 
-        // TODO for now assume turn costs are returned in milliseconds?
         // should we also separate weighting vs. time for turn? E.g. a fast but dangerous turn - is this common?
-        long turnCostsInMillis;
-        if (reverse)
-            turnCostsInMillis = (long) calcTurnWeight(edgeState.getEdge(), edgeState.getBaseNode(), prevOrNextEdgeId);
-        else
-            turnCostsInMillis = (long) calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), edgeState.getEdge());
+        // todo: why no first/last orig edge here as in calcWeight ?
+        final int origEdgeId = edgeState.getEdge();
+        long turnCostsInSeconds = (long) (reverse
+                ? calcTurnWeight(origEdgeId, edgeState.getBaseNode(), prevOrNextEdgeId)
+                : calcTurnWeight(prevOrNextEdgeId, edgeState.getBaseNode(), origEdgeId));
 
-        return millis + turnCostsInMillis;
+        return millis + 1000 * turnCostsInSeconds;
     }
 
     /**
      * This method calculates the turn weight separately.
      */
     public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
+        if (!EdgeIterator.Edge.isValid(edgeFrom) || !EdgeIterator.Edge.isValid(edgeTo)) {
+            return 0;
+        }
+        if (turnCostExt.isUTurn(edgeFrom, edgeTo)) {
+            return uTurnCost;
+        }
         long turnFlags = turnCostExt.getTurnCostFlags(edgeFrom, nodeVia, edgeTo);
         if (turnCostEncoder.isTurnRestricted(turnFlags))
             return Double.POSITIVE_INFINITY;
diff --git a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
index 34e4d5e827..e5b7cdf08e 100644
--- a/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/AbstractDataAccess.java
@@ -40,9 +40,9 @@
     protected int header[] = new int[(HEADER_OFFSET - 20) / 4];
     protected String name;
     protected int segmentSizeInBytes = SEGMENT_SIZE_DEFAULT;
-    protected transient int segmentSizePower;
-    protected transient int indexDivisor;
-    protected transient boolean closed = false;
+    protected int segmentSizePower;
+    protected int indexDivisor;
+    protected boolean closed = false;
 
     public AbstractDataAccess(String name, String location, ByteOrder order) {
         byteOrder = order;
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 2adbf52393..9a2fc5b89c 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -20,20 +20,20 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.coll.SparseIntIntArray;
+import com.graphhopper.routing.profiles.*;
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.search.NameIndex;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
-import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import static com.graphhopper.util.Helper.nf;
-
 import java.util.Locale;
 
+import static com.graphhopper.util.EdgeIteratorState.REVERSE_STATE;
+import static com.graphhopper.util.Helper.nf;
+
 /**
  * The base graph handles nodes and edges file format. It can be used with different Directory
  * implementations like RAMDirectory for fast access or via MMapDirectory for virtual-memory and not
@@ -55,6 +55,7 @@
     final BitUtil bitUtil;
     final EncodingManager encodingManager;
     final EdgeAccess edgeAccess;
+    private final int bytesForFlags;
     // length | nodeA | nextNode | ... | nodeB
     // as we use integer index in 'egdes' area => 'geometry' area is limited to 4GB (we use pos&neg values!)
     private final DataAccess wayGeometry;
@@ -91,13 +92,14 @@ public BaseGraph(Directory dir, final EncodingManager encodingManager, boolean w
                      InternalGraphEventListener listener, GraphExtension extendedStorage) {
         this.dir = dir;
         this.encodingManager = encodingManager;
+        this.bytesForFlags = encodingManager.getBytesForFlags();
         this.bitUtil = BitUtil.get(dir.getByteOrder());
         this.wayGeometry = dir.find("geometry");
         this.nameIndex = new NameIndex(dir);
-        this.nodes = dir.find("nodes");
-        this.edges = dir.find("edges");
+        this.nodes = dir.find("nodes", DAType.getPreferredInt(dir.getDefaultType()));
+        this.edges = dir.find("edges", DAType.getPreferredInt(dir.getDefaultType()));
         this.listener = listener;
-        this.edgeAccess = new EdgeAccess(edges, bitUtil) {
+        this.edgeAccess = new EdgeAccess(edges) {
             @Override
             final EdgeIterable createSingleEdge(EdgeFilter filter) {
                 return new EdgeIterable(BaseGraph.this, this, filter);
@@ -129,11 +131,6 @@ final boolean isInBounds(int edgeId) {
                 return edgeId < edgeCount && edgeId >= 0;
             }
 
-            @Override
-            final long reverseFlags(long edgePointer, long flags) {
-                return encodingManager.reverseFlags(flags);
-            }
-
             @Override
             public String toString() {
                 return "base edge access";
@@ -223,14 +220,12 @@ protected int setWayGeometryHeader() {
     void initStorage() {
         edgeEntryIndex = 0;
         nodeEntryIndex = 0;
-        boolean flagsSizeIsLong = encodingManager.getBytesForFlags() == 8;
         edgeAccess.init(nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(4),
                 nextEdgeEntryIndex(4),
-                nextEdgeEntryIndex(encodingManager.getBytesForFlags()),
-                flagsSizeIsLong);
+                nextEdgeEntryIndex(encodingManager.getBytesForFlags()));
 
         E_GEO = nextEdgeEntryIndex(4);
         E_NAME = nextEdgeEntryIndex(4);
@@ -313,6 +308,11 @@ public int getNodes() {
         return nodeCount;
     }
 
+    @Override
+    public int getEdges() {
+        return getAllEdges().length();
+    }
+
     @Override
     public NodeAccess getNodeAccess() {
         return nodeAccess;
@@ -392,14 +392,17 @@ public void debugPrint() {
         System.out.println("edges:");
         String formatEdges = "%12s | %12s | %12s | %12s | %12s | %12s | %12s \n";
         System.out.format(Locale.ROOT, formatEdges, "#", "E_NODEA", "E_NODEB", "E_LINKA", "E_LINKB", "E_DIST", "E_FLAGS");
+        IntsRef intsRef = new IntsRef(bytesForFlags / 4);
         for (int i = 0; i < Math.min(edgeCount, printMax); ++i) {
+            long edgePointer = edgeAccess.toPointer(i);
+            edgeAccess.readFlags(edgePointer, intsRef);
             System.out.format(Locale.ROOT, formatEdges, i,
-                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_NODEA),
-                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_NODEB),
-                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_LINKA),
-                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_LINKB),
-                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_DIST),
-                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_FLAGS));
+                    edgeAccess.getNodeA(edgePointer),
+                    edgeAccess.getNodeB(edgePointer),
+                    edgeAccess.getLinkA(edgePointer),
+                    edgeAccess.getLinkB(edgePointer),
+                    edgeAccess.getDist(edgePointer),
+                    intsRef);
         }
         if (edgeCount > printMax) {
             System.out.printf(Locale.ROOT, " ... %d more edges", edgeCount - printMax);
@@ -465,12 +468,26 @@ void loadExisting(String dim) {
     }
 
     /**
-     * @return to
+     * This method copies the properties of one {@link EdgeIteratorState} to another.
+     *
+     * @return the updated iterator the properties where copied to.
      */
-    EdgeIteratorState copyProperties(CommonEdgeIterator from, EdgeIteratorState to) {
+    EdgeIteratorState copyProperties(EdgeIteratorState from, CommonEdgeIterator to) {
+        boolean reverse = from.get(REVERSE_STATE);
+        if (to.reverse)
+            reverse = !reverse;
+        // in case reverse is true we have to swap the nodes to store flags correctly in its "storage direction"
+        int nodeA = reverse ? from.getAdjNode() : from.getBaseNode();
+        int nodeB = reverse ? from.getBaseNode() : from.getAdjNode();
+        long edgePointer = edgeAccess.toPointer(to.getEdge());
+        int linkA = reverse ? edgeAccess.getLinkB(edgePointer) : edgeAccess.getLinkA(edgePointer);
+        int linkB = reverse ? edgeAccess.getLinkA(edgePointer) : edgeAccess.getLinkB(edgePointer);
+        edgeAccess.writeEdge(to.getEdge(), nodeA, nodeB, linkA, linkB);
+        edgeAccess.writeFlags(edgePointer, from.getFlags());
+
+        // copy the rest with higher level API
         to.setDistance(from.getDistance()).
                 setName(from.getName()).
-                setFlags(from.getDirectFlags()).
                 setWayGeometry(from.fetchWayGeometry(0));
 
         if (E_ADDITIONAL >= 0)
@@ -480,7 +497,6 @@ EdgeIteratorState copyProperties(CommonEdgeIterator from, EdgeIteratorState to)
 
     /**
      * Create edge between nodes a and b
-     * <p>
      *
      * @return EdgeIteratorState of newly created edge
      */
@@ -507,7 +523,6 @@ void setEdgeCount(int cnt) {
 
     /**
      * Determine next free edgeId and ensure byte capacity to store edge
-     * <p>
      *
      * @return next free edgeId
      */
@@ -622,9 +637,8 @@ void inPlaceNodeRemove(int removeNodeCount) {
         GHBitSet toRemoveSet = new GHBitSetImpl(removeNodeCount);
         removedNodes.copyTo(toRemoveSet);
 
-        Logger logger = LoggerFactory.getLogger(getClass());
         if (removeNodeCount > getNodes() / 2.0)
-            logger.warn("More than a half of the network should be removed!? "
+            LoggerFactory.getLogger(getClass()).warn("More than a half of the network should be removed!? "
                     + "Nodes:" + getNodes() + ", remove:" + removeNodeCount);
 
         EdgeExplorer delExplorer = createEdgeExplorer();
@@ -638,6 +652,7 @@ void inPlaceNodeRemove(int removeNodeCount) {
             }
 
             toMoveNodes--;
+            // move only nodes that are not removed
             for (; toMoveNodes >= 0; toMoveNodes--) {
                 if (!removedNodes.contains(toMoveNodes))
                     break;
@@ -657,17 +672,17 @@ void inPlaceNodeRemove(int removeNodeCount) {
              removeNode = toRemoveSet.next(removeNode + 1)) {
             // remove all edges connected to the deleted nodes
             adjNodesToDelIter.setBaseNode(removeNode);
-            long prev = EdgeIterator.NO_EDGE;
+            long prevPointer = EdgeIterator.NO_EDGE;
             while (adjNodesToDelIter.next()) {
                 int nodeId = adjNodesToDelIter.getAdjNode();
                 // already invalidated
-                if (nodeId != EdgeAccess.NO_NODE && removedNodes.contains(nodeId)) {
+                if (!EdgeAccess.isInvalidNodeB(nodeId) && removedNodes.contains(nodeId)) {
                     int edgeToRemove = adjNodesToDelIter.getEdge();
                     long edgeToRemovePointer = edgeAccess.toPointer(edgeToRemove);
-                    edgeAccess.internalEdgeDisconnect(edgeToRemove, prev, removeNode, nodeId);
+                    edgeAccess.internalEdgeDisconnect(edgeToRemove, prevPointer, removeNode);
                     edgeAccess.invalidateEdge(edgeToRemovePointer);
                 } else {
-                    prev = adjNodesToDelIter.edgePointer;
+                    prevPointer = adjNodesToDelIter.edgePointer;
                 }
             }
         }
@@ -680,11 +695,11 @@ void inPlaceNodeRemove(int removeNodeCount) {
             EdgeIterator movedEdgeIter = movedEdgeExplorer.setBaseNode(oldI);
             while (movedEdgeIter.next()) {
                 int nodeId = movedEdgeIter.getAdjNode();
-                if (nodeId == EdgeAccess.NO_NODE)
+                if (EdgeAccess.isInvalidNodeB(nodeId))
                     continue;
 
                 if (removedNodes.contains(nodeId))
-                    throw new IllegalStateException("shouldn't happen the edge to the node "
+                    throw new IllegalStateException("shouldn't happen as the edge to the node "
                             + nodeId + " should be already deleted. " + oldI);
 
                 toMoveSet.add(nodeId);
@@ -713,7 +728,6 @@ void inPlaceNodeRemove(int removeNodeCount) {
                 continue;
 
             // now overwrite exiting edge with new node ids
-            // also flags and links could have changed due to different node order
             int updatedA = oldToNewMap.get(nodeA);
             if (updatedA < 0)
                 updatedA = nodeA;
@@ -722,15 +736,12 @@ void inPlaceNodeRemove(int removeNodeCount) {
             if (updatedB < 0)
                 updatedB = nodeB;
 
+            // no need to rewrite flags or other properties as they are independent of the node order unlike in <= 0.11
             int edgeId = iter.getEdge();
             long edgePointer = edgeAccess.toPointer(edgeId);
-            int linkA = edgeAccess.getEdgeRef(nodeA, nodeB, edgePointer);
-            int linkB = edgeAccess.getEdgeRef(nodeB, nodeA, edgePointer);
-            long flags = edgeAccess.getFlags_(edgePointer, false);
+            int linkA = edgeAccess.getLinkA(edgePointer);
+            int linkB = edgeAccess.getLinkB(edgePointer);
             edgeAccess.writeEdge(edgeId, updatedA, updatedB, linkA, linkB);
-            edgeAccess.setFlags_(edgePointer, updatedA > updatedB, flags);
-            if (updatedA < updatedB != nodeA < nodeB)
-                setWayGeometry_(fetchWayGeometry_(edgePointer, true, 0, -1, -1), edgePointer, false);
         }
 
         if (removeNodeCount >= nodeCount)
@@ -783,6 +794,18 @@ public GraphExtension getExtension() {
         return extStorage;
     }
 
+    @Override
+    public int getOtherNode(int edge, int node) {
+        long edgePointer = edgeAccess.toPointer(edge);
+        return edgeAccess.getOtherNode(node, edgePointer);
+    }
+
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        long edgePointer = edgeAccess.toPointer(edge);
+        return edgeAccess.isAdjacentToNode(node, edgePointer);
+    }
+
     public void setAdditionalEdgeField(long edgePointer, int value) {
         if (extStorage.isRequireEdgeField() && E_ADDITIONAL >= 0)
             edges.setInt(edgePointer + E_ADDITIONAL, value);
@@ -942,19 +965,21 @@ final void setEdgeId(int edgeId) {
             this.nextEdgeId = this.edgeId = edgeId;
         }
 
+        /**
+         * @return false if the edge has not a node equal to expectedAdjNode
+         */
         final boolean init(int tmpEdgeId, int expectedAdjNode) {
             setEdgeId(tmpEdgeId);
-            if (tmpEdgeId != EdgeIterator.NO_EDGE) {
-                selectEdgeAccess();
-                this.edgePointer = edgeAccess.toPointer(tmpEdgeId);
-            }
-
-            // expect only edgePointer is properly initialized via setEdgeId            
-            baseNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEA);
-            if (baseNode == EdgeAccess.NO_NODE)
+            if (!EdgeIterator.Edge.isValid(edgeId))
+                throw new IllegalArgumentException("fetching the edge requires a valid edgeId but was " + edgeId);
+
+            selectEdgeAccess();
+            edgePointer = edgeAccess.toPointer(tmpEdgeId);
+            baseNode = edgeAccess.getNodeA(edgePointer);
+            adjNode = edgeAccess.getNodeB(edgePointer);
+            if (EdgeAccess.isInvalidNodeB(adjNode))
                 throw new IllegalStateException("content of edgeId " + edgeId + " is marked as invalid - ie. the edge is already removed!");
 
-            adjNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEB);
             // a next() call should return false
             nextEdgeId = EdgeIterator.NO_EDGE;
             if (expectedAdjNode == adjNode || expectedAdjNode == Integer.MIN_VALUE) {
@@ -987,18 +1012,20 @@ protected void selectEdgeAccess() {
         @Override
         public final boolean next() {
             while (true) {
-                if (nextEdgeId == EdgeIterator.NO_EDGE)
+                if (!EdgeIterator.Edge.isValid(nextEdgeId))
                     return false;
 
                 selectEdgeAccess();
                 edgePointer = edgeAccess.toPointer(nextEdgeId);
                 edgeId = nextEdgeId;
-                adjNode = edgeAccess.getOtherNode(baseNode, edgePointer);
-                reverse = baseNode > adjNode;
+                int nodeA = edgeAccess.getNodeA(edgePointer);
+                boolean baseNodeIsNodeA = baseNode == nodeA;
+                adjNode = baseNodeIsNodeA ? edgeAccess.getNodeB(edgePointer) : nodeA;
+                reverse = !baseNodeIsNodeA;
                 freshFlags = false;
 
-                // position to next edge                
-                nextEdgeId = edgeAccess.getEdgeRef(baseNode, adjNode, edgePointer);
+                // position to next edge
+                nextEdgeId = baseNodeIsNodeA ? edgeAccess.getLinkA(edgePointer) : edgeAccess.getLinkB(edgePointer);
                 assert nextEdgeId != edgeId : ("endless loop detected for base node: " + baseNode + ", adj node: " + adjNode
                         + ", edge pointer: " + edgePointer + ", edge: " + edgeId);
 
@@ -1009,7 +1036,7 @@ public final boolean next() {
 
         @Override
         public EdgeIteratorState detach(boolean reverseArg) {
-            if (edgeId == nextEdgeId || edgeId == EdgeIterator.NO_EDGE)
+            if (edgeId == nextEdgeId || !EdgeIterator.Edge.isValid(edgeId))
                 throw new IllegalStateException("call next before detaching or setEdgeId (edgeId:" + edgeId + " vs. next " + nextEdgeId + ")");
 
             EdgeIterable iter = edgeAccess.createSingleEdge(filter);
@@ -1050,14 +1077,13 @@ public boolean next() {
                 if (!checkRange())
                     return false;
 
-                baseNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEA);
-                // some edges are deleted and have a negative node
-                if (baseNode == EdgeAccess.NO_NODE)
+                adjNode = edgeAccess.getNodeB(edgePointer);
+                // some edges are deleted and are marked via a negative node
+                if (EdgeAccess.isInvalidNodeB(adjNode))
                     continue;
 
+                baseNode = edgeAccess.getNodeA(edgePointer);
                 freshFlags = false;
-                adjNode = edgeAccess.edges.getInt(edgePointer + edgeAccess.E_NODEB);
-                // this is always false because of 'getBaseNode() <= getAdjNode()'
                 reverse = false;
                 return true;
             }
@@ -1093,20 +1119,22 @@ public final EdgeIteratorState detach(boolean reverseArg) {
      */
     static abstract class CommonEdgeIterator implements EdgeIteratorState {
         final BaseGraph baseGraph;
-        protected long edgePointer;
-        protected int baseNode;
-        protected int adjNode;
-        protected EdgeAccess edgeAccess;
+        long edgePointer;
+        int baseNode;
+        int adjNode;
+        EdgeAccess edgeAccess;
         // we need reverse if detach is called
         boolean reverse = false;
         boolean freshFlags;
         int edgeId = -1;
-        private long cachedFlags;
+        private final IntsRef baseIntsRef;
+        int chFlags;
 
         public CommonEdgeIterator(long edgePointer, EdgeAccess edgeAccess, BaseGraph baseGraph) {
             this.edgePointer = edgePointer;
             this.edgeAccess = edgeAccess;
             this.baseGraph = baseGraph;
+            this.baseIntsRef = new IntsRef(baseGraph.bytesForFlags / 4);
         }
 
         @Override
@@ -1130,23 +1158,22 @@ public final EdgeIteratorState setDistance(double dist) {
             return this;
         }
 
-        final long getDirectFlags() {
+        @Override
+        public IntsRef getFlags() {
             if (!freshFlags) {
-                cachedFlags = edgeAccess.getFlags_(edgePointer, reverse);
+                edgeAccess.readFlags(edgePointer, baseIntsRef);
                 freshFlags = true;
             }
-            return cachedFlags;
+            return baseIntsRef;
         }
 
         @Override
-        public long getFlags() {
-            return getDirectFlags();
-        }
-
-        @Override
-        public final EdgeIteratorState setFlags(long fl) {
-            edgeAccess.setFlags_(edgePointer, reverse, fl);
-            cachedFlags = fl;
+        public final EdgeIteratorState setFlags(IntsRef edgeFlags) {
+            assert edgeId < baseGraph.edgeCount : "must be edge but was shortcut: " + edgeId + " >= " + baseGraph.edgeCount + ". Use setFlagsAndWeight";
+            edgeAccess.writeFlags(edgePointer, edgeFlags);
+            for (int i = 0; i < edgeFlags.ints.length; i++) {
+                baseIntsRef.ints[i] = edgeFlags.ints[i];
+            }
             freshFlags = true;
             return this;
         }
@@ -1163,24 +1190,104 @@ public final EdgeIteratorState setAdditionalField(int value) {
         }
 
         @Override
-        public final EdgeIteratorState copyPropertiesTo(EdgeIteratorState edge) {
-            return baseGraph.copyProperties(this, edge);
+        public boolean get(BooleanEncodedValue property) {
+            return property.getBool(reverse, getFlags());
         }
 
-        /**
-         * Reports whether the edge is available in forward direction for the specified encoder.
-         */
         @Override
-        public boolean isForward(FlagEncoder encoder) {
-            return encoder.isForward(getDirectFlags());
+        public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
+            property.setBool(reverse, getFlags(), value);
+            edgeAccess.writeFlags(edgePointer, getFlags());
+            return this;
+        }
+
+        @Override
+        public boolean getReverse(BooleanEncodedValue property) {
+            return property.getBool(!reverse, getFlags());
+        }
+
+        @Override
+        public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+            property.setBool(!reverse, getFlags(), value);
+            edgeAccess.writeFlags(edgePointer, getFlags());
+            return this;
+        }
+
+        @Override
+        public int get(IntEncodedValue property) {
+            return property.getInt(reverse, getFlags());
+        }
+
+        @Override
+        public EdgeIteratorState set(IntEncodedValue property, int value) {
+            property.setInt(reverse, getFlags(), value);
+            edgeAccess.writeFlags(edgePointer, getFlags());
+            return this;
+        }
+
+        @Override
+        public int getReverse(IntEncodedValue property) {
+            return property.getInt(!reverse, getFlags());
+        }
+
+        @Override
+        public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+            property.setInt(!reverse, getFlags(), value);
+            edgeAccess.writeFlags(edgePointer, getFlags());
+            return this;
+        }
+
+        @Override
+        public double get(DecimalEncodedValue property) {
+            return property.getDecimal(reverse, getFlags());
         }
 
-        /**
-         * Reports whether the edge is available in backward direction for the specified encoder.
-         */
         @Override
-        public boolean isBackward(FlagEncoder encoder) {
-            return encoder.isBackward(getDirectFlags());
+        public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+            property.setDecimal(reverse, getFlags(), value);
+            edgeAccess.writeFlags(edgePointer, getFlags());
+            return this;
+        }
+
+        @Override
+        public double getReverse(DecimalEncodedValue property) {
+            return property.getDecimal(!reverse, getFlags());
+        }
+
+        @Override
+        public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+            property.setDecimal(!reverse, getFlags(), value);
+            edgeAccess.writeFlags(edgePointer, getFlags());
+            return this;
+        }
+
+        @Override
+        public <T extends Enum> T get(EnumEncodedValue<T> property) {
+            return property.getEnum(reverse, getFlags());
+        }
+
+        @Override
+        public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+            property.setEnum(reverse, getFlags(), value);
+            edgeAccess.writeFlags(edgePointer, getFlags());
+            return this;
+        }
+
+        @Override
+        public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+            return property.getEnum(!reverse, getFlags());
+        }
+
+        @Override
+        public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
+            property.setEnum(!reverse, getFlags(), value);
+            edgeAccess.writeFlags(edgePointer, getFlags());
+            return this;
+        }
+
+        @Override
+        public final EdgeIteratorState copyPropertiesFrom(EdgeIteratorState edge) {
+            return baseGraph.copyProperties(edge, this);
         }
 
         @Override
@@ -1199,6 +1306,16 @@ public int getEdge() {
             return edgeId;
         }
 
+        @Override
+        public int getOrigEdgeFirst() {
+            return getEdge();
+        }
+
+        @Override
+        public int getOrigEdgeLast() {
+            return getEdge();
+        }
+
         @Override
         public String getName() {
             int nameIndexRef = baseGraph.edges.getInt(edgePointer + baseGraph.E_NAME);
@@ -1211,12 +1328,6 @@ public EdgeIteratorState setName(String name) {
             return this;
         }
 
-        @Override
-        public final boolean getBool(int key, boolean _default) {
-            // for non-existent keys return default
-            return _default;
-        }
-
         @Override
         public final String toString() {
             return getEdge() + " " + getBaseNode() + "-" + getAdjNode();
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraph.java b/core/src/main/java/com/graphhopper/storage/CHGraph.java
index c36a9ffdd7..6ef50906ce 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraph.java
@@ -17,20 +17,23 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.ch.NodeOrderingProvider;
 import com.graphhopper.routing.util.AllCHEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.util.CHEdgeExplorer;
 import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
 
 /**
  * Extended graph interface which supports Contraction Hierarchies. Ie. storing and retrieving the
  * levels for a node and creating shortcuts, which are additional 'artificial' edges to speedup
  * traversal in certain cases.
- * <p>
  *
  * @author Peter Karich
  */
 public interface CHGraph extends Graph {
+
     /**
      * This methods sets the level of the specified node.
      */
@@ -50,6 +53,10 @@
      */
     CHEdgeIteratorState shortcut(int a, int b);
 
+    int shortcut(int a, int b, int accessFlags, double weight, double distance, int skippedEdge1, int skippedEdge2);
+
+    int shortcutEdgeBased(int a, int b, int accessFlags, double weight, double distance, int skippedEdge1, int skippedEdge2, int origFirst, int origLast);
+
     @Override
     CHEdgeIteratorState getEdgeIteratorState(int edgeId, int endNode);
 
@@ -59,6 +66,32 @@
     @Override
     CHEdgeExplorer createEdgeExplorer(EdgeFilter filter);
 
+    EdgeExplorer createOriginalEdgeExplorer();
+
+    EdgeExplorer createOriginalEdgeExplorer(EdgeFilter filter);
+
     @Override
     AllCHEdgesIterator getAllEdges();
+
+    /**
+     * Disconnects the edges (higher to lower node) via the specified edgeState pointing from lower to
+     * higher node.
+     * <p>
+     *
+     * @param edgeState the edge from lower to higher
+     */
+    void disconnect(CHEdgeExplorer edgeExplorer, EdgeIteratorState edgeState);
+
+    /**
+     * @return the number of original edges in this graph (without shortcuts)
+     */
+    int getOriginalEdges();
+
+    NodeOrderingProvider getNodeOrderingProvider();
+
+    /**
+     * @return true if contraction can be started (add shortcuts and set levels), false otherwise
+     */
+    boolean isReadyForContraction();
+
 }
diff --git a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
index aef56b34ab..a8bbe1c3ad 100644
--- a/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
+++ b/core/src/main/java/com/graphhopper/storage/CHGraphImpl.java
@@ -17,20 +17,22 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.ch.NodeOrderingProvider;
 import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.AllCHEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.AbstractWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.BaseGraph.AllEdgeIterator;
-import com.graphhopper.storage.BaseGraph.CommonEdgeIterator;
 import com.graphhopper.storage.BaseGraph.EdgeIterable;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.Locale;
+
 import static com.graphhopper.util.Helper.nf;
 
 /**
@@ -43,15 +45,16 @@
 public class CHGraphImpl implements CHGraph, Storable<CHGraph> {
     private static final Logger LOGGER = LoggerFactory.getLogger(CHGraphImpl.class);
     private static final double WEIGHT_FACTOR = 1000f;
-    // 2 bits for access, for now only 32bit => not Long.MAX
-    private static final long MAX_WEIGHT_LONG = (Integer.MAX_VALUE >> 2) << 2;
+    // 2 bits for access, 29 bits for weight (See #1544 on how to improve this to 30 bits)
+    private static final int MAX_WEIGHT_31 = (Integer.MAX_VALUE >> 2) << 2;
     private static final double MAX_WEIGHT = (Integer.MAX_VALUE >> 2) / WEIGHT_FACTOR;
     private static final double MIN_WEIGHT = 1 / WEIGHT_FACTOR;
     final DataAccess shortcuts;
     final DataAccess nodesCH;
-    final long scDirMask = PrepareEncoder.getScDirMask();
+    final int scDirMask = PrepareEncoder.getScDirMask();
+    private final boolean edgeBased;
     private final BaseGraph baseGraph;
-    private final EdgeAccess chEdgeAccess;
+    private final CHEdgeAccess chEdgeAccess;
     private final Weighting weighting;
     int N_CH_REF;
     int shortcutEntryBytes;
@@ -59,71 +62,21 @@
     int nodeCHEntryBytes;
     private int N_LEVEL;
     // shortcut memory layout is synced with edges indices until E_FLAGS, then:
-    private int S_SKIP_EDGE1, S_SKIP_EDGE2;
+    private int S_SKIP_EDGE1, S_SKIP_EDGE2, S_ORIG_FIRST, S_ORIG_LAST;
     private int shortcutCount = 0;
+    private boolean isReadyForContraction;
 
-    CHGraphImpl(Weighting w, Directory dir, final BaseGraph baseGraph) {
+    CHGraphImpl(Weighting w, Directory dir, final BaseGraph baseGraph, boolean edgeBased) {
         if (w == null)
             throw new IllegalStateException("Weighting for CHGraph cannot be null");
 
         this.weighting = w;
         this.baseGraph = baseGraph;
-        final String name = AbstractWeighting.weightingToFileName(w);
-        this.nodesCH = dir.find("nodes_ch_" + name);
-        this.shortcuts = dir.find("shortcuts_" + name);
-        this.chEdgeAccess = new EdgeAccess(shortcuts, baseGraph.bitUtil) {
-            @Override
-            final EdgeIterable createSingleEdge(EdgeFilter edgeFilter) {
-                return new CHEdgeIteratorImpl(baseGraph, this, edgeFilter);
-            }
-
-            @Override
-            final int getEdgeRef(int nodeId) {
-                return nodesCH.getInt((long) nodeId * nodeCHEntryBytes + N_CH_REF);
-            }
-
-            @Override
-            final void setEdgeRef(int nodeId, int edgeId) {
-                nodesCH.setInt((long) nodeId * nodeCHEntryBytes + N_CH_REF, edgeId);
-            }
-
-            @Override
-            final int getEntryBytes() {
-                return shortcutEntryBytes;
-            }
-
-            @Override
-            final long toPointer(int shortcutId) {
-                assert isInBounds(shortcutId) : "shortcutId " + shortcutId + " not in bounds [" + baseGraph.edgeCount + ", " + (baseGraph.edgeCount + shortcutCount) + ")";
-                return (long) (shortcutId - baseGraph.edgeCount) * shortcutEntryBytes;
-            }
-
-            @Override
-            final boolean isInBounds(int shortcutId) {
-                int tmp = shortcutId - baseGraph.edgeCount;
-                return tmp < shortcutCount && tmp >= 0;
-            }
-
-            @Override
-            final long reverseFlags(long edgePointer, long flags) {
-                boolean isShortcut = edgePointer >= toPointer(baseGraph.edgeCount);
-                if (!isShortcut)
-                    return baseGraph.edgeAccess.reverseFlags(edgePointer, flags);
-
-                // we need a special swapping for CHGraph if it is a shortcut as we only store the weight and access flags then
-                long dir = flags & scDirMask;
-                if (dir == scDirMask || dir == 0)
-                    return flags;
-
-                // swap the last bits with this mask
-                return flags ^ scDirMask;
-            }
-
-            @Override
-            public String toString() {
-                return "ch edge access " + name;
-            }
-        };
+        final String name = AbstractWeighting.weightingToFileName(w, edgeBased);
+        this.edgeBased = edgeBased;
+        this.nodesCH = dir.find("nodes_ch_" + name, DAType.getPreferredInt(dir.getDefaultType()));
+        this.shortcuts = dir.find("shortcuts_" + name, DAType.getPreferredInt(dir.getDefaultType()));
+        this.chEdgeAccess = new CHEdgeAccess(name);
     }
 
     public final Weighting getWeighting() {
@@ -168,6 +121,31 @@ public CHEdgeIteratorState shortcut(int a, int b) {
         return iter;
     }
 
+    @Override
+    public int shortcut(int a, int b, int accessFlags, double weight, double distance, int skippedEdge1, int skippedEdge2) {
+        if (!baseGraph.isFrozen())
+            throw new IllegalStateException("Cannot create shortcut if graph is not yet frozen");
+
+        checkNodeId(a);
+        checkNodeId(b);
+
+        int scId = chEdgeAccess.internalEdgeAdd(nextShortcutId(), a, b);
+        // do not create CHEdgeIteratorImpl object
+        long edgePointer = chEdgeAccess.toPointer(scId);
+        chEdgeAccess.setAccessAndWeight(edgePointer, accessFlags & scDirMask, weight);
+        chEdgeAccess.setDist(edgePointer, distance);
+        chEdgeAccess.setSkippedEdges(edgePointer, skippedEdge1, skippedEdge2);
+        return scId;
+    }
+
+    @Override
+    public int shortcutEdgeBased(int a, int b, int accessFlags, double weight, double distance, int skippedEdge1, int skippedEdge2, int origFirst, int origLast) {
+        assert edgeBased : "Edge-based shortcuts should only be added when CHGraph is edge-based";
+        int scId = shortcut(a, b, accessFlags, weight, distance, skippedEdge1, skippedEdge2);
+        chEdgeAccess.setFirstAndLastOrigEdges(chEdgeAccess.toPointer(scId), origFirst, origLast);
+        return scId;
+    }
+
     protected int nextShortcutId() {
         int nextSC = shortcutCount;
         shortcutCount++;
@@ -204,6 +182,16 @@ public CHEdgeExplorer createEdgeExplorer(EdgeFilter filter) {
         return new CHEdgeIteratorImpl(baseGraph, chEdgeAccess, filter);
     }
 
+    @Override
+    public EdgeExplorer createOriginalEdgeExplorer() {
+        return createOriginalEdgeExplorer(EdgeFilter.ALL_EDGES);
+    }
+
+    @Override
+    public EdgeExplorer createOriginalEdgeExplorer(EdgeFilter filter) {
+        return baseGraph.createEdgeExplorer(filter);
+    }
+
     @Override
     public final CHEdgeIteratorState getEdgeIteratorState(int edgeId, int endNode) {
         if (isShortcut(edgeId)) {
@@ -220,6 +208,16 @@ public int getNodes() {
         return baseGraph.getNodes();
     }
 
+    @Override
+    public int getEdges() {
+        return getAllEdges().length();
+    }
+
+    @Override
+    public int getOriginalEdges() {
+        return baseGraph.getEdges();
+    }
+
     @Override
     public NodeAccess getNodeAccess() {
         return baseGraph.getNodeAccess();
@@ -230,7 +228,29 @@ public BBox getBounds() {
         return baseGraph.getBounds();
     }
 
-    void _freeze() {
+    @Override
+    public boolean isReadyForContraction() {
+        return isReadyForContraction;
+    }
+
+    @Override
+    public int getOtherNode(int edge, int node) {
+        EdgeAccess edgeAccess = isShortcut(edge) ? chEdgeAccess : baseGraph.edgeAccess;
+        long edgePointer = edgeAccess.toPointer(edge);
+        return edgeAccess.getOtherNode(node, edgePointer);
+    }
+
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        EdgeAccess edgeAccess = isShortcut(edge) ? chEdgeAccess : baseGraph.edgeAccess;
+        long edgePointer = edgeAccess.toPointer(edge);
+        return edgeAccess.isAdjacentToNode(node, edgePointer);
+    }
+
+    void _prepareForContraction() {
+        if (isReadyForContraction) {
+            return;
+        }
         long maxCapacity = ((long) getNodes()) * nodeCHEntryBytes;
         nodesCH.ensureCapacity(maxCapacity);
         long baseCapacity = baseGraph.nodes.getCapacity();
@@ -245,31 +265,27 @@ void _freeze() {
 
             nodesCH.setInt(pointer, baseGraph.nodes.getInt(basePointer));
         }
+        isReadyForContraction = true;
     }
 
     String toDetailsString() {
         return toString() + ", shortcuts:" + nf(shortcutCount) + ", nodesCH:(" + nodesCH.getCapacity() / Helper.MB + "MB)";
     }
 
-    /**
-     * Disconnects the edges (higher to lower node) via the specified edgeState pointing from lower to
-     * higher node.
-     * <p>
-     *
-     * @param edgeState the edge from lower to higher
-     */
+    @Override
     public void disconnect(CHEdgeExplorer explorer, EdgeIteratorState edgeState) {
         // search edge with opposite direction but we need to know the previousEdge for the internalEdgeDisconnect so we cannot simply do:
-        // EdgeIteratorState tmpIter = getEdgeProps(iter.getEdge(), iter.getBaseNode());
+        // EdgeIteratorState tmpIter = getEdgeIteratorState(iter.getEdge(), iter.getBaseNode());
         CHEdgeIterator tmpIter = explorer.setBaseNode(edgeState.getAdjNode());
         int tmpPrevEdge = EdgeIterator.NO_EDGE;
         while (tmpIter.next()) {
+            // note that we do not disconnect original edges, because we are re-using the base graph for different profiles,
+            // even though this is not optimal from a speed performance point of view.
             if (tmpIter.isShortcut() && tmpIter.getEdge() == edgeState.getEdge()) {
                 // TODO this is ugly, move this somehow into the underlying iteration logic
-                long edgePointer = tmpPrevEdge == EdgeIterator.NO_EDGE ? -1
+                long edgePointer = !EdgeIterator.Edge.isValid(tmpPrevEdge) ? -1
                         : isShortcut(tmpPrevEdge) ? chEdgeAccess.toPointer(tmpPrevEdge) : baseGraph.edgeAccess.toPointer(tmpPrevEdge);
-                chEdgeAccess.internalEdgeDisconnect(edgeState.getEdge(), edgePointer,
-                        edgeState.getAdjNode(), edgeState.getBaseNode());
+                chEdgeAccess.internalEdgeDisconnect(edgeState.getEdge(), edgePointer, edgeState.getAdjNode());
                 break;
             }
 
@@ -282,36 +298,12 @@ public AllCHEdgesIterator getAllEdges() {
         return new AllCHEdgesIteratorImpl(baseGraph);
     }
 
-    final void setWeight(CommonEdgeIterator edge, double weight) {
-        if (weight < 0)
-            throw new IllegalArgumentException("weight cannot be negative but was " + weight);
-
-        long weightLong;
-
-        if (weight < MIN_WEIGHT) {
-            NodeAccess nodeAccess = getNodeAccess();
-            LOGGER.warn("Setting weights smaller than " + MIN_WEIGHT + " is not allowed in CHGraphImpl#setWeight. " +
-                    "You passed: " + weight + " for the edge " + edge.getEdge() + " from " + nodeAccess.getLat(edge.getBaseNode()) + "," + nodeAccess.getLon(edge.getBaseNode()) +
-                    " to " + nodeAccess.getLat(edge.getAdjNode()) + "," + nodeAccess.getLon(edge.getAdjNode()));
-            weight = MIN_WEIGHT;
-        }
-        if (weight > MAX_WEIGHT)
-            weightLong = MAX_WEIGHT_LONG;
-        else
-            weightLong = ((long) (weight * WEIGHT_FACTOR)) << 2;
-
-        long accessFlags = edge.getDirectFlags() & scDirMask;
-        edge.setFlags(weightLong | accessFlags);
+    void loadNodesHeader() {
+        isReadyForContraction = nodesCH.getHeader(0 * 4) == 1;
     }
 
-    final double getWeight(CommonEdgeIterator edge) {
-        // no need for reverseFlags call (shortcut has identical weight if both dies) and also no need for 64bit
-        long flags32bit = edge.getDirectFlags();
-        double weight = (flags32bit >>> 2) / WEIGHT_FACTOR;
-        if (weight >= MAX_WEIGHT)
-            return Double.POSITIVE_INFINITY;
-
-        return weight;
+    void setNodesHeader() {
+        nodesCH.setHeader(0 * 4, isReadyForContraction ? 1 : 0);
     }
 
     protected int loadEdgesHeader() {
@@ -351,11 +343,17 @@ public Graph copyTo(Graph g) {
 
     void initStorage() {
         EdgeAccess ea = baseGraph.edgeAccess;
-        chEdgeAccess.init(ea.E_NODEA, ea.E_NODEB, ea.E_LINKA, ea.E_LINKB, ea.E_DIST, ea.E_FLAGS, false);
+        chEdgeAccess.init(ea.E_NODEA, ea.E_NODEB, ea.E_LINKA, ea.E_LINKB, ea.E_DIST, ea.E_FLAGS);
         // shortcuts
         S_SKIP_EDGE1 = ea.E_FLAGS + 4;
         S_SKIP_EDGE2 = S_SKIP_EDGE1 + 4;
-        shortcutEntryBytes = S_SKIP_EDGE2 + 4;
+        if (edgeBased) {
+            S_ORIG_FIRST = S_SKIP_EDGE2 + 4;
+            S_ORIG_LAST = S_ORIG_FIRST + 4;
+            shortcutEntryBytes = S_ORIG_LAST + 4;
+        } else {
+            shortcutEntryBytes = S_SKIP_EDGE2 + 4;
+        }
 
         // node based data:
         N_LEVEL = 0;
@@ -380,6 +378,7 @@ public boolean loadExisting() {
         if (!nodesCH.loadExisting() || !shortcuts.loadExisting())
             return false;
 
+        loadNodesHeader();
         loadEdgesHeader();
         return true;
     }
@@ -411,15 +410,89 @@ public String toString() {
         return "CHGraph|" + getWeighting().toString();
     }
 
+    public void debugPrint() {
+        final int printMax = 100;
+        System.out.println("nodesCH:");
+        String formatNodes = "%12s | %12s | %12s \n";
+        System.out.format(Locale.ROOT, formatNodes, "#", "N_CH_REF", "N_LEVEL");
+        for (int i = 0; i < Math.min(baseGraph.getNodes(), printMax); ++i) {
+            System.out.format(Locale.ROOT, formatNodes, i, chEdgeAccess.getEdgeRef(i), getLevel(i));
+        }
+        if (baseGraph.getNodes() > printMax) {
+            System.out.format(Locale.ROOT, " ... %d more nodes", baseGraph.getNodes() - printMax);
+        }
+        System.out.println("shortcuts:");
+        String formatShortcutsBase = "%12s | %12s | %12s | %12s | %12s | %12s | %12s | %12s | %12s";
+        String formatShortcutExt = " | %12s | %12s";
+        String header = String.format(Locale.ROOT, formatShortcutsBase, "#", "E_NODEA", "E_NODEB", "E_LINKA", "E_LINKB", "E_DIST", "E_FLAGS", "S_SKIP_EDGE1", "S_SKIP_EDGE2");
+        if (edgeBased) {
+            header += String.format(Locale.ROOT, formatShortcutExt, "S_ORIG_FIRST", "S_ORIG_LAST");
+        }
+        System.out.println(header);
+        for (int i = baseGraph.edgeCount; i < baseGraph.edgeCount + Math.min(shortcutCount, printMax); ++i) {
+            long edgePointer = chEdgeAccess.toPointer(i);
+            String edgeString = String.format(Locale.ROOT, formatShortcutsBase,
+                    i,
+                    chEdgeAccess.getNodeA(edgePointer),
+                    chEdgeAccess.getNodeB(edgePointer),
+                    chEdgeAccess.getLinkA(edgePointer),
+                    chEdgeAccess.getLinkB(edgePointer),
+                    chEdgeAccess.getDist(edgePointer),
+                    chEdgeAccess.getShortcutFlags(edgePointer),
+                    shortcuts.getInt(edgePointer + S_SKIP_EDGE1),
+                    shortcuts.getInt(edgePointer + S_SKIP_EDGE2));
+            if (edgeBased) {
+                edgeString += String.format(Locale.ROOT, formatShortcutExt,
+                        shortcuts.getInt(edgePointer + S_ORIG_FIRST),
+                        shortcuts.getInt(edgePointer + S_ORIG_LAST));
+            }
+            System.out.println(edgeString);
+        }
+        if (shortcutCount > printMax) {
+            System.out.printf(Locale.ROOT, " ... %d more shortcut edges\n", shortcutCount - printMax);
+        }
+    }
+
+    public NodeOrderingProvider getNodeOrderingProvider() {
+        int numNodes = getNodes();
+        final int[] nodeOrdering = new int[numNodes];
+        // the node ordering is the inverse of the ch levels
+        // if we really want to save some memory it could be still reasonable to not create the node ordering here,
+        // but search nodesCH for a given level on demand.
+        for (int i = 0; i < numNodes; ++i) {
+            int level = getLevel(i);
+            nodeOrdering[level] = i;
+        }
+        return new NodeOrderingProvider() {
+            @Override
+            public int getNodeIdForLevel(int level) {
+                return nodeOrdering[level];
+            }
+
+            @Override
+            public int getNumNodes() {
+                return nodeOrdering.length;
+            }
+        };
+    }
+
     class CHEdgeIteratorImpl extends EdgeIterable implements CHEdgeExplorer, CHEdgeIterator {
         public CHEdgeIteratorImpl(BaseGraph baseGraph, EdgeAccess edgeAccess, EdgeFilter filter) {
             super(baseGraph, edgeAccess, filter);
         }
 
         @Override
-        public final long getFlags() {
+        public final IntsRef getFlags() {
             checkShortcut(false, "getFlags");
-            return super.getDirectFlags();
+            return super.getFlags();
+        }
+
+        int getShortcutFlags() {
+            if (!freshFlags) {
+                chFlags = chEdgeAccess.getShortcutFlags(edgePointer);
+                freshFlags = true;
+            }
+            return chFlags;
         }
 
         @Override
@@ -433,14 +506,10 @@ public final CHEdgeIterator setBaseNode(int baseNode) {
         }
 
         @Override
-        public final void setSkippedEdges(int edge1, int edge2) {
+        public final CHEdgeIteratorState setSkippedEdges(int edge1, int edge2) {
             checkShortcut(true, "setSkippedEdges");
-            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2)) {
-                throw new IllegalStateException("Skipped edges of a shortcut needs "
-                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
-            }
-            shortcuts.setInt(edgePointer + S_SKIP_EDGE1, edge1);
-            shortcuts.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+            chEdgeAccess.setSkippedEdges(edgePointer, edge1, edge2);
+            return this;
         }
 
         @Override
@@ -455,6 +524,29 @@ public final int getSkippedEdge2() {
             return shortcuts.getInt(edgePointer + S_SKIP_EDGE2);
         }
 
+        @Override
+        public CHEdgeIteratorState setFirstAndLastOrigEdges(int firstOrigEdge, int lastOrigEdge) {
+            checkShortcutAndEdgeBased("setFirstAndLastOrigEdges");
+            chEdgeAccess.setFirstAndLastOrigEdges(edgePointer, firstOrigEdge, lastOrigEdge);
+            return this;
+        }
+
+        @Override
+        public int getOrigEdgeFirst() {
+            if (!isShortcut() || !edgeBased) {
+                return getEdge();
+            }
+            return shortcuts.getInt(edgePointer + S_ORIG_FIRST);
+        }
+
+        @Override
+        public int getOrigEdgeLast() {
+            if (!isShortcut() || !edgeBased) {
+                return getEdge();
+            }
+            return shortcuts.getInt(edgePointer + S_ORIG_LAST);
+        }
+
         @Override
         public final boolean isShortcut() {
             // assert baseGraph.isFrozen() : "chgraph not yet frozen";
@@ -462,44 +554,47 @@ public final boolean isShortcut() {
         }
 
         @Override
-        public boolean isBackward(FlagEncoder encoder) {
-            assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
+        public boolean get(BooleanEncodedValue property) {
+            // TODO assert equality of "access boolean encoded value" that is specifically created for CHGraph to make it possible we can use other BooleanEncodedValue objects for CH too!
             if (isShortcut())
-                return (getDirectFlags() & PrepareEncoder.getScBwdDir()) != 0;
+                return (getShortcutFlags() & (reverse ? PrepareEncoder.getScBwdDir() : PrepareEncoder.getScFwdDir())) != 0;
 
-            return encoder.isBackward(getDirectFlags());
+            return property.getBool(reverse, getFlags());
         }
 
         @Override
-        public boolean isForward(FlagEncoder encoder) {
-            assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
+        public boolean getReverse(BooleanEncodedValue property) {
             if (isShortcut())
-                return (getDirectFlags() & PrepareEncoder.getScFwdDir()) != 0;
+                return (getShortcutFlags() & (reverse ? PrepareEncoder.getScFwdDir() : PrepareEncoder.getScBwdDir())) != 0;
 
-            return encoder.isForward(getDirectFlags());
+            return property.getBool(!reverse, getFlags());
         }
 
         @Override
         public final CHEdgeIteratorState setWeight(double weight) {
             checkShortcut(true, "setWeight");
-            CHGraphImpl.this.setWeight(this, weight);
+            chEdgeAccess.setShortcutWeight(edgePointer, weight);
             return this;
         }
 
+        @Override
+        public void setFlagsAndWeight(int flags, double weight) {
+            checkShortcut(true, "setFlagsAndWeight");
+            chEdgeAccess.setAccessAndWeight(edgePointer, flags, weight);
+            chFlags = flags;
+            freshFlags = true;
+        }
+
         @Override
         public final double getWeight() {
             checkShortcut(true, "getWeight");
-            return CHGraphImpl.this.getWeight(this);
+            return chEdgeAccess.getShortcutWeight(edgePointer);
         }
 
         @Override
         protected final void selectEdgeAccess() {
-            if (nextEdgeId < baseGraph.edgeCount)
-                // iterate over edges
-                edgeAccess = baseGraph.edgeAccess;
-            else
-                // ... or shortcuts
-                edgeAccess = chEdgeAccess;
+            // iterate over edges or shortcuts
+            edgeAccess = nextEdgeId < baseGraph.edgeCount ? baseGraph.edgeAccess : chEdgeAccess;
         }
 
         public void checkShortcut(boolean shouldBeShortcut, String methodName) {
@@ -510,6 +605,13 @@ public void checkShortcut(boolean shouldBeShortcut, String methodName) {
                 throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
         }
 
+        private void checkShortcutAndEdgeBased(String method) {
+            checkShortcut(true, method);
+            if (!edgeBased) {
+                throw new IllegalStateException("Method " + method + " only allowed when CH graph is configured for edge based traversal");
+            }
+        }
+
         @Override
         public final String getName() {
             checkShortcut(false, "getName");
@@ -535,8 +637,8 @@ public final EdgeIteratorState setWayGeometry(PointList list) {
         }
 
         @Override
-        public int getMergeStatus(long flags) {
-            return PrepareEncoder.getScMergeStatus(getDirectFlags(), flags);
+        public int getMergeStatus(int flags) {
+            return PrepareEncoder.getScMergeStatus(getShortcutFlags(), flags);
         }
     }
 
@@ -560,6 +662,14 @@ protected final boolean checkRange() {
             return edgeId < shortcutCount;
         }
 
+        int getShortcutFlags() {
+            if (!freshFlags) {
+                chFlags = chEdgeAccess.getShortcutFlags(edgePointer);
+                freshFlags = true;
+            }
+            return chFlags;
+        }
+
         @Override
         public int getEdge() {
             if (isShortcut())
@@ -568,28 +678,27 @@ public int getEdge() {
         }
 
         @Override
-        public boolean isBackward(FlagEncoder encoder) {
-            assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
+        public boolean get(BooleanEncodedValue property) {
+            // TODO assert equality of "access boolean encoded value" that is specifically created for CHGraph!
             if (isShortcut())
-                return (getDirectFlags() & PrepareEncoder.getScBwdDir()) != 0;
+                return (getShortcutFlags() & (reverse ? PrepareEncoder.getScBwdDir() : PrepareEncoder.getScFwdDir())) != 0;
 
-            return encoder.isBackward(getDirectFlags());
+            return property.getBool(reverse, getFlags());
         }
 
         @Override
-        public boolean isForward(FlagEncoder encoder) {
-            assert encoder == weighting.getFlagEncoder() : encoder + " vs. " + weighting.getFlagEncoder();
+        public boolean getReverse(BooleanEncodedValue property) {
             if (isShortcut())
-                return (getDirectFlags() & PrepareEncoder.getScFwdDir()) != 0;
+                return (getShortcutFlags() & (reverse ? PrepareEncoder.getScFwdDir() : PrepareEncoder.getScBwdDir())) != 0;
 
-            return encoder.isForward(getDirectFlags());
+            return property.getBool(!reverse, getFlags());
         }
 
         @Override
-        public final long getFlags() {
+        public final IntsRef getFlags() {
             if (isShortcut())
                 throw new IllegalStateException("Shortcut should not need to return raw flags!");
-            return getDirectFlags();
+            return super.getFlags();
         }
 
         @Override
@@ -598,14 +707,10 @@ public int length() {
         }
 
         @Override
-        public final void setSkippedEdges(int edge1, int edge2) {
+        public final CHEdgeIteratorState setSkippedEdges(int edge1, int edge2) {
             checkShortcut(true, "setSkippedEdges");
-            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2)) {
-                throw new IllegalStateException("Skipped edges of a shortcut needs "
-                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
-            }
-            shortcuts.setInt(edgePointer + S_SKIP_EDGE1, edge1);
-            shortcuts.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+            chEdgeAccess.setSkippedEdges(edgePointer, edge1, edge2);
+            return this;
         }
 
         @Override
@@ -620,6 +725,26 @@ public final int getSkippedEdge2() {
             return shortcuts.getInt(edgePointer + S_SKIP_EDGE2);
         }
 
+        @Override
+        public CHEdgeIteratorState setFirstAndLastOrigEdges(int firstOrigEdge, int lastOrigEdge) {
+            checkShortcutAndEdgeBased("setFirstAndLastOrigEdges");
+            shortcuts.setInt(edgePointer + S_ORIG_FIRST, firstOrigEdge);
+            shortcuts.setInt(edgePointer + S_ORIG_LAST, lastOrigEdge);
+            return this;
+        }
+
+        @Override
+        public int getOrigEdgeFirst() {
+            checkShortcutAndEdgeBased("getOrigEdgeFirst");
+            return shortcuts.getInt(edgePointer + S_ORIG_FIRST);
+        }
+
+        @Override
+        public int getOrigEdgeLast() {
+            checkShortcutAndEdgeBased("getOrigEdgeLast");
+            return shortcuts.getInt(edgePointer + S_ORIG_LAST);
+        }
+
         @Override
         public final boolean isShortcut() {
             assert baseGraph.isFrozen() : "level graph not yet frozen";
@@ -628,18 +753,28 @@ public final boolean isShortcut() {
 
         @Override
         public final CHEdgeIteratorState setWeight(double weight) {
-            CHGraphImpl.this.setWeight(this, weight);
+            checkShortcut(true, "setWeight");
+            chEdgeAccess.setShortcutWeight(edgePointer, weight);
             return this;
         }
 
+        @Override
+        public void setFlagsAndWeight(int flags, double weight) {
+            checkShortcut(true, "setFlagsAndWeight");
+            chEdgeAccess.setAccessAndWeight(edgePointer, flags, weight);
+            chFlags = flags;
+            freshFlags = true;
+        }
+
         @Override
         public final double getWeight() {
-            return CHGraphImpl.this.getWeight(this);
+            checkShortcut(true, "getWeight");
+            return chEdgeAccess.getShortcutWeight(edgePointer);
         }
 
         @Override
-        public int getMergeStatus(long flags) {
-            return PrepareEncoder.getScMergeStatus(getDirectFlags(), flags);
+        public int getMergeStatus(int flags) {
+            return PrepareEncoder.getScMergeStatus(getShortcutFlags(), flags);
         }
 
         void checkShortcut(boolean shouldBeShortcut, String methodName) {
@@ -649,5 +784,123 @@ void checkShortcut(boolean shouldBeShortcut, String methodName) {
             } else if (shouldBeShortcut)
                 throw new IllegalStateException("Method " + methodName + " only for shortcuts " + getEdge());
         }
+
+        private void checkShortcutAndEdgeBased(String method) {
+            checkShortcut(true, method);
+            if (!edgeBased) {
+                throw new IllegalStateException("Method " + method + " not supported when turn costs are disabled");
+            }
+        }
+    }
+
+    private class CHEdgeAccess extends EdgeAccess {
+        private final String name;
+
+        public CHEdgeAccess(String name) {
+            super(shortcuts);
+            this.name = name;
+        }
+
+        @Override
+        final EdgeIterable createSingleEdge(EdgeFilter edgeFilter) {
+            return new CHEdgeIteratorImpl(baseGraph, this, edgeFilter);
+        }
+
+        @Override
+        final int getEdgeRef(int nodeId) {
+            return nodesCH.getInt((long) nodeId * nodeCHEntryBytes + N_CH_REF);
+        }
+
+        @Override
+        final void setEdgeRef(int nodeId, int edgeId) {
+            nodesCH.setInt((long) nodeId * nodeCHEntryBytes + N_CH_REF, edgeId);
+        }
+
+        @Override
+        final int getEntryBytes() {
+            return shortcutEntryBytes;
+        }
+
+        void setShortcutFlags(long edgePointer, int flags) {
+            edges.setInt(edgePointer + E_FLAGS, flags);
+        }
+
+        int getShortcutFlags(long edgePointer) {
+            return edges.getInt(edgePointer + E_FLAGS);
+        }
+
+        void setShortcutWeight(long edgePointer, double weight) {
+            int accessFlags = getShortcutFlags(edgePointer) & scDirMask;
+            setAccessAndWeight(edgePointer, accessFlags, weight);
+        }
+
+        void setAccessAndWeight(long edgePointer, int accessFlags, double weight) {
+            int weightFlags = weightToWeightFlags(edgePointer, weight);
+            setShortcutFlags(edgePointer, weightFlags | accessFlags);
+        }
+
+        int weightToWeightFlags(long edgePointer, double weight) {
+            if (weight < 0)
+                throw new IllegalArgumentException("weight cannot be negative but was " + weight);
+
+            int weightInt;
+
+            if (weight < MIN_WEIGHT) {
+                NodeAccess nodeAccess = getNodeAccess();
+                // todo: how to get edge id
+                int edgeId = -1;
+                LOGGER.warn("Setting weights smaller than " + MIN_WEIGHT + " is not allowed in CHGraphImpl#setWeight. " +
+                        "You passed: " + weight + " for the edge " + edgeId +
+                        " nodeA " + nodeAccess.getLat(getNodeA(edgePointer)) + "," + nodeAccess.getLon(getNodeA(edgePointer)) +
+                        " nodeB " + nodeAccess.getLat(getNodeB(edgePointer)) + "," + nodeAccess.getLon(getNodeB(edgePointer)));
+                weight = MIN_WEIGHT;
+            }
+            if (weight > MAX_WEIGHT)
+                weightInt = MAX_WEIGHT_31;
+            else
+                weightInt = ((int) Math.round(weight * WEIGHT_FACTOR)) << 2;
+            return weightInt;
+        }
+
+        double getShortcutWeight(long edgePointer) {
+            // no need for reverseFlags call (shortcut has identical weight if both dies) and also no need for 64bit
+            long flags32bit = getShortcutFlags(edgePointer);
+            double weight = (flags32bit >>> 2) / WEIGHT_FACTOR;
+            if (weight >= MAX_WEIGHT)
+                return Double.POSITIVE_INFINITY;
+
+            return weight;
+        }
+
+        void setSkippedEdges(long edgePointer, int edge1, int edge2) {
+            if (EdgeIterator.Edge.isValid(edge1) != EdgeIterator.Edge.isValid(edge2)) {
+                throw new IllegalStateException("Skipped edges of a shortcut needs "
+                        + "to be both valid or invalid but they were not " + edge1 + ", " + edge2);
+            }
+            shortcuts.setInt(edgePointer + S_SKIP_EDGE1, edge1);
+            shortcuts.setInt(edgePointer + S_SKIP_EDGE2, edge2);
+        }
+
+        public void setFirstAndLastOrigEdges(long edgePointer, int origFirst, int origLast) {
+            shortcuts.setInt(edgePointer + S_ORIG_FIRST, origFirst);
+            shortcuts.setInt(edgePointer + S_ORIG_LAST, origLast);
+        }
+
+        @Override
+        final long toPointer(int shortcutId) {
+            assert isInBounds(shortcutId) : "shortcutId " + shortcutId + " not in bounds [" + baseGraph.edgeCount + ", " + (baseGraph.edgeCount + shortcutCount) + ")";
+            return (long) (shortcutId - baseGraph.edgeCount) * shortcutEntryBytes;
+        }
+
+        @Override
+        final boolean isInBounds(int shortcutId) {
+            int tmp = shortcutId - baseGraph.edgeCount;
+            return tmp < shortcutCount && tmp >= 0;
+        }
+
+        @Override
+        public String toString() {
+            return "ch edge access " + name;
+        }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/DAType.java b/core/src/main/java/com/graphhopper/storage/DAType.java
index 000e00741d..10f7e79e3b 100644
--- a/core/src/main/java/com/graphhopper/storage/DAType.java
+++ b/core/src/main/java/com/graphhopper/storage/DAType.java
@@ -89,6 +89,15 @@ else if (dataAccess.contains("RAM_STORE"))
         return type;
     }
 
+    /**
+     * This method returns RAM_INT if the specified type is in-memory.
+     */
+    public static DAType getPreferredInt(DAType type) {
+        if (type.isInMemory())
+            return type.isStoring() ? RAM_INT_STORE : RAM_INT;
+        return type;
+    }
+
     /**
      * Memory mapped or purely in memory? default is HEAP
      */
diff --git a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
index 68c64ab777..2a5ed08f0d 100644
--- a/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/EdgeAccess.java
@@ -18,7 +18,6 @@
 package com.graphhopper.storage;
 
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.util.BitUtil;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 
@@ -26,28 +25,24 @@
  * @author Peter Karich
  */
 abstract class EdgeAccess {
-    static final int NO_NODE = -1;
+    private static final int NO_NODE = -1;
     // distance of around +-1000 000 meter are ok
     private static final double INT_DIST_FACTOR = 1000d;
-    static double MAX_DIST = (Integer.MAX_VALUE - 1) / INT_DIST_FACTOR;
+    static double MAX_DIST = Integer.MAX_VALUE / INT_DIST_FACTOR;
     final DataAccess edges;
-    private final BitUtil bitUtil;
     int E_NODEA, E_NODEB, E_LINKA, E_LINKB, E_DIST, E_FLAGS;
-    private boolean flagsSizeIsLong;
 
-    EdgeAccess(DataAccess edges, BitUtil bitUtil) {
+    EdgeAccess(DataAccess edges) {
         this.edges = edges;
-        this.bitUtil = bitUtil;
     }
 
-    final void init(int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST, int E_FLAGS, boolean flagsSizeIsLong) {
+    final void init(int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST, int E_FLAGS) {
         this.E_NODEA = E_NODEA;
         this.E_NODEB = E_NODEB;
         this.E_LINKA = E_LINKA;
         this.E_LINKB = E_LINKB;
         this.E_DIST = E_DIST;
         this.E_FLAGS = E_FLAGS;
-        this.flagsSizeIsLong = flagsSizeIsLong;
     }
 
     abstract BaseGraph.EdgeIterable createSingleEdge(EdgeFilter edgeFilter);
@@ -56,8 +51,6 @@ final void init(int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST,
 
     abstract boolean isInBounds(int edgeOrShortcutId);
 
-    abstract long reverseFlags(long edgePointer, long flags);
-
     abstract int getEdgeRef(int nodeId);
 
     abstract void setEdgeRef(int nodeId, int edgeId);
@@ -65,7 +58,11 @@ final void init(int E_NODEA, int E_NODEB, int E_LINKA, int E_LINKB, int E_DIST,
     abstract int getEntryBytes();
 
     final void invalidateEdge(long edgePointer) {
-        edges.setInt(edgePointer + E_NODEA, NO_NODE);
+        edges.setInt(edgePointer + E_NODEB, NO_NODE);
+    }
+
+    static final boolean isInvalidNodeB(int node) {
+        return node == EdgeAccess.NO_NODE;
     }
 
     final void setDist(long edgePointer, double distance) {
@@ -76,12 +73,13 @@ final void setDist(long edgePointer, double distance) {
      * Translates double distance to integer in order to save it in a DataAccess object
      */
     private int distToInt(double distance) {
-        int integ = (int) (distance * INT_DIST_FACTOR);
-        if (integ < 0)
+        if (distance < 0)
             throw new IllegalArgumentException("Distance cannot be negative: " + distance);
-        if (integ >= Integer.MAX_VALUE)
-            return Integer.MAX_VALUE;
-        // throw new IllegalArgumentException("Distance too large leading to overflowed integer (#435): " + distance + " ");
+        if (distance > MAX_DIST) {
+            distance = MAX_DIST;
+        }
+        int integ = (int) Math.round(distance * INT_DIST_FACTOR);
+        assert integ >= 0 : "distance out of range";
         return integ;
     }
 
@@ -94,108 +92,97 @@ final double getDist(long pointer) {
         return val / INT_DIST_FACTOR;
     }
 
-    final long getFlags_(long edgePointer, boolean reverse) {
-        int low = edges.getInt(edgePointer + E_FLAGS);
-        long resFlags = low;
-        if (flagsSizeIsLong) {
-            int high = edges.getInt(edgePointer + E_FLAGS + 4);
-            resFlags = bitUtil.combineIntsToLong(low, high);
+    final void readFlags(long edgePointer, IntsRef edgeFlags) {
+        int size = edgeFlags.ints.length;
+        for (int i = 0; i < size; i++) {
+            edgeFlags.ints[i] = edges.getInt(edgePointer + E_FLAGS + i * 4);
         }
-        if (reverse)
-            resFlags = reverseFlags(edgePointer, resFlags);
-
-        return resFlags;
     }
 
-    final long setFlags_(long edgePointer, boolean reverse, long flags) {
-        if (reverse)
-            flags = reverseFlags(edgePointer, flags);
-
-        edges.setInt(edgePointer + E_FLAGS, bitUtil.getIntLow(flags));
-
-        if (flagsSizeIsLong)
-            edges.setInt(edgePointer + E_FLAGS + 4, bitUtil.getIntHigh(flags));
-
-        return flags;
+    final void writeFlags(long edgePointer, IntsRef edgeFlags) {
+        int size = edgeFlags.ints.length;
+        for (int i = 0; i < size; i++) {
+            edges.setInt(edgePointer + E_FLAGS + i * 4, edgeFlags.ints[i]);
+        }
     }
 
     /**
-     * Write new edge between nodes fromNodeId, and toNodeId both to nodes index and edges index
+     * Writes a new edge to the array of edges and adds it to the linked list of edges at nodeA and nodeB
      */
-    final int internalEdgeAdd(int newEdgeId, int fromNodeId, int toNodeId) {
-        writeEdge(newEdgeId, fromNodeId, toNodeId, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
-        connectNewEdge(fromNodeId, toNodeId, newEdgeId);
-        if (fromNodeId != toNodeId)
-            connectNewEdge(toNodeId, fromNodeId, newEdgeId);
+    final int internalEdgeAdd(int newEdgeId, int nodeA, int nodeB) {
+        writeEdge(newEdgeId, nodeA, nodeB, EdgeIterator.NO_EDGE, EdgeIterator.NO_EDGE);
+        long edgePointer = toPointer(newEdgeId);
+
+        int edge = getEdgeRef(nodeA);
+        if (edge > EdgeIterator.NO_EDGE)
+            edges.setInt(E_LINKA + edgePointer, edge);
+        setEdgeRef(nodeA, newEdgeId);
+
+        if (nodeA != nodeB) {
+            edge = getEdgeRef(nodeB);
+            if (edge > EdgeIterator.NO_EDGE)
+                edges.setInt(E_LINKB + edgePointer, edge);
+            setEdgeRef(nodeB, newEdgeId);
+        }
         return newEdgeId;
     }
 
-    final int getOtherNode(int nodeThis, long edgePointer) {
-        int nodeA = edges.getInt(edgePointer + E_NODEA);
-        if (nodeA == nodeThis)
-            // return b
-            return edges.getInt(edgePointer + E_NODEB);
-        // return a
-        return nodeA;
+    final int getNodeA(long edgePointer) {
+        return edges.getInt(edgePointer + E_NODEA);
     }
 
-    private long _getLinkPosInEdgeArea(int nodeThis, int nodeOther, long edgePointer) {
-        return nodeThis <= nodeOther ? edgePointer + E_LINKA : edgePointer + E_LINKB;
+    final int getNodeB(long edgePointer) {
+        return edges.getInt(edgePointer + E_NODEB);
     }
 
-    final int getEdgeRef(int nodeThis, int nodeOther, long edgePointer) {
-        return edges.getInt(_getLinkPosInEdgeArea(nodeThis, nodeOther, edgePointer));
+    final int getLinkA(long edgePointer) {
+        return edges.getInt(edgePointer + E_LINKA);
     }
 
-    final void connectNewEdge(int fromNode, int otherNode, int newOrExistingEdge) {
-        int edge = getEdgeRef(fromNode);
-        if (edge > EdgeIterator.NO_EDGE) {
-            long edgePointer = toPointer(newOrExistingEdge);
-            long lastLink = _getLinkPosInEdgeArea(fromNode, otherNode, edgePointer);
-            edges.setInt(lastLink, edge);
-        }
-        setEdgeRef(fromNode, newOrExistingEdge);
+    final int getLinkB(long edgePointer) {
+        return edges.getInt(edgePointer + E_LINKB);
     }
 
-    final long writeEdge(int edgeId, int nodeThis, int nodeOther, int nextEdge, int nextEdgeOther) {
-        if (nodeThis > nodeOther) {
-            int tmp = nodeThis;
-            nodeThis = nodeOther;
-            nodeOther = tmp;
-            tmp = nextEdge;
-            nextEdge = nextEdgeOther;
-            nextEdgeOther = tmp;
-        }
-        if (edgeId < 0 || edgeId == EdgeIterator.NO_EDGE)
-            throw new IllegalStateException("Cannot write edge with illegal ID:" + edgeId + "; nodeThis:" + nodeThis + ", nodeOther:" + nodeOther);
+    final int getOtherNode(int nodeThis, long edgePointer) {
+        int nodeA = getNodeA(edgePointer);
+        return nodeThis == nodeA ? getNodeB(edgePointer) : nodeA;
+    }
+
+    final boolean isAdjacentToNode(int node, long edgePointer) {
+        return getNodeA(edgePointer) == node || getNodeB(edgePointer) == node;
+    }
+
+    /**
+     * Writes plain edge information to the edges index
+     */
+    final long writeEdge(int edgeId, int nodeA, int nodeB, int nextEdgeA, int nextEdgeB) {
+        if (!EdgeIterator.Edge.isValid(edgeId))
+            throw new IllegalStateException("Cannot write edge with illegal ID:" + edgeId + "; nodeA:" + nodeA + ", nodeB:" + nodeB);
 
         long edgePointer = toPointer(edgeId);
-        edges.setInt(edgePointer + E_NODEA, nodeThis);
-        edges.setInt(edgePointer + E_NODEB, nodeOther);
-        edges.setInt(edgePointer + E_LINKA, nextEdge);
-        edges.setInt(edgePointer + E_LINKB, nextEdgeOther);
+        edges.setInt(edgePointer + E_NODEA, nodeA);
+        edges.setInt(edgePointer + E_NODEB, nodeB);
+        edges.setInt(edgePointer + E_LINKA, nextEdgeA);
+        edges.setInt(edgePointer + E_LINKB, nextEdgeB);
         return edgePointer;
     }
 
     /**
      * This method disconnects the specified edge from the list of edges of the specified node. It
      * does not release the freed space to be reused.
-     * <p>
      *
-     * @param edgeToUpdatePointer if it is negative then the nextEdgeId will be saved to refToEdges
-     *                            of nodes
+     * @param edgeToUpdatePointer if it is negative then the nextEdgeId will be saved to refToEdges of nodes
      */
-    final long internalEdgeDisconnect(int edgeToRemove, long edgeToUpdatePointer, int baseNode, int adjNode) {
+    final long internalEdgeDisconnect(int edgeToRemove, long edgeToUpdatePointer, int baseNode) {
         long edgeToRemovePointer = toPointer(edgeToRemove);
         // an edge is shared across the two nodes even if the edge is not in both directions
         // so we need to know two edge-pointers pointing to the edge before edgeToRemovePointer
-        int nextEdgeId = getEdgeRef(baseNode, adjNode, edgeToRemovePointer);
+        int nextEdgeId = getNodeA(edgeToRemovePointer) == baseNode ? getLinkA(edgeToRemovePointer) : getLinkB(edgeToRemovePointer);
         if (edgeToUpdatePointer < 0) {
             setEdgeRef(baseNode, nextEdgeId);
         } else {
             // adjNode is different for the edge we want to update with the new link
-            long link = edges.getInt(edgeToUpdatePointer + E_NODEA) == baseNode
-                    ? edgeToUpdatePointer + E_LINKA : edgeToUpdatePointer + E_LINKB;
+            long link = getNodeA(edgeToUpdatePointer) == baseNode ? edgeToUpdatePointer + E_LINKA : edgeToUpdatePointer + E_LINKB;
             edges.setInt(link, nextEdgeId);
         }
         return edgeToRemovePointer;
diff --git a/core/src/main/java/com/graphhopper/storage/GHDirectory.java b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
index 7b7f720a8e..4aeb1879fe 100644
--- a/core/src/main/java/com/graphhopper/storage/GHDirectory.java
+++ b/core/src/main/java/com/graphhopper/storage/GHDirectory.java
@@ -17,8 +17,6 @@
  */
 package com.graphhopper.storage;
 
-import com.graphhopper.util.Helper;
-
 import java.io.File;
 import java.nio.ByteOrder;
 import java.util.Collection;
@@ -52,20 +50,6 @@ public GHDirectory(String _location, DAType defaultType) {
         File dir = new File(location);
         if (dir.exists() && !dir.isDirectory())
             throw new RuntimeException("file '" + dir + "' exists but is not a directory");
-
-        // set default access to integer based
-        // improves performance on server side, 10% faster for queries and preparation
-        if (this.defaultType.isInMemory()) {
-            if (isStoring()) {
-                put("location_index", DAType.RAM_INT_STORE);
-                put("edges", DAType.RAM_INT_STORE);
-                put("nodes", DAType.RAM_INT_STORE);
-            } else {
-                put("location_index", DAType.RAM_INT);
-                put("edges", DAType.RAM_INT);
-                put("nodes", DAType.RAM_INT);
-            }
-        }
     }
 
     @Override
diff --git a/core/src/main/java/com/graphhopper/storage/Graph.java b/core/src/main/java/com/graphhopper/storage/Graph.java
index 4032712d8b..51f9c4d559 100644
--- a/core/src/main/java/com/graphhopper/storage/Graph.java
+++ b/core/src/main/java/com/graphhopper/storage/Graph.java
@@ -26,7 +26,6 @@
 /**
  * An interface to represent a (geo) graph - suited for efficient storage as it can be requested via
  * indices called node IDs. To get the lat,lon point you need to set up a LocationIndex instance.
- * <p>
  *
  * @author Peter Karich
  */
@@ -42,6 +41,11 @@
      */
     int getNodes();
 
+    /**
+     * @return the number of edges in this graph. equivalent to getAllEdges().length();
+     */
+    int getEdges();
+
     /**
      * Creates a node explorer to access node properties.
      */
@@ -72,13 +76,22 @@
      * Returns a wrapper over the specified edgeId.
      *
      * @param adjNode is the node that will be returned via adjNode(). If adjNode is
-     *                Integer.MIN_VALUE then the edge with uncertain values for adjNode and baseNode (two
-     *                possibilities) will be returned.
+     *                Integer.MIN_VALUE then the edge will be returned in the direction of how it is stored
      * @return an edge iterator state or potentially null if adjNode does not match
      * @throws IllegalStateException if edgeId is not valid
      */
     EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode);
 
+    /**
+     * @return the 'opposite' node of a given edge, so if there is an edge 3-2 and node =2 this returns 3
+     */
+    int getOtherNode(int edge, int node);
+
+    /**
+     * @return true if the edge with id edge is adjacent to node, false otherwise
+     */
+    boolean isAdjacentToNode(int edge, int node);
+
     /**
      * @return all edges in this graph, where baseNode will be the smaller node.
      */
@@ -102,7 +115,6 @@
 
     /**
      * Copy this Graph into the specified Graph g.
-     * <p>
      *
      * @return the specified Graph g
      */
@@ -112,4 +124,5 @@
      * @return the graph extension like a TurnCostExtension
      */
     GraphExtension getExtension();
+
 }
diff --git a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
index cf2238e8f7..0d23589950 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphBuilder.java
@@ -21,6 +21,7 @@
 import com.graphhopper.routing.weighting.Weighting;
 
 import java.util.Arrays;
+import java.util.Collections;
 
 /**
  * For now this is just a helper class to quickly create a {@link GraphHopperStorage}
@@ -34,6 +35,8 @@
     private boolean mmap;
     private boolean store;
     private boolean elevation;
+    private boolean turnCosts;
+    private boolean edgeBasedCH;
     private long byteCapacity = 100;
     private Weighting singleCHWeighting;
 
@@ -74,6 +77,16 @@ public GraphBuilder set3D(boolean withElevation) {
         return this;
     }
 
+    public GraphBuilder withTurnCosts(boolean turnCosts) {
+        this.turnCosts = turnCosts;
+        return this;
+    }
+
+    public GraphBuilder setEdgeBasedCH(boolean edgeBasedCH) {
+        this.edgeBasedCH = edgeBasedCH;
+        return this;
+    }
+
     public boolean hasElevation() {
         return elevation;
     }
@@ -82,26 +95,28 @@ public boolean hasElevation() {
      * Creates a CHGraph
      */
     public CHGraph chGraphCreate(Weighting singleCHWeighting) {
-        return setCHGraph(singleCHWeighting).create().getGraph(CHGraph.class, singleCHWeighting);
+        return setCHGraph(singleCHWeighting).create().getCHGraph(singleCHWeighting);
     }
 
     /**
      * Default graph is a {@link GraphHopperStorage} with an in memory directory and disabled storing on flush.
      * Afterwards you'll need to call {@link GraphHopperStorage#create} to have a usable object. Better use
-     * {@link GraphHopperStorage#create} directly.
+     * {@link #create} directly.
      */
     public GraphHopperStorage build() {
         Directory dir = mmap ?
                 new MMapDirectory(location) :
                 new RAMDirectory(location, store);
 
-        GraphHopperStorage graph;
-        if (encodingManager.needsTurnCostsSupport() || singleCHWeighting == null)
-            graph = new GraphHopperStorage(dir, encodingManager, elevation, new TurnCostExtension());
-        else
-            graph = new GraphHopperStorage(Arrays.asList(singleCHWeighting), dir, encodingManager, elevation, new TurnCostExtension.NoOpExtension());
+        GraphExtension graphExtension = encodingManager.needsTurnCostsSupport() || turnCosts ?
+                new TurnCostExtension() :
+                new TurnCostExtension.NoOpExtension();
 
-        return graph;
+        return singleCHWeighting == null ?
+                new GraphHopperStorage(dir, encodingManager, elevation, graphExtension) :
+                edgeBasedCH ?
+                        new GraphHopperStorage(Collections.<Weighting>emptyList(), Arrays.asList(singleCHWeighting), dir, encodingManager, elevation, graphExtension) :
+                        new GraphHopperStorage(Arrays.asList(singleCHWeighting), Collections.<Weighting>emptyList(), dir, encodingManager, elevation, graphExtension);
     }
 
     /**
diff --git a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
index fea30d5225..1eba43e871 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphEdgeIdFinder.java
@@ -17,19 +17,18 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHIntHashSet;
+import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.util.shapes.Polygon;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.BreadthFirstSearch;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.BBox;
-import com.graphhopper.util.shapes.Circle;
-import com.graphhopper.util.shapes.GHPoint;
-import com.graphhopper.util.shapes.Shape;
-import com.vividsolutions.jts.geom.*;
+import com.graphhopper.util.shapes.Polygon;
+import com.graphhopper.util.shapes.*;
+import org.locationtech.jts.geom.*;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -84,6 +83,11 @@ public void findEdgesInShape(final GHIntHashSet edgeIds, final Shape shape, Edge
             final NodeAccess na = graph.getNodeAccess();
             final Shape localShape = shape;
 
+            @Override
+            protected GHBitSet createBitSet() {
+                return new GHTBitSet();
+            }
+
             @Override
             protected boolean goFurther(int nodeId) {
                 if (isPolygon) return isInsideBBox(nodeId);
@@ -137,6 +141,7 @@ public void fillEdgeIDs(GHIntHashSet edgeIds, Geometry geometry, EdgeFilter filt
 
     /**
      * This method reads the blockAreaString and creates a Collection of Shapes or a set of found edges if area is small enough.
+     *
      * @param useEdgeIdsUntilAreaSize until the specified area (specified in m²) use the findEdgesInShape method
      */
     public BlockArea parseBlockArea(String blockAreaString, EdgeFilter filter, double useEdgeIdsUntilAreaSize) {
diff --git a/core/src/main/java/com/graphhopper/storage/GraphExtension.java b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
index cfbde09773..cfb7d9d4e0 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphExtension.java
@@ -19,7 +19,7 @@
 
 /**
  * If you need custom storages, like turn cost tables, or osmid tables for your graph you implement
- * this interface and put it in any graph storage you want.
+ * this interface and add it to any graph storage you want.
  */
 public interface GraphExtension extends Storable<GraphExtension> {
     /**
diff --git a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
index 78f6620161..4a69f18007 100644
--- a/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/GraphHopperStorage.java
@@ -34,12 +34,11 @@
  * This class manages all storage related methods and delegates the calls to the associated graphs.
  * The associated graphs manage their own necessary data structures and are used to provide e.g.
  * different traversal methods. By default this class implements the graph interface and results in
- * identical behavior as the Graph instance from getGraph(Graph.class)
+ * identical behavior as the Graph instance from getBaseGraph()
  * <p>
  *
  * @author Peter Karich
  * @see GraphBuilder to create a (CH)Graph easier
- * @see #getGraph(java.lang.Class)
  */
 public final class GraphHopperStorage implements GraphStorage, Graph {
     private final Directory dir;
@@ -47,19 +46,25 @@
     private final StorableProperties properties;
     private final BaseGraph baseGraph;
     // same flush order etc
-    private final Collection<CHGraphImpl> chGraphs = new ArrayList<>(5);
+    private final Collection<CHGraphImpl> nodeBasedCHGraphs = new ArrayList<>(5);
+    private final Collection<CHGraphImpl> edgeBasedCHGraphs = new ArrayList<>(5);
 
     public GraphHopperStorage(Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage) {
-        this(Collections.<Weighting>emptyList(), dir, encodingManager, withElevation, extendedStorage);
+        this(Collections.<Weighting>emptyList(), Collections.<Weighting>emptyList(), dir, encodingManager, withElevation, extendedStorage);
     }
 
-    public GraphHopperStorage(List<? extends Weighting> chWeightings, Directory dir, final EncodingManager encodingManager,
+    public GraphHopperStorage(List<? extends Weighting> nodeBasedCHWeightings, Directory dir, EncodingManager encodingManager,
                               boolean withElevation, GraphExtension extendedStorage) {
+        this(nodeBasedCHWeightings, Collections.<Weighting>emptyList(), dir, encodingManager, withElevation, extendedStorage);
+    }
+
+    public GraphHopperStorage(List<? extends Weighting> nodeBasedCHWeightings, List<? extends Weighting> edgeBasedCHWeightings,
+                              Directory dir, EncodingManager encodingManager, boolean withElevation, GraphExtension extendedStorage) {
         if (extendedStorage == null)
             throw new IllegalArgumentException("GraphExtension cannot be null, use NoOpExtension");
 
         if (encodingManager == null)
-            throw new IllegalArgumentException("EncodingManager needs to be non-null since 0.7. Create one using new EncodingManager or EncodingManager.create(flagEncoderFactory, ghLocation)");
+            throw new IllegalArgumentException("EncodingManager needs to be non-null since 0.7. Create one using EncodingManager.create or EncodingManager.create(flagEncoderFactory, ghLocation)");
 
         this.encodingManager = encodingManager;
         this.dir = dir;
@@ -67,35 +72,47 @@ public GraphHopperStorage(List<? extends Weighting> chWeightings, Directory dir,
         InternalGraphEventListener listener = new InternalGraphEventListener() {
             @Override
             public void initStorage() {
-                for (CHGraphImpl cg : chGraphs) {
+                for (CHGraphImpl cg : getAllCHGraphs()) {
                     cg.initStorage();
                 }
             }
 
             @Override
             public void freeze() {
-                for (CHGraphImpl cg : chGraphs) {
-                    cg._freeze();
+                for (CHGraphImpl cg : getAllCHGraphs()) {
+                    cg._prepareForContraction();
                 }
             }
         };
 
-        this.baseGraph = new BaseGraph(dir, encodingManager, withElevation, listener, extendedStorage);
-        for (Weighting w : chWeightings) {
-            chGraphs.add(new CHGraphImpl(w, dir, this.baseGraph));
+        baseGraph = new BaseGraph(dir, encodingManager, withElevation, listener, extendedStorage);
+        for (Weighting w : nodeBasedCHWeightings) {
+            nodeBasedCHGraphs.add(new CHGraphImpl(w, dir, baseGraph, false));
+        }
+        for (Weighting w : edgeBasedCHWeightings) {
+            edgeBasedCHGraphs.add(new CHGraphImpl(w, dir, baseGraph, true));
+        }
+    }
+
+    public CHGraph getCHGraph() {
+        Collection<CHGraphImpl> chGraphs = getAllCHGraphs();
+        if (chGraphs.isEmpty()) {
+            throw new IllegalStateException("There is no CHGraph");
+        } else if (chGraphs.size() > 1) {
+            throw new IllegalStateException("There are multiple CHGraphs, use getCHGraph(Weighting) to retrieve a specific one");
+        } else {
+            return chGraphs.iterator().next();
         }
     }
 
     /**
-     * This method returns the routing graph for the specified weighting, could be potentially
-     * filled with shortcuts.
+     * @return the {@link CHGraph} for the specified {@link Weighting}. The graph is identified by the weighting using
+     * reference identity (==)!
      */
-    public <T extends Graph> T getGraph(Class<T> clazz, Weighting weighting) {
-        if (clazz.equals(Graph.class))
-            return (T) baseGraph;
-
+    public CHGraph getCHGraph(Weighting weighting) {
+        Collection<CHGraphImpl> chGraphs = getAllCHGraphs();
         if (chGraphs.isEmpty())
-            throw new IllegalStateException("Cannot find graph implementation for " + clazz);
+            throw new IllegalStateException("There is no CHGraph");
 
         if (weighting == null)
             throw new IllegalStateException("Cannot find CHGraph with null weighting");
@@ -103,32 +120,28 @@ public void freeze() {
         List<Weighting> existing = new ArrayList<>();
         for (CHGraphImpl cg : chGraphs) {
             if (cg.getWeighting() == weighting)
-                return (T) cg;
-
+                return cg;
             existing.add(cg.getWeighting());
         }
 
-        throw new IllegalStateException("Cannot find CHGraph for specified weighting: " + weighting + ", existing:" + existing);
+        throw new IllegalStateException("Cannot find CHGraph for the specified weighting: " + weighting + ", existing:" + existing);
     }
 
-    public <T extends Graph> T getGraph(Class<T> clazz) {
-        if (clazz.equals(Graph.class))
-            return (T) baseGraph;
-
-        if (chGraphs.isEmpty())
-            throw new IllegalStateException("Cannot find graph implementation for " + clazz);
+    public boolean isCHPossible() {
+        return !getAllCHGraphs().isEmpty();
+    }
 
-        CHGraph cg = chGraphs.iterator().next();
-        return (T) cg;
+    public List<Weighting> getNodeBasedCHWeightings() {
+        return getWeightingsFromGraphs(nodeBasedCHGraphs);
     }
 
-    public boolean isCHPossible() {
-        return !chGraphs.isEmpty();
+    public List<Weighting> getEdgeBasedCHWeightings() {
+        return getWeightingsFromGraphs(edgeBasedCHGraphs);
     }
 
-    public List<Weighting> getCHWeightings() {
-        List<Weighting> list = new ArrayList<>(chGraphs.size());
-        for (CHGraphImpl cg : chGraphs) {
+    private List<Weighting> getWeightingsFromGraphs(Collection<CHGraphImpl> graphs) {
+        List<Weighting> list = new ArrayList<>(graphs.size());
+        for (CHGraphImpl cg : graphs) {
             list.add(cg.getWeighting());
         }
         return list;
@@ -146,7 +159,7 @@ public Directory getDirectory() {
     public void setSegmentSize(int bytes) {
         baseGraph.setSegmentSize(bytes);
 
-        for (CHGraphImpl cg : chGraphs) {
+        for (CHGraphImpl cg : getAllCHGraphs()) {
             cg.setSegmentSize(bytes);
         }
     }
@@ -165,7 +178,8 @@ public GraphHopperStorage create(long byteCount) {
         properties.create(100);
 
         properties.put("graph.bytes_for_flags", encodingManager.getBytesForFlags());
-        properties.put("graph.flag_encoders", encodingManager.toDetailsString());
+        properties.put("graph.encoded_values", encodingManager.toEncodedValuesAsString());
+        properties.put("graph.flag_encoders", encodingManager.toFlagEncodersAsString());
 
         properties.put("graph.byte_order", dir.getByteOrder());
         properties.put("graph.dimension", baseGraph.nodeAccess.getDimension());
@@ -173,11 +187,12 @@ public GraphHopperStorage create(long byteCount) {
 
         baseGraph.create(initSize);
 
-        for (CHGraphImpl cg : chGraphs) {
+        for (CHGraphImpl cg : getAllCHGraphs()) {
             cg.create(byteCount);
         }
 
-        properties.put("graph.ch.weightings", getCHWeightings().toString());
+        properties.put("graph.ch.weightings", getNodeBasedCHWeightings().toString());
+        properties.put("graph.ch.edge.weightings", getEdgeBasedCHWeightings().toString());
         return this;
     }
 
@@ -230,13 +245,21 @@ public boolean loadExisting() {
             // check encoding for compatibility
             String flagEncodersStr = properties.get("graph.flag_encoders");
 
-            if (!flagEncodersStr.isEmpty() && !encodingManager.toDetailsString().equalsIgnoreCase(flagEncodersStr)) {
+            if (!encodingManager.toFlagEncodersAsString().equalsIgnoreCase(flagEncodersStr)) {
                 throw new IllegalStateException("Encoding does not match:"
-                        + "\nGraphhopper config: " + encodingManager.toDetailsString()
+                        + "\nGraphhopper config: " + encodingManager.toFlagEncodersAsString()
                         + "\nGraph: " + flagEncodersStr
                         + "\nChange configuration to match the graph or delete " + dir.getLocation());
             }
 
+            String encodedValueStr = properties.get("graph.encoded_values");
+            if (!encodingManager.toEncodedValuesAsString().equalsIgnoreCase(encodedValueStr)) {
+                throw new IllegalStateException("Encoded values do not match:"
+                        + "\nGraphhopper config: " + encodingManager.toEncodedValuesAsString()
+                        + "\nGraph: " + encodedValueStr
+                        + "\nChange configuration to match the graph or delete " + dir.getLocation());
+            }
+
             String byteOrder = properties.get("graph.byte_order");
             if (!byteOrder.equalsIgnoreCase("" + dir.getByteOrder()))
                 throw new IllegalStateException("Configured graph.byte_order (" + dir.getByteOrder() + ") is not equal to loaded " + byteOrder + "");
@@ -248,12 +271,9 @@ public boolean loadExisting() {
             String dim = properties.get("graph.dimension");
             baseGraph.loadExisting(dim);
 
-            String loadedCHWeightings = properties.get("graph.ch.weightings");
-            String configuredCHWeightings = getCHWeightings().toString();
-            if (!loadedCHWeightings.equals(configuredCHWeightings))
-                throw new IllegalStateException("Configured graph.ch.weightings: " + configuredCHWeightings + " is not equal to loaded " + loadedCHWeightings);
+            checkIfConfiguredAndLoadedWeightingsCompatible();
 
-            for (CHGraphImpl cg : chGraphs) {
+            for (CHGraphImpl cg : getAllCHGraphs()) {
                 if (!cg.loadExisting())
                     throw new IllegalStateException("Cannot load " + cg);
             }
@@ -263,9 +283,53 @@ public boolean loadExisting() {
         return false;
     }
 
+    private void checkIfConfiguredAndLoadedWeightingsCompatible() {
+        String loadedStrNode = properties.get("graph.ch.weightings");
+        List<String> loadedNode = parseList(loadedStrNode);
+        String loadedStrEdge = properties.get("graph.ch.edge.weightings");
+        List<String> loadedEdge = parseList(loadedStrEdge);
+        List<Weighting> configuredNode = getNodeBasedCHWeightings();
+        List<Weighting> configuredEdge = getEdgeBasedCHWeightings();
+        // todo: not entirely sure here. when no ch is configured at all (neither edge nor node), but there are any
+        // ch graphs (edge or node) we throw an error ? previously we threw an error when no ch weighting was configured
+        // even though there was a ch graph.
+        if ((configuredNode.isEmpty() && configuredEdge.isEmpty()) && (!loadedNode.isEmpty() || !loadedEdge.isEmpty())) {
+            throw new IllegalStateException("You loaded a CH graph, but you did not specify graph.ch.weightings");
+        }
+        for (Weighting w : configuredNode) {
+            if (!loadedNode.contains(w.toString())) {
+                throw new IllegalStateException("Configured weighting: " + w.toString() + " is not contained in loaded weightings for CH" + loadedStrNode + ".\n" +
+                        "You configured graph.ch.weightings: " + configuredNode);
+            }
+        }
+        for (Weighting w : configuredEdge) {
+            if (!loadedEdge.contains(w.toString())) {
+                throw new IllegalStateException("Configured weighting: " + w.toString() + " is not contained in loaded weightings for edge-based CH" + loadedStrEdge + ".\n" +
+                        "You configured graph.ch.edge.weightings: " + configuredEdge);
+            }
+        }
+    }
+
+    /**
+     * parses a string like [a,b,c]
+     */
+    private List<String> parseList(String listStr) {
+        String trimmed = listStr.trim();
+        String[] items = trimmed.substring(1, trimmed.length() - 1).split(",");
+        List<String> result = new ArrayList<>();
+        for (String item : items) {
+            String s = item.trim();
+            if (!s.isEmpty()) {
+                result.add(s);
+            }
+        }
+        return result;
+    }
+
     @Override
     public void flush() {
-        for (CHGraphImpl cg : chGraphs) {
+        for (CHGraphImpl cg : getAllCHGraphs()) {
+            cg.setNodesHeader();
             cg.setEdgesHeader();
             cg.flush();
         }
@@ -279,7 +343,7 @@ public void close() {
         properties.close();
         baseGraph.close();
 
-        for (CHGraphImpl cg : chGraphs) {
+        for (CHGraphImpl cg : getAllCHGraphs()) {
             cg.close();
         }
     }
@@ -293,7 +357,7 @@ public boolean isClosed() {
     public long getCapacity() {
         long cnt = baseGraph.getCapacity() + properties.getCapacity();
 
-        for (CHGraphImpl cg : chGraphs) {
+        for (CHGraphImpl cg : getAllCHGraphs()) {
             cnt += cg.getCapacity();
         }
         return cnt;
@@ -315,7 +379,7 @@ boolean isFrozen() {
     @Override
     public String toDetailsString() {
         String str = baseGraph.toDetailsString();
-        for (CHGraphImpl cg : chGraphs) {
+        for (CHGraphImpl cg : getAllCHGraphs()) {
             str += ", " + cg.toDetailsString();
         }
 
@@ -332,9 +396,9 @@ public String toString() {
                 + "|" + getProperties().versionsToString();
     }
 
-    // now all delegation graph method to avoid ugly programming flow ala
+    // now delegate all Graph methods to BaseGraph to avoid ugly programming flow ala
     // GraphHopperStorage storage = ..;
-    // Graph g = storage.getGraph(Graph.class);
+    // Graph g = storage.getBaseGraph();
     // instead directly the storage can be used to traverse the base graph
     @Override
     public Graph getBaseGraph() {
@@ -346,6 +410,11 @@ public int getNodes() {
         return baseGraph.getNodes();
     }
 
+    @Override
+    public int getEdges() {
+        return getAllEdges().length();
+    }
+
     @Override
     public NodeAccess getNodeAccess() {
         return baseGraph.getNodeAccess();
@@ -395,4 +464,24 @@ public Graph copyTo(Graph g) {
     public GraphExtension getExtension() {
         return baseGraph.getExtension();
     }
+
+    @Override
+    public int getOtherNode(int edge, int node) {
+        return baseGraph.getOtherNode(edge, node);
+    }
+
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        return baseGraph.isAdjacentToNode(edge, node);
+    }
+
+    private Collection<CHGraphImpl> getAllCHGraphs() {
+        // todo: this method is only used to have a 'view' on the two collections. we could also create this only once
+        // as long as the graph collections are only modified in the constructor (otherwise we would have to make sure
+        // the lists are in sync). another option would be something like guava concat.
+        List<CHGraphImpl> result = new ArrayList<>(nodeBasedCHGraphs.size() + edgeBasedCHGraphs.size());
+        result.addAll(nodeBasedCHGraphs);
+        result.addAll(edgeBasedCHGraphs);
+        return result;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/IntsRef.java b/core/src/main/java/com/graphhopper/storage/IntsRef.java
new file mode 100644
index 0000000000..f8b91a3312
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/IntsRef.java
@@ -0,0 +1,193 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.storage;
+
+import java.util.Arrays;
+
+/**
+ * Idea and most of the code is from Lucene. But the variables are final, except for the array content.
+ */
+public final class IntsRef implements Comparable<IntsRef> {
+    /**
+     * An IntsRef with an array of size 0.
+     */
+    public static final IntsRef EMPTY = new IntsRef(0, false);
+    /**
+     * The contents of the IntsRef. Cannot be {@code null}.
+     */
+    public final int[] ints;
+    /**
+     * Offset of first valid integer.
+     */
+    public final int offset;
+    /**
+     * Length of used ints.
+     */
+    public final int length;
+
+    /**
+     * Create a IntsRef pointing to a new int array of size <code>capacity</code> leading to capacity*32 bits.
+     * Offset will be zero and length will be the capacity.
+     */
+    public IntsRef(int capacity) {
+        this(capacity, true);
+    }
+
+    private IntsRef(int capacity, boolean checked) {
+        if (checked && capacity == 0)
+            throw new IllegalArgumentException("Use instance EMPTY instead of capacity 0");
+        ints = new int[capacity];
+        length = capacity;
+        offset = 0;
+    }
+
+    /**
+     * This instance will directly reference ints w/o making a copy.
+     * ints should not be null.
+     */
+    public IntsRef(int[] ints, int offset, int length) {
+        this.ints = ints;
+        this.offset = offset;
+        this.length = length;
+        assert isValid();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 0;
+        final int end = offset + length;
+        for (int i = offset; i < end; i++) {
+            result = prime * result + ints[i];
+        }
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (other == null) {
+            return false;
+        }
+        if (other instanceof IntsRef) {
+            return this.intsEquals((IntsRef) other);
+        }
+        return false;
+    }
+
+    public boolean intsEquals(IntsRef other) {
+        if (length == other.length) {
+            int otherUpto = other.offset;
+            final int[] otherInts = other.ints;
+            final int end = offset + length;
+            for (int upto = offset; upto < end; upto++, otherUpto++) {
+                if (ints[upto] != otherInts[otherUpto]) {
+                    return false;
+                }
+            }
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Signed int order comparison
+     */
+    @Override
+    public int compareTo(IntsRef other) {
+        if (this == other) return 0;
+        final int[] aInts = this.ints;
+        int aUpto = this.offset;
+        final int[] bInts = other.ints;
+        int bUpto = other.offset;
+        final int aStop = aUpto + Math.min(this.length, other.length);
+        while (aUpto < aStop) {
+            int aInt = aInts[aUpto++];
+            int bInt = bInts[bUpto++];
+            if (aInt > bInt) {
+                return 1;
+            } else if (aInt < bInt) {
+                return -1;
+            }
+        }
+        // One is a prefix of the other, or, they are equal:
+        return this.length - other.length;
+    }
+
+    /**
+     * Creates a new IntsRef that points to a copy of the ints from
+     * <code>other</code>
+     * <p>
+     * The returned IntsRef will have a length of other.length
+     * and an offset of zero.
+     */
+    public static IntsRef deepCopyOf(IntsRef other) {
+        return new IntsRef(Arrays.copyOfRange(other.ints, other.offset, other.offset + other.length), 0, other.length);
+    }
+
+    /**
+     * Performs internal consistency checks.
+     * Always returns true (or throws IllegalStateException)
+     */
+    public boolean isValid() {
+        if (ints == null) {
+            throw new IllegalStateException("ints is null");
+        }
+        if (length < 0) {
+            throw new IllegalStateException("length is negative: " + length);
+        }
+        if (length > ints.length) {
+            throw new IllegalStateException("length is out of bounds: " + length + ",ints.length=" + ints.length);
+        }
+        if (offset < 0) {
+            throw new IllegalStateException("offset is negative: " + offset);
+        }
+        if (offset > ints.length) {
+            throw new IllegalStateException("offset out of bounds: " + offset + ",ints.length=" + ints.length);
+        }
+        if (offset + length < 0) {
+            throw new IllegalStateException("offset+length is negative: offset=" + offset + ",length=" + length);
+        }
+        if (offset + length > ints.length) {
+            throw new IllegalStateException("offset+length out of bounds: offset=" + offset + ",length=" + length + ",ints.length=" + ints.length);
+        }
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append('[');
+        final int end = offset + length;
+        for (int i = offset; i < end; i++) {
+            if (i > offset) {
+                sb.append(' ');
+            }
+            sb.append(Integer.toHexString(ints[i]));
+        }
+        sb.append(']');
+        return sb.toString();
+    }
+
+    public boolean isEmpty() {
+        for (int i = 0; i < ints.length; i++) {
+            if (ints[i] != 0)
+                return false;
+        }
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
index 1fbdf7b734..a6e0fc93ce 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMDataAccess.java
@@ -77,8 +77,7 @@ public DataAccess copyTo(DataAccess da) {
     public RAMDataAccess create(long bytes) {
         if (segments.length > 0)
             throw new IllegalThreadStateException("already created");
-
-        // initialize transient values
+        
         setSegmentSize(segmentSizeInBytes);
         ensureCapacity(Math.max(10 * 4, bytes));
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
index f7a186970d..6079d4053e 100644
--- a/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
+++ b/core/src/main/java/com/graphhopper/storage/RAMIntDataAccess.java
@@ -34,7 +34,7 @@
     private int[][] segments = new int[0][];
     private boolean closed = false;
     private boolean store;
-    private transient int segmentSizeIntsPower;
+    private int segmentSizeIntsPower;
 
     RAMIntDataAccess(String name, String location, boolean store, ByteOrder order) {
         super(name, location, order);
@@ -78,7 +78,6 @@ public RAMIntDataAccess create(long bytes) {
         if (segments.length > 0)
             throw new IllegalThreadStateException("already created");
 
-        // initialize transient values
         setSegmentSize(segmentSizeInBytes);
         ensureCapacity(Math.max(10 * 4, bytes));
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java b/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java
new file mode 100644
index 0000000000..5effacd346
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/ShortcutUnpacker.java
@@ -0,0 +1,125 @@
+package com.graphhopper.storage;
+
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+
+import java.util.Locale;
+
+import static com.graphhopper.util.EdgeIterator.NO_EDGE;
+
+/**
+ * Recursively unpack shortcuts.
+ * <p>
+ *
+ * @author Peter Karich
+ * @author easbar
+ * @see PrepareContractionHierarchies
+ */
+public class ShortcutUnpacker {
+    private final Graph graph;
+    private final Visitor visitor;
+    private final boolean edgeBased;
+    private boolean reverseOrder;
+
+    public ShortcutUnpacker(Graph graph, Visitor visitor, boolean edgeBased) {
+        this.graph = graph;
+        this.visitor = visitor;
+        this.edgeBased = edgeBased;
+    }
+
+    /**
+     * Finds an edge/shortcut with the given id and adjNode and calls the visitor for each original edge that is
+     * packed inside this shortcut (or if an original edge is given simply calls the visitor on it).
+     *
+     * @param reverseOrder if true the original edges will be traversed in reverse order
+     */
+    public void visitOriginalEdgesFwd(int edgeId, int adjNode, boolean reverseOrder, int prevOrNextEdgeId) {
+        doVisitOriginalEdges(edgeId, adjNode, reverseOrder, false, prevOrNextEdgeId);
+    }
+
+    public void visitOriginalEdgesBwd(int edgeId, int adjNode, boolean reverseOrder, int prevOrNextEdgeId) {
+        doVisitOriginalEdges(edgeId, adjNode, reverseOrder, true, prevOrNextEdgeId);
+    }
+
+    private void doVisitOriginalEdges(int edgeId, int adjNode, boolean reverseOrder, boolean reverse, int prevOrNextEdgeId) {
+        this.reverseOrder = reverseOrder;
+        CHEdgeIteratorState edge = getEdge(edgeId, adjNode);
+        if (edge == null) {
+            throw new IllegalArgumentException("Edge with id: " + edgeId + " does not exist or does not touch node " + adjNode);
+        }
+        expandEdge(edge, reverse, prevOrNextEdgeId);
+    }
+
+    private void expandEdge(CHEdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+        if (!edge.isShortcut()) {
+            visitor.visit(edge, reverse, prevOrNextEdgeId);
+            return;
+        }
+        if (edgeBased) {
+            expandSkippedEdgesEdgeBased(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse, prevOrNextEdgeId);
+        } else {
+            expandSkippedEdgesNodeBased(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse);
+        }
+    }
+
+    private void expandSkippedEdgesEdgeBased(int skippedEdge1, int skippedEdge2, int base, int adj, boolean reverse, int prevOrNextEdgeId) {
+        if (reverse) {
+            int tmp = skippedEdge1;
+            skippedEdge1 = skippedEdge2;
+            skippedEdge2 = tmp;
+        }
+        CHEdgeIteratorState sk2 = getEdge(skippedEdge2, adj);
+        assert sk2 != null : "skipped edge " + skippedEdge2 + " + is not attached to adjNode " + adj + ". this should " +
+                "never happen because edge-based CH does not use bidirectional shortcuts at the moment";
+        CHEdgeIteratorState sk1 = getEdge(skippedEdge1, sk2.getBaseNode());
+        if (base == adj && (sk1.getAdjNode() == sk1.getBaseNode() || sk2.getAdjNode() == sk2.getBaseNode())) {
+            throw new IllegalStateException(String.format(Locale.ROOT,
+                    "error: detected edge where a skipped edges is a loop. this should never happen. base: %d, adj: %d, " +
+                            "skip-edge1: %d, skip-edge2: %d, reverse: %b", base, adj, skippedEdge1, skippedEdge2, reverse));
+        }
+        int adjEdge = getOppositeEdge(sk1, base);
+        if (reverseOrder) {
+            expandEdge(sk2, reverse, adjEdge);
+            expandEdge(sk1, reverse, prevOrNextEdgeId);
+        } else {
+            expandEdge(sk1, reverse, prevOrNextEdgeId);
+            expandEdge(sk2, reverse, adjEdge);
+        }
+    }
+
+    private void expandSkippedEdgesNodeBased(int skippedEdge1, int skippedEdge2, int base, int adj, boolean reverse) {
+        CHEdgeIteratorState sk2 = getEdge(skippedEdge2, adj);
+        CHEdgeIteratorState sk1;
+        if (sk2 == null) {
+            sk2 = getEdge(skippedEdge1, adj);
+            sk1 = getEdge(skippedEdge2, sk2.getBaseNode());
+        } else {
+            sk1 = getEdge(skippedEdge1, sk2.getBaseNode());
+        }
+        if (reverseOrder) {
+            expandEdge(sk2, reverse, NO_EDGE);
+            expandEdge(sk1, reverse, NO_EDGE);
+        } else {
+            expandEdge(sk1, reverse, NO_EDGE);
+            expandEdge(sk2, reverse, NO_EDGE);
+        }
+    }
+
+    private int getOppositeEdge(CHEdgeIteratorState edgeState, int adjNode) {
+        assert edgeState.getBaseNode() == adjNode || edgeState.getAdjNode() == adjNode : "adjNode " + adjNode + " must be one of adj/base of edgeState: " + edgeState;
+        // since the first/last orig edge is not stateful (just like skipped1/2) we have to find out which one
+        // is attached to adjNode, similar as we do for skipped1/2.
+        return graph.isAdjacentToNode(edgeState.getOrigEdgeLast(), adjNode)
+                ? edgeState.getOrigEdgeFirst()
+                : edgeState.getOrigEdgeLast();
+    }
+
+    private CHEdgeIteratorState getEdge(int edgeId, int adjNode) {
+        return (CHEdgeIteratorState) graph.getEdgeIteratorState(edgeId, adjNode);
+    }
+
+    public interface Visitor {
+        void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
index 1d4ef4fe35..1fcb5b4bbe 100644
--- a/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
+++ b/core/src/main/java/com/graphhopper/storage/TurnCostExtension.java
@@ -119,7 +119,7 @@ public void addTurnInfo(int fromEdge, int viaNode, int toEdge, long turnFlags) {
     }
 
     /**
-     * Add a new turn cost entry or clear an existing. See TurnFlagsReadWriteTest for usage examples.
+     * Add a new turn cost entry or clear an existing. See tests for usage examples.
      *
      * @param fromEdge  edge ID
      * @param viaNode   node ID
@@ -135,7 +135,7 @@ public void mergeOrOverwriteTurnInfo(int fromEdge, int viaNode, int toEdge, long
         long newFlags = turnFlags;
         int next = NO_TURN_ENTRY;
 
-        // determine if we already have an cost entry for this node
+        // determine if we already have a cost entry for this node
         int previousEntryIndex = nodeAccess.getAdditionalNodeField(viaNode);
         if (previousEntryIndex == NO_TURN_ENTRY) {
             // set cost-pointer to this new cost entry
@@ -189,7 +189,7 @@ public void mergeOrOverwriteTurnInfo(int fromEdge, int viaNode, int toEdge, long
      * @return turn flags of the specified node and edge properties.
      */
     public long getTurnCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
-        if (edgeFrom == EdgeIterator.NO_EDGE || edgeTo == EdgeIterator.NO_EDGE)
+        if (!EdgeIterator.Edge.isValid(edgeFrom) || !EdgeIterator.Edge.isValid(edgeTo))
             throw new IllegalArgumentException("from and to edge cannot be NO_EDGE");
         if (nodeVia < 0)
             throw new IllegalArgumentException("via node cannot be negative");
@@ -197,6 +197,10 @@ public long getTurnCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
         return nextCostFlags(edgeFrom, nodeVia, edgeTo);
     }
 
+    public boolean isUTurn(int edgeFrom, int edgeTo) {
+        return edgeFrom == edgeTo;
+    }
+
     private long nextCostFlags(int edgeFrom, int nodeVia, int edgeTo) {
         int turnCostIndex = nodeAccess.getAdditionalNodeField(nodeVia);
         int i = 0;
diff --git a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
index 7a8c04940b..248064119d 100644
--- a/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
+++ b/core/src/main/java/com/graphhopper/storage/change/ChangeGraphHelper.java
@@ -20,6 +20,8 @@
 import com.carrotsearch.hppc.cursors.IntCursor;
 import com.graphhopper.coll.GHIntHashSet;
 import com.graphhopper.json.geo.JsonFeature;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
@@ -28,13 +30,11 @@
 import com.graphhopper.storage.GraphEdgeIdFinder;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.EdgeIteratorState;
-
-import java.util.Collection;
-import java.util.Iterator;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
@@ -90,8 +90,10 @@ public long applyChanges(EncodingManager em, Collection<JsonFeature> features) {
     }
 
     private long applyChange(JsonFeature jsonFeature, FlagEncoder encoder) {
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+        DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
         long updates = 0;
-        EdgeFilter filter = DefaultEdgeFilter.allEdges(encoder);
+        EdgeFilter filter = EdgeFilter.ALL_EDGES;
         GHIntHashSet edges = new GHIntHashSet();
         if (jsonFeature.hasGeometry()) {
             graphBrowser.fillEdgeIDs(edges, jsonFeature.getGeometry(), filter);
@@ -110,17 +112,17 @@ private long applyChange(JsonFeature jsonFeature, FlagEncoder encoder) {
                 updates++;
                 if (enableLogging)
                     logger.info(encoder.toString() + " - access change via feature " + jsonFeature.getId());
-                edge.setFlags(encoder.setAccess(edge.getFlags(), value, value));
+                edge.set(accessEnc, value).setReverse(accessEnc, value);
 
             } else if (props.containsKey("speed")) {
                 // TODO use different speed for the different directions (see e.g. Bike2WeightFlagEncoder)
                 double value = ((Number) props.get("speed")).doubleValue();
-                double oldSpeed = encoder.getSpeed(edge.getFlags());
+                double oldSpeed = edge.get(avSpeedEnc);
                 if (oldSpeed != value) {
                     updates++;
                     if (enableLogging)
                         logger.info(encoder.toString() + " - speed change via feature " + jsonFeature.getId() + ". Old: " + oldSpeed + ", new:" + value);
-                    edge.setFlags(encoder.setSpeed(edge.getFlags(), value));
+                    edge.set(avSpeedEnc, value);
                 }
             }
         }
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
index 005c2538a8..b44e2baea9 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullIndex.java
@@ -23,11 +23,11 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.Circle;
 
 /**
  * Very slow O(n) LocationIndex but no RAM/disc required.
- * <p>
  *
  * @author Peter Karich
  */
@@ -102,6 +102,11 @@ public QueryResult findClosest(double queryLat, double queryLon, EdgeFilter edge
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     @Override
     public LocationIndex create(long size) {
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
index 653f666a5c..6d822a44c3 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndex.java
@@ -23,6 +23,7 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.DistanceCalc;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.BBox;
 
 /**
  * Same as full index but calculates distance to all edges too
@@ -125,6 +126,11 @@ public QueryResult findClosest(double queryLat, double queryLon, EdgeFilter filt
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     @Override
     public LocationIndex create(long size) {
         return this;
diff --git a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
index 2ae3f58ca0..59445254ac 100644
--- a/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/Location2IDQuadtree.java
@@ -337,6 +337,11 @@ protected boolean goFurther(int baseNode) {
         return res;
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+        throw new IllegalArgumentException("not implemented");
+    }
+
     public void goFurtherHook(int n) {
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
index a95d49f0d7..0717446450 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndex.java
@@ -17,8 +17,13 @@
  */
 package com.graphhopper.storage.index;
 
+import com.carrotsearch.hppc.IntHashSet;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.Storable;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.shapes.BBox;
 
 /**
  * Provides a way to map real world data "lat,lon" to internal ids/indices of a memory efficient graph
@@ -62,4 +67,56 @@
     LocationIndex setApproximation(boolean approxDist);
 
     void setSegmentSize(int bytes);
+
+    /**
+     * This method explores the nodes in this LocationIndex with the specified Visitor. It guarantees to visit all
+     * unique nodes included in the queryBBox but it could visit more.
+     */
+    void query(BBox queryBBox, Visitor function);
+
+    /**
+     * This interface allows to visit every node stored in the leafs of a LocationIndex.
+     */
+    abstract class Visitor {
+        public boolean isTileInfo() {
+            return false;
+        }
+
+        /**
+         * This method is called if isTileInfo is enabled.
+         */
+        public void onTile(BBox bbox, int depth) {
+        }
+
+        public abstract void onNode(int nodeId);
+    }
+
+    /**
+     * This abstract class allows to visit every edge from the stored nodes in the leafs of the tree for a requested
+     * area. It guarantees to visit all unique edges included in the queryBBox but it could be more.
+     */
+    abstract class EdgeVisitor extends Visitor {
+
+        private final IntHashSet edgeIds = new IntHashSet();
+        private final IntHashSet nodeIds = new IntHashSet();
+        private final EdgeExplorer edgeExplorer;
+
+        public EdgeVisitor(EdgeExplorer edgeExplorer) {
+            this.edgeExplorer = edgeExplorer;
+        }
+
+        public final void onNode(int nodeId) {
+            if (!nodeIds.add(nodeId))
+                return;
+
+            EdgeIterator iter = edgeExplorer.setBaseNode(nodeId);
+            while (iter.next()) {
+                if (!edgeIds.add(iter.getEdge()))
+                    continue;
+                onEdge(iter, nodeId, iter.getAdjNode());
+            }
+        }
+
+        public abstract void onEdge(EdgeIteratorState edge, int nodeA, int nodeB);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index ad948ec8c5..9b98cad307 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -18,6 +18,7 @@
 package com.graphhopper.storage.index;
 
 import com.carrotsearch.hppc.IntArrayList;
+import com.carrotsearch.hppc.IntHashSet;
 import com.carrotsearch.hppc.cursors.IntCursor;
 import com.carrotsearch.hppc.predicates.IntPredicate;
 import com.graphhopper.coll.GHBitSet;
@@ -29,26 +30,30 @@
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
-
-import java.util.ArrayList;
-
+import com.graphhopper.util.shapes.Shape;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
+import java.util.*;
 
 /**
- * This implementation implements an n-tree to get the closest node or edge from GPS coordinates.
- * <p>
- * All leafs are at the same depth, otherwise it is quite complicated to calculate the Bresenham
- * line for different resolutions, especially if a leaf node could be split into a tree-node and
- * resolution changes.
- * <p>
+ * This class implements a Quadtree to get the closest node or edge from GPS coordinates.
+ * The following properties are different to an ordinary implementation:
+ * <ol>
+ * <li>To reduce overall size it can use 16 instead of just 4 cell if required</li>
+ * <li>Still all leafs are at the same depth, otherwise it is too complicated to calculate the Bresenham line for different
+ * resolutions, especially if a leaf node could be split into a tree-node and resolution changes.</li>
+ * <li>To further reduce size this Quadtree avoids storing the bounding box of every cell and calculates this per request instead.</li>
+ * <li>To simplify this querying and avoid a slow down for the most frequent queries ala "lat,lon" it encodes the point
+ * into a reverse spatial key {@see SpatialKeyAlgo} and can the use the resulting raw bits as cell index to recurse
+ * into the subtrees. E.g. if there are 3 layers with 16, 4 and 4 cells each, then the reverse spatial key has
+ * three parts: 4 bits for the cellIndex into the 16 cells, 2 bits for the next layer and 2 bits for the last layer.
+ * It is the reverse spatial key and not the forward spatial key as we need the start of the index for the current
+ * layer at index 0</li>
+ * <li>An array structure (DataAccess) is internally used and stores the offset to the next cell.
+ * E.g. in case of 4 cells, the offset is 0,1,2 or 3. Except when the leaf-depth is reached, then the value
+ * is the number of node IDs stored in the cell or, if negative, just a single node ID.</li>
+ * </ol>
  *
  * @author Peter Karich
  */
@@ -61,8 +66,8 @@
     private final int MAGIC_INT;
     private final NodeAccess nodeAccess;
     protected DistanceCalc distCalc = Helper.DIST_PLANE;
-    protected SpatialKeyAlgo keyAlgo;
-    int maxRegionSearch = 4;
+    SpatialKeyAlgo keyAlgo;
+    private int maxRegionSearch = 4;
     private DistanceCalc preciseDistCalc = Helper.DIST_EARTH;
     private int[] entries;
     private byte[] shifts;
@@ -92,10 +97,10 @@ public LocationIndexTree(Graph g, Directory dir) {
         if (g instanceof CHGraph)
             throw new IllegalArgumentException("Use base graph for LocationIndexTree instead of CHGraph");
 
-        MAGIC_INT = Integer.MAX_VALUE / 22316;
+        MAGIC_INT = Integer.MAX_VALUE / 22317;
         this.graph = g;
         this.nodeAccess = g.getNodeAccess();
-        dataAccess = dir.find("location_index");
+        dataAccess = dir.find("location_index", DAType.getPreferredInt(dir.getDefaultType()));
     }
 
     public int getMinResolutionInMeter() {
@@ -133,7 +138,7 @@ void prepareAlgo() {
         equalNormedDelta = distCalc.calcNormalizedDist(0.1);
 
         // now calculate the necessary maxDepth d for our current bounds
-        // if we assume a minimum resolution like 0.5km for a leaf-tile                
+        // if we assume a minimum resolution like 0.5km for a leaf-tile
         // n^(depth/2) = toMeter(dLon) / minResolution
         BBox bounds = graph.getBounds();
         if (graph.getNodes() == 0)
@@ -153,9 +158,7 @@ void prepareAlgo() {
         tmp /= 4;
         while (tmp > 1) {
             int tmpNo;
-            if (tmp >= 64) {
-                tmpNo = 64;
-            } else if (tmp >= 16) {
+            if (tmp >= 16) {
                 tmpNo = 16;
             } else if (tmp >= 4) {
                 tmpNo = 4;
@@ -343,17 +346,19 @@ IntArrayList getEntries() {
         return IntArrayList.from(entries);
     }
 
-    // fillIDs according to how they are stored
-    final void fillIDs(long keyPart, int intIndex, GHIntHashSet set, int depth) {
-        long pointer = (long) intIndex << 2;
+    /**
+     * This method fills the set with stored node IDs from the given spatial key part (a latitude-longitude prefix).
+     */
+    final void fillIDs(long keyPart, int intPointer, GHIntHashSet set, int depth) {
+        long pointer = (long) intPointer << 2;
         if (depth == entries.length) {
-            int value = dataAccess.getInt(pointer);
-            if (value < 0) {
+            int nextIntPointer = dataAccess.getInt(pointer);
+            if (nextIntPointer < 0) {
                 // single data entries (less disc space)
-                set.add(-(value + 1));
+                set.add(-(nextIntPointer + 1));
             } else {
-                long max = (long) value * 4;
-                // leaf entry => value is maxPointer
+                long max = (long) nextIntPointer * 4;
+                // leaf entry => nextIntPointer is maxPointer
                 for (long leafIndex = pointer + 4; leafIndex < max; leafIndex += 4) {
                     set.add(dataAccess.getInt(leafIndex));
                 }
@@ -361,10 +366,10 @@ final void fillIDs(long keyPart, int intIndex, GHIntHashSet set, int depth) {
             return;
         }
         int offset = (int) (bitmasks[depth] & keyPart) << 2;
-        int value = dataAccess.getInt(pointer + offset);
-        if (value > 0) {
+        int nextIntPointer = dataAccess.getInt(pointer + offset);
+        if (nextIntPointer > 0) {
             // tree entry => negative value points to subentries
-            fillIDs(keyPart >>> shifts[depth], value, set, depth + 1);
+            fillIDs(keyPart >>> shifts[depth], nextIntPointer, set, depth + 1);
         }
     }
 
@@ -380,7 +385,6 @@ final long createReverseKey(long key) {
     /**
      * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
      * context of a spatial key tile.
-     * <p>
      */
     final double calculateRMin(double lat, double lon) {
         return calculateRMin(lat, lon, 0);
@@ -437,12 +441,76 @@ public double getDeltaLon() {
         return deltaLon;
     }
 
-    GHPoint getCenter(double lat, double lon) {
-        GHPoint query = new GHPoint(lat, lon);
-        long key = keyAlgo.encode(query);
-        GHPoint center = new GHPoint();
-        keyAlgo.decode(key, center);
-        return center;
+    public void query(BBox queryShape, final Visitor function) {
+        BBox bbox = graph.getBounds();
+        final IntHashSet set = new IntHashSet();
+        query(START_POINTER, queryShape,
+                bbox.minLat, bbox.minLon, bbox.maxLat - bbox.minLat, bbox.maxLon - bbox.minLon,
+                new Visitor() {
+                    @Override
+                    public boolean isTileInfo() {
+                        return function.isTileInfo();
+                    }
+
+                    @Override
+                    public void onTile(BBox bbox, int width) {
+                        function.onTile(bbox, width);
+                    }
+
+                    @Override
+                    public void onNode(int nodeId) {
+                        if (set.add(nodeId))
+                            function.onNode(nodeId);
+                    }
+                }, 0);
+    }
+
+    final void query(int intPointer, Shape queryBBox,
+                     double minLat, double minLon,
+                     double deltaLatPerDepth, double deltaLonPerDepth,
+                     Visitor function, int depth) {
+        long pointer = (long) intPointer << 2;
+        if (depth == entries.length) {
+            int nextIntPointer = dataAccess.getInt(pointer);
+            if (nextIntPointer < 0) {
+                // single data entries (less disc space)
+                function.onNode(-(nextIntPointer + 1));
+            } else {
+                long maxPointer = (long) nextIntPointer * 4;
+                // loop through every leaf entry => nextIntPointer is maxPointer
+                for (long leafPointer = pointer + 4; leafPointer < maxPointer; leafPointer += 4) {
+                    // we could read the whole info at once via getBytes instead of getInt
+                    function.onNode(dataAccess.getInt(leafPointer));
+                }
+            }
+            return;
+        }
+        int max = (1 << shifts[depth]);
+        int factor = max == 4 ? 2 : 4;
+        deltaLonPerDepth /= factor;
+        deltaLatPerDepth /= factor;
+        for (int cellIndex = 0; cellIndex < max; cellIndex++) {
+            int nextIntPointer = dataAccess.getInt(pointer + cellIndex * 4);
+            if (nextIntPointer <= 0)
+                continue;
+            // this bit magic does two things for the 4 and 16 tiles case:
+            // 1. it assumes the cellIndex is a reversed spatial key and so it reverses it
+            // 2. it picks every second bit (e.g. for just latitudes) and interprets the result as an integer
+            int latCount = max == 4 ? (cellIndex & 1) : (cellIndex & 1) * 2 + ((cellIndex & 4) == 0 ? 0 : 1);
+            int lonCount = max == 4 ? (cellIndex >> 1) : (cellIndex & 2) + ((cellIndex & 8) == 0 ? 0 : 1);
+            double tmpMinLon = minLon + deltaLonPerDepth * lonCount,
+                    tmpMinLat = minLat + deltaLatPerDepth * latCount;
+
+            BBox bbox = (queryBBox != null || function.isTileInfo()) ? new BBox(tmpMinLon, tmpMinLon + deltaLonPerDepth, tmpMinLat, tmpMinLat + deltaLatPerDepth) : null;
+            if (function.isTileInfo())
+                function.onTile(bbox, depth);
+            if (queryBBox == null || queryBBox.contains(bbox)) {
+                // fill without a restriction!
+                query(nextIntPointer, null, tmpMinLat, tmpMinLon, deltaLatPerDepth, deltaLonPerDepth, function, depth + 1);
+            } else if (queryBBox.intersects(bbox)) {
+                query(nextIntPointer, queryBBox, tmpMinLat, tmpMinLon, deltaLatPerDepth, deltaLonPerDepth, function, depth + 1);
+            }
+        }
     }
 
     /**
@@ -454,8 +522,8 @@ GHPoint getCenter(double lat, double lon) {
      * @return true if no further call of this method is required. False otherwise, ie. a next
      * iteration is necessary and no early finish possible.
      */
-    public final boolean findNetworkEntries(double queryLat, double queryLon,
-                                            GHIntHashSet foundEntries, int iteration) {
+    final boolean findNetworkEntries(double queryLat, double queryLon,
+                                     GHIntHashSet foundEntries, int iteration) {
         // find entries in border of searchbox
         for (int yreg = -iteration; yreg <= iteration; yreg++) {
             double subqueryLat = queryLat + yreg * deltaLat;
@@ -510,7 +578,7 @@ final double calcMinDistance(double queryLat, double queryLon, GHIntHashSet poin
         return min;
     }
 
-    public final void findNetworkEntriesSingleRegion(GHIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
+    final void findNetworkEntriesSingleRegion(GHIntHashSet storedNetworkEntryIds, double queryLat, double queryLon) {
         long keyPart = createReverseKey(queryLat, queryLon);
         fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
     }
@@ -571,13 +639,13 @@ protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorS
 
         return closestMatch;
     }
-    
+
     /**
      * Returns all edges that are within the specified radius around the queried position.
      * Searches at most 9 cells to avoid performance problems. Hence, if the radius is larger than
      * the cell width then not all edges might be returned.
-     * 
-     * TODO: either clarify the method name and description (to only search e.g. 9 tiles) or 
+     * <p>
+     * TODO: either clarify the method name and description (to only search e.g. 9 tiles) or
      * refactor so it can handle a radius larger than 9 tiles. Also remove reference to 'NClosest',
      * which is misleading, and don't always return at least one value. See map-matching #65.
      * TODO: tidy up logic - see comments in graphhopper #994.
@@ -585,7 +653,7 @@ protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorS
      * @param radius in meters
      */
     public List<QueryResult> findNClosest(final double queryLat, final double queryLon,
-            final EdgeFilter edgeFilter, double radius) {
+                                          final EdgeFilter edgeFilter, double radius) {
         // Return ALL results which are very close and e.g. within the GPS signal accuracy.
         // Also important to get all edges if GPS point is close to a junction.
         final double returnAllResultsWithin = distCalc.calcNormalizedDist(radius);
@@ -684,7 +752,7 @@ protected boolean check(int node, double normedDist, int wayIndex, EdgeIteratorS
 
         return queryResults;
     }
-    
+
     // make entries static as otherwise we get an additional reference to this class (memory waste)
     interface InMemEntry {
         boolean isLeaf();
@@ -719,10 +787,7 @@ IntArrayList getResults() {
 
     // Space efficient sorted integer set. Suited for only a few entries.
     static class SortedIntSet extends IntArrayList {
-        public SortedIntSet() {
-        }
-
-        public SortedIntSet(int capacity) {
+        SortedIntSet(int capacity) {
             super(capacity);
         }
 
@@ -859,7 +924,7 @@ void addNode(InMemEntry entry, int nodeId, int depth, long keyPart, long key) {
 
         Collection<InMemEntry> getEntriesOf(int selectDepth) {
             List<InMemEntry> list = new ArrayList<>();
-            fillLayer(list, selectDepth, 0, ((InMemTreeEntry) root).getSubEntriesForDebug());
+            fillLayer(list, selectDepth, 0, root.getSubEntriesForDebug());
             return list;
         }
 
@@ -903,48 +968,48 @@ void print(InMemEntry e, StringBuilder sb, long key, int depth) {
         }
 
         // store and freezes tree
-        int store(InMemEntry entry, int intIndex) {
-            long refPointer = (long) intIndex * 4;
+        int store(InMemEntry entry, int intPointer) {
+            long pointer = (long) intPointer * 4;
             if (entry.isLeaf()) {
                 InMemLeafEntry leaf = ((InMemLeafEntry) entry);
                 IntArrayList entries = leaf.getResults();
                 int len = entries.size();
                 if (len == 0) {
-                    return intIndex;
+                    return intPointer;
                 }
                 size += len;
-                intIndex++;
+                intPointer++;
                 leafs++;
-                dataAccess.ensureCapacity((long) (intIndex + len + 1) * 4);
+                dataAccess.ensureCapacity((long) (intPointer + len + 1) * 4);
                 if (len == 1) {
                     // less disc space for single entries
-                    dataAccess.setInt(refPointer, -entries.get(0) - 1);
+                    dataAccess.setInt(pointer, -entries.get(0) - 1);
                 } else {
-                    for (int index = 0; index < len; index++, intIndex++) {
-                        dataAccess.setInt((long) intIndex * 4, entries.get(index));
+                    for (int index = 0; index < len; index++, intPointer++) {
+                        dataAccess.setInt((long) intPointer * 4, entries.get(index));
                     }
-                    dataAccess.setInt(refPointer, intIndex);
+                    dataAccess.setInt(pointer, intPointer);
                 }
             } else {
                 InMemTreeEntry treeEntry = ((InMemTreeEntry) entry);
                 int len = treeEntry.subEntries.length;
-                intIndex += len;
-                for (int subCounter = 0; subCounter < len; subCounter++, refPointer += 4) {
+                intPointer += len;
+                for (int subCounter = 0; subCounter < len; subCounter++, pointer += 4) {
                     InMemEntry subEntry = treeEntry.subEntries[subCounter];
                     if (subEntry == null) {
                         continue;
                     }
-                    dataAccess.ensureCapacity((long) (intIndex + 1) * 4);
-                    int beforeIntIndex = intIndex;
-                    intIndex = store(subEntry, beforeIntIndex);
-                    if (intIndex == beforeIntIndex) {
-                        dataAccess.setInt(refPointer, 0);
+                    dataAccess.ensureCapacity((long) (intPointer + 1) * 4);
+                    int prevIntPointer = intPointer;
+                    intPointer = store(subEntry, prevIntPointer);
+                    if (intPointer == prevIntPointer) {
+                        dataAccess.setInt(pointer, 0);
                     } else {
-                        dataAccess.setInt(refPointer, beforeIntIndex);
+                        dataAccess.setInt(pointer, prevIntPointer);
                     }
                 }
             }
-            return intIndex;
+            return intPointer;
         }
     }
 
diff --git a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
index ed68a50c1d..f2695ad087 100644
--- a/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
+++ b/core/src/main/java/com/graphhopper/storage/index/QueryResult.java
@@ -38,10 +38,11 @@
  * @author Peter Karich
  */
 public class QueryResult {
+    public static final int INVALID_NODE = -1;
     private final GHPoint queryPoint;
     private double queryDistance = Double.MAX_VALUE;
     private int wayIndex = -1;
-    private int closestNode = -1;
+    private int closestNode = INVALID_NODE;
     private EdgeIteratorState closestEdge;
     private GHPoint3D snappedPoint;
     private Position snappedPosition;
@@ -54,7 +55,7 @@ public QueryResult(double queryLat, double queryLon) {
      * Returns the closest matching node. This is either a tower node of the base graph
      * or a virtual node (see also {@link com.graphhopper.routing.QueryGraph#lookup(List)}).
      *
-     * @return -1 if nothing found, this should be avoided via a call of 'isValid'
+     * @return {@link #INVALID_NODE} if nothing found, this should be avoided via a call of 'isValid'
      */
     public int getClosestNode() {
         return closestNode;
@@ -164,14 +165,14 @@ public void calcSnappedPoint(DistanceCalc distCalc) {
     @Override
     public String toString() {
         if (closestEdge != null)
-            return closestEdge.getBaseNode() + "-" + closestEdge.getAdjNode() + "  " + snappedPoint;
+            return closestEdge.getBaseNode() + "-" + closestEdge.getAdjNode() + "  " + snappedPoint + ", " + queryPoint;
         return closestNode + ", " + queryPoint + ", " + wayIndex;
     }
 
     /**
      * Whether the query point is projected onto a tower node, pillar node or somewhere within
      * the closest edge.
-     *
+     * <p>
      * Due to precision differences it is hard to define when something is exactly 90° or "on-node"
      * like TOWER or PILLAR or if it is more "on-edge" (EDGE). The default mechanism is to prefer
      * "on-edge" even if it could be 90°. To prefer "on-node" you could use e.g. GHPoint.equals with
diff --git a/core/src/main/java/com/graphhopper/util/BitUtil.java b/core/src/main/java/com/graphhopper/util/BitUtil.java
index 17f4d696b1..e7733cbb9e 100644
--- a/core/src/main/java/com/graphhopper/util/BitUtil.java
+++ b/core/src/main/java/com/graphhopper/util/BitUtil.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.storage.IntsRef;
+
 import java.nio.ByteOrder;
 
 /**
@@ -167,6 +169,14 @@ public final long fromBitString2Long(String str) {
 
     public abstract byte[] fromBitString(String str);
 
+    public final String toBitString(IntsRef intsRef) {
+        StringBuilder str = new StringBuilder();
+        for (int ints : intsRef.ints) {
+            str.append(toBitString(ints, 32));
+        }
+        return str.toString();
+    }
+
     /**
      * Similar to Long.toBinaryString
      */
diff --git a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
index a587af2fe6..773d78e259 100644
--- a/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/BreadthFirstSearch.java
@@ -21,11 +21,10 @@
 
 /**
  * Implementation of breadth first search (BFS)
- * <p>
  *
  * @author Peter Karich
  */
-public class BreadthFirstSearch extends XFirstSearch {
+public abstract class BreadthFirstSearch extends XFirstSearch {
     @Override
     public void start(EdgeExplorer explorer, int startNode) {
         SimpleIntDeque fifo = new SimpleIntDeque();
diff --git a/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
index 173cb6b192..3804f3d5cc 100644
--- a/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/CHEdgeIteratorState.java
@@ -36,7 +36,16 @@
     /**
      * Sets the edges that this shortcut skips. Those skipped edges can be shortcuts too.
      */
-    void setSkippedEdges(int edge1, int edge2);
+    CHEdgeIteratorState setSkippedEdges(int edge1, int edge2);
+
+    /**
+     * Sets the first and last original edges that are skipped by this shortcut. For example for the following shortcut
+     * edge from x to y, which itself skips the shortcuts x->v and v->y the first original edge would be x->u and the
+     * last original edge would be w->y
+     * <p>
+     * x --> u --> v --> w --> y
+     */
+    CHEdgeIteratorState setFirstAndLastOrigEdges(int firstOrigEdge, int lastOrigEdge);
 
     /**
      * @return true if this edge is a shortcut, false otherwise.
@@ -46,9 +55,9 @@
     /**
      * This method is only used on preparation.
      *
-     * @see PrepareEncoder#getScMergeStatus(long, long)
+     * @see PrepareEncoder#getScMergeStatus(int, int)
      */
-    int getMergeStatus(long flags);
+    int getMergeStatus(int flags);
 
     /**
      * Returns the weight of this shortcut.
@@ -59,4 +68,6 @@
      * Sets the weight calculated from Weighting.calcWeight, only applicable if isShortcut is true.
      */
     CHEdgeIteratorState setWeight(double weight);
+
+    void setFlagsAndWeight(int flags, double weight);
 }
diff --git a/core/src/main/java/com/graphhopper/util/Constants.java b/core/src/main/java/com/graphhopper/util/Constants.java
index 17fd86dd15..1944b81ac4 100644
--- a/core/src/main/java/com/graphhopper/util/Constants.java
+++ b/core/src/main/java/com/graphhopper/util/Constants.java
@@ -78,6 +78,7 @@
      */
     public static final String VERSION;
     public static final String BUILD_DATE;
+    public static final String GIT_INFO;
     public static final boolean SNAPSHOT;
 
     static {
@@ -124,6 +125,18 @@
         } catch (Exception ex) {
         }
         BUILD_DATE = buildDate;
+
+        String gitInfo = "";
+        try {
+            List<String> gitInfos = readFile(new InputStreamReader(GraphHopper.class.getResourceAsStream("gitinfo"), UTF_CS));
+            if (gitInfos.size() == 5) {
+                gitInfo = gitInfos.get(1) + "|" + gitInfos.get(2) + "|dirty=" + gitInfos.get(3) + "|" + gitInfos.get(4);
+            } else {
+                System.err.println("GraphHopper Initialization WARNING: unexpected git info: " + gitInfos.toString());
+            }
+        } catch (Exception ex) {
+        }
+        GIT_INFO = gitInfo;
     }
 
     public static String getVersions() {
diff --git a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
index 179de1daa3..10a9c8df88 100644
--- a/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/DepthFirstSearch.java
@@ -22,12 +22,11 @@
 
 /**
  * Implementation of depth first search (DFS) by LIFO queue
- * <p>
  *
  * @author Peter Karich
  * @author Jan Sölter
  */
-public class DepthFirstSearch extends XFirstSearch {
+public abstract class DepthFirstSearch extends XFirstSearch {
     /**
      * beginning with startNode add all following nodes to LIFO queue. If node has been already
      * explored before, skip reexploration.
diff --git a/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java b/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
index a8562aaf12..c34596ee5a 100644
--- a/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
+++ b/core/src/main/java/com/graphhopper/util/DistanceCalc2D.java
@@ -19,6 +19,9 @@
 
 import static java.lang.Math.sqrt;
 
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+
 /**
  * Calculates the distance of two points or one point and an edge in euclidean space.
  * <p>
@@ -44,6 +47,10 @@ public double calcNormalizedDist(double dist) {
         return dist * dist;
     }
 
+    double calcShrinkFactor(double a_lat_deg, double b_lat_deg) {
+        return 1.;
+    }
+
     /**
      * Calculates in normalized meter
      */
@@ -58,4 +65,30 @@ public double calcNormalizedDist(double fromY, double fromX, double toY, double
     public String toString() {
         return "2D";
     }
+
+    @Override
+    public double calcCircumference(double lat) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
+
+    @Override
+    public boolean isDateLineCrossOver(double lon1, double lon2) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
+
+    @Override
+    public BBox createBBox(double lat, double lon, double radiusInMeter) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
+
+    @Override
+    public GHPoint projectCoordinate(double latInDeg, double lonInDeg, double distanceInMeter,
+            double headingClockwiseFromNorth) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
+
+    @Override
+    public boolean isCrossBoundary(double lon1, double lon2) {
+        throw new UnsupportedOperationException("Not supported for the 2D Euclidean space");
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIterator.java b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
index 4fa6b3a3be..0f4d77c439 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIterator.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIterator.java
@@ -40,8 +40,9 @@
  */
 public interface EdgeIterator extends EdgeIteratorState {
     /**
-     * integer value to indicate if an edge is valid or not which then would be initialized with
-     * this value
+     * Integer value used in places where normally an edge would be expected, but none is given. For example in the
+     * shortest path tree of route calculations every child element should have an incoming edge, but for the root item
+     * there is no parent so we would use this value instead.
      */
     int NO_EDGE = -1;
 
@@ -54,8 +55,13 @@
     boolean next();
 
     class Edge {
+        /**
+         * Checks if a given integer edge ID is valid or not. Edge IDs >= 0 are considered valid, while negative
+         * values are considered as invalid. However, some negative values are used as special values, e.g. {@link
+         * #NO_EDGE}.
+         */
         public static boolean isValid(int edgeId) {
-            return edgeId > NO_EDGE;
+            return edgeId >= 0;
         }
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
index 75366a295e..6bc1c33942 100644
--- a/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
+++ b/core/src/main/java/com/graphhopper/util/EdgeIteratorState.java
@@ -17,18 +17,47 @@
  */
 package com.graphhopper.util;
 
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.storage.IntsRef;
 
 /**
  * This interface represents an edge and is one possible state of an EdgeIterator.
- * <p>
  *
  * @author Peter Karich
  * @see EdgeIterator
  * @see EdgeExplorer
  */
 public interface EdgeIteratorState {
-    int K_UNFAVORED_EDGE = -1;
+    BooleanEncodedValue UNFAVORED_EDGE = new SimpleBooleanEncodedValue("unfavored");
+    /**
+     * This method can be used to fetch the internal reverse state of an edge.
+     */
+    BooleanEncodedValue REVERSE_STATE = new BooleanEncodedValue() {
+        @Override
+        public int init(InitializerConfig init) {
+            throw new IllegalStateException("Cannot happen for this BooleanEncodedValue");
+        }
+
+        @Override
+        public String getName() {
+            return "reverse";
+        }
+
+        @Override
+        public int getVersion() {
+            return 1;
+        }
+
+        @Override
+        public boolean getBool(boolean reverse, IntsRef ref) {
+            return reverse;
+        }
+
+        @Override
+        public void setBool(boolean reverse, IntsRef ref, boolean value) {
+            throw new IllegalStateException("reverse state cannot be modified");
+        }
+    };
 
     /**
      * @return the edge id of the current edge. Do not make any assumptions about the concrete
@@ -36,6 +65,17 @@
      */
     int getEdge();
 
+    /**
+     * @return the edge id of the first original edge of the current edge. This is needed for shortcuts
+     * in edge-based contraction hierarchies and otherwise simply returns the id of the current edge.
+     */
+    int getOrigEdgeFirst();
+
+    /**
+     * @see #getOrigEdgeFirst()
+     */
+    int getOrigEdgeLast();
+
     /**
      * Returns the node used to instantiate the EdgeIterator. Example: "EdgeIterator iter =
      * graph.getEdges(baseNode)". Often only used for convenience reasons. Do not confuse this with
@@ -54,7 +94,7 @@
     int getAdjNode();
 
     /**
-     * For roadnetwork data like OSM a way is nearly always a curve not just a straight line. These
+     * For road network data like OSM a way is nearly always a curve not just a straight line. These
      * nodes are called pillar nodes and are between tower nodes (which are used for routing), they
      * are necessary to have a more exact geometry. See the docs for more information
      * (docs/core/low-level-api.md#what-are-pillar-and-tower-nodes). Updates to the returned list
@@ -69,8 +109,9 @@
     PointList fetchWayGeometry(int mode);
 
     /**
-     * @param list is a sorted collection of nodes between the baseNode and the current adjacent
-     *             node. Specify the list without the adjacent and base nodes.
+     * @param list is a sorted collection of nodes between the base node and the current adjacent node. Specify the list
+     *             without the adjacent and base node. This method can be called multiple times, but if the distance
+     *             changes, the setDistance method is not called automatically.
      */
     EdgeIteratorState setWayGeometry(PointList list);
 
@@ -81,9 +122,16 @@
 
     EdgeIteratorState setDistance(double dist);
 
-    long getFlags();
+    /**
+     * Returns edge properties stored in direction of the raw database layout. So do not use it directly, instead
+     * use the appropriate set/get methods with its EncodedValue object.
+     */
+    IntsRef getFlags();
 
-    EdgeIteratorState setFlags(long flags);
+    /**
+     * Stores the specified edgeFlags down to the DataAccess
+     */
+    EdgeIteratorState setFlags(IntsRef edgeFlags);
 
     /**
      * @return the additional field value for this edge
@@ -95,24 +143,37 @@
      */
     EdgeIteratorState setAdditionalField(int value);
 
-    /**
-     * @see FlagEncoder#isForward(long) and #472
-     */
-    boolean isForward(FlagEncoder encoder);
+    boolean get(BooleanEncodedValue property);
 
-    /**
-     * @see FlagEncoder#isBackward(long) and #472
-     */
-    boolean isBackward(FlagEncoder encoder);
+    EdgeIteratorState set(BooleanEncodedValue property, boolean value);
 
-    /**
-     * Get additional boolean information of the edge.
-     * <p>
-     *
-     * @param key      direction or vehicle dependent integer key
-     * @param _default default value if key is not found
-     */
-    boolean getBool(int key, boolean _default);
+    boolean getReverse(BooleanEncodedValue property);
+
+    EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value);
+
+    int get(IntEncodedValue property);
+
+    EdgeIteratorState set(IntEncodedValue property, int value);
+
+    int getReverse(IntEncodedValue property);
+
+    EdgeIteratorState setReverse(IntEncodedValue property, int value);
+
+    double get(DecimalEncodedValue property);
+
+    EdgeIteratorState set(DecimalEncodedValue property, double value);
+
+    double getReverse(DecimalEncodedValue property);
+
+    EdgeIteratorState setReverse(DecimalEncodedValue property, double value);
+
+    <T extends Enum> T get(EnumEncodedValue<T> property);
+
+    <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value);
+
+    <T extends Enum> T getReverse(EnumEncodedValue<T> property);
+
+    <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value);
 
     String getName();
 
@@ -120,19 +181,17 @@
 
     /**
      * Clones this EdgeIteratorState.
-     * <p>
      *
      * @param reverse if true a detached edgeState with reversed properties is created where base
      *                and adjacent nodes, flags and wayGeometry are in reversed order. See #162 for more details
-     *                about why we need the new reverse parameter.
+     *                about why we need the reverse parameter.
      */
     EdgeIteratorState detach(boolean reverse);
 
     /**
-     * Copies the properties of this edge into the specified edge. Does not change nodes!
-     * <p>
+     * Copies the properties of the specified edge into this edge. Does not change nodes!
      *
      * @return the specified edge e
      */
-    EdgeIteratorState copyPropertiesTo(EdgeIteratorState e);
+    EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e);
 }
diff --git a/core/src/main/java/com/graphhopper/util/EngineWarmUp.java b/core/src/main/java/com/graphhopper/util/EngineWarmUp.java
index 261ef72784..0822231bd9 100644
--- a/core/src/main/java/com/graphhopper/util/EngineWarmUp.java
+++ b/core/src/main/java/com/graphhopper/util/EngineWarmUp.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.GHRequest;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.storage.GraphHopperStorage;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -79,6 +81,11 @@ private static void warmUpNonCHSubNetwork(final GraphHopper graphHopper, int ite
             BreadthFirstSearch bfs = new BreadthFirstSearch() {
                 int counter = 0;
 
+                @Override
+                protected GHBitSet createBitSet() {
+                    return new GHTBitSet(graphHopper.getMaxVisitedNodes());
+                }
+
                 @Override
                 public boolean goFurther(int nodeId) {
                     counter++;
diff --git a/core/src/main/java/com/graphhopper/util/GHUtility.java b/core/src/main/java/com/graphhopper/util/GHUtility.java
index 46bbf740eb..6fff92e309 100644
--- a/core/src/main/java/com/graphhopper/util/GHUtility.java
+++ b/core/src/main/java/com/graphhopper/util/GHUtility.java
@@ -21,12 +21,17 @@
 import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.coll.GHIntArrayList;
-import com.graphhopper.routing.util.AllCHEdgesIterator;
-import com.graphhopper.routing.util.AllEdgesIterator;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.coll.GHTBitSet;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.IntEncodedValue;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.parsers.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.shapes.BBox;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -34,13 +39,14 @@
 /**
  * A helper class to avoid cluttering the Graph interface with all the common methods. Most of the
  * methods are useful for unit tests or debugging only.
- * <p>
  *
  * @author Peter Karich
  */
 public class GHUtility {
+    private static final Logger LOGGER = LoggerFactory.getLogger(GHUtility.class);
+
     /**
-     * This method could throw exception if uncatched problems like index out of bounds etc
+     * This method could throw an exception if problems like index out of bounds etc
      */
     public static List<String> getProblems(Graph g) {
         List<String> problems = new ArrayList<>();
@@ -117,10 +123,11 @@ public static int count(EdgeIterator iter) {
     public static void printEdgeInfo(final Graph g, FlagEncoder encoder) {
         System.out.println("-- Graph nodes:" + g.getNodes() + " edges:" + g.getAllEdges().length() + " ---");
         AllEdgesIterator iter = g.getAllEdges();
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
         while (iter.next()) {
             String prefix = (iter instanceof AllCHEdgesIterator && ((AllCHEdgesIterator) iter).isShortcut()) ? "sc" : "  ";
-            String fwdStr = iter.isForward(encoder) ? "fwd" : "   ";
-            String bwdStr = iter.isBackward(encoder) ? "bwd" : "   ";
+            String fwdStr = iter.get(accessEnc) ? "fwd" : "   ";
+            String bwdStr = iter.getReverse(accessEnc) ? "bwd" : "   ";
             System.out.println(prefix + " " + iter + " " + fwdStr + " " + bwdStr + " " + iter.getDistance());
         }
     }
@@ -131,6 +138,7 @@ public static void printGraphForUnitTest(Graph g, FlagEncoder encoder) {
     }
 
     public static void printGraphForUnitTest(Graph g, FlagEncoder encoder, BBox bBox) {
+        System.out.println("WARNING: printGraphForUnitTest does not pay attention to custom edge speeds at the moment");
         NodeAccess na = g.getNodeAccess();
         for (int node = 0; node < g.getNodes(); ++node) {
             if (bBox.contains(na.getLat(node), na.getLon(node))) {
@@ -146,9 +154,10 @@ public static void printGraphForUnitTest(Graph g, FlagEncoder encoder, BBox bBox
         }
     }
 
-    private static void printUnitTestEdge(FlagEncoder flagEncoder, EdgeIteratorState edge) {
-        boolean fwd = edge.isForward(flagEncoder);
-        boolean bwd = edge.isBackward(flagEncoder);
+    private static void printUnitTestEdge(FlagEncoder encoder, EdgeIteratorState edge) {
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+        boolean fwd = edge.get(accessEnc);
+        boolean bwd = edge.getReverse(accessEnc);
         if (!fwd && !bwd) {
             return;
         }
@@ -158,10 +167,105 @@ private static void printUnitTestEdge(FlagEncoder flagEncoder, EdgeIteratorState
                 "graph.edge(%d, %d, %f, %s);\n", from, to, edge.getDistance(), fwd && bwd ? "true" : "false");
     }
 
+    public static void buildRandomGraph(Graph graph, Random random, int numNodes, double meanDegree, boolean allowLoops,
+                                        boolean allowZeroDistance, DecimalEncodedValue randomSpeedEnc,
+                                        double pNonZeroLoop, double pBothDir, double pRandomOffset) {
+        if (numNodes < 2 || meanDegree < 1) {
+            throw new IllegalArgumentException("numNodes must be >= 2, meanDegree >= 1");
+        }
+        for (int i = 0; i < numNodes; ++i) {
+            double lat = 49.4 + (random.nextDouble() * 0.01);
+            double lon = 9.7 + (random.nextDouble() * 0.01);
+            graph.getNodeAccess().setNode(i, lat, lon);
+        }
+        double minDist = Double.MAX_VALUE;
+        double maxDist = Double.MIN_VALUE;
+        int totalNumEdges = (int) (0.5 * meanDegree * numNodes);
+        int numEdges = 0;
+        while (numEdges < totalNumEdges) {
+            int from = random.nextInt(numNodes);
+            int to = random.nextInt(numNodes);
+            if (!allowLoops && from == to) {
+                continue;
+            }
+            double distance = GHUtility.getDistance(from, to, graph.getNodeAccess());
+            // allow loops with non-zero distance
+            if (from == to && random.nextDouble() < pNonZeroLoop) {
+                distance = random.nextDouble() * 1000;
+            }
+            if (!allowZeroDistance) {
+                distance = Math.max(0.001, distance);
+            }
+            // add some random offset, but also allow duplicate edges with same weight
+            if (random.nextDouble() < pRandomOffset)
+                distance += random.nextDouble() * distance * 0.01;
+            minDist = Math.min(minDist, distance);
+            maxDist = Math.max(maxDist, distance);
+            // using bidirectional edges will increase mean degree of graph above given value
+            boolean bothDirections = random.nextDouble() < pBothDir;
+            EdgeIteratorState edge = graph.edge(from, to, distance, bothDirections);
+            double fwdSpeed = 10 + random.nextDouble() * 120;
+            double bwdSpeed = 10 + random.nextDouble() * 120;
+            if (randomSpeedEnc != null) {
+                edge.set(randomSpeedEnc, fwdSpeed);
+                if (randomSpeedEnc.isStoreTwoDirections())
+                    edge.setReverse(randomSpeedEnc, bwdSpeed);
+            }
+            numEdges++;
+        }
+        LOGGER.debug(String.format(Locale.ROOT, "Finished building random graph" +
+                        ", nodes: %d, edges: %d , min distance: %.2f, max distance: %.2f\n",
+                graph.getNodes(), graph.getAllEdges().length(), minDist, maxDist));
+    }
+
+    public static double getDistance(int from, int to, NodeAccess nodeAccess) {
+        double fromLat = nodeAccess.getLat(from);
+        double fromLon = nodeAccess.getLon(from);
+        double toLat = nodeAccess.getLat(to);
+        double toLon = nodeAccess.getLon(to);
+        return Helper.DIST_PLANE.calcDist(fromLat, fromLon, toLat, toLon);
+    }
+
+    public static void addRandomTurnCosts(Graph graph, long seed, FlagEncoder encoder, int maxTurnCost, TurnCostExtension turnCostExtension) {
+        Random random = new Random(seed);
+        double pNodeHasTurnCosts = 0.3;
+        double pEdgePairHasTurnCosts = 0.6;
+        double pCostIsRestriction = 0.1;
+        EdgeExplorer inExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder));
+        EdgeExplorer outExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder));
+        for (int node = 0; node < graph.getNodes(); ++node) {
+            if (random.nextDouble() < pNodeHasTurnCosts) {
+                EdgeIterator inIter = inExplorer.setBaseNode(node);
+                while (inIter.next()) {
+                    EdgeIterator outIter = outExplorer.setBaseNode(node);
+                    while (outIter.next()) {
+                        if (inIter.getEdge() == outIter.getEdge()) {
+                            // leave u-turns as they are
+                            continue;
+                        }
+                        if (random.nextDouble() < pEdgePairHasTurnCosts) {
+                            boolean restricted = false;
+                            if (random.nextDouble() < pCostIsRestriction) {
+                                restricted = true;
+                            }
+                            double cost = restricted ? 0 : random.nextDouble() * maxTurnCost;
+                            turnCostExtension.addTurnInfo(inIter.getEdge(), node, outIter.getEdge(), encoder.getTurnFlags(restricted, cost));
+                        }
+                    }
+                }
+            }
+        }
+    }
+
     public static void printInfo(final Graph g, int startNode, final int counts, final EdgeFilter filter) {
         new BreadthFirstSearch() {
             int counter = 0;
 
+            @Override
+            protected GHBitSet createBitSet() {
+                return new GHTBitSet();
+            }
+
             @Override
             protected boolean goFurther(int nodeId) {
                 System.out.println(getNodeInfo(g, nodeId, filter));
@@ -177,7 +281,7 @@ public static String getNodeInfo(CHGraph g, int nodeId, EdgeFilter filter) {
         String str = nodeId + ":" + na.getLatitude(nodeId) + "," + na.getLongitude(nodeId) + "\n";
         while (iter.next()) {
             str += "  ->" + iter.getAdjNode() + "(" + iter.getSkippedEdge1() + "," + iter.getSkippedEdge2() + ") "
-                    + iter.getEdge() + " \t" + BitUtil.BIG.toBitString(iter.getFlags(), 8) + "\n";
+                    + iter.getEdge() + " \t" + BitUtil.BIG.toBitString(iter.getFlags().ints[0], 8) + "\n";
         }
         return str;
     }
@@ -189,7 +293,7 @@ public static String getNodeInfo(Graph g, int nodeId, EdgeFilter filter) {
         while (iter.next()) {
             str += "  ->" + iter.getAdjNode() + " (" + iter.getDistance() + ") pillars:"
                     + iter.fetchWayGeometry(0).getSize() + ", edgeId:" + iter.getEdge()
-                    + "\t" + BitUtil.BIG.toBitString(iter.getFlags(), 8) + "\n";
+                    + "\t" + BitUtil.BIG.toBitString(iter.getFlags().ints[0], 8) + "\n";
         }
         return str;
     }
@@ -246,7 +350,7 @@ static Graph createSortedGraph(Graph fromGraph, Graph toSortedGraph, final IntIn
             if (newBaseIndex < 0 || newAdjIndex < 0)
                 continue;
 
-            eIter.copyPropertiesTo(toSortedGraph.edge(newBaseIndex, newAdjIndex));
+            toSortedGraph.edge(newBaseIndex, newAdjIndex).copyPropertiesFrom(eIter);
         }
 
         int nodes = fromGraph.getNodes();
@@ -271,7 +375,7 @@ public static Graph copyTo(Graph fromGraph, Graph toGraph) {
         while (eIter.next()) {
             int base = eIter.getBaseNode();
             int adj = eIter.getAdjNode();
-            eIter.copyPropertiesTo(toGraph.edge(base, adj));
+            toGraph.edge(base, adj).copyPropertiesFrom(eIter);
         }
 
         NodeAccess fna = fromGraph.getNodeAccess();
@@ -302,7 +406,7 @@ public static GraphHopperStorage newStorage(GraphHopperStorage store) {
         Directory outdir = guessDirectory(store);
         boolean is3D = store.getNodeAccess().is3D();
 
-        return new GraphHopperStorage(store.getCHWeightings(), outdir, store.getEncodingManager(),
+        return new GraphHopperStorage(store.getNodeBasedCHWeightings(), store.getEdgeBasedCHWeightings(), outdir, store.getEncodingManager(),
                 is3D, store.getExtension()).
                 create(store.getNodes());
     }
@@ -315,7 +419,12 @@ public static int getAdjNode(Graph g, int edge, int adjNode) {
         return adjNode;
     }
 
-    public static EdgeIteratorState createMockedEdgeIteratorState(final double distance, final long flags) {
+    public static EdgeIteratorState createMockedEdgeIteratorState(final double distance, final IntsRef flags) {
+        return createMockedEdgeIteratorState(distance, flags, 0, 1, 2, 3, 4);
+    }
+
+    public static EdgeIteratorState createMockedEdgeIteratorState(final double distance, final IntsRef flags,
+                                                                  final int base, final int adj, final int edge, final int origFirst, final int origLast) {
         return new GHUtility.DisabledEdgeIterator() {
             @Override
             public double getDistance() {
@@ -323,13 +432,68 @@ public double getDistance() {
             }
 
             @Override
-            public long getFlags() {
+            public IntsRef getFlags() {
                 return flags;
             }
 
             @Override
-            public boolean getBool(int key, boolean _default) {
-                return _default;
+            public boolean get(BooleanEncodedValue property) {
+                return property.getBool(false, flags);
+            }
+
+            @Override
+            public boolean getReverse(BooleanEncodedValue property) {
+                return property.getBool(true, flags);
+            }
+
+            @Override
+            public double get(DecimalEncodedValue property) {
+                return property.getDecimal(false, flags);
+            }
+
+            @Override
+            public double getReverse(DecimalEncodedValue property) {
+                return property.getDecimal(true, flags);
+            }
+
+            @Override
+            public <T extends Enum> T get(EnumEncodedValue<T> property) {
+                return property.getEnum(false, flags);
+            }
+
+            @Override
+            public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+                return property.getEnum(true, flags);
+            }
+
+            @Override
+            public int getEdge() {
+                return edge;
+            }
+
+            @Override
+            public int getBaseNode() {
+                return base;
+            }
+
+            @Override
+            public int getAdjNode() {
+                return adj;
+            }
+
+            @Override
+            public PointList fetchWayGeometry(int type) {
+                return Helper.createPointList(0, 2, 6, 4);
+            }
+
+            @Override
+            public int getOrigEdgeFirst() {
+                return origFirst;
+            }
+
+            @Override
+            public int getOrigEdgeLast() {
+                return origLast;
             }
         };
     }
@@ -354,7 +518,7 @@ public static EdgeIteratorState getEdge(Graph graph, int base, int adj) {
     public static int createEdgeKey(int nodeA, int nodeB, int edgeId, boolean reverse) {
         edgeId = edgeId << 1;
         if (reverse)
-            return (nodeA > nodeB) ? edgeId : edgeId + 1;
+            return (nodeA >= nodeB) ? edgeId : edgeId + 1;
         return (nodeA > nodeB) ? edgeId + 1 : edgeId;
     }
 
@@ -380,6 +544,67 @@ public static int getEdgeFromEdgeKey(int edgeKey) {
         return edgeKey / 2;
     }
 
+    /**
+     * Returns the edge key for a given edge id and adjacent node. This is needed in a few places where
+     * the base node is not known.
+     */
+    public static int getEdgeKey(Graph graph, int edgeId, int node, boolean reverse) {
+        EdgeIteratorState edgeIteratorState = graph.getEdgeIteratorState(edgeId, node);
+        return GHUtility.createEdgeKey(edgeIteratorState.getBaseNode(), edgeIteratorState.getAdjNode(), edgeId, reverse);
+    }
+
+    public static IntsRef setProperties(IntsRef edgeFlags, FlagEncoder encoder, double averageSpeed, boolean fwd, boolean bwd) {
+        if (averageSpeed < 0.0001 && (fwd || bwd))
+            throw new IllegalStateException("Zero speed is only allowed if edge will get inaccessible. Otherwise Weighting can produce inconsistent results");
+
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+        DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
+        accessEnc.setBool(false, edgeFlags, fwd);
+        accessEnc.setBool(true, edgeFlags, bwd);
+        if (fwd)
+            avSpeedEnc.setDecimal(false, edgeFlags, averageSpeed);
+        if (bwd)
+            avSpeedEnc.setDecimal(true, edgeFlags, averageSpeed);
+        return edgeFlags;
+    }
+
+    public static EdgeIteratorState setProperties(EdgeIteratorState edge, FlagEncoder encoder, double fwdSpeed, double bwdSpeed) {
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+        edge.set(accessEnc, true).setReverse(accessEnc, true);
+        DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
+        return edge.set(avSpeedEnc, fwdSpeed).setReverse(avSpeedEnc, bwdSpeed);
+    }
+
+    public static IntsRef setProperties(IntsRef edgeFlags, FlagEncoder encoder, double fwdSpeed, double bwdSpeed) {
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+        accessEnc.setBool(false, edgeFlags, true);
+        accessEnc.setBool(true, edgeFlags, true);
+        DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
+        avSpeedEnc.setDecimal(false, edgeFlags, fwdSpeed);
+        avSpeedEnc.setDecimal(true, edgeFlags, bwdSpeed);
+        return edgeFlags;
+    }
+
+    public static EdgeIteratorState setProperties(EdgeIteratorState edge, FlagEncoder encoder, double averageSpeed, boolean fwd, boolean bwd) {
+        if (averageSpeed < 0.0001 && (fwd || bwd))
+            throw new IllegalStateException("Zero speed is only allowed if edge will get inaccessible. Otherwise Weighting can produce inconsistent results");
+
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+        DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
+        edge.set(accessEnc, fwd).setReverse(accessEnc, bwd);
+        if (fwd)
+            edge.set(avSpeedEnc, averageSpeed);
+        if (bwd && avSpeedEnc.isStoreTwoDirections())
+            edge.setReverse(avSpeedEnc, averageSpeed);
+        return edge;
+    }
+
+    public static final EncodingManager.Builder addDefaultEncodedValues(EncodingManager.Builder builder) {
+        return builder.add(new OSMRoadClassParser()).add(new OSMRoadClassLinkParser()).
+                add(new OSMRoadEnvironmentParser()).add(new OSMMaxSpeedParser()).add(new OSMRoadAccessParser()).
+                add(new OSMSurfaceParser());
+    }
+
     /**
      * This edge iterator can be used in tests to mock specific iterator behaviour via overloading
      * certain methods.
@@ -396,7 +621,7 @@ public EdgeIteratorState setDistance(double dist) {
         }
 
         @Override
-        public EdgeIteratorState setFlags(long flags) {
+        public EdgeIteratorState setFlags(IntsRef flags) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
@@ -426,7 +651,7 @@ public double getDistance() {
         }
 
         @Override
-        public long getFlags() {
+        public IntsRef getFlags() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
@@ -451,32 +676,97 @@ public EdgeIteratorState setName(String name) {
         }
 
         @Override
-        public boolean getBool(int key, boolean _default) {
+        public int getAdditionalField() {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public EdgeIteratorState setAdditionalField(int value) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean isBackward(FlagEncoder encoder) {
+        public boolean get(BooleanEncodedValue property) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public boolean isForward(FlagEncoder encoder) {
+        public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public int getAdditionalField() {
+        public boolean getReverse(BooleanEncodedValue property) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState setAdditionalField(int value) {
+        public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public int get(IntEncodedValue property) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public EdgeIteratorState set(IntEncodedValue property, int value) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public int getReverse(IntEncodedValue property) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public double get(DecimalEncodedValue property) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public double getReverse(DecimalEncodedValue property) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
         @Override
-        public EdgeIteratorState copyPropertiesTo(EdgeIteratorState edge) {
+        public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public <T extends Enum> T get(EnumEncodedValue<T> property) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState edge) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
@@ -496,7 +786,22 @@ public int getSkippedEdge2() {
         }
 
         @Override
-        public void setSkippedEdges(int edge1, int edge2) {
+        public CHEdgeIteratorState setSkippedEdges(int edge1, int edge2) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public CHEdgeIteratorState setFirstAndLastOrigEdges(int firstOrigEdge, int lastOrigEdge) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public int getOrigEdgeFirst() {
+            throw new UnsupportedOperationException("Not supported. Edge is empty.");
+        }
+
+        @Override
+        public int getOrigEdgeLast() {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
 
@@ -511,7 +816,12 @@ public CHEdgeIteratorState setWeight(double weight) {
         }
 
         @Override
-        public int getMergeStatus(long flags) {
+        public void setFlagsAndWeight(int flags, double weight) {
+            throw new UnsupportedOperationException("Not supported. Edge is empty");
+        }
+
+        @Override
+        public int getMergeStatus(int flags) {
             throw new UnsupportedOperationException("Not supported. Edge is empty.");
         }
     }
diff --git a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
index 4659ab2545..ffe3dcfc4b 100644
--- a/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
+++ b/core/src/main/java/com/graphhopper/util/MiniPerfTest.java
@@ -93,6 +93,10 @@ public String getReport() {
         return "sum:" + nf(getSum() / 1000f) + "s, time/call:" + nf(getMean() / 1000f) + "s";
     }
 
+    public int getDummySum() {
+        return dummySum;
+    }
+
     public String nf(Number num) {
         return new DecimalFormat("#.###", DecimalFormatSymbols.getInstance(Locale.ROOT)).format(num);
     }
diff --git a/core/src/main/java/com/graphhopper/util/PathMerger.java b/core/src/main/java/com/graphhopper/util/PathMerger.java
index 6cc31fb525..44aa69e670 100644
--- a/core/src/main/java/com/graphhopper/util/PathMerger.java
+++ b/core/src/main/java/com/graphhopper/util/PathMerger.java
@@ -19,7 +19,9 @@
 
 import com.graphhopper.PathWrapper;
 import com.graphhopper.routing.Path;
-import com.graphhopper.util.details.PathDetail;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.Roundabout;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.details.PathDetailsBuilderFactory;
 import com.graphhopper.util.exceptions.ConnectionNotFoundException;
 
@@ -28,12 +30,12 @@
 import java.util.List;
 
 /**
- * This class merges multiple {@link Path} objects into one continues object that
+ * This class merges multiple {@link Path} objects into one continuous object that
  * can be used in the {@link PathWrapper}. There will be a Path between every waypoint.
  * So for two waypoints there will be only one Path object. For three waypoints there will be
  * two Path objects.
  * <p>
- * The instructions are generated per Path object and are merged into one continues InstructionList.
+ * The instructions are generated per Path object and are merged into one continuous InstructionList.
  * The PointList per Path object are merged and optionally simplified.
  *
  * @author Peter Karich
@@ -76,7 +78,7 @@ public PathMerger setEnableInstructions(boolean enableInstructions) {
         return this;
     }
 
-    public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
+    public void doWork(PathWrapper altRsp, List<Path> paths, EncodingManager encodingManager, Translation tr) {
         int origPoints = 0;
         long fullTimeInMillis = 0;
         double fullWeight = 0;
@@ -86,6 +88,7 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
         InstructionList fullInstructions = new InstructionList(tr);
         PointList fullPoints = PointList.EMPTY;
         List<String> description = new ArrayList<>();
+        BooleanEncodedValue roundaboutEnc = encodingManager.getBooleanEncodedValue(Roundabout.KEY);
         for (int pathIndex = 0; pathIndex < paths.size(); pathIndex++) {
             Path path = paths.get(pathIndex);
             if (!path.isFound()) {
@@ -97,7 +100,7 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
             fullDistance += path.getDistance();
             fullWeight += path.getWeight();
             if (enableInstructions) {
-                InstructionList il = path.calcInstructions(tr);
+                InstructionList il = path.calcInstructions(roundaboutEnc, tr);
 
                 if (!il.isEmpty()) {
                     fullInstructions.addAll(il);
@@ -106,7 +109,7 @@ public void doWork(PathWrapper altRsp, List<Path> paths, Translation tr) {
                     if (pathIndex + 1 < paths.size()) {
                         ViaInstruction newInstr = new ViaInstruction(fullInstructions.get(fullInstructions.size() - 1));
                         newInstr.setViaCount(pathIndex + 1);
-                        fullInstructions.replaceLast(newInstr);
+                        fullInstructions.set(fullInstructions.size() - 1, newInstr);
                     }
                 }
 
diff --git a/core/src/main/java/com/graphhopper/util/TranslationMap.java b/core/src/main/java/com/graphhopper/util/TranslationMap.java
index 39e822d9a2..bdf4856ca0 100644
--- a/core/src/main/java/com/graphhopper/util/TranslationMap.java
+++ b/core/src/main/java/com/graphhopper/util/TranslationMap.java
@@ -34,9 +34,9 @@
     // ISO codes (639-1), use 'en_US' as reference
     private static final List<String> LOCALES = Arrays.asList("ar", "ast", "bg", "ca",
             "cs_CZ", "da_DK", "de_DE", "el", "eo", "es", "en_US", "fa", "fil", "fi",
-            "fr_FR", "fr_CH", "gl", "he", "hr_HR", "hsb", "hu_HU", "it", "ja", "ko", "lt_LT", "ne",
+            "fr_FR", "fr_CH", "gl", "he", "hr_HR", "hsb", "hu_HU", "in_ID", "it", "ja", "ko", "lt_LT", "ne",
             "nl", "pl_PL", "pt_BR", "pt_PT", "ro", "ru", "sk", "sl_SI", "sr_RS", "sv_SE", "tr", "uk",
-            "vi_VI", "zh_CN", "zh_HK");
+            "vi_VN", "zh_CN", "zh_HK", "zh_TW");
     private final Map<String, Translation> translations = new HashMap<>();
 
     public static int countOccurence(String phrase, String splitter) {
diff --git a/core/src/main/java/com/graphhopper/util/Unzipper.java b/core/src/main/java/com/graphhopper/util/Unzipper.java
index 9537c2d6db..a8a0976ea5 100644
--- a/core/src/main/java/com/graphhopper/util/Unzipper.java
+++ b/core/src/main/java/com/graphhopper/util/Unzipper.java
@@ -56,13 +56,13 @@ public void unzip(InputStream fromIs, File toFolder, ProgressListener progressLi
             byte[] buffer = new byte[8 * 1024];
             while (ze != null) {
                 if (ze.isDirectory()) {
-                    new File(toFolder, ze.getName()).mkdir();
+                    getVerifiedFile(toFolder, ze).mkdir();
                 } else {
                     double factor = 1;
                     if (ze.getCompressedSize() > 0 && ze.getSize() > 0)
                         factor = (double) ze.getCompressedSize() / ze.getSize();
 
-                    File newFile = new File(toFolder, ze.getName());
+                    File newFile = getVerifiedFile(toFolder, ze);
                     FileOutputStream fos = new FileOutputStream(newFile);
                     try {
                         int len;
@@ -84,4 +84,12 @@ public void unzip(InputStream fromIs, File toFolder, ProgressListener progressLi
             zis.close();
         }
     }
+
+    // see #1628
+    File getVerifiedFile(File destinationDir, ZipEntry ze) throws IOException {
+        File destinationFile = new File(destinationDir, ze.getName());
+        if (!destinationFile.getCanonicalPath().startsWith(destinationDir.getCanonicalPath() + File.separator))
+            throw new SecurityException("Zip Entry is outside of the target dir: " + ze.getName());
+        return destinationFile;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/util/XFirstSearch.java b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
index 50581b74a7..13073c2f8c 100644
--- a/core/src/main/java/com/graphhopper/util/XFirstSearch.java
+++ b/core/src/main/java/com/graphhopper/util/XFirstSearch.java
@@ -18,18 +18,18 @@
 package com.graphhopper.util;
 
 import com.graphhopper.coll.GHBitSet;
-import com.graphhopper.coll.GHBitSetImpl;
 
 /**
  * This abstract class defines commonalities for BFS and DFS
- * <p>
  *
  * @author Jan Sölter
  */
 public abstract class XFirstSearch {
-    protected GHBitSet createBitSet() {
-        return new GHBitSetImpl();
-    }
+    /**
+     * Pick the BitSet implementation wisely. Use {@link com.graphhopper.coll.GHBitSetImpl} only if we are sure you visit a large portion of the graph.
+     * And if you choose {@link com.graphhopper.coll.GHTBitSet} the initial capacity can be also important for performance.
+     */
+    protected abstract GHBitSet createBitSet();
 
     public abstract void start(EdgeExplorer explorer, int startNode);
 
diff --git a/core/src/main/java/com/graphhopper/util/details/DecimalDetails.java b/core/src/main/java/com/graphhopper/util/details/DecimalDetails.java
new file mode 100644
index 0000000000..be43f9e048
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/details/DecimalDetails.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.details;
+
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.util.EdgeIteratorState;
+
+public class DecimalDetails extends AbstractPathDetailsBuilder {
+
+    private final DecimalEncodedValue ev;
+    private double decimalValue = -1;
+    private final String infinityJsonValue;
+
+    public DecimalDetails(String name, DecimalEncodedValue ev) {
+        this(name, ev, null);
+    }
+
+    /**
+     * DecimalEncodedValue can return infinity as default value, but JSON cannot include this
+     * https://stackoverflow.com/a/9218955/194609
+     */
+    public DecimalDetails(String name, DecimalEncodedValue ev, String infinityJsonValue) {
+        super(name);
+        this.ev = ev;
+        this.infinityJsonValue = infinityJsonValue;
+    }
+
+    @Override
+    protected Object getCurrentValue() {
+        if (Double.isInfinite(decimalValue))
+            return infinityJsonValue;
+
+        return decimalValue;
+    }
+
+    @Override
+    public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
+        double tmpVal = edge.get(ev);
+        if (Math.abs(tmpVal - decimalValue) > 0.0001) {
+            this.decimalValue = tmpVal;
+            return true;
+        }
+        return false;
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/util/details/DistanceDetails.java b/core/src/main/java/com/graphhopper/util/details/DistanceDetails.java
index 177b6e4153..c36e1cf458 100644
--- a/core/src/main/java/com/graphhopper/util/details/DistanceDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/DistanceDetails.java
@@ -1,30 +1,47 @@
-package com.graphhopper.util.details;
-
-import com.graphhopper.util.EdgeIteratorState;
-
-import static com.graphhopper.util.Parameters.DETAILS.DISTANCE;
-
-public class DistanceDetails extends AbstractPathDetailsBuilder {
-
-    private int edgeId = -1;
-    private double distance = 0;
-
-    public DistanceDetails() {
-        super(DISTANCE);
-    }
-
-    @Override
-    public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
-        if (edge.getEdge() != edgeId) {
-            edgeId = edge.getEdge();
-            distance = edge.getDistance();
-            return true;
-        }
-        return false;
-    }
-
-    @Override
-    public Object getCurrentValue() {
-        return this.distance;
-    }
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.util.details;
+
+import com.graphhopper.util.EdgeIteratorState;
+
+import static com.graphhopper.util.Parameters.Details.DISTANCE;
+
+public class DistanceDetails extends AbstractPathDetailsBuilder {
+
+    private int edgeId = -1;
+    private double distance = 0;
+
+    public DistanceDetails() {
+        super(DISTANCE);
+    }
+
+    @Override
+    public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
+        if (edge.getEdge() != edgeId) {
+            edgeId = edge.getEdge();
+            distance = edge.getDistance();
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public Object getCurrentValue() {
+        return this.distance;
+    }
 }
\ No newline at end of file
diff --git a/core/src/main/java/com/graphhopper/util/details/EdgeIdDetails.java b/core/src/main/java/com/graphhopper/util/details/EdgeIdDetails.java
index eeee952086..3ee89686a7 100644
--- a/core/src/main/java/com/graphhopper/util/details/EdgeIdDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/EdgeIdDetails.java
@@ -21,7 +21,7 @@
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 
-import static com.graphhopper.util.Parameters.DETAILS.EDGE_ID;
+import static com.graphhopper.util.Parameters.Details.EDGE_ID;
 
 /**
  * Calculate the Edge Id segments of a Path
@@ -48,7 +48,7 @@ public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
 
     private int edgeId(EdgeIteratorState edge) {
         if (edge instanceof VirtualEdgeIteratorState) {
-            return GHUtility.getEdgeFromEdgeKey(((VirtualEdgeIteratorState) edge).getOriginalTraversalKey());
+            return GHUtility.getEdgeFromEdgeKey(((VirtualEdgeIteratorState) edge).getOriginalEdgeKey());
         } else {
             return edge.getEdge();
         }
diff --git a/core/src/main/java/com/graphhopper/util/details/AverageSpeedDetails.java b/core/src/main/java/com/graphhopper/util/details/EnumDetails.java
similarity index 60%
rename from core/src/main/java/com/graphhopper/util/details/AverageSpeedDetails.java
rename to core/src/main/java/com/graphhopper/util/details/EnumDetails.java
index d0d4257d1f..1b8ab6e250 100644
--- a/core/src/main/java/com/graphhopper/util/details/AverageSpeedDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/EnumDetails.java
@@ -17,37 +17,32 @@
  */
 package com.graphhopper.util.details;
 
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
 import com.graphhopper.util.EdgeIteratorState;
 
-import static com.graphhopper.util.Parameters.DETAILS.AVERAGE_SPEED;
+public class EnumDetails<E extends Enum> extends AbstractPathDetailsBuilder {
 
-/**
- * Calculate the average speed segments for a Path
- *
- * @author Robin Boldt
- */
-public class AverageSpeedDetails extends AbstractPathDetailsBuilder {
+    private final EnumEncodedValue<E> ev;
+    private Enum objVal = null;
 
-    private final FlagEncoder encoder;
-    private double curAvgSpeed = -1;
+    public EnumDetails(String name, EnumEncodedValue<E> ev) {
+        super(name);
+        this.ev = ev;
+    }
 
-    public AverageSpeedDetails(FlagEncoder encoder) {
-        super(AVERAGE_SPEED);
-        this.encoder = encoder;
+    @Override
+    protected Object getCurrentValue() {
+        return objVal.toString();
     }
 
     @Override
     public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
-        if (Math.abs(encoder.getSpeed(edge.getFlags()) - curAvgSpeed) > 0.0001) {
-            this.curAvgSpeed = this.encoder.getSpeed(edge.getFlags());
+        E val = edge.get(ev);
+        // we can use the reference equality here
+        if (val != objVal) {
+            this.objVal = val;
             return true;
         }
         return false;
     }
-
-    @Override
-    public Object getCurrentValue() {
-        return this.curAvgSpeed;
-    }
 }
diff --git a/core/src/main/java/com/graphhopper/reader/dem/BridgeElevationInterpolator.java b/core/src/main/java/com/graphhopper/util/details/IntDetails.java
similarity index 55%
rename from core/src/main/java/com/graphhopper/reader/dem/BridgeElevationInterpolator.java
rename to core/src/main/java/com/graphhopper/util/details/IntDetails.java
index 9924a1a1cb..7b72c1f62c 100644
--- a/core/src/main/java/com/graphhopper/reader/dem/BridgeElevationInterpolator.java
+++ b/core/src/main/java/com/graphhopper/util/details/IntDetails.java
@@ -15,27 +15,33 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.reader.dem;
+package com.graphhopper.util.details;
 
-import com.graphhopper.routing.util.DataFlagEncoder;
-import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.routing.profiles.IntEncodedValue;
 import com.graphhopper.util.EdgeIteratorState;
 
-/**
- * Elevation interpolator for bridges. Estimates elevations of inner nodes of
- * the bridge based on elevations of entry/exit nodes of the bridge.
- *
- * @author Alexey Valikov
- */
-public class BridgeElevationInterpolator extends AbstractEdgeElevationInterpolator {
+public class IntDetails extends AbstractPathDetailsBuilder {
+
+    private final IntEncodedValue ev;
+    private int intVal = -1;
 
-    public BridgeElevationInterpolator(GraphHopperStorage storage,
-                                       DataFlagEncoder dataFlagEncoder) {
-        super(storage, dataFlagEncoder);
+    public IntDetails(String name, IntEncodedValue ev) {
+        super(name);
+        this.ev = ev;
+    }
+
+    @Override
+    protected Object getCurrentValue() {
+        return intVal;
     }
 
     @Override
-    protected boolean isInterpolatableEdge(EdgeIteratorState edge) {
-        return dataFlagEncoder.isTransportModeBridge(edge);
+    public boolean isEdgeDifferentToLastEdge(EdgeIteratorState edge) {
+        int val = edge.get(ev);
+        if (val != intVal) {
+            this.intVal = val;
+            return true;
+        }
+        return false;
     }
 }
diff --git a/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java b/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
index 290323e199..62e373256c 100644
--- a/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
+++ b/core/src/main/java/com/graphhopper/util/details/PathDetailsBuilderFactory.java
@@ -17,13 +17,17 @@
  */
 package com.graphhopper.util.details;
 
+import com.graphhopper.coll.MapEntry;
+import com.graphhopper.routing.profiles.*;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.Weighting;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
+import java.util.Map;
 
-import static com.graphhopper.util.Parameters.DETAILS.*;
+import static com.graphhopper.util.Parameters.Details.*;
 
 /**
  * Generates a list of PathDetailsBuilder from a List of PathDetail names
@@ -36,7 +40,7 @@
         List<PathDetailsBuilder> builders = new ArrayList<>();
 
         if (requestedPathDetails.contains(AVERAGE_SPEED))
-            builders.add(new AverageSpeedDetails(encoder));
+            builders.add(new DecimalDetails(AVERAGE_SPEED, encoder.getAverageSpeedEnc()));
 
         if (requestedPathDetails.contains(STREET_NAME))
             builders.add(new StreetNameDetails());
@@ -50,6 +54,20 @@
         if (requestedPathDetails.contains(DISTANCE))
             builders.add(new DistanceDetails());
 
+        for (String key : Arrays.asList(MaxSpeed.KEY, MaxWidth.KEY, MaxHeight.KEY, MaxWeight.KEY)) {
+            if (requestedPathDetails.contains(key) && encoder.hasEncodedValue(key))
+                builders.add(new DecimalDetails(key, encoder.getDecimalEncodedValue(key)));
+        }
+
+        for (Map.Entry entry : Arrays.asList(new MapEntry<>(RoadClass.KEY, RoadClass.class),
+                new MapEntry<>(RoadEnvironment.KEY, RoadEnvironment.class), new MapEntry<>(Surface.KEY, Surface.class),
+                new MapEntry<>(RoadAccess.KEY, RoadAccess.class), new MapEntry<>(Toll.KEY, Toll.class),
+                new MapEntry<>(Country.KEY, Country.class))) {
+            String key = (String) entry.getKey();
+            if (requestedPathDetails.contains(key) && encoder.hasEncodedValue(key))
+                builders.add(new EnumDetails(key, encoder.getEnumEncodedValue(key, (Class<Enum>) entry.getValue())));
+        }
+
         if (requestedPathDetails.size() != builders.size()) {
             throw new IllegalArgumentException("You requested the details " + requestedPathDetails + " but we could only find " + builders);
         }
diff --git a/core/src/main/java/com/graphhopper/util/details/StreetNameDetails.java b/core/src/main/java/com/graphhopper/util/details/StreetNameDetails.java
index 8ae0a05e40..ca80323f1a 100644
--- a/core/src/main/java/com/graphhopper/util/details/StreetNameDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/StreetNameDetails.java
@@ -19,7 +19,7 @@
 
 import com.graphhopper.util.EdgeIteratorState;
 
-import static com.graphhopper.util.Parameters.DETAILS.STREET_NAME;
+import static com.graphhopper.util.Parameters.Details.STREET_NAME;
 
 /**
  * Calculate the speed name segments of a Path
diff --git a/core/src/main/java/com/graphhopper/util/details/TimeDetails.java b/core/src/main/java/com/graphhopper/util/details/TimeDetails.java
index d65d314d39..cb89cd0829 100644
--- a/core/src/main/java/com/graphhopper/util/details/TimeDetails.java
+++ b/core/src/main/java/com/graphhopper/util/details/TimeDetails.java
@@ -20,7 +20,7 @@
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.util.EdgeIteratorState;
 
-import static com.graphhopper.util.Parameters.DETAILS.TIME;
+import static com.graphhopper.util.Parameters.Details.TIME;
 
 /**
  * Calculate the time segments for a Path
diff --git a/core/src/main/resources/com/graphhopper/gitinfo b/core/src/main/resources/com/graphhopper/gitinfo
new file mode 100644
index 0000000000..50d85b5868
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/gitinfo
@@ -0,0 +1,5 @@
+# properties will be filled by git-commit-id-plugin during maven build
+${git.commit.id}
+${git.branch}
+${git.dirty}
+${git.commit.time}
\ No newline at end of file
diff --git a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
index d8bc4e4756..315d712d53 100644
--- a/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
+++ b/core/src/main/resources/com/graphhopper/util/cs_CZ.txt
@@ -4,15 +4,15 @@ continue=pokračujte
 continue_onto=pokračujte na %1$s
 turn_left=odbočte vlevo
 turn_right=odbočte vpravo
-turn_slight_left=odbočte mírně vpravo
+turn_slight_left=odbočte mírně vlevo
 turn_slight_right=odbočte mírně vpravo
-turn_sharp_left=odbočte ostře doleva
-turn_sharp_right=odbočte ostře doprava
-keep_left=
-keep_right=
+turn_sharp_left=odbočte ostře vlevo
+turn_sharp_right=odbočte ostře vpravo
+keep_left=držte se vlevo
+keep_right=držte se vpravo
 turn_onto=%1$s na %2$s
-u_turn=
-unknown=
+u_turn=otočte se
+unknown=neznámý pokyn „%1$s“
 web.search_button=Vyhledat
 web.from_hint=Z
 web.via_hint=Přes 
@@ -20,15 +20,15 @@ web.to_hint=Do
 web.more_button=více
 web.gpx_export_button=Export do GPX
 web.route_info=%1$s bude trvat %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=dorazí v %1$s, %2$s přestup(y) (%3$s) 
+web.pt_route_info_walking=dorazí v %1$s (%2$s)
 web.locations_not_found=Navigování není dostupné. Pozice nenalezena v této oblasti.
 web.bike=Kolo
 web.racingbike=Závodní kolo
 web.mtb=Horské kolo
 web.car=Automobil
 web.foot=Pěšky
-web.hike=
+web.hike=Turistika
 web.small_truck=Dodávka
 web.bus=Autobus
 web.truck=Nákladní automobil
@@ -47,7 +47,7 @@ road=silnice
 off_bike=sesedněte z kola
 cycleway=cyklotrasa
 way=cesta
-small_way=
+small_way=pešina
 paved=zpevněná
 unpaved=nezpevněná
 stopover=zastávka %1$s
@@ -56,10 +56,10 @@ roundabout_exit=Na kruhovém objezdu použijte %1$s. výjezd
 roundabout_exit_onto=Na kruhovém objezdu použijte %1$s. výjezd, směrem na %2$s
 total_ascend=Celkové stoupání %1$s
 total_descend=Celkové klesání %1$s
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=na cestě je brod
+pt_start_trip=nastupte do %1$s
+pt_end_trip=vystupte z %1$s
+pt_transfer_to=přestupte na %1$s
 web.start_label=Start
 web.intermediate_label=Zastávka
 web.end_label=Cíl
@@ -76,4 +76,4 @@ web.refresh_button=Obnovit stránku
 web.server_status=Stav
 web.zoom_in=Přiblížit
 web.zoom_out=Oddálit
-web.drag_to_reorder=
+web.drag_to_reorder=Přetažením změníte pořadí
diff --git a/core/src/main/resources/com/graphhopper/util/da_DK.txt b/core/src/main/resources/com/graphhopper/util/da_DK.txt
index 925a4c9aa0..1368e20d59 100644
--- a/core/src/main/resources/com/graphhopper/util/da_DK.txt
+++ b/core/src/main/resources/com/graphhopper/util/da_DK.txt
@@ -8,72 +8,72 @@ turn_slight_left=drej lidt til venstre
 turn_slight_right=drej lidt til højre
 turn_sharp_left=drej skarpt til venstre
 turn_sharp_right=drej skarpt til højre
-keep_left=Hold til venstre
-keep_right=Hold til højre
+keep_left=hold til venstre
+keep_right=hold til højre
 turn_onto=%1$s ind på %2$s
-u_turn=Lav en U-vending
-unknown=
+u_turn=foretag en U-vending
+unknown=ukendt instruktionsskilt '%1$s'
 web.search_button=Søg
 web.from_hint=Fra 
 web.via_hint=Via
 web.to_hint=Til
-web.more_button=Mere
+web.more_button=mere
 web.gpx_export_button=Eksportér GPX-fil
 web.route_info=%1$s med køretid %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=ankommer %1$s med %2$s omstigninger (%3$s)
+web.pt_route_info_walking=ankommer til fods %1$s (%2$s)
 web.locations_not_found=Kan ikke beregne ruten. Lokation(erne) kan ikke findes i området.
 web.bike=Cykel
 web.racingbike=Racercykel
 web.mtb=Mountain bike
 web.car=Bil
 web.foot=Gang
-web.hike=
-web.small_truck=
-web.bus=
-web.truck=
-web.staticlink=Direkte link
+web.hike=Vandre
+web.small_truck=Varevogn
+web.bus=Bus
+web.truck=Lastbil
+web.staticlink=statisk link
 web.motorcycle=Motorcykel
 via=via
 finish=Fremme!
-hour_abbr=tim
-day_abbr= d
-min_abbr= min
-km_abbr= km
-m_abbr= m
-mi_abbr= mi
+hour_abbr=t
+day_abbr=d
+min_abbr=min
+km_abbr=km
+m_abbr=m
+mi_abbr=mi
 ft_abbr=fod
 road=gade
-off_bike=hop af cyklen
-cycleway=cykelvej
+off_bike=stig af cyklen
+cycleway=cykelsti
 way=vej
-small_way=
-paved=brolagt
-unpaved=grusvej
+small_way=sti
+paved=belagt
+unpaved=ubelagt
 stopover=delmål %1$s
 roundabout_enter=Kør ind i rundskørslen
 roundabout_exit=I rundkørslen, tag udkørsel %1$s
-roundabout_exit_onto=I rundskørslen, ta udkørsel %1$s ind på %2$s
-total_ascend=
-total_descend=
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
-web.start_label=
-web.intermediate_label=
-web.end_label=
-web.set_start=
-web.set_intermediate=
-web.set_end=
-web.center_map=
-web.show_coords=
-web.route=
-web.delete_from_route=
-web.marker=
-web.gh_offline_info=
-web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
-web.drag_to_reorder=
+roundabout_exit_onto=I rundskørslen, tag udkørsel %1$s ind på %2$s
+total_ascend=%1$s samlet stigning
+total_descend=%1$s samlet fald
+way_contains_ford=der er et vadested undervejs
+pt_start_trip=stig på %1$s
+pt_end_trip=stig af %1$s
+pt_transfer_to=omstigning til %1$s
+web.start_label=Start
+web.intermediate_label=Via
+web.end_label=Mål
+web.set_start=Sæt som start
+web.set_intermediate=Sæt via
+web.set_end=Sæt som mål
+web.center_map=Centrer kort her
+web.show_coords=Vis koordinater
+web.route=Rute
+web.delete_from_route=Fjern fra rute
+web.marker=Markør
+web.gh_offline_info=Er GraphHopper API offline?
+web.refresh_button=Genindlæs siden
+web.server_status=Status
+web.zoom_in=Zoom ind
+web.zoom_out=Zoom ud
+web.drag_to_reorder=Træk for at ændre rækkefølgen
diff --git a/core/src/main/resources/com/graphhopper/util/fa.txt b/core/src/main/resources/com/graphhopper/util/fa.txt
index 059df616f9..0dcbb3fb64 100644
--- a/core/src/main/resources/com/graphhopper/util/fa.txt
+++ b/core/src/main/resources/com/graphhopper/util/fa.txt
@@ -1,41 +1,41 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-continue= ادامه دهید
-continue_onto=تا %1$s ادامه دهید
+continue=ادامه دهید
+continue_onto=در %1$s ادامه دهید
 turn_left=به چپ بپیچید
 turn_right=به راست بپیچید
 turn_slight_left=کمی به چپ بپیچید
 turn_slight_right=کمی به راست بپیچید
-turn_sharp_left=کاملا به چپ بپیچید
-turn_sharp_right=کاملا به راست بپیچید
-keep_left=از سمت چپ حرکت کنید
-keep_right=از سمت راست حرکت کنید
-turn_onto= از %1$s به %2$s وارد شوید
-u_turn=وارد دور بردگردان شوید
-unknown=علامت راهنمایی ناشناخته '%1$s'
-web.search_button=جستجو
+turn_sharp_left=در پیچ تند به چپ بپیچید
+turn_sharp_right=در پیچ تند به راست بپیچید
+keep_left=به چپ برانید
+keep_right=به راست برانید
+turn_onto=%1$s و به %2$s وارد شوید
+u_turn=دور بزنید
+unknown=علامت راهنمایی ناشناخته: '%1$s'
+web.search_button=جست‌وجو
 web.from_hint=از
-web.via_hint=از طریق
+web.via_hint=با گذر از
 web.to_hint=به
 web.more_button=بیشتر
-web.gpx_export_button=دریافت به صورت GPX
-web.route_info=مسافت %1$s به مدت %2$s طول خواهد کشید
-web.pt_route_info=%2$s سفر در زمان %1$s پایان می‌پذیرد (%3$s)
-web.pt_route_info_walking=سفر به صورت پیاده روی در زمان %1$s پایان می‌پذیرد (%3$s)
-web.locations_not_found=مسیریابی ممکن نیست. محل مورد نظردرناحیه پیدا نشد.
+web.gpx_export_button=دریافت در قالب GPX
+web.route_info=%1$s %2$s طول می‌کشد
+web.pt_route_info=با %2$s جابه‌جایی در ساعت %1$s می‌رسید (%3$s)
+web.pt_route_info_walking=ساعت %1$s می‌رسید، فقط پیاده (%2$s)
+web.locations_not_found=مسیریابی ممکن نیست. مکان(ها) در ناحیهٔ موردنظر پیدا نشد.
 web.bike=دوچرخه
 web.racingbike=دوچرخه کورسی
 web.mtb=دوچرخه کوهستان
 web.car=ماشین
-web.foot=پیاده
-web.hike=پیاده‌روی
+web.foot=پیاده‌روی
+web.hike=پیاده‌گردی
 web.small_truck=وانت
 web.bus=اتوبوس
 web.truck=کامیون
-web.staticlink=مسیر ثابت
+web.staticlink=پیوند ثابت
 web.motorcycle=موتورسیکلت
-via=از طریق
-finish=پایان!
+via=با گذر از
+finish=به مقصد رسیدید
 hour_abbr=ساعت
 day_abbr=روز
 min_abbr=دقیقه
@@ -48,32 +48,32 @@ off_bike=از دوچرخه پیاده شوید
 cycleway=مسیر دوچرخه
 way=مسیر
 small_way=مسیر باریک
-paved=خط کشی شده
-unpaved=خط کشی نشده
-stopover=توقفگاه  %1$s
-roundabout_enter=وارد میدان شوید
-roundabout_exit=در میدان خروجی %1$s را انتخاب کنید
-roundabout_exit_onto=در میدان از خروجی %1$s به "%2$s" وارد شوید
+paved=روسازی‌شده
+unpaved=روسازی‌نشده
+stopover=نقطهٔ بین‌راهی %1$s
+roundabout_enter=وارد فلکه شوید
+roundabout_exit=در فلکه، به خروجی %1$s بروید
+roundabout_exit_onto=در فلکه، از خروجی %1$s به %2$s بروید
 total_ascend=مجموع صعود %1$s
 total_descend=مجموع نزول %1$s
-way_contains_ford=مسیر از رودخانه می‌گذرد
+way_contains_ford=در طول مسیر گُدار وجود دارد
 pt_start_trip=وارد %1$s شوید
 pt_end_trip=از %1$s خارج شوید
 pt_transfer_to=مسیر را به %1$s تغییر دهید
-web.start_label=شروع
-web.intermediate_label=نقطه‌ی میانی
+web.start_label=آغاز
+web.intermediate_label=نقطهٔ میانی
 web.end_label=پایان
-web.set_start=انتخاب به عنوان شروع
-web.set_intermediate=انتخاب به عنوان نقطه‌ی میانی
-web.set_end=انتخاب به عنوان پایان
-web.center_map=تنظیم مرکز صفحه به این نقطه
-web.show_coords=نمایش مختصات
+web.set_start=انتخاب نقطهٔ آغاز
+web.set_intermediate=انتخاب نقطهٔ میانی
+web.set_end=انتخاب نقطهٔ پایان
+web.center_map=اینجا مرکز نقشه شود
+web.show_coords=مختصات اینجا
 web.route=مسیر
-web.delete_from_route=حذف از مسیر
-web.marker=مارکر
+web.delete_from_route=از مسیر حذف شود
+web.marker=نشانه
 web.gh_offline_info=گراف‌هاپر در دسترس نیست؟
-web.refresh_button=بارگذاری مجدد
+web.refresh_button=تازه‌سازی صفحه
 web.server_status=وضعیت
-web.zoom_in=بزرگنمایی
+web.zoom_in=بزرگ‌نمایی
 web.zoom_out=کوچک‌نمایی
-web.drag_to_reorder=برای جابجایی نگه‌دارید
+web.drag_to_reorder=برای مرتب‌سازی جابه‌جا کنید
diff --git a/core/src/main/resources/com/graphhopper/util/hu_HU.txt b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
index 814346872c..3dbd457649 100644
--- a/core/src/main/resources/com/graphhopper/util/hu_HU.txt
+++ b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
@@ -1,17 +1,17 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-continue=Haladjon tovább
-continue_onto=Haladjon tovább erre %1$s
-turn_left=Forduljon balra
-turn_right=Forduljon jobbra
-turn_slight_left=Forduljon enyhén balra
-turn_slight_right=Forduljon enyhén jobbra
-turn_sharp_left=Forduljon élesen balra
-turn_sharp_right=Forduljon élesen jobbra
-keep_left=Tartson balra
-keep_right=Tartson jobbra
+continue=haladjon tovább
+continue_onto=haladjon tovább erre: %1$s
+turn_left=forduljon balra
+turn_right=forduljon jobbra
+turn_slight_left=forduljon enyhén balra
+turn_slight_right=forduljon enyhén jobbra
+turn_sharp_left=forduljon élesen balra
+turn_sharp_right=forduljon élesen jobbra
+keep_left=tartson balra
+keep_right=tartson jobbra
 turn_onto=%1$s erre: %2$s
-u_turn=Forduljon meg
+u_turn=forduljon meg
 unknown=ismeretlen jelzőtábla: %1$s
 web.search_button=Keresés
 web.from_hint=Innen
@@ -35,7 +35,7 @@ web.truck=Teherautó
 web.staticlink=Statikus hivatkozás
 web.motorcycle=Motorkerékpár
 via=ezen át:
-finish=Megérekezett a célponthoz
+finish=érkezés a célponthoz
 hour_abbr=óra
 day_abbr=nap
 min_abbr=perc
@@ -54,8 +54,8 @@ stopover=%1$s. útpont
 roundabout_enter=Hajtson be a körforgalomba
 roundabout_exit=Hajtson ki a körforgalomból itt: %1$s. kijárat
 roundabout_exit_onto=Hajtson ki a körforgalomból itt: %1$s. kijárat, majd hajtson rá erre: %2$s
-total_ascend=összes szintemelkedés: %1$s
-total_descend=összes szintcsökkenés: %1$s
+total_ascend=Összes szintemelkedés: %1$s
+total_descend=Összes szintcsökkenés: %1$s
 way_contains_ford=gázló van az útvonalon
 pt_start_trip=szálljon fel erre: %1$s
 pt_end_trip=szálljon le erről: %1$s
@@ -63,8 +63,8 @@ pt_transfer_to=szálljon át erre: %1$s
 web.start_label=Indulás
 web.intermediate_label=Köztes célpont
 web.end_label=Célpont
-web.set_start=Beállítás köztes célpontnak
-web.set_intermediate=Beállítás kiindulási pontnak
+web.set_start=Beállítás kiindulási pontnak
+web.set_intermediate=Beállítás köztes célpontnak
 web.set_end=Beállítás célpontnak
 web.center_map=Beállítás a térkép középpontjának
 web.show_coords=Pozíció megjelenítése
diff --git a/core/src/main/resources/com/graphhopper/util/in_ID.txt b/core/src/main/resources/com/graphhopper/util/in_ID.txt
new file mode 100644
index 0000000000..fe7f6e5bb2
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/in_ID.txt
@@ -0,0 +1,79 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=lanjut
+continue_onto=menuju pada %1$s
+turn_left=belok kiri
+turn_right=belok kanan
+turn_slight_left=belok kiri sedikit
+turn_slight_right=belok kanan sedikit
+turn_sharp_left=belok kiri tajam
+turn_sharp_right=belok kanan tajam
+keep_left=tetap berada jalur kiri
+keep_right=tetap berada jalur kiri
+turn_onto=%1$s belok menuju %2$s
+u_turn=putar balik
+unknown=petunjuk baru %1$s
+web.search_button=pencarian
+web.from_hint=dari
+web.via_hint=melalui
+web.to_hint=ke
+web.more_button=lebih lanjut
+web.gpx_export_button=Ekspor GPX
+web.route_info=%1$s berada dalam waktu %2$s
+web.pt_route_info=sampai pada %1$s dengan %2$s jarak (%3$s)
+web.pt_route_info_walking=sampai pada %1$s dengan berjalan kaki (%2$s)
+web.locations_not_found=Penentuan rute tidak dapat dilakukan. Lokasi tidak ditemukan
+web.bike=Sepeda
+web.racingbike=Sepeda Balap
+web.mtb=Sepeda Gunung
+web.car=Mobil
+web.foot=Jalan Kaki
+web.hike=Mendaki
+web.small_truck=Truk Kecil
+web.bus=Bus
+web.truck=Truk
+web.staticlink=Jalur tetap
+web.motorcycle=Motor
+via=melalui
+finish=Sampai pada tujuan akhir
+hour_abbr=jam
+day_abbr=hari
+min_abbr=menit
+km_abbr=km
+m_abbr=m
+mi_abbr=mil
+ft_abbr=foot
+road=jalan
+off_bike=turun dari sepeda
+cycleway=jalur sepeda
+way=jalan
+small_way=jalan kecil
+paved=beraspal
+unpaved=non-aspal
+stopover=titik hubung %1$s
+roundabout_enter=Masuk bundaran
+roundabout_exit=Pada bundaran, keluar melalui %1$s
+roundabout_exit_onto=At roundabout, take exit %1$s onto %2$s
+total_ascend=naik dengan jarak %1$s
+total_descend=turun dengan jarak %1$s
+way_contains_ford=terdapat jalan untuk dilewati
+pt_start_trip=masuk dalam %1$s
+pt_end_trip=keluar dalam %1$s
+pt_transfer_to=berpindah ke jalur %1$s
+web.start_label=Mulai
+web.intermediate_label=Antara
+web.end_label=Akhir
+web.set_start=Atur sebagai titik mulai
+web.set_intermediate=Atur sebagai titik antara
+web.set_end=Atur sebagai titik akhir
+web.center_map=Tengahkan Peta
+web.show_coords=Tampilkan koordinat
+web.route=Rute
+web.delete_from_route=Hapus dari rute
+web.marker=Titik
+web.gh_offline_info=Pelayanan API Graphhopper dalam kondisi offline
+web.refresh_button=Perbarui Halaman
+web.server_status=Status
+web.zoom_in=Perbesaran
+web.zoom_out=Pengecilan
+web.drag_to_reorder=Drag untuk mengatur urutan
diff --git a/core/src/main/resources/com/graphhopper/util/it.txt b/core/src/main/resources/com/graphhopper/util/it.txt
index b298978fc9..2173685fe3 100644
--- a/core/src/main/resources/com/graphhopper/util/it.txt
+++ b/core/src/main/resources/com/graphhopper/util/it.txt
@@ -8,11 +8,11 @@ turn_slight_left=gira leggermente a sinistra
 turn_slight_right=gira leggermente a destra
 turn_sharp_left=gira nettamente a sinistra
 turn_sharp_right=gira nettamente a destra
-keep_left=
-keep_right=
+keep_left=tieni la sinistra
+keep_right=tieni la destra
 turn_onto=%1$s su %2$s
-u_turn=
-unknown=
+u_turn=fai una inversione a U
+unknown=sconosciuto %1$s
 web.search_button=Ricerca
 web.from_hint=Da
 web.via_hint=attraverso
@@ -20,8 +20,8 @@ web.to_hint=A
 web.more_button=altro
 web.gpx_export_button=Esporta GPX
 web.route_info=%1$s in %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info=arrivato alle %1$s con %2$s trasferimenti (%3$s)
+web.pt_route_info_walking=arrivato alle %1$s solocamminando (%2$s)
 web.locations_not_found=Percorso non calcolabile. Località non trovata(e) nell'area.
 web.bike=Bicicletta
 web.racingbike=Bici da corsa
@@ -34,8 +34,8 @@ web.bus=Tram
 web.truck=Camion
 web.staticlink=permalink
 web.motorcycle=Moto
-via=attraverso
-finish=Arrivo!
+via=via
+finish=Arrivato a destinazione
 hour_abbr=hh
 day_abbr=gg
 min_abbr=mm
@@ -56,10 +56,10 @@ roundabout_exit=Nella rotatoria, prendere l'uscita %1$s
 roundabout_exit_onto=Nella rotatoria, prendere l'uscita %1$s su %2$s
 total_ascend=%1$s di dislivello positivo
 total_descend=%1$s di dislivello negativo
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=c'é un guado sulla strada
+pt_start_trip=prendi %1$s
+pt_end_trip=lascia %1$s
+pt_transfer_to=cambia con %1$s
 web.start_label=Partenza
 web.intermediate_label=Punto intermedio
 web.end_label=Arrivo
diff --git a/core/src/main/resources/com/graphhopper/util/ru.txt b/core/src/main/resources/com/graphhopper/util/ru.txt
index f07afe968a..3a7cbe6891 100644
--- a/core/src/main/resources/com/graphhopper/util/ru.txt
+++ b/core/src/main/resources/com/graphhopper/util/ru.txt
@@ -1,7 +1,7 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
 continue=Продолжите движение
-continue_onto=Продолжайте движение по %1$s
+continue_onto=Продолжите движение по %1$s
 turn_left=Поверните налево
 turn_right=Поверните направо
 turn_slight_left=Плавно поверните налево
diff --git a/core/src/main/resources/com/graphhopper/util/sk.txt b/core/src/main/resources/com/graphhopper/util/sk.txt
index a263e96c82..c1450f93b1 100644
--- a/core/src/main/resources/com/graphhopper/util/sk.txt
+++ b/core/src/main/resources/com/graphhopper/util/sk.txt
@@ -21,7 +21,7 @@ web.more_button=viac
 web.gpx_export_button=Export do GPX
 web.route_info=%1$s zaberie %2$s
 web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info_walking=príchod o %1$s iba chôdzou (%2$s)
 web.locations_not_found=Navigovanie nie je možné. Umiestnenie nebolo nájdené v oblasti.
 web.bike=Bicykel
 web.racingbike=Cestný bicykel
@@ -56,10 +56,10 @@ roundabout_exit=Na kruhovom objazde, ho opustite cez %1$s. výjazd
 roundabout_exit_onto=Na kruhovom objazde, ho opustite cez %1$s. výjazd na %2$s
 total_ascend=%1$s celkové stúpanie
 total_descend=%1$s celkové klesanie
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
+way_contains_ford=popri ceste sa nachádza brod
+pt_start_trip=nastúpte na linku %1$s
+pt_end_trip=vystúpte z linky %1$s
+pt_transfer_to=prestúpte na linku %1$s
 web.start_label=Začiatok
 web.intermediate_label=Bod trasy
 web.end_label=Koniec
diff --git a/core/src/main/resources/com/graphhopper/util/uk.txt b/core/src/main/resources/com/graphhopper/util/uk.txt
index 48997d93e4..34e536fd72 100644
--- a/core/src/main/resources/com/graphhopper/util/uk.txt
+++ b/core/src/main/resources/com/graphhopper/util/uk.txt
@@ -1,7 +1,7 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
 continue=продовжуйте
-continue_onto=продовжуйте по „%1$s“
+continue_onto=продовжуйте по %1$s
 turn_left=Поверніть ліворуч
 turn_right=Поверніть праворуч
 turn_slight_left=Поверніть трохи лівіше
@@ -10,9 +10,9 @@ turn_sharp_left=Різко поверніть ліворуч
 turn_sharp_right=Різко поверніть праворуч
 keep_left=Тримайтеся ліворуч
 keep_right=Тримайтеся праворуч
-turn_onto=%1$s на „%2$s“
+turn_onto=%1$s на %2$s
 u_turn=Розверніться
-unknown=Невідома інструкція „%1$s“
+unknown=Невідома інструкція %1$s
 web.search_button=Пошук
 web.from_hint=Від
 web.via_hint=через
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VI.txt b/core/src/main/resources/com/graphhopper/util/vi_VI.txt
deleted file mode 100644
index 6296833aae..0000000000
--- a/core/src/main/resources/com/graphhopper/util/vi_VI.txt
+++ /dev/null
@@ -1,79 +0,0 @@
-# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
-
-continue=tiếp tục
-continue_onto=tiếp tục theo %1$s
-turn_left=rẽ trái
-turn_right=rẽ phải
-turn_slight_left=rẽ trái nhẹ
-turn_slight_right=rẽ phải nhẹ
-turn_sharp_left=rẽ trái ngay
-turn_sharp_right=rẽ phải ngay
-keep_left=
-keep_right=
-turn_onto=%1$s theo %1$s
-u_turn=
-unknown=
-web.search_button=Tìm
-web.from_hint=Từ
-web.via_hint=Qua
-web.to_hint=Đến
-web.more_button=thêm
-web.gpx_export_button=Xuất GPX
-web.route_info=%1$s mất %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
-web.locations_not_found=Không tìm thấy lộ trình! Các điểm đã chọn không tìm thấy trong vùng này.
-web.bike=Xe đạp
-web.racingbike=Xe đua
-web.mtb=Xe leo núi
-web.car=Ô tô
-web.foot=Đi bộ
-web.hike=
-web.small_truck=Xe tải nhỏ
-web.bus=
-web.truck=
-web.staticlink=liên kết tĩnh
-web.motorcycle=Mô tô
-via=qua
-finish=Kết thúc!
-hour_abbr=g
-day_abbr=n
-min_abbr=p
-km_abbr=km
-m_abbr=m
-mi_abbr=dặm
-ft_abbr=ft
-road=đường
-off_bike=xuống khỏi xe đạp
-cycleway=đường xe đạp
-way=đường
-small_way=
-paved=đường lát
-unpaved=đường không lát
-stopover=chặng dừng chân %1$s
-roundabout_enter=Đi vào vòng xoay
-roundabout_exit=Tại vòng xoay, rẽ lối rẽ %1$s
-roundabout_exit_onto=Tại vòng xoay, rẽ lối rẽ %1$s vào đường %2$s
-total_ascend=Đi tiếp %1$s nữa
-total_descend=
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
-web.start_label=
-web.intermediate_label=
-web.end_label=
-web.set_start=
-web.set_intermediate=
-web.set_end=
-web.center_map=
-web.show_coords=
-web.route=
-web.delete_from_route=
-web.marker=
-web.gh_offline_info=
-web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
-web.drag_to_reorder=
diff --git a/core/src/main/resources/com/graphhopper/util/vi_VN.txt b/core/src/main/resources/com/graphhopper/util/vi_VN.txt
new file mode 100644
index 0000000000..659d4e1135
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/vi_VN.txt
@@ -0,0 +1,79 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=tiếp tục
+continue_onto=tiếp tục theo %1$s
+turn_left=rẽ trái
+turn_right=rẽ phải
+turn_slight_left=rẽ nhẹ sang trái
+turn_slight_right=rẽ nhẹ sang phải
+turn_sharp_left=rẽ trái ngay lập tức
+turn_sharp_right=rẽ phải ngay lập tức
+keep_left=ở bên trái
+keep_right=ở bên phải
+turn_onto=%1$s vào %2$s
+u_turn=quay đầu xe
+unknown=không xác định %1$s
+web.search_button=Tìm
+web.from_hint=Từ
+web.via_hint=Qua
+web.to_hint=Đến
+web.more_button=thêm
+web.gpx_export_button=Xuất GPX
+web.route_info=%1$s mất %2$s
+web.pt_route_info=Đến lúc %1$s với %2$s phương tiện(tuyến) (%3$s )
+web.pt_route_info_walking=Đến lúc %1$s chỉ bằng cách đi bộ (%2$s)
+web.locations_not_found=Không tìm thấy lộ trình! Các điểm đã chọn không tìm thấy trong vùng này.
+web.bike=Xe đạp
+web.racingbike=Xe đạp đua
+web.mtb=Xe leo núi
+web.car=Ô tô
+web.foot=Đi bộ
+web.hike=Đi bộ đường dài
+web.small_truck=Xe tải nhỏ
+web.bus=Xe buýt
+web.truck=Xe tải
+web.staticlink=liên kết tĩnh
+web.motorcycle=Mô tô
+via=qua
+finish=Kết thúc!
+hour_abbr=giờ
+day_abbr=ngày
+min_abbr=phút
+km_abbr=km
+m_abbr=m
+mi_abbr=dặm
+ft_abbr=ft
+road=đường
+off_bike=xuống khỏi xe đạp
+cycleway=đường xe đạp
+way=đường
+small_way=đường nhỏ
+paved=đường lát
+unpaved=đường không lát
+stopover=chặng dừng chân %1$s
+roundabout_enter=Đi vào vòng xoay
+roundabout_exit=Tại vòng xoay, rẽ lối rẽ %1$s
+roundabout_exit_onto=Tại vòng xoay, rẽ lối rẽ %1$s vào đường %2$s
+total_ascend=Đi tiếp %1$s nữa
+total_descend=
+way_contains_ford=có khúc sông cạn trên đường
+pt_start_trip=nhập tuyến %1$s
+pt_end_trip=rời tuyến %1$s
+pt_transfer_to=chuyển sang tuyến %1$s
+web.start_label=Điểm bắt đầu
+web.intermediate_label=Điểm trung gian
+web.end_label=Điểm kết thúc
+web.set_start=Chọn điểm bắt đầu
+web.set_intermediate=Chọn điểm trung gian
+web.set_end=Chọn điểm kết thúc
+web.center_map=Trung tâm bản đồ
+web.show_coords=Xem tọa độ
+web.route=Lộ trình
+web.delete_from_route=Xóa khỏi tuyến đường
+web.marker=Đánh dấu
+web.gh_offline_info=Mất kết nối với GH API
+web.refresh_button=Làm mới lại trang
+web.server_status=Tình trạng Server
+web.zoom_in=Phóng to
+web.zoom_out=Thu nhỏ
+web.drag_to_reorder=Kéo để xếp lại
diff --git a/core/src/main/resources/com/graphhopper/util/zh_CN.txt b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
index 2aa3bb1187..c4eec2a121 100644
--- a/core/src/main/resources/com/graphhopper/util/zh_CN.txt
+++ b/core/src/main/resources/com/graphhopper/util/zh_CN.txt
@@ -8,11 +8,11 @@ turn_slight_left=偏左转
 turn_slight_right=偏右转
 turn_sharp_left=左急转
 turn_sharp_right=右急转
-keep_left=
-keep_right=
+keep_left=保持左行
+keep_right=保持右行
 turn_onto=%1$s 到  %2$s
-u_turn=
-unknown=
+u_turn=掉头
+unknown=未知指示标志 '%1$s'
 web.search_button=搜索
 web.from_hint=起点
 web.via_hint=途经点
@@ -21,17 +21,17 @@ web.more_button=更多
 web.gpx_export_button=GPX导出
 web.route_info=%1$s 的路线，需要 %2$s 时间
 web.pt_route_info=
-web.pt_route_info_walking=
+web.pt_route_info_walking=步行(%2$s), %1$s到达
 web.locations_not_found=地点未找到
 web.bike=自行车
 web.racingbike=竞技自行车
 web.mtb=山地自行车
 web.car=驾车
 web.foot=步行
-web.hike=
-web.small_truck=
-web.bus=
-web.truck=
+web.hike=徒步
+web.small_truck=小火车
+web.bus=公交车
+web.truck=卡车
 web.staticlink=静态链接
 web.motorcycle=摩托车
 via=途经
@@ -47,33 +47,33 @@ road=道路
 off_bike=下自行车
 cycleway=自行车道
 way=路
-small_way=
+small_way=小路
 paved=路面铺就
 unpaved=路面未铺就
 stopover=途中休息 %1$s
 roundabout_enter=进入环岛
 roundabout_exit=在环岛内，使用%1$s出口出环岛
 roundabout_exit_onto=在环岛内，使用%1$s出口出环岛，进入%2$s
-total_ascend=
-total_descend=
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
-web.start_label=
-web.intermediate_label=
-web.end_label=
-web.set_start=
-web.set_intermediate=
-web.set_end=
-web.center_map=
-web.show_coords=
-web.route=
-web.delete_from_route=
-web.marker=
-web.gh_offline_info=
-web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
+total_ascend=总上升%1$s
+total_descend=总下降%1$s
+way_contains_ford=路径中包含河滩
+pt_start_trip=进入%1$s
+pt_end_trip=离开%1$s
+pt_transfer_to=变道进入%1$s
+web.start_label=起点
+web.intermediate_label=途经点
+web.end_label=终点
+web.set_start=设置为起点
+web.set_intermediate=设置为途经点
+web.set_end=设置为终点
+web.center_map=地图居中到这里
+web.show_coords=显示坐标
+web.route=路线
+web.delete_from_route=从线路中移除
+web.marker=标记
+web.gh_offline_info=无法链接GraphHopper API
+web.refresh_button=刷新网页
+web.server_status=状态
+web.zoom_in=放大
+web.zoom_out=缩小
 web.drag_to_reorder=拖动可重新排序
diff --git a/core/src/main/resources/com/graphhopper/util/zh_TW.txt b/core/src/main/resources/com/graphhopper/util/zh_TW.txt
new file mode 100644
index 0000000000..a91fd1775b
--- /dev/null
+++ b/core/src/main/resources/com/graphhopper/util/zh_TW.txt
@@ -0,0 +1,79 @@
+# do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
+
+continue=繼續
+continue_onto=繼續行駛到 %1$s
+turn_left=左轉
+turn_right=右轉
+turn_slight_left=微靠左轉
+turn_slight_right=微靠右轉
+turn_sharp_left=左急轉
+turn_sharp_right=右急轉
+keep_left=保持左側
+keep_right=保持右側
+turn_onto=%1$s 進入%2$s
+u_turn=迴轉
+unknown=未知指示標誌 '%1$s'
+web.search_button=搜尋
+web.from_hint=起點
+web.via_hint=途經
+web.to_hint=迄點
+web.more_button=更多
+web.gpx_export_button=匯出GPS
+web.route_info=%1$s 需時 %2$s
+web.pt_route_info=於 %1$s 抵達，%2$s 次轉乘 (%3$s)
+web.pt_route_info_walking=於 %1$s 抵達，僅步行 (%2$s)
+web.locations_not_found=無法進行規劃。無法在此區域內找到指定的地點
+web.bike=自行車
+web.racingbike=競技自行車
+web.mtb=登山車
+web.car=汽車
+web.foot=步行
+web.hike=健行
+web.small_truck=小貨車
+web.bus=公車
+web.truck=貨車
+web.staticlink=永久鏈結
+web.motorcycle=摩托車
+via=途經
+finish=抵達目的地
+hour_abbr=小時
+day_abbr=天
+min_abbr=分鐘
+km_abbr=公里
+m_abbr=公尺
+mi_abbr=英里
+ft_abbr=英尺
+road=道路
+off_bike=下自行車
+cycleway=自行車道
+way=路
+small_way=小路
+paved=路面有鋪設
+unpaved=路面無鋪設
+stopover=中途點 %1$s
+roundabout_enter=進入圓環
+roundabout_exit=於 %1$s 個出口離開圓環
+roundabout_exit_onto=於 %1$s 個出口離開圓環，進入 %2$s
+total_ascend=總共上昇 %1$s
+total_descend=總共下降 %1$s
+way_contains_ford=路徑中含有淺灘
+pt_start_trip=進入 %1$s
+pt_end_trip=離開 %1$s
+pt_transfer_to=變換至 %1$s
+web.start_label=出發點
+web.intermediate_label=途經點
+web.end_label=抵達點
+web.set_start=設為出發點
+web.set_intermediate=設為途經點
+web.set_end=設為抵達點
+web.center_map=設為地圖中心
+web.show_coords=顯示坐標
+web.route=路線
+web.delete_from_route=從路線中移除
+web.marker=標記
+web.gh_offline_info=GraphHopper API 離線狀態？
+web.refresh_button=刷新頁面
+web.server_status=狀態
+web.zoom_in=放大
+web.zoom_out=縮小
+web.drag_to_reorder=拖曳排序
diff --git a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
index 0c1494e978..9cc85e6b3c 100644
--- a/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
+++ b/core/src/test/java/com/graphhopper/GraphHopperAPITest.java
@@ -18,17 +18,21 @@
 package com.graphhopper;
 
 import com.graphhopper.json.geo.JsonFeature;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.parsers.OSMRoadEnvironmentParser;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.change.ChangeGraphHelper;
 import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
 import org.junit.Test;
 
+import java.io.File;
 import java.util.*;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -42,7 +46,7 @@
  * @author Peter Karich
  */
 public class GraphHopperAPITest {
-    final EncodingManager encodingManager = new EncodingManager("car");
+    final EncodingManager encodingManager = EncodingManager.create("car");
 
     void initGraph(GraphHopperStorage graph) {
         NodeAccess na = graph.getNodeAccess();
@@ -107,6 +111,57 @@ public void testDisconnected179() {
         instance.close();
     }
 
+    @Test
+    public void testDoNotInterpolateTwice1645() {
+        String loc = "./target/issue1645";
+        Helper.removeDir(new File(loc));
+        EncodingManager em = new EncodingManager.Builder(4).add(new OSMRoadEnvironmentParser()).add(new CarFlagEncoder()).build();
+        GraphHopperStorage graph = new GraphBuilder(em).setLocation(loc).set3D(true).setStore(true).create();
+
+        // we need elevation
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 42, 10, 10);
+        na.setNode(1, 42.1, 10.1, 10);
+        na.setNode(2, 42.1, 10.2, 1);
+        na.setNode(3, 42, 10.4, 1);
+
+        graph.edge(0, 1, 10, true);
+        graph.edge(2, 3, 10, true);
+
+        final AtomicInteger counter = new AtomicInteger(0);
+        GraphHopper instance = new GraphHopper().setEncodingManager(em).setElevation(true).setGraphHopperLocation(loc).setCHEnabled(false)
+                .loadGraph(graph);
+        instance.flush();
+        instance.close();
+        assertEquals(0, counter.get());
+
+        instance = new GraphHopper() {
+            @Override
+            void interpolateBridgesAndOrTunnels() {
+                counter.incrementAndGet();
+                super.interpolateBridgesAndOrTunnels();
+            }
+        }.setEncodingManager(em).setElevation(true).setCHEnabled(false);
+        instance.load(loc);
+        instance.flush();
+        instance.close();
+        assertEquals(1, counter.get());
+
+        instance = new GraphHopper() {
+            @Override
+            void interpolateBridgesAndOrTunnels() {
+                counter.incrementAndGet();
+                super.interpolateBridgesAndOrTunnels();
+            }
+        }.setEncodingManager(em).setElevation(true).setCHEnabled(false);
+        instance.load(loc);
+        instance.flush();
+        instance.close();
+        assertEquals(1, counter.get());
+
+        Helper.removeDir(new File(loc));
+    }
+
     @Test
     public void testNoLoad() {
         GraphHopper instance = new GraphHopper().
diff --git a/core/src/test/java/com/graphhopper/Repeat.java b/core/src/test/java/com/graphhopper/Repeat.java
new file mode 100644
index 0000000000..7b6bb0f9e6
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/Repeat.java
@@ -0,0 +1,12 @@
+package com.graphhopper;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.METHOD})
+public @interface Repeat {
+    int times();
+}
diff --git a/core/src/test/java/com/graphhopper/RepeatRule.java b/core/src/test/java/com/graphhopper/RepeatRule.java
new file mode 100644
index 0000000000..cf304e195f
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/RepeatRule.java
@@ -0,0 +1,32 @@
+package com.graphhopper;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+public class RepeatRule implements TestRule {
+    @Override
+    public Statement apply(Statement base, Description description) {
+        Repeat repeat = description.getAnnotation(Repeat.class);
+        return repeat != null ?
+                new RepeatStatement(repeat.times(), base) :
+                base;
+    }
+
+    private static class RepeatStatement extends Statement {
+        private final int times;
+        private final Statement base;
+
+        RepeatStatement(int times, Statement base) {
+            this.times = times;
+            this.base = base;
+        }
+
+        @Override
+        public void evaluate() throws Throwable {
+            for (int i = 0; i < times; ++i) {
+                base.evaluate();
+            }
+        }
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java b/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
index 58c71daad2..ac0dfc304f 100644
--- a/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
+++ b/core/src/test/java/com/graphhopper/reader/PrincetonReaderTest.java
@@ -37,7 +37,7 @@
  * @author Peter Karich
  */
 public class PrincetonReaderTest {
-    private EncodingManager encodingManager = new EncodingManager("car");
+    private EncodingManager encodingManager = EncodingManager.create("car");
     private EdgeFilter carOutEdges = DefaultEdgeFilter.outEdges(encodingManager.getEncoder("car"));
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/reader/dem/BridgeElevationInterpolatorTest.java b/core/src/test/java/com/graphhopper/reader/dem/BridgeElevationInterpolatorTest.java
index 2baba77b6e..1bbf7721cd 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/BridgeElevationInterpolatorTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/BridgeElevationInterpolatorTest.java
@@ -18,21 +18,20 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.coll.GHIntHashSet;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Test;
-
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.RoadEnvironment;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PointList;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Alexey Valikov
  */
-public class BridgeElevationInterpolatorTest extends AbstractEdgeElevationInterpolatorTest {
+public class BridgeElevationInterpolatorTest extends EdgeElevationInterpolatorTest {
 
     @Override
     protected ReaderWay createInterpolatableWay() {
@@ -43,8 +42,8 @@ protected ReaderWay createInterpolatableWay() {
     }
 
     @Override
-    protected AbstractEdgeElevationInterpolator createEdgeElevationInterpolator() {
-        return new BridgeElevationInterpolator(graph, dataFlagEncoder);
+    protected EdgeElevationInterpolator createEdgeElevationInterpolator() {
+        return new EdgeElevationInterpolator(graph, roadEnvEnc, RoadEnvironment.BRIDGE);
     }
 
     @Test
@@ -53,13 +52,13 @@ public void interpolatesElevationOfPillarNodes() {
         // @formatter:off
         /*
          * Graph structure:
-		 * 0-----1-----2-----3-----4
-		 *        \    |    /
-		 *         \   |   /
-		 *          T  T  T
-		 *           \ | /
-		 *            \|/
-		 * 5-----6--T--7--T--8-----9
+         * 0-----1-----2-----3-----4
+         *        \    |    /
+         *         \   |   /
+         *          T  T  T
+         *           \ | /
+         *            \|/
+         * 5-----6--T--7--T--8-----9
          */
         // @formatter:on
         NodeAccess na = graph.getNodeAccess();
@@ -88,19 +87,19 @@ public void interpolatesElevationOfPillarNodes() {
         edge17.setWayGeometry(
                 Helper.createPointList3D(12, 2, 200, 14, 4, 400, 16, 6, 600, 18, 8, 800));
 
-        edge01.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge12.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge23.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge34.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge01.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge12.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge23.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge34.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
 
-        edge56.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge67.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge78.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge89.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge56.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge67.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge78.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge89.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
 
-        edge17.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge27.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge37.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge17.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge27.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge37.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
 
         final GHIntHashSet outerNodeIds = new GHIntHashSet();
         final GHIntHashSet innerNodeIds = new GHIntHashSet();
diff --git a/core/src/test/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolatorTest.java b/core/src/test/java/com/graphhopper/reader/dem/EdgeElevationInterpolatorTest.java
similarity index 68%
rename from core/src/test/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolatorTest.java
rename to core/src/test/java/com/graphhopper/reader/dem/EdgeElevationInterpolatorTest.java
index 02991c15da..fd32b1bf19 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/AbstractEdgeElevationInterpolatorTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/EdgeElevationInterpolatorTest.java
@@ -17,45 +17,47 @@
  */
 package com.graphhopper.reader.dem;
 
-import java.util.Arrays;
-
-import org.junit.After;
-import org.junit.Before;
-
 import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.coll.GHIntHashSet;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.util.DataFlagEncoder;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadEnvironment;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.routing.util.parsers.OSMRoadEnvironmentParser;
 import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
+import org.junit.After;
+import org.junit.Before;
 
 /**
  * @author Alexey Valikov
  */
-public abstract class AbstractEdgeElevationInterpolatorTest {
+public abstract class EdgeElevationInterpolatorTest {
 
+    protected final static EncodingManager.AcceptWay ACCEPT_WAY = new EncodingManager.AcceptWay().
+            put(RoadEnvironment.KEY, EncodingManager.Access.WAY).put("car", EncodingManager.Access.WAY).put("foot", EncodingManager.Access.WAY);
     protected static final double PRECISION = ElevationInterpolator.EPSILON2;
     protected ReaderWay interpolatableWay;
     protected ReaderWay normalWay;
 
     protected GraphHopperStorage graph;
-    protected DataFlagEncoder dataFlagEncoder;
-    protected AbstractEdgeElevationInterpolator edgeElevationInterpolator;
+    protected EnumEncodedValue<RoadEnvironment> roadEnvEnc;
+    protected EncodingManager encodingManager;
+    protected EdgeElevationInterpolator edgeElevationInterpolator;
 
     @SuppressWarnings("resource")
     @Before
     public void setUp() {
-        dataFlagEncoder = new DataFlagEncoder();
         graph = new GraphHopperStorage(new RAMDirectory(),
-                new EncodingManager(Arrays.asList(dataFlagEncoder, new FootFlagEncoder()),
-                        8),
+                encodingManager = new EncodingManager.Builder(8).add(new CarFlagEncoder()).add(new FootFlagEncoder()).
+                        add(new OSMRoadEnvironmentParser()).build(),
                 true, new GraphExtension.NoOpExtension()).create(100);
-
+        roadEnvEnc = encodingManager.getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class);
         edgeElevationInterpolator = createEdgeElevationInterpolator();
 
         interpolatableWay = createInterpolatableWay();
@@ -70,8 +72,8 @@ public void tearDown() {
 
     protected abstract ReaderWay createInterpolatableWay();
 
-    protected AbstractEdgeElevationInterpolator createEdgeElevationInterpolator() {
-        return new BridgeElevationInterpolator(graph, dataFlagEncoder);
+    protected EdgeElevationInterpolator createEdgeElevationInterpolator() {
+        return new EdgeElevationInterpolator(graph, roadEnvEnc, RoadEnvironment.BRIDGE);
     }
 
     protected void gatherOuterAndInnerNodeIdsOfStructure(EdgeIteratorState edge,
diff --git a/core/src/test/java/com/graphhopper/reader/dem/TunnelElevationInterpolatorTest.java b/core/src/test/java/com/graphhopper/reader/dem/TunnelElevationInterpolatorTest.java
index ee9d80408e..a10f2deb6a 100644
--- a/core/src/test/java/com/graphhopper/reader/dem/TunnelElevationInterpolatorTest.java
+++ b/core/src/test/java/com/graphhopper/reader/dem/TunnelElevationInterpolatorTest.java
@@ -18,19 +18,18 @@
 package com.graphhopper.reader.dem;
 
 import com.graphhopper.coll.GHIntHashSet;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Test;
-
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.RoadEnvironment;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Alexey Valikov
  */
-public class TunnelElevationInterpolatorTest extends AbstractEdgeElevationInterpolatorTest {
+public class TunnelElevationInterpolatorTest extends EdgeElevationInterpolatorTest {
 
     @Override
     protected ReaderWay createInterpolatableWay() {
@@ -41,8 +40,8 @@ protected ReaderWay createInterpolatableWay() {
     }
 
     @Override
-    protected AbstractEdgeElevationInterpolator createEdgeElevationInterpolator() {
-        return new TunnelElevationInterpolator(graph, dataFlagEncoder);
+    protected EdgeElevationInterpolator createEdgeElevationInterpolator() {
+        return new EdgeElevationInterpolator(graph, roadEnvEnc, RoadEnvironment.TUNNEL);
     }
 
     @Test
@@ -51,8 +50,8 @@ public void doesNotInterpolateElevationOfTunnelWithZeroOuterNodes() {
         // @formatter:off
         /*
          * Graph structure:
-		 * 0--T--1--T--2     3--T--4
-		 * Tunnel 0-1-2 has a single outer node 2.
+         * 0--T--1--T--2     3--T--4
+         * Tunnel 0-1-2 has a single outer node 2.
          */
         // @formatter:on
         NodeAccess na = graph.getNodeAccess();
@@ -66,9 +65,9 @@ public void doesNotInterpolateElevationOfTunnelWithZeroOuterNodes() {
         EdgeIteratorState edge12 = graph.edge(1, 2, 10, true);
         EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
 
-        edge01.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge34.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge01.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge12.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge34.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
 
         final GHIntHashSet outerNodeIds = new GHIntHashSet();
         final GHIntHashSet innerNodeIds = new GHIntHashSet();
@@ -90,8 +89,8 @@ public void interpolatesElevationOfTunnelWithSingleOuterNode() {
 
         // @formatter:off
         /*
-		 * Graph structure:
-		 * 0--T--1--T--2-----3--T--4
+         * Graph structure:
+         * 0--T--1--T--2-----3--T--4
          */
         // @formatter:on
         NodeAccess na = graph.getNodeAccess();
@@ -106,10 +105,10 @@ public void interpolatesElevationOfTunnelWithSingleOuterNode() {
         EdgeIteratorState edge23 = graph.edge(2, 3, 10, true);
         EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
 
-        edge01.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge23.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge34.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge01.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge12.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge23.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge34.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
 
         final GHIntHashSet outerNodeIds = new GHIntHashSet();
         final GHIntHashSet innerNodeIds = new GHIntHashSet();
@@ -131,8 +130,8 @@ public void interpolatesElevationOfTunnelWithTwoOuterNodes() {
 
         // @formatter:off
         /*
-		 * Graph structure:
-		 * 0-----1--T--2--T--3-----4
+         * Graph structure:
+         * 0-----1--T--2--T--3-----4
          */
         // @formatter:on
         NodeAccess na = graph.getNodeAccess();
@@ -147,10 +146,10 @@ public void interpolatesElevationOfTunnelWithTwoOuterNodes() {
         EdgeIteratorState edge23 = graph.edge(2, 3, 10, true);
         EdgeIteratorState edge34 = graph.edge(3, 4, 10, true);
 
-        edge01.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge23.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge34.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge01.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge12.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge23.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge34.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
 
         final GHIntHashSet outerNodeIds = new GHIntHashSet();
         final GHIntHashSet innerNodeIds = new GHIntHashSet();
@@ -172,14 +171,14 @@ public void interpolatesElevationOfTunnelWithThreeOuterNodes() {
 
         // @formatter:off
         /*
-		 * Graph structure:
-		 * 0-----1--T--2--T--3-----4
-		 *             |
-		 *             |
-		 *             T
-		 *             |
-		 *             |
-		 *             5--T--6-----7
+         * Graph structure:
+         * 0-----1--T--2--T--3-----4
+         *             |
+         *             |
+         *             T
+         *             |
+         *             |
+         *             5--T--6-----7
          */
         // @formatter:on
         NodeAccess na = graph.getNodeAccess();
@@ -200,13 +199,13 @@ public void interpolatesElevationOfTunnelWithThreeOuterNodes() {
         EdgeIteratorState edge56 = graph.edge(5, 6, 10, true);
         EdgeIteratorState edge67 = graph.edge(6, 7, 10, true);
 
-        edge01.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge23.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge34.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge25.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge56.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge67.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge01.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge12.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge23.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge34.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge25.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge56.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge67.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
 
         final GHIntHashSet outerNodeIds = new GHIntHashSet();
         final GHIntHashSet innerNodeIds = new GHIntHashSet();
@@ -231,14 +230,14 @@ public void interpolatesElevationOfTunnelWithFourOuterNodes() {
 
         // @formatter:off
         /*
-            * Graph structure:
-            * 0-----1--T--2--T--3-----4
-            *             |
-            *             |
-            *             T
-            *             |
-            *             |
-            * 5-----6--T--7--T--8-----9
+         * Graph structure:
+         * 0-----1--T--2--T--3-----4
+         *             |
+         *             |
+         *             T
+         *             |
+         *             |
+         * 5-----6--T--7--T--8-----9
          */
         // @formatter:on
         NodeAccess na = graph.getNodeAccess();
@@ -263,17 +262,17 @@ public void interpolatesElevationOfTunnelWithFourOuterNodes() {
         EdgeIteratorState edge89 = graph.edge(8, 9, 10, true);
         EdgeIteratorState edge27 = graph.edge(2, 7, 10, true);
 
-        edge01.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge12.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge23.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge34.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge01.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge12.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge23.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge34.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
 
-        edge56.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
-        edge67.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge78.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
-        edge89.setFlags(dataFlagEncoder.handleWayTags(normalWay, 1, 0));
+        edge56.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
+        edge67.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge78.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
+        edge89.setFlags(encodingManager.handleWayTags(normalWay, ACCEPT_WAY, 0));
 
-        edge27.setFlags(dataFlagEncoder.handleWayTags(interpolatableWay, 1, 0));
+        edge27.setFlags(encodingManager.handleWayTags(interpolatableWay, ACCEPT_WAY, 0));
 
         final GHIntHashSet outerNodeIds = new GHIntHashSet();
         final GHIntHashSet innerNodeIds = new GHIntHashSet();
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionEdgeCHTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionEdgeCHTest.java
new file mode 100644
index 0000000000..b578638ca4
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionEdgeCHTest.java
@@ -0,0 +1,62 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.Parameters;
+
+import java.util.Collections;
+import java.util.List;
+
+public class AStarBidirectionEdgeCHTest extends AbstractRoutingAlgorithmTester {
+    @Override
+    protected AlgorithmOptions createAlgoOptions() {
+        return AlgorithmOptions.start()
+                .algorithm(Parameters.Algorithms.ASTAR_BI)
+                .weighting(new ShortestWeighting(carEncoder)).build();
+    }
+
+    @Override
+    protected CHGraph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
+        return ghStorage.getCHGraph(weighting);
+    }
+
+    @Override
+    protected GraphHopperStorage createGHStorage(
+            EncodingManager em, List<? extends Weighting> weightings, boolean is3D) {
+        return new GraphHopperStorage(Collections.<Weighting>emptyList(), weightings, new RAMDirectory(), em, is3D, new TurnCostExtension()).create(1000);
+    }
+
+    @Override
+    public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
+        ghStorage.freeze();
+        PrepareContractionHierarchies ch = PrepareContractionHierarchies.fromGraphHopperStorage(
+                ghStorage, opts.getWeighting(), TraversalMode.EDGE_BASED);
+        ch.doWork();
+        return ch;
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
index 60b70c23d6..1c1b63a3a1 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarBidirectionTest.java
@@ -19,9 +19,12 @@
 
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.SPTEntry;
+import com.graphhopper.storage.TurnCostExtension;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -39,9 +42,11 @@
 @RunWith(Parameterized.class)
 public class AStarBidirectionTest extends AbstractRoutingAlgorithmTester {
     private final TraversalMode traversalMode;
+    private final boolean allowUTurns;
 
-    public AStarBidirectionTest(TraversalMode tMode) {
+    public AStarBidirectionTest(TraversalMode tMode, boolean allowUTurns) {
         this.traversalMode = tMode;
+        this.allowUTurns = allowUTurns;
     }
 
     /**
@@ -50,10 +55,9 @@ public AStarBidirectionTest(TraversalMode tMode) {
     @Parameters(name = "{0}")
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
-                {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_1DIR},
-                {TraversalMode.EDGE_BASED_2DIR},
-                {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                {TraversalMode.NODE_BASED, false},
+                {TraversalMode.EDGE_BASED, false},
+                {TraversalMode.EDGE_BASED, true}
         });
     }
 
@@ -62,7 +66,12 @@ public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, Al
         return new RoutingAlgorithmFactory() {
             @Override
             public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
-                return new AStarBidirection(g, opts.getWeighting(), traversalMode);
+                Weighting w = opts.getWeighting();
+                if (traversalMode.isEdgeBased()) {
+                    double uTurnCost = allowUTurns ? 40 : Double.POSITIVE_INFINITY;
+                    w = new TurnWeighting(w, (TurnCostExtension) g.getExtension(), uTurnCost);
+                }
+                return new AStarBidirection(g, w, traversalMode);
             }
         };
     }
diff --git a/core/src/test/java/com/graphhopper/routing/AStarTest.java b/core/src/test/java/com/graphhopper/routing/AStarTest.java
index 56f12bd467..1cfe5e6989 100644
--- a/core/src/test/java/com/graphhopper/routing/AStarTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AStarTest.java
@@ -18,8 +18,11 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
@@ -27,37 +30,43 @@
 import java.util.Arrays;
 import java.util.Collection;
 
+
 /**
  * @author Peter Karich
  */
 @RunWith(Parameterized.class)
 public class AStarTest extends AbstractRoutingAlgorithmTester {
     private final TraversalMode traversalMode;
+    private final boolean allowUTurns;
 
-    public AStarTest(TraversalMode tMode) {
+    public AStarTest(TraversalMode tMode, boolean allowUTurns) {
         this.traversalMode = tMode;
+        this.allowUTurns = allowUTurns;
     }
 
     /**
      * Runs the same test with each of the supported traversal modes
      */
     @Parameters(name = "{0}")
-
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
-                {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_1DIR},
-                {TraversalMode.EDGE_BASED_2DIR},
-                {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                {TraversalMode.NODE_BASED, false},
+                {TraversalMode.EDGE_BASED, false},
+                {TraversalMode.EDGE_BASED, true}
         });
     }
 
     @Override
-    public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, AlgorithmOptions prepareOpts) {
+    public RoutingAlgorithmFactory createFactory(final GraphHopperStorage prepareGraph, final AlgorithmOptions prepareOpts) {
         return new RoutingAlgorithmFactory() {
             @Override
             public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
-                return new AStar(g, opts.getWeighting(), traversalMode);
+                Weighting w = opts.getWeighting();
+                if (traversalMode.isEdgeBased()) {
+                    double uTurnCost = allowUTurns ? 40 : Double.POSITIVE_INFINITY;
+                    w = new TurnWeighting(w, (TurnCostExtension) g.getExtension(), uTurnCost);
+                }
+                return new AStar(g, w, traversalMode);
             }
         };
     }
diff --git a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
index 3c3af34e5b..584dcbdf7d 100644
--- a/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
+++ b/core/src/test/java/com/graphhopper/routing/AbstractRoutingAlgorithmTester.java
@@ -19,6 +19,8 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.IntIndexedContainer;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
@@ -42,9 +44,11 @@
  * @author Peter Karich
  */
 public abstract class AbstractRoutingAlgorithmTester {
-    protected static final EncodingManager encodingManager = new EncodingManager("car,foot");
+    protected static final EncodingManager encodingManager = EncodingManager.create("car,foot");
     private static final DistanceCalc distCalc = new DistanceCalcEarth();
     protected FlagEncoder carEncoder;
+    protected DecimalEncodedValue carAvSpeedEnc;
+    protected BooleanEncodedValue carAccessEnc;
     protected FlagEncoder footEncoder;
     protected AlgorithmOptions defaultOpts;
 
@@ -147,6 +151,8 @@ protected static GraphHopperStorage createMatrixAlikeGraph(GraphHopperStorage tm
     @Before
     public void setUp() {
         carEncoder = encodingManager.getEncoder("car");
+        carAccessEnc = carEncoder.getAccessEnc();
+        carAvSpeedEnc = carEncoder.getAverageSpeedEnc();
         footEncoder = encodingManager.getEncoder("foot");
         defaultOpts = createAlgoOptions();
     }
@@ -157,11 +163,11 @@ protected AlgorithmOptions createAlgoOptions() {
     }
 
     protected Graph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
-        return ghStorage.getGraph(Graph.class, weighting);
+        return ghStorage.getBaseGraph();
     }
 
     protected GraphHopperStorage createGHStorage(EncodingManager em, List<? extends Weighting> weightings, boolean is3D) {
-        return new GraphBuilder(em).set3D(is3D).create();
+        return new GraphBuilder(em).set3D(is3D).withTurnCosts(true).create();
     }
 
     protected GraphHopperStorage createGHStorage(boolean is3D) {
@@ -183,7 +189,7 @@ public void testCalcShortestPath() {
         GraphHopperStorage ghStorage = createTestStorage();
         RoutingAlgorithm algo = createAlgo(ghStorage);
         Path p = algo.calcPath(0, 7);
-        assertEquals(p.toString(), IntArrayList.from(new int[]{0, 4, 5, 7}), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(0, 4, 5, 7), p.calcNodes());
         assertEquals(p.toString(), 62.1, p.getDistance(), .1);
     }
 
@@ -195,8 +201,7 @@ public void testCalcShortestPath_sourceEqualsTarget() {
 
         RoutingAlgorithm algo = createAlgo(graph);
         Path p = algo.calcPath(0, 0);
-        assertEquals(p.toString(), IntArrayList.from(new int[]{0}), p.calcNodes());
-        assertEquals(p.toString(), 0, p.getDistance(), 1.e-6);
+        assertPathFromEqualsTo(p, 0);
     }
 
     @Test
@@ -212,7 +217,7 @@ public void testSimpleAlternative() {
         graph.edge(4, 1, 9, true);
         Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
-        assertEquals(IntArrayList.from(new int[]{0, 2, 1, 4}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 2, 1, 4), p.calcNodes());
     }
 
     @Test
@@ -225,7 +230,7 @@ public void testBidirectionalLinear() {
         graph.edge(4, 1, 9, true);
         Path p = createAlgo(graph).calcPath(3, 5);
         assertEquals(p.toString(), 28, p.getDistance(), 1e-4);
-        assertEquals(IntArrayList.from(new int[]{3, 2, 1, 4, 5}), p.calcNodes());
+        assertEquals(IntArrayList.from(3, 2, 1, 4, 5), p.calcNodes());
     }
 
     // see calc-fastest-graph.svg
@@ -235,7 +240,7 @@ public void testCalcFastestPath() {
         initDirectedAndDiffSpeed(graphShortest, carEncoder);
         Path p1 = createAlgo(graphShortest, defaultOpts).
                 calcPath(0, 3);
-        assertEquals(IntArrayList.from(new int[]{0, 1, 5, 2, 3}), p1.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 5, 2, 3), p1.calcNodes());
         assertEquals(p1.toString(), 402.3, p1.getDistance(), .1);
         assertEquals(p1.toString(), 144823, p1.getTime());
 
@@ -245,7 +250,7 @@ public void testCalcFastestPath() {
         initDirectedAndDiffSpeed(graphFastest, carEncoder);
         Path p2 = createAlgo(graphFastest, opts).
                 calcPath(0, 3);
-        assertEquals(IntArrayList.from(new int[]{0, 4, 6, 7, 5, 3}), p2.calcNodes());
+        assertEquals(IntArrayList.from(0, 4, 6, 7, 5, 3), p2.calcNodes());
         assertEquals(p2.toString(), 1261.7, p2.getDistance(), 0.1);
         assertEquals(p2.toString(), 111442, p2.getTime());
     }
@@ -256,26 +261,26 @@ public void testCalcFastestPath() {
     // |/ \--7
     // 6----/
     protected void initDirectedAndDiffSpeed(Graph graph, FlagEncoder enc) {
-        graph.edge(0, 1).setFlags(enc.setProperties(10, true, false));
-        graph.edge(0, 4).setFlags(enc.setProperties(100, true, false));
+        GHUtility.setProperties(graph.edge(0, 1), enc, 10, true, false);
+        GHUtility.setProperties(graph.edge(0, 4), enc, 100, true, false);
 
-        graph.edge(1, 4).setFlags(enc.setProperties(10, true, true));
-        graph.edge(1, 5).setFlags(enc.setProperties(10, true, true));
-        EdgeIteratorState edge12 = graph.edge(1, 2).setFlags(enc.setProperties(10, true, true));
+        GHUtility.setProperties(graph.edge(1, 4), enc, 10, true, true);
+        GHUtility.setProperties(graph.edge(1, 5), enc, 10, true, true);
+        EdgeIteratorState edge12 = GHUtility.setProperties(graph.edge(1, 2), enc, 10, true, true);
 
-        graph.edge(5, 2).setFlags(enc.setProperties(10, true, false));
-        graph.edge(2, 3).setFlags(enc.setProperties(10, true, false));
+        GHUtility.setProperties(graph.edge(5, 2), enc, 10, true, false);
+        GHUtility.setProperties(graph.edge(2, 3), enc, 10, true, false);
 
-        EdgeIteratorState edge53 = graph.edge(5, 3).setFlags(enc.setProperties(20, true, false));
-        graph.edge(3, 7).setFlags(enc.setProperties(10, true, false));
+        EdgeIteratorState edge53 = GHUtility.setProperties(graph.edge(5, 3), enc, 20, true, false);
+        GHUtility.setProperties(graph.edge(3, 7), enc, 10, true, false);
 
-        graph.edge(4, 6).setFlags(enc.setProperties(100, true, false));
-        graph.edge(5, 4).setFlags(enc.setProperties(10, true, false));
+        GHUtility.setProperties(graph.edge(4, 6), enc, 100, true, false);
+        GHUtility.setProperties(graph.edge(5, 4), enc, 10, true, false);
 
-        graph.edge(5, 6).setFlags(enc.setProperties(10, true, false));
-        graph.edge(7, 5).setFlags(enc.setProperties(100, true, false));
+        GHUtility.setProperties(graph.edge(5, 6), enc, 10, true, false);
+        GHUtility.setProperties(graph.edge(7, 5), enc, 100, true, false);
 
-        graph.edge(6, 7).setFlags(enc.setProperties(100, true, true));
+        GHUtility.setProperties(graph.edge(6, 7), enc, 100, true, true);
 
         updateDistancesFor(graph, 0, 0.002, 0);
         updateDistancesFor(graph, 1, 0.002, 0.001);
@@ -300,30 +305,44 @@ public void testCalcFootPath() {
                 calcPath(0, 7);
         assertEquals(p1.toString(), 17000, p1.getDistance(), 1e-6);
         assertEquals(p1.toString(), 12240 * 1000, p1.getTime());
-        assertEquals(IntArrayList.from(new int[]{0, 4, 5, 7}), p1.calcNodes());
+        assertEquals(IntArrayList.from(0, 4, 5, 7), p1.calcNodes());
     }
 
     protected void initFootVsCar(Graph graph) {
-        graph.edge(0, 1).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
-
-        graph.edge(1, 4).setDistance(7000).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setDistance(7000).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 2).setDistance(20000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, true));
-
-        graph.edge(5, 2).setDistance(5000).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
-
-        graph.edge(5, 3).setDistance(11000).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
-
-        graph.edge(4, 6).setDistance(5000).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(5, 4).setDistance(7000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(10, true, false));
-
-        graph.edge(5, 6).setDistance(7000).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setDistance(5000).setFlags(footEncoder.setProperties(5, true, true) | carEncoder.setProperties(20, true, false));
-
-        graph.edge(6, 7).setDistance(5000).setFlags(carEncoder.setProperties(20, true, true));
+        EdgeIteratorState edge = graph.edge(0, 1).setDistance(7000);
+        GHUtility.setProperties(edge, footEncoder, 5, true, true);
+        GHUtility.setProperties(edge, carEncoder, 10, true, false);
+        edge = graph.edge(0, 4).setDistance(5000);
+        GHUtility.setProperties(edge, footEncoder, 5, true, true);
+        GHUtility.setProperties(edge, carEncoder, 20, true, false);
+
+        GHUtility.setProperties(graph.edge(1, 4).setDistance(7000), carEncoder, 10, true, true);
+        GHUtility.setProperties(graph.edge(1, 5).setDistance(7000), carEncoder, 10, true, true);
+        edge = graph.edge(1, 2).setDistance(20000);
+        GHUtility.setProperties(edge, footEncoder, 5, true, true);
+        GHUtility.setProperties(edge, carEncoder, 10, true, true);
+
+        GHUtility.setProperties(graph.edge(5, 2).setDistance(5000), carEncoder, 10, true, false);
+        edge = graph.edge(2, 3).setDistance(5000);
+        GHUtility.setProperties(edge, footEncoder, 5, true, true);
+        GHUtility.setProperties(edge, carEncoder, 10, true, false);
+
+        GHUtility.setProperties(graph.edge(5, 3).setDistance(11000), carEncoder, 20, true, false);
+        edge = graph.edge(3, 7).setDistance(7000);
+        GHUtility.setProperties(edge, footEncoder, 5, true, true);
+        GHUtility.setProperties(edge, carEncoder, 10, true, false);
+
+        GHUtility.setProperties(graph.edge(4, 6).setDistance(5000), carEncoder, 20, true, false);
+        edge = graph.edge(5, 4).setDistance(7000);
+        GHUtility.setProperties(edge, footEncoder, 5, true, true);
+        GHUtility.setProperties(edge, carEncoder, 10, true, false);
+
+        GHUtility.setProperties(graph.edge(5, 6).setDistance(7000), carEncoder, 10, true, false);
+        edge = graph.edge(7, 5).setDistance(5000);
+        GHUtility.setProperties(edge, footEncoder, 5, true, true);
+        GHUtility.setProperties(edge, carEncoder, 20, true, false);
+
+        GHUtility.setProperties(graph.edge(6, 7).setDistance(5000), carEncoder, 20, true, true);
     }
 
     // see test-graph.svg !
@@ -395,14 +414,14 @@ public void testNoPathFound() {
     public void testWikipediaShortestPath() {
         GraphHopperStorage ghStorage = createWikipediaTestGraph();
         Path p = createAlgo(ghStorage).calcPath(0, 4);
-        assertEquals(p.toString(), IntArrayList.from(new int[]{0, 2, 5, 4}), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(0, 2, 5, 4), p.calcNodes());
         assertEquals(p.toString(), 20, p.getDistance(), 1e-4);
     }
 
     @Test
     public void testCalcIf1EdgeAway() {
         Path p = createAlgo(createTestStorage()).calcPath(1, 2);
-        assertEquals(IntArrayList.from(new int[]{1, 2}), p.calcNodes());
+        assertEquals(IntArrayList.from(1, 2), p.calcNodes());
         assertEquals(p.toString(), 35.1, p.getDistance(), .1);
     }
 
@@ -429,12 +448,12 @@ public void testBidirectional() {
         // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
         Path p = createAlgo(graph).calcPath(0, 4);
         // PrepareTowerNodesShortcutsTest.printEdges((CHGraph) graph);
-        assertEquals(p.toString(), IntArrayList.from(new int[]{0, 7, 6, 8, 3, 4}), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(0, 7, 6, 8, 3, 4), p.calcNodes());
         assertEquals(p.toString(), 335.8, p.getDistance(), .1);
 
         p = createAlgo(graph).calcPath(1, 2);
         // the other way around is even larger as 0-1 is already 11008.452
-        assertEquals(p.toString(), IntArrayList.from(new int[]{1, 2}), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(1, 2), p.calcNodes());
         assertEquals(p.toString(), 10007.7, p.getDistance(), .1);
     }
 
@@ -498,7 +517,7 @@ public void testBidirectional2() {
         Path p = createAlgo(graph).calcPath(0, 4);
         assertEquals(p.toString(), 40, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 5, p.calcNodes().size());
-        assertEquals(IntArrayList.from(new int[]{0, 7, 6, 5, 4}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 7, 6, 5, 4), p.calcNodes());
     }
 
     @Test
@@ -509,9 +528,9 @@ public void testRekeyBugOfIntBinHeap() {
         assertEquals(12, p.calcNodes().size());
 
         IntIndexedContainer list = p.calcNodes();
-        if (!IntArrayList.from(new int[]{36, 46, 56, 66, 76, 86, 85, 84, 94, 93, 92, 91}).equals(list)
-                && !IntArrayList.from(new int[]{36, 46, 56, 66, 76, 86, 85, 84, 83, 82, 92, 91}).equals(list)) {
-            assertTrue("wrong locations: " + list.toString(), false);
+        if (!IntArrayList.from(36, 46, 56, 66, 76, 86, 85, 84, 94, 93, 92, 91).equals(list)
+                && !IntArrayList.from(36, 46, 56, 66, 76, 86, 85, 84, 83, 82, 92, 91).equals(list)) {
+            fail("wrong locations: " + list.toString());
         }
         assertEquals(66f, p.getDistance(), 1e-3);
 
@@ -521,14 +540,14 @@ public void testRekeyBugOfIntBinHeap() {
 
     public void testBug1(GraphHopperStorage g) {
         Path p = createAlgo(g).calcPath(34, 36);
-        assertEquals(IntArrayList.from(new int[]{34, 35, 36}), p.calcNodes());
+        assertEquals(IntArrayList.from(34, 35, 36), p.calcNodes());
         assertEquals(3, p.calcNodes().size());
         assertEquals(17, p.getDistance(), 1e-5);
     }
 
     public void testCorrectWeight(GraphHopperStorage g) {
         Path p = createAlgo(g).calcPath(45, 72);
-        assertEquals(IntArrayList.from(new int[]{45, 44, 54, 64, 74, 73, 72}), p.calcNodes());
+        assertEquals(IntArrayList.from(45, 44, 54, 64, 74, 73, 72), p.calcNodes());
         assertEquals(38f, p.getDistance(), 1e-3);
     }
 
@@ -553,7 +572,7 @@ public void testDirectedGraphBug1() {
         graph.edge(4, 2, 1, false);
 
         Path p = createAlgo(graph).calcPath(0, 2);
-        assertEquals(IntArrayList.from(new int[]{0, 1, 2}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 2), p.calcNodes());
         assertEquals(p.toString(), 5.99, p.getDistance(), 1e-4);
         assertEquals(p.toString(), 3, p.calcNodes().size());
     }
@@ -568,7 +587,7 @@ public void testDirectedGraphBug2() {
         graph.edge(3, 1, 4, true);
 
         Path p = createAlgo(graph).calcPath(0, 3);
-        assertEquals(IntArrayList.from(new int[]{0, 1, 2, 3}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 2, 3), p.calcNodes());
     }
 
     // a-b-0-c-1
@@ -600,12 +619,12 @@ public void testWithCoordinates() {
         AlgorithmOptions opts = new AlgorithmOptions(DIJKSTRA_BI, weighting);
         RoutingAlgorithmFactory prepare = createFactory(graph, opts);
         Path p = prepare.createAlgo(getGraph(graph, opts.getWeighting()), opts).calcPath(4, 0);
-        assertEquals(IntArrayList.from(new int[]{4, 1, 0}), p.calcNodes());
+        assertEquals(IntArrayList.from(4, 1, 0), p.calcNodes());
         assertEquals(Helper.createPointList(0, 2, 1, 1.5, 1.5, 1, 1, 0.6), p.calcPoints());
         assertEquals(274128, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
 
         p = prepare.createAlgo(getGraph(graph, opts.getWeighting()), opts).calcPath(2, 1);
-        assertEquals(IntArrayList.from(new int[]{2, 0, 1}), p.calcNodes());
+        assertEquals(IntArrayList.from(2, 0, 1), p.calcNodes());
         assertEquals(Helper.createPointList(0, 0, 1, 0.6, 1.5, 1, 1, 1.5), p.calcPoints());
         assertEquals(279482, p.calcPoints().calcDistance(new DistanceCalcEarth()), 1);
     }
@@ -613,8 +632,7 @@ public void testWithCoordinates() {
     @Test
     public void testCalcIfEmptyWay() {
         Path p = createAlgo(createTestStorage()).calcPath(0, 0);
-        assertEquals(p.calcNodes().toString(), 1, p.calcNodes().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        assertPathFromEqualsTo(p, 0);
     }
 
     @Test
@@ -622,21 +640,15 @@ public void testViaEdges_FromEqualsTo() {
         GraphHopperStorage ghStorage = createTestStorage();
         // identical tower nodes
         Path p = calcPathViaQuery(ghStorage, 0.001, 0.000, 0.001, 0.000);
-        assertTrue(p.isFound());
-        assertEquals(IntArrayList.from(new int[]{0}), p.calcNodes());
-        // assertEquals(1, p.calcPoints().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        assertPathFromEqualsTo(p, 0);
 
         // identical query points on edge
         p = calcPath(ghStorage, 0, 1, 0, 1);
-        assertTrue(p.isFound());
-        assertEquals(IntArrayList.from(new int[]{8}), p.calcNodes());
-        // assertEquals(1, p.calcPoints().size());
-        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        assertPathFromEqualsTo(p, 8);
 
         // very close
         p = calcPathViaQuery(ghStorage, 0.00092, 0, 0.00091, 0);
-        assertEquals(IntArrayList.from(new int[]{8, 9}), p.calcNodes());
+        assertEquals(IntArrayList.from(8, 9), p.calcNodes());
         assertEquals(p.toString(), 1.11, p.getDistance(), .1);
     }
 
@@ -647,12 +659,12 @@ public void testViaEdges_BiGraph() {
 
         // 0-7 to 4-3
         Path p = calcPathViaQuery(graph, 0.0009, 0, 0.001, 0.001105);
-        assertEquals(p.toString(), IntArrayList.from(new int[]{10, 7, 6, 8, 3, 9}), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(10, 7, 6, 8, 3, 9), p.calcNodes());
         assertEquals(p.toString(), 324.11, p.getDistance(), 0.01);
 
         // 0-1 to 2-3
         p = calcPathViaQuery(graph, 0.001, 0.0001, 0.010, 0.0011);
-        assertEquals(p.toString(), IntArrayList.from(new int[]{0, 7, 6, 8, 3, 9}), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(0, 7, 6, 8, 3, 9), p.calcNodes());
         assertEquals(p.toString(), 1335.35, p.getDistance(), 0.01);
     }
 
@@ -660,7 +672,7 @@ public void testViaEdges_BiGraph() {
     public void testViaEdges_WithCoordinates() {
         GraphHopperStorage ghStorage = createTestStorage();
         Path p = calcPath(ghStorage, 0, 1, 2, 3);
-        assertEquals(IntArrayList.from(new int[]{8, 1, 2, 9}), p.calcNodes());
+        assertEquals(IntArrayList.from(8, 1, 2, 9), p.calcNodes());
         assertEquals(p.toString(), 56.7, p.getDistance(), .1);
     }
 
@@ -684,17 +696,17 @@ public void testViaEdges_SpecialCases() {
 
         // 0-1 to 3-4
         Path p = calcPathViaQuery(graph, 0.00010, 0.00001, 0, 0.00009);
-        assertEquals(IntArrayList.from(new int[]{5, 1, 2, 3, 6}), p.calcNodes());
+        assertEquals(IntArrayList.from(5, 1, 2, 3, 6), p.calcNodes());
         assertEquals(p.toString(), 26.81, p.getDistance(), .1);
 
         // overlapping edges: 2-3 and 3-2
         p = calcPathViaQuery(graph, 0.000049, 0.00014, 0.00001, 0.0001);
-        assertEquals(IntArrayList.from(new int[]{5, 6}), p.calcNodes());
+        assertEquals(IntArrayList.from(5, 6), p.calcNodes());
         assertEquals(p.toString(), 6.2, p.getDistance(), .1);
 
         // 'from' and 'to' edge share one node '2': 1-2 to 3-2
         p = calcPathViaQuery(graph, 0.00009, 0.00011, 0.00001, 0.00011);
-        assertEquals(p.toString(), IntArrayList.from(new int[]{6, 2, 5}), p.calcNodes());
+        assertEquals(p.toString(), IntArrayList.from(6, 2, 5), p.calcNodes());
         assertEquals(p.toString(), 12.57, p.getDistance(), .1);
     }
 
@@ -704,7 +716,7 @@ public void testQueryGraphAndFastest() {
         GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(weighting), false);
         initDirectedAndDiffSpeed(graph, carEncoder);
         Path p = calcPathViaQuery(weighting, graph, 0.002, 0.0005, 0.0017, 0.0031);
-        assertEquals(IntArrayList.from(new int[]{8, 1, 5, 3, 9}), p.calcNodes());
+        assertEquals(IntArrayList.from(8, 1, 5, 3, 9), p.calcNodes());
         assertEquals(602.98, p.getDistance(), 1e-1);
     }
 
@@ -762,13 +774,13 @@ QueryResult newQR(Graph graph, int node1, int node2) {
     @Test
     public void testTwoWeightsPerEdge() {
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
-        EncodingManager em = new EncodingManager(encoder);
+        EncodingManager em = EncodingManager.create(encoder);
         AlgorithmOptions opts = AlgorithmOptions.start().
                 weighting(new FastestWeighting(encoder)).build();
         GraphHopperStorage graph = createGHStorage(em, Arrays.asList(opts.getWeighting()), true);
         initEleGraph(graph);
         // force the other path
-        GHUtility.getEdge(graph, 0, 3).setFlags(encoder.setProperties(10, false, true));
+        GHUtility.setProperties(GHUtility.getEdge(graph, 0, 3), encoder, 10, false, true);
 
         // for two weights per edge it happened that Path (and also the Weighting) read the wrong side
         // of the speed and read 0 => infinity weight => overflow of millis => negative millis!
@@ -782,15 +794,19 @@ public void testTwoWeightsPerEdge() {
     @Test
     public void test0SpeedButUnblocked_Issue242() {
         GraphHopperStorage graph = createGHStorage(false);
-        long flags = carEncoder.setAccess(carEncoder.setSpeed(0, 0), true, true);
+        EdgeIteratorState edge01 = graph.edge(0, 1).setDistance(10);
+        EdgeIteratorState edge12 = graph.edge(1, 2).setDistance(10);
+        edge01.set(carAvSpeedEnc, 0.0).set(carAccessEnc, true).setReverse(carAccessEnc, true);
+        edge01.setFlags(edge01.getFlags());
+
+        edge12.set(carAvSpeedEnc, 0.0).set(carAccessEnc, true).setReverse(carAccessEnc, true);
+        edge12.setFlags(edge12.getFlags());
 
-        graph.edge(0, 1).setFlags(flags).setDistance(10);
-        graph.edge(1, 2).setFlags(flags).setDistance(10);
 
         RoutingAlgorithm algo = createAlgo(graph);
         try {
             Path p = algo.calcPath(0, 2);
-            assertTrue(false);
+            fail("there should have been an exception");
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Speed cannot be 0"));
         }
@@ -854,7 +870,7 @@ public String getName() {
         initEleGraph(graph);
         Path p = createAlgo(graph, opts).calcPath(0, 10);
         // GHUtility.printEdgeInfo(graph, carEncoder);
-        assertEquals(IntArrayList.from(new int[]{0, 4, 6, 10}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 4, 6, 10), p.calcNodes());
 
         AlgorithmOptions fakeOpts = AlgorithmOptions.start().weighting(fakeWeighting).build();
         graph = createGHStorage(encodingManager, Arrays.asList(fakeOpts.getWeighting()), true);
@@ -865,7 +881,7 @@ public String getName() {
         RoutingAlgorithmFactory factory = createFactory(graph, fakeOpts);
         QueryGraph qGraph = new QueryGraph(getGraph(graph, fakeWeighting)).lookup(from, to);
         p = factory.createAlgo(qGraph, fakeOpts).calcPath(from.getClosestNode(), to.getClosestNode());
-        assertEquals(IntArrayList.from(new int[]{12, 0, 1, 2, 11, 7, 10, 13}), p.calcNodes());
+        assertEquals(IntArrayList.from(12, 0, 1, 2, 11, 7, 10, 13), p.calcNodes());
         assertEquals(37009621, p.getTime());
         assertEquals(616827, p.getDistance(), 1);
         assertEquals(493462, p.getWeight(), 1);
@@ -886,7 +902,7 @@ public void testMultipleVehicles_issue548() {
         initFootVsCar(ghStorage);
 
         // normal path would be 0-4-6-7 but block 4-6
-        GHUtility.getEdge(ghStorage, 4, 6).setFlags(carEncoder.setProperties(20, false, false));
+        GHUtility.setProperties(GHUtility.getEdge(ghStorage, 4, 6), carEncoder, 20, false, false);
 
         RoutingAlgorithm algoFoot = createFactory(ghStorage, footOptions).
                 createAlgo(getGraph(ghStorage, footWeighting), footOptions);
@@ -894,7 +910,7 @@ public void testMultipleVehicles_issue548() {
         RoutingAlgorithm algoCar = createFactory(ghStorage, carOptions).
                 createAlgo(getGraph(ghStorage, carWeighting), carOptions);
         Path p1 = algoCar.calcPath(0, 7);
-        assertEquals(IntArrayList.from(new int[]{0, 1, 5, 6, 7}), p1.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 5, 6, 7), p1.calcNodes());
         assertEquals(p1.toString(), 26000, p1.getDistance(), 1e-6);
     }
 
@@ -943,4 +959,14 @@ Graph initEleGraph(Graph g) {
     protected GraphHopperStorage createMatrixGraph() {
         return createMatrixAlikeGraph(createGHStorage(false));
     }
+
+    private void assertPathFromEqualsTo(Path p, int node) {
+        assertTrue(p.isFound());
+        assertEquals(p.toString(), IntArrayList.from(node), p.calcNodes());
+        assertEquals(p.toString(), 1, p.calcPoints().size());
+        assertEquals(p.toString(), 0, p.calcEdges().size());
+        assertEquals(p.toString(), 0, p.getWeight(), 1e-4);
+        assertEquals(p.toString(), 0, p.getDistance(), 1e-4);
+        assertEquals(p.toString(), 0, p.getTime(), 1e-4);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
index c80f0eefad..3da0516de2 100644
--- a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
@@ -24,11 +24,9 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphExtension;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.*;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -43,7 +41,9 @@
 @RunWith(Parameterized.class)
 public class AlternativeRouteTest {
     private final FlagEncoder carFE = new CarFlagEncoder();
-    private final EncodingManager em = new EncodingManager(carFE);
+    private final EncodingManager em = EncodingManager.create(carFE);
+    private final TurnCostExtension turnCostExtension = new TurnCostExtension();
+    private final Weighting weighting = new TurnWeighting(new FastestWeighting(carFE), turnCostExtension);
     private final TraversalMode traversalMode;
 
     public AlternativeRouteTest(TraversalMode tMode) {
@@ -57,12 +57,12 @@ public AlternativeRouteTest(TraversalMode tMode) {
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
                 {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_2DIR}
+                {TraversalMode.EDGE_BASED}
         });
     }
 
     public GraphHopperStorage createTestGraph(boolean fullGraph, EncodingManager tmpEM) {
-        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(), tmpEM, false, new GraphExtension.NoOpExtension());
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(), tmpEM, false, turnCostExtension);
         graph.create(1000);
 
         /* 9
@@ -104,8 +104,7 @@ public GraphHopperStorage createTestGraph(boolean fullGraph, EncodingManager tmp
     }
 
     @Test
-    public void testCalcAlternatives() throws Exception {
-        Weighting weighting = new FastestWeighting(carFE);
+    public void testCalcAlternatives() {
         GraphHopperStorage g = createTestGraph(true, em);
         AlternativeRoute altDijkstra = new AlternativeRoute(g, weighting, traversalMode);
         altDijkstra.setMaxShareFactor(0.5);
@@ -123,18 +122,17 @@ public void testCalcAlternatives() throws Exception {
         assertEquals(bestPath.calcNodes(), bestAlt.calcNodes());
         assertEquals(bestPath.getWeight(), bestAlt.getWeight(), 1e-3);
 
-        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 4}), bestAlt.calcNodes());
+        assertEquals(IntArrayList.from(5, 6, 3, 4), bestAlt.calcNodes());
 
         // Note: here plateau is longer, even longer than optimum, but path is longer
         // so which alternative is better? longer plateau.weight with bigger path.weight or smaller path.weight with smaller plateau.weight
-        // assertEquals(Helper.createTList(5, 1, 9, 2, 3, 4), secondAlt.calcNodes());
-        assertEquals(IntArrayList.from(new int[]{5, 6, 7, 8, 4}), secondAlt.calcNodes());
+        // assertEquals(IntArrayList.from(5, 1, 9, 2, 3, 4), secondAlt.calcNodes());
+        assertEquals(IntArrayList.from(5, 6, 7, 8, 4), secondAlt.calcNodes());
         assertEquals(1667.9, secondAlt.getWeight(), .1);
     }
 
     @Test
-    public void testCalcAlternatives2() throws Exception {
-        Weighting weighting = new FastestWeighting(carFE);
+    public void testCalcAlternatives2() {
         Graph g = createTestGraph(true, em);
         AlternativeRoute altDijkstra = new AlternativeRoute(g, weighting, traversalMode);
         altDijkstra.setMaxPaths(3);
@@ -149,23 +147,23 @@ public void testCalcAlternatives2() throws Exception {
         assertEquals(3, pathInfos.size());
 
         // result is sorted based on the plateau to full weight ratio
-        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 4}), pathInfos.get(0).getPath().calcNodes());
-        assertEquals(IntArrayList.from(new int[]{5, 6, 7, 8, 4}), pathInfos.get(1).getPath().calcNodes());
-        assertEquals(IntArrayList.from(new int[]{5, 1, 9, 2, 3, 4}), pathInfos.get(2).getPath().calcNodes());
+        assertEquals(IntArrayList.from(5, 6, 3, 4), pathInfos.get(0).getPath().calcNodes());
+        assertEquals(IntArrayList.from(5, 6, 7, 8, 4), pathInfos.get(1).getPath().calcNodes());
+        assertEquals(IntArrayList.from(5, 1, 9, 2, 3, 4), pathInfos.get(2).getPath().calcNodes());
         assertEquals(2416.0, pathInfos.get(2).getPath().getWeight(), .1);
     }
 
-    void checkAlternatives(List<AlternativeRoute.AlternativeInfo> alternativeInfos) {
+    private void checkAlternatives(List<AlternativeRoute.AlternativeInfo> alternativeInfos) {
         assertFalse("alternativeInfos should contain alternatives", alternativeInfos.isEmpty());
         AlternativeRoute.AlternativeInfo bestInfo = alternativeInfos.get(0);
         for (int i = 1; i < alternativeInfos.size(); i++) {
             AlternativeRoute.AlternativeInfo a = alternativeInfos.get(i);
             if (a.getPath().getWeight() < bestInfo.getPath().getWeight())
-                assertTrue("alternative is not longer -> " + a + " vs " + bestInfo, false);
+                fail("alternative is not longer -> " + a + " vs " + bestInfo);
 
             if (a.getShareWeight() > bestInfo.getPath().getWeight()
                     || a.getShareWeight() > a.getPath().getWeight())
-                assertTrue("share or sortby incorrect -> " + a + " vs " + bestInfo, false);
+                fail("share or sortby incorrect -> " + a + " vs " + bestInfo);
         }
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java b/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
new file mode 100644
index 0000000000..af69fd51c7
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/CHQueryWithTurnCostsTest.java
@@ -0,0 +1,753 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.routing.ch.PreparationWeighting;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.LevelEdgeFilter;
+import com.graphhopper.routing.util.MotorcycleFlagEncoder;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+/**
+ * Tests the correctness of the contraction hierarchies query in the presence of turn costs.
+ * The graph preparation is done manually here and the tests try to focus on border cases that have to be covered
+ * by the query algorithm correctly.
+ */
+@RunWith(Parameterized.class)
+public class CHQueryWithTurnCostsTest {
+    private final int maxCost = 10;
+    private final FlagEncoder encoder = new MotorcycleFlagEncoder(5, 5, maxCost);
+    private final EncodingManager encodingManager = EncodingManager.create(encoder);
+    private final Weighting weighting = new ShortestWeighting(encoder);
+    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+    private final TurnCostExtension turnCostExtension = (TurnCostExtension) graph.getExtension();
+    private final CHGraph chGraph = graph.getCHGraph();
+    private String algoString;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static Object[] parameters() {
+        return new Object[]{"astar", "dijkstra"};
+    }
+
+    public CHQueryWithTurnCostsTest(String algoString) {
+        this.algoString = algoString;
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_bidirected_no_shortcuts_smallGraph() {
+        // some special cases where from=to, or start and target edges are the same
+        // 1 -- 0 -- 2
+        graph.edge(1, 0, 3, true);
+        graph.edge(0, 2, 5, true);
+        addTurnCost(1, 0, 2, 3);
+        graph.freeze();
+
+        // contraction yields no shortcuts for edge based case (at least without u-turns).
+        setLevelEqualToNodeIdForAllNodes();
+
+        for (int i = 0; i < 3; ++i) {
+            testPathCalculation(i, i, 0, IntArrayList.from(i));
+        }
+        testPathCalculation(1, 2, 8, IntArrayList.from(1, 0, 2), 3);
+        testPathCalculation(2, 1, 8, IntArrayList.from(2, 0, 1));
+        testPathCalculation(0, 1, 3, IntArrayList.from(0, 1));
+        testPathCalculation(0, 2, 5, IntArrayList.from(0, 2));
+        testPathCalculation(1, 0, 3, IntArrayList.from(1, 0));
+        testPathCalculation(2, 0, 5, IntArrayList.from(2, 0));
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_bidirected_no_shortcuts() {
+        // 0 -- 2 -- 4 -- 6 -- 5 -- 3 -- 1
+        graph.edge(0, 2, 3, true);
+        graph.edge(2, 4, 2, true);
+        graph.edge(4, 6, 7, true);
+        graph.edge(6, 5, 9, true);
+        graph.edge(5, 3, 1, true);
+        graph.edge(3, 1, 4, true);
+        addTurnCost(0, 2, 4, 3);
+        addTurnCost(4, 6, 5, 6);
+        addTurnCost(5, 6, 4, 2);
+        addTurnCost(5, 3, 1, 5);
+        graph.freeze();
+
+        // contraction yields no shortcuts
+        setLevelEqualToNodeIdForAllNodes();
+
+        // note that we are using the shortest weighting but turn cost times are included whatsoever, see #1590
+        testPathCalculation(0, 1, 26, IntArrayList.from(0, 2, 4, 6, 5, 3, 1), 14);
+        testPathCalculation(1, 0, 26, IntArrayList.from(1, 3, 5, 6, 4, 2, 0), 2);
+        testPathCalculation(4, 3, 17, IntArrayList.from(4, 6, 5, 3), 6);
+        testPathCalculation(0, 0, 0, IntArrayList.from(0));
+        testPathCalculation(4, 4, 0, IntArrayList.from(4));
+
+        // also check if distance and times (including turn costs) are calculated correctly
+        Path path = createAlgo().calcPath(0, 1);
+        assertEquals("wrong weight", 40, path.getWeight(), 1.e-3);
+        assertEquals("wrong distance", 26, path.getDistance(), 1.e-3);
+        double weightPerMeter = 0.06;
+        assertEquals("wrong time", (26 * weightPerMeter + 14) * 1000, path.getTime(), 1.e-3);
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_loopShortcutBwdSearch() {
+        // the loop shortcut 4-4 will be encountered during the bwd search
+        //             3
+        //            / \
+        //           1   2
+        //            \ /
+        // 0 - 7 - 8 - 4 - 6 - 5
+        graph.edge(0, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 6, 1, false);
+        graph.edge(6, 5, 1, false);
+        addRestriction(8, 4, 6);
+        addRestriction(8, 4, 2);
+        addRestriction(1, 4, 6);
+
+        graph.freeze();
+
+        // from contracting node 1
+        addShortcut(4, 3, 3, 4, 3, 4, 2);
+        // from contracting node 2
+        addShortcut(3, 4, 5, 6, 5, 6, 2);
+        // from contracting node 3
+        addShortcut(4, 4, 3, 6, 9, 10, 4);
+        // from contracting node 4
+        addShortcut(8, 4, 2, 6, 2, 11, 5);
+        addShortcut(8, 6, 2, 7, 12, 7, 6);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(0, 5, 9, IntArrayList.from(0, 7, 8, 4, 1, 3, 2, 4, 6, 5));
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_loopShortcutFwdSearch() {
+        // the loop shortcut 4-4 will be encountered during the fwd search
+        //         3
+        //        / \
+        //       1   2
+        //        \ /
+        // 5 - 6 - 4 - 7 - 8 - 0
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 0, 1, false);
+        addRestriction(6, 4, 7);
+        addRestriction(6, 4, 2);
+        addRestriction(1, 4, 7);
+        graph.freeze();
+
+        // from contracting node 1
+        addShortcut(4, 3, 2, 3, 2, 3, 2);
+        // from contracting node 2
+        addShortcut(3, 4, 4, 5, 4, 5, 2);
+        // from contracting node 3
+        addShortcut(4, 4, 2, 5, 9, 10, 4);
+        // from contracting node 4
+        addShortcut(6, 4, 1, 5, 1, 11, 5);
+        addShortcut(6, 7, 1, 6, 12, 6, 6);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(5, 0, 9, IntArrayList.from(5, 6, 4, 1, 3, 2, 4, 7, 8, 0));
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_directed_single_shortcut() {
+        //    2     3
+        //   /5\   /1\
+        //  /   \2/   \
+        // 1     0     4
+        graph.edge(1, 2, 4, false);
+        graph.edge(2, 0, 2, false);
+        graph.edge(0, 3, 3, false);
+        graph.edge(3, 4, 2, false);
+        addTurnCost(1, 2, 0, 5);
+        addTurnCost(2, 0, 3, 2);
+        addTurnCost(0, 3, 4, 1);
+        graph.freeze();
+
+        // only when node 0 is contracted a shortcut is added
+        addShortcut(2, 3, 1, 2, 1, 2, 7);
+        setLevelEqualToNodeIdForAllNodes();
+
+        // when we are searching a path to the highest level node, the backward search will not expand any edges
+        testPathCalculation(1, 4, 11, IntArrayList.from(1, 2, 0, 3, 4), 8);
+        testPathCalculation(2, 4, 7, IntArrayList.from(2, 0, 3, 4), 3);
+        testPathCalculation(0, 4, 5, IntArrayList.from(0, 3, 4), 1);
+
+        // when we search a path to or start the search from a low level node both forward and backward searches run
+        testPathCalculation(1, 0, 6, IntArrayList.from(1, 2, 0), 5);
+        testPathCalculation(0, 4, 5, IntArrayList.from(0, 3, 4), 1);
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_directed_single_shortcut_fwdSearchStopsQuickly() {
+        //     0
+        //    / \
+        // 1-3-s-2-4
+        graph.edge(1, 3, 2, false);
+        graph.edge(3, 0, 3, false);
+        graph.edge(0, 2, 1, false);
+        graph.edge(2, 4, 3, false);
+        graph.freeze();
+
+        addTurnCost(1, 3, 0, 2);
+        addTurnCost(0, 2, 4, 4);
+
+        // from contracting node 0
+        addShortcut(3, 2, 1, 2, 1, 2, 4);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(1, 4, 9, IntArrayList.from(1, 3, 0, 2, 4), 6);
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_directed_two_shortcuts() {
+        //    3     0
+        //   /5\   /1\
+        //  /   \2/   \
+        // 2     1     4
+        graph.edge(2, 3, 4, false);
+        graph.edge(3, 1, 2, false);
+        graph.edge(1, 0, 3, false);
+        graph.edge(0, 4, 2, false);
+        addTurnCost(2, 3, 1, 5);
+        addTurnCost(3, 1, 0, 2);
+        addTurnCost(1, 0, 4, 1);
+        graph.freeze();
+
+        // contraction of node 0 and 1 each yield a single shortcut
+        addShortcut(1, 4, 2, 3, 2, 3, 6);
+        addShortcut(3, 4, 1, 3, 1, 4, 10);
+        setLevelEqualToNodeIdForAllNodes();
+
+        // the turn costs have to be accounted for also when the shortcuts are used
+        testPathCalculation(2, 4, 11, IntArrayList.from(2, 3, 1, 0, 4), 8);
+        testPathCalculation(1, 4, 5, IntArrayList.from(1, 0, 4), 1);
+        testPathCalculation(2, 0, 9, IntArrayList.from(2, 3, 1, 0), 7);
+        testPathCalculation(3, 4, 7, IntArrayList.from(3, 1, 0, 4), 3);
+        testPathCalculation(2, 1, 6, IntArrayList.from(2, 3, 1), 5);
+    }
+
+    @Test
+    public void testFindPath_directConnectionIsNotTheBestPath() {
+        // this case is interesting because there is an expensive edge going from the source to the target directly
+        // 0 --------\
+        // |         |
+        // v         v
+        // 2 -> 3 -> 1
+        graph.edge(0, 2, 3, false);
+        graph.edge(2, 3, 2, false);
+        graph.edge(3, 1, 9, false);
+        graph.edge(0, 1, 50, false);
+        addTurnCost(2, 3, 1, 4);
+        graph.freeze();
+
+        // no shortcuts here
+        setLevelEqualToNodeIdForAllNodes();
+        testPathCalculation(0, 1, 14, IntArrayList.from(0, 2, 3, 1), 4);
+    }
+
+    @Test
+    public void testFindPath_upwardSearchRunsIntoTarget() {
+        // this case is interesting because one possible path runs from 0 to 4 directly (the backward search does not
+        // contribute anything in this case), but this path is not as good as the one via node 5
+        // 0 -> 1 -> 5
+        //      |    |
+        //      v    v
+        //      3 -> 4 -> 2
+        graph.edge(0, 1, 9, false);
+        graph.edge(1, 5, 2, false);
+        graph.edge(1, 3, 2, false);
+        graph.edge(3, 4, 4, false);
+        graph.edge(5, 4, 6, false);
+        graph.edge(4, 2, 3, false);
+        addTurnCost(1, 3, 4, 3);
+        graph.freeze();
+
+        // no shortcuts here
+        setLevelEqualToNodeIdForAllNodes();
+        testPathCalculation(0, 4, 17, IntArrayList.from(0, 1, 5, 4));
+    }
+
+    @Test
+    public void testFindPath_downwardSearchRunsIntoTarget() {
+        // 0 <- 1
+        //  \   ^
+        //   \  |
+        //    <-2<-3
+        graph.edge(1, 0, 9, false);
+        graph.edge(2, 0, 14, false);
+        graph.edge(2, 1, 2, false);
+        graph.edge(3, 2, 9, false);
+        graph.freeze();
+
+        //no shortcuts
+        setLevelEqualToNodeIdForAllNodes();
+        testPathCalculation(3, 0, 20, IntArrayList.from(3, 2, 1, 0));
+    }
+
+    @Test
+    public void testFindPath_incomingShortcut() {
+        // this test covers the case where an original edge and a shortcut have the same traversal id
+        // 0 -- 1
+        // | __/
+        // v/
+        // 3 -> 2
+        graph.edge(0, 1, 9, true);
+        graph.edge(0, 3, 14, false);
+        graph.edge(3, 2, 9, false);
+        graph.freeze();
+        addShortcut(1, 3, 0, 1, 0, 1, 23);
+        setLevelEqualToNodeIdForAllNodes();
+        testPathCalculation(0, 2, 23, IntArrayList.from(0, 3, 2));
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_fwdBwdSearchesMeetWithUTurn() {
+        //       3
+        //       |
+        // 0 --- 2 --- 1
+        graph.edge(0, 2, 1, false);
+        graph.edge(2, 3, 2, true);
+        graph.edge(2, 1, 3, false);
+        addRestriction(0, 2, 1);
+        addTurnCost(0, 2, 3, 5);
+        addTurnCost(2, 3, 2, 4);
+        addTurnCost(3, 2, 1, 7);
+        graph.freeze();
+
+        // contraction yields no shortcuts
+        setLevelEqualToNodeIdForAllNodes();
+
+        // without u-turns no path can be found
+        testPathCalculation(0, 1, -1, IntArrayList.from());
+    }
+
+    @Test
+    public void testFindPath_doNotMakeUTurn() {
+        // in this case there should be no u-turn at node A, but in principal it would be ok to take a shortcut from
+        // A to B
+        checkUTurnNotBeingUsed(false);
+    }
+
+    @Test
+    public void testFindPath_doNotMakeUTurn_toLowerLevelNode() {
+        // in this case it would be forbidden to take the shortcut from A to B because B has lower level than A and
+        // because we can not do a shortcut at node A. The optimization to not check the node levels in LevelEdgeFilter
+        // that relies on shortcuts to lower level nodes being disconnected can 'hide' a u-turn bug here.
+        checkUTurnNotBeingUsed(true);
+    }
+
+    private void checkUTurnNotBeingUsed(boolean toLowerLevelNode) {
+        //           A <- 1
+        //           |
+        // 2 <- B <- 3 <- 0
+        int nodeA = 4;
+        int nodeB = 5;
+        if (toLowerLevelNode) {
+            int tmp = nodeA;
+            nodeA = nodeB;
+            nodeB = tmp;
+        }
+        graph.edge(1, nodeA, 4, false);
+        graph.edge(0, 3, 4, false);
+        graph.edge(nodeB, 2, 1, false);
+        final EdgeIteratorState e3toB = graph.edge(3, nodeB, 2, false);
+        final EdgeIteratorState e3toA = graph.edge(3, nodeA, 1, true);
+        graph.freeze();
+        addRestriction(0, 3, nodeB);
+
+        // one shortcut when contracting node 3
+        addShortcut(nodeA, nodeB, e3toA.getEdge(), e3toB.getEdge(), e3toA.getEdge(), e3toB.getEdge(), 2);
+        setLevelEqualToNodeIdForAllNodes();
+
+        // without u-turns the only 'possible' path 0-3-A-3-B-2 is forbidden
+        testPathCalculation(0, 2, -1, IntArrayList.from());
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_loop() {
+        //       3\
+        //       |/
+        // 0 --- 2 --- 1
+        final EdgeIteratorState edge1 = graph.edge(0, 2, 4, false);
+        final EdgeIteratorState edge2 = graph.edge(2, 3, 1, true);
+        final EdgeIteratorState edge3 = graph.edge(3, 2, 7, false);
+        final EdgeIteratorState edge4 = graph.edge(2, 1, 3, false);
+        // need to specify edges explicitly because there are two edges between nodes 2 and 3
+        addRestriction(edge1, edge4, 2);
+        addTurnCost(edge1, edge2, 2, 3);
+        graph.freeze();
+
+        // no shortcuts
+        setLevelEqualToNodeIdForAllNodes();
+
+        // without u-turns we need to take the loop
+        testPathCalculation(0, 1, 15, IntArrayList.from(0, 2, 3, 2, 1), 3);
+
+        // additional check
+        testPathCalculation(3, 1, 4, IntArrayList.from(3, 2, 1));
+    }
+
+    @Test
+    public void testFindPathWithTurnCosts_multiple_bridge_nodes() {
+        //   --- 2 ---
+        //  /         \
+        // 0 --- 3 --- 1
+        //  \         /
+        //   --- 4 ---
+        graph.edge(0, 2, 1, false);
+        graph.edge(0, 3, 3, false);
+        graph.edge(0, 4, 2, false);
+        graph.edge(2, 1, 1, false);
+        graph.edge(3, 1, 2, false);
+        graph.edge(4, 1, 6, false);
+        addTurnCost(0, 2, 1, 9);
+        addTurnCost(0, 3, 1, 2);
+        addTurnCost(0, 4, 1, 1);
+        graph.freeze();
+
+        // contraction yields no shortcuts
+        setLevelEqualToNodeIdForAllNodes();
+
+        // going via 2, 3 and 4 is possible, but we want the shortest path taking into account turn costs also at
+        // the bridge node
+        testPathCalculation(0, 1, 5, IntArrayList.from(0, 3, 1), 2);
+    }
+
+    @Test
+    public void testFindPath_loopIsRecognizedAsIncomingEdge() {
+        //     ---
+        //     \ /
+        // 0 -- 3 -- 2 -- 1
+        EdgeIteratorState edge0 = graph.edge(0, 3, 1, true);
+        EdgeIteratorState edge1 = graph.edge(3, 3, 1, false);
+        EdgeIteratorState edge2 = graph.edge(3, 2, 1, true);
+        EdgeIteratorState edge3 = graph.edge(2, 1, 1, false);
+        addRestriction(edge0, edge2, 3);
+        graph.freeze();
+
+        // contraction yields no shortcuts
+        setLevelEqualToNodeIdForAllNodes();
+
+        // node 3 is the bridge node where both forward and backward searches meet. since there is a turn restriction
+        // at node 3 we cannot go from 0 to 2 directly, but we need to take the loop at 3 first. when the backward 
+        // search arrives at 3 it checks if 3 could be reached by the forward search and therefore its crucial that
+        // the ('forward') loop at 3 is recognized as an incoming edge at node 3
+        testPathCalculation(0, 1, 4, IntArrayList.from(0, 3, 3, 2, 1));
+    }
+
+    @Test
+    public void testFindPath_shortcutLoopIsRecognizedAsIncomingEdge() {
+        //          -0-
+        //          \ /
+        // 3 -- 4 -- 2 -- 1
+        EdgeIteratorState edge0 = graph.edge(3, 4, 1, true);
+        EdgeIteratorState edge1 = graph.edge(4, 2, 1, true);
+        EdgeIteratorState edge2 = graph.edge(2, 0, 1, false);
+        EdgeIteratorState edge3 = graph.edge(0, 2, 1, false);
+        EdgeIteratorState edge4 = graph.edge(2, 1, 1, false);
+        addRestriction(edge1, edge4, 2);
+        graph.freeze();
+
+        // contracting node 0 yields (the only) shortcut - and its a loop
+        addShortcut(2, 2, edge2.getEdge(), edge3.getEdge(), edge2.getEdge(), edge3.getEdge(), 2);
+        setLevelEqualToNodeIdForAllNodes();
+
+        // node 2 is the bridge node where the forward and backward searches meet (highest level). since there is a turn restriction
+        // at node 2 we cannot go from 4 to 1 directly, but we need to take the loop at 2 first. when the backward
+        // search arrives at 2 it is crucial that the ('forward') loop-shortcut at 2 is recognized as an incoming edge
+        // at node 2, otherwise the backward search ends at node 2. the forward search can never reach node 2 at all,
+        // because it never goes to a lower level. so when the backward search does not see the 'forward' loop shortcut
+        // no path between 3 and 1 will be found even though there is one.
+        testPathCalculation(3, 1, 5, IntArrayList.from(3, 4, 2, 0, 2, 1));
+    }
+
+    @Test
+    public void testFindPathWithTurnRestriction_single_loop() {
+        //     0
+        //     | \
+        //     |  >
+        // 3-> 4---1
+        //     |
+        //     v  no right turn at 4 when coming from 3!
+        //     2
+        graph.edge(3, 4, 2, false);
+        graph.edge(4, 0, 1, true);
+        graph.edge(0, 1, 3, false);
+        graph.edge(4, 1, 5, true);
+        graph.edge(4, 2, 4, false);
+        addRestriction(3, 4, 2);
+        graph.freeze();
+
+        // contracting node 0
+        addShortcut(4, 1, 1, 2, 1, 2, 4);
+        // contracting node 1
+        addShortcut(4, 4, 1, 3, 5, 3, 9);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(3, 2, 15, IntArrayList.from(3, 4, 0, 1, 4, 2));
+    }
+
+    @Test
+    public void testFindPath_singleLoopInFwdSearch() {
+        runTestWithSingleLoop(true);
+    }
+
+    @Test
+    public void testFindPath_singleLoopInBwdSearch() {
+        runTestWithSingleLoop(false);
+    }
+
+    private void runTestWithSingleLoop(boolean loopInFwdSearch) {
+        // because we set the node levels equal to the node ids, depending on the size relation between node A and B
+        // either the fwd search or the bwd search will explore the loop at node 5.
+        // in any case it is important that the fwd/bwd search unpacks the loop shortcut at node 5 correctly
+        int nodeA = 0;
+        int nodeB = 6;
+        if (!loopInFwdSearch) {
+            int tmp = nodeA;
+            nodeA = nodeB;
+            nodeB = tmp;
+        }
+        //  4 1<-3
+        //  | |  |
+        //  A-5->2
+        //    |
+        //    B-7
+        graph.edge(4, nodeA, 1, false);
+        graph.edge(nodeA, 5, 2, false);
+        graph.edge(5, 2, 2, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 1, 2, false);
+        graph.edge(1, 5, 1, false);
+        graph.edge(5, nodeB, 1, false);
+        graph.edge(nodeB, 7, 2, false);
+        addRestriction(nodeA, 5, nodeB);
+        graph.freeze();
+        addShortcut(3, 5, 4, 5, 4, 5, 3);
+        addShortcut(5, 3, 2, 3, 2, 3, 3);
+        addShortcut(5, 5, 2, 5, 9, 8, 6);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(4, 7, 12, IntArrayList.from(4, nodeA, 5, 2, 3, 1, 5, nodeB, 7));
+    }
+
+    @Test
+    public void testFindPathWithTurnRestriction_double_loop() {
+        //   1
+        //   |\  at 6 we can only take the next left turn (can not skip a turn or go right)
+        //   | \
+        //   0--6--2
+        //     / \ |
+        //     |  \|
+        // 4---7   3
+        //     |
+        //     |  no right turn at 7 when coming from 4 and no left turn at 7 when coming from 5!
+        //     5
+        final EdgeIteratorState e0to1 = graph.edge(0, 1, 2, true);
+        final EdgeIteratorState e1to6 = graph.edge(1, 6, 1, true);
+        final EdgeIteratorState e0to6 = graph.edge(0, 6, 4, true);
+        final EdgeIteratorState e2to6 = graph.edge(2, 6, 5, true);
+        final EdgeIteratorState e2to3 = graph.edge(2, 3, 3, true);
+        final EdgeIteratorState e3to6 = graph.edge(3, 6, 2, true);
+        final EdgeIteratorState e6to7 = graph.edge(7, 6, 1, true);
+        final EdgeIteratorState e4to7 = graph.edge(7, 4, 3, true);
+        final EdgeIteratorState e5to7 = graph.edge(7, 5, 2, true);
+
+        addRestriction(e6to7, e1to6, 6);
+        addRestriction(e6to7, e2to6, 6);
+        addRestriction(e6to7, e3to6, 6);
+        addRestriction(e1to6, e3to6, 6);
+        addRestriction(e1to6, e6to7, 6);
+        addRestriction(e1to6, e0to6, 6);
+
+        addRestriction(e4to7, e5to7, 7);
+        addRestriction(e5to7, e4to7, 7);
+        graph.freeze();
+
+        // contracting node 0 and 1
+        addShortcut(6, 1, 2, 0, 2, 0, 6);
+        addShortcut(6, 6, 2, 1, 9, 1, 7);
+        // contracting node 2 and 3
+        addShortcut(6, 3, 3, 4, 3, 4, 8);
+        addShortcut(6, 6, 3, 5, 11, 5, 10);
+        // contracting node 4 and 5 yields no shortcuts
+        // contracting node 6 --> three shortcuts to account for double loop (we nest shortcuts inside each other)
+        addShortcut(7, 6, 6, 1, 6, 10, 8);
+        addShortcut(7, 6, 6, 5, 13, 12, 18);
+        addShortcut(7, 7, 6, 6, 14, 6, 19);
+        setLevelEqualToNodeIdForAllNodes();
+
+        testPathCalculation(4, 5, 24, IntArrayList.from(4, 7, 6, 0, 1, 6, 2, 3, 6, 7, 5));
+        testPathCalculation(5, 4, 24, IntArrayList.from(5, 7, 6, 0, 1, 6, 2, 3, 6, 7, 4));
+    }
+
+    @Test
+    public void testFindPathWithTurnRestriction_two_different_loops() {
+        // 1
+        // | \
+        // ^  \
+        // |   |
+        // 0<- 5
+        //     | \
+        //     |  >
+        // 3-> 6---4
+        //     |
+        //     v  no right turn at 6 when coming from 3!
+        //     2
+        graph.edge(0, 1, 2, false);
+        graph.edge(1, 5, 1, true);
+        graph.edge(5, 0, 1, false);
+        graph.edge(5, 4, 5, false);
+        graph.edge(5, 6, 3, true);
+        graph.edge(6, 4, 4, true);
+
+        graph.edge(3, 6, 3, false);
+        graph.edge(6, 2, 4, false);
+        addRestriction(3, 6, 2);
+        graph.freeze();
+
+        // contracting node 0
+        addShortcut(5, 1, 2, 0, 2, 0, 3);
+        // contracting node 1
+        addShortcut(5, 5, 2, 1, 8, 1, 4);
+        // contracting node 2 & 3 does not yield any shortcuts
+        // contracting node 4
+        addShortcut(5, 6, 3, 5, 3, 5, 9);
+        // contracting node 5 --> two shortcuts to account for loop (we nest shortcuts inside each other)
+        addShortcut(6, 5, 4, 1, 4, 9, 7);
+        addShortcut(6, 6, 4, 4, 11, 4, 10);
+        // contracting node 6 --> no more shortcuts
+
+        setLevelEqualToNodeIdForAllNodes();
+
+        List<List<Integer>> distMatrix = Arrays.asList(
+                // -1 if no path is expected
+                Arrays.asList(0, 2, 10, -1, 8, 3, 6),
+                Arrays.asList(2, 0, 8, -1, 6, 1, 4),
+                Arrays.asList(-1, -1, 0, -1, -1, -1, -1),
+                Arrays.asList(7, 7, 17, 0, 7, 6, 3),
+                Arrays.asList(8, 8, 8, -1, 0, 7, 4),
+                Arrays.asList(1, 1, 7, -1, 5, 0, 3),
+                Arrays.asList(4, 4, 4, -1, 4, 3, 0));
+
+        for (int i = 0; i < distMatrix.size(); ++i) {
+            for (int j = 0; j < distMatrix.get(i).size(); ++j) {
+                testPathCalculation(i, j, distMatrix.get(i).get(j), null);
+            }
+        }
+    }
+
+    private void testPathCalculation(int from, int to, int expectedWeight, IntArrayList expectedNodes) {
+        testPathCalculation(from, to, expectedWeight, expectedNodes, 0);
+    }
+
+    private void testPathCalculation(int from, int to, int expectedEdgeWeight, IntArrayList expectedNodes, int expectedTurnCost) {
+        int expectedWeight = expectedEdgeWeight + expectedTurnCost;
+        int expectedDistance = expectedEdgeWeight;
+        int expectedTime = expectedEdgeWeight * 60 + expectedTurnCost * 1000;
+        AbstractBidirectionEdgeCHNoSOD algo = createAlgo();
+        Path path = algo.calcPath(from, to);
+        if (expectedWeight < 0) {
+            assertFalse(String.format(Locale.ROOT, "Unexpected path from %d to %d.", from, to), path.isFound());
+        } else {
+            if (expectedNodes != null) {
+                assertEquals(String.format(Locale.ROOT, "Unexpected path from %d to %d", from, to), expectedNodes, path.calcNodes());
+            }
+            assertEquals(String.format(Locale.ROOT, "Unexpected path weight from %d to %d", from, to), expectedWeight, path.getWeight(), 1.e-6);
+            assertEquals(String.format(Locale.ROOT, "Unexpected path distance from %d to %d", from, to), expectedDistance, path.getDistance(), 1.e-6);
+            assertEquals(String.format(Locale.ROOT, "Unexpected path time from %d to %d", from, to), expectedTime, path.getTime());
+        }
+    }
+
+    private AbstractBidirectionEdgeCHNoSOD createAlgo() {
+        TurnWeighting chTurnWeighting = new TurnWeighting(new PreparationWeighting(weighting), turnCostExtension);
+        AbstractBidirectionEdgeCHNoSOD algo = "astar".equals(algoString) ?
+                new AStarBidirectionEdgeCHNoSOD(chGraph, chTurnWeighting) :
+                new DijkstraBidirectionEdgeCHNoSOD(chGraph, chTurnWeighting);
+        algo.setEdgeFilter(new LevelEdgeFilter(chGraph));
+        return algo;
+    }
+
+    private void addShortcut(int from, int to, int firstOrigEdge, int lastOrigEdge, int skipped1, int skipped2, double weight) {
+        CHEdgeIteratorState shortcut = chGraph.shortcut(from, to);
+        // we need to set flags first because they overwrite weight etc
+        shortcut.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), weight);
+        shortcut.setFirstAndLastOrigEdges(firstOrigEdge, lastOrigEdge).setSkippedEdges(skipped1, skipped2);
+    }
+
+    private void setLevelEqualToNodeIdForAllNodes() {
+        for (int node = 0; node < chGraph.getNodes(); ++node) {
+            chGraph.setLevel(node, node);
+        }
+    }
+
+    private void addTurnCost(EdgeIteratorState edge1, EdgeIteratorState edge2, int viaNode, double costs) {
+        turnCostExtension.addTurnInfo(edge1.getEdge(), viaNode, edge2.getEdge(), encoder.getTurnFlags(false, costs));
+    }
+
+    private void addTurnCost(int from, int via, int to, int cost) {
+        addTurnCost(getEdge(from, via), getEdge(via, to), via, cost);
+    }
+
+    private void addRestriction(int from, int via, int to) {
+        addRestriction(getEdge(from, via), getEdge(via, to), via);
+    }
+
+    private void addRestriction(EdgeIteratorState edge1, EdgeIteratorState edge2, int viaNode) {
+        turnCostExtension.addTurnInfo(edge1.getEdge(), viaNode, edge2.getEdge(), encoder.getTurnFlags(true, 0));
+    }
+
+    private EdgeIteratorState getEdge(int from, int to) {
+        return GHUtility.getEdge(graph, from, to);
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
index 3be22f30f0..51b639a748 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionCHTest.java
@@ -18,7 +18,10 @@
 package com.graphhopper.routing;
 
 import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.routing.ch.NodeBasedNodeContractorTest;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
@@ -26,6 +29,7 @@
 import com.graphhopper.storage.*;
 import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Parameters;
 import org.junit.Test;
 
@@ -37,29 +41,27 @@
 /**
  * Tests if a graph optimized by contraction hierarchies returns the same results as a none
  * optimized one. Additionally fine grained path unpacking is tested.
- * <p>
  *
  * @author Peter Karich
  */
 public class DijkstraBidirectionCHTest extends AbstractRoutingAlgorithmTester {
     @Override
     protected CHGraph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
-        return ghStorage.getGraph(CHGraph.class, weighting);
+        return ghStorage.getCHGraph(weighting);
     }
 
     @Override
     protected GraphHopperStorage createGHStorage(EncodingManager em,
                                                  List<? extends Weighting> weightings, boolean is3D) {
-        return new GraphHopperStorage(weightings, new RAMDirectory(),
-                em, is3D, new GraphExtension.NoOpExtension()).
+        return new GraphHopperStorage(weightings, new RAMDirectory(), em, is3D, new GraphExtension.NoOpExtension()).
                 create(1000);
     }
 
     @Override
     public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                ghStorage, getGraph(ghStorage, opts.getWeighting()),
-                opts.getWeighting(), TraversalMode.NODE_BASED);
+        ghStorage.freeze();
+        PrepareContractionHierarchies ch = PrepareContractionHierarchies.fromGraphHopperStorage(
+                ghStorage, opts.getWeighting(), TraversalMode.NODE_BASED);
         ch.doWork();
         return ch;
     }
@@ -68,10 +70,10 @@ public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, Algor
     public void testPathRecursiveUnpacking() {
         // use an encoder where it is possible to store 2 weights per edge        
         FlagEncoder encoder = new Bike2WeightFlagEncoder();
-        EncodingManager em = new EncodingManager(encoder);
+        EncodingManager em = EncodingManager.create(encoder);
         ShortestWeighting weighting = new ShortestWeighting(encoder);
         GraphHopperStorage ghStorage = createGHStorage(em, Arrays.asList(weighting), false);
-        CHGraphImpl g2 = (CHGraphImpl) ghStorage.getGraph(CHGraph.class, weighting);
+        CHGraph g2 = ghStorage.getCHGraph(weighting);
         g2.edge(0, 1, 1, true);
         EdgeIteratorState iter1_1 = g2.edge(0, 2, 1.4, false);
         EdgeIteratorState iter1_2 = g2.edge(2, 5, 1.4, false);
@@ -85,15 +87,17 @@ public void testPathRecursiveUnpacking() {
         g2.edge(4, 6, 1, true);
         g2.edge(6, 7, 1, true);
         EdgeIteratorState iter2_2 = g2.edge(5, 7);
-        iter2_2.setDistance(1.4).setFlags(encoder.setProperties(10, true, false));
+        iter2_2.setDistance(1.4).setFlags(GHUtility.setProperties(em.createEdgeFlags(), encoder, 10, true, false));
 
         ghStorage.freeze();
         // simulate preparation
         CHEdgeIteratorState iter2_1 = g2.shortcut(0, 5);
-        iter2_1.setDistance(2.8).setFlags(encoder.setProperties(10, true, false));
+        iter2_1.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 1);
+        iter2_1.setDistance(2.8);
         iter2_1.setSkippedEdges(iter1_1.getEdge(), iter1_2.getEdge());
         CHEdgeIteratorState tmp = g2.shortcut(0, 7);
-        tmp.setDistance(4.2).setFlags(encoder.setProperties(10, true, false));
+        tmp.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 1);
+        tmp.setDistance(4.2);
         tmp.setSkippedEdges(iter2_1.getEdge(), iter2_2.getEdge());
         g2.setLevel(1, 0);
         g2.setLevel(3, 1);
@@ -105,8 +109,8 @@ public void testPathRecursiveUnpacking() {
         g2.setLevel(0, 7);
 
         AlgorithmOptions opts = new AlgorithmOptions(Parameters.Algorithms.DIJKSTRA_BI, weighting);
-        Path p = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                ghStorage, g2, weighting, TraversalMode.NODE_BASED).
+        Path p = new PrepareContractionHierarchies(
+                g2, weighting, TraversalMode.NODE_BASED).
                 createAlgo(g2, opts).calcPath(0, 7);
 
         assertEquals(IntArrayList.from(0, 2, 5, 7), p.calcNodes());
@@ -117,7 +121,7 @@ public void testPathRecursiveUnpacking() {
     @Test
     public void testBaseGraph() {
         CarFlagEncoder carFE = new CarFlagEncoder();
-        EncodingManager em = new EncodingManager(carFE);
+        EncodingManager em = EncodingManager.create(carFE);
         AlgorithmOptions opts = AlgorithmOptions.start().
                 weighting(new ShortestWeighting(carFE)).build();
         GraphHopperStorage ghStorage = createGHStorage(em,
@@ -191,7 +195,7 @@ public void testStallingNodesReducesNumberOfVisitedNodes() {
         }
         graph.edge(9, 0, 1, false);
         graph.edge(3, 9, 200, false);
-        CHGraph chGraph = graph.getGraph(CHGraph.class);
+        CHGraph chGraph = graph.getCHGraph();
 
         // explicitly set the node levels equal to the node ids
         // the graph contraction with this ordering yields no shortcuts
@@ -235,20 +239,18 @@ public void testDirectionDependentSpeedBwdSearch() {
         runTestWithDirectionDependentEdgeSpeed(20, 10, 2, 0, IntArrayList.from(2, 1, 0), new Bike2WeightFlagEncoder());
     }
 
-    private void runTestWithDirectionDependentEdgeSpeed(
-            int speed, int revSpeed, int from, int to, IntArrayList expectedPath, FlagEncoder encoder) {
-        EncodingManager encodingManager = new EncodingManager(encoder);
+    private void runTestWithDirectionDependentEdgeSpeed(double speed, double revSpeed, int from, int to, IntArrayList expectedPath, FlagEncoder encoder) {
+        EncodingManager encodingManager = EncodingManager.create(encoder);
         FastestWeighting weighting = new FastestWeighting(encoder);
         AlgorithmOptions algoOpts = AlgorithmOptions.start().weighting(weighting).build();
         GraphHopperStorage graph = createGHStorage(encodingManager, Arrays.asList(weighting), false);
         EdgeIteratorState edge = graph.edge(0, 1, 2, true);
-        long flags = edge.getFlags();
-        flags = encoder.setSpeed(flags, speed);
-        flags = encoder.setReverseSpeed(flags, revSpeed);
-        edge.setFlags(flags);
+        DecimalEncodedValue avSpeedEnc = encodingManager.getDecimalEncodedValue(EncodingManager.getKey(encoder, "average_speed"));
+        edge.set(avSpeedEnc, speed).setReverse(avSpeedEnc, revSpeed);
+
         graph.edge(1, 2, 1, true);
 
-        CHGraph chGraph = graph.getGraph(CHGraph.class);
+        CHGraph chGraph = graph.getCHGraph();
         for (int i = 0; i < 3; ++i) {
             chGraph.setLevel(i, i);
         }
@@ -261,8 +263,8 @@ private void runTestWithDirectionDependentEdgeSpeed(
     }
 
     private RoutingAlgorithm createCHAlgo(GraphHopperStorage graph, CHGraph chGraph, boolean withSOD, AlgorithmOptions algorithmOptions) {
-        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(new GHDirectory("", DAType.RAM_INT),
-                graph, chGraph, algorithmOptions.getWeighting(), TraversalMode.NODE_BASED);
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(
+                chGraph, algorithmOptions.getWeighting(), TraversalMode.NODE_BASED);
         if (!withSOD) {
             algorithmOptions.getHints().put("stall_on_demand", false);
         }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHTest.java
new file mode 100644
index 0000000000..5dc139b0e3
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionEdgeCHTest.java
@@ -0,0 +1,51 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+
+import java.util.Collections;
+import java.util.List;
+
+public class DijkstraBidirectionEdgeCHTest extends AbstractRoutingAlgorithmTester {
+    @Override
+    protected CHGraph getGraph(GraphHopperStorage ghStorage, Weighting weighting) {
+        return ghStorage.getCHGraph(weighting);
+    }
+
+    @Override
+    protected GraphHopperStorage createGHStorage(
+            EncodingManager em, List<? extends Weighting> weightings, boolean is3D) {
+        return new GraphHopperStorage(Collections.<Weighting>emptyList(), weightings, new RAMDirectory(),
+                em, is3D, new TurnCostExtension()).create(1000);
+    }
+
+    @Override
+    public RoutingAlgorithmFactory createFactory(GraphHopperStorage ghStorage, AlgorithmOptions opts) {
+        ghStorage.freeze();
+        PrepareContractionHierarchies ch = PrepareContractionHierarchies.fromGraphHopperStorage(
+                ghStorage, opts.getWeighting(), TraversalMode.EDGE_BASED);
+        ch.doWork();
+        return ch;
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
index 9667bd3617..b405cc9f4c 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraBidirectionRefTest.java
@@ -18,8 +18,11 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
@@ -33,9 +36,11 @@
 @RunWith(Parameterized.class)
 public class DijkstraBidirectionRefTest extends AbstractRoutingAlgorithmTester {
     private final TraversalMode traversalMode;
+    private final boolean allowUTurns;
 
-    public DijkstraBidirectionRefTest(TraversalMode tMode) {
+    public DijkstraBidirectionRefTest(TraversalMode tMode, boolean allowUTurns) {
         this.traversalMode = tMode;
+        this.allowUTurns = allowUTurns;
     }
 
     /**
@@ -44,10 +49,9 @@ public DijkstraBidirectionRefTest(TraversalMode tMode) {
     @Parameters(name = "{0}")
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
-                {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_1DIR},
-                {TraversalMode.EDGE_BASED_2DIR},
-                {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                {TraversalMode.NODE_BASED, false},
+                {TraversalMode.EDGE_BASED, false},
+                {TraversalMode.EDGE_BASED, true}
         });
     }
 
@@ -56,7 +60,12 @@ public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, Al
         return new RoutingAlgorithmFactory() {
             @Override
             public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
-                return new DijkstraBidirectionRef(g, opts.getWeighting(), traversalMode);
+                Weighting w = opts.getWeighting();
+                if (traversalMode.isEdgeBased()) {
+                    double uTurnCost = allowUTurns ? 40 : Double.POSITIVE_INFINITY;
+                    w = new TurnWeighting(w, (TurnCostExtension) g.getExtension(), uTurnCost);
+                }
+                return new DijkstraBidirectionRef(g, w, traversalMode);
             }
         };
     }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
index 5450a50d85..158867463a 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraOneToManyTest.java
@@ -55,9 +55,8 @@ public DijkstraOneToManyTest(TraversalMode tMode) {
         return Arrays.asList(new Object[][]{
                 {
                         TraversalMode.NODE_BASED
-                }, //            TODO { TraversalMode.EDGE_BASED_1DIR },
-                //            TODO { TraversalMode.EDGE_BASED_2DIR },
-                //            TODO { TraversalMode.EDGE_BASED_2DIR_UTURN }
+                },
+                //            TODO { TraversalMode.EDGE_BASED },
         });
     }
 
@@ -130,11 +129,11 @@ public void testIssue182() {
         initGraph(storage);
         RoutingAlgorithm algo = createAlgo(storage);
         Path p = algo.calcPath(0, 8);
-        assertEquals(IntArrayList.from(new int[]{0, 7, 8}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 7, 8), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 10);
-        assertEquals(IntArrayList.from(new int[]{0, 1, 2, 3, 4, 10}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 10), p.calcNodes());
     }
 
     @Test
@@ -160,15 +159,15 @@ public void testIssue239_and362() {
     public void testUseCache() {
         RoutingAlgorithm algo = createAlgo(createTestStorage());
         Path p = algo.calcPath(0, 4);
-        assertEquals(IntArrayList.from(new int[]{0, 4}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 4), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 7);
-        assertEquals(IntArrayList.from(new int[]{0, 4, 5, 7}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 4, 5, 7), p.calcNodes());
 
         // use SPT
         p = algo.calcPath(0, 2);
-        assertEquals(IntArrayList.from(new int[]{0, 1, 2}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 2), p.calcNodes());
     }
 
     @Test
@@ -188,7 +187,7 @@ public boolean accept(EdgeIteratorState iter) {
             }
         });
         Path p = algo.calcPath(4, 6);
-        assertEquals(IntArrayList.from(new int[]{4, 3, 6}), p.calcNodes());
+        assertEquals(IntArrayList.from(4, 3, 6), p.calcNodes());
 
         // important call!
         algo.clear();
@@ -199,7 +198,7 @@ public boolean accept(EdgeIteratorState iter) {
             }
         });
         p = algo.calcPath(4, 6);
-        assertEquals(IntArrayList.from(new int[]{4, 5, 6}), p.calcNodes());
+        assertEquals(IntArrayList.from(4, 5, 6), p.calcNodes());
     }
 
     private Graph initGraph(Graph g) {
@@ -241,18 +240,18 @@ public void testUseCacheZeroPath_issue707() {
         RoutingAlgorithm algo = createAlgo(createTestStorage());
 
         Path p = algo.calcPath(0, 0);
-        assertEquals(0, p.distance, 0.00000);
+        assertEquals(0, p.getDistance(), 0.00000);
 
         p = algo.calcPath(0, 4);
-        assertEquals(IntArrayList.from(new int[]{0, 4}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 4), p.calcNodes());
 
         // expand SPT
         p = algo.calcPath(0, 7);
-        assertEquals(IntArrayList.from(new int[]{0, 4, 5, 7}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 4, 5, 7), p.calcNodes());
 
         // use SPT
         p = algo.calcPath(0, 2);
-        assertEquals(IntArrayList.from(new int[]{0, 1, 2}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 2), p.calcNodes());
     }
 
 }
diff --git a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
index 29fec92015..0eee6f0cdb 100644
--- a/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
+++ b/core/src/test/java/com/graphhopper/routing/DijkstraTest.java
@@ -18,8 +18,11 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.TurnCostExtension;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
@@ -33,9 +36,11 @@
 @RunWith(Parameterized.class)
 public class DijkstraTest extends AbstractRoutingAlgorithmTester {
     private final TraversalMode traversalMode;
+    private final boolean allowUTurns;
 
-    public DijkstraTest(TraversalMode tMode) {
+    public DijkstraTest(TraversalMode tMode, boolean allowUTurns) {
         this.traversalMode = tMode;
+        this.allowUTurns = allowUTurns;
     }
 
     /**
@@ -44,10 +49,9 @@ public DijkstraTest(TraversalMode tMode) {
     @Parameters(name = "{0}")
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
-                {TraversalMode.NODE_BASED},
-                {TraversalMode.EDGE_BASED_1DIR},
-                {TraversalMode.EDGE_BASED_2DIR},
-                {TraversalMode.EDGE_BASED_2DIR_UTURN}
+                {TraversalMode.NODE_BASED, false},
+                {TraversalMode.EDGE_BASED, false},
+                {TraversalMode.EDGE_BASED, true}
         });
     }
 
@@ -56,7 +60,12 @@ public RoutingAlgorithmFactory createFactory(GraphHopperStorage prepareGraph, Al
         return new RoutingAlgorithmFactory() {
             @Override
             public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
-                return new Dijkstra(g, opts.getWeighting(), traversalMode);
+                Weighting w = opts.getWeighting();
+                if (traversalMode.isEdgeBased()) {
+                    double uTurnCost = allowUTurns ? 40 : Double.POSITIVE_INFINITY;
+                    w = new TurnWeighting(w, (TurnCostExtension) g.getExtension(), uTurnCost);
+                }
+                return new Dijkstra(g, w, traversalMode);
             }
         };
     }
diff --git a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
index e934b652d9..97b87e2de1 100644
--- a/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
+++ b/core/src/test/java/com/graphhopper/routing/EdgeBasedRoutingAlgorithmTest.java
@@ -19,7 +19,10 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.cursors.IntCursor;
-import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.routing.weighting.Weighting;
@@ -27,15 +30,16 @@
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.TurnCostExtension;
-import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
 
-import java.util.Arrays;
-import java.util.Collection;
+import java.util.*;
 
+import static com.graphhopper.routing.util.TraversalMode.EDGE_BASED;
 import static com.graphhopper.util.GHUtility.getEdge;
 import static com.graphhopper.util.Parameters.Algorithms.*;
 import static org.junit.Assert.*;
@@ -47,6 +51,7 @@
 public class EdgeBasedRoutingAlgorithmTest {
     private final String algoStr;
     private FlagEncoder carEncoder;
+    private TurnCostExtension tcs;
 
     public EdgeBasedRoutingAlgorithmTest(String algo) {
         this.algoStr = algo;
@@ -55,6 +60,8 @@ public EdgeBasedRoutingAlgorithmTest(String algo) {
     @Parameters(name = "{0}")
     public static Collection<Object[]> configs() {
         return Arrays.asList(new Object[][]{
+                // todo: make this test run also for edge-based CH or otherwise make sure time calculation is tested also for edge-based CH (at the moment it will fail!)
+                // todo: make this test run also for ALT or otherwise make sure time calculation is tested also for ALT (at the moment it will fail?!)
                 {DIJKSTRA},
                 {DIJKSTRA_BI},
                 {ASTAR},
@@ -81,13 +88,21 @@ public static void initGraph(Graph g) {
         g.edge(6, 7, 1, true);
     }
 
-    EncodingManager createEncodingManager(boolean restrictedOnly) {
+    private EncodingManager createEncodingManager(boolean restrictedOnly) {
         if (restrictedOnly)
             carEncoder = new CarFlagEncoder(5, 5, 1);
         else
             // allow for basic costs too
             carEncoder = new CarFlagEncoder(5, 5, 3);
-        return new EncodingManager(carEncoder);
+        return EncodingManager.create(carEncoder);
+    }
+
+    public Path calcPath(Graph g, int from, int to) {
+        return createAlgo(g, createWeighting(), EDGE_BASED).calcPath(from, to);
+    }
+
+    public RoutingAlgorithm createAlgo(Graph g, Weighting weighting, TraversalMode traversalMode) {
+        return createAlgo(g, AlgorithmOptions.start().weighting(weighting).traversalMode(traversalMode).build());
     }
 
     public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
@@ -95,96 +110,193 @@ public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
         return new RoutingAlgorithmFactorySimple().createAlgo(g, opts);
     }
 
-    protected GraphHopperStorage createStorage(EncodingManager em) {
-        return new GraphBuilder(em).create();
+    private GraphHopperStorage createStorage(EncodingManager em) {
+        GraphHopperStorage ghStorage = new GraphBuilder(em).create();
+        tcs = (TurnCostExtension) ghStorage.getExtension();
+        return ghStorage;
     }
 
-    private void initTurnRestrictions(Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder) {
-        long tflags = tEncoder.getTurnFlags(true, 0);
-
+    private void initTurnRestrictions(Graph g) {
         // only forward from 2-3 to 3-4 => limit 2,3->3,6 and 2,3->3,1
-        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
-        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
+        addTurnRestriction(g, 2, 3, 6);
+        addTurnRestriction(g, 2, 3, 1);
 
         // only right   from 5-2 to 2-3 => limit 5,2->2,0
-        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 0).getEdge(), tflags);
+        addTurnRestriction(g, 5, 2, 0);
 
         // only right   from 7-6 to 6-3 => limit 7,6->6,5
-        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
+        addTurnRestriction(g, 7, 6, 5);
 
         // no 5-6 to 6-3
-        tcs.addTurnInfo(getEdge(g, 5, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
+        addTurnRestriction(g, 5, 6, 3);
         // no 4-3 to 3-1
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), tflags);
+        addTurnRestriction(g, 4, 3, 1);
         // no 4-3 to 3-2
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), tflags);
+        addTurnRestriction(g, 4, 3, 2);
 
         // no u-turn at 6-7
-        tcs.addTurnInfo(getEdge(g, 6, 7).getEdge(), 7, getEdge(g, 7, 6).getEdge(), tflags);
+        addTurnRestriction(g, 6, 7, 6);
 
         // no u-turn at 3-6
-        tcs.addTurnInfo(getEdge(g, 3, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
+        addTurnRestriction(g, 3, 6, 3);
     }
 
-    Weighting createWeighting(FlagEncoder encoder, TurnCostExtension tcs, double uTurnCosts) {
-        return new TurnWeighting(new FastestWeighting(encoder), tcs).setDefaultUTurnCost(uTurnCosts);
+    private Weighting createWeighting() {
+        return createWeighting(carEncoder, Double.POSITIVE_INFINITY);
+    }
+
+    private Weighting createWeighting(FlagEncoder encoder, double uTurnCosts) {
+        return new TurnWeighting(new FastestWeighting(encoder), tcs, uTurnCosts);
+    }
+
+    @Test
+    public void testRandomGraph() {
+        long seed = System.nanoTime();
+        final int numQueries = 100;
+        Random rnd = new Random(seed);
+        GraphHopperStorage g = createStorage(createEncodingManager(false));
+        GHUtility.buildRandomGraph(g, rnd, 50, 2.2, true, true, carEncoder.getAverageSpeedEnc(), 0.8, 0.8, 0.8);
+        GHUtility.addRandomTurnCosts(g, seed, carEncoder, 3, tcs);
+        g.freeze();
+        int numPathsNotFound = 0;
+        // todo: reduce redundancy with RandomCHRoutingTest
+        List<String> strictViolations = new ArrayList<>();
+        for (int i = 0; i < numQueries; i++) {
+            int from = rnd.nextInt(g.getNodes());
+            int to = rnd.nextInt(g.getNodes());
+            Weighting w = createWeighting();
+            RoutingAlgorithm refAlgo = new Dijkstra(g, w, EDGE_BASED);
+            Path refPath = refAlgo.calcPath(from, to);
+            double refWeight = refPath.getWeight();
+            if (!refPath.isFound()) {
+                numPathsNotFound++;
+                continue;
+            }
+
+            Path path = calcPath(g, from, to);
+            if (!path.isFound()) {
+                fail("path not found for " + from + "->" + to + ", expected weight: " + refWeight);
+            }
+
+            double weight = path.getWeight();
+            if (Math.abs(refWeight - weight) > 1.e-2) {
+                System.out.println("expected: " + refPath.calcNodes());
+                System.out.println("given:    " + path.calcNodes());
+                fail("wrong weight: " + from + "->" + to + ", dijkstra: " + refWeight + " vs. " + algoStr + ": " + path.getWeight());
+            }
+            if (Math.abs(path.getDistance() - refPath.getDistance()) > 1.e-1) {
+                strictViolations.add("wrong distance " + from + "->" + to + ", expected: " + refPath.getDistance() + ", given: " + path.getDistance());
+            }
+            if (Math.abs(path.getTime() - refPath.getTime()) > 50) {
+                strictViolations.add("wrong time " + from + "->" + to + ", expected: " + refPath.getTime() + ", given: " + path.getTime());
+            }
+        }
+        if (numPathsNotFound > 0.9 * numQueries) {
+            fail("Too many paths not found: " + numPathsNotFound + "/" + numQueries);
+        }
+        if (strictViolations.size() > 0.05 * numQueries) {
+            fail("Too many strict violations: " + strictViolations.size() + "/" + numQueries + "\n" +
+                    Helper.join("\n", strictViolations));
+        }
     }
 
     @Test
     public void testBasicTurnRestriction() {
         GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
-        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
-        initTurnRestrictions(g, tcs, carEncoder);
-        Path p = createAlgo(g, AlgorithmOptions.start().
-                weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
-                calcPath(5, 1);
-        assertEquals(IntArrayList.from(new int[]{5, 2, 3, 4, 7, 6, 3, 1}), p.calcNodes());
+        initTurnRestrictions(g);
+        Path p = calcPath(g, 5, 1);
+        assertEquals(IntArrayList.from(5, 2, 3, 4, 7, 6, 3, 1), p.calcNodes());
 
         // test 7-6-5 and reverse
-        p = createAlgo(g, AlgorithmOptions.start().
-                weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
-                calcPath(5, 7);
-        assertEquals(IntArrayList.from(new int[]{5, 6, 7}), p.calcNodes());
-
-        p = createAlgo(g, AlgorithmOptions.start().
-                weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
-                calcPath(7, 5);
-        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 2, 5}), p.calcNodes());
+        p = calcPath(g, 5, 7);
+        assertEquals(IntArrayList.from(5, 6, 7), p.calcNodes());
+
+        p = calcPath(g, 7, 5);
+        assertEquals(IntArrayList.from(7, 6, 3, 2, 5), p.calcNodes());
+    }
+
+    @Test
+    public void testLoop_issue1592() {
+        GraphHopperStorage g = createStorage(createEncodingManager(true));
+        // 0-6
+        //  \ \
+        //   4-3
+        //   |
+        //   1o
+        g.edge(0, 6, 10, true);
+        g.edge(6, 3, 10, true);
+        g.edge(0, 4, 1, true);
+        g.edge(4, 1, 1, true);
+        g.edge(4, 3, 1, true);
+        g.edge(1, 1, 10, true);
+        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
+        addTurnRestriction(g, 0, 4, 3);
+
+        Path p = calcPath(g, 0, 3);
+        assertEquals(14, p.getDistance(), 1.e-3);
+        assertEquals(IntArrayList.from(0, 4, 1, 1, 4, 3), p.calcNodes());
+    }
+
+    @Test
+    public void testTurnCosts_timeCalculation() {
+        // 0 - 1 - 2 - 3 - 4
+        GraphHopperStorage g = createStorage(createEncodingManager(false));
+        final int distance = 100;
+        final int turnCosts = 2;
+        g.edge(0, 1, distance, true);
+        g.edge(1, 2, distance, true);
+        g.edge(2, 3, distance, true);
+        g.edge(3, 4, distance, true);
+        addTurnCost(g, turnCosts, 1, 2, 3);
+
+        {
+            // simple case where turn cost is encountered during forward search
+            Path p14 = calcPath(g, 1, 4);
+            assertDistTimeWeight(p14, 3, distance, 6, turnCosts);
+            assertEquals(20, p14.getWeight(), 1.e-6);
+            assertEquals(20000, p14.getTime());
+        }
+
+        {
+            // this test is more involved for bidir algos: the turn costs have to be taken into account also at the
+            // node where fwd and bwd searches meet
+            Path p04 = calcPath(g, 0, 4);
+            assertDistTimeWeight(p04, 4, distance, 6, turnCosts);
+            assertEquals(26, p04.getWeight(), 1.e-6);
+            assertEquals(26000, p04.getTime());
+        }
     }
 
+    private void assertDistTimeWeight(Path path, int numEdges, double distPerEdge, double weightPerEdge, int turnCost) {
+        assertEquals("wrong distance", numEdges * distPerEdge, path.getDistance(), 1.e-6);
+        assertEquals("wrong weight", numEdges * weightPerEdge + turnCost, path.getWeight(), 1.e-6);
+        assertEquals("wrong time", 1000 * (numEdges * weightPerEdge + turnCost), path.getTime(), 1.e-6);
+    }
 
-    private void blockNode3(Graph g, TurnCostExtension tcs, TurnCostEncoder tEncoder) {
+    private void blockNode3(Graph g) {
         // Totally block this node (all 9 turn relations)
-        final long BLOCK = tEncoder.getTurnFlags(true, 0);
-        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 2, 3).getEdge(), 3, getEdge(g, 3, 4).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 1).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 4).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 1, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 1, 3).getEdge(), 3, getEdge(g, 3, 2).getEdge(), BLOCK);
-        tcs.addTurnInfo(getEdge(g, 1, 3).getEdge(), 3, getEdge(g, 3, 4).getEdge(), BLOCK);
+        addTurnRestriction(g, 2, 3, 1);
+        addTurnRestriction(g, 2, 3, 4);
+        addTurnRestriction(g, 4, 3, 1);
+        addTurnRestriction(g, 4, 3, 2);
+        addTurnRestriction(g, 6, 3, 1);
+        addTurnRestriction(g, 6, 3, 4);
+        addTurnRestriction(g, 1, 3, 6);
+        addTurnRestriction(g, 1, 3, 2);
+        addTurnRestriction(g, 1, 3, 4);
     }
 
     @Test
     public void testBlockANode() {
         GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
-        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
-        blockNode3(g, tcs, carEncoder);
-        for (int i=0; i<=7; i++) {
-            if (i==3) continue;
-            for (int j=0; j<=7; j++) {
-                if (j==3) continue;
-                Path p = createAlgo(g, AlgorithmOptions.start().
-                        weighting(createWeighting(carEncoder, tcs, 40)).
-                        traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
-                        calcPath(i, j);
+        blockNode3(g);
+        for (int i = 0; i <= 7; i++) {
+            if (i == 3) continue;
+            for (int j = 0; j <= 7; j++) {
+                if (j == 3) continue;
+                Path p = calcPath(g, i, j);
                 assertTrue(p.isFound()); // We can go from everywhere to everywhere else without using node 3
                 for (IntCursor node : p.calcNodes()) {
                     assertNotEquals(p.calcNodes().toString(), 3, node.value);
@@ -197,89 +309,165 @@ public void testBlockANode() {
     public void testUTurns() {
         GraphHopperStorage g = createStorage(createEncodingManager(true));
         initGraph(g);
-        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
-
-        long tflags = carEncoder.getTurnFlags(true, 0);
 
-        // force u-turn via lowering the cost for it
-        EdgeIteratorState e3_6 = getEdge(g, 3, 6);
-        e3_6.setDistance(0.1);
+        // force u-turn at node 3 by using finite u-turn costs
+        getEdge(g, 3, 6).setDistance(0.1);
         getEdge(g, 3, 2).setDistance(864);
         getEdge(g, 1, 0).setDistance(864);
 
-        tcs.addTurnInfo(getEdge(g, 7, 6).getEdge(), 6, getEdge(g, 6, 5).getEdge(), tflags);
-        tcs.addTurnInfo(getEdge(g, 4, 3).getEdge(), 3, e3_6.getEdge(), tflags);
-        AlgorithmOptions opts = AlgorithmOptions.start().
-                weighting(createWeighting(carEncoder, tcs, 50)).
-                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
-        Path p = createAlgo(g, opts).calcPath(7, 5);
+        addTurnRestriction(g, 7, 6, 5);
+        addTurnRestriction(g, 4, 3, 6);
+        Path p = createAlgo(g, createWeighting(carEncoder, 50), EDGE_BASED).calcPath(7, 5);
 
-        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 6, 5}), p.calcNodes());
+        assertEquals(2 + 2 * 0.1, p.getDistance(), 1.e-6);
+        assertEquals(2.2 * 0.06 + 50, p.getWeight(), 1.e-6);
+        assertEquals((2.2 * 0.06 + 50) * 1000, p.getTime(), 1.e-6);
+        assertEquals(IntArrayList.from(7, 6, 3, 6, 5), p.calcNodes());
 
-        // no u-turn for 6-3
-        opts = AlgorithmOptions.start().
-                weighting(createWeighting(carEncoder, tcs, 100)).
-                traversalMode(TraversalMode.EDGE_BASED_2DIR_UTURN).build();
-        tcs.addTurnInfo(getEdge(g, 6, 3).getEdge(), 3, getEdge(g, 3, 6).getEdge(), tflags);
-        p = createAlgo(g, opts).calcPath(7, 5);
+        // with default infinite u-turn costs we need to take an expensive detour
+        p = calcPath(g, 7, 5);
+        assertEquals(1.1 + 864 + 0.5, p.getDistance(), 1.e-6);
+        assertEquals(865.6 * 0.06, p.getWeight(), 1.e-6);
+        assertEquals(IntArrayList.from(7, 6, 3, 2, 5), p.calcNodes());
 
-        assertEquals(IntArrayList.from(new int[]{7, 6, 3, 2, 5}), p.calcNodes());
+        // no more u-turn 6-3-6 -> now we have to take the expensive roads even with finite u-turn costs
+        addTurnRestriction(g, 6, 3, 6);
+        p = createAlgo(g, createWeighting(carEncoder, 100), EDGE_BASED).calcPath(7, 5);
+
+        assertEquals(1.1 + 864 + 0.5, p.getDistance(), 1.e-6);
+        assertEquals(865.6 * 0.06, p.getWeight(), 1.e-6);
+        assertEquals(IntArrayList.from(7, 6, 3, 2, 5), p.calcNodes());
+    }
+
+    @Test
+    public void uTurnCostAtMeetingNode() {
+        //           3
+        //           |
+        // 0 -> 1 -> 2 -> 4 -> 5
+        GraphHopperStorage g = createStorage(createEncodingManager(false));
+        g.edge(0, 1, 10, false);
+        g.edge(1, 2, 10, false);
+        g.edge(2, 3, 10, true);
+        g.edge(2, 4, 10, false);
+        g.edge(4, 5, 10, false);
+
+        // cannot go straight at node 2
+        addTurnRestriction(g, 1, 2, 4);
+
+        // with default/infinite u-turn costs there is no shortest path
+        {
+            Path path = calcPath(g, 0, 5);
+            assertFalse(path.isFound());
+        }
+
+        // with finite u-turn costs it is possible, the u-turn costs should be included
+        // here we make sure the default u-turn time is also included at the meeting node for bidir algos
+        {
+            Path path = createAlgo(g, createWeighting(carEncoder, 67), EDGE_BASED).calcPath(0, 5);
+            assertEquals(60, path.getDistance(), 1.e-6);
+            assertEquals(60 * 0.06 + 67, path.getWeight(), 1.e-6);
+            assertEquals((36 + 670) * 100, path.getTime(), 1.e-6);
+        }
     }
 
     @Test
     public void testBasicTurnCosts() {
         GraphHopperStorage g = createStorage(createEncodingManager(false));
         initGraph(g);
-        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
-        Path p = createAlgo(g, AlgorithmOptions.start().
-                weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
-                calcPath(5, 1);
+        Path p = calcPath(g, 5, 1);
 
         // no restriction and costs
-        EdgeIteratorState e3_6 = getEdge(g, 5, 6);
-        e3_6.setDistance(2);
-        assertEquals(IntArrayList.from(new int[]{5, 2, 3, 1}), p.calcNodes());
+        assertEquals(IntArrayList.from(5, 2, 3, 1), p.calcNodes());
 
         // now introduce some turn costs
-        long tflags = carEncoder.getTurnFlags(false, 2);
-        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
-
-        p = createAlgo(g, AlgorithmOptions.start().
-                weighting(createWeighting(carEncoder, tcs, 40)).
-                traversalMode(TraversalMode.EDGE_BASED_1DIR).build()).
-                calcPath(5, 1);
-        assertEquals(IntArrayList.from(new int[]{5, 6, 3, 1}), p.calcNodes());
+        getEdge(g, 5, 6).setDistance(2);
+        addTurnCost(g, 2, 5, 2, 3);
+
+        p = calcPath(g, 5, 1);
+        assertEquals(IntArrayList.from(5, 6, 3, 1), p.calcNodes());
     }
 
     @Test
     public void testTurnCostsBug_991() {
         final GraphHopperStorage g = createStorage(createEncodingManager(false));
         initGraph(g);
-        TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
 
-        long tflags = carEncoder.getTurnFlags(false, 2);
-        tcs.addTurnInfo(getEdge(g, 5, 2).getEdge(), 2, getEdge(g, 2, 3).getEdge(), tflags);
-        tcs.addTurnInfo(getEdge(g, 2, 0).getEdge(), 0, getEdge(g, 0, 1).getEdge(), tflags);
-        tcs.addTurnInfo(getEdge(g, 5, 6).getEdge(), 6, getEdge(g, 6, 3).getEdge(), tflags);
-
-        tflags = carEncoder.getTurnFlags(false, 1);
-        tcs.addTurnInfo(getEdge(g, 6, 7).getEdge(), 7, getEdge(g, 7, 4).getEdge(), tflags);
-
-        Path p = createAlgo(g, AlgorithmOptions.start().
-                weighting(new TurnWeighting(new FastestWeighting(carEncoder), tcs) {
-                    @Override
-                    public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
-                        if (edgeFrom >= 0)
-                            assertNotNull("edge " + edgeFrom + " to " + nodeVia + " does not exist", g.getEdgeIteratorState(edgeFrom, nodeVia));
-                        if (edgeTo >= 0)
-                            assertNotNull("edge " + edgeTo + " to " + nodeVia + " does not exist", g.getEdgeIteratorState(edgeTo, nodeVia));
-                        return super.calcTurnWeight(edgeFrom, nodeVia, edgeTo);
-                    }
-                }.setDefaultUTurnCost(40)).
-                traversalMode(TraversalMode.EDGE_BASED_2DIR).build()).
-                calcPath(5, 1);
-        assertEquals(IntArrayList.from(new int[]{5, 6, 7, 4, 3, 1}), p.calcNodes());
-        assertEquals(301, p.getTime(), .1);
+        addTurnCost(g, 2, 5, 2, 3);
+        addTurnCost(g, 2, 2, 0, 1);
+        addTurnCost(g, 2, 5, 6, 3);
+        addTurnCost(g, 1, 6, 7, 4);
+
+        TurnWeighting weighting = new TurnWeighting(new FastestWeighting(carEncoder), tcs) {
+            @Override
+            public double calcTurnWeight(int edgeFrom, int nodeVia, int edgeTo) {
+                if (edgeFrom >= 0)
+                    assertNotNull("edge " + edgeFrom + " to " + nodeVia + " does not exist", g.getEdgeIteratorState(edgeFrom, nodeVia));
+                if (edgeTo >= 0)
+                    assertNotNull("edge " + edgeTo + " to " + nodeVia + " does not exist", g.getEdgeIteratorState(edgeTo, nodeVia));
+                return super.calcTurnWeight(edgeFrom, nodeVia, edgeTo);
+            }
+        };
+        Path p = createAlgo(g, weighting, EDGE_BASED).calcPath(5, 1);
+        assertEquals(IntArrayList.from(5, 6, 7, 4, 3, 1), p.calcNodes());
+        assertEquals(5 * 0.06 + 1, p.getWeight(), 1.e-6);
+        assertEquals(1300, p.getTime(), .1);
+    }
+
+    @Test
+    public void testLoopEdge() {
+        //   o
+        // 3-2-4
+        //  \|
+        //   0
+        final GraphHopperStorage g = createStorage(createEncodingManager(false));
+        g.edge(3, 2, 188, false);
+        g.edge(3, 0, 182, true);
+        g.edge(4, 2, 690, true);
+        g.edge(2, 2, 121, false);
+        g.edge(2, 0, 132, true);
+        addTurnRestriction(g, 2, 2, 0);
+        addTurnRestriction(g, 3, 2, 4);
+
+        Path p = calcPath(g, 3, 4);
+        assertEquals(IntArrayList.from(3, 2, 2, 4), p.calcNodes());
+        assertEquals(999, p.getDistance(), 1.e-3);
+    }
+
+    @Test
+    public void testDoubleLoopPTurn() {
+        // we cannot go 1-4-5, but taking the loop at 4 is cheaper than taking the one at 3
+        //  0-1
+        //    |
+        // o3-4o
+        //    |
+        //    5
+        final GraphHopperStorage g = createStorage(createEncodingManager(false));
+        g.edge(0, 1, 1, true);
+        g.edge(3, 4, 2, true);
+        g.edge(4, 4, 4, true);
+        g.edge(3, 3, 1, true);
+        g.edge(1, 4, 5, true);
+        g.edge(5, 4, 1, true);
+        addTurnRestriction(g, 1, 4, 5);
+
+        Path p = calcPath(g, 0, 5);
+        assertEquals(IntArrayList.from(0, 1, 4, 4, 5), p.calcNodes());
+        assertEquals(11, p.getDistance(), 1.e-3);
+        assertEquals(11 * 0.06, p.getWeight(), 1.e-3);
+        assertEquals(11 * 0.06 * 1000, p.getTime(), 1.e-3);
+    }
+
+    private void addTurnRestriction(Graph g, int from, int via, int to) {
+        long turnFlags = carEncoder.getTurnFlags(true, 0);
+        addTurnFlags(g, from, via, to, turnFlags);
+    }
+
+    private void addTurnCost(Graph g, double costs, int from, int via, int to) {
+        long turnFlags = carEncoder.getTurnFlags(false, costs);
+        addTurnFlags(g, from, via, to, turnFlags);
+    }
+
+    private void addTurnFlags(Graph g, int from, int via, int to, long turnFlags) {
+        tcs.addTurnInfo(getEdge(g, from, via).getEdge(), via, getEdge(g, via, to).getEdge(), turnFlags);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
index 53350d752f..6ee7677a52 100644
--- a/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathBidirRefTest.java
@@ -18,15 +18,15 @@
 package com.graphhopper.routing;
 
 import com.carrotsearch.hppc.IntArrayList;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.SPTEntry;
-import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.storage.TurnCostExtension;
 import com.graphhopper.util.EdgeIterator;
 import org.junit.Test;
 
@@ -36,9 +36,8 @@
  * @author Peter Karich
  */
 public class PathBidirRefTest {
-    private final EncodingManager encodingManager = new EncodingManager("car");
-    private FlagEncoder carEncoder = encodingManager.getEncoder("car");
-    private EdgeFilter carOutEdges = DefaultEdgeFilter.outEdges(carEncoder);
+    private FlagEncoder carEncoder = new CarFlagEncoder(5, 5, 10);
+    private final EncodingManager encodingManager = EncodingManager.create(carEncoder);
 
     Graph createGraph() {
         return new GraphBuilder(encodingManager).create();
@@ -48,37 +47,38 @@ Graph createGraph() {
     public void testExtract() {
         Graph g = createGraph();
         g.edge(1, 2, 10, true);
-        PathBidirRef pw = new PathBidirRef(g, new FastestWeighting(carEncoder));
-        EdgeExplorer explorer = g.createEdgeExplorer(carOutEdges);
-        EdgeIterator iter = explorer.setBaseNode(1);
-        iter.next();
-        pw.sptEntry = new SPTEntry(iter.getEdge(), 2, 0);
-        pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
-        pw.edgeTo = new SPTEntry(EdgeIterator.NO_EDGE, 2, 0);
-        Path p = pw.extract();
-        assertEquals(IntArrayList.from(new int[]{1, 2}), p.calcNodes());
+        PathBidirRef p = new PathBidirRef(g, new FastestWeighting(carEncoder));
+        p.sptEntry = new SPTEntry(0, 2, 0);
+        p.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 10);
+        p.edgeTo = new SPTEntry(EdgeIterator.NO_EDGE, 2, 0);
+        p.extract();
+        assertEquals(IntArrayList.from(1, 2), p.calcNodes());
         assertEquals(10, p.getDistance(), 1e-4);
     }
 
     @Test
     public void testExtract2() {
+        // 1->2->3
         Graph g = createGraph();
         g.edge(1, 2, 10, false);
         g.edge(2, 3, 20, false);
-        EdgeExplorer explorer = g.createEdgeExplorer(carOutEdges);
-        EdgeIterator iter = explorer.setBaseNode(1);
-        iter.next();
-        PathBidirRef pw = new PathBidirRef(g, new FastestWeighting(carEncoder));
-        pw.sptEntry = new SPTEntry(iter.getEdge(), 2, 10);
-        pw.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
+        // add some turn costs at node 2 where fwd&bwd searches meet. these costs have to be included in the
+        // weight and the time of the path
+        TurnCostExtension turnCostExtension = (TurnCostExtension) g.getExtension();
+        turnCostExtension.addTurnInfo(0, 2, 1, carEncoder.getTurnFlags(false, 5));
 
-        explorer = g.createEdgeExplorer(DefaultEdgeFilter.inEdges(carEncoder));
-        iter = explorer.setBaseNode(3);
-        iter.next();
-        pw.edgeTo = new SPTEntry(iter.getEdge(), 2, 20);
-        pw.edgeTo.parent = new SPTEntry(EdgeIterator.NO_EDGE, 3, 0);
-        Path p = pw.extract();
-        assertEquals(IntArrayList.from(new int[]{1, 2, 3}), p.calcNodes());
+        PathBidirRef p = new PathBidirRef(g, new TurnWeighting(new FastestWeighting(carEncoder), turnCostExtension));
+        p.sptEntry = new SPTEntry(0, 2, 0.6);
+        p.sptEntry.parent = new SPTEntry(EdgeIterator.NO_EDGE, 1, 0);
+
+        p.edgeTo = new SPTEntry(1, 2, 1.2);
+        p.edgeTo.parent = new SPTEntry(EdgeIterator.NO_EDGE, 3, 0);
+        p.setWeight(5 + 1.8);
+
+        p.extract();
+        assertEquals(IntArrayList.from(1, 2, 3), p.calcNodes());
         assertEquals(30, p.getDistance(), 1e-4);
+        assertEquals(5 + 1.8, p.getWeight(), 1e-4);
+        assertEquals(5000 + 1800, p.getTime(), 1.e-6);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 9c8df060dd..f816aa4ded 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -18,6 +18,9 @@
 package com.graphhopper.routing;
 
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.Roundabout;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.GenericWeighting;
@@ -31,7 +34,7 @@
 import java.util.*;
 
 import static com.graphhopper.storage.AbstractGraphStorageTester.assertPList;
-import static com.graphhopper.util.Parameters.DETAILS.*;
+import static com.graphhopper.util.Parameters.Details.*;
 import static org.junit.Assert.*;
 
 /**
@@ -40,9 +43,13 @@
 public class PathTest {
     private final FlagEncoder encoder = new CarFlagEncoder();
     private final DataFlagEncoder dataFlagEncoder = new DataFlagEncoder();
-    private final EncodingManager carManager = new EncodingManager(encoder);
-    private final EncodingManager dataFlagManager = new EncodingManager(dataFlagEncoder);
-    private final EncodingManager mixedEncoders = new EncodingManager(new CarFlagEncoder());
+    private final EncodingManager carManager = EncodingManager.create(encoder);
+    private final BooleanEncodedValue carManagerRoundabout = carManager.getBooleanEncodedValue(Roundabout.KEY);
+    private final BooleanEncodedValue carAccessEnc = encoder.getAccessEnc();
+    private final DecimalEncodedValue carAvSpeedEnv = encoder.getAverageSpeedEnc();
+    private final EncodingManager dataFlagManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(4)).add(dataFlagEncoder).build();
+    private final EncodingManager mixedEncoders = EncodingManager.create(new CarFlagEncoder(), new FootFlagEncoder());
+    private final BooleanEncodedValue mixedManagerRoundabout = mixedEncoders.getBooleanEncodedValue(Roundabout.KEY);
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
     private final RoundaboutGraph roundaboutGraph = new RoundaboutGraph();
@@ -66,9 +73,10 @@ public void testWayList() {
         na.setNode(1, 1.0, 0.1);
         na.setNode(2, 2.0, 0.1);
 
-        EdgeIteratorState edge1 = g.edge(0, 1).setDistance(1000).setFlags(encoder.setProperties(10, true, true));
+        EdgeIteratorState edge1 = g.edge(0, 1).setDistance(1000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 10.0);
+
         edge1.setWayGeometry(Helper.createPointList(8, 1, 9, 1));
-        EdgeIteratorState edge2 = g.edge(2, 1).setDistance(2000).setFlags(encoder.setProperties(50, true, true));
+        EdgeIteratorState edge2 = g.edge(2, 1).setDistance(2000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
         edge2.setWayGeometry(Helper.createPointList(11, 1, 10, 1));
 
         Path path = new Path(g, new FastestWeighting(encoder));
@@ -79,26 +87,34 @@ public void testWayList() {
         path.extract();
         // 0-1-2
         assertPList(Helper.createPointList(0, 0.1, 8, 1, 9, 1, 1, 0.1, 10, 1, 11, 1, 2, 0.1), path.calcPoints());
-        InstructionList instr = path.calcInstructions(tr);
-        List<Map<String, Object>> res = instr.createJson();
-        Map<String, Object> tmp = res.get(0);
-        assertEquals(3000.0, tmp.get("distance"));
-        assertEquals(504000L, tmp.get("time"));
-        assertEquals("Continue", tmp.get("text"));
-        assertEquals("[0, 6]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(0.0, tmp.get("distance"));
-        assertEquals(0L, tmp.get("time"));
-        assertEquals("Arrive at destination", tmp.get("text"));
-        assertEquals("[6, 6]", tmp.get("interval").toString());
-        int lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+        InstructionList instr = path.calcInstructions(carManagerRoundabout, tr);
+        Instruction tmp = instr.get(0);
+        assertEquals(3000.0, tmp.getDistance(), 0.0);
+        assertEquals(504000L, tmp.getTime());
+        assertEquals("continue", tmp.getTurnDescription(tr));
+//        assertEquals("[0, 6]", tmp.get("interval").toString());
+        assertEquals(6, tmp.getLength());
+//        System.out.println(tmp.getPoints());
+
+
+        tmp = instr.get(1);
+        assertEquals(0.0, tmp.getDistance(), 0.0);
+        assertEquals(0L, tmp.getTime());
+        assertEquals("arrive at destination", tmp.getTurnDescription(tr));
+//        assertEquals("[6, 6]", tmp.get("interval").toString());
+        assertEquals(0, tmp.getLength());
+//        System.out.println(tmp.getPoints());
+
+        int acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
 
         // force minor change for instructions
         edge2.setName("2");
         na.setNode(3, 1.0, 1.0);
-        EdgeIteratorState edge3 = g.edge(1, 3).setDistance(1000).setFlags(encoder.setProperties(10, true, true));
+        g.edge(1, 3).setDistance(1000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 10.0);
 
         path = new Path(g, new FastestWeighting(encoder));
         e1 = new SPTEntry(edge2.getEdge(), 2, 1);
@@ -106,22 +122,24 @@ public void testWayList() {
         e1.parent.parent = new SPTEntry(-1, 0, 1);
         path.setSPTEntry(e1);
         path.extract();
-        instr = path.calcInstructions(tr);
-        res = instr.createJson();
-
-        tmp = res.get(0);
-        assertEquals(1000.0, tmp.get("distance"));
-        assertEquals(360000L, tmp.get("time"));
-        assertEquals("Continue", tmp.get("text"));
-        assertEquals("[0, 3]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(2000.0, tmp.get("distance"));
-        assertEquals(144000L, tmp.get("time"));
-        assertEquals("Turn sharp right onto 2", tmp.get("text"));
-        assertEquals("[3, 6]", tmp.get("interval").toString());
-        lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+        instr = path.calcInstructions(carManagerRoundabout, tr);
+
+        tmp = instr.get(0);
+        assertEquals(1000.0, tmp.getDistance(), 0);
+        assertEquals(360000L, tmp.getTime());
+        assertEquals("continue", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+
+        tmp = instr.get(1);
+        assertEquals(2000.0, tmp.getDistance(), 0);
+        assertEquals(144000L, tmp.getTime());
+        assertEquals("turn sharp right onto 2", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+        acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
 
         // now reverse order
         path = new Path(g, new FastestWeighting(encoder));
@@ -133,21 +151,23 @@ public void testWayList() {
         // 2-1-0
         assertPList(Helper.createPointList(2, 0.1, 11, 1, 10, 1, 1, 0.1, 9, 1, 8, 1, 0, 0.1), path.calcPoints());
 
-        instr = path.calcInstructions(tr);
-        res = instr.createJson();
-        tmp = res.get(0);
-        assertEquals(2000.0, tmp.get("distance"));
-        assertEquals(144000L, tmp.get("time"));
-        assertEquals("Continue onto 2", tmp.get("text"));
-        assertEquals("[0, 3]", tmp.get("interval").toString());
-
-        tmp = res.get(1);
-        assertEquals(1000.0, tmp.get("distance"));
-        assertEquals(360000L, tmp.get("time"));
-        assertEquals("Turn sharp left", tmp.get("text"));
-        assertEquals("[3, 6]", tmp.get("interval").toString());
-        lastIndex = (Integer) ((List) res.get(res.size() - 1).get("interval")).get(0);
-        assertEquals(path.calcPoints().size() - 1, lastIndex);
+        instr = path.calcInstructions(carManagerRoundabout, tr);
+        tmp = instr.get(0);
+        assertEquals(2000.0, tmp.getDistance(), 0);
+        assertEquals(144000L, tmp.getTime());
+        assertEquals("continue onto 2", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+
+        tmp = instr.get(1);
+        assertEquals(1000.0, tmp.getDistance(), 0);
+        assertEquals(360000L, tmp.getTime());
+        assertEquals("turn sharp left", tmp.getTurnDescription(tr));
+        assertEquals(3, tmp.getLength());
+        acc = 0;
+        for (Instruction instruction : instr) {
+            acc += instruction.getLength();
+        }
+        assertEquals(path.calcPoints().size() - 1, acc);
     }
 
     @Test
@@ -162,22 +182,22 @@ public void testFindInstruction() {
         na.setNode(5, 5.0, 1.0);
 
 
-        EdgeIteratorState edge1 = g.edge(0, 1).setDistance(1000).setFlags(encoder.setProperties(50, true, true));
+        EdgeIteratorState edge1 = g.edge(0, 1).setDistance(1000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
         edge1.setWayGeometry(Helper.createPointList());
         edge1.setName("Street 1");
-        EdgeIteratorState edge2 = g.edge(1, 2).setDistance(1000).setFlags(encoder.setProperties(50, true, true));
+        EdgeIteratorState edge2 = g.edge(1, 2).setDistance(1000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
         edge2.setWayGeometry(Helper.createPointList());
         edge2.setName("Street 2");
-        EdgeIteratorState edge3 = g.edge(2, 3).setDistance(1000).setFlags(encoder.setProperties(50, true, true));
+        EdgeIteratorState edge3 = g.edge(2, 3).setDistance(1000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
         edge3.setWayGeometry(Helper.createPointList());
         edge3.setName("Street 3");
-        EdgeIteratorState edge4 = g.edge(3, 4).setDistance(500).setFlags(encoder.setProperties(50, true, true));
+        EdgeIteratorState edge4 = g.edge(3, 4).setDistance(500).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
         edge4.setWayGeometry(Helper.createPointList());
         edge4.setName("Street 4");
 
-        g.edge(1, 5).setDistance(10000).setFlags(encoder.setProperties(50, true, true));
-        g.edge(2, 5).setDistance(10000).setFlags(encoder.setProperties(50, true, true));
-        g.edge(3, 5).setDistance(100000).setFlags(encoder.setProperties(50, true, true));
+        g.edge(1, 5).setDistance(10000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
+        g.edge(2, 5).setDistance(10000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
+        g.edge(3, 5).setDistance(100000).set(carAccessEnc, true).setReverse(carAccessEnc, true).set(carAvSpeedEnv, 50.0);
 
         Path path = new Path(g, new FastestWeighting(encoder));
         SPTEntry e1 = new SPTEntry(edge4.getEdge(), 4, 1);
@@ -188,7 +208,7 @@ public void testFindInstruction() {
         path.setSPTEntry(e1);
         path.extract();
 
-        InstructionList il = path.calcInstructions(tr);
+        InstructionList il = path.calcInstructions(carManagerRoundabout, tr);
         Instruction nextInstr0 = il.find(-0.001, 0.0, 1000);
         assertEquals(Instruction.CONTINUE_ON_STREET, nextInstr0.getSign());
 
@@ -218,12 +238,13 @@ public void testCalcInstructionsRoundabout() {
             Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                     .calcPath(1, 8);
             assertTrue(p.isFound());
-            InstructionList wayList = p.calcInstructions(tr);
+            assertEquals("[1, 2, 3, 4, 5, 8]", p.calcNodes().toString());
+            InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
             // Test instructions
-            List<String> tmpList = pick("text", wayList.createJson());
-            assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+            List<String> tmpList = getTurnDescriptions(wayList);
+            assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                     "At roundabout, take exit 3 onto 5-8",
-                    "Arrive at destination"),
+                    "arrive at destination"),
                     tmpList);
             // Test Radian
             double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -233,11 +254,11 @@ public void testCalcInstructionsRoundabout() {
             // case of continuing a street through a roundabout
             p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED).
                     calcPath(1, 7);
-            wayList = p.calcInstructions(tr);
-            tmpList = pick("text", wayList.createJson());
-            assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+            wayList = p.calcInstructions(mixedManagerRoundabout, tr);
+            tmpList = getTurnDescriptions(wayList);
+            assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                     "At roundabout, take exit 2 onto MainStreet 4 7",
-                    "Arrive at destination"),
+                    "arrive at destination"),
                     tmpList);
             // Test Radian
             delta = roundaboutGraph.getAngle(1, 2, 4, 7);
@@ -254,10 +275,10 @@ public void testCalcInstructionsRoundaboutBegin() {
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(2, 8);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
-        List<String> tmpList = pick("text", wayList.createJson());
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
+        List<String> tmpList = getTurnDescriptions(wayList);
         assertEquals(Arrays.asList("At roundabout, take exit 3 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
     }
 
@@ -270,11 +291,11 @@ public void testCalcInstructionsRoundaboutDirectExit() {
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(6, 8);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 3-6",
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 3-6",
                 "At roundabout, take exit 3 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         roundaboutGraph.inverse3to9();
     }
@@ -394,11 +415,11 @@ public void testCalcInstructionsRoundabout2() {
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 8);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                 "At roundabout, take exit 2 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -441,21 +462,29 @@ public void testCalcInstructionsRoundaboutIssue353() {
         // roundabout
         EdgeIteratorState tmpEdge;
         tmpEdge = g.edge(3, 9, 2, false).setName("3-9");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        carManagerRoundabout.setBool(false, tmpEdge.getFlags(), true);
+        tmpEdge.setFlags(tmpEdge.getFlags());
         tmpEdge = g.edge(9, 10, 2, false).setName("9-10");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        carManagerRoundabout.setBool(false, tmpEdge.getFlags(), true);
+        tmpEdge.setFlags(tmpEdge.getFlags());
         tmpEdge = g.edge(6, 10, 2, false).setName("6-10");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        carManagerRoundabout.setBool(false, tmpEdge.getFlags(), true);
+        tmpEdge.setFlags(tmpEdge.getFlags());
         tmpEdge = g.edge(10, 1, 2, false).setName("10-1");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        carManagerRoundabout.setBool(false, tmpEdge.getFlags(), true);
+        tmpEdge.setFlags(tmpEdge.getFlags());
         tmpEdge = g.edge(3, 2, 5, false).setName("2-3");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        carManagerRoundabout.setBool(false, tmpEdge.getFlags(), true);
+        tmpEdge.setFlags(tmpEdge.getFlags());
         tmpEdge = g.edge(4, 3, 5, false).setName("3-4");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        carManagerRoundabout.setBool(false, tmpEdge.getFlags(), true);
+        tmpEdge.setFlags(tmpEdge.getFlags());
         tmpEdge = g.edge(5, 4, 5, false).setName("4-5");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        carManagerRoundabout.setBool(false, tmpEdge.getFlags(), true);
+        tmpEdge.setFlags(tmpEdge.getFlags());
         tmpEdge = g.edge(2, 5, 5, false).setName("5-2");
-        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        carManagerRoundabout.setBool(false, tmpEdge.getFlags(), true);
+        tmpEdge.setFlags(tmpEdge.getFlags());
 
         g.edge(4, 7, 5, true).setName("MainStreet 4 7");
         g.edge(5, 8, 5, true).setName("5-8");
@@ -464,10 +493,10 @@ public void testCalcInstructionsRoundaboutIssue353() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(6, 11);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
-        List<String> tmpList = pick("text", wayList.createJson());
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
+        List<String> tmpList = getTurnDescriptions(wayList);
         assertEquals(Arrays.asList("At roundabout, take exit 1 onto MainStreet 1 11",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
     }
 
@@ -480,11 +509,11 @@ public void testCalcInstructionsRoundaboutClockwise() {
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 8);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto MainStreet 1 2",
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto MainStreet 1 2",
                 "At roundabout, take exit 1 onto 5-8",
-                "Arrive at destination"),
+                "arrive at destination"),
                 tmpList);
         // Test Radian
         double delta = roundaboutGraph.getAngle(1, 2, 5, 8);
@@ -492,22 +521,13 @@ public void testCalcInstructionsRoundaboutClockwise() {
         assertEquals(delta, instr.getTurnAngle(), 0.01);
     }
 
-    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
-        List<String> list = new ArrayList<>();
-
-        for (Map<String, Object> json : instructionJson) {
-            list.add(json.get(key).toString());
-        }
-        return list;
-    }
-
     @Test
     public void testCalcInstructionsIgnoreContinue() {
         // Follow a couple of straight edges, including a name change
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(4, 11);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
 
         // Contain only start and finish instruction, no CONTINUE
         assertEquals(2, wayList.size());
@@ -519,7 +539,7 @@ public void testCalcInstructionsIgnoreTurnIfNoAlternative() {
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(10, 12);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
 
         // Contain only start and finish instruction
         assertEquals(2, wayList.size());
@@ -550,7 +570,7 @@ public void testCalcInstructionForForkWithSameName() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 4);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         assertEquals(3, wayList.size());
         assertEquals(-7, wayList.get(1).getSign());
@@ -578,7 +598,7 @@ public void testCalcInstructionsEnterMotoway() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(4, 3);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         // no turn instruction for entering the highway
         assertEquals(2, wayList.size());
@@ -606,7 +626,7 @@ public void testCalcInstructionsMotowayJunction() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 3);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         assertEquals(3, wayList.size());
         // TODO this should be a keep_right
@@ -635,7 +655,7 @@ public void testCalcInstructionsOntoOneway() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(4, 3);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         assertEquals(3, wayList.size());
         assertEquals(2, wayList.get(1).getSign());
@@ -662,7 +682,7 @@ public void testCalcInstructionContinueLeavingStreet() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 4);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         assertEquals(3, wayList.size());
         assertEquals(-7, wayList.get(1).getSign());
@@ -691,7 +711,7 @@ public void testCalcInstructionSlightTurn() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(4, 1);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         assertEquals(3, wayList.size());
         assertEquals(-1, wayList.get(1).getSign());
@@ -726,7 +746,7 @@ public void testUTurnLeft() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 4);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         assertEquals(3, wayList.size());
         assertEquals(Instruction.U_TURN_LEFT, wayList.get(1).getSign());
@@ -761,7 +781,7 @@ public void testUTurnRight() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 6);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         assertEquals(3, wayList.size());
         assertEquals(Instruction.U_TURN_RIGHT, wayList.get(1).getSign());
@@ -773,7 +793,7 @@ public void testCalcInstructionsForTurn() {
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(11, 13);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
 
         // Contain start, turn, and finish instruction
         assertEquals(3, wayList.size());
@@ -794,13 +814,16 @@ public void testCalcInstructionsForDataFlagEncoder() {
         ReaderWay w = new ReaderWay(1);
         w.setTag("highway", "tertiary");
 
-        g.edge(1, 2, 5, true).setFlags(dataFlagEncoder.handleWayTags(w, 1, 0));
-        g.edge(2, 4, 5, true).setFlags(dataFlagEncoder.handleWayTags(w, 1, 0));
-        g.edge(2, 3, 5, true).setFlags(dataFlagEncoder.handleWayTags(w, 1, 0));
+        g.edge(1, 2, 5, true).setFlags(dataFlagEncoder.handleWayTags(dataFlagManager.createEdgeFlags(), w,
+                EncodingManager.Access.WAY, 0));
+        g.edge(2, 4, 5, true).setFlags(dataFlagEncoder.handleWayTags(dataFlagManager.createEdgeFlags(), w,
+                EncodingManager.Access.WAY, 0));
+        g.edge(2, 3, 5, true).setFlags(dataFlagEncoder.handleWayTags(dataFlagManager.createEdgeFlags(), w,
+                EncodingManager.Access.WAY, 0));
 
         Path p = new Dijkstra(g, new GenericWeighting(dataFlagEncoder, new HintsMap()), TraversalMode.NODE_BASED).calcPath(1, 3);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
         assertEquals(3, wayList.size());
     }
 
@@ -810,7 +833,7 @@ public void testCalcInstructionsForSlightTurnWithOtherSlightTurn() {
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(12, 16);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
 
         // Contain start, turn, and finish instruction
         assertEquals(3, wayList.size());
@@ -840,7 +863,7 @@ public void testCalcInstructionsForSlightTurnOntoDifferentStreet() {
         Path p = new Dijkstra(g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(1, 2);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(carManagerRoundabout, tr);
 
         assertEquals(3, wayList.size());
         assertEquals(Instruction.TURN_SLIGHT_RIGHT, wayList.get(1).getSign());
@@ -852,12 +875,20 @@ public void testIgnoreInstructionsForSlightTurnWithOtherTurn() {
         Path p = new Dijkstra(roundaboutGraph.g, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
                 .calcPath(16, 19);
         assertTrue(p.isFound());
-        InstructionList wayList = p.calcInstructions(tr);
+        InstructionList wayList = p.calcInstructions(mixedManagerRoundabout, tr);
 
         // Contain start, and finish instruction
         assertEquals(2, wayList.size());
     }
 
+    List<String> getTurnDescriptions(InstructionList instructionJson) {
+        List<String> list = new ArrayList<>();
+        for (Instruction instruction : instructionJson) {
+            list.add(instruction.getTurnDescription(tr));
+        }
+        return list;
+    }
+
     private Graph generatePathDetailsGraph() {
         final Graph g = new GraphBuilder(carManager).create();
         final NodeAccess na = g.getNodeAccess();
@@ -874,17 +905,19 @@ private Graph generatePathDetailsGraph() {
 
         EdgeIteratorState tmpEdge;
         tmpEdge = g.edge(1, 2, 5, true).setName("1-2");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        assertTrue(carManager.acceptWay(w, map));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
         tmpEdge = g.edge(4, 5, 5, true).setName("4-5");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
 
         w.setTag("maxspeed", "100");
         tmpEdge = g.edge(2, 3, 5, true).setName("2-3");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
 
         w.setTag("maxspeed", "10");
         tmpEdge = g.edge(3, 4, 10, true).setName("3-4");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
 
         return g;
     }
@@ -942,7 +975,6 @@ private RoundaboutGraph() {
             edge3to6 = g.edge(3, 6, 5, true).setName("3-6");
             edge3to9 = g.edge(3, 9, 5, false).setName("3-9");
 
-            // Don't set names
             g.edge(7, 10, 5, true);
             g.edge(10, 11, 5, true);
             g.edge(11, 12, 5, true);
@@ -954,17 +986,17 @@ private RoundaboutGraph() {
             g.edge(17, 18, 5, true);
             g.edge(17, 19, 5, true);
 
-
             setRoundabout(clockwise);
             inverse3to9();
-
         }
 
         public void setRoundabout(boolean clockwise) {
             for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders()) {
+                BooleanEncodedValue accessEnc = encoder.getAccessEnc();
                 for (EdgeIteratorState edge : roundaboutEdges) {
-                    edge.setFlags(encoder.setAccess(edge.getFlags(), clockwise, !clockwise));
-                    edge.setFlags(encoder.setBool(edge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+                    edge.set(accessEnc, clockwise).setReverse(accessEnc, !clockwise);
+                    mixedManagerRoundabout.setBool(false, edge.getFlags(), true);
+                    edge.setFlags(edge.getFlags());
                 }
             }
             this.clockwise = clockwise;
@@ -972,15 +1004,15 @@ public void setRoundabout(boolean clockwise) {
 
         public void inverse3to9() {
             for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders()) {
-                long flags = edge3to9.getFlags();
-                edge3to9.setFlags(encoder.setAccess(flags, !edge3to9.isForward(encoder), false));
+                BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+                edge3to9.set(accessEnc, !edge3to9.get(accessEnc)).setReverse(accessEnc, false);
             }
         }
 
         public void inverse3to6() {
             for (FlagEncoder encoder : mixedEncoders.fetchEdgeEncoders()) {
-                long flags = edge3to6.getFlags();
-                edge3to6.setFlags(encoder.setAccess(flags, !edge3to6.isForward(encoder), true));
+                BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+                edge3to6.set(accessEnc, !edge3to6.get(accessEnc)).setReverse(accessEnc, true);
             }
         }
 
diff --git a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
index c3f61249b7..fda2a48546 100644
--- a/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
+++ b/core/src/test/java/com/graphhopper/routing/QueryGraphTest.java
@@ -18,10 +18,14 @@
 package com.graphhopper.routing;
 
 import com.carrotsearch.hppc.IntObjectMap;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.TurnWeighting;
 import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
@@ -29,9 +33,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.LinkedHashSet;
+import java.util.*;
 
 import static com.graphhopper.storage.index.QueryResult.Position.*;
 import static org.junit.Assert.*;
@@ -47,7 +49,7 @@
     @Before
     public void setUp() {
         carEncoder = new CarFlagEncoder();
-        encodingManager = new EncodingManager(carEncoder);
+        encodingManager = EncodingManager.create(carEncoder);
         g = new GraphHopperStorage(new RAMDirectory(), encodingManager, false, new GraphExtension.NoOpExtension()).create(100);
     }
 
@@ -109,7 +111,7 @@ public void testOneVirtualNode() {
         queryGraph.lookup(Arrays.asList(res));
         assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
-        assertEquals(4, getPoints(queryGraph, 0, 3).getSize());
+        assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
         assertEquals(2, getPoints(queryGraph, 3, 1).getSize());
 
         queryGraph = new QueryGraph(g);
@@ -117,7 +119,7 @@ public void testOneVirtualNode() {
         queryGraph.lookup(Arrays.asList(res));
         assertEquals(new GHPoint(1.5, 1.5), res.getSnappedPoint());
         assertEquals(3, res.getClosestNode());
-        assertEquals(4, getPoints(queryGraph, 0, 3).getSize());
+        assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
         assertEquals(2, getPoints(queryGraph, 3, 1).getSize());
 
         // snap to edge which has pillar nodes        
@@ -158,9 +160,9 @@ void fillVirtualEdges(IntObjectMap<VirtualEdgeIterator> node2Edge, int towerNode
                 super.fillVirtualEdges(node2Edge, towerNode, mainExpl);
                 // ignore nodes should include baseNode == 1
                 if (towerNode == 3)
-                    assertEquals("[3->4]", node2Edge.get(towerNode).toString());
+                    assertEquals("virtual edge: (invalid), all: [3->4]", node2Edge.get(towerNode).toString());
                 else if (towerNode == 1)
-                    assertEquals("[1->4, 1 1-0]", node2Edge.get(towerNode).toString());
+                    assertEquals("virtual edge: (invalid), all: [1->4, 1 1-0]", node2Edge.get(towerNode).toString());
                 else
                     throw new IllegalStateException("not allowed " + towerNode);
             }
@@ -186,11 +188,11 @@ public void testMultipleVirtualNodes() {
         queryGraph.lookup(Arrays.asList(res1));
         assertEquals(new GHPoint(1.5, 1.5), res1.getSnappedPoint());
         assertEquals(3, res1.getClosestNode());
-        assertEquals(4, getPoints(queryGraph, 0, 3).getSize());
+        assertEquals(3, getPoints(queryGraph, 0, 3).getSize());
         PointList pl = getPoints(queryGraph, 3, 1);
         assertEquals(2, pl.getSize());
-        assertEquals(new GHPoint(1.5, 1.5), pl.toGHPoint(0));
-        assertEquals(new GHPoint(1, 2.5), pl.toGHPoint(1));
+        assertEquals(new GHPoint(1.5, 1.5), pl.get(0));
+        assertEquals(new GHPoint(1, 2.5), pl.get(1));
 
         EdgeIteratorState edge = GHUtility.getEdge(queryGraph, 3, 1);
         assertNotNull(queryGraph.getEdgeIteratorState(edge.getEdge(), 3));
@@ -212,7 +214,7 @@ public void testMultipleVirtualNodes() {
         assertEquals(3, res1.getClosestNode());
         assertEquals(new GHPoint(1.5, 1.5), res1.getSnappedPoint());
 
-        assertEquals(4, getPoints(queryGraph, 3, 0).getSize());
+        assertEquals(3, getPoints(queryGraph, 3, 0).getSize());
         assertEquals(2, getPoints(queryGraph, 3, 4).getSize());
         assertEquals(2, getPoints(queryGraph, 4, 1).getSize());
         assertNull(GHUtility.getEdge(queryGraph, 4, 0));
@@ -324,10 +326,12 @@ public void testOneWayLoop_Issue162() {
         na.setNode(0, 0, 0);
         na.setNode(1, 0, -0.001);
         g.edge(0, 1, 10, true);
+        BooleanEncodedValue accessEnc = carEncoder.getAccessEnc();
+        DecimalEncodedValue avSpeedEnc = carEncoder.getAverageSpeedEnc();
         // in the case of identical nodes the wayGeometry defines the direction!
         EdgeIteratorState edge = g.edge(0, 0).
                 setDistance(100).
-                setFlags(carEncoder.setProperties(20, true, false)).
+                set(accessEnc, true).setReverse(accessEnc, false).set(avSpeedEnc, 20.0).
                 setWayGeometry(Helper.createPointList(0.001, 0, 0, 0.001));
 
         QueryResult qr = new QueryResult(0.0011, 0.0009);
@@ -342,12 +346,12 @@ public void testOneWayLoop_Issue162() {
         assertEquals(2, GHUtility.count(ee.setBaseNode(qr.getClosestNode())));
         EdgeIterator iter = ee.setBaseNode(qr.getClosestNode());
         iter.next();
-        assertTrue(iter.toString(), iter.isForward(carEncoder));
-        assertFalse(iter.toString(), iter.isBackward(carEncoder));
+        assertTrue(iter.toString(), iter.get(accessEnc));
+        assertFalse(iter.toString(), iter.getReverse(accessEnc));
 
         iter.next();
-        assertFalse(iter.toString(), iter.isForward(carEncoder));
-        assertTrue(iter.toString(), iter.isBackward(carEncoder));
+        assertFalse(iter.toString(), iter.get(accessEnc));
+        assertTrue(iter.toString(), iter.getReverse(accessEnc));
     }
 
     @Test
@@ -437,7 +441,7 @@ public void testIteration_Issue163() {
         int nodeB = 1;
 
         /* init test graph: one directional edge going from A to B, via virtual nodes C and D
-         * 
+         *
          *   (C)-(D)
          *  /       \
          * A         B
@@ -492,7 +496,7 @@ public void testTurnCostsProperlyPropagated_Issue282() {
         FlagEncoder encoder = new CarFlagEncoder(5, 5, 15);
 
         GraphHopperStorage graphWithTurnCosts = new GraphHopperStorage(new RAMDirectory(),
-                new EncodingManager(encoder), false, turnExt).
+                EncodingManager.create(encoder), false, turnExt).
                 create(100);
         NodeAccess na = graphWithTurnCosts.getNodeAccess();
         na.setNode(0, .00, .00);
@@ -546,9 +550,8 @@ private QueryResult fakeEdgeQueryResult(EdgeIteratorState edge, double lat, doub
         return qr;
     }
 
-    private boolean isAvoidEdge(QueryGraph queryGraph, int virtualEdgeTypeId, boolean _default) {
-        boolean avoidEdge = queryGraph.virtualEdges.get(virtualEdgeTypeId).getBool(EdgeIteratorState.K_UNFAVORED_EDGE, _default);
-        return avoidEdge;
+    private boolean isAvoidEdge(QueryGraph queryGraph, int virtualEdgeTypeId) {
+        return queryGraph.virtualEdges.get(virtualEdgeTypeId).get(EdgeIteratorState.UNFAVORED_EDGE);
     }
 
     @Test
@@ -566,21 +569,21 @@ public void testEnforceHeading() {
         queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
         // test penalized south
         boolean expect = true;
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV, !expect));
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE));
 
         queryGraph.clearUnfavoredStatus();
         // test cleared edges south
         expect = false;
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV, !expect));
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE));
 
         // enforce coming in north
         queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
         // test penalized south
         expect = true;
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV, !expect));
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE_REV));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_BASE));
 
         // query result on second vertical part of way (downward)
         qr = fakeEdgeQueryResult(edge, 1.5, 2, 2);
@@ -591,16 +594,16 @@ public void testEnforceHeading() {
         queryGraph.enforceHeading(qr.getClosestNode(), 0., false);
         // test penalized south
         expect = true;
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ, !expect));
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ_REV, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ_REV));
 
         queryGraph.clearUnfavoredStatus();
         // enforce coming in north
         queryGraph.enforceHeading(qr.getClosestNode(), 180., true);
         // test penalized south
         expect = true;
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ, !expect));
-        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ_REV, !expect));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ));
+        assertEquals(expect, isAvoidEdge(queryGraph, QueryGraph.VE_ADJ_REV));
     }
 
     @Test
@@ -620,20 +623,20 @@ public void testunfavorVirtualEdgePair() {
         VirtualEdgeIteratorState incomingEdge = (VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(1, 2);
         VirtualEdgeIteratorState incomingEdgeReverse = (VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(1, incomingEdge.getBaseNode());
         boolean expect = true;  // expect incoming and reverse incoming edge to be avoided
-        assertEquals(expect, incomingEdge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, !expect));
-        assertEquals(expect, incomingEdgeReverse.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, !expect));
+        assertEquals(expect, incomingEdge.get(EdgeIteratorState.UNFAVORED_EDGE));
+        assertEquals(expect, incomingEdgeReverse.get(EdgeIteratorState.UNFAVORED_EDGE));
         assertEquals(new LinkedHashSet<>(Arrays.asList(incomingEdge, incomingEdgeReverse)),
                 queryGraph.getUnfavoredVirtualEdges());
 
         queryGraph.clearUnfavoredStatus();
         expect = false; // expect incoming and reverse incoming edge not to be avoided
-        assertEquals(expect, incomingEdge.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, !expect));
-        assertEquals(expect, incomingEdgeReverse.getBool(EdgeIteratorState.K_UNFAVORED_EDGE, !expect));
+        assertEquals(expect, incomingEdge.get(EdgeIteratorState.UNFAVORED_EDGE));
+        assertEquals(expect, incomingEdgeReverse.get(EdgeIteratorState.UNFAVORED_EDGE));
         assertEquals(new LinkedHashSet<>(), queryGraph.getUnfavoredVirtualEdges());
     }
 
     @Test
-    public void testInternalAPIOriginalTraversalKey() {
+    public void testInternalAPIOriginalEdgeKey() {
         initGraph(g);
 
         EdgeExplorer explorer = g.createEdgeExplorer();
@@ -652,12 +655,12 @@ public void testInternalAPIOriginalTraversalKey() {
         assertTrue(iter.next());
         assertEquals(0, iter.getAdjNode());
         assertEquals(GHUtility.createEdgeKey(1, 0, origEdgeId, false),
-                ((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), 0)).getOriginalTraversalKey());
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), 0)).getOriginalEdgeKey());
 
         assertTrue(iter.next());
         assertEquals(1, iter.getAdjNode());
         assertEquals(GHUtility.createEdgeKey(0, 1, origEdgeId, false),
-                ((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), 1)).getOriginalTraversalKey());
+                ((VirtualEdgeIteratorState) queryGraph.getEdgeIteratorState(iter.getEdge(), 1)).getOriginalEdgeKey());
     }
 
     @Test
@@ -673,6 +676,168 @@ public void useEECache() {
 
         EdgeExplorer edgeExplorer = queryGraph.createEdgeExplorer();
         // using cache means same reference
-        assertTrue(edgeExplorer == queryGraph.createEdgeExplorer());
+        assertSame(edgeExplorer, queryGraph.createEdgeExplorer());
+    }
+
+    @Test
+    public void useEECache_nestedLoop() {
+        //
+        // 0->3
+        // |\
+        // 1 2->6
+        //   |\
+        //   4 5
+        g.edge(0, 1, 10, false);
+        g.edge(0, 2, 10, false);
+        g.edge(0, 3, 10, false);
+        g.edge(2, 4, 10, false);
+        g.edge(2, 5, 10, false);
+        g.edge(2, 6, 10, false);
+
+        EdgeExplorer explorer = g.createEdgeExplorer();
+        EdgeIterator iter = explorer.setBaseNode(0);
+        assertTrue(iter.next());
+        QueryResult res = createLocationResult(0, 0, iter, 1, PILLAR);
+
+        QueryGraph queryGraph = new QueryGraph(g).setUseEdgeExplorerCache(true);
+        queryGraph.lookup(Collections.singletonList(res));
+
+        EdgeExplorer outerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
+        EdgeExplorer innerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
+
+        // without using filter id for DefaultEdgeFilter the filters are equal and using the explorers in a nested
+        // loop would fail
+        assertSame(outerEdgeExplorer, innerEdgeExplorer);
+
+        // using a different filter id for the second filter we get different explorers
+        outerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
+        innerEdgeExplorer = queryGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder).setFilterId(1));
+        assertNotSame(outerEdgeExplorer, innerEdgeExplorer);
+
+        // now we can safely use the two explorers in a nested loop
+        Set<String> edges = new HashSet<>();
+        EdgeIterator outerIter = outerEdgeExplorer.setBaseNode(0);
+        while (outerIter.next()) {
+            edges.add("o" + outerIter.getBaseNode() + "-" + outerIter.getAdjNode());
+            EdgeIterator innerIter = innerEdgeExplorer.setBaseNode(outerIter.getAdjNode());
+            while (innerIter.next()) {
+                edges.add("i" + innerIter.getBaseNode() + "-" + innerIter.getAdjNode());
+            }
+        }
+        assertEquals(new HashSet<>(Arrays.asList("o0-1", "o0-2", "o0-3", "i2-4", "i2-5", "i2-6")), edges);
     }
+
+    @Test
+    public void testWayGeometry_edge() {
+        // drawn as horizontal linear graph for simplicity
+        // 0 - * - x - * - 1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0.3, 0.3);
+        g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(0.1, 0.1, 0.2, 0.2));
+
+        QueryGraph queryGraph = new QueryGraph(g);
+        LocationIndex locationIndex = new LocationIndexTree(g, new RAMDirectory());
+        locationIndex.prepareIndex();
+        QueryResult qr = locationIndex.findClosest(0.15, 0.15, DefaultEdgeFilter.allEdges(carEncoder));
+        assertTrue(qr.isValid());
+        assertEquals("this test was supposed to test the Position.EDGE case", EDGE, qr.getSnappedPosition());
+        queryGraph.lookup(Collections.singletonList(qr));
+        EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(qr.getClosestNode());
+
+        assertTrue(iter.next());
+        assertEquals(0, iter.getAdjNode());
+        assertEquals(1, iter.fetchWayGeometry(0).size());
+        assertEquals(2, iter.fetchWayGeometry(1).size());
+        assertEquals(2, iter.fetchWayGeometry(2).size());
+        assertEquals(3, iter.fetchWayGeometry(3).size());
+        assertEquals(Helper.createPointList(0.15, 0.15, 0.1, 0.1, 0.0, 0.0), iter.fetchWayGeometry(3));
+
+        assertTrue(iter.next());
+        assertEquals(1, iter.getAdjNode());
+        assertEquals(1, iter.fetchWayGeometry(0).size());
+        assertEquals(2, iter.fetchWayGeometry(1).size());
+        assertEquals(2, iter.fetchWayGeometry(2).size());
+        assertEquals(3, iter.fetchWayGeometry(3).size());
+        assertEquals(Helper.createPointList(0.15, 0.15, 0.2, 0.2, 0.3, 0.3), iter.fetchWayGeometry(3));
+
+        assertFalse(iter.next());
+    }
+
+    @Test
+    public void testWayGeometry_pillar() {
+        //   1
+        //    \
+        //     * x
+        //    /
+        //   *
+        //  /
+        // 0
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0.5, 0.1);
+        g.edge(0, 1, 10, true).setWayGeometry(Helper.createPointList(0.1, 0.1, 0.2, 0.2));
+
+        QueryGraph queryGraph = new QueryGraph(g);
+        LocationIndex locationIndex = new LocationIndexTree(g, new RAMDirectory());
+        locationIndex.prepareIndex();
+        QueryResult qr = locationIndex.findClosest(0.2, 0.21, DefaultEdgeFilter.allEdges(carEncoder));
+        assertTrue(qr.isValid());
+        assertEquals("this test was supposed to test the Position.PILLAR case", PILLAR, qr.getSnappedPosition());
+        queryGraph.lookup(Collections.singletonList(qr));
+        EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(qr.getClosestNode());
+
+        assertTrue(iter.next());
+        assertEquals(0, iter.getAdjNode());
+        assertEquals(1, iter.fetchWayGeometry(0).size());
+        assertEquals(2, iter.fetchWayGeometry(1).size());
+        assertEquals(2, iter.fetchWayGeometry(2).size());
+        assertEquals(3, iter.fetchWayGeometry(3).size());
+        assertEquals(Helper.createPointList(0.2, 0.2, 0.1, 0.1, 0.0, 0.0), iter.fetchWayGeometry(3));
+
+        assertTrue(iter.next());
+        assertEquals(1, iter.getAdjNode());
+        assertEquals(0, iter.fetchWayGeometry(0).size());
+        assertEquals(1, iter.fetchWayGeometry(1).size());
+        assertEquals(1, iter.fetchWayGeometry(2).size());
+        assertEquals(2, iter.fetchWayGeometry(3).size());
+        assertEquals(Helper.createPointList(0.2, 0.2, 0.5, 0.1), iter.fetchWayGeometry(3));
+
+        assertFalse(iter.next());
+    }
+
+    @Test
+    public void testVirtualEdgeDistance() {
+        //   x
+        // -----
+        // |   |
+        // 0   1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(0, 0, 0);
+        na.setNode(1, 0, 1);
+        // dummy node to make sure graph bounds are valid
+        na.setNode(2, 2, 2);
+        DistanceCalc distCalc = Helper.DIST_PLANE;
+        double dist = 0;
+        dist += distCalc.calcDist(0, 0, 1, 0);
+        dist += distCalc.calcDist(1, 0, 1, 1);
+        dist += distCalc.calcDist(1, 1, 0, 1);
+        g.edge(0, 1, dist, true).setWayGeometry(Helper.createPointList(1, 0, 1, 1));
+        LocationIndexTree index = new LocationIndexTree(g, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr = index.findClosest(1.01, 0.7, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(g);
+        queryGraph.lookup(Collections.singletonList(qr));
+        // the sum of the virtual edge distances adjacent to the virtual node should be equal to the distance
+        // of the real edge, so the 'distance' from 0 to 1 is the same no matter if we travel on the query graph or the
+        // real graph
+        EdgeIterator iter = queryGraph.createEdgeExplorer().setBaseNode(3);
+        double virtualEdgeDistanceSum = 0;
+        while (iter.next()) {
+            virtualEdgeDistanceSum += iter.getDistance();
+        }
+        double directDist = g.getEdgeIteratorState(0, 1).getDistance();
+        assertEquals(directDist, virtualEdgeDistanceSum, 1.e-3);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
new file mode 100644
index 0000000000..affbb99301
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/RandomCHRoutingTest.java
@@ -0,0 +1,267 @@
+package com.graphhopper.routing;
+
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
+import com.graphhopper.util.shapes.BBox;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Random;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+@RunWith(Parameterized.class)
+public class RandomCHRoutingTest {
+    private final TraversalMode traversalMode;
+    private final int maxTurnCosts;
+    private Directory dir;
+    private CarFlagEncoder encoder;
+    private Weighting weighting;
+    private GraphHopperStorage graph;
+    private LocationIndexTree locationIndex;
+    private CHGraph chGraph;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static Object[] params() {
+        return new Object[]{
+                TraversalMode.NODE_BASED,
+                TraversalMode.EDGE_BASED
+        };
+    }
+
+    public RandomCHRoutingTest(TraversalMode traversalMode) {
+        this.traversalMode = traversalMode;
+        this.maxTurnCosts = 10;
+    }
+
+    @Before
+    public void init() {
+        dir = new RAMDirectory();
+        encoder = new CarFlagEncoder(5, 5, maxTurnCosts);
+        EncodingManager em = EncodingManager.create(encoder);
+        weighting = new FastestWeighting(encoder);
+        GraphBuilder graphBuilder = new GraphBuilder(em);
+        graphBuilder.setEdgeBasedCH(traversalMode.isEdgeBased());
+        graph = graphBuilder.setCHGraph(weighting).create();
+        chGraph = graph.getCHGraph();
+    }
+
+    /**
+     * Runs random routing queries on a random query/CH graph with random speeds and adding random virtual edges and
+     * nodes.
+     */
+    @Test
+    public void random() {
+        // you might have to keep this test running in an infinite loop for several minutes to find potential routing
+        // bugs (e.g. use intellij 'run until stop/failure').
+        int numNodes = 50;
+        long seed = System.nanoTime();
+        System.out.println("seed: " + seed);
+        Random rnd = new Random(seed);
+        // we may not use an offset when query graph is involved, otherwise traveling via virtual edges will not be
+        // the same as taking the direct edge!
+        double pOffset = 0;
+        GHUtility.buildRandomGraph(graph, rnd, numNodes, 2.5, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, pOffset);
+        if (traversalMode.isEdgeBased()) {
+            GHUtility.addRandomTurnCosts(graph, seed, encoder, maxTurnCosts, (TurnCostExtension) graph.getExtension());
+        }
+        runRandomTest(rnd, 20);
+    }
+
+    @Test
+    public void issue1574_1() {
+        Assume.assumeFalse(traversalMode.isEdgeBased());
+        Random rnd = new Random(9348906923700L);
+        buildRandomGraphLegacy(rnd, 50, 2.5, false, true, 0.9);
+        runRandomTest(rnd, 20);
+    }
+
+    @Test
+    public void issue1574_2() {
+        Assume.assumeFalse(traversalMode.isEdgeBased());
+        Random rnd = new Random(10093639220394L);
+        buildRandomGraphLegacy(rnd, 50, 2.5, false, true, 0.9);
+        runRandomTest(rnd, 20);
+    }
+
+    @Test
+    public void issue1582() {
+        Assume.assumeFalse(traversalMode.isEdgeBased());
+        Random rnd = new Random(4111485945982L);
+        buildRandomGraphLegacy(rnd, 10, 2.5, false, true, 0.9);
+        runRandomTest(rnd, 100);
+    }
+
+    @Test
+    public void issue1583() {
+        Assume.assumeFalse(traversalMode.isEdgeBased());
+        Random rnd = new Random(10785899964423L);
+        buildRandomGraphLegacy(rnd, 50, 2.5, true, true, 0.9);
+        runRandomTest(rnd, 20);
+    }
+
+    @Test
+    public void issue1593() {
+        Assume.assumeTrue(traversalMode.isEdgeBased());
+        long seed = 60643479675316L;
+        Random rnd = new Random(seed);
+        GHUtility.buildRandomGraph(graph, rnd, 50, 2.5, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, 0.0);
+        GHUtility.addRandomTurnCosts(graph, seed, encoder, maxTurnCosts, (TurnCostExtension) graph.getExtension());
+        runRandomTest(rnd, 20);
+    }
+
+    private void runRandomTest(Random rnd, int numVirtualNodes) {
+        locationIndex = new LocationIndexTree(graph, dir);
+        locationIndex.prepareIndex();
+
+        graph.freeze();
+        PrepareContractionHierarchies pch = new PrepareContractionHierarchies(chGraph, weighting, traversalMode);
+        pch.doWork();
+
+        int numQueryGraph = 25;
+        for (int j = 0; j < numQueryGraph; j++) {
+            QueryGraph queryGraph = new QueryGraph(graph);
+            QueryGraph chQueryGraph = new QueryGraph(chGraph);
+            // add virtual nodes and edges, because they can change the routing behavior and/or produce bugs, e.g.
+            // when via-points are used
+            addVirtualNodesAndEdges(rnd, queryGraph, chQueryGraph, numVirtualNodes);
+
+            int numQueries = 100;
+            int numPathsNotFound = 0;
+            List<String> strictViolations = new ArrayList<>();
+            for (int i = 0; i < numQueries; i++) {
+                assertEquals("queryGraph and chQueryGraph should have equal number of nodes", queryGraph.getNodes(), chQueryGraph.getNodes());
+                int from = rnd.nextInt(queryGraph.getNodes());
+                int to = rnd.nextInt(queryGraph.getNodes());
+                Weighting w = traversalMode.isEdgeBased()
+                        ? new TurnWeighting(weighting, (TurnCostExtension) queryGraph.getExtension())
+                        : weighting;
+                // using plain dijkstra instead of bidirectional, because of #1592
+                RoutingAlgorithm refAlgo = new Dijkstra(queryGraph, w, traversalMode);
+                Path refPath = refAlgo.calcPath(from, to);
+                double refWeight = refPath.getWeight();
+                if (!refPath.isFound()) {
+                    numPathsNotFound++;
+                    continue;
+                }
+
+                RoutingAlgorithm algo = pch.createAlgo(chQueryGraph, AlgorithmOptions.start().hints(new PMap().put("stall_on_demand", true)).build());
+                Path path = algo.calcPath(from, to);
+                if (!path.isFound()) {
+                    fail("path not found for " + from + "->" + to + ", expected weight: " + refWeight);
+                }
+
+                double weight = path.getWeight();
+                if (Math.abs(refWeight - weight) > 1.e-2) {
+                    System.out.println("expected: " + refPath.calcNodes());
+                    System.out.println("given:    " + path.calcNodes());
+                    fail("wrong weight: " + from + "->" + to + ", dijkstra: " + refWeight + " vs. ch: " + path.getWeight());
+                }
+                if (Math.abs(path.getDistance() - refPath.getDistance()) > 1.e-1) {
+                    strictViolations.add("wrong distance " + from + "->" + to + ", expected: " + refPath.getDistance() + ", given: " + path.getDistance());
+                }
+                if (Math.abs(path.getTime() - refPath.getTime()) > 50) {
+                    strictViolations.add("wrong time " + from + "->" + to + ", expected: " + refPath.getTime() + ", given: " + path.getTime());
+                }
+            }
+            if (numPathsNotFound > 0.9 * numQueries) {
+                fail("Too many paths not found: " + numPathsNotFound + "/" + numQueries);
+            }
+            if (strictViolations.size() > 0.05 * numQueries) {
+                fail("Too many strict violations: " + strictViolations.size() + "/" + numQueries + "\n" +
+                        Helper.join("\n", strictViolations));
+            }
+        }
+    }
+
+    private void addVirtualNodesAndEdges(Random rnd, QueryGraph queryGraph, QueryGraph chQueryGraph, int numVirtualNodes) {
+        BBox bbox = graph.getBounds();
+        int count = 0;
+        List<QueryResult> qrs = new ArrayList<>(numVirtualNodes);
+        while (qrs.size() < numVirtualNodes) {
+            if (count > numVirtualNodes * 100) {
+                throw new IllegalArgumentException("Could not create enough virtual edges");
+            }
+            QueryResult qr = findQueryResult(rnd, bbox);
+            if (qr.getSnappedPosition().equals(QueryResult.Position.EDGE)) {
+                qrs.add(qr);
+            }
+            count++;
+        }
+        queryGraph.lookup(qrs);
+        chQueryGraph.lookup(qrs);
+    }
+
+    private QueryResult findQueryResult(Random rnd, BBox bbox) {
+        return locationIndex.findClosest(
+                randomDoubleInRange(rnd, bbox.minLat, bbox.maxLat),
+                randomDoubleInRange(rnd, bbox.minLon, bbox.maxLon),
+                EdgeFilter.ALL_EDGES
+        );
+    }
+
+    private double randomDoubleInRange(Random rnd, double min, double max) {
+        return min + rnd.nextDouble() * (max - min);
+    }
+
+    /**
+     * More or less does the same as {@link GHUtility#buildRandomGraph}, but since some special seeds
+     * are used in a few tests above this code is kept here. Do not use it for new tests.
+     */
+    private void buildRandomGraphLegacy(Random random, int numNodes, double meanDegree, boolean allowLoops, boolean allowZeroDistance, double pBothDir) {
+        for (int i = 0; i < numNodes; ++i) {
+            double lat = 49.4 + (random.nextDouble() * 0.0001);
+            double lon = 9.7 + (random.nextDouble() * 0.0001);
+            graph.getNodeAccess().setNode(i, lat, lon);
+        }
+        double minDist = Double.MAX_VALUE;
+        double maxDist = Double.MIN_VALUE;
+        int numEdges = (int) (0.5 * meanDegree * numNodes);
+        for (int i = 0; i < numEdges; ++i) {
+            int from = random.nextInt(numNodes);
+            int to = random.nextInt(numNodes);
+            if (!allowLoops && from == to) {
+                continue;
+            }
+            double distance = GHUtility.getDistance(from, to, graph.getNodeAccess());
+            if (!allowZeroDistance) {
+                distance = Math.max(0.001, distance);
+            }
+            // add some random offset for most cases, but also allow duplicate edges with same weight
+            if (random.nextDouble() < 0.8)
+                distance += random.nextDouble() * distance * 0.01;
+            minDist = Math.min(minDist, distance);
+            maxDist = Math.max(maxDist, distance);
+            // using bidirectional edges will increase mean degree of graph above given value
+            boolean bothDirections = random.nextDouble() < pBothDir;
+            EdgeIteratorState edge = graph.edge(from, to, distance, bothDirections);
+            double fwdSpeed = 10 + random.nextDouble() * 120;
+            double bwdSpeed = 10 + random.nextDouble() * 120;
+            DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+            edge.set(speedEnc, fwdSpeed);
+            if (speedEnc.isStoreTwoDirections())
+                edge.setReverse(speedEnc, bwdSpeed);
+        }
+    }
+}
+
diff --git a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
index 33ba89bbec..98c46678d8 100644
--- a/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
+++ b/core/src/test/java/com/graphhopper/routing/RoutingAlgorithmIT.java
@@ -89,18 +89,28 @@ public RoutingAlgorithmFactory createRoutingFactory() {
         }
 
         if (hopper.getCHFactoryDecorator().isEnabled()) {
-            final HintsMap chHints = new HintsMap(defaultHints).put(Parameters.CH.DISABLE, false);
+            final HintsMap chHints = new HintsMap(defaultHints);
+            chHints.put(Parameters.CH.DISABLE, false);
+            chHints.put(Parameters.Routing.EDGE_BASED, tMode.isEdgeBased());
             Weighting pickedWeighting = null;
-            for (Weighting tmpWeighting : hopper.getCHFactoryDecorator().getWeightings()) {
+            for (Weighting tmpWeighting : hopper.getCHFactoryDecorator().getNodeBasedWeightings()) {
+                if (tmpWeighting.equals(weighting)) {
+                    pickedWeighting = tmpWeighting;
+                    break;
+                }
+            }
+            // todo: not so sure about this, can the edge based weighting entry overwrite the picked weighting found
+            // in the node based weightings ?
+            for (Weighting tmpWeighting : hopper.getCHFactoryDecorator().getEdgeBasedWeightings()) {
                 if (tmpWeighting.equals(weighting)) {
                     pickedWeighting = tmpWeighting;
                     break;
                 }
             }
             if (pickedWeighting == null)
-                throw new IllegalStateException("Didn't find weighting " + hints.getWeighting() + " in " + hopper.getCHFactoryDecorator().getWeightings());
+                throw new IllegalStateException("Didn't find weighting " + hints.getWeighting() + " in " + hopper.getCHFactoryDecorator().getNodeBasedWeightings());
 
-            prepare.add(new AlgoHelperEntry(ghStorage.getGraph(CHGraph.class, pickedWeighting),
+            prepare.add(new AlgoHelperEntry(ghStorage.getCHGraph(pickedWeighting),
                     AlgorithmOptions.start(dijkstrabiOpts).hints(chHints).build(), idx, "dijkstrabi|ch|prepare|" + hints.getWeighting()) {
                 @Override
                 public RoutingAlgorithmFactory createRoutingFactory() {
@@ -108,7 +118,7 @@ public RoutingAlgorithmFactory createRoutingFactory() {
                 }
             });
 
-            prepare.add(new AlgoHelperEntry(ghStorage.getGraph(CHGraph.class, pickedWeighting),
+            prepare.add(new AlgoHelperEntry(ghStorage.getCHGraph(pickedWeighting),
                     AlgorithmOptions.start(astarbiOpts).hints(chHints).build(), idx, "astarbi|ch|prepare|" + hints.getWeighting()) {
                 @Override
                 public RoutingAlgorithmFactory createRoutingFactory() {
@@ -126,7 +136,7 @@ public void testPerformance() throws IOException {
         int noJvmWarming = N / 4;
 
         Random rand = new Random(0);
-        final EncodingManager eManager = new EncodingManager("car");
+        final EncodingManager eManager = EncodingManager.create("car");
         final GraphHopperStorage graph = new GraphBuilder(eManager).create();
 
         String bigFile = "10000EWD.txt.gz";
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
index 187044fa7c..b3915467b0 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHAlgoFactoryDecoratorTest.java
@@ -17,21 +17,125 @@
  */
 package com.graphhopper.routing.ch;
 
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.ShortFastestWeighting;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import org.junit.Before;
 import org.junit.Test;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import java.util.Arrays;
+import java.util.List;
+
+import static com.graphhopper.routing.util.TraversalMode.EDGE_BASED;
+import static com.graphhopper.routing.util.TraversalMode.NODE_BASED;
+import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
 public class CHAlgoFactoryDecoratorTest {
+    private CHAlgoFactoryDecorator instance;
+    private Weighting weighting1;
+    private Weighting weighting2;
+    private Weighting weighting3;
+    private GraphHopperStorage ghStorage;
+
+    @Before
+    public void setup() {
+        instance = new CHAlgoFactoryDecorator();
+        Directory dir = new RAMDirectory();
+        FlagEncoder encoder = new CarFlagEncoder();
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        weighting1 = new FastestWeighting(encoder);
+        weighting2 = new ShortestWeighting(encoder);
+        weighting3 = new ShortFastestWeighting(encoder, 0.1);
+        ghStorage = new GraphHopperStorage(
+                Arrays.asList(weighting1, weighting2, weighting3),
+                Arrays.asList(weighting1, weighting2, weighting3),
+                dir, encodingManager, false, new GraphExtension.NoOpExtension());
+    }
+
     @Test
     public void testCreatePreparations() {
-        CHAlgoFactoryDecorator instance = new CHAlgoFactoryDecorator();
         assertFalse(instance.isDisablingAllowed());
-
         instance.setEnabled(false);
         assertTrue(instance.isDisablingAllowed());
     }
+
+    @Test(expected = IllegalStateException.class)
+    public void testAddingPreparationBeforeWeighting_throws() {
+        PrepareContractionHierarchies preparation = createNodeBasedPreparation(weighting1);
+        instance.addPreparation(preparation);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddingPreparationWithWrongWeighting_throws() {
+        instance.addNodeBasedWeighting(weighting1);
+        PrepareContractionHierarchies preparation = createNodeBasedPreparation(weighting2);
+        instance.addPreparation(preparation);
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testAddingPreparationsInWrongOrder_throws() {
+        instance.addNodeBasedWeighting(weighting1);
+        instance.addNodeBasedWeighting(weighting2);
+        instance.addPreparation(createNodeBasedPreparation(weighting2));
+        instance.addPreparation(createNodeBasedPreparation(weighting1));
+    }
+
+    @Test
+    public void testAddingPreparationsWithEdgeAndNodeBasedIntermixed_works() {
+        instance.addNodeBasedWeighting(weighting1);
+        instance.addEdgeBasedWeighting(weighting1);
+        instance.addPreparation(createEdgeBasedPreparation(weighting1));
+        instance.addPreparation(createNodeBasedPreparation(weighting1));
+    }
+
+    @Test
+    public void testAddingEdgeAndNodeBased_works() {
+        instance.addEdgeBasedWeighting(weighting1);
+        instance.addNodeBasedWeighting(weighting2);
+        instance.addNodeBasedWeighting(weighting1);
+        instance.addEdgeBasedWeighting(weighting2);
+        instance.addEdgeBasedWeighting(weighting3);
+        // we can change the order between edge and node based as long as within each group the weightings have the
+        // right order
+        instance.addPreparation(createEdgeBasedPreparation(weighting1));
+        instance.addPreparation(createNodeBasedPreparation(weighting2));
+        instance.addPreparation(createEdgeBasedPreparation(weighting2));
+        instance.addPreparation(createEdgeBasedPreparation(weighting3));
+        instance.addPreparation(createNodeBasedPreparation(weighting1));
+
+        Weighting[] expectedWeightings = new Weighting[]{weighting1, weighting2, weighting2, weighting3, weighting1};
+        boolean[] expectedEdgedBaseds = new boolean[]{true, false, true, true, false};
+
+        List<PrepareContractionHierarchies> preparations = instance.getPreparations();
+        for (int i = 0; i < preparations.size(); ++i) {
+            assertSame(expectedWeightings[i], preparations.get(i).getWeighting());
+            assertSame(expectedEdgedBaseds[i], preparations.get(i).isEdgeBased());
+        }
+    }
+
+    private PrepareContractionHierarchies createNodeBasedPreparation(Weighting weighting) {
+        return createPreparation(weighting, false);
+    }
+
+    private PrepareContractionHierarchies createEdgeBasedPreparation(Weighting weighting) {
+        return createPreparation(weighting, true);
+    }
+
+    private PrepareContractionHierarchies createPreparation(Weighting weighting, boolean edgedBased) {
+        TraversalMode traversalMode = edgedBased ? EDGE_BASED : NODE_BASED;
+        return PrepareContractionHierarchies.fromGraphHopperStorage(ghStorage, weighting, traversalMode);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
new file mode 100644
index 0000000000..5736f074e0
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/CHTurnCostTest.java
@@ -0,0 +1,1163 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.Repeat;
+import com.graphhopper.RepeatRule;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.*;
+
+import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
+import static com.graphhopper.routing.ch.CHParameters.*;
+import static org.junit.Assert.*;
+
+/**
+ * Here we test if Contraction Hierarchies work with turn costs, i.e. we first contract the graph and then run
+ * routing queries and check if the routing results are correct. We thus test the combination of
+ * {@link EdgeBasedNodeContractor} and {@link DijkstraBidirectionEdgeCHNoSOD}. In most cases we either use a predefined
+ * or random contraction order, so the hard to test and heuristic automatic search for an efficient contraction order
+ * taking place  in {@link PrepareContractionHierarchies} is not covered, but this is ok, because the correctness
+ * of CH should not depend on the contraction order.
+ *
+ * @see EdgeBasedNodeContractor where shortcut creation is tested independent from the routing query
+ */
+public class CHTurnCostTest {
+    private static final Logger LOGGER = LoggerFactory.getLogger(CHTurnCostTest.class);
+    private int maxCost;
+    private CarFlagEncoder encoder;
+    private Weighting weighting;
+    private GraphHopperStorage graph;
+    private TurnCostExtension turnCostExtension;
+    private TurnWeighting turnWeighting;
+    private CHGraph chGraph;
+    private boolean checkStrict;
+
+    @Rule
+    public RepeatRule repeatRule = new RepeatRule();
+
+    @Before
+    public void init() {
+        // its important to use @Before when using Repeat Rule!
+        maxCost = 10;
+        encoder = new CarFlagEncoder(5, 5, maxCost);
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        weighting = new ShortestWeighting(encoder);
+        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+        turnCostExtension = (TurnCostExtension) graph.getExtension();
+        turnWeighting = new TurnWeighting(weighting, turnCostExtension);
+        chGraph = graph.getCHGraph();
+        checkStrict = true;
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testFindPath_randomContractionOrder_linear() {
+        // 2-1-0-3-4
+        graph.edge(2, 1, 2, true);
+        graph.edge(1, 0, 3, true);
+        graph.edge(0, 3, 1, true);
+        graph.edge(3, 4, 3, true);
+        graph.freeze();
+        addTurnCost(2, 1, 0, 2);
+        addTurnCost(0, 3, 4, 4);
+        checkPathUsingRandomContractionOrder(IntArrayList.from(2, 1, 0, 3, 4), 9, 6, 2, 4);
+    }
+
+    @Test
+    public void testFindPath_randomContractionOrder_duplicate_edges() {
+        //  /\    /<-3
+        // 0  1--2
+        //  \/    \->4
+        graph.edge(0, 1, 5, true);
+        graph.edge(0, 1, 6, true);
+        graph.edge(1, 2, 2, true);
+        graph.edge(3, 2, 3, false);
+        graph.edge(2, 4, 3, false);
+        addRestriction(3, 2, 4);
+        graph.freeze();
+        compareCHWithDijkstra(10, Arrays.asList(0, 1, 2, 3, 4));
+    }
+
+    @Test
+    public void testFindPath_randomContractionOrder_double_duplicate_edges() {
+        //  /\ /\   
+        // 0  1  2--3
+        //  \/ \/
+        graph.edge(0, 1, 25.789000, true);
+        graph.edge(0, 1, 26.016000, true);
+        graph.edge(1, 2, 21.902000, true);
+        graph.edge(1, 2, 21.862000, true);
+        graph.edge(2, 3, 52.987000, true);
+        graph.freeze();
+        compareCHWithDijkstra(1000, Arrays.asList(0, 1, 2, 3));
+    }
+
+    @Test
+    @Repeat(times = 100)
+    public void testFindPath_multipleInOutEdges_turnReplacementDifference() {
+        //   0   3 - 4   8
+        //    \ /     \ /
+        // 1 - 5 - 6 - 7 - 9
+        //    /         \
+        //   2           10
+        // When we contract node 6, 'normally' a shortcut would be expected using nodes 3 and 4, but this strongly depends
+        // on the turn restrictions of the in/outcoming edges. Basically a shortcut is only needed if 5, 6, 7 is part of
+        // the shortest path between an incoming source edge x-5 and an outgoing target edge 7-y. 
+        // To cover all or at least as many as possible different cases we randomly apply some restrictions and compare
+        // the resulting query with a standard Dijkstra search.
+        // If this test fails use the logger output to generate code for further debugging.
+        graph.edge(0, 5, 1, false);
+        graph.edge(1, 5, 1, false);
+        graph.edge(2, 5, 1, false);
+        graph.edge(5, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(4, 7, 1, false);
+        graph.edge(5, 6, 3, false);
+        graph.edge(6, 7, 3, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(7, 9, 1, false);
+        graph.edge(7, 10, 1, false);
+
+        long seed = System.nanoTime();
+        Random rnd = new Random(seed);
+        LOGGER.info("Seed used to generate turn costs and restrictions: {}", seed);
+        addRandomCost(2, 5, 3, rnd);
+        addRandomCost(2, 5, 6, rnd);
+        addRandomCost(4, 7, 10, rnd);
+        addRandomCost(6, 7, 10, rnd);
+        addRandomCostOrRestriction(0, 5, 3, rnd);
+        addRandomCostOrRestriction(1, 5, 3, rnd);
+        addRandomCostOrRestriction(0, 5, 6, rnd);
+        addRandomCostOrRestriction(1, 5, 6, rnd);
+        addRandomCostOrRestriction(4, 7, 8, rnd);
+        addRandomCostOrRestriction(4, 7, 9, rnd);
+        addRandomCostOrRestriction(6, 7, 8, rnd);
+        addRandomCostOrRestriction(6, 7, 9, rnd);
+
+        RoutingAlgorithmFactory factory = prepareCH(Arrays.asList(6, 0, 1, 2, 8, 9, 10, 5, 3, 4, 7));
+        // run queries for all cases (target/source edge possibly restricted/has costs)
+        checkStrict = false;
+        compareCHQueryWithDijkstra(factory, 2, 10);
+        compareCHQueryWithDijkstra(factory, 1, 10);
+        compareCHQueryWithDijkstra(factory, 2, 9);
+        compareCHQueryWithDijkstra(factory, 1, 9);
+    }
+
+    @Test
+    public void testFindPath_multipleInOutEdges_turnReplacementDifference_bug1() {
+        //       3 - 4
+        //      /     \
+        // 1 - 5 - 6 - 7 - 9
+        //    /         \
+        //   2           10
+        graph.edge(1, 5, 1, false);
+        graph.edge(2, 5, 1, false);
+        graph.edge(5, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(4, 7, 1, false);
+        graph.edge(5, 6, 3, false);
+        graph.edge(6, 7, 3, false);
+        graph.edge(7, 9, 1, false);
+        graph.edge(7, 10, 1, false);
+
+        addTurnCost(2, 5, 6, 4);
+        addRestriction(1, 5, 6);
+        addRestriction(4, 7, 9);
+
+        RoutingAlgorithmFactory factory = prepareCH(Arrays.asList(6, 0, 1, 2, 8, 9, 10, 5, 3, 4, 7));
+        compareCHQueryWithDijkstra(factory, 2, 9);
+    }
+
+    @Test
+    public void testFindPath_duplicateEdge() {
+        // 0 -> 1 -> 2 -> 3 -> 4
+        //            \->/
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        List<Integer> contractionOrder = Arrays.asList(2, 3, 0, 4, 1);
+        compareCHWithDijkstra(100, contractionOrder);
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testFindPath_randomContractionOrder_simpleLoop() {
+        //      2
+        //     /|
+        //  0-4-3
+        //    |
+        //    1
+        graph.edge(0, 4, 2, false);
+        graph.edge(4, 3, 2, true);
+        graph.edge(3, 2, 1, true);
+        graph.edge(2, 4, 1, true);
+        graph.edge(4, 1, 1, false);
+        graph.freeze();
+
+        // enforce loop (going counter-clockwise)
+        addRestriction(0, 4, 1);
+        addTurnCost(4, 2, 3, 4);
+        addTurnCost(3, 2, 4, 2);
+
+        checkPathUsingRandomContractionOrder(IntArrayList.from(0, 4, 3, 2, 4, 1), 7, 2, 0, 1);
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testFindPath_randomContractionOrder_singleDirectedLoop() {
+        //  3 1-2
+        //  | | |
+        //  7-5-0
+        //    |
+        //    6-4
+        graph.edge(3, 7, 1, false);
+        graph.edge(7, 5, 2, false);
+        graph.edge(5, 0, 2, false);
+        graph.edge(0, 2, 1, false);
+        graph.edge(2, 1, 2, false);
+        graph.edge(1, 5, 1, false);
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 4, 2, false);
+        graph.freeze();
+
+        addRestriction(7, 5, 6);
+        addTurnCost(0, 2, 1, 2);
+
+        final IntArrayList expectedPath = IntArrayList.from(3, 7, 5, 0, 2, 1, 5, 6, 4);
+        final int roadCosts = 12;
+        final int turnCosts = 2;
+
+        checkPathUsingRandomContractionOrder(expectedPath, roadCosts, turnCosts, 3, 4);
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testFindPath_randomContractionOrder_singleLoop() {
+        //  0   4
+        //  |  /|
+        //  1-2-3
+        //    |
+        //    5-6
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 2, false);
+        graph.edge(2, 3, 2, true);
+        graph.edge(3, 4, 1, true);
+        graph.edge(4, 2, 1, true);
+        graph.edge(2, 5, 1, false);
+        graph.edge(5, 6, 2, false);
+        graph.freeze();
+
+        // enforce loop (going counter-clockwise)
+        addRestriction(1, 2, 5);
+        addTurnCost(3, 4, 2, 2);
+        addTurnCost(2, 4, 3, 4);
+
+        final IntArrayList expectedPath = IntArrayList.from(0, 1, 2, 3, 4, 2, 5, 6);
+        final int roadCosts = 10;
+        final int turnCosts = 2;
+
+        checkPathUsingRandomContractionOrder(expectedPath, roadCosts, turnCosts, 0, 6);
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testFindPath_randomContractionOrder_singleLoopWithNoise() {
+        //  0~15~16~17              solid lines: paths contributing to shortest path from 0 to 14
+        //  |        {              wiggly lines: extra paths to make it more complicated
+        //  1~ 2- 3~ 4
+        //  |  |  |  {
+        //  6- 7- 8  9
+        //  }  |  }  }
+        // 11~12-13-14
+
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 6, 1, true);
+        graph.edge(6, 7, 2, true);
+        graph.edge(7, 8, 2, true);
+        graph.edge(8, 3, 1, true);
+        graph.edge(3, 2, 2, true);
+        graph.edge(2, 7, 1, true);
+        graph.edge(7, 12, 1, true);
+        graph.edge(12, 13, 2, true);
+        graph.edge(13, 14, 2, true);
+
+        // some more edges to make it more complicated -> potentially find more bugs
+        graph.edge(1, 2, 8, true);
+        graph.edge(6, 11, 3, true);
+        graph.edge(11, 12, 50, true);
+        graph.edge(8, 13, 1, true);
+        graph.edge(0, 15, 1, true);
+        graph.edge(15, 16, 2, true);
+        graph.edge(16, 17, 3, true);
+        graph.edge(17, 4, 2, true);
+        graph.edge(3, 4, 2, true);
+        graph.edge(4, 9, 1, true);
+        graph.edge(9, 14, 2, true);
+        graph.freeze();
+
+        // enforce loop (going counter-clockwise)
+        addRestriction(6, 7, 12);
+        addTurnCost(8, 3, 2, 2);
+        addTurnCost(2, 3, 8, 4);
+
+        // make alternative paths not worth it
+        addTurnCost(1, 2, 7, 3);
+        addTurnCost(7, 8, 13, 8);
+        addTurnCost(8, 13, 14, 7);
+        addTurnCost(16, 17, 4, 4);
+        addTurnCost(4, 9, 14, 3);
+        addTurnCost(3, 4, 9, 3);
+
+        final IntArrayList expectedPath = IntArrayList.from(0, 1, 6, 7, 8, 3, 2, 7, 12, 13, 14);
+        final int roadCosts = 15;
+        final int turnCosts = 2;
+
+        checkPathUsingRandomContractionOrder(expectedPath, roadCosts, turnCosts, 0, 14);
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testFindPath_randomContractionOrder_complicatedGraphAndPath() {
+        // In this test we try to find a rather complicated shortest path including a double loop and two p-turns
+        // with several turn restrictions and turn costs.
+
+        //  0              solid lines: paths contributing to shortest path from 0 to 26
+        //  |              wiggly lines: extra paths to make it more complicated
+        //  1~ 2- 3<~4- 5
+        //   \ |  |  |  |
+        //  6->7->8~ 9-10
+        //  |  |\    |
+        // 11-12 13-14~15~27
+        //     {  {  |     }
+        // 16-17-18-19-20~28
+        //  |  {  {  |  |  }
+        // 21-22-23-24 25-26
+
+        // first we add all edges that contribute to the shortest path, verticals: cost=1, horizontals: cost=2
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 7, 3, true);
+        graph.edge(7, 8, 2, false);
+        graph.edge(8, 3, 1, true);
+        graph.edge(3, 2, 2, true);
+        graph.edge(2, 7, 1, true);
+        graph.edge(7, 12, 1, true);
+        graph.edge(12, 11, 2, true);
+        graph.edge(11, 6, 1, true);
+        graph.edge(6, 7, 2, false);
+        graph.edge(7, 13, 3, true);
+        graph.edge(13, 14, 2, true);
+        graph.edge(14, 9, 1, true);
+        graph.edge(9, 4, 1, true);
+        graph.edge(4, 5, 2, true);
+        graph.edge(5, 10, 1, true);
+        graph.edge(10, 9, 2, true);
+        graph.edge(14, 19, 1, true);
+        graph.edge(19, 18, 2, true);
+        graph.edge(18, 17, 2, true);
+        graph.edge(17, 16, 2, true);
+        graph.edge(16, 21, 1, true);
+        graph.edge(21, 22, 2, true);
+        graph.edge(22, 23, 2, true);
+        graph.edge(23, 24, 2, true);
+        graph.edge(24, 19, 1, true);
+        graph.edge(19, 20, 2, true);
+        graph.edge(20, 25, 1, true);
+        graph.edge(25, 26, 2, true);
+
+        //some more edges to make it more complicated -> potentially find more bugs
+        graph.edge(1, 2, 1, true);
+        graph.edge(4, 3, 1, false);
+        graph.edge(8, 9, 75, true);
+        graph.edge(17, 22, 9, true);
+        graph.edge(18, 23, 15, true);
+        graph.edge(12, 17, 50, true);
+        graph.edge(13, 18, 80, true);
+        graph.edge(14, 15, 3, true);
+        graph.edge(15, 27, 2, true);
+        graph.edge(27, 28, 100, true);
+        graph.edge(28, 26, 1, true);
+        graph.edge(20, 28, 1, true);
+        graph.freeze();
+
+        // enforce figure of eight curve at node 7
+        addRestriction(1, 7, 13);
+        addTurnCost(1, 7, 12, 7);
+        addTurnCost(2, 7, 13, 7);
+
+        // enforce p-loop at the top right (going counter-clockwise)
+        addRestriction(13, 14, 19);
+        addTurnCost(4, 5, 10, 3);
+        addTurnCost(10, 5, 4, 2);
+
+        // enforce big p-loop at bottom left (going clockwise)
+        addRestriction(14, 19, 20);
+        addTurnCost(17, 16, 21, 3);
+
+        // make some alternative paths not worth it
+        addTurnCost(1, 2, 7, 8);
+        addTurnCost(20, 28, 26, 3);
+
+        // add some more turn costs on the shortest path
+        addTurnCost(7, 13, 14, 2);
+
+        // expected costs of the shortest path
+        final IntArrayList expectedPath = IntArrayList.from(
+                0, 1, 7, 8, 3, 2, 7, 12, 11, 6, 7, 13, 14, 9, 10, 5, 4, 9, 14, 19, 24, 23, 22, 21, 16, 17, 18, 19, 20, 25, 26);
+        final int roadCosts = 49;
+        final int turnCosts = 4;
+
+        checkPathUsingRandomContractionOrder(expectedPath, roadCosts, turnCosts, 0, 26);
+    }
+
+    @Test
+    public void testFindPath_pTurn_uTurnAtContractedNode() {
+        // when contracting node 4 we need a loop shortcut at node 6
+        //           2- 3
+        //           |  |
+        //           4- 0
+        //           |
+        //     5 ->  6 -> 1
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 1, 1, false);
+        graph.edge(6, 4, 1, true);
+        graph.edge(4, 0, 1, false);
+        graph.edge(0, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.freeze();
+        addRestriction(5, 6, 1);
+
+        final IntArrayList expectedPath = IntArrayList.from(5, 6, 4, 0, 3, 2, 4, 6, 1);
+        checkPath(expectedPath, 8, 0, 5, 1, Arrays.asList(0, 1, 2, 3, 4, 5, 6));
+    }
+
+
+    @Test
+    public void testFindPath_pTurn_uTurnAtContractedNode_twoShortcutsInAndOut() {
+        //           2- 3
+        //           |  |
+        //           4- 0
+        //           |
+        //           1
+        //           |
+        //     5 ->  6 -> 7
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 7, 1, false);
+        graph.edge(6, 1, 1, true);
+        graph.edge(1, 4, 1, true);
+        graph.edge(4, 0, 1, false);
+        graph.edge(0, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.freeze();
+        addRestriction(5, 6, 7);
+
+        final IntArrayList expectedPath = IntArrayList.from(5, 6, 1, 4, 0, 3, 2, 4, 1, 6, 7);
+        checkPath(expectedPath, 10, 0, 5, 7, Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7));
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testFindPath_highlyConnectedGraph_compareWithDijkstra() {
+        // In this test we use a random contraction order and run many random routing queries. The results are checked
+        // by comparing them to the results of a standard dijkstra search.
+        // If a test fails use the debug output to generate the graph creation code for further debugging!
+
+        // 0 - 1 - 2  example for size=3
+        // | x | x |
+        // 3 - 4 - 5
+        // | x | x |
+        // 6 - 7 - 8
+        // for large sizes contraction takes very long because there are so many edges
+        final int size = 4;
+        final int maxDist = 4;
+        final int numQueries = 1000;
+        long seed = System.nanoTime();
+        LOGGER.info("Seed used to generate graph: {}", seed);
+        final Random rnd = new Random(seed);
+
+        int edgeCounter = 0;
+        // horizontal edges
+        for (int i = 0; i < size; ++i) {
+            for (int j = 0; j < size - 1; ++j) {
+                final int from = i * size + j;
+                final int to = from + 1;
+                final double dist = nextDist(maxDist, rnd);
+                graph.edge(from, to, dist, true);
+                LOGGER.trace("final EdgeIteratorState edge{} = graph.edge({},{},{},true);", edgeCounter++, from, to, dist);
+            }
+        }
+        // vertical edges
+        for (int i = 0; i < size - 1; ++i) {
+            for (int j = 0; j < size; ++j) {
+                final int from = i * size + j;
+                final int to = from + size;
+                double dist = nextDist(maxDist, rnd);
+                graph.edge(from, to, dist, true);
+                LOGGER.trace("final EdgeIteratorState edge{} = graph.edge({},{},{},true);", edgeCounter++, from, to, dist);
+            }
+        }
+        // diagonal edges
+        for (int i = 0; i < size - 1; ++i) {
+            for (int j = 0; j < size; ++j) {
+                final int from = i * size + j;
+                if (j < size - 1) {
+                    final double dist = nextDist(maxDist, rnd);
+                    final int to = from + size + 1;
+                    graph.edge(from, to, dist, true);
+                    LOGGER.trace("final EdgeIteratorState edge{} = graph.edge({},{},{},true);", edgeCounter++, from, to, dist);
+                }
+                if (j > 0) {
+                    final double dist = nextDist(maxDist, rnd);
+                    final int to = from + size - 1;
+                    graph.edge(from, to, dist, true);
+                    LOGGER.trace("final EdgeIteratorState edge{} = graph.edge({},{},{},true);", edgeCounter++, from, to, dist);
+                }
+            }
+        }
+        graph.freeze();
+        EdgeExplorer inExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder));
+        EdgeExplorer outExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder));
+
+        // add turn costs or restrictions
+        for (int node = 0; node < size * size; ++node) {
+            EdgeIterator inIter = inExplorer.setBaseNode(node);
+            while (inIter.next()) {
+                EdgeIterator outIter = outExplorer.setBaseNode(node);
+                while (outIter.next()) {
+                    // do not modify u-turn costs
+                    if (inIter.getEdge() == outIter.getEdge()) {
+                        continue;
+                    }
+                    int cost = nextCost(rnd);
+                    addCostOrRestriction(inIter, outIter, node, cost);
+                }
+            }
+        }
+
+        List<Integer> contractionOrder = getRandomIntegerSequence(chGraph.getNodes(), rnd);
+        checkStrict = false;
+        compareCHWithDijkstra(numQueries, contractionOrder);
+    }
+
+    @Test
+    public void testFindPath_bug() {
+        graph.edge(1, 2, 18.364000, false);
+        graph.edge(1, 4, 29.814000, true);
+        graph.edge(0, 2, 14.554000, true);
+        graph.edge(1, 4, 29.819000, true);
+        graph.edge(1, 3, 29.271000, true);
+        addRestriction(3, 1, 2);
+        graph.freeze();
+
+        List<Integer> contractionOrder = Arrays.asList(1, 0, 3, 2, 4);
+        compareCHWithDijkstra(100, contractionOrder);
+    }
+
+    @Test
+    public void testFindPath_bug2() {
+        graph.edge(0, 3, 24.001000, true);
+        graph.edge(0, 1, 6.087000, true);
+        graph.edge(0, 1, 6.067000, true);
+        graph.edge(2, 3, 46.631000, true);
+        graph.edge(2, 4, 46.184000, true);
+        graph.freeze();
+
+        List<Integer> contractionOrder = Arrays.asList(1, 0, 3, 2, 4);
+        compareCHWithDijkstra(1000, contractionOrder);
+    }
+
+    @Test
+    public void testFindPath_loop() {
+        //             3
+        //            / \
+        //           1   2
+        //            \ /
+        // 0 - 7 - 8 - 4 - 6 - 5
+        graph.edge(0, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(8, 4, 1, false);
+        graph.edge(4, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(3, 2, 1, false);
+        graph.edge(2, 4, 1, false);
+        graph.edge(4, 6, 1, false);
+        graph.edge(6, 5, 1, false);
+        addRestriction(8, 4, 6);
+        graph.freeze();
+
+        RoutingAlgorithmFactory factory = prepareCH(Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8));
+        compareCHQueryWithDijkstra(factory, 0, 5);
+    }
+
+    @Test
+    public void testFindPath_calcTurnCostTime() {
+        // here there will be a shortcut from 1 to 4 and when the path is unpacked it is important that
+        // the turn costs are included at node 1 even though the unpacked original edge 1-0 might be in the
+        // reverted state
+        // 2-1--3
+        //   |  |
+        //   0->4
+        EdgeIteratorState edge0 = graph.edge(1, 2, 1, true);
+        EdgeIteratorState edge1 = graph.edge(0, 4, 1, false);
+        EdgeIteratorState edge2 = graph.edge(4, 3, 1, true);
+        EdgeIteratorState edge3 = graph.edge(1, 3, 1, true);
+        EdgeIteratorState edge4 = graph.edge(1, 0, 1, true);
+        addTurnCost(edge0, edge4, 1, 8);
+        addRestriction(edge0, edge3, 1);
+        graph.freeze();
+        checkPath(IntArrayList.from(2, 1, 0, 4), 3, 8, 2, 4, Arrays.asList(2, 0, 1, 3, 4));
+    }
+
+    @Test
+    public void testFindPath_loopsMustAlwaysBeAccepted() {
+        //     ---
+        //     \ /
+        // 0 -- 1 -- 2 -- 3
+        EdgeIteratorState edge0 = graph.edge(0, 1, 1, true);
+        EdgeIteratorState edge1 = graph.edge(1, 1, 1, false);
+        EdgeIteratorState edge2 = graph.edge(1, 2, 1, true);
+        EdgeIteratorState edge3 = graph.edge(2, 3, 1, false);
+        addTurnCost(edge0, edge1, 1, 1);
+        addRestriction(edge0, edge2, 1);
+        graph.freeze();
+        final IntArrayList expectedPath = IntArrayList.from(0, 1, 1, 2, 3);
+        checkPath(expectedPath, 4, 1, 0, 3, Arrays.asList(0, 2, 1, 3));
+    }
+
+    @Test
+    public void testFindPath_compareWithDijkstra_zeroWeightLoops_random() {
+        graph.edge(5, 3, 21.329000, false);
+        graph.edge(4, 5, 29.126000, false);
+        graph.edge(1, 0, 38.865000, false);
+        graph.edge(1, 4, 80.005000, false);
+        graph.edge(3, 1, 91.023000, false);
+        // add loops with zero weight ...
+        graph.edge(1, 1, 0.000000, false);
+        graph.edge(1, 1, 0.000000, false);
+        graph.freeze();
+        automaticCompareCHWithDijkstra(100);
+    }
+
+    @Test
+    public void testFindPath_compareWithDijkstra_zeroWeightLoops() {
+        //                  /|
+        // 0 -> 1 -> 2 -> 3 --
+        //                | \|
+        //                4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        IntArrayList expectedPath = IntArrayList.from(0, 1, 2, 3, 4);
+        List<Integer> contractionOrder = Arrays.asList(2, 0, 4, 1, 3);
+        checkPath(expectedPath, 4, 0, 0, 4, contractionOrder);
+    }
+
+    @Test
+    public void testFindPath_compareWithDijkstra_zeroWeightLoops_withTurnRestriction() {
+        //                  /|
+        // 0 -> 1 -> 2 -> 3 --
+        //                | \|
+        //                4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        EdgeIteratorState edge2 = graph.edge(2, 3, 1, false);
+        EdgeIteratorState edge3 = graph.edge(3, 3, 0, false);
+        EdgeIteratorState edge4 = graph.edge(3, 3, 0, false);
+        EdgeIteratorState edge5 = graph.edge(3, 4, 1, false);
+        addTurnCost(edge2, edge3, 3, 5);
+        addTurnCost(edge2, edge4, 3, 4);
+        addTurnCost(edge3, edge4, 3, 2);
+        addRestriction(edge2, edge5, 3);
+        graph.freeze();
+        IntArrayList expectedPath = IntArrayList.from(0, 1, 2, 3, 3, 4);
+        List<Integer> contractionOrder = Arrays.asList(2, 0, 4, 1, 3);
+        checkPath(expectedPath, 4, 4, 0, 4, contractionOrder);
+    }
+
+    @Test
+    public void testFindPath_oneWayLoop() {
+        //     o
+        // 0-1-2-3-4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        addRestriction(1, 2, 3);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        compareCHQueryWithDijkstra(pch, 0, 3);
+        compareCHQueryWithDijkstra(pch, 1, 4);
+        automaticCompareCHWithDijkstra(100);
+    }
+
+    @Test
+    public void testFindPath_loopEdge() {
+        // 1-0
+        // | |
+        // 4-2o
+        graph.edge(1, 0, 802.964000, false);
+        graph.edge(1, 4, 615.195000, true);
+        graph.edge(2, 2, 181.788000, true);
+        graph.edge(0, 2, 191.996000, true);
+        graph.edge(2, 4, 527.821000, false);
+        addRestriction(0, 2, 4);
+        addTurnCost(0, 2, 2, 3);
+        addTurnCost(2, 2, 4, 4);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        compareCHQueryWithDijkstra(pch, 0, 4);
+    }
+
+    @Test
+    public void test_issue1593_full() {
+        //      6   5
+        //   1<-x-4-x-3
+        //  ||    |
+        //  |x7   x8
+        //  ||   /
+        //   2---
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 49.407117, 9.701306);
+        na.setNode(1, 49.406914, 9.703393);
+        na.setNode(2, 49.404004, 9.709110);
+        na.setNode(3, 49.400160, 9.708787);
+        na.setNode(4, 49.400883, 9.706347);
+        EdgeIteratorState edge0 = graph.edge(4, 3, 194.063000, true);
+        EdgeIteratorState edge1 = graph.edge(1, 2, 525.106000, true);
+        EdgeIteratorState edge2 = graph.edge(1, 2, 525.106000, true);
+        EdgeIteratorState edge3 = graph.edge(4, 1, 703.778000, false);
+        EdgeIteratorState edge4 = graph.edge(2, 4, 400.509000, true);
+        // cannot go 4-2-1 and 1-2-4 (at least when using edge1, there is still edge2!)
+        addRestriction(edge4, edge1, 2);
+        addRestriction(edge1, edge4, 2);
+        // cannot go 3-4-1
+        addRestriction(edge0, edge3, 4);
+        graph.freeze();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        List<GHPoint> points = Arrays.asList(
+                // 8 (on edge4)
+                new GHPoint(49.401669187194116, 9.706821649608745),
+                // 5 (on edge0)
+                new GHPoint(49.40056349818417, 9.70767186472369),
+                // 7 (on edge2)
+                new GHPoint(49.406580835146556, 9.704665738628218),
+                // 6 (on edge3)
+                new GHPoint(49.40107534698834, 9.702248694088528)
+        );
+
+        List<QueryResult> queryResults = new ArrayList<>(points.size());
+        for (GHPoint point : points) {
+            queryResults.add(index.findClosest(point.getLat(), point.getLon(), EdgeFilter.ALL_EDGES));
+        }
+
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+        queryGraph.lookup(queryResults);
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED)
+                .build());
+        Path path = chAlgo.calcPath(5, 6);
+        // there should not be a path from 5 to 6, because first we cannot go directly 5-4-6, so we need to go left
+        // to 8. then at 2 we cannot go on edge 1 because of another turn restriction, but we can go on edge 2 so we
+        // travel via the virtual node 7 to node 1. From there we cannot go to 6 because of the one-way so we go back
+        // to node 2 (no u-turn because of the duplicate edge) on edge1. And this is were the journey ends: we cannot
+        // go to 8 because of the turn restriction from edge1 to edge4 -> there should not be a path!
+        assertFalse("there should not be a path, but found: " + path.calcNodes(), path.isFound());
+    }
+
+    @Test
+    public void test_issue_1593_simple() {
+        // 1
+        // |
+        // 3-0-x-5-4
+        // |
+        // 2
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(1, 0.2, 0.0);
+        na.setNode(3, 0.1, 0.0);
+        na.setNode(2, 0.0, 0.0);
+        na.setNode(0, 0.1, 0.1);
+        na.setNode(5, 0.1, 0.2);
+        na.setNode(4, 0.1, 0.3);
+        EdgeIteratorState edge0 = graph.edge(3, 1, 10, true);
+        EdgeIteratorState edge1 = graph.edge(2, 3, 10, true);
+        graph.edge(3, 0, 10, true);
+        graph.edge(0, 5, 10, true);
+        graph.edge(5, 4, 10, true);
+        // cannot go, 2-3-1
+        addRestriction(edge1, edge0, 3);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = prepareCH(Arrays.asList(0, 1, 2, 3, 4, 5));
+        assertEquals(5, chGraph.getOriginalEdges());
+        assertEquals("expected two shortcuts: 3->5 and 5->3", 7, chGraph.getEdges());
+        // there should be no path from 2 to 1, because of the turn restriction and because u-turns are not allowed
+        assertFalse(findPathUsingDijkstra(2, 1).isFound());
+        compareCHQueryWithDijkstra(pch, 2, 1);
+
+        // we have to pay attention when there are virtual nodes: turning from the shortcut 3-5 onto the
+        // virtual edge 5-x should be forbidden.
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr = index.findClosest(0.1, 0.15, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+        queryGraph.lookup(Collections.singletonList(qr));
+        assertEquals("expected one virtual node", 1, queryGraph.getNodes() - chGraph.getNodes());
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED)
+                .build());
+        Path path = chAlgo.calcPath(2, 1);
+        assertFalse("no path should be found, but found " + path.calcNodes(), path.isFound());
+    }
+
+    @Test
+    public void test_issue_1623_query_graph_cache() {
+        // 4-2->5-3
+        NodeAccess na = graph.getNodeAccess();
+        na.setNode(0, 49.408550, 9.701805);
+        na.setNode(1, 49.405988, 9.706111);
+        na.setNode(2, 49.400772, 9.706245);
+        na.setNode(3, 49.403167, 9.704774);
+        na.setNode(4, 49.405817, 9.704301);
+        na.setNode(5, 49.402488, 9.707799);
+        graph.edge(2, 5, 222.771000, false);
+        graph.edge(4, 2, 583.496000, true);
+        graph.edge(3, 5, 231.495000, true);
+        graph.freeze();
+
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr1 = index.findClosest(49.400772, 9.706245, EdgeFilter.ALL_EDGES);
+        QueryResult qr2 = index.findClosest(49.403167, 9.704774, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+
+        // before fixing #1623 this test only worked for a disabled edge explorer cache
+        queryGraph.setUseEdgeExplorerCache(true);
+
+        queryGraph.lookup(Arrays.asList(qr1, qr2));
+        assertEquals(2, qr1.getClosestNode());
+        assertEquals(3, qr2.getClosestNode());
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED)
+                .build());
+        Path path = chAlgo.calcPath(2, 3);
+        assertTrue("no path found", path.isFound());
+        assertEquals(IntArrayList.from(2, 5, 3), path.calcNodes());
+        assertEquals(454.266, path.getDistance(), 1.e-1);
+    }
+
+    @Test
+    public void testRouteViaVirtualNode() {
+        //   3
+        // 0-x-1-2
+        graph.edge(0, 1, 0, false);
+        graph.edge(1, 2, 0, false);
+        updateDistancesFor(graph, 0, 0.00, 0.00);
+        updateDistancesFor(graph, 1, 0.02, 0.02);
+        updateDistancesFor(graph, 2, 0.03, 0.03);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr = index.findClosest(0.01, 0.01, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+        queryGraph.lookup(Collections.singletonList(qr));
+        assertEquals(3, qr.getClosestNode());
+        assertEquals(0, qr.getClosestEdge().getEdge());
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED)
+                .build());
+        Path path = chAlgo.calcPath(0, 2);
+        assertTrue("it should be possible to route via a virtual node, but no path found", path.isFound());
+        assertEquals(IntArrayList.from(0, 3, 1, 2), path.calcNodes());
+        assertEquals(Helper.DIST_PLANE.calcDist(0.00, 0.00, 0.03, 0.03), path.getDistance(), 1.e-1);
+    }
+
+    @Test
+    public void testRouteViaVirtualNode_withAlternative() {
+        //   3
+        // 0-x-1
+        //  \  |
+        //   \-2
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 0, 1, true);
+        updateDistancesFor(graph, 0, 0.01, 0.00);
+        updateDistancesFor(graph, 1, 0.01, 0.02);
+        updateDistancesFor(graph, 2, 0.00, 0.02);
+        graph.freeze();
+        RoutingAlgorithmFactory pch = automaticPrepareCH();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.prepareIndex();
+        QueryResult qr = index.findClosest(0.01, 0.01, EdgeFilter.ALL_EDGES);
+        QueryGraph queryGraph = new QueryGraph(chGraph);
+        queryGraph.lookup(Collections.singletonList(qr));
+        assertEquals(3, qr.getClosestNode());
+        assertEquals(0, qr.getClosestEdge().getEdge());
+        RoutingAlgorithm chAlgo = pch.createAlgo(queryGraph, AlgorithmOptions.start()
+                .traversalMode(TraversalMode.EDGE_BASED)
+                .build());
+        Path path = chAlgo.calcPath(1, 0);
+        assertEquals(IntArrayList.from(1, 3, 0), path.calcNodes());
+    }
+
+    /**
+     * This test runs on a random graph with random turn costs and a predefined (but random) contraction order.
+     * It often produces exotic conditions that are hard to anticipate beforehand.
+     * when it fails use {@link GHUtility#printGraphForUnitTest} to extract the graph and reproduce the error.
+     */
+    @Repeat(times = 10)
+    @Test
+    public void testFindPath_random_compareWithDijkstra() {
+        long seed = System.nanoTime();
+        LOGGER.info("Seed used to generate graph: {}", seed);
+        final Random rnd = new Random(seed);
+        // for larger graphs preparation takes much longer the higher the degree is!
+        GHUtility.buildRandomGraph(graph, rnd, 20, 3.0, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, 0.8);
+        GHUtility.addRandomTurnCosts(graph, seed, encoder, maxCost, turnCostExtension);
+        graph.freeze();
+        checkStrict = false;
+        List<Integer> contractionOrder = getRandomIntegerSequence(chGraph.getNodes(), rnd);
+        compareCHWithDijkstra(100, contractionOrder);
+    }
+
+    /**
+     * same as {@link #testFindPath_random_compareWithDijkstra()}, but using automatic node priority calculation
+     */
+    @Repeat(times = 10)
+    @Test
+    public void testFindPath_heuristic_compareWithDijkstra() {
+        long seed = System.nanoTime();
+        LOGGER.info("Seed used to generate graph: {}", seed);
+        GHUtility.buildRandomGraph(graph, new Random(seed), 20, 3.0, true, true, encoder.getAverageSpeedEnc(), 0.7, 0.9, 0.8);
+        GHUtility.addRandomTurnCosts(graph, seed, encoder, maxCost, turnCostExtension);
+        graph.freeze();
+        checkStrict = false;
+        automaticCompareCHWithDijkstra(100);
+    }
+
+    private int nextCost(Random rnd) {
+        // choose bound above max cost such that turn restrictions are likely
+        return rnd.nextInt(3 * maxCost);
+    }
+
+    private double nextDist(int maxDist, Random rnd) {
+        return rnd.nextDouble() * maxDist;
+    }
+
+    private void checkPathUsingRandomContractionOrder(IntArrayList expectedPath, int expectedWeight, int expectedTurnCosts, int from, int to) {
+        List<Integer> contractionOrder = getRandomIntegerSequence(chGraph.getNodes());
+        checkPath(expectedPath, expectedWeight, expectedTurnCosts, from, to, contractionOrder);
+    }
+
+    private void checkPath(IntArrayList expectedPath, int expectedEdgeWeight, int expectedTurnCosts, int from, int to, List<Integer> contractionOrder) {
+        checkPathUsingDijkstra(expectedPath, expectedEdgeWeight, expectedTurnCosts, from, to);
+        checkPathUsingCH(expectedPath, expectedEdgeWeight, expectedTurnCosts, from, to, contractionOrder);
+    }
+
+    private void checkPathUsingDijkstra(IntArrayList expectedPath, int expectedEdgeWeight, int expectedTurnCosts, int from, int to) {
+        Path dijkstraPath = findPathUsingDijkstra(from, to);
+        int expectedWeight = expectedEdgeWeight + expectedTurnCosts;
+        int expectedDistance = expectedEdgeWeight;
+        int expectedTime = expectedEdgeWeight * 60 + expectedTurnCosts * 1000;
+        assertEquals("Normal Dijkstra did not find expected path.", expectedPath, dijkstraPath.calcNodes());
+        assertEquals("Normal Dijkstra did not calculate expected weight.", expectedWeight, dijkstraPath.getWeight(), 1.e-6);
+        assertEquals("Normal Dijkstra did not calculate expected distance.", expectedDistance, dijkstraPath.getDistance(), 1.e-6);
+        assertEquals("Normal Dijkstra did not calculate expected time.", expectedTime, dijkstraPath.getTime(), 1.e-6);
+    }
+
+    private void checkPathUsingCH(IntArrayList expectedPath, int expectedEdgeWeight, int expectedTurnCosts, int from, int to, List<Integer> contractionOrder) {
+        Path chPath = findPathUsingCH(from, to, contractionOrder);
+        int expectedWeight = expectedEdgeWeight + expectedTurnCosts;
+        int expectedDistance = expectedEdgeWeight;
+        int expectedTime = expectedEdgeWeight * 60 + expectedTurnCosts * 1000;
+        assertEquals("Contraction Hierarchies did not find expected path. contraction order=" + contractionOrder, expectedPath, chPath.calcNodes());
+        assertEquals("Contraction Hierarchies did not calculate expected weight.", expectedWeight, chPath.getWeight(), 1.e-6);
+        assertEquals("Contraction Hierarchies did not calculate expected distance.", expectedDistance, chPath.getDistance(), 1.e-6);
+        assertEquals("Contraction Hierarchies did not calculate expected time.", expectedTime, chPath.getTime(), 1.e-6);
+    }
+
+    private Path findPathUsingDijkstra(int from, int to) {
+        Dijkstra dijkstra = new Dijkstra(graph, turnWeighting, TraversalMode.EDGE_BASED);
+        return dijkstra.calcPath(from, to);
+    }
+
+    private Path findPathUsingCH(int from, int to, List<Integer> contractionOrder) {
+        RoutingAlgorithmFactory routingAlgorithmFactory = prepareCH(contractionOrder);
+        RoutingAlgorithm chAlgo = routingAlgorithmFactory.createAlgo(chGraph, AlgorithmOptions.start().build());
+        return chAlgo.calcPath(from, to);
+    }
+
+    private RoutingAlgorithmFactory prepareCH(final List<Integer> contractionOrder) {
+        LOGGER.debug("Calculating CH with contraction order {}", contractionOrder);
+        graph.freeze();
+        NodeOrderingProvider nodeOrderingProvider = new NodeOrderingProvider() {
+            @Override
+            public int getNodeIdForLevel(int level) {
+                return contractionOrder.get(level);
+            }
+
+            @Override
+            public int getNumNodes() {
+                return contractionOrder.size();
+            }
+        };
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(chGraph, weighting, TraversalMode.EDGE_BASED)
+                .useFixedNodeOrdering(nodeOrderingProvider);
+        ch.doWork();
+        return ch;
+    }
+
+    private RoutingAlgorithmFactory automaticPrepareCH() {
+        PMap pMap = new PMap();
+        pMap.put(PERIODIC_UPDATES, 20);
+        pMap.put(LAST_LAZY_NODES_UPDATES, 100);
+        pMap.put(NEIGHBOR_UPDATES, 4);
+        pMap.put(LOG_MESSAGES, 10);
+        PrepareContractionHierarchies ch = new PrepareContractionHierarchies(
+                chGraph, weighting, TraversalMode.EDGE_BASED);
+        ch.setParams(pMap);
+        ch.doWork();
+        return ch;
+    }
+
+    private void automaticCompareCHWithDijkstra(int numQueries) {
+        long seed = System.nanoTime();
+        LOGGER.info("Seed used to create random routing queries: {}", seed);
+        final Random rnd = new Random(seed);
+        RoutingAlgorithmFactory factory = automaticPrepareCH();
+        for (int i = 0; i < numQueries; ++i) {
+            compareCHQueryWithDijkstra(factory, rnd.nextInt(graph.getNodes()), rnd.nextInt(graph.getNodes()));
+        }
+    }
+
+    private void compareCHWithDijkstra(int numQueries, List<Integer> contractionOrder) {
+        long seed = System.nanoTime();
+        LOGGER.info("Seed used to create random routing queries: {}", seed);
+        final Random rnd = new Random(seed);
+        RoutingAlgorithmFactory factory = prepareCH(contractionOrder);
+        for (int i = 0; i < numQueries; ++i) {
+            compareCHQueryWithDijkstra(factory, rnd.nextInt(graph.getNodes()), rnd.nextInt(graph.getNodes()));
+        }
+    }
+
+    private void compareCHQueryWithDijkstra(RoutingAlgorithmFactory factory, int from, int to) {
+        Path dijkstraPath = findPathUsingDijkstra(from, to);
+        RoutingAlgorithm chAlgo = factory.createAlgo(chGraph, AlgorithmOptions.start().build());
+        Path chPath = chAlgo.calcPath(from, to);
+        boolean algosDisagree = Math.abs(dijkstraPath.getWeight() - chPath.getWeight()) > 1.e-2;
+        if (checkStrict) {
+            algosDisagree = algosDisagree
+                    || Math.abs(dijkstraPath.getDistance() - chPath.getDistance()) > 1.e-2
+                    || Math.abs(dijkstraPath.getTime() - chPath.getTime()) > 1;
+        }
+        if (algosDisagree) {
+            System.out.println("Graph that produced error:");
+            GHUtility.printGraphForUnitTest(graph, encoder);
+            fail("Dijkstra and CH did not find equal shortest paths for route from " + from + " to " + to + "\n" +
+                    " dijkstra: weight: " + dijkstraPath.getWeight() + ", distance: " + dijkstraPath.getDistance() +
+                    ", time: " + dijkstraPath.getTime() + ", nodes: " + dijkstraPath.calcNodes() + "\n" +
+                    "       ch: weight: " + chPath.getWeight() + ", distance: " + chPath.getDistance() +
+                    ", time: " + chPath.getTime() + ", nodes: " + chPath.calcNodes());
+        }
+    }
+
+    private List<Integer> getRandomIntegerSequence(int nodes) {
+        return getRandomIntegerSequence(nodes, new Random());
+    }
+
+    private List<Integer> getRandomIntegerSequence(int nodes, Random rnd) {
+        List<Integer> contractionOrder = new ArrayList<>(nodes);
+        for (int i = 0; i < nodes; ++i) {
+            contractionOrder.add(i);
+        }
+        Collections.shuffle(contractionOrder, rnd);
+        return contractionOrder;
+    }
+
+    private void addRandomCostOrRestriction(int from, int via, int to, Random rnd) {
+        final double chance = 0.7;
+        if (rnd.nextDouble() < chance) {
+            addRestriction(from, via, to);
+            LOGGER.trace("addRestriction({}, {}, {});", from, via, to);
+        } else {
+            addRandomCost(from, via, to, rnd);
+        }
+    }
+
+    private void addRandomCost(int from, int via, int to, Random rnd) {
+        int cost = (int) (rnd.nextDouble() * maxCost / 2);
+        addTurnCost(from, via, to, cost);
+        LOGGER.trace("addTurnCost({}, {}, {}, {});", from, via, to, cost);
+    }
+
+    private void addRestriction(int from, int via, int to) {
+        addRestriction(getEdge(from, via), getEdge(via, to), via);
+    }
+
+    private void addRestriction(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode) {
+        turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(true, 0));
+    }
+
+    private void addTurnCost(int from, int via, int to, int cost) {
+        addTurnCost(getEdge(from, via), getEdge(via, to), via, cost);
+    }
+
+    private void addTurnCost(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode, double costs) {
+        turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(false, costs));
+    }
+
+    private void addCostOrRestriction(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode, int cost) {
+        if (cost >= maxCost) {
+            addRestriction(inEdge, outEdge, viaNode);
+            LOGGER.trace("addRestriction(edge{}, edge{}, {});", inEdge.getEdge(), outEdge.getEdge(), viaNode);
+        } else {
+            addTurnCost(inEdge, outEdge, viaNode, cost);
+            LOGGER.trace("addTurnCost(edge{}, edge{}, {}, {});", inEdge.getEdge(), outEdge.getEdge(), viaNode, cost);
+        }
+    }
+
+    private EdgeIteratorState getEdge(int from, int to) {
+        return GHUtility.getEdge(graph, from, to);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/routing/ch/EdgeBasedNodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/EdgeBasedNodeContractorTest.java
new file mode 100644
index 0000000000..f2d3a8fad2
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/EdgeBasedNodeContractorTest.java
@@ -0,0 +1,1523 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.Repeat;
+import com.graphhopper.RepeatRule;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.util.AllCHEdgesIterator;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import com.graphhopper.util.PMap;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+
+import static org.junit.Assert.*;
+
+/**
+ * In this test we mainly test if {@link EdgeBasedNodeContractorTest} inserts the correct shortcuts when certain
+ * nodes are contracted.
+ *
+ * @see CHTurnCostTest where node contraction is tested in combination with the routing query
+ */
+public class EdgeBasedNodeContractorTest {
+    private final int maxCost = 10;
+    private CHGraph chGraph;
+    private CarFlagEncoder encoder;
+    private GraphHopperStorage graph;
+    private TurnCostExtension turnCostExtension;
+    private TurnWeighting turnWeighting;
+    private TurnWeighting chTurnWeighting;
+
+    @Rule
+    public RepeatRule repeatRule = new RepeatRule();
+
+    @Before
+    public void setup() {
+        // its important to use @Before when using RepeatRule!
+        initialize();
+    }
+
+    private void initialize() {
+        encoder = new CarFlagEncoder(5, 5, maxCost);
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        Weighting weighting = new ShortestWeighting(encoder);
+        PreparationWeighting preparationWeighting = new PreparationWeighting(weighting);
+        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+        turnCostExtension = (TurnCostExtension) graph.getExtension();
+        turnWeighting = new TurnWeighting(weighting, turnCostExtension);
+        chTurnWeighting = new TurnWeighting(preparationWeighting, turnCostExtension);
+        chGraph = graph.getCHGraph();
+    }
+
+    @Test
+    public void testContractNodes_simpleLoop() {
+        //     2-3
+        //     | |
+        //  6- 7-8
+        //     |
+        //     9
+        graph.edge(6, 7, 2, false);
+        final EdgeIteratorState edge7to8 = graph.edge(7, 8, 2, false);
+        final EdgeIteratorState edge8to3 = graph.edge(8, 3, 1, false);
+        final EdgeIteratorState edge3to2 = graph.edge(3, 2, 2, false);
+        final EdgeIteratorState edge2to7 = graph.edge(2, 7, 1, false);
+        graph.edge(7, 9, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+
+        addRestriction(6, 7, 9);
+        addTurnCost(8, 3, 2, 2);
+
+        contractNodes(5, 6, 3, 2, 9, 1, 8, 4, 7, 0);
+        checkShortcuts(
+                createShortcut(8, 2, edge8to3, edge3to2, 5),
+                createShortcut(8, 7, edge8to3.getEdge(), edge2to7.getEdge(), 6, edge2to7.getEdge(), 6),
+                createShortcut(7, 7, edge7to8.getEdge(), edge2to7.getEdge(), edge7to8.getEdge(), 7, 8)
+        );
+    }
+
+    @Test
+    public void testContractNodes_necessaryAlternative() {
+        //      1
+        //      |    can't go 1->6->3
+        //      v
+        // 2 -> 6 -> 3 -> 5 -> 4
+        //      |    ^
+        //      -> 0-|
+        final EdgeIteratorState e6to0 = graph.edge(6, 0, 4, false);
+        final EdgeIteratorState e0to3 = graph.edge(0, 3, 5, false);
+        graph.edge(1, 6, 1, false);
+        final EdgeIteratorState e6to3 = graph.edge(6, 3, 1, false);
+        final EdgeIteratorState e3to5 = graph.edge(3, 5, 2, false);
+        graph.edge(2, 6, 1, false);
+        graph.edge(5, 4, 2, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        addRestriction(1, 6, 3);
+        contractAllNodesInOrder();
+        checkShortcuts(
+                // from contracting node 0: need a shortcut because of turn restriction
+                createShortcut(6, 3, e6to0, e0to3, 9),
+                // from contracting node 3: two shortcuts:
+                // 1) in case we come from 1->6 (cant turn left)
+                // 2) in case we come from 2->6 (going via node 0 would be more expensive)
+                createShortcut(6, 5, e6to0.getEdge(), e3to5.getEdge(), 7, e3to5.getEdge(), 11),
+                createShortcut(6, 5, e6to3, e3to5, 3)
+        );
+    }
+
+    @Test
+    public void testContractNodes_alternativeNecessary_noUTurn() {
+        //    /->0-->
+        //   v       \
+        //  4 <-----> 2 -> 3 -> 1
+        EdgeIteratorState e0to4 = graph.edge(4, 0, 3, true);
+        EdgeIteratorState e0to2 = graph.edge(0, 2, 5, false);
+        EdgeIteratorState e2to3 = graph.edge(2, 3, 2, false);
+        EdgeIteratorState e1to3 = graph.edge(3, 1, 2, false);
+        EdgeIteratorState e2to4 = graph.edge(4, 2, 2, true);
+        graph.freeze();
+
+        setMaxLevelOnAllNodes();
+        contractAllNodesInOrder();
+        checkShortcuts(
+                // from contraction of node 0
+                createShortcut(4, 2, e0to4, e0to2, 8),
+                // from contraction of node 2
+                // It might look like it is always better to go directly from 4 to 2, but when we come from edge (2->4)
+                // we may not do a u-turn at 4.
+                createShortcut(4, 3, e0to4.getEdge(), e2to3.getEdge(), 5, e2to3.getEdge(), 10),
+                createShortcut(4, 3, e2to4, e2to3, 4)
+        );
+    }
+
+    @Test
+    public void testContractNodes_bidirectionalLoop() {
+        //  1   3
+        //  |  /|
+        //  0-4-6
+        //    |
+        //    5-2
+        graph.edge(1, 0, 1, false);
+        graph.edge(0, 4, 2, false);
+        final EdgeIteratorState e4to6 = graph.edge(4, 6, 2, true);
+        final EdgeIteratorState e3to6 = graph.edge(6, 3, 1, true);
+        final EdgeIteratorState e3to4 = graph.edge(3, 4, 1, true);
+        final EdgeIteratorState e4to5 = graph.edge(4, 5, 1, false);
+        graph.edge(5, 2, 2, false);
+        graph.freeze();
+
+        // enforce loop (going counter-clockwise)
+        addRestriction(0, 4, 5);
+        addTurnCost(6, 3, 4, 2);
+        addTurnCost(4, 3, 6, 4);
+        setMaxLevelOnAllNodes();
+
+        contractAllNodesInOrder();
+        checkShortcuts(
+                // from contraction of node 3
+                createShortcut(4, 6, e3to4, e3to6, 6),
+                createShortcut(6, 4, e3to6, e3to4, 4),
+                // from contraction of node 4
+                // two 'parallel' shortcuts to preserve shortest paths to 5 when coming from 4->6 and 3->6 !!
+                createShortcut(6, 5, e3to6.getEdge(), e4to5.getEdge(), 8, e4to5.getEdge(), 5),
+                createShortcut(6, 5, e4to6, e4to5, 3)
+        );
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_noSourceEdgeToConnect() {
+        // 1 --> 0 --> 2 --> 3
+        graph.edge(1, 0, 3, false);
+        graph.edge(0, 2, 5, false);
+        graph.edge(2, 3, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(0);
+        // it looks like we need a shortcut from 1 to 2, but shortcuts are only introduced to maintain shortest paths
+        // between original edges, so there should be no shortcuts here, because there is no original edge incoming
+        // to node 1.
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_noTargetEdgeToConnect() {
+        // 3 --> 1 --> 0 --> 2
+        graph.edge(3, 1, 1, false);
+        graph.edge(1, 0, 3, false);
+        graph.edge(0, 2, 5, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(0);
+        // it looks like we need a shortcut from 1 to 2, but shortcuts are only introduced to maintain shortest paths
+        // between original edges, so there should be no shortcuts here, because there is no original edge outgoing
+        // from node 2.
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_noEdgesToConnectBecauseOfTurnRestrictions() {
+        // 0 --> 3 --> 2 --> 4 --> 1
+        graph.edge(0, 3, 1, false);
+        graph.edge(3, 2, 3, false);
+        graph.edge(2, 4, 5, false);
+        graph.edge(4, 1, 1, false);
+        addRestriction(0, 3, 2);
+        addRestriction(2, 4, 1);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        // It looks like we need a shortcut from 3 to 4, but due to the turn restrictions there should be none.
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_noTurncosts() {
+        // 0 --> 3 --> 2 --> 4 --> 1
+        graph.edge(0, 3, 1, false);
+        final EdgeIteratorState e3to2 = graph.edge(3, 2, 3, false);
+        final EdgeIteratorState e2to4 = graph.edge(2, 4, 5, false);
+        graph.edge(4, 1, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        EdgeBasedNodeContractor nodeContractor = createNodeContractor();
+        contractNode(nodeContractor, 0, 0);
+        contractNode(nodeContractor, 1, 1);
+        // no shortcuts so far
+        checkShortcuts();
+        // contracting node 2 should yield a shortcut to preserve the shortest path from (1->2) to (3->4). note that
+        // it does not matter that nodes 0 and 1 have lower level and are contracted already!
+        contractNode(nodeContractor, 2, 2);
+        checkShortcuts(createShortcut(3, 4, e3to2, e2to4, 8));
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_noShortcuts() {
+        // 0 --> 1 --> 2 --> 3 --> 4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 3, false);
+        graph.edge(2, 3, 5, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractAllNodesInOrder();
+        // for each contraction the node levels are such that no shortcuts are introduced
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_noOutgoingEdges() {
+        // 0 --> 1 --> 2 <-- 3 <-- 4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 3, false);
+        graph.edge(3, 2, 5, false);
+        graph.edge(4, 3, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_noIncomingEdges() {
+        // 0 <-- 1 <-- 2 --> 3 --> 4
+        graph.edge(1, 0, 1, false);
+        graph.edge(2, 1, 3, false);
+        graph.edge(2, 3, 5, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_duplicateOutgoingEdges_differentWeight() {
+        // duplicate edges with different weight occur frequently, because there might be different ways between
+        // the tower nodes
+
+        // 0 -> 1 -> 2 -> 3 -> 4
+        //            \->/
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 2, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        // there should be only one shortcut
+        checkShortcuts(
+                createShortcut(1, 3, 1, 3, 1, 3, 2)
+        );
+    }
+
+    @Test
+    public void testContractNode_duplicateIncomingEdges_differentWeight() {
+        // 0 -> 1 -> 2 -> 3 -> 4
+        //       \->/
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 2, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 2, 3, 2, 3, 2)
+        );
+    }
+
+    @Test
+    public void testContractNode_duplicateOutgoingEdges_sameWeight() {
+        // there might be duplicates of edges with the same weight, for example here:
+        // http://www.openstreetmap.org/#map=19/51.93569/10.5781
+        // http://www.openstreetmap.org/way/446299649
+        // this test makes sure that the necessary shortcuts are introduced nonetheless
+
+        // 0 -> 1 -> 2 -> 3 -> 4
+        //            \->/
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkNumShortcuts(1);
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testContractNode_duplicateIncomingEdges_sameWeight() {
+        // 0 -> 1 -> 2 -> 3 -> 4
+        //       \->/
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkNumShortcuts(1);
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_withTurnCost() {
+        // 0 --> 3 --> 2 --> 4 --> 1
+        graph.edge(0, 3, 1, false);
+        final EdgeIteratorState e3to2 = graph.edge(3, 2, 3, false);
+        final EdgeIteratorState e2to4 = graph.edge(2, 4, 5, false);
+        graph.edge(4, 1, 1, false);
+        addTurnCost(3, 2, 4, 4);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        double weight = calcWeight(e3to2, e2to4);
+        checkShortcuts(createShortcut(3, 4, e3to2, e2to4, weight));
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_withTurnRestriction() {
+        // 0 --> 3 --> 2 --> 4 --> 1
+        graph.edge(0, 3, 1, false);
+        graph.edge(3, 2, 3, false);
+        graph.edge(2, 4, 5, false);
+        graph.edge(4, 1, 1, false);
+        addRestriction(3, 2, 4);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_bidirectional() {
+        // 0 -- 3 -- 2 -- 4 -- 1
+        graph.edge(0, 3, 1, true);
+        final EdgeIteratorState e3to2 = graph.edge(3, 2, 3, true);
+        final EdgeIteratorState e2to4 = graph.edge(2, 4, 5, true);
+        graph.edge(4, 1, 1, true);
+        addTurnCost(e3to2, e2to4, 2, 4);
+        addTurnCost(e2to4, e3to2, 2, 4);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                // note that for now we add a shortcut for each direction. using fwd/bwd flags would be more efficient,
+                // but requires a more sophisticated way to determine the 'first' and 'last' original edges at various
+                // places
+                createShortcut(3, 4, e3to2, e2to4, 12),
+                createShortcut(4, 3, e2to4, e3to2, 12)
+        );
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_bidirectional_differentCosts() {
+        // 0 -- 3 -- 2 -- 4 -- 1
+        graph.edge(0, 3, 1, true);
+        final EdgeIteratorState e2to3 = graph.edge(3, 2, 3, true);
+        final EdgeIteratorState e2to4 = graph.edge(2, 4, 5, true);
+        graph.edge(4, 1, 1, true);
+        addTurnCost(e2to3, e2to4, 2, 4);
+        addTurnCost(e2to4, e2to3, 2, 7);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(3, 4, e2to3, e2to4, 12),
+                createShortcut(4, 3, e2to4, e2to3, 15)
+        );
+    }
+
+    @Test
+    public void testContractNode_multiple_bidirectional_linear() {
+        // 3 -- 2 -- 1 -- 4
+        graph.edge(3, 2, 2, true);
+        graph.edge(2, 1, 3, true);
+        graph.edge(1, 4, 6, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+
+        contractNodes(1, 2);
+        // no shortcuts needed
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_withTurnCost_andLoop() {
+        runTestWithTurnCostAndLoop(false);
+    }
+
+    @Test
+    public void testContractNode_twoNormalEdges_withTurnCost_andLoop_loopHelps() {
+        runTestWithTurnCostAndLoop(true);
+    }
+
+    private void runTestWithTurnCostAndLoop(boolean loopHelps) {
+        //            />\
+        //            \ /
+        // 0 --> 3 --> 2 --> 4 --> 1
+        graph.edge(0, 3, 1, false);
+        final EdgeIteratorState e3to2 = graph.edge(3, 2, 3, false);
+        final EdgeIteratorState e2to2 = graph.edge(2, 2, 2, false);
+        final EdgeIteratorState e2to4 = graph.edge(2, 4, 5, false);
+        graph.edge(4, 1, 1, false);
+
+        addTurnCost(e3to2, e2to2, 2, 2);
+        addTurnCost(e2to2, e2to4, 2, 1);
+        addTurnCost(e3to2, e2to4, 2, loopHelps ? 6 : 3);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+
+        createNodeContractor().contractNode(2);
+        if (loopHelps) {
+            // it is better to take the loop at node 2, so we need to introduce two shortcuts where the second contains
+            // the first (this is important for path unpacking)
+            checkShortcuts(
+                    createShortcut(3, 2, e3to2, e2to2, 7),
+                    createShortcut(3, 4, e3to2.getEdge(), e2to4.getEdge(), 5, e2to4.getEdge(), 13));
+        } else {
+            // taking the loop would be worse, so the path is just 3-2-4 and we only need a single shortcut
+            checkShortcuts(
+                    createShortcut(3, 4, e3to2, e2to4, 11));
+        }
+    }
+
+    @Test
+    public void testContractNode_shortcutDoesNotSpanUTurn() {
+        // 2 -> 7 -> 3 -> 5 -> 6
+        //           |
+        //     1 <-> 4
+        final EdgeIteratorState e7to3 = graph.edge(7, 3, 1, false);
+        final EdgeIteratorState e3to5 = graph.edge(3, 5, 1, false);
+        final EdgeIteratorState e3to4 = graph.edge(3, 4, 2, true);
+        graph.edge(2, 7, 1, false);
+        graph.edge(5, 6, 1, false);
+        graph.edge(1, 4, 1, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        addRestriction(7, 3, 5);
+        contractNodes(3, 4);
+        checkShortcuts(
+                // from contracting node 3
+                createShortcut(7, 4, e7to3, e3to4, 3),
+                createShortcut(4, 5, e3to4, e3to5, 3)
+                // important! no shortcut from 7 to 5 when contracting node 4, because it includes a u-turn
+        );
+    }
+
+    @Test
+    public void testContractNode_multiple_loops_directTurnIsBest() {
+        // turning on any of the loops is restricted so we take the direct turn -> one extra shortcuts
+        GraphWithTwoLoops g = new GraphWithTwoLoops(maxCost, maxCost, 1, 2, 3, 4);
+        g.contractAndCheckShortcuts(
+                createShortcut(7, 8, g.e7to6, g.e6to8, 11));
+    }
+
+    @Test
+    public void testContractNode_multiple_loops_leftLoopIsBest() {
+        // direct turn is restricted, so we take the left loop -> two extra shortcuts
+        GraphWithTwoLoops g = new GraphWithTwoLoops(2, maxCost, 1, 2, 3, maxCost);
+        g.contractAndCheckShortcuts(
+                createShortcut(7, 6, g.e7to6.getEdge(), g.e1to6.getEdge(), g.e7to6.getEdge(), g.getScEdge(1), 12),
+                createShortcut(7, 8, g.e7to6.getEdge(), g.e6to8.getEdge(), g.getScEdge(4), g.e6to8.getEdge(), 20)
+        );
+    }
+
+    @Test
+    public void testContractNode_multiple_loops_rightLoopIsBest() {
+        // direct turn is restricted, going on left loop is expensive, so we take the right loop -> two extra shortcuts
+        GraphWithTwoLoops g = new GraphWithTwoLoops(8, 1, 1, 2, 3, maxCost);
+        g.contractAndCheckShortcuts(
+                createShortcut(7, 6, g.e7to6.getEdge(), g.e3to6.getEdge(), g.e7to6.getEdge(), g.getScEdge(3), 12),
+                createShortcut(7, 8, g.e7to6.getEdge(), g.e6to8.getEdge(), g.getScEdge(4), g.e6to8.getEdge(), 21)
+        );
+    }
+
+    @Test
+    public void testContractNode_multiple_loops_leftRightLoopIsBest() {
+        // multiple turns are restricted, it is best to take the left and the right loop -> three extra shortcuts
+        GraphWithTwoLoops g = new GraphWithTwoLoops(3, maxCost, 1, maxCost, 3, maxCost);
+        g.contractAndCheckShortcuts(
+                createShortcut(7, 6, g.e7to6.getEdge(), g.e1to6.getEdge(), g.e7to6.getEdge(), g.getScEdge(1), 13),
+                createShortcut(7, 6, g.e7to6.getEdge(), g.e3to6.getEdge(), g.getScEdge(4), g.getScEdge(3), 24),
+                createShortcut(7, 8, g.e7to6.getEdge(), g.e6to8.getEdge(), g.getScEdge(5), g.e6to8.getEdge(), 33)
+        );
+    }
+
+    @Test
+    public void testContractNode_multiple_loops_rightLeftLoopIsBest() {
+        // multiple turns are restricted, it is best to take the right and the left loop -> three extra shortcuts
+        GraphWithTwoLoops g = new GraphWithTwoLoops(maxCost, 5, 4, 2, maxCost, maxCost);
+        g.contractAndCheckShortcuts(
+                createShortcut(7, 6, g.e7to6.getEdge(), g.e3to6.getEdge(), g.e7to6.getEdge(), g.getScEdge(3), 16),
+                createShortcut(7, 6, g.e7to6.getEdge(), g.e1to6.getEdge(), g.getScEdge(4), g.getScEdge(1), 25),
+                createShortcut(7, 8, g.e7to6.getEdge(), g.e6to8.getEdge(), g.getScEdge(5), g.e6to8.getEdge(), 33)
+        );
+    }
+
+    //    1 4 2
+    //    |\|/|
+    //    0-6-3
+    //     /|\
+    // 9--7 5 8--10
+    private class GraphWithTwoLoops {
+        final int centerNode = 6;
+        final EdgeIteratorState e0to1 = graph.edge(0, 1, 3, false);
+        final EdgeIteratorState e1to6 = graph.edge(1, 6, 2, false);
+        final EdgeIteratorState e6to0 = graph.edge(6, 0, 4, false);
+        final EdgeIteratorState e2to3 = graph.edge(2, 3, 2, false);
+        final EdgeIteratorState e3to6 = graph.edge(3, 6, 7, false);
+        final EdgeIteratorState e6to2 = graph.edge(6, 2, 1, false);
+        final EdgeIteratorState e7to6 = graph.edge(7, 6, 1, false);
+        final EdgeIteratorState e6to8 = graph.edge(6, 8, 6, false);
+        final EdgeIteratorState e9to7 = graph.edge(9, 7, 2, false);
+        final EdgeIteratorState e8to10 = graph.edge(8, 10, 3, false);
+        // these two edges help to avoid loop avoidance for the left and right loops
+        final EdgeIteratorState e4to6 = graph.edge(4, 6, 1, false);
+        final EdgeIteratorState e5to6 = graph.edge(5, 6, 1, false);
+        final int numEdges = 12;
+
+        GraphWithTwoLoops(int turnCost70, int turnCost72, int turnCost12, int turnCost18, int turnCost38, int turnCost78) {
+            addCostOrRestriction(e7to6, e6to0, centerNode, turnCost70);
+            addCostOrRestriction(e7to6, e6to2, centerNode, turnCost72);
+            addCostOrRestriction(e7to6, e6to8, centerNode, turnCost78);
+            addCostOrRestriction(e1to6, e6to2, centerNode, turnCost12);
+            addCostOrRestriction(e1to6, e6to8, centerNode, turnCost18);
+            addCostOrRestriction(e3to6, e6to8, centerNode, turnCost38);
+            // restrictions to make sure that no loop avoidance takes place when the left&right loops are contracted
+            addRestriction(e4to6, e6to8, centerNode);
+            addRestriction(e5to6, e6to2, centerNode);
+            addRestriction(e4to6, e6to0, centerNode);
+
+            graph.freeze();
+            setMaxLevelOnAllNodes();
+        }
+
+        private void contractAndCheckShortcuts(Shortcut... shortcuts) {
+            contractNodes(0, 1, 2, 3, 4, 5, 6);
+            HashSet<Shortcut> expectedShortcuts = new HashSet<>();
+            expectedShortcuts.addAll(Arrays.asList(
+                    createShortcut(6, 1, e6to0, e0to1, 7),
+                    createShortcut(6, 6, e6to0.getEdge(), e1to6.getEdge(), getScEdge(0), e1to6.getEdge(), 9),
+                    createShortcut(6, 3, e6to2, e2to3, 3),
+                    createShortcut(6, 6, e6to2.getEdge(), e3to6.getEdge(), getScEdge(2), e3to6.getEdge(), 10)
+            ));
+            expectedShortcuts.addAll(Arrays.asList(shortcuts));
+            checkShortcuts(expectedShortcuts);
+        }
+
+        private int getScEdge(int shortcutId) {
+            return numEdges + shortcutId;
+        }
+    }
+
+    @Test
+    public void testContractNode_detour_detourIsBetter() {
+        // starting the detour by turning left at node 1 seems expensive but is still worth it because going straight
+        // at node 2 when coming from node 1 is worse -> one shortcut required
+        GraphWithDetour g = new GraphWithDetour(2, 9, 5, 1);
+        contractNodes(0);
+        checkShortcuts(
+                createShortcut(1, 2, g.e1to0, g.e0to2, 7)
+        );
+    }
+
+    @Test
+    public void testContractNode_detour_detourIsWorse() {
+        // starting the detour is cheap but going left at node 2 is expensive -> no shortcut
+        GraphWithDetour g = new GraphWithDetour(4, 1, 1, 7);
+        contractNodes(0);
+        checkShortcuts();
+    }
+
+    //      0
+    //     / \
+    // 4--1---2--3
+    private class GraphWithDetour {
+        private final EdgeIteratorState e4to1 = graph.edge(4, 1, 2, false);
+        private final EdgeIteratorState e1to0 = graph.edge(1, 0, 4, false);
+        private final EdgeIteratorState e1to2 = graph.edge(1, 2, 3, false);
+        private final EdgeIteratorState e0to2 = graph.edge(0, 2, 3, false);
+        private final EdgeIteratorState e2to3 = graph.edge(2, 3, 2, false);
+
+        GraphWithDetour(int turnCost42, int turnCost13, int turnCost40, int turnCost03) {
+            addCostOrRestriction(e4to1, e1to2, 1, turnCost42);
+            addCostOrRestriction(e4to1, e1to0, 1, turnCost40);
+            addCostOrRestriction(e1to2, e2to3, 2, turnCost13);
+            addCostOrRestriction(e0to2, e2to3, 2, turnCost03);
+            graph.freeze();
+            setMaxLevelOnAllNodes();
+        }
+
+    }
+
+    @Test
+    public void testContractNode_detour_multipleInOut_needsShortcut() {
+        GraphWithDetourMultipleInOutEdges g = new GraphWithDetourMultipleInOutEdges(0, 0, 0, 1, 3);
+        contractNodes(0);
+        checkShortcuts(createShortcut(1, 4, g.e1to0, g.e0to4, 7));
+    }
+
+    @Test
+    public void testContractNode_detour_multipleInOut_noShortcuts() {
+        GraphWithDetourMultipleInOutEdges g = new GraphWithDetourMultipleInOutEdges(0, 0, 0, 0, 0);
+        contractNodes(0);
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_detour_multipleInOut_restrictedIn() {
+        GraphWithDetourMultipleInOutEdges g = new GraphWithDetourMultipleInOutEdges(0, maxCost, 0, maxCost, 0);
+        contractNodes(0);
+        checkShortcuts();
+    }
+
+    // 5   3   7
+    //  \ / \ /
+    // 2-1-0-4-6
+    private class GraphWithDetourMultipleInOutEdges {
+        final EdgeIteratorState e5to1 = graph.edge(5, 1, 3, false);
+        final EdgeIteratorState e2to1 = graph.edge(2, 1, 2, false);
+        final EdgeIteratorState e1to3 = graph.edge(1, 3, 1, false);
+        final EdgeIteratorState e3to4 = graph.edge(3, 4, 2, false);
+        final EdgeIteratorState e1to0 = graph.edge(1, 0, 5, false);
+        final EdgeIteratorState e0to4 = graph.edge(0, 4, 2, false);
+        final EdgeIteratorState e4to6 = graph.edge(4, 6, 1, false);
+        final EdgeIteratorState e4to7 = graph.edge(4, 7, 3, false);
+
+        GraphWithDetourMultipleInOutEdges(int turnCost20, int turnCost50, int turnCost23, int turnCost53, int turnCost36) {
+            addTurnCost(e1to3, e3to4, 3, 2);
+            addCostOrRestriction(e2to1, e1to0, 1, turnCost20);
+            addCostOrRestriction(e2to1, e1to3, 1, turnCost23);
+            addCostOrRestriction(e5to1, e1to0, 1, turnCost50);
+            addCostOrRestriction(e5to1, e1to3, 1, turnCost53);
+            addCostOrRestriction(e3to4, e4to6, 4, turnCost36);
+            graph.freeze();
+            setMaxLevelOnAllNodes();
+        }
+    }
+
+    @Test
+    public void testContractNode_loopAvoidance_loopNecessary() {
+        // turning from 3 via 2 to 4 is costly, it is better to take the 2-1-0-2 loop so a loop shortcut is required
+        GraphWithLoop g = new GraphWithLoop(7);
+        contractNodes(0, 1);
+        final int numEdges = 6;
+        checkShortcuts(
+                createShortcut(2, 1, g.e2to0, g.e0to1, 3),
+                createShortcut(2, 2, g.e2to0.getEdge(), g.e1to2.getEdge(), numEdges, g.e1to2.getEdge(), 4)
+        );
+    }
+
+    @Test
+    public void testContractNode_loopAvoidance_loopAvoidable() {
+        // turning from 3 via 2 to 4 is cheap, it is better to go straight 3-2-4, no loop shortcut necessary
+        GraphWithLoop g = new GraphWithLoop(3);
+        contractNodes(0, 1);
+        checkShortcuts(
+                createShortcut(2, 1, g.e2to0, g.e0to1, 3)
+        );
+    }
+
+    //   0 - 1
+    //    \ /
+    // 3 - 2 - 4
+    //     |
+    //     5
+    private class GraphWithLoop {
+        final EdgeIteratorState e0to1 = graph.edge(0, 1, 2, false);
+        final EdgeIteratorState e1to2 = graph.edge(1, 2, 1, false);
+        final EdgeIteratorState e2to0 = graph.edge(2, 0, 1, false);
+        final EdgeIteratorState e3to2 = graph.edge(3, 2, 3, false);
+        final EdgeIteratorState e2to4 = graph.edge(2, 4, 5, false);
+        final EdgeIteratorState e5to2 = graph.edge(5, 2, 2, false);
+
+        GraphWithLoop(int turnCost34) {
+            addCostOrRestriction(e3to2, e2to4, 2, turnCost34);
+            graph.freeze();
+            setMaxLevelOnAllNodes();
+        }
+    }
+
+    @Test
+    public void testContractNode_witnessPathsAreFound() {
+        //         2 ----- 7 - 10 
+        //       / |       |
+        // 0 - 1   3 - 4   |
+        //     |   |      /     
+        //     5 - 9 ---- 
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 5, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(1, 5, 1, false);
+        graph.edge(5, 9, 1, false);
+        graph.edge(9, 3, 1, false);
+        graph.edge(2, 7, 6, false);
+        graph.edge(9, 7, 1, false);
+        graph.edge(7, 10, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts();
+    }
+
+    @Test
+    @Repeat(times = 10)
+    public void testContractNode_noUnnecessaryShortcut_witnessPathOfEqualWeight() {
+        // this test runs repeatedly because it might pass/fail by chance (because path lengths are equal)
+
+        // 0 -> 1 -> 5
+        //      v    v 
+        //      2 -> 3 -> 4 -> 5
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(1, 5, 1, false);
+        EdgeIteratorState e2to3 = graph.edge(2, 3, 1, false);
+        EdgeIteratorState e3to4 = graph.edge(3, 4, 1, false);
+        graph.edge(4, 5, 1, false);
+        EdgeIteratorState e5to3 = graph.edge(5, 3, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(3, 2);
+        // when contracting node 2 there is a witness (1-5-3-4) and no shortcut from 1 to 4 should be introduced.
+        // what might be tricky here is that both the original path and the witness path have equal weight!
+        checkShortcuts(
+                createShortcut(2, 4, e2to3, e3to4, 2),
+                createShortcut(5, 4, e5to3, e3to4, 2)
+        );
+    }
+
+    @Test
+    public void testContractNode_noUnnecessaryShortcut_differentWitnessesForDifferentOutEdges() {
+        //         /--> 2 ---\
+        //        /           \
+        // 0 --> 1 ---> 3 ---> 5 --> 6 
+        //        \           /
+        //         \--> 4 ---/   
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.edge(1, 4, 1, false);
+        graph.edge(2, 5, 1, true); // bidirectional
+        graph.edge(3, 5, 1, false);
+        graph.edge(4, 5, 1, true); // bidirectional
+        graph.edge(5, 6, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(3);
+
+        // We do not need a shortcut here! we can only access node 1 from node 0 and at node 5 we can either go to 
+        // node 2,4 or 6. To get to node 6 we can either take the northern witness via 2 or the southern one via 4.
+        // to get to node 2 we need to take the witness via node 4 and vice versa. the interesting part here is that
+        // we use a different witness depending on the target edge and even more that the witness paths itself yield
+        // outgoing edges that need to be witnessed because edges 2->5 and 4->5 are bidirectional like the majority
+        // of edges in road networks.
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_noUnnecessaryShortcut_differentInitialEntriesForDifferentInEdges() {
+        // this test shows a (quite realistic) example where the aggressive search finds a witness where the turn
+        // replacement search described in the turn-cost CH article by Gaisberger/Vettel does not.
+
+        //         /--- 2 ->-\
+        //        /           \
+        // 0 --> 1 ---> 3 ---> 5 --> 6 
+        //        \           /
+        //         \--- 4 ->-/   
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, true); // bidirectional
+        graph.edge(1, 3, 1, false);
+        graph.edge(1, 4, 1, true); // bidirectional
+        graph.edge(2, 5, 1, false);
+        graph.edge(3, 5, 1, false);
+        graph.edge(4, 5, 1, false);
+        graph.edge(5, 6, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(3);
+
+        // We do not need a shortcut here! node 1 can be reached from nodes 0, 2 and 4 and from the target node 5 we can
+        // only reach node 6. so coming into node 1 from node 0 we can either go north or south via nodes 2/4 to reach
+        // the edge 5->6. If we come from node 2 we can take the southern witness via 4 and vice versa.
+        // 
+        // This is an example of an unnecessary shortcut introduced by the turn replacement algorithm, because the 
+        // out turn replacement difference for the potential witnesses would be infinite at node 1. 
+        // Note that this happens basically whenever there is a bidirectional edge (and u-turns are forbidden) !
+        checkShortcuts();
+    }
+
+    @Test
+    public void testContractNode_bidirectional_edge_at_fromNode() {
+        int nodeToContract = 2;
+        // we might come from (5->1) so we still need a way back to (3->4) -> we need a shortcut
+        Shortcut expectedShortcuts = createShortcut(1, 3, 1, 2, 1, 2, 2);
+        runTestWithBidirectionalEdgeAtFromNode(nodeToContract, false, expectedShortcuts);
+    }
+
+    @Test
+    public void testContractNode_bidirectional_edge_at_fromNode_is() {
+        int nodeToContract = 2;
+        // we might come from (5->1) so we still need a way back to (3->4) -> we need a shortcut
+        Shortcut expectedShortcuts = createShortcut(1, 3, 1, 2, 1, 2, 2);
+        runTestWithBidirectionalEdgeAtFromNode(nodeToContract, true, expectedShortcuts);
+    }
+
+    @Test
+    public void testContractNode_bidirectional_edge_at_fromNode_going_to_node() {
+        int nodeToContract = 5;
+        // wherever we come from we can always go via node 2 -> no shortcut needed
+        Shortcut[] expectedShortcuts = new Shortcut[0];
+        runTestWithBidirectionalEdgeAtFromNode(nodeToContract, false, expectedShortcuts);
+    }
+
+    private void runTestWithBidirectionalEdgeAtFromNode(int nodeToContract, boolean edge1to2bidirectional, Shortcut... expectedShortcuts) {
+        // 0 -> 1 <-> 5
+        //      v     v 
+        //      2 --> 3 -> 4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, edge1to2bidirectional);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(1, 5, 1, true);
+        graph.edge(5, 3, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(nodeToContract);
+        checkShortcuts(expectedShortcuts);
+    }
+
+    @Test
+    public void testNodeContraction_directWitness() {
+        // 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8
+        //     /      \                 /      \
+        //10 ->        ------> 9 ------>        -> 11
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(4, 5, 1, false);
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.edge(2, 9, 1, false);
+        graph.edge(9, 6, 1, false);
+        graph.edge(10, 1, 1, false);
+        graph.edge(7, 11, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2, 6, 3, 5, 4);
+        // note that the shortcut edge ids depend on the insertion order which might change when changing the implementation
+        checkShortcuts(
+                createShortcut(1, 3, 1, 2, 1, 2, 2),
+                createShortcut(1, 9, 1, 8, 1, 8, 2),
+                createShortcut(5, 7, 5, 6, 5, 6, 2),
+                createShortcut(9, 7, 9, 6, 9, 6, 2),
+                createShortcut(1, 4, 1, 3, 13, 3, 3),
+                createShortcut(4, 7, 4, 6, 4, 15, 3)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_witnessBetterBecauseOfTurnCostAtTargetNode() {
+        // when we contract node 2 we should not stop searching for witnesses when edge 2->3 is settled, because then we miss
+        // the witness path via 5 that is found later, but still has less weight because of the turn costs at node 3
+        // 0 -> 1 -> 2 -> 3 -> 4
+        //       \       /         
+        //        -- 5 ->   
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(1, 5, 3, false);
+        graph.edge(5, 3, 1, false);
+        addTurnCost(2, 3, 4, 5);
+        addTurnCost(5, 3, 4, 2);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts();
+    }
+
+    @Test
+    public void testNodeContraction_letShortcutsWitnessEachOther_twoIn() {
+        // coming from (0->1) it is best to go via node 2 to reach (5->6)
+        // when contracting node 3 adding the shortcut 2->3->4 is therefore enough and we do not need an 
+        // additional shortcut 1->3->4. while this seems obvious it requires that the 1->3->4 witness search is 
+        // somehow 'aware' of the fact that the shortcut 2->3->4 will be introduced anyway.
+
+        // 0 -> 1 -> 2 -> 3 -> 4 -> 5
+        //       \        |
+        //        ------->|
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(1, 3, 4, false);
+        graph.edge(4, 5, 1, false);
+
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(3);
+        checkShortcuts(
+                createShortcut(2, 4, 2, 3, 2, 3, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_letShortcutsWitnessEachOther_twoOut() {
+        // coming from (0->1) it is best to go via node 3 to reach (4->5)
+        // when contracting node 2 adding the shortcut 1->2->3 is therefore enough and we do not need an 
+        // additional shortcut 1->2->4.
+
+        // 0 -> 1 -> 2 -> 3 -> 4 -> 5
+        //           |        / 
+        //           ------->
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(4, 5, 1, false);
+        graph.edge(2, 4, 4, false);
+
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 1, 2, 1, 2, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_parallelEdges_onlyOneLoopShortcutNeeded() {
+        // 0 -- 1 -- 2
+        //  \--/
+        EdgeIteratorState edge0 = graph.edge(0, 1, 2, true);
+        EdgeIteratorState edge1 = graph.edge(1, 0, 4, true);
+        graph.edge(1, 2, 5, true);
+        addTurnCost(edge0, edge1, 0, 1);
+        addTurnCost(edge1, edge0, 0, 2);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(0);
+        // it is sufficient to be able to travel the 1-0-1 loop in one (the cheaper) direction
+        checkShortcuts(
+                createShortcut(1, 1, 0, 1, 0, 1, 7)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_duplicateEdge_severalLoops() {
+        // 5 -- 4 -- 3 -- 1
+        // |\   |
+        // | \  /        
+        // -- 2 
+        graph.edge(1, 3, 47, true);
+        graph.edge(2, 4, 19, true);
+        EdgeIteratorState e2 = graph.edge(2, 5, 38, true);
+        EdgeIteratorState e3 = graph.edge(2, 5, 57, true); // note there is a duplicate edge here (with different weight) 
+        graph.edge(3, 4, 10, true);
+        EdgeIteratorState e5 = graph.edge(4, 5, 56, true);
+
+        addTurnCost(e3, e2, 5, 4);
+        addTurnCost(e2, e3, 5, 5);
+        addTurnCost(e5, e3, 5, 3);
+        addTurnCost(e3, e5, 5, 2);
+        addTurnCost(e2, e5, 5, 2);
+        addTurnCost(e5, e2, 5, 1);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(4, 5);
+        // note that the shortcut edge ids depend on the insertion order which might change when changing the implementation
+        checkNumShortcuts(11);
+        checkShortcuts(
+                // from node 4 contraction
+                createShortcut(5, 3, 5, 4, 5, 4, 66),
+                createShortcut(3, 5, 4, 5, 4, 5, 66),
+                createShortcut(2, 3, 1, 4, 1, 4, 29),
+                createShortcut(3, 2, 4, 1, 4, 1, 29),
+                createShortcut(2, 5, 1, 5, 1, 5, 75),
+                createShortcut(5, 2, 5, 1, 5, 1, 75),
+                // from node 5 contraction
+                createShortcut(2, 2, 3, 2, 3, 2, 99),
+                createShortcut(2, 2, 3, 1, 3, 7, 134),
+                createShortcut(2, 2, 1, 2, 10, 2, 114),
+                createShortcut(2, 3, 2, 4, 2, 6, 106),
+                createShortcut(3, 2, 4, 2, 8, 2, 105)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_tripleConnection() {
+        graph.edge(0, 1, 1.0, true);
+        graph.edge(0, 1, 2.0, true);
+        graph.edge(0, 1, 3.5, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(1);
+        checkShortcuts(
+                createShortcut(0, 0, 1, 2, 1, 2, 5.5),
+                createShortcut(0, 0, 0, 2, 0, 2, 4.5),
+                createShortcut(0, 0, 0, 1, 0, 1, 3.0)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_fromAndToNodesEqual() {
+        // 0 -> 1 -> 3
+        //     / \
+        //    v   ^
+        //     \ /
+        //      2
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 1, 1, false);
+        graph.edge(1, 3, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts();
+    }
+
+    @Test
+    public void testNodeContraction_node_in_loop() {
+        //      2
+        //     /|
+        //  0-4-3
+        //    |
+        //    1
+        graph.edge(0, 4, 2, false);
+        graph.edge(4, 3, 2, true);
+        graph.edge(3, 2, 1, true);
+        graph.edge(2, 4, 1, true);
+        graph.edge(4, 1, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+
+        // enforce loop (going counter-clockwise)
+        addRestriction(0, 4, 1);
+        addTurnCost(4, 2, 3, 4);
+        addTurnCost(3, 2, 4, 2);
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(4, 3, 3, 2, 3, 2, 6),
+                createShortcut(3, 4, 2, 3, 2, 3, 4)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_turnRestrictionAndLoop() {
+        //  /\    /<-3
+        // 0  1--2
+        //  \/    \->4
+        graph.edge(0, 1, 5, true);
+        graph.edge(0, 1, 6, true);
+        graph.edge(1, 2, 2, true);
+        graph.edge(3, 2, 3, false);
+        graph.edge(2, 4, 3, false);
+        addRestriction(3, 2, 4);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(0);
+        checkNumShortcuts(1);
+    }
+
+    @Test
+    public void testNodeContraction_forwardLoopNeedsToBeRecognizedAsIncoming() {
+        //     ---
+        //     \ /
+        // 0 -- 1 -- 2 -- 3 -- 4
+        EdgeIteratorState edge0 = graph.edge(0, 1, 1, true);
+        EdgeIteratorState edge1 = graph.edge(1, 1, 1, false);
+        EdgeIteratorState edge2 = graph.edge(1, 2, 1, true);
+        EdgeIteratorState edge3 = graph.edge(2, 3, 1, false);
+        EdgeIteratorState edge4 = graph.edge(3, 4, 1, false);
+        addRestriction(edge0, edge2, 1);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                // we need a shortcut going from 1 to 3, but this is not entirely trivial, because it is crucial that
+                // the loop at node 1 is recognized as an incoming edge at node 1 although it is only 'unidirectional',
+                // i.e. it has only a fwd flag
+                createShortcut(1, 3, edge2, edge3, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_minorWeightDeviation() {
+        // 0 -> 1 -> 2 -> 3 -> 4
+        graph.edge(0, 1, 51.401, false);
+        graph.edge(1, 2, 70.041, false);
+        graph.edge(2, 3, 75.806, false);
+        graph.edge(3, 4, 05.003, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 1, 2, 1, 2, 145.847)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_zeroWeightLoop_loopOnly() {
+        // zero weight loops are quite a headache..., also see #1355
+        //                  /|
+        // 0 -> 1 -> 2 -> 3 --
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 1, 2, 1, 2, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_zeroWeightLoop_loopAndEdge() {
+        //                  /|
+        // 0 -> 1 -> 2 -> 3 --
+        //                |
+        //                4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 1, 2, 1, 2, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_zeroWeightLoop_twoLoops() {
+        //                  /|
+        // 0 -> 1 -> 2 -> 3 --
+        //                  \|
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 3, 0, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 1, 2, 1, 2, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_zeroWeightLoop_twoLoopsAndEdge_edgeFirst() {
+        //                  /|
+        // 0 -> 1 -> 2 -> 3 --
+        //                | \|
+        //                4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 1, 2, 1, 2, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_zeroWeightLoop_twoLoopsAndEdge_loopsFirst() {
+        //                  /|
+        // 0 -> 1 -> 2 -> 3 --
+        //                | \|
+        //                4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 1, 4, 1, 4, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_zeroWeightLoop_manyLoops() {
+        //                  /| many
+        // 0 -> 1 -> 2 -> 3 --
+        //                | 
+        //                4
+        graph.edge(3, 3, 0, false);
+        graph.edge(0, 1, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(3, 3, 0, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkShortcuts(
+                createShortcut(1, 3, 3, 5, 3, 5, 2)
+        );
+    }
+
+    @Test
+    public void testNodeContraction_zeroWeightLoop_twoLoopsAndEdge_withTurnRestriction() {
+        //                  /|
+        // 0 -> 1 -> 2 -> 3 --
+        //                | 
+        //                4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        EdgeIteratorState edge2 = graph.edge(2, 3, 1, false);
+        EdgeIteratorState edge3 = graph.edge(3, 3, 0, false);
+        EdgeIteratorState edge4 = graph.edge(3, 4, 1, false);
+        // add a few more loops to make this test more difficult to pass
+        graph.edge(3, 3, 0, false);
+        graph.edge(3, 3, 0, false);
+        // we have to use the zero weight loop so it may not be excluded
+        addTurnCost(edge2, edge3, 3, 5);
+        addRestriction(edge2, edge4, 3);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        contractNodes(2);
+        checkNumShortcuts(1);
+    }
+
+    @Test
+    public void testNodeContraction_numPolledEdges() {
+        graph.edge(3, 2, 71.203000, false);
+        graph.edge(0, 3, 79.003000, false);
+        graph.edge(2, 0, 21.328000, false);
+        graph.edge(2, 4, 16.499000, false);
+        graph.edge(4, 2, 16.487000, false);
+        graph.edge(6, 1, 55.603000, false);
+        graph.edge(2, 1, 33.453000, false);
+        graph.edge(4, 5, 29.665000, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        EdgeBasedNodeContractor nodeContractor = createNodeContractor();
+        nodeContractor.contractNode(0);
+        assertTrue("too many edges polled: " + nodeContractor.getNumPolledEdges(),
+                nodeContractor.getNumPolledEdges() <= 8);
+    }
+
+    private void contractNode(NodeContractor nodeContractor, int node, int level) {
+        nodeContractor.contractNode(node);
+        chGraph.setLevel(node, level);
+    }
+
+    private void contractAllNodesInOrder() {
+        EdgeBasedNodeContractor nodeContractor = createNodeContractor();
+        for (int node = 0; node < graph.getNodes(); ++node) {
+            nodeContractor.contractNode(node);
+            chGraph.setLevel(node, node);
+        }
+    }
+
+    /**
+     * contracts the given nodes and sets the node levels in order.
+     * this method may only be called once per test !
+     */
+    private void contractNodes(int... nodes) {
+        EdgeBasedNodeContractor nodeContractor = createNodeContractor();
+        for (int i = 0; i < nodes.length; ++i) {
+            nodeContractor.contractNode(nodes[i]);
+            chGraph.setLevel(nodes[i], i);
+        }
+    }
+
+    private EdgeBasedNodeContractor createNodeContractor() {
+        EdgeBasedNodeContractor nodeContractor = new EdgeBasedNodeContractor(chGraph, chTurnWeighting, new PMap());
+        nodeContractor.initFromGraph();
+        return nodeContractor;
+    }
+
+    private double calcWeight(EdgeIteratorState edge1, EdgeIteratorState edge2) {
+        return turnWeighting.calcWeight(edge1, false, EdgeIterator.NO_EDGE) +
+                turnWeighting.calcWeight(edge2, false, edge1.getEdge());
+    }
+
+    private void addRestriction(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode) {
+        turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(true, 0));
+    }
+
+    private void addRestriction(int from, int via, int to) {
+        addRestriction(getEdge(from, via), getEdge(via, to), via);
+    }
+
+    private void addTurnCost(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode, double cost) {
+        turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(false, cost));
+    }
+
+    private void addTurnCost(int from, int via, int to, int cost) {
+        addTurnCost(getEdge(from, via), getEdge(via, to), via, cost);
+    }
+
+    private void addCostOrRestriction(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode, int cost) {
+        if (cost >= maxCost) {
+            addRestriction(inEdge, outEdge, viaNode);
+        } else {
+            addTurnCost(inEdge, outEdge, viaNode, cost);
+        }
+    }
+
+    private EdgeIteratorState getEdge(int from, int to) {
+        return GHUtility.getEdge(graph, from, to);
+    }
+
+    private Shortcut createShortcut(int from, int to, EdgeIteratorState edge1, EdgeIteratorState edge2, double weight) {
+        return createShortcut(from, to, edge1.getEdge(), edge2.getEdge(), edge1.getEdge(), edge2.getEdge(), weight);
+    }
+
+    private Shortcut createShortcut(int from, int to, int firstOrigEdge, int lastOrigEdge, int skipEdge1, int skipEdge2, double weight) {
+        boolean fwd = true;
+        boolean bwd = false;
+        return new Shortcut(from, to, firstOrigEdge, lastOrigEdge, skipEdge1, skipEdge2, weight, fwd, bwd);
+    }
+
+    /**
+     * Queries the ch graph and checks if the graph's shortcuts match the given expected shortcuts.
+     */
+    private void checkShortcuts(Shortcut... expectedShortcuts) {
+        Set<Shortcut> expected = setOf(expectedShortcuts);
+        if (expected.size() != expectedShortcuts.length) {
+            fail("was given duplicate shortcuts");
+        }
+        checkShortcuts(expected);
+    }
+
+    private void checkShortcuts(Set<Shortcut> expected) {
+        assertEquals(expected, getCurrentShortcuts());
+    }
+
+    private void checkNumShortcuts(int expected) {
+        assertEquals(expected, getCurrentShortcuts().size());
+    }
+
+    private Set<Shortcut> getCurrentShortcuts() {
+        Set<Shortcut> shortcuts = new HashSet<>();
+        AllCHEdgesIterator iter = chGraph.getAllEdges();
+        while (iter.next()) {
+            if (iter.isShortcut()) {
+                BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+                shortcuts.add(new Shortcut(
+                        iter.getBaseNode(), iter.getAdjNode(),
+                        iter.getOrigEdgeFirst(), iter.getOrigEdgeLast(), iter.getSkippedEdge1(), iter.getSkippedEdge2(), iter.getWeight(),
+                        iter.get(accessEnc), iter.getReverse(accessEnc)
+                ));
+            }
+        }
+        return shortcuts;
+    }
+
+    private Set<Shortcut> setOf(Shortcut... shortcuts) {
+        return new HashSet<>(Arrays.asList(shortcuts));
+    }
+
+    private void setMaxLevelOnAllNodes() {
+        int nodes = chGraph.getNodes();
+        for (int node = 0; node < nodes; node++) {
+            chGraph.setLevel(node, nodes);
+        }
+    }
+
+    private static class Shortcut {
+        int baseNode;
+        int adjNode;
+        int firstOrigEdge;
+        int lastOrigEdge;
+        double weight;
+        boolean fwd;
+        boolean bwd;
+        int skipEdge1;
+        int skipEdge2;
+
+        public Shortcut(int baseNode, int adjNode, int firstOrigEdge, int lastOrigEdge, int skipEdge1, int skipEdge2, double weight,
+                        boolean fwd, boolean bwd) {
+            this.baseNode = baseNode;
+            this.adjNode = adjNode;
+            this.firstOrigEdge = firstOrigEdge;
+            this.lastOrigEdge = lastOrigEdge;
+            this.weight = weight;
+            this.fwd = fwd;
+            this.bwd = bwd;
+            this.skipEdge1 = skipEdge1;
+            this.skipEdge2 = skipEdge2;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            Shortcut shortcut = (Shortcut) o;
+            return baseNode == shortcut.baseNode &&
+                    adjNode == shortcut.adjNode &&
+                    firstOrigEdge == shortcut.firstOrigEdge &&
+                    lastOrigEdge == shortcut.lastOrigEdge &&
+                    Double.compare(shortcut.weight, weight) == 0 &&
+                    fwd == shortcut.fwd &&
+                    bwd == shortcut.bwd &&
+                    skipEdge1 == shortcut.skipEdge1 &&
+                    skipEdge2 == shortcut.skipEdge2;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(baseNode, adjNode, firstOrigEdge, lastOrigEdge, weight, fwd, bwd,
+                    skipEdge1, skipEdge2);
+        }
+
+        @Override
+        public String toString() {
+            return "Shortcut{" +
+                    "baseNode=" + baseNode +
+                    ", adjNode=" + adjNode +
+                    ", firstOrigEdge=" + firstOrigEdge +
+                    ", lastOrigEdge=" + lastOrigEdge +
+                    ", weight=" + weight +
+                    ", fwd=" + fwd +
+                    ", bwd=" + bwd +
+                    ", skipEdge1=" + skipEdge1 +
+                    ", skipEdge2=" + skipEdge2 +
+                    '}';
+        }
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
index 2b56086672..18ae4a100e 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
@@ -17,41 +17,54 @@
  */
 package com.graphhopper.routing.ch;
 
-import com.graphhopper.routing.Dijkstra;
-import com.graphhopper.routing.DijkstraOneToMany;
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.routing.*;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.SimpleBooleanEncodedValue;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.CHEdgeIteratorState;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
-import org.junit.Before;
+import com.graphhopper.util.PMap;
 import org.junit.Test;
 
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Objects;
-import java.util.Set;
+import java.util.*;
 
+import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
+import static com.graphhopper.util.Parameters.Routing.HEADING_PENALTY;
 import static org.junit.Assert.*;
 
 public class NodeBasedNodeContractorTest {
+    // TODO integrate this into CHGraphImpl somehow
+    public final static BooleanEncodedValue SC_ACCESS = new SimpleBooleanEncodedValue("sc_access", true);
+
+    static {
+        SC_ACCESS.init(new EncodedValue.InitializerConfig());
+    }
+
     private final CarFlagEncoder encoder = new CarFlagEncoder();
-    private final EncodingManager encodingManager = new EncodingManager(encoder);
+    private final EncodingManager encodingManager = EncodingManager.create(encoder);
     private final Weighting weighting = new ShortestWeighting(encoder);
     private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
-    private final CHGraph lg = graph.getGraph(CHGraph.class);
+    private final CHGraph lg = graph.getCHGraph();
     private final TraversalMode traversalMode = TraversalMode.NODE_BASED;
-    private Directory dir;
 
-    @Before
-    public void setUp() {
-        dir = new GHDirectory("", DAType.RAM_INT);
+    private NodeContractor createNodeContractor() {
+        return createNodeContractor(lg, weighting);
     }
 
-    private NodeContractor createNodeContractor() {
-        NodeContractor nodeContractor = new NodeBasedNodeContractor(dir, graph, lg, weighting);
+    private NodeContractor createNodeContractor(CHGraph chGraph, Weighting weighting) {
+        NodeContractor nodeContractor = new NodeBasedNodeContractor(chGraph, weighting, new PMap());
         nodeContractor.initFromGraph();
         nodeContractor.prepareContraction();
         return nodeContractor;
@@ -79,7 +92,6 @@ public void testShortestPathSkipNode() {
         createExampleGraph();
         final double normalDist = new Dijkstra(graph, weighting, traversalMode).calcPath(4, 2).getDistance();
         DijkstraOneToMany algo = new DijkstraOneToMany(graph, weighting, traversalMode);
-        CHGraph lg = graph.getGraph(CHGraph.class);
 
         setMaxLevelOnAllNodes();
 
@@ -153,7 +165,7 @@ public void testDirectedGraph() {
         NodeContractor nodeContractor = createNodeContractor();
         nodeContractor.contractNode(1);
         checkShortcuts(
-                expectedShortcut(2, 3, edge1to3, edge2to1bidirected, true, true),
+                expectedShortcut(3, 2, edge1to3, edge2to1bidirected, true, true),
                 expectedShortcut(2, 3, edge2to1directed, edge1to3, true, false)
         );
     }
@@ -173,21 +185,17 @@ public void testFindShortcuts_Roundabout() {
         graph.freeze();
 
         CHEdgeIteratorState sc1to4 = lg.shortcut(1, 4);
-        sc1to4.setFlags(PrepareEncoder.getScDirMask());
-        sc1to4.setWeight(2);
+        sc1to4.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 2);
         sc1to4.setDistance(2);
         sc1to4.setSkippedEdges(iter1to3.getEdge(), iter3to4.getEdge());
 
-        long f = PrepareEncoder.getScFwdDir();
         CHEdgeIteratorState sc4to6 = lg.shortcut(4, 6);
-        sc4to6.setFlags(f);
-        sc4to6.setWeight(2);
+        sc4to6.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 2);
         sc4to6.setDistance(2);
         sc4to6.setSkippedEdges(iter4to5.getEdge(), iter5to6.getEdge());
 
         CHEdgeIteratorState sc6to4 = lg.shortcut(6, 4);
-        sc6to4.setFlags(f);
-        sc6to4.setWeight(3);
+        sc6to4.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 3);
         sc6to4.setDistance(3);
         sc6to4.setSkippedEdges(iter6to8.getEdge(), iter8to4.getEdge());
 
@@ -200,7 +208,7 @@ public void testFindShortcuts_Roundabout() {
 
         Shortcut manualSc1 = expectedShortcut(1, 4, iter1to3, iter3to4, true, true);
         Shortcut manualSc2 = expectedShortcut(4, 6, iter4to5, iter5to6, true, false);
-        Shortcut manualSc3 = expectedShortcut(4, 6, iter6to8, iter8to4, false, true);
+        Shortcut manualSc3 = expectedShortcut(6, 4, iter6to8, iter8to4, true, false);
         checkShortcuts(manualSc1, manualSc2, manualSc3);
 
         // after 'manual contraction' of nodes 3, 5, 8 the graph looks like:
@@ -214,11 +222,10 @@ public void testFindShortcuts_Roundabout() {
         checkShortcuts(manualSc1, manualSc2, manualSc3,
                 // there should be two different shortcuts for both directions!
                 expectedShortcut(1, 6, sc1to4, sc4to6, true, false),
-                expectedShortcut(1, 6, sc6to4, sc1to4, false, true)
+                expectedShortcut(6, 1, sc6to4, sc1to4, true, false)
         );
     }
 
-
     @Test
     public void testShortcutMergeBug() {
         // We refer to this real world situation http://www.openstreetmap.org/#map=19/52.71205/-1.77326
@@ -237,7 +244,7 @@ public void testShortcutMergeBug() {
         NodeContractor nodeContractor = createNodeContractor();
         nodeContractor.contractNode(2);
         checkShortcuts(
-                expectedShortcut(1, 3, edge2to3, edge1to2bidirected, false, true),
+                expectedShortcut(3, 1, edge2to3, edge1to2bidirected, true, false),
                 expectedShortcut(1, 3, edge1to2directed, edge2to3, true, false)
         );
     }
@@ -261,7 +268,7 @@ public void testContractNode_directed_shortcutRequired_reverse() {
         graph.freeze();
         setMaxLevelOnAllNodes();
         createNodeContractor().contractNode(1);
-        checkShortcuts(expectedShortcut(0, 2, edge1, edge2, false, true));
+        checkShortcuts(expectedShortcut(2, 0, edge1, edge2, true, false));
     }
 
     @Test
@@ -272,7 +279,7 @@ public void testContractNode_bidirected_shortcutsRequired() {
         graph.freeze();
         setMaxLevelOnAllNodes();
         createNodeContractor().contractNode(1);
-        checkShortcuts(expectedShortcut(0, 2, edge2, edge1, true, true));
+        checkShortcuts(expectedShortcut(2, 0, edge2, edge1, true, true));
     }
 
     @Test
@@ -288,21 +295,212 @@ public void testContractNode_directed_withWitness() {
         checkNoShortcuts();
     }
 
+    @Test
+    public void testNodeContraction_shortcutDistanceRounding() {
+        assertTrue("this test was constructed assuming we are using the ShortestWeighting", weighting instanceof ShortestWeighting);
+        // 0 ------------> 4
+        //  \             /
+        //   1 --> 2 --> 3
+        double[] distances = {4.019, 1.006, 1.004, 1.006, 1.004};
+        graph.edge(0, 4, distances[0], false);
+        EdgeIteratorState edge1 = graph.edge(0, 1, distances[1], false);
+        EdgeIteratorState edge2 = graph.edge(1, 2, distances[2], false);
+        EdgeIteratorState edge3 = graph.edge(2, 3, distances[3], false);
+        EdgeIteratorState edge4 = graph.edge(3, 4, distances[4], false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+
+        // make sure that distances do not get changed in storage (they might get truncated)
+        AllCHEdgesIterator iter = lg.getAllEdges();
+        double[] storedDistances = new double[iter.length()];
+        int count = 0;
+        while (iter.next()) {
+            storedDistances[count++] = iter.getDistance();
+        }
+        assertArrayEquals(distances, storedDistances, 1.e-6);
+
+        // perform CH contraction
+        contractInOrder(1, 3, 2, 0, 4);
+
+        // first we compare dijkstra with CH to make sure they produce the same results
+        int from = 0;
+        int to = 4;
+        Dijkstra dikstra = new Dijkstra(graph, weighting, TraversalMode.NODE_BASED);
+        Path dijkstraPath = dikstra.calcPath(from, to);
+
+        DijkstraBidirectionCH ch = new DijkstraBidirectionCH(lg, new PreparationWeighting(weighting));
+        Path chPath = ch.calcPath(from, to);
+        assertEquals(dijkstraPath.calcNodes(), chPath.calcNodes());
+        assertEquals(dijkstraPath.getDistance(), chPath.getDistance(), 1.e-6);
+        assertEquals(dijkstraPath.getWeight(), chPath.getWeight(), 1.e-6);
+
+        // on a more detailed level we check that the right shortcuts were added
+        // contracting nodes 1&3 will always introduce shortcuts, but contracting node 2 should not because going from
+        // 0 to 4 directly via edge 4 is cheaper. however, if shortcut distances get truncated it appears as if going
+        // via node 2 is better. here we check that this does not happen.
+        checkShortcuts(
+                expectedShortcut(0, 2, edge1, edge2, true, false),
+                expectedShortcut(2, 4, edge3, edge4, true, false)
+        );
+    }
+
+    /**
+     * similar to the previous test, but using the fastest weighting
+     */
+    @Test
+    public void testNodeContraction_shortcutWeightRounding() {
+        CarFlagEncoder encoder = new CarFlagEncoder();
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        Weighting weighting = new FastestWeighting(encoder);
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
+        CHGraph lg = graph.getCHGraph();
+        // 0 ------------> 4
+        //  \             /
+        //   1 --> 2 --> 3
+        double fac = 60 / 3.6;
+        double[] distances = {fac * 4.019, fac * 1.006, fac * 1.004, fac * 1.006, fac * 1.004};
+        graph.edge(0, 4, distances[0], false);
+        graph.edge(0, 1, distances[1], false);
+        graph.edge(1, 2, distances[2], false);
+        graph.edge(2, 3, distances[3], false);
+        graph.edge(3, 4, distances[4], false);
+        graph.freeze();
+        setMaxLevelOnAllNodes(lg);
+
+        // perform CH contraction
+        contractInOrder(lg, weighting, 1, 3, 2, 0, 4);
+
+        // first we compare dijkstra with CH to make sure they produce the same results
+        int from = 0;
+        int to = 4;
+        Dijkstra dikstra = new Dijkstra(graph, weighting, TraversalMode.NODE_BASED);
+        Path dijkstraPath = dikstra.calcPath(from, to);
+
+        DijkstraBidirectionCH ch = new DijkstraBidirectionCH(lg, new PreparationWeighting(weighting));
+        Path chPath = ch.calcPath(from, to);
+        assertEquals(dijkstraPath.calcNodes(), chPath.calcNodes());
+        assertEquals(dijkstraPath.getDistance(), chPath.getDistance(), 1.e-6);
+        assertEquals(dijkstraPath.getWeight(), chPath.getWeight(), 1.e-6);
+    }
+
+    @Test
+    public void testNodeContraction_preventUnnecessaryShortcutWithLoop() {
+        // there should not be shortcuts where one of the skipped edges is a loop at the node to be contracted,
+        // see also #1583
+        CarFlagEncoder encoder = new CarFlagEncoder();
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        Weighting weighting = new FastestWeighting(encoder);
+        GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
+        CHGraph lg = graph.getCHGraph();
+        // 0 - 1 - 2 - 3
+        // o           o
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 3, 1, true);
+        graph.edge(0, 0, 1, true);
+        graph.edge(3, 3, 1, true);
+
+        graph.freeze();
+        setMaxLevelOnAllNodes(lg);
+        NodeContractor nodeContractor = createNodeContractor(lg, weighting);
+        nodeContractor.contractNode(0);
+        nodeContractor.contractNode(3);
+        checkNoShortcuts(lg);
+    }
+
+    @Test
+    public void routingWithHeading_fails() {
+        // heading does not work properly with CH!
+        // 3 - 2 - x - 0 - 1 - 4
+        //     |           |
+        //     5 - - - - - 6
+        graph.edge(3, 2, 10, true);
+        graph.edge(2, 0, 10, true);
+        graph.edge(0, 1, 10, true);
+        graph.edge(1, 4, 10, true);
+        graph.edge(2, 5, 10, true);
+        graph.edge(5, 6, 10, true);
+        graph.edge(6, 1, 10, true);
+        updateDistancesFor(graph, 3, 0.02, 0.00);
+        updateDistancesFor(graph, 2, 0.02, 0.01);
+        updateDistancesFor(graph, 0, 0.02, 0.03);
+        updateDistancesFor(graph, 1, 0.02, 0.04);
+        updateDistancesFor(graph, 4, 0.02, 0.05);
+        updateDistancesFor(graph, 5, 0.01, 0.01);
+        updateDistancesFor(graph, 6, 0.01, 0.01);
+
+        graph.freeze();
+        setMaxLevelOnAllNodes(lg);
+
+        // perform CH contraction
+        Weighting weighting = new FastestWeighting(encoder, new PMap().put(HEADING_PENALTY, Double.POSITIVE_INFINITY));
+        contractInOrder(lg, weighting, 0, 1, 2, 3, 4, 5, 6);
+
+        // build query graph
+        LocationIndexTree locationIndex = new LocationIndexTree(graph, new RAMDirectory());
+        locationIndex.prepareIndex();
+
+        QueryGraph chQueryGraph = new QueryGraph(lg);
+        chQueryGraph.lookup(Collections.singletonList(locationIndex.findClosest(0.021, 0.02, EdgeFilter.ALL_EDGES)));
+
+        QueryGraph queryGraph = new QueryGraph(graph);
+        queryGraph.lookup(Collections.singletonList(locationIndex.findClosest(0.021, 0.02, EdgeFilter.ALL_EDGES)));
+
+        // without heading
+        {
+            DijkstraBidirectionCH ch = new DijkstraBidirectionCH(chQueryGraph, new PreparationWeighting(weighting));
+            Path chPath = ch.calcPath(7, 3);
+            assertEquals(IntArrayList.from(7, 2, 3), chPath.calcNodes());
+        }
+        // with heading
+        {
+            queryGraph.enforceHeading(7, 90, false);
+            Dijkstra dijkstra = new Dijkstra(queryGraph, weighting, TraversalMode.NODE_BASED);
+            Path path = dijkstra.calcPath(7, 3);
+            assertEquals(IntArrayList.from(7, 0, 1, 6, 5, 2, 3), path.calcNodes());
+
+            chQueryGraph.enforceHeading(7, 90, false);
+            DijkstraBidirectionCH ch = new DijkstraBidirectionCH(chQueryGraph, new PreparationWeighting(weighting));
+            Path chPath = ch.calcPath(7, 3);
+            // the route takes a u-turn at node 1 and 'skips' the virtual node when going from 0 to 3 (because it takes
+            // the shortcut from 1 to 2), which both should not be
+            assertEquals(IntArrayList.from(7, 0, 1, 0, 2, 3), chPath.calcNodes());
+        }
+    }
+
+    private void contractInOrder(int... nodeIds) {
+        contractInOrder(lg, weighting, nodeIds);
+    }
+
+    private void contractInOrder(CHGraph chGraph, Weighting weighting, int... nodeIds) {
+        NodeContractor nodeContractor = createNodeContractor(chGraph, weighting);
+        int level = 0;
+        for (int n : nodeIds) {
+            nodeContractor.contractNode(n);
+            chGraph.setLevel(n, level);
+            level++;
+        }
+    }
+
     /**
      * Queries the ch graph and checks if the graph's shortcuts match the given expected shortcuts.
      */
     private void checkShortcuts(Shortcut... expectedShortcuts) {
+        checkShortcuts(lg, expectedShortcuts);
+    }
+
+    private void checkShortcuts(CHGraph chGraph, Shortcut... expectedShortcuts) {
         Set<Shortcut> expected = setOf(expectedShortcuts);
         if (expected.size() != expectedShortcuts.length) {
             fail("was given duplicate shortcuts");
         }
-        AllCHEdgesIterator iter = lg.getAllEdges();
+        AllCHEdgesIterator iter = chGraph.getAllEdges();
         Set<Shortcut> given = new HashSet<>();
         while (iter.next()) {
             if (iter.isShortcut()) {
                 given.add(new Shortcut(
                         iter.getBaseNode(), iter.getAdjNode(), iter.getWeight(), iter.getDistance(),
-                        iter.isForward(encoder), iter.isBackward(encoder),
+                        iter.get(SC_ACCESS), iter.getReverse(SC_ACCESS),
                         iter.getSkippedEdge1(), iter.getSkippedEdge2()));
             }
         }
@@ -310,7 +508,11 @@ private void checkShortcuts(Shortcut... expectedShortcuts) {
     }
 
     private void checkNoShortcuts() {
-        checkShortcuts();
+        checkShortcuts(lg);
+    }
+
+    private void checkNoShortcuts(CHGraph chGraph) {
+        checkShortcuts(chGraph);
     }
 
     private Shortcut expectedShortcut(int baseNode, int adjNode, EdgeIteratorState edge1, EdgeIteratorState edge2,
@@ -323,15 +525,17 @@ private Shortcut expectedShortcut(int baseNode, int adjNode, EdgeIteratorState e
     }
 
     private Set<Shortcut> setOf(Shortcut... shortcuts) {
-        Set<Shortcut> result = new HashSet<>();
-        result.addAll(Arrays.asList(shortcuts));
-        return result;
+        return new HashSet<>(Arrays.asList(shortcuts));
     }
 
     private void setMaxLevelOnAllNodes() {
-        int nodes = lg.getNodes();
+        setMaxLevelOnAllNodes(lg);
+    }
+
+    private void setMaxLevelOnAllNodes(CHGraph chGraph) {
+        int nodes = chGraph.getNodes();
         for (int node = 0; node < nodes; node++) {
-            lg.setLevel(node, nodes);
+            chGraph.setLevel(node, nodes);
         }
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/ch/OnFlyStatisticsCalculatorTest.java b/core/src/test/java/com/graphhopper/routing/ch/OnFlyStatisticsCalculatorTest.java
new file mode 100644
index 0000000000..32d8435169
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/OnFlyStatisticsCalculatorTest.java
@@ -0,0 +1,39 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class OnFlyStatisticsCalculatorTest {
+
+    @Test
+    public void testOnFlyMeanAndVarianceCalculation() {
+        OnFlyStatisticsCalculator calc = new OnFlyStatisticsCalculator();
+        calc.addObservation(5);
+        calc.addObservation(7);
+        calc.addObservation(10);
+        calc.addObservation(12);
+        calc.addObservation(17);
+        assertEquals(10.2, calc.getMean(), 1.e-6);
+        assertEquals(17.36, calc.getVariance(), 1.e-6);
+
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java b/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java
new file mode 100644
index 0000000000..4eeb5f876c
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/Path4CHTest.java
@@ -0,0 +1,166 @@
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.AbstractBidirectionEdgeCHNoSOD;
+import com.graphhopper.routing.DijkstraBidirectionEdgeCHNoSOD;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.LevelEdgeFilter;
+import com.graphhopper.routing.util.MotorcycleFlagEncoder;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class Path4CHTest {
+    private final int maxTurnCosts = 10;
+    private GraphHopperStorage graph;
+    private CHGraph chGraph;
+    private FlagEncoder encoder;
+    private Weighting weighting;
+    private TurnCostExtension turnCostExtension;
+
+    @Before
+    public void init() {
+        encoder = new MotorcycleFlagEncoder(5, 5, maxTurnCosts);
+        EncodingManager em = EncodingManager.create(encoder);
+        weighting = new FastestWeighting(encoder);
+        graph = new GraphBuilder(em).setEdgeBasedCH(true).setCHGraph(weighting).create();
+        chGraph = graph.getCHGraph();
+        turnCostExtension = (TurnCostExtension) graph.getExtension();
+    }
+
+    @Test
+    public void shortcut_chain() {
+        // 0   2   4   6   8
+        //  \ / \ / \ / \ /
+        //   1   3   5   7
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(4, 5, 1, false);
+        graph.edge(5, 6, 1, false);
+        graph.edge(6, 7, 1, false);
+        graph.edge(7, 8, 1, false);
+        graph.freeze();
+        addTurnCost(1, 2, 3, 4);
+        addTurnCost(3, 4, 5, 2);
+        addTurnCost(5, 6, 7, 3);
+        // we 'contract' the graph such that only a few shortcuts are created and that the fwd/bwd searches for the
+        // 0-8 query meet at node 4 (make sure we include all three cases where turn cost times might come to play:
+        // fwd/bwd search and meeting point)
+        addShortcut(0, 2, 0, 1, 0, 1, 0.12, 2, 0);
+        addShortcut(2, 4, 2, 3, 2, 3, 0.12, 2, 0);
+        addShortcut(4, 6, 4, 5, 4, 5, 0.12, 2, 0);
+        addShortcut(6, 8, 6, 7, 6, 7, 0.12, 2, 0);
+        setCHOrder(1, 3, 5, 7, 0, 8, 2, 6, 4);
+
+        // going from 0 to 8 will create shortest path tree entries that follow the shortcuts.
+        // it is important that the original edge ids are used to calculate the turn costs.
+        checkPath(0, 8, 0.48, 8, 9);
+    }
+
+    private void setCHOrder(int... nodeIds) {
+        for (int i = 0; i < nodeIds.length; i++) {
+            chGraph.setLevel(nodeIds[i], i);
+        }
+    }
+
+    @Test
+    public void paths_different_fwd_bwd_speeds() {
+        //   5 3 2 1 4    turn costs ->
+        // 0-1-2-3-4-5-6
+        //   0 1 4 2 3    turn costs <-
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        EdgeIteratorState edge0 = graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge1 = graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge2 = graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge3 = graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge4 = graph.edge(4, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge5 = graph.edge(5, 6, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+
+        // turn costs ->
+        addTurnCost(edge0, edge1, 1, 5);
+        addTurnCost(edge1, edge2, 2, 3);
+        addTurnCost(edge2, edge3, 3, 2);
+        addTurnCost(edge3, edge4, 4, 1);
+        addTurnCost(edge4, edge5, 5, 4);
+        // turn costs <-
+        addTurnCost(edge5, edge4, 5, 3);
+        addTurnCost(edge4, edge3, 4, 2);
+        addTurnCost(edge3, edge2, 3, 4);
+        addTurnCost(edge2, edge1, 2, 1);
+        addTurnCost(edge1, edge0, 1, 0);
+
+        // shortcuts ->
+        addShortcut(0, 2, 0, 1, 0, 1, 0.12, 2, 5);
+        addShortcut(2, 4, 2, 3, 2, 3, 0.12, 2, 2);
+        addShortcut(4, 6, 4, 5, 4, 5, 0.12, 2, 4);
+        addShortcut(2, 6, 2, 5, 7, 8, 0.24, 4, 7);
+        addShortcut(0, 6, 0, 5, 6, 9, 0.36, 6, 12);
+
+        // shortcuts <-
+        addShortcut(6, 4, 5, 4, 5, 4, 0.24, 2, 3);
+        addShortcut(4, 2, 3, 2, 3, 2, 0.24, 2, 4);
+        addShortcut(2, 0, 1, 0, 1, 0, 0.24, 2, 0);
+        addShortcut(6, 2, 5, 2, 11, 12, 0.48, 4, 9);
+        addShortcut(6, 0, 5, 0, 14, 13, 0.60, 6, 10);
+
+        // strictly it would be cleaner to manually build the SPT and extract the path, but for convenience we
+        // use the routing algo to build it
+        checkPath(0, 6, 0.36, 6, 15);
+        checkPath(6, 0, 0.72, 6, 10);
+        checkPath(1, 3, 0.12, 2, 3);
+        checkPath(3, 1, 0.24, 2, 1);
+        checkPath(1, 5, 0.24, 4, 6);
+        checkPath(5, 1, 0.48, 4, 7);
+    }
+
+    private void addTurnCost(int from, int via, int to, int cost) {
+        addTurnCost(getEdge(from, via), getEdge(via, to), via, cost);
+    }
+
+    private void addTurnCost(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode, int cost) {
+        turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(false, cost));
+    }
+
+    private EdgeIteratorState getEdge(int from, int to) {
+        return GHUtility.getEdge(graph, from, to);
+    }
+
+    private void addShortcut(int from, int to, int origFirst, int origLast, int skip1, int skip2, double edgeWeight, double distance, int turnCost) {
+        double weight = edgeWeight + turnCost * 1000;
+        chGraph.shortcutEdgeBased(from, to, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2, origFirst, origLast);
+    }
+
+    private void checkPath(int from, int to, double edgeWeight, int distance, int turnCostTime) {
+        double expectedWeight = (edgeWeight + turnCostTime);
+        Path path = createAlgo().calcPath(from, to);
+        assertEquals("wrong weight", expectedWeight, path.getWeight(), 1.e-3);
+        assertEquals("wrong distance", distance, path.getDistance(), 1.e-3);
+        assertEquals("wrong time", expectedWeight * 1000, path.getTime(), 1.e-3);
+    }
+
+    private AbstractBidirectionEdgeCHNoSOD createAlgo() {
+        TurnWeighting chTurnWeighting = new TurnWeighting(new PreparationWeighting(weighting), turnCostExtension);
+        CHGraph lg = graph.getCHGraph(weighting);
+        AbstractBidirectionEdgeCHNoSOD algo = new DijkstraBidirectionEdgeCHNoSOD(lg, chTurnWeighting);
+        algo.setEdgeFilter(new LevelEdgeFilter(lg));
+        return algo;
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 104132d0bd..8b73762ab3 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -20,21 +20,19 @@
 import com.carrotsearch.hppc.IntArrayList;
 import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.routing.*;
-import com.graphhopper.routing.util.BikeFlagEncoder;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Arrays;
-import java.util.List;
+import java.util.*;
 
+import static com.graphhopper.routing.AbstractRoutingAlgorithmTester.updateDistancesFor;
 import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
 import static org.junit.Assert.*;
 
@@ -42,8 +40,8 @@
  * @author Peter Karich
  */
 public class PrepareContractionHierarchiesTest {
-    private final CarFlagEncoder carEncoder = new CarFlagEncoder();
-    private final EncodingManager encodingManager = new EncodingManager(carEncoder);
+    private final CarFlagEncoder carEncoder = new CarFlagEncoder("speed_two_directions=true");
+    private final EncodingManager encodingManager = EncodingManager.create(carEncoder);
     private final Weighting weighting = new ShortestWeighting(carEncoder);
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
     private Directory dir;
@@ -123,7 +121,11 @@ public static Graph initShortcutsGraph(Graph g) {
     }
 
     GraphHopperStorage createGHStorage() {
-        return new GraphBuilder(encodingManager).setCHGraph(weighting).create();
+        return createGHStorage(weighting);
+    }
+
+    GraphHopperStorage createGHStorage(Weighting w) {
+        return new GraphBuilder(encodingManager).setCHGraph(w).create();
     }
 
     GraphHopperStorage createExampleGraph() {
@@ -150,32 +152,41 @@ public void setUp() {
         dir = new GHDirectory("", DAType.RAM_INT);
     }
 
+    @Test
+    public void testReturnsCorrectWeighting() {
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getCHGraph();
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
+        prepare.doWork();
+        assertSame(weighting, prepare.getWeighting());
+    }
+
     @Test
     public void testAddShortcuts() {
         GraphHopperStorage g = createExampleGraph();
-        CHGraph lg = g.getGraph(CHGraph.class);
-        int old = lg.getAllEdges().length();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        CHGraph lg = g.getCHGraph();
+        int old = lg.getEdges();
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
-        assertEquals(old + 2, lg.getAllEdges().length());
+        assertEquals(old + 2, lg.getEdges());
     }
 
     @Test
     public void testMoreComplexGraph() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         initShortcutsGraph(lg);
         int oldCount = g.getAllEdges().length();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
-        assertEquals(oldCount, g.getAllEdges().length());
-        assertEquals(oldCount + 7, lg.getAllEdges().length());
+        assertEquals(oldCount, g.getEdges());
+        assertEquals(oldCount + 7, lg.getEdges());
     }
 
     @Test
     public void testDirectedGraph() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         g.edge(5, 4, 3, false);
         g.edge(4, 5, 10, false);
         g.edge(2, 4, 1, false);
@@ -185,24 +196,24 @@ public void testDirectedGraph() {
         g.freeze();
         int oldCount = GHUtility.count(lg.getAllEdges());
         assertEquals(6, oldCount);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
         assertEquals(oldCount + 2, GHUtility.count(lg.getAllEdges()));
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(4, 2);
         assertEquals(3, p.getDistance(), 1e-6);
-        assertEquals(IntArrayList.from(new int[]{4, 3, 5, 2}), p.calcNodes());
+        assertEquals(IntArrayList.from(4, 3, 5, 2), p.calcNodes());
     }
 
     @Test
     public void testDirectedGraph2() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         initDirected2(g);
         int oldCount = GHUtility.count(g.getAllEdges());
         assertEquals(19, oldCount);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
         // PrepareTowerNodesShortcutsTest.printEdges(g);
         assertEquals(oldCount, g.getAllEdges().length());
@@ -210,12 +221,12 @@ public void testDirectedGraph2() {
 
         long numShortcuts = 9;
         assertEquals(numShortcuts, prepare.getShortcuts());
-        assertEquals(oldCount + numShortcuts, lg.getAllEdges().length());
+        assertEquals(oldCount + numShortcuts, lg.getEdges());
         assertEquals(oldCount + numShortcuts, GHUtility.count(lg.getAllEdges()));
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(0, 10);
         assertEquals(10, p.getDistance(), 1e-6);
-        assertEquals(IntArrayList.from(new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}), p.calcNodes());
+        assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10), p.calcNodes());
     }
 
     void initRoundaboutGraph(Graph g) {
@@ -272,52 +283,59 @@ void initRoundaboutGraph(Graph g) {
     @Test
     public void testRoundaboutUnpacking() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         initRoundaboutGraph(g);
         int oldCount = g.getAllEdges().length();
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
-        assertEquals(oldCount, g.getAllEdges().length());
-        assertEquals(oldCount + 23, lg.getAllEdges().length());
+        assertEquals(oldCount, g.getEdges());
+        assertEquals(oldCount + 23, lg.getEdges());
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(4, 7);
-        assertEquals(IntArrayList.from(new int[]{4, 5, 6, 7}), p.calcNodes());
+        assertEquals(IntArrayList.from(4, 5, 6, 7), p.calcNodes());
     }
 
     void initUnpackingGraph(GraphHopperStorage ghStorage, CHGraph g, Weighting w) {
-        final long flags = carEncoder.setProperties(30, true, false);
+        final IntsRef edgeFlags = encodingManager.createEdgeFlags();
+        carEncoder.getAccessEnc().setBool(false, edgeFlags, true);
+        carEncoder.getAccessEnc().setBool(true, edgeFlags, false);
+        carEncoder.getAverageSpeedEnc().setDecimal(false, edgeFlags, 30.0);
         double dist = 1;
-        g.edge(10, 0).setDistance(dist).setFlags(flags);
+        g.edge(10, 0).setDistance(dist).setFlags(edgeFlags);
         EdgeIteratorState edgeState01 = g.edge(0, 1);
-        edgeState01.setDistance(dist).setFlags(flags);
-        EdgeIteratorState edgeState12 = g.edge(1, 2).setDistance(dist).setFlags(flags);
-        EdgeIteratorState edgeState23 = g.edge(2, 3).setDistance(dist).setFlags(flags);
-        EdgeIteratorState edgeState34 = g.edge(3, 4).setDistance(dist).setFlags(flags);
-        EdgeIteratorState edgeState45 = g.edge(4, 5).setDistance(dist).setFlags(flags);
-        EdgeIteratorState edgeState56 = g.edge(5, 6).setDistance(dist).setFlags(flags);
-        long oneDirFlags = PrepareEncoder.getScFwdDir();
+        edgeState01.setDistance(dist).setFlags(edgeFlags);
+        EdgeIteratorState edgeState12 = g.edge(1, 2).setDistance(dist).setFlags(edgeFlags);
+        EdgeIteratorState edgeState23 = g.edge(2, 3).setDistance(dist).setFlags(edgeFlags);
+        EdgeIteratorState edgeState34 = g.edge(3, 4).setDistance(dist).setFlags(edgeFlags);
+        EdgeIteratorState edgeState45 = g.edge(4, 5).setDistance(dist).setFlags(edgeFlags);
+        EdgeIteratorState edgeState56 = g.edge(5, 6).setDistance(dist).setFlags(edgeFlags);
 
         int tmpEdgeId = edgeState01.getEdge();
         ghStorage.freeze();
         CHEdgeIteratorState sc0_2 = g.shortcut(0, 2);
         int x = EdgeIterator.NO_EDGE;
-        sc0_2.setWeight(w.calcWeight(edgeState01, false, x) + w.calcWeight(edgeState12, false, x)).setDistance(2 * dist).setFlags(oneDirFlags);
+        sc0_2.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), w.calcWeight(edgeState01, false, x) + w.calcWeight(edgeState12, false, x));
+        sc0_2.setDistance(2 * dist);
         sc0_2.setSkippedEdges(tmpEdgeId, edgeState12.getEdge());
         tmpEdgeId = sc0_2.getEdge();
         CHEdgeIteratorState sc0_3 = g.shortcut(0, 3);
-        sc0_3.setWeight(sc0_2.getWeight() + w.calcWeight(edgeState23, false, x)).setDistance(3 * dist).setFlags(oneDirFlags);
+        sc0_3.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), sc0_2.getWeight() + w.calcWeight(edgeState23, false, x));
+        sc0_3.setDistance(3 * dist);
         sc0_3.setSkippedEdges(tmpEdgeId, edgeState23.getEdge());
         tmpEdgeId = sc0_3.getEdge();
         CHEdgeIteratorState sc0_4 = g.shortcut(0, 4);
-        sc0_4.setWeight(sc0_3.getWeight() + w.calcWeight(edgeState34, false, x)).setDistance(4).setFlags(oneDirFlags);
+        sc0_4.setDistance(4);
+        sc0_4.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), sc0_3.getWeight() + w.calcWeight(edgeState34, false, x));
         sc0_4.setSkippedEdges(tmpEdgeId, edgeState34.getEdge());
         tmpEdgeId = sc0_4.getEdge();
         CHEdgeIteratorState sc0_5 = g.shortcut(0, 5);
-        sc0_5.setWeight(sc0_4.getWeight() + w.calcWeight(edgeState45, false, x)).setDistance(5).setFlags(oneDirFlags);
+        sc0_5.setDistance(5);
+        sc0_5.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), sc0_4.getWeight() + w.calcWeight(edgeState45, false, x));
         sc0_5.setSkippedEdges(tmpEdgeId, edgeState45.getEdge());
         tmpEdgeId = sc0_5.getEdge();
         CHEdgeIteratorState sc0_6 = g.shortcut(0, 6);
-        sc0_6.setWeight(sc0_5.getWeight() + w.calcWeight(edgeState56, false, x)).setDistance(6).setFlags(oneDirFlags);
+        sc0_6.setDistance(6);
+        sc0_6.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), sc0_5.getWeight() + w.calcWeight(edgeState56, false, x));
         sc0_6.setSkippedEdges(tmpEdgeId, edgeState56.getEdge());
         g.setLevel(0, 10);
         g.setLevel(6, 9);
@@ -331,34 +349,197 @@ void initUnpackingGraph(GraphHopperStorage ghStorage, CHGraph g, Weighting w) {
 
     @Test
     public void testUnpackingOrder() {
-        GraphHopperStorage ghStorage = createGHStorage();
-        CHGraph lg = ghStorage.getGraph(CHGraph.class);
-        initUnpackingGraph(ghStorage, lg, weighting);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, weighting, tMode);
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getCHGraph();
+        initUnpackingGraph(g, lg, weighting);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
+        prepare.doWork();
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-5);
-        assertEquals(IntArrayList.from(new int[]{10, 0, 1, 2, 3, 4, 5, 6}), p.calcNodes());
+        assertEquals(IntArrayList.from(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
     }
 
     @Test
     public void testUnpackingOrder_Fastest() {
-        GraphHopperStorage ghStorage = createGHStorage();
-        CHGraph lg = ghStorage.getGraph(CHGraph.class);
+        GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getCHGraph();
         Weighting w = new FastestWeighting(carEncoder);
-        initUnpackingGraph(ghStorage, lg, w);
+        initUnpackingGraph(g, lg, w);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
+        prepare.doWork();
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, weighting, tMode));
         Path p = algo.calcPath(10, 6);
         assertEquals(7, p.getDistance(), 1e-1);
-        assertEquals(IntArrayList.from(new int[]{10, 0, 1, 2, 3, 4, 5, 6}), p.calcNodes());
+        assertEquals(IntArrayList.from(10, 0, 1, 2, 3, 4, 5, 6), p.calcNodes());
+    }
+
+    @Test
+    public void testDisconnects() {
+        final GraphHopperStorage g = createGHStorage();
+        CHGraph lg = g.getCHGraph();
+        //            4
+        //            v
+        //            0
+        //            v
+        //  8 -> 3 -> 6 -> 1 -> 5
+        //            v
+        //            2
+        //            v
+        //            7
+        g.edge(8, 3, 1, false);
+        g.edge(3, 6, 1, false);
+        g.edge(6, 1, 1, false);
+        g.edge(1, 5, 1, false);
+        g.edge(4, 0, 1, false);
+        g.edge(0, 6, 1, false);
+        g.edge(6, 2, 1, false);
+        g.edge(2, 7, 1, false);
+        g.freeze();
+
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg)
+                .useFixedNodeOrdering(new NodeOrderingProvider() {
+                    @Override
+                    public int getNodeIdForLevel(int level) {
+                        return level;
+                    }
+
+                    @Override
+                    public int getNumNodes() {
+                        return g.getNodes();
+                    }
+                });
+        prepare.doWork();
+        CHEdgeExplorer explorer = lg.createEdgeExplorer();
+        // shortcuts (and edges) leading to or coming from lower level nodes should be disconnected
+        // so far we are only disconnecting shortcuts however, see comments in CHGraphImpl.
+        assertEquals(buildSet(7, 8, 0, 1, 2, 3), GHUtility.getNeighbors(explorer.setBaseNode(6)));
+        assertEquals(buildSet(6, 0), GHUtility.getNeighbors(explorer.setBaseNode(4)));
+        assertEquals(buildSet(6, 1), GHUtility.getNeighbors(explorer.setBaseNode(5)));
+        assertEquals(buildSet(8, 2), GHUtility.getNeighbors(explorer.setBaseNode(7)));
+        assertEquals(buildSet(3), GHUtility.getNeighbors(explorer.setBaseNode(8)));
+    }
+
+    private Set<Integer> buildSet(Integer... values) {
+        return new HashSet<>(Arrays.asList(values));
+    }
+
+    @Test
+    public void testStallOnDemandViaVirtuaNode_issue1574() {
+        // this test reproduces the issue that appeared in issue1574
+        // the problem is very intricate and a combination of all these things:
+        // * contraction hierarchies
+        // * stall-on-demand (without sod there is no problem, at least in this test)
+        // * shortcuts weight rounding
+        // * via nodes/virtual edges and the associated weight precision (without virtual nodes between source and target
+        //   there is no problem, but this can happen for via routes
+        // * the fact that the LevelEdgeFilter always accepts virtual nodes
+        // here we wil construct a special case where a connection is not found without the fix in #1574.
+
+        // use fastest weighting in this test to be able to fine-tune some weights via the speed (see below)
+        Weighting fastestWeighting = new FastestWeighting(carEncoder);
+        final GraphHopperStorage g = createGHStorage(fastestWeighting);
+        CHGraph lg = g.getCHGraph();
+        // the following graph reproduces the issue. note that we will use the node ids as ch levels, so there will
+        // be a shortcut 3->2 visible at node 2 and another one 3->4 visible at node 3.
+        // we will fine-tune the edge-speeds such that without the fix node 4 will be stalled and node 5 will not get
+        // discovered. consequently, no path will be found, because only the forward search runs (from 0 to 7 the
+        // shortest path is strictly upward). node 4 is only stalled when node 2 gets stalled before, which in turn will
+        // happen due to the the virtual node between 3 and 1.
+        //
+        // start 0 - 3 - x - 1 - 2
+        //             \         |
+        //               sc ---- 4 - 5 - 6 - 7 finish
+        g.edge(0, 3, 1, true);
+        EdgeIteratorState edge31 = g.edge(3, 1, 1, true);
+        g.edge(1, 2, 1, true);
+        EdgeIteratorState edge24 = g.edge(2, 4, 1, true);
+        g.edge(4, 5, 1, true);
+        g.edge(5, 6, 1, true);
+        g.edge(6, 7, 1, true);
+        updateDistancesFor(g, 0, 0.001, 0.0000);
+        updateDistancesFor(g, 3, 0.001, 0.0001);
+        updateDistancesFor(g, 1, 0.001, 0.0002);
+        updateDistancesFor(g, 2, 0.001, 0.0003);
+        updateDistancesFor(g, 4, 0.000, 0.0003);
+        updateDistancesFor(g, 5, 0.000, 0.0004);
+        updateDistancesFor(g, 6, 0.000, 0.0005);
+        updateDistancesFor(g, 7, 0.000, 0.0006);
+
+        // we use the speed to fine tune some weights:
+        // the weight of edge 3-1 is chosen such that node 2 gets stalled in the forward search via the incoming shortcut
+        // at node 2 coming from 3. this happens because due to the virtual node x between 3 and 1, the weight of the
+        // spt entry at 2 is different to the sum of the weights of the spt entry at node 3 and the shortcut edge. this
+        // is due to different floating point rounding arithmetic of shortcuts and virtual edges on the query graph.
+        edge31.set(carEncoder.getAverageSpeedEnc(), 22);
+        edge31.setReverse(carEncoder.getAverageSpeedEnc(), 22);
+
+        // just stalling node 2 alone would not lead to connection not found, because the shortcut 3-4 still finds node
+        // 4. however, we can choose the weight of edge 2-4 such that node 4 also gets stalled via node 2.
+        // it is important that node 2 gets stalled before otherwise node 4 would have already be discovered.
+        // note that without the virtual node between 3 and 1 node 2 would not even be explored in the forward search,
+        // but because of the virtual node the strict upward search is modified and goes like 0-3-x-1-2.
+        edge24.set(carEncoder.getAverageSpeedEnc(), 27.5);
+        edge24.setReverse(carEncoder.getAverageSpeedEnc(), 27.5);
+
+        // prepare ch, use node ids as levels
+        PrepareContractionHierarchies pch = createPrepareContractionHierarchies(g, lg, fastestWeighting);
+        pch.useFixedNodeOrdering(new NodeOrderingProvider() {
+            @Override
+            public int getNodeIdForLevel(int level) {
+                return level;
+            }
+
+            @Override
+            public int getNumNodes() {
+                return g.getNodes();
+            }
+        }).doWork();
+        assertEquals("there should be exactly two (bidirectional) shortcuts (2-3) and (3-4)", 2, lg.getEdges() - lg.getOriginalEdges());
+
+        // insert virtual node and edges
+        QueryResult qr = new QueryResult(0.0001, 0.0015);
+        qr.setClosestEdge(edge31);
+        qr.setSnappedPosition(QueryResult.Position.EDGE);
+        qr.setClosestNode(8);
+        qr.setWayIndex(0);
+        qr.calcSnappedPoint(new DistanceCalc2D());
+        QueryGraph queryGraph = new QueryGraph(lg);
+        queryGraph.lookup(Collections.singletonList(qr));
+
+        // we make sure our weight fine tunings do what they are supposed to
+        double weight03 = getWeight(queryGraph, fastestWeighting, 0, 3, false);
+        double scWeight23 = weight03 + ((CHEdgeIteratorState) getEdge(lg, 2, 3, true)).getWeight();
+        double scWeight34 = weight03 + ((CHEdgeIteratorState) getEdge(lg, 3, 4, false)).getWeight();
+        double sptWeight2 = weight03 + getWeight(queryGraph, fastestWeighting, 3, 8, false) + getWeight(queryGraph, fastestWeighting, 8, 1, false) + getWeight(queryGraph, fastestWeighting, 1, 2, false);
+        double sptWeight4 = sptWeight2 + getWeight(queryGraph, fastestWeighting, 2, 4, false);
+        assertTrue("incoming shortcut weight 3->2 should be smaller than sptWeight at node 2 to make sure 2 gets stalled", scWeight23 < sptWeight2);
+        assertTrue("sptWeight at node 4 should be smaller than shortcut weight 3->4 to make sure node 4 gets stalled", sptWeight4 < scWeight34);
+
+        Path path = pch.createAlgo(queryGraph, AlgorithmOptions.start().build()).calcPath(0, 7);
+        assertEquals("wrong or no path found", IntArrayList.from(0, 3, 8, 1, 2, 4, 5, 6, 7), path.calcNodes());
+    }
+
+    private double getWeight(Graph graph, Weighting w, int from, int to, boolean incoming) {
+        return w.calcWeight(getEdge(graph, from, to, false), incoming, -1);
+    }
+
+    private EdgeIteratorState getEdge(Graph graph, int from, int to, boolean incoming) {
+        EdgeFilter filter = incoming ? DefaultEdgeFilter.inEdges(carEncoder) : DefaultEdgeFilter.outEdges(carEncoder);
+        EdgeIterator iter = graph.createEdgeExplorer(filter).setBaseNode(from);
+        while (iter.next()) {
+            if (iter.getAdjNode() == to) {
+                return iter;
+            }
+        }
+        throw new IllegalArgumentException("Could not find edge from: " + from + " to: " + to);
     }
 
     @Test
     public void testCircleBug() {
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         //  /--1
         // -0--/
         //  |
@@ -366,7 +547,7 @@ public void testCircleBug() {
         g.edge(0, 1, 4, true);
         g.edge(0, 2, 10, true);
         g.edge(0, 3, 10, true);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
         assertEquals(0, prepare.getShortcuts());
     }
@@ -379,7 +560,7 @@ public void testBug178() {
         //   \-<-/
         //
         GraphHopperStorage g = createGHStorage();
-        CHGraph lg = g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         g.edge(1, 2, 1, false);
         g.edge(2, 1, 1, false);
 
@@ -390,7 +571,7 @@ public void testBug178() {
         g.edge(3, 4, 1, true);
         g.edge(6, 3, 1, true);
 
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, g, lg, weighting, tMode);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg);
         prepare.doWork();
         assertEquals(2, prepare.getShortcuts());
     }
@@ -439,7 +620,7 @@ public void testBits() {
     public void testMultiplePreparationsIdenticalView() {
         CarFlagEncoder tmpCarEncoder = new CarFlagEncoder();
         BikeFlagEncoder tmpBikeEncoder = new BikeFlagEncoder();
-        EncodingManager tmpEncodingManager = new EncodingManager(tmpCarEncoder, tmpBikeEncoder);
+        EncodingManager tmpEncodingManager = EncodingManager.create(tmpCarEncoder, tmpBikeEncoder);
 
         // FastestWeighting would lead to different shortcuts due to different default speeds for bike and car
         Weighting carWeighting = new ShortestWeighting(tmpCarEncoder);
@@ -452,7 +633,7 @@ public void testMultiplePreparationsIdenticalView() {
         ghStorage.freeze();
 
         for (Weighting w : chWeightings) {
-            checkPath(ghStorage, w, 7, 5, IntArrayList.from(new int[]{3, 9, 14, 16, 13, 12}));
+            checkPath(ghStorage, w, 7, 5, IntArrayList.from(3, 9, 14, 16, 13, 12));
         }
     }
 
@@ -460,7 +641,7 @@ public void testMultiplePreparationsIdenticalView() {
     public void testMultiplePreparationsDifferentView() {
         CarFlagEncoder tmpCarEncoder = new CarFlagEncoder();
         BikeFlagEncoder tmpBikeEncoder = new BikeFlagEncoder();
-        EncodingManager tmpEncodingManager = new EncodingManager(tmpCarEncoder, tmpBikeEncoder);
+        EncodingManager tmpEncodingManager = EncodingManager.create(tmpCarEncoder, tmpBikeEncoder);
 
         Weighting carWeighting = new FastestWeighting(tmpCarEncoder);
         Weighting bikeWeighting = new FastestWeighting(tmpBikeEncoder);
@@ -468,19 +649,70 @@ public void testMultiplePreparationsDifferentView() {
         List<Weighting> chWeightings = Arrays.asList(carWeighting, bikeWeighting);
         GraphHopperStorage ghStorage = new GraphHopperStorage(chWeightings, dir, tmpEncodingManager, false, new GraphExtension.NoOpExtension()).create(1000);
         initShortcutsGraph(ghStorage);
-        EdgeIteratorState edge = GHUtility.getEdge(ghStorage, 9, 14);
-        edge.setFlags(tmpBikeEncoder.setAccess(edge.getFlags(), false, false));
+        EdgeIteratorState edge = GHUtility.getEdge(ghStorage, 9, 14).
+                set(tmpBikeEncoder.getAccessEnc(), false).setReverse(tmpBikeEncoder.getAccessEnc(), false);
 
         ghStorage.freeze();
 
-        checkPath(ghStorage, carWeighting, 7, 5, IntArrayList.from(new int[]{3, 9, 14, 16, 13, 12}));
+        checkPath(ghStorage, carWeighting, 7, 5, IntArrayList.from(3, 9, 14, 16, 13, 12));
         // detour around blocked 9,14
-        checkPath(ghStorage, bikeWeighting, 9, 5, IntArrayList.from(new int[]{3, 10, 14, 16, 13, 12}));
+        checkPath(ghStorage, bikeWeighting, 9, 5, IntArrayList.from(3, 10, 14, 16, 13, 12));
     }
 
-    void checkPath(GraphHopperStorage ghStorage, Weighting w, int expShortcuts, double expDistance, IntIndexedContainer expNodes) {
-        CHGraph lg = ghStorage.getGraph(CHGraph.class, w);
-        PrepareContractionHierarchies prepare = new PrepareContractionHierarchies(dir, ghStorage, lg, w, tMode);
+    @Test
+    public void testReusingNodeOrdering() {
+        CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        MotorcycleFlagEncoder motorCycleEncoder = new MotorcycleFlagEncoder();
+        EncodingManager em = EncodingManager.create(carFlagEncoder, motorCycleEncoder);
+        Weighting carWeighting = new FastestWeighting(carFlagEncoder);
+        Weighting motorCycleWeighting = new FastestWeighting(motorCycleEncoder);
+        Directory dir = new RAMDirectory();
+        GraphHopperStorage ghStorage = new GraphHopperStorage(Arrays.asList(carWeighting, motorCycleWeighting), dir, em, false, new GraphExtension.NoOpExtension());
+        ghStorage.create(1000);
+
+        int numNodes = 5_000;
+        int numQueries = 100;
+        long seed = System.nanoTime();
+        Random rnd = new Random(seed);
+        GHUtility.buildRandomGraph(ghStorage, rnd, numNodes, 1.3, true, true, carFlagEncoder.getAverageSpeedEnc(), 0.7, 0.9, 0.8);
+        ghStorage.freeze();
+
+        // create CH for cars
+        StopWatch sw = new StopWatch().start();
+        CHGraph carCH = ghStorage.getCHGraph(carWeighting);
+        TraversalMode traversalMode = TraversalMode.NODE_BASED;
+        PrepareContractionHierarchies carPch = new PrepareContractionHierarchies(carCH, carWeighting, traversalMode);
+        carPch.doWork();
+        long timeCar = sw.stop().getMillis();
+
+        // create CH for motorcycles, re-use car contraction order
+        // this speeds up contraction significantly, but can lead to slower queries
+        sw = new StopWatch().start();
+        CHGraph motorCycleCH = ghStorage.getCHGraph(motorCycleWeighting);
+        NodeOrderingProvider nodeOrderingProvider = carCH.getNodeOrderingProvider();
+        PrepareContractionHierarchies motorCyclePch = new PrepareContractionHierarchies(motorCycleCH, motorCycleWeighting, traversalMode)
+                .useFixedNodeOrdering(nodeOrderingProvider);
+        motorCyclePch.doWork();
+
+        // run a few sample queries to check correctness
+        for (int i = 0; i < numQueries; ++i) {
+            Dijkstra dijkstra = new Dijkstra(ghStorage, motorCycleWeighting, traversalMode);
+            RoutingAlgorithm chAlgo = motorCyclePch.createAlgo(motorCycleCH, AlgorithmOptions.start().weighting(motorCycleWeighting).build());
+
+            int from = rnd.nextInt(numNodes);
+            int to = rnd.nextInt(numNodes);
+            double dijkstraWeight = dijkstra.calcPath(from, to).getWeight();
+            double chWeight = chAlgo.calcPath(from, to).getWeight();
+            assertEquals(dijkstraWeight, chWeight, 1.e-1);
+        }
+        long timeMotorCycle = sw.getMillis();
+
+        assertTrue("reusing node ordering should speed up ch contraction", timeMotorCycle < 0.5 * timeCar);
+    }
+
+    void checkPath(GraphHopperStorage g, Weighting w, int expShortcuts, double expDistance, IntIndexedContainer expNodes) {
+        CHGraph lg = g.getCHGraph(w);
+        PrepareContractionHierarchies prepare = createPrepareContractionHierarchies(g, lg, w);
         prepare.doWork();
         assertEquals(w.toString(), expShortcuts, prepare.getShortcuts());
         RoutingAlgorithm algo = prepare.createAlgo(lg, new AlgorithmOptions(DIJKSTRA_BI, w, tMode));
@@ -489,4 +721,13 @@ void checkPath(GraphHopperStorage ghStorage, Weighting w, int expShortcuts, doub
         assertEquals(w.toString(), expNodes, p.calcNodes());
     }
 
+    private PrepareContractionHierarchies createPrepareContractionHierarchies(GraphHopperStorage g, CHGraph lg) {
+        return createPrepareContractionHierarchies(g, lg, weighting);
+    }
+
+    private PrepareContractionHierarchies createPrepareContractionHierarchies(GraphHopperStorage g, CHGraph lg, Weighting w) {
+        g.freeze();
+        return new PrepareContractionHierarchies(lg, w, tMode);
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
index f9782c1c3f..8fd7f249a8 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareEncoderTest.java
@@ -30,9 +30,9 @@
 
     @Test
     public void testOverwrite() {
-        long forward = PrepareEncoder.getScFwdDir();
-        long backward = PrepareEncoder.getScFwdDir() ^ PrepareEncoder.getScDirMask();
-        long both = PrepareEncoder.getScDirMask();
+        int forward = PrepareEncoder.getScFwdDir();
+        int backward = PrepareEncoder.getScFwdDir() ^ PrepareEncoder.getScDirMask();
+        int both = PrepareEncoder.getScDirMask();
         assertEquals(1, PrepareEncoder.getScMergeStatus(forward, forward));
         assertEquals(1, PrepareEncoder.getScMergeStatus(backward, backward));
         assertEquals(2, PrepareEncoder.getScMergeStatus(forward, both));
diff --git a/core/src/test/java/com/graphhopper/routing/ch/WitnessPathSearcherTest.java b/core/src/test/java/com/graphhopper/routing/ch/WitnessPathSearcherTest.java
new file mode 100644
index 0000000000..897ef6496d
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/ch/WitnessPathSearcherTest.java
@@ -0,0 +1,175 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.PMap;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class WitnessPathSearcherTest {
+
+    private GraphHopperStorage graph;
+    private CHGraph chGraph;
+    private TurnWeighting chTurnWeighting;
+
+    @Before
+    public void setup() {
+        CarFlagEncoder encoder = new CarFlagEncoder(5, 5, 10);
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        Weighting weighting = new ShortestWeighting(encoder);
+        PreparationWeighting preparationWeighting = new PreparationWeighting(weighting);
+        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+        TurnCostExtension turnCostExtension = (TurnCostExtension) graph.getExtension();
+        chTurnWeighting = new TurnWeighting(preparationWeighting, turnCostExtension);
+        chGraph = graph.getCHGraph();
+    }
+
+    @Test
+    public void test_shortcut_needed_basic() {
+        // 0 -> 1 -> 2 -> 3 -> 4
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 1, false);
+        graph.edge(3, 4, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        WitnessPathSearcher finder = createFinder();
+        finder.initSearch(2, 1, 0);
+        CHEntry result = finder.runSearch(3, 3);
+        CHEntry expected = new ExpectedResultBuilder(3, 2, 2, 2.0)
+                .withParent(2, 1, 1, 1.0)
+                .build(1);
+        assertFinderResult(expected, result);
+    }
+
+    @Test
+    public void test_shortcut_needed_bidirectional() {
+        // 0 -> 1 -> 2 -> 3 -> 4
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 3, 1, true);
+        graph.edge(3, 4, 1, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        WitnessPathSearcher finder = createFinder();
+        finder.initSearch(2, 1, 0);
+        CHEntry result = finder.runSearch(3, 3);
+        CHEntry expected = new ExpectedResultBuilder(3, 2, 2, 2.0)
+                .withParent(2, 1, 1, 1.0)
+                .build(1);
+        assertFinderResult(expected, result);
+    }
+
+    @Test
+    public void test_witness_basic() {
+        // 0 -> 1 -> 2 -> 3 -> 4
+        //       \       /
+        //        \> 5 >/
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.edge(2, 3, 2, false);
+        graph.edge(3, 4, 1, false);
+        graph.edge(1, 5, 1, false);
+        graph.edge(5, 3, 1, false);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        WitnessPathSearcher finder = createFinder();
+        finder.initSearch(2, 1, 0);
+        CHEntry result = finder.runSearch(3, 3);
+        assertNull(result);
+    }
+
+    @Test
+    public void test_witness_bidirectional() {
+        // 0 -> 1 -> 2 -> 3 -> 4
+        //       \       /
+        //        \> 5 >/
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(2, 3, 2, true);
+        graph.edge(3, 4, 1, true);
+        graph.edge(1, 5, 1, true);
+        graph.edge(5, 3, 1, true);
+        graph.freeze();
+        setMaxLevelOnAllNodes();
+        WitnessPathSearcher finder = createFinder();
+        finder.initSearch(2, 1, 0);
+        CHEntry result = finder.runSearch(3, 3);
+        assertNull(result);
+    }
+
+    private WitnessPathSearcher createFinder() {
+        return new WitnessPathSearcher(chGraph, chTurnWeighting, new PMap());
+    }
+
+    private void setMaxLevelOnAllNodes() {
+        int nodes = chGraph.getNodes();
+        for (int node = 0; node < nodes; node++) {
+            chGraph.setLevel(node, nodes);
+        }
+    }
+
+    private void assertFinderResult(CHEntry expected, CHEntry result) {
+        while (expected.parent != null) {
+            assertEquals(expected.adjNode, result.adjNode);
+            assertEquals(expected.edge, result.edge);
+            assertEquals(expected.incEdge, result.incEdge);
+            assertEquals(expected.weight, result.weight, 1.e-6);
+            expected = expected.getParent();
+            result = result.getParent();
+        }
+    }
+
+    private static class ExpectedResultBuilder {
+        private CHEntry result;
+        private CHEntry last;
+
+        private ExpectedResultBuilder(int adjNode, int edge, int incEdge, double weight) {
+            result = new CHEntry(edge, incEdge, adjNode, weight);
+            last = result;
+        }
+
+        ExpectedResultBuilder withParent(int adjNode, int edge, int incEdge, double weight) {
+            CHEntry parent = new CHEntry(edge, incEdge, adjNode, weight);
+            last.parent = parent;
+            last = parent;
+            return this;
+        }
+
+        CHEntry build(int firstEdge) {
+            last.parent = new CHEntry(EdgeIterator.NO_EDGE, firstEdge, -1, 0.0);
+            return result;
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/lm/LMAlgoFactoryDecoratorTest.java b/core/src/test/java/com/graphhopper/routing/lm/LMAlgoFactoryDecoratorTest.java
index c3f28b9c10..a238715a83 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/LMAlgoFactoryDecoratorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/LMAlgoFactoryDecoratorTest.java
@@ -3,7 +3,6 @@
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.GraphExtension;
@@ -15,9 +14,7 @@
 
 import java.util.Arrays;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 
 public class LMAlgoFactoryDecoratorTest {
@@ -35,7 +32,7 @@ public void addWeighting() {
         assertEquals(Arrays.asList("fastest", "shortest"), dec.getWeightingsAsStrings());
 
         FlagEncoder car = new CarFlagEncoder();
-        EncodingManager em = new EncodingManager(car);
+        EncodingManager em = EncodingManager.create(car);
         dec.addWeighting(new FastestWeighting(car)).addWeighting(new ShortestWeighting(car));
         dec.createPreparations(new GraphHopperStorage(new RAMDirectory(), em, false, new GraphExtension.NoOpExtension()), null);
         assertEquals(1, dec.getPreparations().get(0).getLandmarkStorage().getFactor(), .1);
@@ -55,5 +52,10 @@ public void testPrepareWeightingNo() {
         dec = new LMAlgoFactoryDecorator();
         dec.init(args);
         assertFalse(dec.isEnabled());
+
+        args.put(Parameters.Landmark.PREPARE + "weightings", "false");
+        dec = new LMAlgoFactoryDecorator();
+        dec.init(args);
+        assertFalse(dec.isEnabled());
     }
 }
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
index f3fbe7060f..41d97b5e61 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/LandmarkStorageTest.java
@@ -27,6 +27,7 @@
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.After;
@@ -43,12 +44,14 @@
 public class LandmarkStorageTest {
     private GraphHopperStorage ghStorage;
     private FlagEncoder encoder;
+    private EncodingManager encodingManager;
 
     @Before
     public void setUp() {
         encoder = new CarFlagEncoder();
+        encodingManager = EncodingManager.create(encoder);
         ghStorage = new GraphHopperStorage(new RAMDirectory(),
-                new EncodingManager(encoder), false, new GraphExtension.NoOpExtension());
+                encodingManager, false, new GraphExtension.NoOpExtension());
         ghStorage.create(1000);
     }
 
@@ -84,26 +87,38 @@ public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevO
     public void testSetGetWeight() {
         ghStorage.edge(0, 1, 40, true);
         Directory dir = new RAMDirectory();
-        DataAccess da = dir.find("landmarks_fastest_car");
+        DataAccess da = dir.find("landmarks_fastest_car_node");
         da.create(2000);
 
         LandmarkStorage lms = new LandmarkStorage(ghStorage, dir, new FastestWeighting(encoder), 4).
                 setMaximumWeight(LandmarkStorage.PRECISION);
-        // 2^16=65536, use -1 for infinity and -2 for maximum
-        lms.setWeight(0, 65536);
-        // reached maximum value but do not reset to 0 instead use 2^16-2
-        assertEquals(65536 - 2, lms.getFromWeight(0, 0));
-        lms.setWeight(0, 65535);
-        assertEquals(65534, lms.getFromWeight(0, 0));
-        lms.setWeight(0, 79999);
-        assertEquals(65534, lms.getFromWeight(0, 0));
+        /* FROM_WEIGHT_BITS = 18
+        2^18 = 262144, use -1 for infinity and -2 for maximum
+        As the backward weight reaches a too high value it will use the maximum instead of 0 or infinity*/
+        lms.setWeight(0, 0, 16, Math.pow(2, 18), true);
+        assertEquals((int) Math.pow(2, 18) - 2, lms.getFromWeight(0, 0));
+        lms.setWeight(0, 0, 16, 999999, true);
+        assertEquals((int) Math.pow(2, 18) - 2, lms.getFromWeight(0, 0));
+
+        /* FROM_WEIGHT_BITS = 18 --> remaining bits: 32-18 = 14
+        The delta value is signed and will therefore go from -2^(14-1) to 2^(14-1).
+        Now 2^13-1 is used for infinity, 2^13-2 as maximum and -2^13 as minimum.
+        If the difference between forward and backward weight is too large it will use
+        the maximum (if positive) or the minimum (if negative) instead of 0 or infinity
+        The delta will then be added to the backward weight*/
+        lms.setWeight(0, 0, 16, 999999, false);
+        assertEquals((int) (Math.pow(2, 18) - 2 + Math.pow(2, 13) - 2), lms.getToWeight(0, 0));
+        //                 {backward weight}   {delta weight}
+        lms.setWeight(0, 0, 16, 1, false);
+        assertEquals((int) (Math.pow(2, 18) - 2 + -Math.pow(2, 13)), lms.getToWeight(0, 0));
+        //                 {backward weight}   {delta weight}
 
         da.setInt(0, Integer.MAX_VALUE);
         assertTrue(lms.isInfinity(0));
         // for infinity return much bigger value
         // assertEquals(Integer.MAX_VALUE, lms.getFromWeight(0, 0));
 
-        lms.setWeight(0, 79999);
+        lms.setWeight(0, 0, 16, 999999, true);
         assertFalse(lms.isInfinity(0));
     }
 
@@ -112,7 +127,7 @@ public void testWithSubnetworks() {
         ghStorage.edge(0, 1, 10, true);
         ghStorage.edge(1, 2, 10, true);
 
-        ghStorage.edge(2, 4).setFlags(encoder.setAccess(0, false, false));
+        ghStorage.edge(2, 4).set(encoder.getAccessEnc(), false).setReverse(encoder.getAccessEnc(), false);
         ghStorage.edge(4, 5, 10, true);
         ghStorage.edge(5, 6, 10, false);
 
@@ -164,7 +179,7 @@ public void testWithOnewaySubnetworks() {
     public void testWeightingConsistence() {
         // create an indifferent problem: shortest weighting can pass the speed==0 edge but fastest cannot (?)
         ghStorage.edge(0, 1, 10, true);
-        ghStorage.edge(1, 2).setDistance(10).setFlags(encoder.setProperties(0.9, true, true));
+        GHUtility.setProperties(ghStorage.edge(1, 2).setDistance(10), encoder, 0.9, true, true);
         ghStorage.edge(2, 3, 10, true);
 
         LandmarkStorage storage = new LandmarkStorage(ghStorage, new RAMDirectory(), new FastestWeighting(encoder), 2);
@@ -212,6 +227,11 @@ public int getSpatialId(SpatialRule rule) {
                 throw new IllegalStateException();
             }
 
+            @Override
+            public SpatialRule getSpatialRule(int spatialId) {
+                throw new IllegalStateException();
+            }
+
             @Override
             public int size() {
                 return 2;
@@ -228,4 +248,75 @@ public BBox getBounds() {
         storage.createLandmarks();
         assertEquals(3, storage.getSubnetworksWithLandmarks());
     }
+
+    @Test
+    public void testDelta() {
+        int distance = 1000000;
+
+        ghStorage.edge(1, 2, distance, false);
+        ghStorage.edge(2, 3, distance, false);
+        ghStorage.edge(3, 1, distance, false);
+
+        ghStorage.edge(2, 4, distance, true);
+        ghStorage.edge(4, 5, distance, true);
+        ghStorage.edge(5, 6, distance, true);
+        ghStorage.edge(6, 7, distance, true);
+        ghStorage.edge(7, 8, distance, true);
+        ghStorage.edge(8, 9, distance, true);
+
+        ghStorage.edge(3, 10, distance, true);
+        ghStorage.edge(10, 11, distance, true);
+        ghStorage.edge(11, 12, distance, true);
+        ghStorage.edge(12, 13, distance, true);
+        ghStorage.edge(13, 14, distance, true);
+        ghStorage.edge(14, 15, distance, true);
+
+        LandmarkStorage storage = new LandmarkStorage(ghStorage, new RAMDirectory(), new FastestWeighting(encoder), 2);
+        storage.createLandmarks();
+
+        assertEquals(15, storage.getLandmarks(1)[0]);
+        assertEquals(9, storage.getLandmarks(1)[1]);
+
+        assertEquals(35680, storage.getFromWeight(0, 1));
+        assertEquals(40777, storage.getToWeight(0, 1));
+        assertEquals(71361, storage.getFromWeight(0, 9));
+        assertEquals(66264, storage.getToWeight(0, 9));
+        assertEquals(15291, storage.getFromWeight(0, 12));
+        assertEquals(15291, storage.getToWeight(0, 12));
+        assertEquals(40777, storage.getFromWeight(1, 1));
+        assertEquals(35680, storage.getToWeight(1, 1));
+        assertEquals(50972, storage.getFromWeight(1, 12));
+        assertEquals(56069, storage.getToWeight(1, 12));
+        assertEquals(66264, storage.getFromWeight(1, 15));
+        assertEquals(71361, storage.getToWeight(1, 15));
+    }
+
+    @Test
+    public void testDeltaWarning() {
+        int distance = 1000000;
+
+        ghStorage.edge(1, 2, distance, false);
+        ghStorage.edge(2, 3, distance, false);
+        ghStorage.edge(3, 4, distance, false);
+        ghStorage.edge(4, 5, distance, false);
+        ghStorage.edge(5, 6, distance, false);
+        ghStorage.edge(6, 1, distance, false);
+
+        ghStorage.edge(1, 7, distance, true);
+        ghStorage.edge(7, 8, distance, true);
+        ghStorage.edge(8, 9, distance, true);
+
+        ghStorage.edge(6, 10, distance, true);
+        ghStorage.edge(10, 11, distance, true);
+        ghStorage.edge(11, 12, distance, true);
+
+        LandmarkStorage storage = new LandmarkStorage(ghStorage, new RAMDirectory(), new FastestWeighting(encoder), 2);
+        storage.createLandmarks();
+
+        assertEquals(12, storage.getLandmarks(1)[0]);
+        assertEquals(9, storage.getLandmarks(1)[1]);
+
+        assertEquals((int) Math.pow(2, 13) - 2, storage.getToWeight(0, 9) - storage.getFromWeight(0, 9));
+        assertEquals((int) -Math.pow(2, 13), storage.getToWeight(1, 12) - storage.getFromWeight(1, 12));
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java b/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
index 09e2522762..def9c2eea1 100644
--- a/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/lm/PrepareLandmarksTest.java
@@ -18,6 +18,8 @@
 package com.graphhopper.routing.lm;
 
 import com.graphhopper.routing.*;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
@@ -45,8 +47,9 @@
  * @author Peter Karich
  */
 public class PrepareLandmarksTest
-/* extends AbstractRoutingAlgorithmTester */ {
+        /* extends AbstractRoutingAlgorithmTester */ {
     private GraphHopperStorage graph;
+    private EncodingManager encodingManager;
     private FlagEncoder encoder;
     private TraversalMode tm;
 
@@ -54,8 +57,9 @@
     public void setUp() {
         encoder = new CarFlagEncoder();
         tm = TraversalMode.NODE_BASED;
+        encodingManager = EncodingManager.create(encoder);
         GraphHopperStorage tmp = new GraphHopperStorage(new RAMDirectory(),
-                new EncodingManager(encoder), false, new GraphExtension.NoOpExtension());
+                encodingManager, false, new GraphExtension.NoOpExtension());
         tmp.create(1000);
         graph = tmp;
     }
@@ -68,18 +72,20 @@ public void testLandmarkStorageAndRouting() {
         Random rand = new Random(0);
         int width = 15, height = 15;
 
+        DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
         for (int hIndex = 0; hIndex < height; hIndex++) {
             for (int wIndex = 0; wIndex < width; wIndex++) {
                 int node = wIndex + hIndex * width;
 
-                long flags = encoder.setProperties(20 + rand.nextDouble() * 30, true, true);
                 // do not connect first with last column!
+                double speed = 20 + rand.nextDouble() * 30;
                 if (wIndex + 1 < width)
-                    graph.edge(node, node + 1).setFlags(flags);
+                    graph.edge(node, node + 1).set(accessEnc, true).setReverse(accessEnc, true).set(avSpeedEnc, speed);
 
                 // avoid dead ends
                 if (hIndex + 1 < height)
-                    graph.edge(node, node + width).setFlags(flags);
+                    graph.edge(node, node + width).set(accessEnc, true).setReverse(accessEnc, true).set(avSpeedEnc, speed);
 
                 AbstractRoutingAlgorithmTester.updateDistancesFor(graph, node, -hIndex / 50.0, wIndex / 50.0);
             }
diff --git a/core/src/test/java/com/graphhopper/routing/profiles/BooleanEncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/profiles/BooleanEncodedValueTest.java
new file mode 100644
index 0000000000..14308baefc
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/profiles/BooleanEncodedValueTest.java
@@ -0,0 +1,39 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+import org.junit.Test;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertFalse;
+
+
+public class BooleanEncodedValueTest {
+
+    @Test
+    public void testBit() {
+        EncodedValue.InitializerConfig config = new EncodedValue.InitializerConfig();
+        IntEncodedValue intProp = new UnsignedIntEncodedValue("somevalue", 5, false);
+        intProp.init(config);
+
+        BooleanEncodedValue bool = new SimpleBooleanEncodedValue("access", false);
+        bool.init(config);
+        IntsRef ref = new IntsRef(1);
+        bool.setBool(false, ref, false);
+        assertFalse(bool.getBool(false, ref));
+        bool.setBool(false, ref, true);
+        assertTrue(bool.getBool(false, ref));
+    }
+
+    @Test
+    public void testBitDirected() {
+        EncodedValue.InitializerConfig config = new EncodedValue.InitializerConfig();
+        BooleanEncodedValue bool = new SimpleBooleanEncodedValue("access", true);
+        bool.init(config);
+        IntsRef ref = new IntsRef(1);
+        bool.setBool(false, ref, false);
+        bool.setBool(true, ref, true);
+
+        assertFalse(bool.getBool(false, ref));
+        assertTrue(bool.getBool(true, ref));
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/profiles/DecimalEncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/profiles/DecimalEncodedValueTest.java
new file mode 100644
index 0000000000..c4382b42b6
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/profiles/DecimalEncodedValueTest.java
@@ -0,0 +1,52 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public class DecimalEncodedValueTest {
+
+    @Test
+    public void testInit() {
+        DecimalEncodedValue prop = new UnsignedDecimalEncodedValue("test", 10, 2, false);
+        prop.init(new EncodedValue.InitializerConfig());
+        IntsRef ref = new IntsRef(1);
+        prop.setDecimal(false, ref, 10d);
+        assertEquals(10d, prop.getDecimal(false, ref), 0.1);
+    }
+
+    @Test
+    public void testMaxValue() {
+        CarFlagEncoder carEncoder = new CarFlagEncoder(10, 0.5, 0);
+        EncodingManager em = EncodingManager.create(carEncoder);
+        DecimalEncodedValue carAverageSpeedEnc = em.getDecimalEncodedValue(EncodingManager.getKey(carEncoder, "average_speed"));
+
+        ReaderWay way = new ReaderWay(1);
+        way.setTag("highway", "motorway_link");
+        way.setTag("maxspeed", "70 mph");
+        IntsRef flags = carEncoder.handleWayTags(em.createEdgeFlags(), way, carEncoder.getAccess(way), 0);
+        assertEquals(101.5, carAverageSpeedEnc.getDecimal(true, flags), 1e-1);
+
+        DecimalEncodedValue instance1 = new UnsignedDecimalEncodedValue("test1", 8, 0.5, false);
+        instance1.init(new EncodedValue.InitializerConfig());
+        flags = em.createEdgeFlags();
+        instance1.setDecimal(false, flags, 100d);
+        assertEquals(100, instance1.getDecimal(false, flags), 1e-1);
+    }
+
+    @Test
+    public void testNegativeBounds() {
+        DecimalEncodedValue prop = new UnsignedDecimalEncodedValue("test", 10, 5, false);
+        prop.init(new EncodedValue.InitializerConfig());
+        try {
+            prop.setDecimal(false, new IntsRef(1), -1);
+            assertTrue(false);
+        } catch (Exception ex) {
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactoryTest.java b/core/src/test/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactoryTest.java
new file mode 100644
index 0000000000..f3124836b7
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/profiles/DefaultEncodedValueFactoryTest.java
@@ -0,0 +1,31 @@
+package com.graphhopper.routing.profiles;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class DefaultEncodedValueFactoryTest {
+
+    private final DefaultEncodedValueFactory factory = new DefaultEncodedValueFactory();
+
+    @Test
+    public void loadRoadClass() {
+        EncodedValue rcEnc = new EnumEncodedValue<>(RoadClass.KEY, RoadClass.class);
+        EncodedValue loadedRCEnc = factory.create(rcEnc.toString());
+        assertEquals(loadedRCEnc, rcEnc);
+    }
+
+    @Test
+    public void loadCarMaxSpeed() {
+        EncodedValue enc = MaxSpeed.create();
+        UnsignedDecimalEncodedValue loadedEnc = (UnsignedDecimalEncodedValue) factory.create(enc.toString());
+        assertEquals(loadedEnc, enc);
+    }
+
+    @Test
+    public void loadBoolean() {
+        EncodedValue enc = Roundabout.create();
+        BooleanEncodedValue loadedEnc = (BooleanEncodedValue) factory.create(enc.toString());
+        assertEquals(loadedEnc, enc);
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/profiles/EnumEncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/profiles/EnumEncodedValueTest.java
new file mode 100644
index 0000000000..f3c18da936
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/profiles/EnumEncodedValueTest.java
@@ -0,0 +1,26 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class EnumEncodedValueTest {
+
+    @Test
+    public void testInit() {
+        EnumEncodedValue<RoadClass> prop = new EnumEncodedValue<>("road_class", RoadClass.class);
+        EncodedValue.InitializerConfig init = new EncodedValue.InitializerConfig();
+        assertEquals(5, prop.init(init));
+        assertEquals(5, prop.bits);
+        assertEquals(0, init.dataIndex);
+        assertEquals(0, init.shift);
+        IntsRef ref = new IntsRef(1);
+        // default if empty
+        ref.ints[0] = 0;
+        assertEquals(RoadClass.OTHER, prop.getEnum(false, ref));
+
+        prop.setEnum(false, ref, RoadClass.SECONDARY);
+        assertEquals(RoadClass.SECONDARY, prop.getEnum(false, ref));
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/profiles/IntEncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/profiles/IntEncodedValueTest.java
new file mode 100644
index 0000000000..e2c1f61ca1
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/profiles/IntEncodedValueTest.java
@@ -0,0 +1,74 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+public class IntEncodedValueTest {
+
+    @Test
+    public void testInvalidReverseAccess() {
+        IntEncodedValue prop = new UnsignedIntEncodedValue("test", 10, false);
+        prop.init(new EncodedValue.InitializerConfig());
+        try {
+            prop.setInt(true, new IntsRef(1), -1);
+            assertTrue(false);
+        } catch (Exception ex) {
+        }
+    }
+
+    @Test
+    public void testDirectedValue() {
+        IntEncodedValue prop = new UnsignedIntEncodedValue("test", 10, true);
+        prop.init(new EncodedValue.InitializerConfig());
+        IntsRef ref = new IntsRef(1);
+        prop.setInt(false, ref, 10);
+        prop.setInt(true, ref, 20);
+        assertEquals(10, prop.getInt(false, ref));
+        assertEquals(20, prop.getInt(true, ref));
+    }
+
+    @Test
+    public void multiIntsUsage() {
+        IntEncodedValue prop = new UnsignedIntEncodedValue("test", 31, true);
+        prop.init(new EncodedValue.InitializerConfig());
+        IntsRef ref = new IntsRef(2);
+        prop.setInt(false, ref, 10);
+        prop.setInt(true, ref, 20);
+        assertEquals(10, prop.getInt(false, ref));
+        assertEquals(20, prop.getInt(true, ref));
+    }
+
+    @Test
+    public void padding() {
+        IntEncodedValue prop = new UnsignedIntEncodedValue("test", 30, true);
+        prop.init(new EncodedValue.InitializerConfig());
+        IntsRef ref = new IntsRef(2);
+        prop.setInt(false, ref, 10);
+        prop.setInt(true, ref, 20);
+        assertEquals(10, prop.getInt(false, ref));
+        assertEquals(20, prop.getInt(true, ref));
+    }
+
+    @Test
+    public void testSignedInt() {
+        IntEncodedValue prop = new UnsignedIntEncodedValue("test", 31, false);
+        BooleanEncodedValue sign = new SimpleBooleanEncodedValue("a");
+        EncodedValue.InitializerConfig config = new EncodedValue.InitializerConfig();
+        prop.init(config);
+        sign.init(config);
+
+        IntsRef ref = new IntsRef(1);
+
+        prop.setInt(false, ref, Integer.MAX_VALUE);
+        sign.setBool(false, ref, true);
+        assertEquals(Integer.MAX_VALUE, prop.getInt(false, ref));
+        assertTrue(sign.getBool(false, ref));
+
+        prop.setInt(false, ref, Integer.MAX_VALUE);
+        sign.setBool(false, ref, false);
+        assertEquals(Integer.MAX_VALUE, prop.getInt(false, ref));
+        assertFalse(sign.getBool(false, ref));
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/profiles/MaxWeightTest.java b/core/src/test/java/com/graphhopper/routing/profiles/MaxWeightTest.java
new file mode 100644
index 0000000000..75b20deb52
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/profiles/MaxWeightTest.java
@@ -0,0 +1,25 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class MaxWeightTest {
+
+    @Test
+    public void testSetAndGet() {
+        DecimalEncodedValue mappedDecimalEnc = MaxWeight.create();
+        mappedDecimalEnc.init(new EncodedValue.InitializerConfig());
+        IntsRef intsRef = new IntsRef(1);
+        mappedDecimalEnc.setDecimal(false, intsRef, 20);
+        assertEquals(20, mappedDecimalEnc.getDecimal(false, intsRef), .1);
+
+        intsRef = new IntsRef(1);
+        mappedDecimalEnc.setDecimal(false, intsRef, 0);
+        assertEquals(Double.POSITIVE_INFINITY, mappedDecimalEnc.getDecimal(false, intsRef), .1);
+
+        mappedDecimalEnc.setDecimal(false, intsRef, Double.POSITIVE_INFINITY);
+        assertEquals(Double.POSITIVE_INFINITY, mappedDecimalEnc.getDecimal(false, intsRef), .1);
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/profiles/RoadAccessTest.java b/core/src/test/java/com/graphhopper/routing/profiles/RoadAccessTest.java
new file mode 100644
index 0000000000..fd58c8415d
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/profiles/RoadAccessTest.java
@@ -0,0 +1,16 @@
+package com.graphhopper.routing.profiles;
+
+import org.junit.Test;
+
+import static com.graphhopper.routing.profiles.RoadAccess.NO;
+import static com.graphhopper.routing.profiles.RoadAccess.YES;
+import static org.junit.Assert.assertEquals;
+
+public class RoadAccessTest {
+    @Test
+    public void testBasics() {
+        assertEquals(YES, RoadAccess.find("unknown"));
+        assertEquals(NO, RoadAccess.find("no"));
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValueTest.java
new file mode 100644
index 0000000000..3fb43b2929
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/profiles/UnsignedDecimalEncodedValueTest.java
@@ -0,0 +1,39 @@
+package com.graphhopper.routing.profiles;
+
+import com.graphhopper.storage.IntsRef;
+import org.junit.Test;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertEquals;
+
+public class UnsignedDecimalEncodedValueTest {
+
+    @Test
+    public void getDecimal() {
+        UnsignedDecimalEncodedValue testEnc = new UnsignedDecimalEncodedValue("test", 3, 1, 100, false);
+        testEnc.init(new EncodedValue.InitializerConfig());
+
+        IntsRef intsRef = new IntsRef(1);
+        testEnc.setDecimal(false, intsRef, 7);
+        assertEquals(7, testEnc.getDecimal(false, intsRef), .1);
+    }
+
+    @Test
+    public void testDefault() {
+        // default value 100
+        UnsignedDecimalEncodedValue testEnc = new UnsignedDecimalEncodedValue("test", 3, 1, 100, false);
+        testEnc.init(new EncodedValue.InitializerConfig());
+        IntsRef intsRef = new IntsRef(1);
+        testEnc.setDecimal(false, intsRef, 0);
+        assertEquals(100, testEnc.getDecimal(false, intsRef), .1);
+
+        // try positive infinity
+        testEnc = new UnsignedDecimalEncodedValue("test", 3, 1, Double.POSITIVE_INFINITY, false);
+        testEnc.init(new EncodedValue.InitializerConfig());
+        testEnc.setDecimal(false, intsRef, 0);
+        assertTrue(Double.isInfinite(testEnc.getDecimal(false, intsRef)));
+        assertTrue(Double.MAX_VALUE < testEnc.getDecimal(false, intsRef));
+        testEnc.setDecimal(false, intsRef, Double.POSITIVE_INFINITY);
+        assertTrue(Double.isInfinite(testEnc.getDecimal(false, intsRef)));
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
index c4796c9910..72f9f06358 100644
--- a/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
+++ b/core/src/test/java/com/graphhopper/routing/subnetwork/PrepareRoutingSubnetworksTest.java
@@ -18,7 +18,6 @@
 package com.graphhopper.routing.subnetwork;
 
 import com.carrotsearch.hppc.IntArrayList;
-import com.graphhopper.routing.subnetwork.PrepareRoutingSubnetworks.PrepEdgeFilter;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
@@ -40,7 +39,7 @@
  */
 public class PrepareRoutingSubnetworksTest {
     private final FlagEncoder carFlagEncoder = new CarFlagEncoder();
-    private final EncodingManager em = new EncodingManager(carFlagEncoder);
+    private final EncodingManager em = EncodingManager.create(carFlagEncoder);
 
     GraphHopperStorage createStorage(EncodingManager eman) {
         return new GraphBuilder(eman).create();
@@ -96,7 +95,7 @@ GraphHopperStorage createSubnetworkTestStorage2(EncodingManager em) {
     @Test
     public void testFindSubnetworks() {
         GraphHopperStorage g = createSubnetworkTestStorage();
-        PrepEdgeFilter filter = new PrepEdgeFilter(carFlagEncoder);
+        DefaultEdgeFilter filter = DefaultEdgeFilter.allEdges(carFlagEncoder);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder));
         List<IntArrayList> components = instance.findSubnetworks(filter);
 
@@ -112,7 +111,7 @@ public void testFindSubnetworks() {
     @Test
     public void testKeepLargestNetworks() {
         GraphHopperStorage g = createSubnetworkTestStorage();
-        PrepEdgeFilter filter = new PrepEdgeFilter(carFlagEncoder);
+        DefaultEdgeFilter filter = DefaultEdgeFilter.allEdges(carFlagEncoder);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder));
         List<IntArrayList> components = instance.findSubnetworks(filter);
         assertEquals(3, components.size());
@@ -153,7 +152,7 @@ public void testRemoveSubnetworkIfOnlyOneVehicle() {
     public void testRemoveNode() {
         FlagEncoder carEncoder = new CarFlagEncoder();
         BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
-        EncodingManager em2 = new EncodingManager(carEncoder, bikeEncoder);
+        EncodingManager em2 = EncodingManager.create(carEncoder, bikeEncoder);
         GraphHopperStorage g = createSubnetworkTestStorage2(em2);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em2.fetchEdgeEncoders());
 
@@ -164,8 +163,8 @@ public void testRemoveNode() {
 
         // mark certain edges inaccessible for all encoders
         for (EdgeIteratorState edge : Arrays.asList(GHUtility.getEdge(g, 5, 6), GHUtility.getEdge(g, 4, 5), GHUtility.getEdge(g, 4, 6))) {
-            for (FlagEncoder encoders : em2.fetchEdgeEncoders()) {
-                edge.setFlags(encoders.setAccess(0, false, false));
+            for (FlagEncoder encoder : em2.fetchEdgeEncoders()) {
+                edge.set(encoder.getAccessEnc(), false).setReverse(encoder.getAccessEnc(), false);
             }
         }
 
@@ -178,10 +177,12 @@ public void testRemoveNode() {
     public void testRemoveSubnetworkWhenMultipleVehicles() {
         FlagEncoder carEncoder = new CarFlagEncoder();
         BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
-        EncodingManager em2 = new EncodingManager(carEncoder, bikeEncoder);
+        EncodingManager em2 = EncodingManager.create(carEncoder, bikeEncoder);
         GraphHopperStorage g = createSubnetworkTestStorage2(em2);
-        GHUtility.getEdge(g, 3, 4).setFlags(carEncoder.setProperties(10, false, false)
-                | bikeEncoder.setProperties(5, true, true));
+
+        EdgeIteratorState edge = GHUtility.getEdge(g, 3, 4);
+        GHUtility.setProperties(edge, carEncoder, 10, false, false);
+        GHUtility.setProperties(edge, bikeEncoder, 5, true, true);
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, em2.fetchEdgeEncoders());
         instance.setMinNetworkSize(5);
         instance.doWork();
@@ -194,7 +195,9 @@ public void testRemoveSubnetworkWhenMultipleVehicles() {
         EdgeExplorer bikeExplorer = g.createEdgeExplorer(DefaultEdgeFilter.allEdges(bikeEncoder));
         assertEquals(GHUtility.asSet(7, 2, 1, 4), GHUtility.getNeighbors(bikeExplorer.setBaseNode(3)));
 
-        GHUtility.getEdge(g, 3, 4).setFlags(carEncoder.setProperties(10, false, false) | bikeEncoder.setProperties(5, false, false));
+        edge = GHUtility.getEdge(g, 3, 4);
+        GHUtility.setProperties(edge, carEncoder, 10, false, false);
+        GHUtility.setProperties(edge, bikeEncoder, 5, false, false);
         instance = new PrepareRoutingSubnetworks(g, em2.fetchEdgeEncoders());
         instance.setMinNetworkSize(5);
         instance.doWork();
@@ -249,7 +252,7 @@ public void testRemoveDeadEndUnvisitedNetworks() {
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder)).
                 setMinOneWayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
+        int removed = instance.removeDeadEndUnvisitedNetworks(DefaultEdgeFilter.allEdges(carFlagEncoder));
 
         assertEquals(3, removed);
         instance.markNodesRemovedIfUnreachable();
@@ -265,7 +268,7 @@ public void testAddEdgesAfterwards() {
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder)).
                 setMinOneWayNetworkSize(3);
-        int removed = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
+        int removed = instance.removeDeadEndUnvisitedNetworks(DefaultEdgeFilter.allEdges(carFlagEncoder));
 
         assertEquals(3, removed);
         instance.markNodesRemovedIfUnreachable();
@@ -274,7 +277,7 @@ public void testAddEdgesAfterwards() {
         assertEquals(8, g.getNodes());
 
         assertTrue(isConsistent(g));
-        g.edge(7,8);
+        g.edge(7, 8);
         assertTrue(isConsistent(g));
     }
 
@@ -305,7 +308,7 @@ public void testNodeOrderingRegression() {
 
         PrepareRoutingSubnetworks instance = new PrepareRoutingSubnetworks(g, Collections.singletonList(carFlagEncoder)).
                 setMinOneWayNetworkSize(2);
-        int removedEdges = instance.removeDeadEndUnvisitedNetworks(new PrepEdgeFilter(carFlagEncoder));
+        int removedEdges = instance.removeDeadEndUnvisitedNetworks(DefaultEdgeFilter.allEdges(carFlagEncoder));
         assertEquals(2, removedEdges);
     }
 
@@ -332,15 +335,15 @@ public void test481() {
         instance.doWork();
 
         // only one remaining network
-        List<IntArrayList> components = instance.findSubnetworks(new PrepEdgeFilter(carFlagEncoder));
+        List<IntArrayList> components = instance.findSubnetworks(DefaultEdgeFilter.allEdges(carFlagEncoder));
         assertEquals(1, components.size());
     }
 
     public static boolean isConsistent(GraphHopperStorage storage) {
         EdgeExplorer edgeExplorer = storage.createEdgeExplorer();
         int nNodes = storage.getNodes();
-        for(int i=0; i<nNodes; i++) {
-            if(!check(storage, edgeExplorer, i)) return false;
+        for (int i = 0; i < nNodes; i++) {
+            if (!check(storage, edgeExplorer, i)) return false;
         }
         return true;
     }
@@ -349,7 +352,7 @@ public static boolean check(GraphHopperStorage storage, EdgeExplorer edgeExplore
         List<Integer> toNodes = new ArrayList<>();
         List<Integer> edges = new ArrayList<>();
         EdgeIterator edgeIterator = edgeExplorer.setBaseNode(node);
-        while(edgeIterator.next()) {
+        while (edgeIterator.next()) {
             if (edgeIterator.getBaseNode() < 0 || edgeIterator.getAdjNode() < 0) {
                 return false;
             }
@@ -357,13 +360,13 @@ public static boolean check(GraphHopperStorage storage, EdgeExplorer edgeExplore
             edges.add(edgeIterator.getEdge());
         }
 
-        for(int i=0;i<toNodes.size();i++) {
+        for (int i = 0; i < toNodes.size(); i++) {
             EdgeIteratorState edgeIteratorState = storage.getEdgeIteratorState(edges.get(i), toNodes.get(i));
-            if(edgeIteratorState == null) {
+            if (edgeIteratorState == null) {
                 return false;
             }
             EdgeIteratorState edgeIteratorState2 = storage.getEdgeIteratorState(edges.get(i), node);
-            if(edgeIteratorState2 == null) {
+            if (edgeIteratorState2 == null) {
                 return false;
             }
         }
diff --git a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
index 6f9fbaa5d6..57d62929d4 100644
--- a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
@@ -24,7 +24,10 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.*;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.storage.index.QueryResult;
@@ -45,8 +48,8 @@
  */
 public class RoundTripRoutingTemplateTest {
     private final FlagEncoder carFE = new CarFlagEncoder();
-    private final EncodingManager em = new EncodingManager(carFE);
-    // TODO private final TraversalMode tMode = TraversalMode.EDGE_BASED_2DIR;
+    private final EncodingManager em = EncodingManager.create(carFE);
+    // TODO private final TraversalMode tMode = TraversalMode.EDGE_BASED;
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
     private final GHPoint ghPoint1 = new GHPoint(0, 0);
     private final GHPoint ghPoint2 = new GHPoint(1, 1);
@@ -54,14 +57,14 @@
     @Test(expected = IllegalArgumentException.class)
     public void lookup_throwsIfNumberOfGivenPointsNotOne() {
         RoundTripRoutingTemplate routingTemplate = new RoundTripRoutingTemplate(
-                new GHRequest(Collections.singletonList(ghPoint1)), new GHResponse(), null, 1);
+                new GHRequest(Collections.singletonList(ghPoint1)), new GHResponse(), null, em, 1);
         routingTemplate.lookup(Arrays.asList(ghPoint1, ghPoint2), carFE);
     }
 
     @Test(expected = IllegalArgumentException.class)
     public void lookup_throwsIfNumberOfPointsInRequestNotOne() {
         RoundTripRoutingTemplate routingTemplate = new RoundTripRoutingTemplate(
-                new GHRequest(Arrays.asList(ghPoint1, ghPoint2)), new GHResponse(), null, 1);
+                new GHRequest(Arrays.asList(ghPoint1, ghPoint2)), new GHResponse(), null, em, 1);
         routingTemplate.lookup(Collections.singletonList(ghPoint1), carFE);
     }
 
@@ -80,7 +83,7 @@ public void testLookupAndCalcPaths_simpleSquareGraph() {
         ghRequest.getHints().put(Parameters.Algorithms.RoundTrip.DISTANCE, roundTripDistance);
         LocationIndex locationIndex = new LocationIndexTree(g, new RAMDirectory()).prepareIndex();
         RoundTripRoutingTemplate routingTemplate =
-                new RoundTripRoutingTemplate(ghRequest, new GHResponse(), locationIndex, 1);
+                new RoundTripRoutingTemplate(ghRequest, new GHResponse(), locationIndex, em, 1);
         List<QueryResult> stagePoints = routingTemplate.lookup(ghRequest.getPoints(), carFE);
         assertEquals(3, stagePoints.size());
         assertEquals(0, stagePoints.get(0).getClosestNode());
@@ -104,7 +107,7 @@ public void testCalcRoundTrip() throws Exception {
         Graph g = createTestGraph(true);
 
         RoundTripRoutingTemplate rTripRouting =
-                new RoundTripRoutingTemplate(new GHRequest(), new GHResponse(), null, 1);
+                new RoundTripRoutingTemplate(new GHRequest(), new GHResponse(), null, em, 1);
 
         LocationIndex locationIndex = new LocationIndexTree(g, new RAMDirectory()).prepareIndex();
         QueryResult qr4 = locationIndex.findClosest(0.05, 0.25, EdgeFilter.ALL_EDGES);
diff --git a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
index 3929435d4b..7739a44f62 100644
--- a/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
+++ b/core/src/test/java/com/graphhopper/routing/util/AbstractBikeFlagEncoderTester.java
@@ -19,7 +19,10 @@
 
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.weighting.PriorityWeighting;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.Roundabout;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Translation;
 import org.junit.Before;
@@ -39,10 +42,17 @@
  */
 public abstract class AbstractBikeFlagEncoderTester {
     protected BikeCommonFlagEncoder encoder;
+    protected EncodingManager encodingManager;
+    protected BooleanEncodedValue roundaboutEnc;
+    protected DecimalEncodedValue priorityEnc;
+    protected DecimalEncodedValue avSpeedEnc;
 
     @Before
     public void setUp() {
-        encoder = createBikeEncoder();
+        encodingManager = EncodingManager.create(encoder = createBikeEncoder());
+        roundaboutEnc = encodingManager.getBooleanEncodedValue(Roundabout.KEY);
+        priorityEnc = encodingManager.getDecimalEncodedValue(EncodingManager.getKey(encoder, "priority"));
+        avSpeedEnc = encoder.getAverageSpeedEnc();
     }
 
     protected abstract BikeCommonFlagEncoder createBikeEncoder();
@@ -56,9 +66,8 @@ protected void assertPriority(int expectedPrio, ReaderWay way, long relationFlag
     }
 
     protected double getSpeedFromFlags(ReaderWay way) {
-        long allowed = encoder.acceptBit;
-        long flags = encoder.handleWayTags(way, allowed, 0);
-        return encoder.getSpeed(flags);
+        IntsRef flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, EncodingManager.Access.WAY, 0);
+        return avSpeedEnc.getDecimal(false, flags);
     }
 
     protected String getWayTypeFromFlags(ReaderWay way) {
@@ -66,8 +75,7 @@ protected String getWayTypeFromFlags(ReaderWay way) {
     }
 
     protected String getWayTypeFromFlags(ReaderWay way, long relationFlags) {
-        long allowed = encoder.acceptBit;
-        long flags = encoder.handleWayTags(way, allowed, relationFlags);
+        IntsRef flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, EncodingManager.Access.WAY, relationFlags);
         Translation enMap = SINGLETON.getWithFallBack(Locale.UK);
         return encoder.getAnnotation(flags, enMap).getMessage();
     }
@@ -77,122 +85,127 @@ public void testAccess() {
         ReaderWay way = new ReaderWay(1);
 
         way.setTag("highway", "motorway");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.setTag("highway", "motorway");
         way.setTag("bicycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("highway", "footway");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("bicycle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.setTag("highway", "footway");
         way.setTag("bicycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("highway", "pedestrian");
         way.setTag("bicycle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.setTag("highway", "pedestrian");
         way.setTag("bicycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("bicycle", "yes");
         way.setTag("highway", "cycleway");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "path");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("highway", "path");
         way.setTag("bicycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
         way.clearTags();
 
         way.setTag("highway", "track");
         way.setTag("bicycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
         way.clearTags();
 
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("mtb", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("foot", "official");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("bicycle", "official");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "tertiary");
         way.setTag("motorroad", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("ford", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("bicycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "secondary");
         way.setTag("access", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("bicycle", "dismount");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "secondary");
         way.setTag("vehicle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("bicycle", "dismount");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
-        way.clearTags();
-        way.setTag("route", "ferry");
-        assertTrue(encoder.acceptWay(way) > 0);
-        way.setTag("bicycle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
-
-        way.clearTags();
-        way.setTag("route", "ferry");
-        way.setTag("foot", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
+        
 
         way.clearTags();
         way.setTag("highway", "cycleway");
         way.setTag("cycleway", "track");
         way.setTag("railway", "abandoned");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
+
+        way.clearTags();
+        way.setTag("highway", "platform");
+        assertTrue(encoder.getAccess(way).isWay());
+
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("bicycle", "dismount");
+        assertTrue(encoder.getAccess(way).isWay());
+
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("bicycle", "no");
+        assertTrue(encoder.getAccess(way).canSkip());
 
         DateFormat simpleDateFormat = Helper.createFormatter("yyyy MMM dd");
 
         way.clearTags();
         way.setTag("highway", "road");
         way.setTag("bicycle:conditional", "no @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "road");
         way.setTag("access", "no");
         way.setTag("bicycle:conditional", "yes @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
     }
 
     @Test
@@ -200,39 +213,40 @@ public void testTramStations() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "secondary");
         way.setTag("railway", "rail");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way = new ReaderWay(1);
         way.setTag("highway", "secondary");
         way.setTag("railway", "station");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way = new ReaderWay(1);
         way.setTag("highway", "secondary");
         way.setTag("railway", "station");
         way.setTag("bicycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("bicycle", "no");
-        assertTrue(encoder.acceptWay(way) == 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way = new ReaderWay(1);
         way.setTag("railway", "platform");
-        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertNotEquals(0, flags);
+        IntsRef flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertNotEquals(0, flags.ints[0]);
 
         way = new ReaderWay(1);
         way.setTag("highway", "track");
         way.setTag("railway", "platform");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertNotEquals(0, flags);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertNotEquals(0, flags.ints[0]);
 
         way = new ReaderWay(1);
         way.setTag("highway", "track");
         way.setTag("railway", "platform");
         way.setTag("bicycle", "no");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertEquals(0, flags);
+
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertEquals(0, flags.ints[0]);
     }
 
     @Test
@@ -355,6 +369,16 @@ public void testHandleCommonWayTags() {
         wayType = getWayTypeFromFlags(way);
         assertEquals("get off the bike", wayType);
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("get off the bike", wayType);
+
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("bicycle", "yes");
+        wayType = getWayTypeFromFlags(way);
+        assertEquals("", wayType);
     }
 
     @Test
@@ -375,10 +399,10 @@ public void testSacScale() {
         way.setTag("highway", "service");
         way.setTag("sac_scale", "hiking");
         // allow
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("sac_scale", "alpine_hiking");
-        assertTrue(encoder.acceptWay(way) == 0);
+        assertTrue(encoder.getAccess(way).canSkip());
     }
 
     @Test
@@ -392,7 +416,9 @@ public void testReduceToMaxSpeed() {
     public void testPreferenceForSlowSpeed() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "tertiary");
-        assertEquals(30, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 49))), 1e-1);
+        IntsRef edgeFlags = encodingManager.createEdgeFlags();
+        avSpeedEnc.setDecimal(false, edgeFlags, encoder.applyMaxSpeed(osmWay, 49));
+        assertEquals(30, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
         assertPriority(PREFER.getValue(), osmWay);
     }
 
@@ -400,8 +426,9 @@ public void testPreferenceForSlowSpeed() {
     public void testHandleWayTagsCallsHandlePriority() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "cycleway");
-        long encoded = encoder.handleWayTags(osmWay, encoder.acceptBit, 0);
-        assertEquals((double) VERY_NICE.getValue() / BEST.getValue(), encoder.getDouble(encoded, PriorityWeighting.KEY), 1e-3);
+        IntsRef edgeFlags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, 0);
+        DecimalEncodedValue priorityEnc = encodingManager.getDecimalEncodedValue(EncodingManager.getKey(encoder, "priority"));
+        assertEquals((double) VERY_NICE.getValue() / BEST.getValue(), priorityEnc.getDecimal(false, edgeFlags), 1e-3);
     }
 
     @Test
@@ -414,11 +441,14 @@ public void testAvoidMotorway() {
 
     @Test
     public void testPriority() {
-        long flags = encoder.priorityWayEncoder.setValue(0, PriorityCode.BEST.getValue());
-        assertEquals(1, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
-
-        flags = encoder.priorityWayEncoder.setValue(0, PriorityCode.AVOID_IF_POSSIBLE.getValue());
-        assertEquals(3d / 7d, encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+        IntsRef flags = encodingManager.createEdgeFlags();
+        encoder.priorityWayEncoder.setDecimal(false, flags, PriorityCode.getFactor(PriorityCode.BEST.getValue()));
+        DecimalEncodedValue priorityEnc = encodingManager.getDecimalEncodedValue(EncodingManager.getKey(encoder, "priority"));
+        assertEquals(1, priorityEnc.getDecimal(false, flags), 1e-3);
+
+        flags = encodingManager.createEdgeFlags();
+        encoder.priorityWayEncoder.setDecimal(false, flags, PriorityCode.getFactor(PriorityCode.AVOID_IF_POSSIBLE.getValue()));
+        assertEquals(3d / 7d, priorityEnc.getDecimal(false, flags), 1e-3);
     }
 
     @Test
@@ -472,4 +502,55 @@ public void testBarrierAccessFord() {
         // no barrier!
         assertTrue(encoder.handleNodeTags(node) == 0);
     }
+
+    @Test
+    public void testFerries(){
+        ReaderWay way = new ReaderWay(1);
+
+        way.clearTags();
+        way.setTag("route", "ferry");
+        assertTrue(encoder.getAccess(way).isFerry());
+        way.setTag("bicycle", "no");
+        assertFalse(encoder.getAccess(way).isFerry());
+
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("foot", "yes");
+        assertFalse(encoder.getAccess(way).isFerry());
+
+        // #1122
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("bicycle", "yes");
+        way.setTag("access", "private");
+        assertTrue(encoder.getAccess(way).canSkip());
+
+        // #1562, test if ferry route with bicycle
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("bicycle", "designated");
+        assertTrue(encoder.getAccess(way).isFerry());
+
+        way.setTag("bicycle", "official");
+        assertTrue(encoder.getAccess(way).isFerry());
+
+        way.setTag("bicycle", "permissive");
+        assertTrue(encoder.getAccess(way).isFerry());
+
+        way.setTag("foot", "yes");
+        assertTrue(encoder.getAccess(way).isFerry());
+
+        way.setTag("bicycle", "no");
+        assertTrue(encoder.getAccess(way).canSkip());
+
+        way.setTag("bicycle", "designated");
+        way.setTag("access", "private");
+        assertTrue(encoder.getAccess(way).canSkip());
+
+        // test if when foot is set is invalid
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("foot", "yes");
+        assertTrue(encoder.getAccess(way).canSkip());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
index 03d9cd8d0d..f59be0c456 100644
--- a/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/Bike2WeightFlagEncoderTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.*;
 import org.junit.Test;
@@ -28,15 +29,14 @@
  * @author Peter Karich
  */
 public class Bike2WeightFlagEncoderTest extends BikeFlagEncoderTest {
-    private final EncodingManager em = new EncodingManager("bike,bike2");
 
     @Override
     protected BikeCommonFlagEncoder createBikeEncoder() {
-        return (BikeCommonFlagEncoder) em.getEncoder("bike2");
+        return new Bike2WeightFlagEncoder();
     }
 
     private Graph initExampleGraph() {
-        GraphHopperStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true, new GraphExtension.NoOpExtension()).create(1000);
+        GraphHopperStorage gs = new GraphHopperStorage(new RAMDirectory(), encodingManager, true, new GraphExtension.NoOpExtension()).create(1000);
         NodeAccess na = gs.getNodeAccess();
         // 50--(0.0001)-->49--(0.0004)-->55--(0.0005)-->60
         na.setNode(0, 51.1, 12.001, 50);
@@ -44,8 +44,7 @@ private Graph initExampleGraph() {
         EdgeIteratorState edge = gs.edge(0, 1).
                 setWayGeometry(Helper.createPointList3D(51.1, 12.0011, 49, 51.1, 12.0015, 55));
         edge.setDistance(100);
-
-        edge.setFlags(encoder.setReverseSpeed(encoder.setProperties(10, true, true), 15));
+        GHUtility.setProperties(edge, encoder, 10, 15);
         return gs;
     }
 
@@ -56,18 +55,18 @@ public void testApplyWayTags() {
         ReaderWay way = new ReaderWay(1);
         encoder.applyWayTags(way, edge);
 
-        long flags = edge.getFlags();
+        IntsRef flags = edge.getFlags();
         // decrease speed
-        assertEquals(2, encoder.getSpeed(flags), 1e-1);
+        assertEquals(2, encoder.getSpeed(false, flags), 1e-1);
         // increase speed but use maximum speed (calculated was 24)
-        assertEquals(18, encoder.getReverseSpeed(flags), 1e-1);
+        assertEquals(18, encoder.getSpeed(true, flags), 1e-1);
     }
 
     @Test
     public void testUnchangedForStepsBridgeAndTunnel() {
         Graph graph = initExampleGraph();
         EdgeIteratorState edge = GHUtility.getEdge(graph, 0, 1);
-        long oldFlags = edge.getFlags();
+        IntsRef oldFlags = edge.getFlags();
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "steps");
         encoder.applyWayTags(way, edge);
@@ -77,27 +76,30 @@ public void testUnchangedForStepsBridgeAndTunnel() {
 
     @Test
     public void testSetSpeed0_issue367() {
-        long flags = encoder.setProperties(10, true, true);
-        flags = encoder.setSpeed(flags, 0);
+        IntsRef edgeFlags = GHUtility.setProperties(encodingManager.createEdgeFlags(), encoder, 10, 10);
+        assertEquals(10, encoder.getSpeed(false, edgeFlags), .1);
+        assertEquals(10, encoder.getSpeed(true, edgeFlags), .1);
+
+        encoder.setSpeed(false, edgeFlags, 0);
 
-        assertEquals(0, encoder.getSpeed(flags), .1);
-        assertEquals(10, encoder.getReverseSpeed(flags), .1);
-        assertFalse(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        assertEquals(0, encoder.getSpeed(false, edgeFlags), .1);
+        assertEquals(10, encoder.getSpeed(true, edgeFlags), .1);
+        assertFalse(encoder.getAccessEnc().getBool(false, edgeFlags));
+        assertTrue(encoder.getAccessEnc().getBool(true, edgeFlags));
     }
 
     @Test
     public void testRoutingFailsWithInvalidGraph_issue665() {
-        GraphHopperStorage graph = new GraphHopperStorage(
-                new RAMDirectory(), em, true, new GraphExtension.NoOpExtension());
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(), encodingManager, true, new GraphExtension.NoOpExtension());
         graph.create(100);
 
         ReaderWay way = new ReaderWay(0);
         way.setTag("route", "ferry");
 
-        long includeWay = em.acceptWay(way);
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        assertTrue(encodingManager.acceptWay(way, map));
         long relationFlags = 0;
-        long wayFlags = em.handleWayTags(way, includeWay, relationFlags);
+        IntsRef wayFlags = encodingManager.handleWayTags(way, map, relationFlags);
         graph.edge(0, 1).setDistance(247).setFlags(wayFlags);
 
         assertTrue(isGraphValid(graph, encoder));
@@ -106,19 +108,20 @@ public void testRoutingFailsWithInvalidGraph_issue665() {
     private boolean isGraphValid(Graph graph, FlagEncoder encoder) {
         EdgeExplorer explorer = graph.createEdgeExplorer();
 
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
         // iterator at node 0 considers the edge 0-1 to be undirected
         EdgeIterator iter0 = explorer.setBaseNode(0);
         iter0.next();
         boolean iter0flag
                 = iter0.getBaseNode() == 0 && iter0.getAdjNode() == 1
-                && iter0.isForward(encoder) && iter0.isBackward(encoder);
+                && iter0.get(accessEnc) && iter0.getReverse(accessEnc);
 
         // iterator at node 1 considers the edge 1-0 to be directed
         EdgeIterator iter1 = explorer.setBaseNode(1);
         iter1.next();
         boolean iter1flag
                 = iter1.getBaseNode() == 1 && iter1.getAdjNode() == 0
-                && iter1.isForward(encoder) && iter1.isBackward(encoder);
+                && iter1.get(accessEnc) && iter1.getReverse(accessEnc);
 
         return iter0flag && iter1flag;
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
index 7d477f87cc..7ade7832fc 100644
--- a/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/BikeFlagEncoderTest.java
@@ -20,7 +20,7 @@
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.weighting.PriorityWeighting;
+import com.graphhopper.storage.IntsRef;
 import org.junit.Test;
 
 import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
@@ -32,15 +32,19 @@
  * @author ratrun
  */
 public class BikeFlagEncoderTest extends AbstractBikeFlagEncoderTester {
+
     @Override
     protected BikeCommonFlagEncoder createBikeEncoder() {
-        return (BikeCommonFlagEncoder) new EncodingManager("bike,mtb").getEncoder("bike");
+        return new BikeFlagEncoder();
     }
 
     @Test
     public void testGetSpeed() {
-        long result = encoder.setProperties(10, true, true);
-        assertEquals(10, encoder.getSpeed(result), 1e-1);
+        IntsRef intsRef = encodingManager.createEdgeFlags();
+        encoder.setSpeed(false, intsRef, 10);
+        encoder.getAccessEnc().setBool(false, intsRef, true);
+        encoder.getAccessEnc().setBool(true, intsRef, true);
+        assertEquals(10, encoder.getSpeed(intsRef), 1e-1);
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "primary");
         assertEquals(18, encoder.getSpeed(way));
@@ -89,6 +93,16 @@ public void testGetSpeed() {
         assertEquals(PUSHING_SECTION_SPEED * 2, encoder.getSpeed(way));
         assertPriority(PREFER.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "yes");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+        way.setTag("segregated", "yes");
+        assertEquals(PUSHING_SECTION_SPEED * 2, encoder.getSpeed(way));
+        assertPriority(PREFER.getValue(), way);
+
         way.clearTags();
         way.setTag("highway", "cycleway");
         assertEquals(18, encoder.getSpeed(way));
@@ -157,6 +171,12 @@ public void testGetSpeed() {
         assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
         assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("surface", "paved");
+        assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(way));
+        assertPriority(AVOID_IF_POSSIBLE.getValue(), way);
+
         way.clearTags();
         way.setTag("highway", "footway");
         way.setTag("surface", "paved");
@@ -164,6 +184,13 @@ public void testGetSpeed() {
         assertEquals(cyclewaySpeed, encoder.getSpeed(way));
         assertPriority(VERY_NICE.getValue(), way);
 
+        way.clearTags();
+        way.setTag("highway", "platform");
+        way.setTag("surface", "paved");
+        way.setTag("bicycle", "designated");
+        assertEquals(cyclewaySpeed, encoder.getSpeed(way));
+        assertPriority(VERY_NICE.getValue(), way);
+
         way.clearTags();
         way.setTag("highway", "track");
         assertEquals(12, encoder.getSpeed(way));
@@ -285,18 +312,6 @@ public void testHandleWayTags() {
         way.setTag("tracktype", "grade2");
         wayType = getWayTypeFromFlags(way);
         assertEquals("get off the bike, unpaved", wayType);
-
-        way.clearTags();
-        way.setTag("junction", "roundabout");
-        way.setTag("highway", "tertiary");
-        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
-
-        way.clearTags();
-        way.setTag("junction", "circular");
-        way.setTag("highway", "tertiary");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
     }
 
     @Test
@@ -304,86 +319,79 @@ public void testWayAcceptance() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "cycleway");
         way.setTag("vehicle", "no");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         // Sensless tagging: JOSM does create a warning here. We follow the highway tag:
         way.setTag("bicycle", "no");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("bicycle", "designated");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "motorway");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("bicycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "residential");
         way.setTag("bicycle", "yes");
         way.setTag("access", "no");
-        assertTrue(encoder.acceptWay(way) > 0);
-
-        // #1122
-        way.clearTags();
-        way.setTag("route", "ferry");
-        way.setTag("bicycle", "yes");
-        way.setTag("access", "private");
-        assertTrue(encoder.acceptWay(way) == 0);
+        assertTrue(encoder.getAccess(way).isWay());
     }
 
     @Test
     public void testOneway() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "tertiary");
-        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        IntsRef flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
         way.setTag("oneway", "yes");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertFalse(encoder.getAccessEnc().getBool(true, flags));
         way.clearTags();
         way.setTag("highway", "tertiary");
         way.setTag("oneway:bicycle", "yes");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertFalse(encoder.getAccessEnc().getBool(true, flags));
         way.clearTags();
 
         way.setTag("highway", "tertiary");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
         way.clearTags();
 
         way.setTag("highway", "tertiary");
         way.setTag("vehicle:forward", "no");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertFalse(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertFalse(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
         way.clearTags();
 
         way.setTag("highway", "tertiary");
         way.setTag("bicycle:forward", "no");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertFalse(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertFalse(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
         way.clearTags();
 
         way.setTag("highway", "tertiary");
         way.setTag("vehicle:backward", "no");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertFalse(encoder.getAccessEnc().getBool(true, flags));
         way.clearTags();
 
         way.setTag("highway", "tertiary");
         way.setTag("motor_vehicle:backward", "no");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
         way.clearTags();
 
         // attention bicycle:backward=no/yes has a completely different meaning!
@@ -391,65 +399,64 @@ public void testOneway() {
         way.setTag("highway", "tertiary");
         way.setTag("oneway", "yes");
         way.setTag("bicycle:backward", "no");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
 
         way.setTag("bicycle:backward", "yes");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
 
         way.clearTags();
         way.setTag("highway", "tertiary");
         way.setTag("oneway", "yes");
         way.setTag("cycleway", "opposite");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
 
         way.clearTags();
         way.setTag("highway", "residential");
         way.setTag("oneway", "yes");
         way.setTag("cycleway:left", "opposite_lane");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(encoder.getAccessEnc().getBool(false, flags));
+        assertTrue(encoder.getAccessEnc().getBool(true, flags));
     }
 
     @Test
     public void testHandleWayTagsInfluencedByRelation() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "road");
-        long allowed = encoder.acceptBit;
 
         ReaderRelation osmRel = new ReaderRelation(1);
-        long relFlags = encoder.handleRelationTags(osmRel, 0);
+        long relFlags = encoder.handleRelationTags(0, osmRel);
         // unchanged
-        long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        IntsRef flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(12, encoder.getSpeed(flags), 1e-1);
         assertPriority(UNCHANGED.getValue(), osmWay, relFlags);
 
         // relation code is PREFER
         osmRel.setTag("route", "bicycle");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(12, encoder.getSpeed(flags), 1e-1);
         assertPriority(PREFER.getValue(), osmWay, relFlags);
         osmRel.setTag("network", "lcn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(12, encoder.getSpeed(flags), 1e-1);
         assertPriority(PREFER.getValue(), osmWay, relFlags);
 
         // relation code is VERY_NICE
         osmRel.setTag("network", "rcn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
+        relFlags = encoder.handleRelationTags(0, osmRel);
         assertPriority(VERY_NICE.getValue(), osmWay, relFlags);
 
         // relation code is BEST
         osmRel.setTag("network", "ncn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
+        relFlags = encoder.handleRelationTags(0, osmRel);
         assertPriority(BEST.getValue(), osmWay, relFlags);
 
         // PREFER relation, but tertiary road => no get off the bike but road wayTypeCode and faster
@@ -457,7 +464,7 @@ public void testHandleWayTagsInfluencedByRelation() {
         osmWay.setTag("highway", "tertiary");
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
+        relFlags = encoder.handleRelationTags(0, osmRel);
         assertPriority(PREFER.getValue(), osmWay, relFlags);
 
         // A footway is not of waytype get off the bike in case that it is part of a cycle route
@@ -467,7 +474,7 @@ public void testHandleWayTagsInfluencedByRelation() {
         osmWay.setTag("surface", "grass");
 
         // First tests without a cycle route relation, this is a get off the bike
-        relFlags = encoder.handleRelationTags(osmRel, 0);
+        relFlags = encoder.handleRelationTags(0, osmRel);
         String wayType = getWayTypeFromFlags(osmWay, relFlags);
         assertEquals("get off the bike, unpaved", wayType);
 
@@ -475,16 +482,35 @@ public void testHandleWayTagsInfluencedByRelation() {
         osmRel.setTag("type", "route");
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
+        relFlags = encoder.handleRelationTags(0, osmRel);
         wayType = getWayTypeFromFlags(osmWay, relFlags);
         assertEquals("small way, unpaved", wayType);
 
         // steps are still shown as get off the bike
         osmWay.clearTags();
         osmWay.setTag("highway", "steps");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
+        relFlags = encoder.handleRelationTags(0, osmRel);
         wayType = getWayTypeFromFlags(osmWay, relFlags);
         assertEquals("get off the bike", wayType);
+
+        // Test for highway=platform.
+        osmRel.clearTags();
+        osmWay.clearTags();
+        osmWay.setTag("highway", "platform");
+
+        // First tests without a cycle route relation, this is a get off the bike
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("get off the bike", wayType);
+
+        // now as part of a cycle route relation
+        osmRel.setTag("type", "route");
+        osmRel.setTag("route", "bicycle");
+        osmRel.setTag("network", "lcn");
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        wayType = getWayTypeFromFlags(osmWay, relFlags);
+        assertEquals("", wayType);
+
     }
 
     @Test
@@ -494,7 +520,7 @@ public void testUnchangedRelationShouldNotInfluencePriority() {
 
         ReaderRelation osmRel = new ReaderRelation(1);
         osmRel.setTag("description", "something");
-        long relFlags = encoder.handleRelationTags(osmRel, 0);
+        long relFlags = encoder.handleRelationTags(0, osmRel);
         assertPriority(REACH_DEST.getValue(), osmWay, relFlags);
     }
 
@@ -504,41 +530,37 @@ public void testSacScale() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
-        // allow
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("highway", "path");
         way.setTag("sac_scale", "mountain_hiking");
-        // disallow
-        assertEquals(0, encoder.acceptWay(way));
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.setTag("highway", "cycleway");
         way.setTag("sac_scale", "hiking");
-        // allow
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("highway", "cycleway");
         way.setTag("sac_scale", "mountain_hiking");
         // disallow questionable combination as too dangerous
-        assertEquals(0, encoder.acceptWay(way));
+        assertTrue(encoder.getAccess(way).canSkip());
     }
 
     @Test
     public void testCalcPriority() {
-        long allowed = encoder.acceptBit;
         ReaderWay osmWay = new ReaderWay(1);
         ReaderRelation osmRel = new ReaderRelation(1);
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "icn");
-        long relFlags = encoder.handleRelationTags(osmRel, 0);
-        long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
-        assertEquals((double) BEST.getValue() / BEST.getValue(), encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+        long relFlags = encoder.handleRelationTags(0, osmRel);
+        IntsRef flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
+        assertEquals(PriorityCode.getFactor(BEST.getValue()), priorityEnc.getDecimal(false, flags), .1);
 
         // important: UNCHANGED should not get 0 priority!
         osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "somethingelse");
-        flags = encoder.handleWayTags(osmWay, allowed, 0);
-        assertEquals((double) UNCHANGED.getValue() / BEST.getValue(), encoder.getDouble(flags, PriorityWeighting.KEY), 1e-3);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, 0);
+        assertEquals(PriorityCode.getFactor(UNCHANGED.getValue()), priorityEnc.getDecimal(false, flags), .1);
     }
 
     @Test
@@ -546,30 +568,36 @@ public void testMaxSpeed() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "secondary");
         way.setTag("maxspeed", "10");
-        long allowed = encoder.acceptWay(way);
-        long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+        EncodingManager.Access allowed = encoder.getAccess(way);
+        IntsRef edgeFlags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, allowed, 0);
+        assertEquals(10, encoder.getSpeed(edgeFlags), 1e-1);
         assertPriority(VERY_NICE.getValue(), way);
 
         way = new ReaderWay(1);
         way.setTag("highway", "tertiary");
         way.setTag("maxspeed", "90");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 20))), 1e-1);
+        edgeFlags = encodingManager.createEdgeFlags();
+        encoder.setSpeed(false, edgeFlags, encoder.applyMaxSpeed(way, 20));
+        assertEquals(20, encoder.getSpeed(edgeFlags), 1e-1);
         assertPriority(UNCHANGED.getValue(), way);
 
         way = new ReaderWay(1);
         way.setTag("highway", "track");
         way.setTag("maxspeed", "90");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 20))), 1e-1);
+        edgeFlags = encodingManager.createEdgeFlags();
+        encoder.setSpeed(false, edgeFlags, encoder.applyMaxSpeed(way, 20));
+        assertEquals(20, encoder.getSpeed(edgeFlags), 1e-1);
         assertPriority(UNCHANGED.getValue(), way);
 
         way = new ReaderWay(1);
         way.setTag("highway", "residential");
         way.setTag("maxspeed", "15");
-        assertEquals(15, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(way, 15))), 1.0);
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(15, encoder.getSpeed(encoded), 1.0);
+        edgeFlags = encodingManager.createEdgeFlags();
+        encoder.setSpeed(false, edgeFlags, encoder.applyMaxSpeed(way, 15));
+        assertEquals(15, encoder.getSpeed(edgeFlags), 1.0);
+        allowed = encoder.getAccess(way);
+        edgeFlags = encoder.handleWayTags(encodingManager.createEdgeFlags(), way, allowed, 0);
+        assertEquals(15, encoder.getSpeed(edgeFlags), 1.0);
         assertPriority(VERY_NICE.getValue(), way);
 
     }
@@ -599,7 +627,7 @@ public void testTurnFlagEncoding_DefaultNoRestrictionsAndNoCosts() {
     @Test
     public void testTurnFlagEncoding_withCosts() {
         encoder = new BikeFlagEncoder(4, 2, 127);
-        new EncodingManager(encoder);
+        EncodingManager.create(encoder);
 
         long flags_r0 = encoder.getTurnFlags(true, 0);
         long flags_0 = encoder.getTurnFlags(false, 0);
@@ -645,6 +673,11 @@ public void testBarrierAccess() {
         node.setTag("bicycle", "yes");
         // barrier!
         assertFalse(encoder.handleNodeTags(node) == 0);
+
+        // Test if cattle_grid is non blocking
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "cattle_grid");
+        assertTrue(encoder.handleNodeTags(node) == 0);
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/Car4WDFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/Car4WDFlagEncoderTest.java
index eae1bec0f3..9c24487bc9 100644
--- a/core/src/test/java/com/graphhopper/routing/util/Car4WDFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/Car4WDFlagEncoderTest.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.routing.util;
 
-import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.util.Helper;
 import org.junit.Test;
@@ -25,105 +24,104 @@
 import java.text.DateFormat;
 import java.util.Date;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  * @author zstadler
  */
 public class Car4WDFlagEncoderTest extends CarFlagEncoderTest {
-    private final EncodingManager em = new EncodingManager("car4wd,bike,foot");
+    private final EncodingManager em = EncodingManager.create("car4wd,bike,foot");
     private final Car4WDFlagEncoder encoder = (Car4WDFlagEncoder) em.getEncoder("car4wd");
 
     @Override
     @Test
     public void testAccess() {
         ReaderWay way = new ReaderWay(1);
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("highway", "service");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
         way.setTag("access", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("motorcar", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         // for now allow grade1+2+3 for every country, see #253
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("tracktype", "grade2");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
         // This is the only difference from a "car"
         way.setTag("tracktype", "grade4");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "delivery");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "unclassified");
         way.setTag("ford", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("motorcar", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("route", "ferry");
-        assertTrue(encoder.acceptWay(way) > 0);
-        assertTrue(encoder.isFerry(encoder.acceptWay(way)));
+        assertTrue(encoder.getAccess(way).isFerry());
         way.setTag("motorcar", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("route", "ferry");
         way.setTag("foot", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
-        assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("access", "yes");
         way.setTag("motor_vehicle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "yes");
         way.setTag("motor_vehicle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "no");
         way.setTag("motorcar", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "emergency");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("motor_vehicle", "emergency");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         DateFormat simpleDateFormat = Helper.createFormatter("yyyy MMM dd");
 
         way.clearTags();
         way.setTag("highway", "road");
         way.setTag("access:conditional", "no @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "road");
         way.setTag("access", "no");
         way.setTag("access:conditional", "yes @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
index 3e18ee644b..377ac98d56 100644
--- a/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/CarFlagEncoderTest.java
@@ -19,11 +19,17 @@
 
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.PMap;
 import org.junit.Test;
 
 import java.text.DateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Date;
+import java.util.List;
 
 import static org.junit.Assert.*;
 
@@ -31,104 +37,106 @@
  * @author Peter Karich
  */
 public class CarFlagEncoderTest {
-    private final EncodingManager em = new EncodingManager("car,bike,foot");
+    private final EncodingManager em = EncodingManager.create(Arrays.asList(new CarFlagEncoder(new PMap("speed_two_directions=true")),
+            new BikeFlagEncoder(), new FootFlagEncoder()), 8);
     private final CarFlagEncoder encoder = (CarFlagEncoder) em.getEncoder("car");
+    private final BooleanEncodedValue roundaboutEnc = em.getBooleanEncodedValue(Roundabout.KEY);
+    private final DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
+    private final BooleanEncodedValue accessEnc = encoder.getAccessEnc();
 
     @Test
     public void testAccess() {
         ReaderWay way = new ReaderWay(1);
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("highway", "service");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
         way.setTag("access", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("motorcar", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         // for now allow grade1+2+3 for every country, see #253
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("tracktype", "grade2");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
         way.setTag("tracktype", "grade4");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "delivery");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "unclassified");
         way.setTag("ford", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("motorcar", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("route", "ferry");
-        assertTrue(encoder.acceptWay(way) > 0);
-        assertTrue(encoder.isFerry(encoder.acceptWay(way)));
+        assertTrue(encoder.getAccess(way).isFerry());
         way.setTag("motorcar", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("route", "ferry");
         way.setTag("foot", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
-        assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("route", "ferry");
         way.setTag("access", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("vehicle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isFerry());
 
         way.clearTags();
         way.setTag("access", "yes");
         way.setTag("motor_vehicle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "yes");
         way.setTag("motor_vehicle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "no");
         way.setTag("motorcar", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "emergency");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("motor_vehicle", "emergency");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         DateFormat simpleDateFormat = Helper.createFormatter("yyyy MMM dd");
 
         way.clearTags();
         way.setTag("highway", "road");
         way.setTag("access:conditional", "no @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "road");
         way.setTag("access", "no");
         way.setTag("access:conditional", "yes @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
     }
 
     @Test
@@ -136,7 +144,7 @@ public void testMilitaryAccess() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "track");
         way.setTag("access", "military");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
     }
 
     @Test
@@ -150,13 +158,13 @@ public void testFordAccess() {
 
         // Node and way are initially blocking
         assertTrue(encoder.isBlockFords());
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         assertTrue(encoder.handleNodeTags(node) > 0);
 
         try {
             // Now they are passable
             encoder.setBlockFords(false);
-            assertTrue(encoder.acceptWay(way) > 0);
+            assertTrue(encoder.getAccess(way).isWay());
             assertFalse(encoder.handleNodeTags(node) > 0);
         } finally {
             encoder.setBlockFords(true);
@@ -167,33 +175,33 @@ public void testFordAccess() {
     public void testOneway() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "primary");
-        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        IntsRef flags = encoder.handleWayTags(em.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(accessEnc.getBool(false, flags));
+        assertTrue(accessEnc.getBool(true, flags));
         way.setTag("oneway", "yes");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(em.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(accessEnc.getBool(false, flags));
+        assertFalse(accessEnc.getBool(true, flags));
         way.clearTags();
 
         way.setTag("highway", "tertiary");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(em.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(accessEnc.getBool(false, flags));
+        assertTrue(accessEnc.getBool(true, flags));
         way.clearTags();
 
         way.setTag("highway", "tertiary");
         way.setTag("vehicle:forward", "no");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertFalse(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(em.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertFalse(accessEnc.getBool(false, flags));
+        assertTrue(accessEnc.getBool(true, flags));
         way.clearTags();
 
         way.setTag("highway", "tertiary");
         way.setTag("vehicle:backward", "no");
-        flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
+        flags = encoder.handleWayTags(em.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertTrue(accessEnc.getBool(false, flags));
+        assertFalse(accessEnc.getBool(true, flags));
         way.clearTags();
     }
 
@@ -205,31 +213,44 @@ public void testDestinationTag() {
         assertEquals(60, encoder.getSpeed(way), 1e-1);
 
         way.setTag("vehicle", "destination");
-        long flags = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertEquals(5, encoder.getSpeed(flags), 1e-1);
+        IntsRef flags = encoder.handleWayTags(em.createEdgeFlags(), way, encoder.getAccess(way), 0);
+        assertEquals(5, avSpeedEnc.getDecimal(false, flags), 1e-1);
     }
 
     @Test
     public void testSetAccess() {
-        assertTrue(encoder.isForward(encoder.setProperties(0, true, true)));
-        assertTrue(encoder.isBackward(encoder.setProperties(0, true, true)));
-
-        assertTrue(encoder.isForward(encoder.setProperties(0, true, false)));
-        assertFalse(encoder.isBackward(encoder.setProperties(0, true, false)));
-
-        assertFalse(encoder.isForward(encoder.setProperties(0, false, true)));
-        assertTrue(encoder.isBackward(encoder.setProperties(0, false, true)));
-
-        assertTrue(encoder.isForward(encoder.flagsDefault(true, true)));
-        assertTrue(encoder.isBackward(encoder.flagsDefault(true, true)));
-
-        assertTrue(encoder.isForward(encoder.flagsDefault(true, false)));
-        assertFalse(encoder.isBackward(encoder.flagsDefault(true, false)));
-
-        long flags = encoder.flagsDefault(true, true);
+        IntsRef edgeFlags = em.createEdgeFlags();
+        accessEnc.setBool(false, edgeFlags, true);
+        accessEnc.setBool(true, edgeFlags, true);
+        assertTrue(accessEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(true, edgeFlags));
+
+        accessEnc.setBool(false, edgeFlags, true);
+        accessEnc.setBool(true, edgeFlags, false);
+        assertTrue(accessEnc.getBool(false, edgeFlags));
+        assertFalse(accessEnc.getBool(true, edgeFlags));
+
+        accessEnc.setBool(false, edgeFlags, false);
+        accessEnc.setBool(true, edgeFlags, true);
+        assertFalse(accessEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(true, edgeFlags));
+
+        encoder.flagsDefault(edgeFlags, true, true);
+        assertTrue(accessEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(true, edgeFlags));
+
+        encoder.flagsDefault(edgeFlags, true, false);
+        assertTrue(accessEnc.getBool(false, edgeFlags));
+        assertFalse(accessEnc.getBool(true, edgeFlags));
+
+        encoder.flagsDefault(edgeFlags, true, true);
         // disable access
-        assertFalse(encoder.isForward(encoder.setAccess(flags, false, false)));
-        assertFalse(encoder.isBackward(encoder.setAccess(flags, false, false)));
+        accessEnc.setBool(false, edgeFlags, false);
+        accessEnc.setBool(true, edgeFlags, false);
+        assertFalse(accessEnc.getBool(false, edgeFlags));
+        accessEnc.setBool(false, edgeFlags, false);
+        accessEnc.setBool(true, edgeFlags, false);
+        assertFalse(accessEnc.getBool(true, edgeFlags));
     }
 
     @Test
@@ -237,34 +258,36 @@ public void testMaxSpeed() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "trunk");
         way.setTag("maxspeed", "500");
-        long allowed = encoder.acceptWay(way);
-        long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(140, encoder.getSpeed(encoded), 1e-1);
+        EncodingManager.AcceptWay allowed = new EncodingManager.AcceptWay();
+        for (FlagEncoder encoder : em.fetchEdgeEncoders())
+            allowed.put(encoder.toString(), EncodingManager.Access.WAY);
+        IntsRef edgeFlags = em.handleWayTags(way, allowed, 0);
+        assertEquals(140, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way = new ReaderWay(1);
         way.setTag("highway", "primary");
         way.setTag("maxspeed:backward", "10");
         way.setTag("maxspeed:forward", "20");
-        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertEquals(10, encoder.getSpeed(encoded), 1e-1);
+        edgeFlags = em.handleWayTags(way, allowed, 0);
+        assertEquals(10, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way = new ReaderWay(1);
         way.setTag("highway", "primary");
         way.setTag("maxspeed:forward", "20");
-        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+        edgeFlags = em.handleWayTags(way, allowed, 0);
+        assertEquals(20, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way = new ReaderWay(1);
         way.setTag("highway", "primary");
         way.setTag("maxspeed:backward", "20");
-        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+        edgeFlags = em.handleWayTags(way, allowed, 0);
+        assertEquals(20, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way = new ReaderWay(1);
         way.setTag("highway", "motorway");
         way.setTag("maxspeed", "none");
-        encoded = encoder.handleWayTags(way, encoder.acceptWay(way), 0);
-        assertEquals(125, encoder.getSpeed(encoded), .1);
+        edgeFlags = em.handleWayTags(way, allowed, 0);
+        assertEquals(135, avSpeedEnc.getDecimal(false, edgeFlags), .1);
     }
 
     @Test
@@ -273,60 +296,60 @@ public void testSpeed() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "trunk");
         way.setTag("maxspeed", "110");
-        long allowed = encoder.acceptWay(way);
-        long encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+        EncodingManager.Access allowed = encoder.getAccess(way);
+        IntsRef edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, allowed, 0);
+        assertEquals(100, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "residential");
         way.setTag("surface", "cobblestone");
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(30, encoder.getSpeed(encoded), 1e-1);
+        allowed = encoder.getAccess(way);
+        edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, allowed, 0);
+        assertEquals(30, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "track");
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(15, encoder.getSpeed(encoded), 1e-1);
+        allowed = encoder.getAccess(way);
+        edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, allowed, 0);
+        assertEquals(15, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("tracktype", "grade1");
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(20, encoder.getSpeed(encoded), 1e-1);
+        allowed = encoder.getAccess(way);
+        edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, allowed, 0);
+        assertEquals(20, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "secondary");
         way.setTag("surface", "compacted");
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(30, encoder.getSpeed(encoded), 1e-1);
+        allowed = encoder.getAccess(way);
+        edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, allowed, 0);
+        assertEquals(30, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "secondary");
         way.setTag("motorroad", "yes");
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(90, encoder.getSpeed(encoded), 1e-1);
+        allowed = encoder.getAccess(way);
+        edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, allowed, 0);
+        assertEquals(90, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "motorway");
         way.setTag("motorroad", "yes"); // this tag should be ignored
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(100, encoder.getSpeed(encoded), 1e-1);
+        allowed = encoder.getAccess(way);
+        edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, allowed, 0);
+        assertEquals(100, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "motorway_link");
         way.setTag("motorroad", "yes"); // this tag should be ignored
-        allowed = encoder.acceptWay(way);
-        encoded = encoder.handleWayTags(way, allowed, 0);
-        assertEquals(70, encoder.getSpeed(encoded), 1e-1);
+        allowed = encoder.getAccess(way);
+        edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, allowed, 0);
+        assertEquals(70, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         try {
-            encoder.setSpeed(0, -1);
+            avSpeedEnc.setDecimal(false, em.createEdgeFlags(), -1);
             assertTrue(false);
         } catch (IllegalArgumentException ex) {
         }
@@ -334,53 +357,51 @@ public void testSpeed() {
 
     @Test
     public void testSetSpeed() {
-        assertEquals(10, encoder.getSpeed(encoder.setSpeed(0, 10)), 1e-1);
+        IntsRef edgeFlags = em.createEdgeFlags();
+        avSpeedEnc.setDecimal(false, edgeFlags, 10);
+        assertEquals(10, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
     }
 
     @Test
     public void testSetSpeed0_issue367() {
-        long flags = encoder.setProperties(10, true, true);
-        flags = encoder.setSpeed(flags, encoder.speedFactor * 0.49);
+        IntsRef edgeFlags = em.createEdgeFlags();
+        accessEnc.setBool(false, edgeFlags, true);
+        accessEnc.setBool(true, edgeFlags, true);
+
+        encoder.setSpeed(false, edgeFlags, encoder.speedFactor * 0.49);
 
-        assertEquals(0, encoder.getSpeed(flags), .1);
-        assertEquals(0, encoder.getReverseSpeed(flags), .1);
-        assertFalse(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
+        // one direction effects the other direction as one encoder for speed but this is not true for access
+        assertEquals(0, avSpeedEnc.getDecimal(false, edgeFlags), .1);
+        assertEquals(0, avSpeedEnc.getDecimal(true, edgeFlags), .1);
+        assertFalse(accessEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(true, edgeFlags));
+
+        // so always call this method with reverse=true too
+        encoder.setSpeed(true, edgeFlags, encoder.speedFactor * 0.49);
+        assertFalse(accessEnc.getBool(true, edgeFlags));
     }
 
     @Test
     public void testRoundabout() {
-        long flags = encoder.setAccess(0, true, true);
-        long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
-        assertTrue(encoder.isForward(resFlags));
-        assertTrue(encoder.isBackward(resFlags));
-
-        resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, false);
-        assertFalse(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
-        assertTrue(encoder.isForward(resFlags));
-        assertTrue(encoder.isBackward(resFlags));
+        IntsRef edgeFlags = em.createEdgeFlags();
+        accessEnc.setBool(false, edgeFlags, true);
+        accessEnc.setBool(true, edgeFlags, true);
+        roundaboutEnc.setBool(false, edgeFlags, true);
+        assertTrue(roundaboutEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(true, edgeFlags));
+
+        roundaboutEnc.setBool(false, edgeFlags, false);
+        assertFalse(roundaboutEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(true, edgeFlags));
 
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "motorway");
-        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
-        assertFalse(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
-
-        way.setTag("junction", "roundabout");
-        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
-
-        way.clearTags();
-        way.setTag("highway", "motorway");
-        way.setTag("junction", "circular");
-        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+        edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, EncodingManager.Access.WAY, 0);
+        assertTrue(accessEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(true, edgeFlags));
+        assertFalse(roundaboutEnc.getBool(false, edgeFlags));
     }
 
     @Test
@@ -388,29 +409,29 @@ public void testRailway() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "secondary");
         way.setTag("railway", "rail");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "path");
         way.setTag("railway", "abandoned");
-        assertTrue(encoder.acceptWay(way) == 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         // this is fully okay as sometimes old rails are on the road
         way.setTag("highway", "primary");
         way.setTag("railway", "historic");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("motorcar", "no");
-        assertTrue(encoder.acceptWay(way) == 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way = new ReaderWay(1);
         way.setTag("highway", "secondary");
         way.setTag("railway", "tram");
         // but allow tram to be on the same way
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way = new ReaderWay(1);
         way.setTag("route", "shuttle_train");
@@ -420,7 +441,7 @@ public void testRailway() {
         way.setTag("duration:seconds", Long.toString(35 * 60));
         way.setTag("estimated_distance", 50000);
         // accept
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isFerry());
         // calculate speed from estimated_distance and duration
         assertEquals(61, encoder.getFerrySpeed(way), 1e-1);
 
@@ -432,10 +453,13 @@ public void testRailway() {
         way.setTag("duration:seconds", Long.toString(12 * 60));
         way.setTag("estimated_distance", 100);
         // accept
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isFerry());
         // We can't store 0.5km/h, but we expect the lowest possible speed (5km/h)
         assertEquals(2.5, encoder.getFerrySpeed(way), 1e-1);
-        assertEquals(5, encoder.getSpeed(encoder.setSpeed(0, 2.5)), 1e-1);
+
+        IntsRef edgeFlags = em.createEdgeFlags();
+        avSpeedEnc.setDecimal(false, edgeFlags, 2.5);
+        assertEquals(5, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
 
         //Test for an unrealisitic long duration
         way = new ReaderWay(1);
@@ -445,25 +469,11 @@ public void testRailway() {
         way.setTag("duration:seconds", Long.toString(87900 * 60));
         way.setTag("estimated_distance", 100);
         // accept
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isFerry());
         // We have ignored the unrealisitc long duration and take the unknown speed
         assertEquals(2.5, encoder.getFerrySpeed(way), 1e-1);
     }
 
-    @Test
-    public void testSwapDir() {
-        long swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, true));
-        assertTrue(encoder.isForward(swappedFlags));
-        assertTrue(encoder.isBackward(swappedFlags));
-
-        swappedFlags = encoder.reverseFlags(encoder.flagsDefault(true, false));
-
-        assertFalse(encoder.isForward(swappedFlags));
-        assertTrue(encoder.isBackward(swappedFlags));
-
-        assertEquals(0, encoder.reverseFlags(0));
-    }
-
     @Test
     public void testBarrierAccess() {
         ReaderNode node = new ReaderNode(1, -1, -1);
@@ -501,12 +511,19 @@ public void testBarrierAccess() {
         node.setTag("motorcar", "yes");
         // still barrier!
         assertTrue(encoder.handleNodeTags(node) > 0);
+
+        encoder.setBlockByDefault(false);
+
+        // Test if cattle_grid is not blocking
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "cattle_grid");
+        assertTrue(encoder.handleNodeTags(node) == 0);
     }
 
     @Test
     public void testTurnFlagEncoding_noCosts() {
         FlagEncoder tmpEnc = new CarFlagEncoder(8, 5, 0);
-        EncodingManager em = new EncodingManager(tmpEnc);
+        EncodingManager em = EncodingManager.create(tmpEnc);
 
         long flags_r0 = tmpEnc.getTurnFlags(true, 0);
         long flags_0 = tmpEnc.getTurnFlags(false, 0);
@@ -530,7 +547,7 @@ public void testTurnFlagEncoding_noCosts() {
     @Test
     public void testTurnFlagEncoding_withCosts() {
         FlagEncoder tmpEncoder = new CarFlagEncoder(8, 5, 127);
-        EncodingManager em = new EncodingManager(tmpEncoder);
+        EncodingManager em = EncodingManager.create(tmpEncoder);
 
         long flags_r0 = tmpEncoder.getTurnFlags(true, 0);
         long flags_0 = tmpEncoder.getTurnFlags(false, 0);
@@ -559,32 +576,32 @@ public void testTurnFlagEncoding_withCosts() {
     @Test
     public void testMaxValue() {
         CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
-        EncodingManager em = new EncodingManager(instance);
+        EncodingManager em = EncodingManager.create(instance);
+        DecimalEncodedValue avSpeedEnc = em.getDecimalEncodedValue(EncodingManager.getKey(instance, "average_speed"));
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "motorway_link");
         way.setTag("maxspeed", "60 mph");
-        long flags = instance.handleWayTags(way, 1, 0);
+        IntsRef edgeFlags = instance.handleWayTags(em.createEdgeFlags(), way, EncodingManager.Access.WAY, 0);
 
         // double speed = AbstractFlagEncoder.parseSpeed("60 mph");
         // => 96.56 * 0.9 => 86.9
-        assertEquals(86.9, instance.getSpeed(flags), 1e-1);
-        flags = instance.reverseFlags(flags);
-        assertEquals(86.9, instance.getSpeed(flags), 1e-1);
+        assertEquals(86.9, avSpeedEnc.getDecimal(false, edgeFlags), 1e-1);
+        assertEquals(86.9, avSpeedEnc.getDecimal(true, edgeFlags), 1e-1);
 
         // test that maxPossibleValue  is not exceeded
         way = new ReaderWay(2);
         way.setTag("highway", "motorway_link");
         way.setTag("maxspeed", "70 mph");
-        flags = instance.handleWayTags(way, 1, 0);
-        assertEquals(101.5, instance.getSpeed(flags), .1);
+        edgeFlags = instance.handleWayTags(em.createEdgeFlags(), way, EncodingManager.Access.WAY, 0);
+        assertEquals(101.5, avSpeedEnc.getDecimal(false, edgeFlags), .1);
     }
 
     @Test
     public void testRegisterOnlyOnceAllowed() {
         CarFlagEncoder instance = new CarFlagEncoder(10, 0.5, 0);
-        EncodingManager tmpEM = new EncodingManager(instance);
+        EncodingManager tmpEM = EncodingManager.create(instance);
         try {
-            tmpEM = new EncodingManager(instance);
+            tmpEM = EncodingManager.create(instance);
             assertTrue(false);
         } catch (IllegalStateException ex) {
         }
@@ -603,12 +620,14 @@ public void testCombination() {
         way.setTag("highway", "cycleway");
         way.setTag("sac_scale", "hiking");
 
-        long flags = em.acceptWay(way);
-        long edgeFlags = em.handleWayTags(way, flags, 0);
-        assertFalse(encoder.isBackward(edgeFlags));
-        assertFalse(encoder.isForward(edgeFlags));
-        assertTrue(em.getEncoder("bike").isBackward(edgeFlags));
-        assertTrue(em.getEncoder("bike").isForward(edgeFlags));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        assertTrue(em.acceptWay(way, map));
+        IntsRef edgeFlags = em.handleWayTags(way, map, 0);
+        assertFalse(accessEnc.getBool(true, edgeFlags));
+        assertFalse(accessEnc.getBool(false, edgeFlags));
+        BooleanEncodedValue bikeAccessEnc = em.getEncoder("bike").getAccessEnc();
+        assertTrue(bikeAccessEnc.getBool(true, edgeFlags));
+        assertTrue(bikeAccessEnc.getBool(false, edgeFlags));
     }
 
     @Test
@@ -617,7 +636,6 @@ public void testApplyBadSurfaceSpeed() {
         way.setTag("highway", "secondary");
         way.setTag("surface", "unpaved");
         assertEquals(30, encoder.applyBadSurfaceSpeed(way, 90), 1e-1);
-
     }
 
     @Test
@@ -627,7 +645,9 @@ public void testIssue_1256() {
         way.setTag("estimated_distance", 257);
 
         CarFlagEncoder lowFactorCar = new CarFlagEncoder(10, 1, 0);
-        lowFactorCar.defineWayBits(0,0);
+        List<EncodedValue> list = new ArrayList<>();
+        lowFactorCar.setEncodedValueLookup(em);
+        lowFactorCar.createEncodedValues(list, "car", 0);
         assertEquals(2.5, encoder.getFerrySpeed(way), .1);
         assertEquals(.5, lowFactorCar.getFerrySpeed(way), .1);
     }
diff --git a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
index 810e759dee..7b80efa42d 100644
--- a/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/DataFlagEncoderTest.java
@@ -1,20 +1,26 @@
 package com.graphhopper.routing.util;
 
-import java.util.*;
-
+import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.routing.util.parsers.*;
+import com.graphhopper.routing.util.spatialrules.SpatialRule;
+import com.graphhopper.routing.util.spatialrules.SpatialRuleLookup;
 import com.graphhopper.routing.util.spatialrules.countries.GermanySpatialRule;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.PMap;
-import com.graphhopper.routing.util.spatialrules.*;
-import com.graphhopper.util.*;
+import com.graphhopper.util.TranslationMapTest;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Polygon;
 import org.junit.Test;
 
-import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphBuilder;
+import java.util.Arrays;
+import java.util.Collections;
 
 import static org.junit.Assert.*;
 
@@ -22,36 +28,49 @@
  * @author Peter Karich
  */
 public class DataFlagEncoderTest {
+    private final EncodingManager.AcceptWay map;
     private final PMap properties;
     private final DataFlagEncoder encoder;
+    private final BooleanEncodedValue accessEnc;
+    private final EnumEncodedValue<RoadAccess> roadAccessEnc;
+    private final EnumEncodedValue<RoadEnvironment> roadEnvironmentEnc;
+    private final EnumEncodedValue<RoadClass> roadClassEnc;
+    private final EnumEncodedValue<Surface> surfaceEnc;
+    private final DecimalEncodedValue carMaxSpeedEnc;
     private final EncodingManager encodingManager;
-    private final int motorVehicleInt;
 
     private final double DELTA = 0.1;
 
     public DataFlagEncoderTest() {
         properties = new PMap();
-        properties.put("store_height", true);
-        properties.put("store_weight", true);
-        properties.put("store_width", true);
         encoder = new DataFlagEncoder(properties);
-        encodingManager = new EncodingManager(Arrays.asList(encoder), 8);
-
-        motorVehicleInt = encoder.getAccessType("motor_vehicle");
+        encodingManager = new EncodingManager.Builder(8).
+                add(new OSMRoadEnvironmentParser()).
+                add(new OSMRoadClassParser()).
+                add(new OSMRoadAccessParser()).
+                add(new OSMSurfaceParser()).
+                add(new OSMMaxSpeedParser(carMaxSpeedEnc = MaxSpeed.create())).
+                add(encoder).build();
+        roadEnvironmentEnc = encodingManager.getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class);
+        roadClassEnc = encodingManager.getEnumEncodedValue(RoadClass.KEY, RoadClass.class);
+        roadAccessEnc = encodingManager.getEnumEncodedValue(RoadAccess.KEY, RoadAccess.class);
+        surfaceEnc = encodingManager.getEnumEncodedValue(Surface.KEY, Surface.class);
+        map = new EncodingManager.AcceptWay().put(encoder.toString(), EncodingManager.Access.WAY);
+        accessEnc = encoder.getAccessEnc();
     }
 
-    @Test(expected = IllegalArgumentException.class)
-    public void testInsufficientEncoderBitLength() {
-        EncodingManager em = new EncodingManager(Arrays.asList(new DataFlagEncoder(properties)));
+    @Test(expected = IllegalStateException.class)
+    public void testNoDefaultEncodedValues() {
+        EncodingManager em = EncodingManager.create(Arrays.asList(new DataFlagEncoder(properties)));
     }
 
     @Test
     public void testSufficientEncoderBitLength() {
         try {
-            EncodingManager em = new EncodingManager(Arrays.asList(new DataFlagEncoder(properties)), 8);
-            EncodingManager em1 = new EncodingManager(Arrays.asList(new DataFlagEncoder()));
+            EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).add(new DataFlagEncoder(properties)).build();
+            EncodingManager em1 = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(12)).add(new DataFlagEncoder(properties)).build();
         } catch (Throwable t) {
-            fail();
+            fail(t.toString());
         }
     }
 
@@ -61,27 +80,27 @@ public void testHighway() {
         osmWay.setTag("highway", "primary");
         osmWay.setTag("surface", "sand");
         osmWay.setTag("tunnel", "yes");
-        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        IntsRef flags = encodingManager.handleWayTags(osmWay, map, 0);
         EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals("primary", encoder.getHighwayAsString(edge));
-        assertEquals("sand", encoder.getSurfaceAsString(edge));
-        assertEquals("tunnel", encoder.getTransportModeAsString(edge));
-        assertTrue(encoder.isForward(edge, motorVehicleInt));
-        assertTrue(encoder.isBackward(edge, motorVehicleInt));
+        assertEquals("primary", edge.get(roadClassEnc).toString());
+        assertEquals("sand", edge.get(surfaceEnc).toString());
+        assertEquals("tunnel", edge.get(roadEnvironmentEnc).toString());
+        assertTrue(edge.get(accessEnc));
+        assertTrue(edge.getReverse(accessEnc));
 
         osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("oneway", "yes");
-        flags = encoder.handleWayTags(osmWay, 1, 0);
+        flags = encodingManager.handleWayTags(osmWay, map, 0);
         edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertTrue(encoder.isForward(edge, motorVehicleInt));
-        assertFalse(encoder.isBackward(edge, motorVehicleInt));
+        assertTrue(edge.get(accessEnc));
+        assertFalse(edge.getReverse(accessEnc));
 
         osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "unknownX");
-        flags = encoder.handleWayTags(osmWay, 1, 0);
+        flags = encodingManager.handleWayTags(osmWay, map, 0);
         edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals("_default", encoder.getHighwayAsString(edge));
+        assertEquals("other", edge.get(roadClassEnc).toString());
     }
 
     @Test
@@ -89,22 +108,22 @@ public void testTunnel() {
         ReaderWay osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("tunnel", "yes");
-        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        IntsRef flags = encodingManager.handleWayTags(osmWay, map, 0);
         EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals("primary", encoder.getHighwayAsString(edge));
-        assertEquals("tunnel", encoder.getTransportModeAsString(edge));
-        assertTrue(encoder.isTransportModeTunnel(edge));
-        assertFalse(encoder.isTransportModeBridge(edge));
+        assertEquals("primary", edge.get(roadClassEnc).toString());
+        assertEquals("tunnel", edge.get(roadEnvironmentEnc).toString());
+        assertTrue(edge.get(roadEnvironmentEnc) == RoadEnvironment.TUNNEL);
+        assertFalse(edge.get(roadEnvironmentEnc) == RoadEnvironment.BRIDGE);
 
         osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("tunnel", "yes");
         osmWay.setTag("bridge", "yes");
-        flags = encoder.handleWayTags(osmWay, 1, 0);
+        flags = encodingManager.handleWayTags(osmWay, map, 0);
         edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals("bridge", encoder.getTransportModeAsString(edge));
-        assertFalse(encoder.isTransportModeTunnel(edge));
-        assertTrue(encoder.isTransportModeBridge(edge));
+        assertEquals("bridge", edge.get(roadEnvironmentEnc).toString());
+        assertFalse(edge.get(roadEnvironmentEnc) == RoadEnvironment.TUNNEL);
+        assertTrue(edge.get(roadEnvironmentEnc) == RoadEnvironment.BRIDGE);
     }
 
     @Test
@@ -112,22 +131,22 @@ public void testBridge() {
         ReaderWay osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("bridge", "yes");
-        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        IntsRef flags = encodingManager.handleWayTags(osmWay, map, 0);
         EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals("primary", encoder.getHighwayAsString(edge));
-        assertEquals("bridge", encoder.getTransportModeAsString(edge));
-        assertFalse(encoder.isTransportModeTunnel(edge));
-        assertTrue(encoder.isTransportModeBridge(edge));
+        assertEquals("primary", edge.get(roadClassEnc).toString());
+        assertEquals("bridge", edge.get(roadEnvironmentEnc).toString());
+        assertFalse(edge.get(roadEnvironmentEnc) == RoadEnvironment.TUNNEL);
+        assertTrue(edge.get(roadEnvironmentEnc) == RoadEnvironment.BRIDGE);
 
         osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("bridge", "yes");
         osmWay.setTag("tunnel", "yes");
-        flags = encoder.handleWayTags(osmWay, 1, 0);
+        flags = encodingManager.handleWayTags(osmWay, map, 0);
         edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals("bridge", encoder.getTransportModeAsString(edge));
-        assertFalse(encoder.isTransportModeTunnel(edge));
-        assertTrue(encoder.isTransportModeBridge(edge));
+        assertEquals("bridge", edge.get(roadEnvironmentEnc).toString());
+        assertFalse(edge.get(roadEnvironmentEnc) == RoadEnvironment.TUNNEL);
+        assertTrue(edge.get(roadEnvironmentEnc) == RoadEnvironment.BRIDGE);
     }
 
     @Test
@@ -135,47 +154,48 @@ public void testFord() {
         ReaderWay osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "unclassified");
         osmWay.setTag("ford", "yes");
-        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        IntsRef flags = encodingManager.handleWayTags(osmWay, map, 0);
         EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals("ford", encoder.getTransportModeAsString(edge));
-        assertTrue(encoder.isTransportModeFord(edge.getFlags()));
+        assertEquals("ford", edge.get(roadEnvironmentEnc).toString());
+        assertTrue(edge.get(roadEnvironmentEnc) == RoadEnvironment.FORD);
         assertTrue(encoder.getAnnotation(edge.getFlags(), TranslationMapTest.SINGLETON.get("en")).getMessage().contains("ford"));
     }
 
-    @Test
-    public void testCircularJunction() {
-        ReaderWay osmWay = new ReaderWay(0);
-        osmWay.setTag("highway", "unclassified");
-        osmWay.setTag("junction", "circular");
-        long flags = encoder.handleWayTags(osmWay, 1, 0);
-        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertTrue(encoder.isRoundabout(edge));
-    }
-
     @Test
     public void testHighwaySpeed() {
-        Map<String, Double> map = new LinkedHashMap<>();
+        PMap map = new PMap();
         map.put("motorway", 100d);
         map.put("motorway_link", 100d);
         map.put("motorroad", 90d);
         map.put("trunk", 90d);
         map.put("trunk_link", 90d);
 
-        double[] arr = encoder.getHighwaySpeedMap(map);
-        assertEquals("[0.0, 100.0, 100.0, 90.0, 90.0, 90.0]", Helper.createDoubleList(arr).subList(0, 6).toString());
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, encodingManager.createEdgeFlags());
+        DataFlagEncoder.WeightingConfig config = encoder.createWeightingConfig(map);
+        roadClassEnc.setEnum(false, edge.getFlags(), RoadClass.MOTORWAY);
+        assertEquals(100, config.getSpeed(edge), 1);
+
+        roadClassEnc.setEnum(false, edge.getFlags(), RoadClass.TRUNK);
+        assertEquals(90, config.getSpeed(edge), 1);
     }
 
     @Test
     public void testDestinationTag() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "secondary");
-        assertEquals(AccessValue.ACCESSIBLE, encoder.getAccessValue(encoder.handleWayTags(way, encoder.acceptWay(way), 0)));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay().put(encoder.toString(), encoder.getAccess(way));
+        IntsRef intsref = encodingManager.handleWayTags(way, map, 0);
+        assertEquals(RoadAccess.YES, roadAccessEnc.getEnum(false, intsref));
 
         way.setTag("vehicle", "destination");
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, encoder.getAccessValue(encoder.handleWayTags(way, encoder.acceptWay(way), 0)));
+        map = new EncodingManager.AcceptWay().put(encoder.toString(), encoder.getAccess(way));
+        intsref = encodingManager.handleWayTags(way, map, 0);
+        assertEquals(RoadAccess.DESTINATION, roadAccessEnc.getEnum(false, intsref));
 
         way.setTag("vehicle", "no");
-        assertEquals(AccessValue.NOT_ACCESSIBLE, encoder.getAccessValue(encoder.handleWayTags(way, encoder.acceptWay(way), 0)));
+        map = new EncodingManager.AcceptWay().put(encoder.toString(), encoder.getAccess(way));
+        intsref = encodingManager.handleWayTags(way, map, 0);
+        assertEquals(RoadAccess.NO, roadAccessEnc.getEnum(false, intsref));
     }
 
     @Test
@@ -183,47 +203,45 @@ public void testMaxspeed() {
         ReaderWay osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("maxspeed", "10");
-        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        IntsRef flags = encodingManager.handleWayTags(osmWay, map, 0);
         EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
-        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+        assertEquals(10, edge.get(carMaxSpeedEnc), .1);
+        assertEquals(10, edge.getReverse(carMaxSpeedEnc), .1);
 
         osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("maxspeed:forward", "10");
-        flags = encoder.handleWayTags(osmWay, 1, 0);
+        flags = encodingManager.handleWayTags(osmWay, map, 0);
         edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
-        assertEquals(-1, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+        assertEquals(10, edge.get(carMaxSpeedEnc), .1);
+        assertEquals(Double.POSITIVE_INFINITY, edge.getReverse(carMaxSpeedEnc), .1);
 
         osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("maxspeed:forward", "50");
         osmWay.setTag("maxspeed:backward", "50");
         osmWay.setTag("maxspeed", "60");
-        flags = encoder.handleWayTags(osmWay, 1, 0);
+        flags = encodingManager.handleWayTags(osmWay, map, 0);
         edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals(50, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
-        assertEquals(50, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+        assertEquals(50, edge.get(carMaxSpeedEnc), .1);
+        assertEquals(50, edge.getReverse(carMaxSpeedEnc), .1);
     }
 
     @Test
     public void testLargeMaxspeed() {
         ReaderWay osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
-        osmWay.setTag("maxspeed", "145");
-        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        osmWay.setTag("maxspeed", "170");
+        IntsRef flags = encodingManager.handleWayTags(osmWay, map, 0);
         EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals(140, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
-        assertEquals(140, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+        assertEquals(MaxSpeed.UNLIMITED_SIGN_SPEED, edge.get(carMaxSpeedEnc), .1);
 
         osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("maxspeed", "1000");
-        flags = encoder.handleWayTags(osmWay, 1, 0);
+        flags = encodingManager.handleWayTags(osmWay, map, 0);
         edge = GHUtility.createMockedEdgeIteratorState(0, flags);
-        assertEquals(140, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
-        assertEquals(140, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+        assertEquals(MaxSpeed.UNLIMITED_SIGN_SPEED, edge.get(carMaxSpeedEnc), .1);
     }
 
     @Test
@@ -233,15 +251,15 @@ public void reverseEdge() {
         ReaderWay osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
         osmWay.setTag("maxspeed:forward", "10");
-        long flags = encoder.handleWayTags(osmWay, 1, 0);
+        IntsRef flags = encodingManager.handleWayTags(osmWay, map, 0);
         edge.setFlags(flags);
 
-        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
-        assertEquals(-1, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+        assertEquals(10, edge.get(carMaxSpeedEnc), .1);
+        assertEquals(Double.POSITIVE_INFINITY, edge.getReverse(carMaxSpeedEnc), .1);
 
         edge = edge.detach(true);
-        assertEquals(-1, encoder.getMaxspeed(edge, motorVehicleInt, false), .1);
-        assertEquals(10, encoder.getMaxspeed(edge, motorVehicleInt, true), .1);
+        assertEquals(Double.POSITIVE_INFINITY, edge.get(carMaxSpeedEnc), .1);
+        assertEquals(10, edge.getReverse(carMaxSpeedEnc), .1);
     }
 
     @Test
@@ -249,88 +267,91 @@ public void setAccess() {
         Graph graph = new GraphBuilder(encodingManager).create();
         EdgeIteratorState edge = graph.edge(0, 1);
 
-        edge.setFlags(encoder.setAccess(edge.getFlags(), true, true));
-        assertTrue(encoder.isForward(edge, motorVehicleInt));
-        assertTrue(encoder.isBackward(edge, motorVehicleInt));
+        edge.set(accessEnc, true).setReverse(accessEnc, true);
+        edge.setFlags(edge.getFlags());
+        assertTrue(edge.get(accessEnc));
+        assertTrue(edge.getReverse(accessEnc));
 
-        edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-        assertTrue(encoder.isForward(edge, motorVehicleInt));
-        assertFalse(encoder.isBackward(edge, motorVehicleInt));
+        edge.set(accessEnc, true).setReverse(accessEnc, false);
+        edge.setFlags(edge.getFlags());
+        assertTrue(edge.get(accessEnc));
+        assertFalse(edge.getReverse(accessEnc));
 
         edge = edge.detach(true);
-        assertFalse(encoder.isForward(edge, motorVehicleInt));
-        assertTrue(encoder.isBackward(edge, motorVehicleInt));
+        assertFalse(edge.get(accessEnc));
+        assertTrue(edge.getReverse(accessEnc));
         edge = edge.detach(true);
-        assertTrue(encoder.isForward(edge, motorVehicleInt));
-        assertFalse(encoder.isBackward(edge, motorVehicleInt));
+        assertTrue(edge.get(accessEnc));
+        assertFalse(edge.getReverse(accessEnc));
 
-        edge.setFlags(encoder.setAccess(edge.getFlags(), false, false));
-        assertFalse(encoder.isForward(edge, motorVehicleInt));
-        assertFalse(encoder.isBackward(edge, motorVehicleInt));
+        edge.set(accessEnc, false).setReverse(accessEnc, false);
+        edge.setFlags(edge.getFlags());
+        assertFalse(edge.get(accessEnc));
+        assertFalse(edge.getReverse(accessEnc));
     }
 
     @Test
     public void acceptWay() {
         ReaderWay osmWay = new ReaderWay(0);
         osmWay.setTag("highway", "primary");
-        assertTrue(encoder.acceptWay(osmWay) != 0);
+        assertTrue(encoder.getAccess(osmWay).isWay());
 
         // important to filter out illegal highways to reduce the number of edges before adding them to the graph
         osmWay.setTag("highway", "building");
-        assertTrue(encoder.acceptWay(osmWay) == 0);
+        assertTrue(encoder.getAccess(osmWay).canSkip());
     }
 
     @Test
     public void stringToMeter() {
-        assertEquals(1.5, DataFlagEncoder.stringToMeter("1.5"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToMeter("1.5m"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToMeter("1.5 m"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToMeter("1.5   m"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToMeter("1.5 meter"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToMeter("4 ft 11 in"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToMeter("4'11''"), DELTA);
+        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5"), DELTA);
+        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5m"), DELTA);
+        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5 m"), DELTA);
+        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5   m"), DELTA);
+        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("1.5 meter"), DELTA);
+        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("4 ft 11 in"), DELTA);
+        assertEquals(1.5, OSMMaxWidthParser.stringToMeter("4'11''"), DELTA);
 
 
-        assertEquals(3, DataFlagEncoder.stringToMeter("3 m."), DELTA);
-        assertEquals(3, DataFlagEncoder.stringToMeter("3meters"), DELTA);
-        assertEquals(0.8 * 3, DataFlagEncoder.stringToMeter("~3"), DELTA);
-        assertEquals(3 * 0.8, DataFlagEncoder.stringToMeter("3 m approx"), DELTA);
+        assertEquals(3, OSMMaxWidthParser.stringToMeter("3 m."), DELTA);
+        assertEquals(3, OSMMaxWidthParser.stringToMeter("3meters"), DELTA);
+        assertEquals(0.8 * 3, OSMMaxWidthParser.stringToMeter("~3"), DELTA);
+        assertEquals(3 * 0.8, OSMMaxWidthParser.stringToMeter("3 m approx"), DELTA);
 
         // 2.743 + 0.178
-        assertEquals(2.921, DataFlagEncoder.stringToMeter("9 ft 7in"), DELTA);
-        assertEquals(2.921, DataFlagEncoder.stringToMeter("9'7\""), DELTA);
-        assertEquals(2.921, DataFlagEncoder.stringToMeter("9'7''"), DELTA);
-        assertEquals(2.921, DataFlagEncoder.stringToMeter("9' 7\""), DELTA);
+        assertEquals(2.921, OSMMaxWidthParser.stringToMeter("9 ft 7in"), DELTA);
+        assertEquals(2.921, OSMMaxWidthParser.stringToMeter("9'7\""), DELTA);
+        assertEquals(2.921, OSMMaxWidthParser.stringToMeter("9'7''"), DELTA);
+        assertEquals(2.921, OSMMaxWidthParser.stringToMeter("9' 7\""), DELTA);
 
-        assertEquals(2.743, DataFlagEncoder.stringToMeter("9'"), DELTA);
-        assertEquals(2.743, DataFlagEncoder.stringToMeter("9 feet"), DELTA);
+        assertEquals(2.743, OSMMaxWidthParser.stringToMeter("9'"), DELTA);
+        assertEquals(2.743, OSMMaxWidthParser.stringToMeter("9 feet"), DELTA);
     }
 
     @Test(expected = NumberFormatException.class)
     public void stringToMeterException() {
         // Unexpected values
-        DataFlagEncoder.stringToMeter("height limit 1.5m");
+        OSMMaxWidthParser.stringToMeter("height limit 1.5m");
     }
 
     @Test
     public void stringToTons() {
-        assertEquals(1.5, DataFlagEncoder.stringToTons("1.5"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToTons("1.5 t"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToTons("1.5   t"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToTons("1.5 tons"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToTons("1.5 ton"), DELTA);
-        assertEquals(1.5, DataFlagEncoder.stringToTons("3306.9 lbs"), DELTA);
-        assertEquals(3, DataFlagEncoder.stringToTons("3 T"), DELTA);
-        assertEquals(3, DataFlagEncoder.stringToTons("3ton"), DELTA);
+        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5"), DELTA);
+        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5 t"), DELTA);
+        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5   t"), DELTA);
+        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5 tons"), DELTA);
+        assertEquals(1.5, OSMMaxWeightParser.stringToTons("1.5 ton"), DELTA);
+        assertEquals(1.5, OSMMaxWeightParser.stringToTons("3306.9 lbs"), DELTA);
+        assertEquals(3, OSMMaxWeightParser.stringToTons("3 T"), DELTA);
+        assertEquals(3, OSMMaxWeightParser.stringToTons("3ton"), DELTA);
 
         // maximum gross weight
-        assertEquals(6, DataFlagEncoder.stringToTons("6t mgw"), DELTA);
+        assertEquals(6, OSMMaxWeightParser.stringToTons("6t mgw"), DELTA);
     }
 
     @Test(expected = NumberFormatException.class)
     public void stringToTonsException() {
         // Unexpected values
-        DataFlagEncoder.stringToTons("weight limit 1.5t");
+        OSMMaxWeightParser.stringToTons("weight limit 1.5t");
     }
 
     @Test
@@ -363,6 +384,11 @@ public int getSpatialId(SpatialRule rule) {
                 }
             }
 
+            @Override
+            public SpatialRule getSpatialRule(int spatialId) {
+                return SpatialRule.EMPTY;
+            }
+
             @Override
             public int size() {
                 return 2;
@@ -374,50 +400,48 @@ public BBox getBounds() {
             }
         };
 
-        DataFlagEncoder encoder = new DataFlagEncoder(new PMap());
-        encoder.setSpatialRuleLookup(index);
-        EncodingManager em = new EncodingManager(encoder);
+        DataFlagEncoder tmpEncoder = new DataFlagEncoder(new PMap());
+        EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(4).add(new SpatialRuleParser(index))).add(tmpEncoder).build();
+        IntEncodedValue countrySpatialIdEnc = em.getIntEncodedValue(Country.KEY);
+        EnumEncodedValue<RoadAccess> tmpRoadAccessEnc = em.getEnumEncodedValue(RoadAccess.KEY, RoadAccess.class);
+        DecimalEncodedValue tmpCarMaxSpeedEnc = em.getDecimalEncodedValue(MaxSpeed.KEY);
+
+        Graph graph = new GraphBuilder(em).create();
+        EdgeIteratorState e1 = graph.edge(0, 1, 1, true);
+        EdgeIteratorState e2 = graph.edge(0, 2, 1, true);
+        EdgeIteratorState e3 = graph.edge(0, 3, 1, true);
+        EdgeIteratorState e4 = graph.edge(0, 4, 1, true);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, -0.01, -0.01);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.01, 0.01);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, -0.01, -0.01);
 
         ReaderWay way = new ReaderWay(27l);
         way.setTag("highway", "track");
         way.setTag("estimated_center", new GHPoint(0.005, 0.005));
+        e1.setFlags(em.handleWayTags(way, map, 0));
+        assertEquals(RoadAccess.DESTINATION, e1.get(tmpRoadAccessEnc));
 
         ReaderWay way2 = new ReaderWay(28l);
         way2.setTag("highway", "track");
         way2.setTag("estimated_center", new GHPoint(-0.005, -0.005));
+        e2.setFlags(em.handleWayTags(way2, map, 0));
+        assertEquals(RoadAccess.YES, e2.get(tmpRoadAccessEnc));
+
+        assertEquals(index.getSpatialId(new GermanySpatialRule()), e1.get(countrySpatialIdEnc));
+        assertEquals(index.getSpatialId(SpatialRule.EMPTY), e2.get(countrySpatialIdEnc));
 
         ReaderWay livingStreet = new ReaderWay(29l);
         livingStreet.setTag("highway", "living_street");
         livingStreet.setTag("estimated_center", new GHPoint(0.005, 0.005));
+        e3.setFlags(em.handleWayTags(livingStreet, map, 0));
+        assertEquals(5, e3.get(tmpCarMaxSpeedEnc), .1);
 
         ReaderWay livingStreet2 = new ReaderWay(30l);
         livingStreet2.setTag("highway", "living_street");
         livingStreet2.setTag("estimated_center", new GHPoint(-0.005, -0.005));
-
-        Graph graph = new GraphBuilder(em).create();
-        EdgeIteratorState e1 = graph.edge(0, 1, 1, true);
-        EdgeIteratorState e2 = graph.edge(0, 2, 1, true);
-        EdgeIteratorState e3 = graph.edge(0, 3, 1, true);
-        EdgeIteratorState e4 = graph.edge(0, 4, 1, true);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, -0.01, -0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.01, 0.01);
-        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, -0.01, -0.01);
-
-        e1.setFlags(encoder.handleWayTags(way, 1, 0));
-        e2.setFlags(encoder.handleWayTags(way2, 1, 0));
-        e3.setFlags(encoder.handleWayTags(livingStreet, 1, 0));
-        e4.setFlags(encoder.handleWayTags(livingStreet2, 1, 0));
-
-        assertEquals(index.getSpatialId(new GermanySpatialRule()), encoder.getSpatialId(e1.getFlags()));
-        assertEquals(index.getSpatialId(SpatialRule.EMPTY), encoder.getSpatialId(e2.getFlags()));
-
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, encoder.getAccessValue(e1.getFlags()));
-        assertEquals(AccessValue.ACCESSIBLE, encoder.getAccessValue(e2.getFlags()));
-
-        assertEquals(5, encoder.getMaxspeed(e3, -1, false), .1);
-        assertEquals(-1, encoder.getMaxspeed(e4, -1, false), .1);
+        e4.setFlags(em.handleWayTags(livingStreet2, map, 0));
+        assertEquals(MaxSpeed.UNSET_SPEED, e4.get(tmpCarMaxSpeedEnc), .1);
     }
-
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/DefaultEdgeFilterTest.java b/core/src/test/java/com/graphhopper/routing/util/DefaultEdgeFilterTest.java
new file mode 100644
index 0000000000..cc96455848
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/DefaultEdgeFilterTest.java
@@ -0,0 +1,77 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import com.carrotsearch.hppc.IntHashSet;
+import com.carrotsearch.hppc.IntSet;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.CHEdgeExplorer;
+import com.graphhopper.util.CHEdgeIterator;
+import com.graphhopper.util.CHEdgeIteratorState;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class DefaultEdgeFilterTest {
+    private final CarFlagEncoder encoder = new CarFlagEncoder();
+    private final EncodingManager encodingManager = EncodingManager.create(encoder);
+    private final Weighting weighting = new ShortestWeighting(encoder);
+    private final GraphHopperStorage graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(true).create();
+    private final CHGraph chGraph = graph.getCHGraph();
+
+    @Test
+    public void testAccept_fwdLoopShortcut_acceptedByInExplorer() {
+        // 0-1
+        //  \|
+        //   2
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 2, false);
+        graph.edge(2, 0, 3, false);
+        graph.freeze();
+        // add loop shortcut in 'fwd' direction
+        addShortcut(chGraph, 0, 0, true, 0, 2);
+        CHEdgeExplorer outExplorer = chGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder));
+        CHEdgeExplorer inExplorer = chGraph.createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder));
+
+        IntSet inEdges = new IntHashSet();
+        IntSet outEdges = new IntHashSet();
+        CHEdgeIterator outIter = outExplorer.setBaseNode(0);
+        while (outIter.next()) {
+            outEdges.add(outIter.getEdge());
+        }
+        CHEdgeIterator inIter = inExplorer.setBaseNode(0);
+        while (inIter.next()) {
+            inEdges.add(inIter.getEdge());
+        }
+        // the loop should be accepted by in- and outExplorers
+        assertEquals("Wrong outgoing edges", IntHashSet.from(0, 3), outEdges);
+        assertEquals("Wrong incoming edges", IntHashSet.from(2, 3), inEdges);
+    }
+
+    private void addShortcut(CHGraph chGraph, int from, int to, boolean fwd, int firstOrigEdge, int lastOrigEdge) {
+        CHEdgeIteratorState shortcut = chGraph.shortcut(from, to);
+        shortcut.setFlagsAndWeight(fwd ? PrepareEncoder.getScFwdDir() : PrepareEncoder.getScBwdDir(), 0);
+        shortcut.setFirstAndLastOrigEdges(firstOrigEdge, lastOrigEdge);
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
deleted file mode 100644
index e2bdd186fa..0000000000
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedDoubleValueTest.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing.util;
-
-import com.graphhopper.reader.ReaderWay;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-
-/**
- * @author Peter Karich
- */
-public class EncodedDoubleValueTest {
-    @Test
-    public void testSetDoubleValue() {
-        EncodedDoubleValue instance = new EncodedDoubleValue("test", 6, 10, 0.01, 5, 10);
-        assertEquals(10.12, instance.getDoubleValue(instance.setDoubleValue(0, 10.12)), 1e-4);
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testIllegalFactorMaxValueCombination() {
-        new EncodedDoubleValue("illegalcombination", 6, 2, 2, 0, 3);
-    }
-
-    @Test
-    public void testMaxValue() {
-        EncodedDoubleValue instance1 = new EncodedDoubleValue("test1", 0, 8, 0.5, 60, 100);
-        long flags = instance1.setDoubleValue(0, instance1.getMaxValue());
-        assertEquals(100, instance1.getDoubleValue(flags), 1e-1);
-
-        CarFlagEncoder carEncoder = new CarFlagEncoder(10, 0.5, 0);
-        new EncodingManager(carEncoder);
-        ReaderWay way = new ReaderWay(1);
-        way.setTag("highway", "motorway_link");
-        way.setTag("maxspeed", "70 mph");
-        flags = carEncoder.handleWayTags(way, 1, 0);
-
-        // double speed = AbstractFlagEncoder.parseSpeed("70 mph");
-        flags = carEncoder.reverseFlags(flags);
-        assertEquals(101.5, carEncoder.getSpeed(flags), 1e-1);
-    }
-
-    @Test
-    public void testUnsignedRightShift_issue417() {
-        EncodedDoubleValue speedEncoder = new EncodedDoubleValue("Speed", 56, 8, 1, 30, 255);
-        Long flags = -72057594037927936L;
-        assertEquals(255, speedEncoder.getDoubleValue(flags), 0.01);
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodedValueOldTest.java
similarity index 61%
rename from core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
rename to core/src/test/java/com/graphhopper/routing/util/EncodedValueOldTest.java
index a7713c4684..4a479bc7f4 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodedValueTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodedValueOldTest.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing.util;
 
+import com.graphhopper.storage.IntsRef;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -24,25 +25,17 @@
 /**
  * @author Peter Karich
  */
-public class EncodedValueTest {
+public class EncodedValueOldTest {
     @Test
     public void testSetValue() {
-        EncodedValue instance = new EncodedValue("test", 6, 4, 1, 5, 10);
+        EncodedValueOld instance = new EncodedValueOld("test", 6, 4, 1, 5, 10);
         assertEquals(10, instance.getValue(instance.setValue(0, 10)));
 
-        instance = new EncodedValue("test", 0, 4, 1, 5, 10);
+        instance = new EncodedValueOld("test", 0, 4, 1, 5, 10);
         assertEquals(10, instance.getValue(instance.setValue(0, 10)));
 
-        instance = new EncodedValue("test", 0, 4, 1, 5, 10);
-        assertEquals(5, instance.getValue(instance.setDefaultValue(0)));
-    }
-
-    @Test
-    public void testSwap() {
-        EncodedValue instance1 = new EncodedValue("test1", 0, 10, 1, 5, 1000);
-        EncodedValue instance2 = new EncodedValue("test2", 10, 10, 1, 5, 1000);
-        long flags = instance2.setValue(instance1.setValue(0, 13), 874);
-        long swappedFlags = instance1.setValue(instance2.setValue(0, 13), 874);
-        assertEquals(swappedFlags, instance1.swap(flags, instance2));
+        instance = new EncodedValueOld("test", 0, 4, 1, 5, 10);
+        long flags = instance.setDefaultValue(0);
+        assertEquals(5, instance.getValue(flags));
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
index 5057eabbaa..d12f3922f0 100644
--- a/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/EncodingManagerTest.java
@@ -19,11 +19,11 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.routing.weighting.PriorityWeighting;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.Roundabout;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.BitUtil;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 
 import static org.junit.Assert.*;
 
@@ -31,12 +31,10 @@
  * @author Peter Karich
  */
 public class EncodingManagerTest {
-    @Rule
-    public ExpectedException thrown = ExpectedException.none();
 
     @Test
     public void testCompatibility() {
-        EncodingManager manager = new EncodingManager("car,bike,foot");
+        EncodingManager manager = EncodingManager.create("car,bike,foot");
         BikeFlagEncoder bike = (BikeFlagEncoder) manager.getEncoder("bike");
         CarFlagEncoder car = (CarFlagEncoder) manager.getEncoder("car");
         FootFlagEncoder foot = (FootFlagEncoder) manager.getEncoder("foot");
@@ -46,50 +44,45 @@ public void testCompatibility() {
         assertNotEquals(car.hashCode(), foot.hashCode());
 
         FootFlagEncoder foot2 = new FootFlagEncoder();
-        EncodingManager manager2 = new EncodingManager(foot2);
+        EncodingManager.create(foot2);
         assertNotEquals(foot, foot2);
         assertNotEquals(foot.hashCode(), foot2.hashCode());
 
         FootFlagEncoder foot3 = new FootFlagEncoder();
-        EncodingManager manager3 = new EncodingManager(foot3);
+        EncodingManager.create(foot3);
         assertEquals(foot3, foot2);
         assertEquals(foot3.hashCode(), foot2.hashCode());
 
         try {
-            new EncodingManager("car,car");
-            assertTrue("do not allow duplicate flag encoders", false);
+            EncodingManager.create("car,car");
+            fail("there should have been an exception, do not allow duplicate flag encoders");
         } catch (Exception ex) {
+            // ok
         }
     }
 
     @Test
     public void testEncoderAcceptNoException() {
-        EncodingManager manager = new EncodingManager("car");
-        assertTrue(manager.supports("car"));
-        assertFalse(manager.supports("foot"));
-    }
-
-    @Test
-    public void testEncoderWithWrongVersionIsRejected() {
-        thrown.expect(IllegalArgumentException.class);
-        EncodingManager manager = new EncodingManager("car|version=0");
+        EncodingManager manager = EncodingManager.create("car");
+        assertTrue(manager.hasEncoder("car"));
+        assertFalse(manager.hasEncoder("foot"));
     }
 
     @Test
     public void testWrongEncoders() {
         try {
             FootFlagEncoder foot = new FootFlagEncoder();
-            new EncodingManager(foot, foot);
-            assertTrue(false);
+            EncodingManager.create(foot, foot);
+            fail("There should have been an exception");
         } catch (Exception ex) {
             assertEquals("You must not register a FlagEncoder (foot) twice!", ex.getMessage());
         }
 
         try {
-            new EncodingManager(new FootFlagEncoder(), new CarFlagEncoder(), new BikeFlagEncoder(), new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder());
-            assertTrue(false);
+            EncodingManager.create(new FootFlagEncoder(), new CarFlagEncoder(), new BikeFlagEncoder(), new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder());
+            fail("There should have been an exception");
         } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoders are requesting 44 bits, more than 32 bits of way flags. Decrease the"));
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoders are requesting 36 bits, more than 32 bits of edge flags"));
         }
     }
 
@@ -112,24 +105,24 @@ protected String getPropertiesString() {
             }
 
             @Override
-            public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
+            public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
                 return 0;
             }
 
             @Override
-            public long acceptWay(ReaderWay way) {
-                return 0;
+            public EncodingManager.Access getAccess(ReaderWay way) {
+                return EncodingManager.Access.WAY;
             }
 
             @Override
-            public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
-                return 0;
+            public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access accept, long relationFlags) {
+                return edgeFlags;
             }
         };
 
-        EncodingManager subject = new EncodingManager(encoder);
+        EncodingManager subject = EncodingManager.create(encoder);
 
-        assertEquals("new_encoder|my_properties|version=10", subject.toDetailsString());
+        assertEquals("new_encoder|my_properties|version=10", subject.toFlagEncodersAsString());
     }
 
     @Test
@@ -142,12 +135,12 @@ public void testCombineRelations() {
         BikeFlagEncoder lessRelationCodes = new BikeFlagEncoder() {
             @Override
             public int defineRelationBits(int index, int shift) {
-                relationCodeEncoder = new EncodedValue("RelationCode2", shift, 2, 1, 0, 3);
+                relationCodeEncoder = new EncodedValueOld("RelationCode2", shift, 2, 1, 0, 3);
                 return shift + 2;
             }
 
             @Override
-            public long handleRelationTags(ReaderRelation relation, long oldRelFlags) {
+            public long handleRelationTags(long oldRelFlags, ReaderRelation relation) {
                 if (relation.hasTag("route", "bicycle"))
                     return relationCodeEncoder.setValue(0, 2);
                 return relationCodeEncoder.setValue(0, 0);
@@ -163,17 +156,18 @@ public String toString() {
                 return "less_relations_bits";
             }
         };
-        EncodingManager manager = new EncodingManager(defaultBike, lessRelationCodes);
+        EncodingManager manager = EncodingManager.create(defaultBike, lessRelationCodes);
 
         // relation code is PREFER
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
-        long relFlags = manager.handleRelationTags(osmRel, 0);
-        long allow = defaultBike.acceptBit | lessRelationCodes.acceptBit;
-        long flags = manager.handleWayTags(osmWay, allow, relFlags);
+        long relFlags = manager.handleRelationTags(0, osmRel);
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        manager.acceptWay(osmWay, map);
+        IntsRef edgeFlags = manager.handleWayTags(osmWay, map, relFlags);
 
-        assertTrue(defaultBike.getDouble(flags, PriorityWeighting.KEY)
-                > lessRelationCodes.getDouble(flags, PriorityWeighting.KEY));
+        assertTrue(defaultBike.relationCodeEncoder.getValue(edgeFlags.ints[0])
+                > lessRelationCodes.relationCodeEncoder.getValue(edgeFlags.ints[0]));
     }
 
     @Test
@@ -186,24 +180,25 @@ public void testMixBikeTypesAndRelationCombination() {
 
         BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
         MountainBikeFlagEncoder mtbEncoder = new MountainBikeFlagEncoder();
-        EncodingManager manager = new EncodingManager(bikeEncoder, mtbEncoder);
+        EncodingManager manager = EncodingManager.create(bikeEncoder, mtbEncoder);
 
         // relation code for network rcn is VERY_NICE for bike and PREFER for mountainbike
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "rcn");
-        long relFlags = manager.handleRelationTags(osmRel, 0);
-        long allow = bikeEncoder.acceptBit | mtbEncoder.acceptBit;
-        long flags = manager.handleWayTags(osmWay, allow, relFlags);
+        long relFlags = manager.handleRelationTags(0, osmRel);
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        manager.acceptWay(osmWay, map);
+        IntsRef flags = manager.handleWayTags(osmWay, map, relFlags);
 
         // bike: uninfluenced speed for grade but via network => VERY_NICE                
         // mtb: uninfluenced speed only PREFER
-        assertTrue(bikeEncoder.getDouble(flags, PriorityWeighting.KEY)
-                > mtbEncoder.getDouble(flags, PriorityWeighting.KEY));
+        assertTrue(bikeEncoder.relationCodeEncoder.getValue(flags.ints[0])
+                > mtbEncoder.relationCodeEncoder.getValue(flags.ints[0]));
     }
 
     public void testFullBitMask() {
         BitUtil bitUtil = BitUtil.LITTLE;
-        EncodingManager manager = new EncodingManager("car,foot");
+        EncodingManager manager = EncodingManager.create("car,foot");
         AbstractFlagEncoder carr = (AbstractFlagEncoder) manager.getEncoder("car");
         assertTrue(bitUtil.toBitString(carr.getNodeBitMask()).endsWith("00000000001111111"));
 
@@ -219,35 +214,38 @@ public void testFixWayName() {
 
     @Test
     public void testCompatibilityBug() {
-        EncodingManager manager2 = new EncodingManager(FlagEncoderFactory.DEFAULT, "bike2", 8);
+        EncodingManager manager2 = EncodingManager.create(new DefaultFlagEncoderFactory(), "bike2", 8);
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "footway");
         osmWay.setTag("name", "test");
 
         BikeFlagEncoder singleBikeEnc = (BikeFlagEncoder) manager2.getEncoder("bike2");
-        long flags = manager2.handleWayTags(osmWay, singleBikeEnc.acceptBit, 0);
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        manager2.acceptWay(osmWay, map);
+        IntsRef flags = manager2.handleWayTags(osmWay, map, 0);
         double singleSpeed = singleBikeEnc.getSpeed(flags);
         assertEquals(4, singleSpeed, 1e-3);
-        assertEquals(singleSpeed, singleBikeEnc.getReverseSpeed(flags), 1e-3);
+        assertEquals(singleSpeed, singleBikeEnc.getSpeed(true, flags), 1e-3);
 
-        EncodingManager manager = new EncodingManager(FlagEncoderFactory.DEFAULT, "bike2,bike,foot", 8);
+        EncodingManager manager = EncodingManager.create(new DefaultFlagEncoderFactory(), "bike2,bike,foot", 8);
         FootFlagEncoder foot = (FootFlagEncoder) manager.getEncoder("foot");
         BikeFlagEncoder bike = (BikeFlagEncoder) manager.getEncoder("bike2");
 
-        long acceptBits = foot.acceptBit | bike.acceptBit;
-        flags = manager.handleWayTags(osmWay, acceptBits, 0);
+        map = new EncodingManager.AcceptWay();
+        manager.acceptWay(osmWay, map);
+        flags = manager.handleWayTags(osmWay, map, 0);
         assertEquals(singleSpeed, bike.getSpeed(flags), 1e-2);
-        assertEquals(singleSpeed, bike.getReverseSpeed(flags), 1e-2);
+        assertEquals(singleSpeed, bike.getSpeed(true, flags), 1e-2);
 
         assertEquals(5, foot.getSpeed(flags), 1e-2);
-        assertEquals(5, foot.getReverseSpeed(flags), 1e-2);
+        assertEquals(5, foot.getSpeed(true, flags), 1e-2);
     }
 
     @Test
     public void testSupportFords() {
         // 1) no encoder crossing fords
         String flagEncodersStr = "car,bike,foot";
-        EncodingManager manager = new EncodingManager(FlagEncoderFactory.DEFAULT, flagEncodersStr, 8);
+        EncodingManager manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr, 8);
 
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
@@ -255,7 +253,7 @@ public void testSupportFords() {
 
         // 2) two encoders crossing fords
         flagEncodersStr = "car,bike|block_fords=false,foot|block_fords=false";
-        manager = new EncodingManager(FlagEncoderFactory.DEFAULT, flagEncodersStr, 8);
+        manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr, 8);
 
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
         assertFalse(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
@@ -263,10 +261,43 @@ public void testSupportFords() {
 
         // 2) Try combined with another tag
         flagEncodersStr = "car|turn_costs=true|block_fords=true,bike,foot|block_fords=false";
-        manager = new EncodingManager(FlagEncoderFactory.DEFAULT, flagEncodersStr, 8);
+        manager = EncodingManager.create(new DefaultFlagEncoderFactory(), flagEncodersStr, 8);
 
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("car")).isBlockFords());
         assertTrue(((AbstractFlagEncoder) manager.getEncoder("bike")).isBlockFords());
         assertFalse(((AbstractFlagEncoder) manager.getEncoder("foot")).isBlockFords());
     }
+
+    @Test
+    public void testSharedEncodedValues() {
+        EncodingManager manager = EncodingManager.create("car,foot,bike,motorcycle,mtb", 8);
+
+        for (FlagEncoder tmp : manager.fetchEdgeEncoders()) {
+            AbstractFlagEncoder encoder = (AbstractFlagEncoder) tmp;
+            BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+            BooleanEncodedValue roundaboutEnc = manager.getBooleanEncodedValue(Roundabout.KEY);
+
+            ReaderWay way = new ReaderWay(1);
+            way.setTag("highway", "primary");
+            way.setTag("junction", "roundabout");
+            EncodingManager.AcceptWay aw = new EncodingManager.AcceptWay();
+            manager.acceptWay(way, aw);
+            IntsRef edgeFlags = manager.handleWayTags(way, aw, 0);
+            assertTrue(accessEnc.getBool(false, edgeFlags));
+            if (!encoder.toString().equals("foot"))
+                assertFalse(encoder.toString(), accessEnc.getBool(true, edgeFlags));
+            assertTrue(encoder.toString(), roundaboutEnc.getBool(false, edgeFlags));
+
+            way.clearTags();
+            way.setTag("highway", "tertiary");
+            way.setTag("junction", "circular");
+            aw = new EncodingManager.AcceptWay();
+            manager.acceptWay(way, aw);
+            edgeFlags = manager.handleWayTags(way, aw, 0);
+            assertTrue(accessEnc.getBool(false, edgeFlags));
+            if (!encoder.toString().equals("foot"))
+                assertFalse(encoder.toString(), accessEnc.getBool(true, edgeFlags));
+            assertTrue(encoder.toString(), roundaboutEnc.getBool(false, edgeFlags));
+        }
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
index 0dd1ec075a..1b74cbaa7b 100644
--- a/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/FootFlagEncoderTest.java
@@ -19,9 +19,13 @@
 
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import org.junit.Test;
@@ -35,46 +39,65 @@
  * @author Peter Karich
  */
 public class FootFlagEncoderTest {
-    private final EncodingManager encodingManager = new EncodingManager("car,bike,foot");
+    private final EncodingManager encodingManager = EncodingManager.create("car,bike,foot");
     private final FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("foot");
+    private final DecimalEncodedValue footAvSpeedEnc = footEncoder.getAverageSpeedEnc();
+    private final BooleanEncodedValue footAccessEnc = footEncoder.getAccessEnc();
+    private final DecimalEncodedValue carAvSpeedEnc = encodingManager.getEncoder("car").getAverageSpeedEnc();
+    private final BooleanEncodedValue carAccessEnc = encodingManager.getEncoder("car").getAccessEnc();
 
     @Test
     public void testGetSpeed() {
-        long fl = footEncoder.setProperties(10, true, true);
+        IntsRef fl = encodingManager.createEdgeFlags();
+        footAccessEnc.setBool(false, fl, true);
+        footAccessEnc.setBool(true, fl, true);
+        footAvSpeedEnc.setDecimal(false, fl, 10);
         assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
     }
 
     @Test
     public void testBasics() {
-        long fl = footEncoder.flagsDefault(true, true);
-        assertEquals(FootFlagEncoder.MEAN_SPEED, footEncoder.getSpeed(fl), 1e-1);
-
-        long fl1 = footEncoder.flagsDefault(true, false);
-        long fl2 = footEncoder.reverseFlags(fl1);
-        assertEquals(footEncoder.getSpeed(fl2), footEncoder.getSpeed(fl1), 1e-1);
+        IntsRef edgeFlags = encodingManager.createEdgeFlags();
+        footEncoder.flagsDefault(edgeFlags, true, true);
+        assertEquals(FootFlagEncoder.MEAN_SPEED, footEncoder.getSpeed(edgeFlags), 1e-1);
+
+        IntsRef ef1 = encodingManager.createEdgeFlags();
+        footEncoder.flagsDefault(ef1, true, false);
+        IntsRef ef2 = encodingManager.createEdgeFlags();
+        footEncoder.flagsDefault(ef2, false, true);
+        assertEquals(footAccessEnc.getBool(false, ef1), footAccessEnc.getBool(true, ef2));
+        assertEquals(footEncoder.getSpeed(ef1), footEncoder.getSpeed(ef1), 1e-1);
     }
 
     @Test
     public void testCombined() {
+        Graph g = new GraphBuilder(encodingManager).create();
         FlagEncoder carEncoder = encodingManager.getEncoder("car");
-        long fl = footEncoder.setProperties(10, true, true) | carEncoder.setProperties(100, true, false);
-        assertEquals(10, footEncoder.getSpeed(fl), 1e-1);
-        assertTrue(footEncoder.isForward(fl));
-        assertTrue(footEncoder.isBackward(fl));
-
-        assertEquals(100, carEncoder.getSpeed(fl), 1e-1);
-        assertTrue(carEncoder.isForward(fl));
-        assertFalse(carEncoder.isBackward(fl));
-
-        assertEquals(0, carEncoder.getSpeed(footEncoder.setProperties(10, true, true)), 1e-1);
+        EdgeIteratorState edge = g.edge(0, 1);
+        edge.set(footAvSpeedEnc, 10.0).set(footAccessEnc, true).setReverse(footAccessEnc, true);
+        edge.set(carAvSpeedEnc, 100.0).set(carAccessEnc, true).setReverse(carAccessEnc, false);
+
+        assertEquals(10, edge.get(footAvSpeedEnc), 1e-1);
+        assertTrue(edge.get(footAccessEnc));
+        assertTrue(edge.getReverse(footAccessEnc));
+
+        assertEquals(100, edge.get(carAvSpeedEnc), 1e-1);
+        assertTrue(edge.get(carAccessEnc));
+        assertFalse(edge.getReverse(carAccessEnc));
+
+        IntsRef raw = encodingManager.createEdgeFlags();
+        footAvSpeedEnc.setDecimal(false, raw, 10);
+        footAccessEnc.setBool(false, raw, true);
+        footAccessEnc.setBool(true, raw, true);
+        assertEquals(0, carAvSpeedEnc.getDecimal(false, raw), 1e-1);
     }
 
     @Test
     public void testGraph() {
         Graph g = new GraphBuilder(encodingManager).create();
-        g.edge(0, 1).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
-        g.edge(0, 2).setDistance(10).setFlags(footEncoder.setProperties(5, true, true));
-        g.edge(1, 3).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
+        g.edge(0, 1).setDistance(10).set(footAvSpeedEnc, 10.0).set(footAccessEnc, true).setReverse(footAccessEnc, true);
+        g.edge(0, 2).setDistance(10).set(footAvSpeedEnc, 5.0).set(footAccessEnc, true).setReverse(footAccessEnc, true);
+        g.edge(1, 3).setDistance(10).set(footAvSpeedEnc, 10.0).set(footAccessEnc, true).setReverse(footAccessEnc, true);
         EdgeExplorer out = g.createEdgeExplorer(DefaultEdgeFilter.outEdges(footEncoder));
         assertEquals(GHUtility.asSet(1, 2), GHUtility.getNeighbors(out.setBaseNode(0)));
         assertEquals(GHUtility.asSet(0, 3), GHUtility.getNeighbors(out.setBaseNode(1)));
@@ -87,126 +110,151 @@ public void testAccess() {
 
         way.setTag("highway", "motorway");
         way.setTag("sidewalk", "yes");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
         way.setTag("sidewalk", "left");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
 
         way.setTag("sidewalk", "none");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "tertiary");
         way.setTag("sidewalk", "left");
         way.setTag("access", "private");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
         way.clearTags();
 
         way.setTag("highway", "pedestrian");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
 
         way.setTag("highway", "footway");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
+
+        way.setTag("highway", "platform");
+        assertTrue(footEncoder.getAccess(way).isWay());
 
         way.setTag("highway", "motorway");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
 
         way.setTag("highway", "path");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
 
         way.setTag("bicycle", "official");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
         way.setTag("foot", "no");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
 
         way.setTag("foot", "official");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "no");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
         way.setTag("foot", "yes");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("vehicle", "no");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
         way.setTag("foot", "no");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "tertiary");
         way.setTag("motorroad", "yes");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "cycleway");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
         way.setTag("foot", "no");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
         way.setTag("access", "yes");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("foot", "yes");
         way.setTag("access", "no");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("ford", "yes");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
         way.setTag("foot", "yes");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("route", "ferry");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isFerry());
         way.setTag("foot", "no");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
+
+        // #1562, test if ferry route with foot
+        way.clearTags();
+        way.setTag("route", "ferry");
+        way.setTag("foot", "yes");
+        assertTrue(footEncoder.getAccess(way).isFerry());
+
+        way.setTag("foot", "designated");
+        assertTrue(footEncoder.getAccess(way).isFerry());
+
+        way.setTag("foot", "official");
+        assertTrue(footEncoder.getAccess(way).isFerry());
+
+        way.setTag("foot", "permissive");
+        assertTrue(footEncoder.getAccess(way).isFerry());
+
+        way.setTag("foot", "no");
+        assertTrue(footEncoder.getAccess(way).canSkip());
+
+        way.setTag("foot", "designated");
+        way.setTag("access", "private");
+        assertTrue(footEncoder.getAccess(way).canSkip());
 
         DateFormat simpleDateFormat = Helper.createFormatter("yyyy MMM dd");
 
         way.clearTags();
         way.setTag("highway", "footway");
         way.setTag("access:conditional", "no @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertFalse(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "footway");
         way.setTag("access", "no");
         way.setTag("access:conditional", "yes @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertTrue(footEncoder.acceptWay(way) > 0);
+        assertTrue(footEncoder.getAccess(way).isWay());
     }
 
     @Test
     public void testRailPlatformIssue366() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("railway", "platform");
-        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertNotEquals(0, flags);
+        IntsRef flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
+        assertNotEquals(0, flags.ints[0]);
 
         way.clearTags();
         way.setTag("highway", "track");
         way.setTag("railway", "platform");
-        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertNotEquals(0, flags);
+        flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
+        assertNotEquals(0, flags.ints[0]);
 
         way.clearTags();
         // only tram, no highway => no access
         way.setTag("railway", "tram");
-        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertEquals(0, flags);
+        flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
+        assertEquals(0, flags.ints[0]);
     }
 
     @Test
     public void testPier() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("man_made", "pier");
-        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertNotEquals(0, flags);
+        IntsRef flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
+        assertNotEquals(0, flags.ints[0]);
     }
 
     @Test
@@ -215,7 +263,7 @@ public void testFerrySpeed() {
         way.setTag("route", "ferry");
         // a bit longer than an hour
         way.setTag("duration:seconds", "4000");
-        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        IntsRef flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
         assertTrue(footEncoder.getSpeed(flags) > footEncoder.getMaxSpeed());
         assertEquals(20, footEncoder.getSpeed(flags), .1);
     }
@@ -224,16 +272,16 @@ public void testFerrySpeed() {
     public void testMixSpeedAndSafe() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "motorway");
-        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertEquals(0, flags);
+        IntsRef flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
+        assertEquals(0, flags.ints[0]);
 
         way.setTag("sidewalk", "yes");
-        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
         assertEquals(5, footEncoder.getSpeed(flags), 1e-1);
 
         way.clearTags();
         way.setTag("highway", "track");
-        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
         assertEquals(5, footEncoder.getSpeed(flags), 1e-1);
     }
 
@@ -293,12 +341,12 @@ public void testSlowHiking() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "track");
         way.setTag("sac_scale", "hiking");
-        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        IntsRef flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
         assertEquals(FootFlagEncoder.MEAN_SPEED, footEncoder.getSpeed(flags), 1e-1);
 
         way.setTag("highway", "track");
         way.setTag("sac_scale", "mountain_hiking");
-        flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
+        flags = footEncoder.handleWayTags(encodingManager.createEdgeFlags(), way, footEncoder.getAccess(way), 0);
         assertEquals(FootFlagEncoder.SLOW_SPEED, footEncoder.getSpeed(flags), 1e-1);
     }
 
@@ -360,23 +408,6 @@ public void testBarrierAccess() {
     }
 
     @Test
-    public void handleWayTagsRoundabout() {
-        ReaderWay way = new ReaderWay(1);
-        way.setTag("junction", "roundabout");
-        way.setTag("highway", "tertiary");
-        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
-    }
-
-    @Test
-    public void handleWayTagsCircularJunction() {
-        ReaderWay way = new ReaderWay(1);
-        way.setTag("junction", "circular");
-        way.setTag("highway", "tertiary");
-        long flags = footEncoder.handleWayTags(way, footEncoder.acceptWay(way), 0);
-        assertTrue(footEncoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
-    }
-
     public void testFord() {
         // by default deny access through fords!
         ReaderNode node = new ReaderNode(1, -1, -1);
@@ -402,4 +433,45 @@ public void testFord() {
         node.setTag("ford", "yes");
         assertTrue(footEncoder.handleNodeTags(node) == 0);
     }
+
+    @Test
+    public void testBlockByDefault() {
+        FootFlagEncoder tmpFootEncoder = new FootFlagEncoder();
+        EncodingManager.create(tmpFootEncoder);
+
+        ReaderNode node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        // potential barriers are no barrier by default
+        assertTrue(tmpFootEncoder.handleNodeTags(node) == 0);
+        node.setTag("access", "no");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+
+        // absolute barriers always block
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "fence");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+        node.setTag("barrier", "fence");
+        node.setTag("access", "yes");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+
+        // Now let's block potential barriers per default (if no other access tag exists)
+        tmpFootEncoder.setBlockByDefault(true);
+
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "gate");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+        node.setTag("access", "yes");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) == 0);
+
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "fence");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) > 0);
+
+        // Let's stop block potential barriers to test if barrier:cattle_grid is non blocking
+        tmpFootEncoder.setBlockByDefault(false);
+
+        node = new ReaderNode(1, -1, -1);
+        node.setTag("barrier", "cattle_grid");
+        assertTrue(tmpFootEncoder.handleNodeTags(node) == 0);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/HikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/HikeFlagEncoderTest.java
index 78215d07ae..23a5164da7 100644
--- a/core/src/test/java/com/graphhopper/routing/util/HikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/HikeFlagEncoderTest.java
@@ -20,16 +20,15 @@
 import com.graphhopper.reader.ReaderWay;
 import org.junit.Test;
 
-import java.io.Reader;
-
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
  */
 public class HikeFlagEncoderTest {
-    private final EncodingManager encodingManager = new EncodingManager("car,hike");
+    private final EncodingManager encodingManager = EncodingManager.create("car,hike");
     private final HikeFlagEncoder hikeEncoder = (HikeFlagEncoder) encodingManager.getEncoder("hike");
 
     @Test
@@ -39,7 +38,7 @@ public void testAccess() {
         way.setTag("access", "no");
         way.setTag("sidewalk", "both");
         way.setTag("foot", "no");
-        assertFalse(hikeEncoder.acceptWay(way) > 0);
+        assertTrue(hikeEncoder.getAccess(way).canSkip());
     }
 
     @Test
diff --git a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
index 5ef4485897..33a0b77399 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MotorcycleFlagEncoderTest.java
@@ -18,6 +18,8 @@
 package com.graphhopper.routing.util;
 
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.GHUtility;
@@ -33,8 +35,9 @@
  * @author Peter Karich
  */
 public class MotorcycleFlagEncoderTest {
-    private final EncodingManager em = new EncodingManager("motorcycle,foot");
+    private final EncodingManager em = EncodingManager.create("motorcycle,foot");
     private final MotorcycleFlagEncoder encoder = (MotorcycleFlagEncoder) em.getEncoder("motorcycle");
+    private final BooleanEncodedValue accessEnc = encoder.getAccessEnc();
 
     private Graph initExampleGraph() {
         GraphHopperStorage gs = new GraphHopperStorage(new RAMDirectory(), em, true, new GraphExtension.NoOpExtension()).create(1000);
@@ -46,138 +49,107 @@ private Graph initExampleGraph() {
                 setWayGeometry(Helper.createPointList3D(51.1, 12.0011, 49, 51.1, 12.0015, 55));
         edge.setDistance(100);
 
-        edge.setFlags(encoder.setReverseSpeed(encoder.setProperties(10, true, true), 15));
+        edge.set(accessEnc, true).setReverse(accessEnc, true).set(encoder.getAverageSpeedEnc(), 10.0).setReverse(encoder.getAverageSpeedEnc(), 15.0);
         return gs;
     }
 
     @Test
     public void testAccess() {
         ReaderWay way = new ReaderWay(1);
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("highway", "service");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
         way.setTag("access", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "track");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "delivery");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "unclassified");
         way.setTag("ford", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
         way.setTag("motorcycle", "yes");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.clearTags();
         way.setTag("route", "ferry");
-        assertTrue(encoder.acceptWay(way) > 0);
-        assertTrue(encoder.isFerry(encoder.acceptWay(way)));
+        assertTrue(encoder.getAccess(way).isFerry());
         way.setTag("motorcycle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("route", "ferry");
         way.setTag("foot", "yes");
-        assertFalse(encoder.acceptWay(way) > 0);
-        assertFalse(encoder.isFerry(encoder.acceptWay(way)));
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("access", "yes");
         way.setTag("motor_vehicle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "yes");
         way.setTag("motor_vehicle", "no");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("access", "emergency");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "service");
         way.setTag("motor_vehicle", "emergency");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         DateFormat simpleDateFormat = Helper.createFormatter("yyyy MMM dd");
 
         way.clearTags();
         way.setTag("highway", "road");
         way.setTag("access:conditional", "no @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertFalse(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.clearTags();
         way.setTag("highway", "road");
         way.setTag("access", "no");
         way.setTag("access:conditional", "yes @ (" + simpleDateFormat.format(new Date().getTime()) + ")");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
     }
 
     @Test
     public void testHandleWayTags() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
-        long flags = encoder.acceptWay(way);
-        assertTrue(flags > 0);
-        long result = encoder.handleWayTags(way, flags, 0);
-        assertEquals(20, encoder.getSpeed(result), .1);
-        assertEquals(20, encoder.getReverseSpeed(result), .1);
-    }
-
-    @Test
-    public void testRoundabout() {
-        long flags = encoder.setAccess(0, true, true);
-        long resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, true);
-        assertTrue(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
-        assertTrue(encoder.isForward(resFlags));
-        assertTrue(encoder.isBackward(resFlags));
-
-        resFlags = encoder.setBool(flags, FlagEncoder.K_ROUNDABOUT, false);
-        assertFalse(encoder.isBool(resFlags, FlagEncoder.K_ROUNDABOUT));
-        assertTrue(encoder.isForward(resFlags));
-        assertTrue(encoder.isBackward(resFlags));
-
-        ReaderWay way = new ReaderWay(1);
-        way.setTag("highway", "motorway");
-        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
-        assertFalse(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
-
-        way.setTag("junction", "roundabout");
-        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
-
-        way.clearTags();
-        way.setTag("highway", "motorway");
-        way.setTag("junction", "circular");
-        flags = encoder.handleWayTags(way, encoder.acceptBit, 0);
-        assertTrue(encoder.isForward(flags));
-        assertFalse(encoder.isBackward(flags));
-        assertTrue(encoder.isBool(flags, FlagEncoder.K_ROUNDABOUT));
+        assertTrue(encoder.getAccess(way).isWay());
+        IntsRef edgeFlags = encoder.handleWayTags(em.createEdgeFlags(), way, EncodingManager.Access.WAY, 0);
+        assertEquals(20, encoder.getSpeed(edgeFlags), .1);
+        assertEquals(20, encoder.getSpeed(true, edgeFlags), .1);
     }
 
     @Test
     public void testSetSpeed0_issue367() {
-        long flags = encoder.setProperties(10, true, true);
-        flags = encoder.setSpeed(flags, 0);
-
-        assertEquals(0, encoder.getSpeed(flags), .1);
-        assertEquals(10, encoder.getReverseSpeed(flags), .1);
-        assertFalse(encoder.isForward(flags));
-        assertTrue(encoder.isBackward(flags));
+        IntsRef edgeFlags = em.createEdgeFlags();
+        accessEnc.setBool(false, edgeFlags, true);
+        accessEnc.setBool(true, edgeFlags, true);
+        encoder.getAverageSpeedEnc().setDecimal(false, edgeFlags, 10);
+        encoder.getAverageSpeedEnc().setDecimal(true, edgeFlags, 10);
+
+        assertEquals(10, encoder.getAverageSpeedEnc().getDecimal(false, edgeFlags), .1);
+        assertEquals(10, encoder.getAverageSpeedEnc().getDecimal(true, edgeFlags), .1);
+
+        encoder.setSpeed(false, edgeFlags, 0);
+        assertEquals(0, encoder.getSpeed(edgeFlags), .1);
+        assertEquals(10, encoder.getSpeed(true, edgeFlags), .1);
+        assertFalse(accessEnc.getBool(false, edgeFlags));
+        assertTrue(accessEnc.getBool(true, edgeFlags));
     }
 
     @Test
@@ -195,10 +167,11 @@ private double getBendiness(EdgeIteratorState edge, double estimatedDistance) {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "primary");
         way.setTag("estimated_distance", estimatedDistance);
-        long includeWay = encoder.acceptWay(way);
-        long flags = encoder.handleWayTags(way, includeWay, 0l);
+        assertTrue(encoder.getAccess(way).isWay());
+        IntsRef flags = encoder.handleWayTags(em.createEdgeFlags(), way, EncodingManager.Access.WAY, 0);
         edge.setFlags(flags);
         encoder.applyWayTags(way, edge);
-        return encoder.getDouble(edge.getFlags(), MotorcycleFlagEncoder.CURVATURE_KEY);
+        DecimalEncodedValue curvatureEnc = encoder.getDecimalEncodedValue(EncodingManager.getKey(encoder, "curvature"));
+        return curvatureEnc.getDecimal(false, edge.getFlags());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
index b6ce5eaac0..aa54dcbdbc 100644
--- a/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/MountainBikeFlagEncoderTest.java
@@ -20,6 +20,8 @@
 import com.graphhopper.reader.ReaderNode;
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.GHUtility;
 import org.junit.Test;
 
 import static com.graphhopper.routing.util.PriorityCode.*;
@@ -28,13 +30,13 @@
 public class MountainBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester {
     @Override
     protected BikeCommonFlagEncoder createBikeEncoder() {
-        return (BikeCommonFlagEncoder) new EncodingManager("bike,mtb").getEncoder("mtb");
+        return new MountainBikeFlagEncoder();
     }
 
     @Test
     public void testGetSpeed() {
-        long result = encoder.setProperties(10, true, true);
-        assertEquals(10, encoder.getSpeed(result), 1e-1);
+        IntsRef intsRef = GHUtility.setProperties(encodingManager.createEdgeFlags(), encoder, 10, true, false);
+        assertEquals(10, encoder.getSpeed(intsRef), 1e-1);
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "primary");
         assertEquals(18, encoder.getSpeed(way));
@@ -86,17 +88,17 @@ public void testSacScale() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
         way.setTag("sac_scale", "hiking");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("highway", "service");
         way.setTag("sac_scale", "mountain_hiking");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("sac_scale", "alpine_hiking");
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         way.setTag("sac_scale", "demanding_alpine_hiking");
-        assertTrue(encoder.acceptWay(way) == 0);
+        assertTrue(encoder.getAccess(way).canSkip());
     }
 
     @Test
@@ -151,12 +153,11 @@ public void testHandleWayTags() {
     public void testHandleWayTagsInfluencedByRelation() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "track");
-        long allowed = encoder.acceptBit;
 
         ReaderRelation osmRel = new ReaderRelation(1);
-        long relFlags = encoder.handleRelationTags(osmRel, 0);
+        long relFlags = encoder.handleRelationTags(0, osmRel);
         // unchanged
-        long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        IntsRef flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(18, encoder.getSpeed(flags), 1e-1);
         assertPriority(PriorityCode.PREFER.getValue(), osmWay);
         assertEquals("small way, unpaved", getWayTypeFromFlags(osmWay));
@@ -164,23 +165,24 @@ public void testHandleWayTagsInfluencedByRelation() {
         // relation code is PREFER
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(18, encoder.getSpeed(flags), 1e-1);
         assertPriority(PriorityCode.PREFER.getValue(), osmWay);
         assertEquals("small way, unpaved", getWayTypeFromFlags(osmWay));
 
         // relation code is PREFER
         osmRel.setTag("network", "rcn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertPriority(PriorityCode.PREFER.getValue(), osmWay);
         assertEquals(18, encoder.getSpeed(flags), 1e-1);
 
         // relation code is PREFER
         osmRel.setTag("network", "ncn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertPriority(PriorityCode.PREFER.getValue(), osmWay);
         assertEquals(18, encoder.getSpeed(flags), 1e-1);
 
@@ -191,8 +193,8 @@ public void testHandleWayTagsInfluencedByRelation() {
 
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(18, encoder.getSpeed(flags), 1e-1);
         assertPriority(PriorityCode.PREFER.getValue(), osmWay);
         assertEquals("", getWayTypeFromFlags(osmWay));
diff --git a/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java b/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
index d2d30f41eb..81dfa60b0f 100644
--- a/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/NameSimilarityEdgeFilterTest.java
@@ -175,7 +175,12 @@ public void testAcceptWithTypos() {
     }
 
     private NameSimilarityEdgeFilter createNameSimilarityEdgeFilter(String s) {
-        return new NameSimilarityEdgeFilter(DefaultEdgeFilter.allEdges(new CarFlagEncoder()), s);
+        return new NameSimilarityEdgeFilter(new EdgeFilter() {
+            @Override
+            public boolean accept(EdgeIteratorState edgeState) {
+                return true;
+            }
+        }, s);
     }
 
     private EdgeIteratorState createTestEdgeIterator(final String name) {
@@ -185,16 +190,6 @@ private EdgeIteratorState createTestEdgeIterator(final String name) {
             public String getName() {
                 return name;
             }
-
-            @Override
-            public boolean isForward(FlagEncoder encoder) {
-                return true;
-            }
-
-            @Override
-            public boolean isBackward(FlagEncoder encoder) {
-                return true;
-            }
         };
     }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
index 80450133a1..9b7e8e91fc 100644
--- a/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/RacingBikeFlagEncoderTest.java
@@ -19,6 +19,8 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.GHUtility;
 import org.junit.Test;
 
 import static com.graphhopper.routing.util.BikeCommonFlagEncoder.PUSHING_SECTION_SPEED;
@@ -32,7 +34,7 @@
 public class RacingBikeFlagEncoderTest extends AbstractBikeFlagEncoderTester {
     @Override
     protected BikeCommonFlagEncoder createBikeEncoder() {
-        return (BikeCommonFlagEncoder) new EncodingManager("bike,racingbike").getEncoder("racingbike");
+        return new RacingBikeFlagEncoder();
     }
 
     @Test
@@ -71,30 +73,28 @@ public void testSacScale() {
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "service");
         way.setTag("sac_scale", "mountain_hiking");
-        // disallow
-        assertEquals(0, encoder.acceptWay(way));
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.setTag("highway", "path");
         way.setTag("sac_scale", "hiking");
-        // disallow
-        assertEquals(0, encoder.acceptWay(way));
+        assertTrue(encoder.getAccess(way).canSkip());
 
         way.setTag("highway", "cycleway");
         way.setTag("sac_scale", "hiking");
         // but allow this as there is no reason for not allowing it
-        assertTrue(encoder.acceptWay(way) > 0);
+        assertTrue(encoder.getAccess(way).isWay());
 
         // This looks to be tagging error:
         way.setTag("highway", "cycleway");
         way.setTag("sac_scale", "mountain_hiking");
-        // we are coutious and disallow this
-        assertEquals(0, encoder.acceptWay(way));
+        // we are cautious and disallow this
+        assertTrue(encoder.getAccess(way).canSkip());
     }
 
     @Test
     public void testGetSpeed() {
-        long result = encoder.setProperties(10, true, true);
-        assertEquals(10, encoder.getSpeed(result), 1e-1);
+        IntsRef intsRef = GHUtility.setProperties(encodingManager.createEdgeFlags(), encoder, 10, true, false);
+        assertEquals(10, encoder.getSpeed(intsRef), 1e-1);
         ReaderWay way = new ReaderWay(1);
         way.setTag("highway", "track");
         way.setTag("tracktype", "grade3");
@@ -133,34 +133,33 @@ public void testHandleWayTagsInfluencedByRelation() {
         assertEquals("small way, unpaved", getWayTypeFromFlags(osmWay, 0));
 
         // relation code is PREFER
-        long allowed = encoder.acceptBit;
         ReaderRelation osmRel = new ReaderRelation(1);
         osmRel.setTag("route", "bicycle");
         osmRel.setTag("network", "lcn");
-        long relFlags = encoder.handleRelationTags(osmRel, 0);
-        long flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        long relFlags = encoder.handleRelationTags(0, osmRel);
+        IntsRef flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(2, encoder.getSpeed(flags), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
         assertEquals("small way, unpaved", getWayTypeFromFlags(osmWay, relFlags));
 
         // relation code is OUTSTANDING NICE but as unpaved, the speed is still PUSHING_SECTION_SPEED/2
         osmRel.setTag("network", "icn");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(2, encoder.getSpeed(flags), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
 
         // Now we assume bicycle=yes, anyhow still unpaved
         osmWay.setTag("bicycle", "yes");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(2, encoder.getSpeed(flags), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
 
         // Now we assume bicycle=yes, and paved
         osmWay.setTag("tracktype", "grade1");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(20, encoder.getSpeed(flags), 1e-1);
         assertPriority(PREFER.getValue(), osmWay, relFlags);
         assertEquals("cycleway", getWayTypeFromFlags(osmWay, relFlags));
@@ -168,8 +167,8 @@ public void testHandleWayTagsInfluencedByRelation() {
         // Now we assume bicycle=yes, and unpaved as part of a cycle relation
         osmWay.setTag("tracktype", "grade2");
         osmWay.setTag("bicycle", "yes");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(10, encoder.getSpeed(flags), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
         assertEquals("small way, unpaved", getWayTypeFromFlags(osmWay, relFlags));
@@ -179,8 +178,8 @@ public void testHandleWayTagsInfluencedByRelation() {
         osmWay.clearTags();
         osmWay.setTag("highway", "track");
         osmWay.setTag("tracktype", "grade3");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(PUSHING_SECTION_SPEED, encoder.getSpeed(flags), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
         assertEquals("get off the bike, unpaved", getWayTypeFromFlags(osmWay, relFlags));
@@ -189,8 +188,8 @@ public void testHandleWayTagsInfluencedByRelation() {
         osmRel.clearTags();
         osmWay.clearTags();
         osmWay.setTag("highway", "track");
-        relFlags = encoder.handleRelationTags(osmRel, 0);
-        flags = encoder.handleWayTags(osmWay, allowed, relFlags);
+        relFlags = encoder.handleRelationTags(0, osmRel);
+        flags = encoder.handleWayTags(encodingManager.createEdgeFlags(), osmWay, EncodingManager.Access.WAY, relFlags);
         assertEquals(2, encoder.getSpeed(flags), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay, relFlags);
         assertEquals("small way, unpaved", getWayTypeFromFlags(osmWay, relFlags));
@@ -201,58 +200,70 @@ public void testAvoidanceOfHighMaxSpeed() {
         ReaderWay osmWay = new ReaderWay(1);
         osmWay.setTag("highway", "tertiary");
         osmWay.setTag("maxspeed", "50");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        IntsRef intsRef = encodingManager.createEdgeFlags();
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(PREFER.getValue(), osmWay);
 
         osmWay.setTag("maxspeed", "60");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(PREFER.getValue(), osmWay);
 
         osmWay.setTag("maxspeed", "80");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(PREFER.getValue(), osmWay);
 
         osmWay.setTag("maxspeed", "90");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(UNCHANGED.getValue(), osmWay);
 
         osmWay.setTag("maxspeed", "120");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(UNCHANGED.getValue(), osmWay);
 
         osmWay.setTag("highway", "motorway");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(REACH_DEST.getValue(), osmWay);
 
         osmWay.setTag("tunnel", "yes");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
 
         osmWay.clearTags();
         osmWay.setTag("highway", "motorway");
         osmWay.setTag("tunnel", "yes");
         osmWay.setTag("maxspeed", "80");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
 
         osmWay.clearTags();
         osmWay.setTag("highway", "motorway");
         osmWay.setTag("tunnel", "yes");
         osmWay.setTag("maxspeed", "120");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
 
         osmWay.clearTags();
         osmWay.setTag("highway", "notdefined");
         osmWay.setTag("tunnel", "yes");
         osmWay.setTag("maxspeed", "120");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(AVOID_AT_ALL_COSTS.getValue(), osmWay);
 
         osmWay.clearTags();
         osmWay.setTag("highway", "notdefined");
         osmWay.setTag("maxspeed", "50");
-        assertEquals(20, encoder.getSpeed(encoder.setSpeed(0, encoder.applyMaxSpeed(osmWay, 20))), 1e-1);
+        encoder.setSpeed(false, intsRef, encoder.applyMaxSpeed(osmWay, 20));
+        assertEquals(20, encoder.getSpeed(intsRef), 1e-1);
         assertPriority(UNCHANGED.getValue(), osmWay);
     }
 
diff --git a/core/src/test/java/com/graphhopper/routing/util/SnapPreventionEdgeFilterTest.java b/core/src/test/java/com/graphhopper/routing/util/SnapPreventionEdgeFilterTest.java
new file mode 100644
index 0000000000..e5fa5cfeaa
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/SnapPreventionEdgeFilterTest.java
@@ -0,0 +1,43 @@
+package com.graphhopper.routing.util;
+
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadClass;
+import com.graphhopper.routing.profiles.RoadEnvironment;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
+import org.junit.Test;
+
+import java.util.Arrays;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertFalse;
+
+public class SnapPreventionEdgeFilterTest {
+
+    @Test
+    public void accept() {
+        EdgeFilter trueFilter = new EdgeFilter() {
+            @Override
+            public boolean accept(EdgeIteratorState edgeState) {
+                return true;
+            }
+        };
+        EncodingManager em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(4)).build();
+        EnumEncodedValue<RoadClass> rcEnc = em.getEnumEncodedValue(RoadClass.KEY, RoadClass.class);
+        EnumEncodedValue<RoadEnvironment> reEnc = em.getEnumEncodedValue(RoadEnvironment.KEY, RoadEnvironment.class);
+        SnapPreventionEdgeFilter filter = new SnapPreventionEdgeFilter(trueFilter, rcEnc, reEnc, Arrays.asList("motorway", "ferry"));
+
+        IntsRef intsRef = em.createEdgeFlags();
+        assertTrue(filter.accept(GHUtility.createMockedEdgeIteratorState(1, intsRef)));
+        reEnc.setEnum(false, intsRef, RoadEnvironment.FERRY);
+        assertFalse(filter.accept(GHUtility.createMockedEdgeIteratorState(1, intsRef)));
+        reEnc.setEnum(false, intsRef, RoadEnvironment.FORD);
+        assertTrue(filter.accept(GHUtility.createMockedEdgeIteratorState(1, intsRef)));
+
+        rcEnc.setEnum(false, intsRef, RoadClass.RESIDENTIAL);
+        assertTrue(filter.accept(GHUtility.createMockedEdgeIteratorState(1, intsRef)));
+        rcEnc.setEnum(false, intsRef, RoadClass.MOTORWAY);
+        assertFalse(filter.accept(GHUtility.createMockedEdgeIteratorState(1, intsRef)));
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParserTest.java
new file mode 100644
index 0000000000..7a3cc149dd
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMMaxWeightParserTest.java
@@ -0,0 +1,42 @@
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.MaxWeight;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.graphhopper.routing.util.EncodingManager.Access.WAY;
+import static org.junit.Assert.assertEquals;
+
+public class OSMMaxWeightParserTest {
+
+    private EncodingManager em;
+    private DecimalEncodedValue mwEnc;
+    private OSMMaxWeightParser parser;
+
+    @Before
+    public void setUp() {
+        parser = new OSMMaxWeightParser();
+        em = new EncodingManager.Builder(4).add(parser).build();
+        mwEnc = em.getDecimalEncodedValue(MaxWeight.KEY);
+    }
+
+    @Test
+    public void testSimpleTags() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "primary");
+        readerWay.setTag("maxweight", "5");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(5.0, mwEnc.getDecimal(false, intsRef), .01);
+
+        // if value is beyond the maximum then do not use infinity instead fallback to more restrictive maximum
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("maxweight", "50");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(mwEnc.getMaxDecimal(), mwEnc.getDecimal(false, intsRef), .01);
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMRoadClassParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMRoadClassParserTest.java
new file mode 100644
index 0000000000..3adb03b4b8
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMRoadClassParserTest.java
@@ -0,0 +1,63 @@
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.RoadClass;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.graphhopper.routing.util.EncodingManager.Access.FERRY;
+import static com.graphhopper.routing.util.EncodingManager.Access.WAY;
+import static org.junit.Assert.assertEquals;
+
+public class OSMRoadClassParserTest {
+
+    private EncodingManager em;
+    private EnumEncodedValue<RoadClass> rcEnc;
+    private OSMRoadClassParser parser;
+
+    @Before
+    public void setUp() {
+        parser = new OSMRoadClassParser();
+        em = new EncodingManager.Builder(4).add(parser).build();
+        rcEnc = em.getEnumEncodedValue(RoadClass.KEY, RoadClass.class);
+    }
+
+    @Test
+    public void testSimpleTags() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "primary");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(RoadClass.PRIMARY, rcEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "unknownstuff");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(RoadClass.OTHER, rcEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "motorway_link");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(RoadClass.MOTORWAY, rcEnc.getEnum(false, intsRef));
+    }
+
+    @Test
+    public void testIgnore() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        readerWay.setTag("route", "ferry");
+        parser.handleWayTags(intsRef, readerWay, FERRY, 0);
+        assertEquals(RoadClass.OTHER, rcEnc.getEnum(false, intsRef));
+    }
+
+    @Test
+    public void testNoNPE() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(RoadClass.OTHER, rcEnc.getEnum(false, intsRef));
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java
new file mode 100644
index 0000000000..f6cc675a55
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/util/parsers/OSMTollParserTest.java
@@ -0,0 +1,53 @@
+package com.graphhopper.routing.util.parsers;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.Toll;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.graphhopper.routing.util.EncodingManager.Access.WAY;
+import static org.junit.Assert.assertEquals;
+
+public class OSMTollParserTest {
+    private EncodingManager em;
+    private EnumEncodedValue<Toll> tollEnc;
+    private OSMTollParser parser;
+
+    @Before
+    public void setUp() {
+        parser = new OSMTollParser();
+        em = new EncodingManager.Builder(4).add(parser).build();
+        tollEnc = em.getEnumEncodedValue(Toll.KEY, Toll.class);
+    }
+
+    @Test
+    public void testSimpleTags() {
+        ReaderWay readerWay = new ReaderWay(1);
+        IntsRef intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "primary");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(Toll.NO, tollEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "primary");
+        readerWay.setTag("toll:hgv", "yes");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(Toll.HGV, tollEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "primary");
+        readerWay.setTag("toll", "yes");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(Toll.ALL, tollEnc.getEnum(false, intsRef));
+
+        intsRef = em.createEdgeFlags();
+        readerWay.setTag("highway", "primary");
+        readerWay.setTag("toll", "yes");
+        readerWay.setTag("toll:hgv", "yes");
+        parser.handleWayTags(intsRef, readerWay, WAY, 0);
+        assertEquals(Toll.ALL, tollEnc.getEnum(false, intsRef));
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
index 67e0fd8d23..9aa6cabc8b 100644
--- a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupArrayTest.java
@@ -1,8 +1,8 @@
 package com.graphhopper.routing.util.spatialrules;
 
+import com.graphhopper.routing.profiles.RoadAccess;
 import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.Polygon;
-import org.junit.Assert;
 import org.junit.Test;
 
 import java.util.ArrayList;
@@ -52,9 +52,9 @@ public void testSmallScenario() {
 
         SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, false, new BBox(1, 4, 1, 4));
 
-        Assert.assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(2.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
+        assertEquals(RoadAccess.DESTINATION, spatialRuleLookup.lookupRule(1.2, 1.7).getAccess(null, TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
+        assertEquals(RoadAccess.DESTINATION, spatialRuleLookup.lookupRule(1.2, 3.7).getAccess(null, TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
+        assertEquals(RoadAccess.YES, spatialRuleLookup.lookupRule(2.2, 1.7).getAccess(null, TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
     }
 
     @Test
@@ -66,11 +66,11 @@ public void testExact() {
 
         SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, 1, true, new BBox(-1, 4, 1, 4));
 
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(1.2, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
+        assertEquals(RoadAccess.DESTINATION, spatialRuleLookup.lookupRule(1.2, 1.7).getAccess(null, TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
+        assertEquals(RoadAccess.DESTINATION, spatialRuleLookup.lookupRule(1.2, 3.7).getAccess(null, TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
         // Not in the second Polygon anymore
-        assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(3.9, 3.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(2.2, 1.7).getAccessValue(null, TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
+        assertEquals(RoadAccess.YES, spatialRuleLookup.lookupRule(3.9, 3.7).getAccess(null, TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
+        assertEquals(RoadAccess.YES, spatialRuleLookup.lookupRule(2.2, 1.7).getAccess(null, TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
         // Get the EmptySpatialRule in a BorderTile #1077
         assertEquals(SpatialRule.EMPTY.getId(), spatialRuleLookup.lookupRule(0.9, 0.9).getId());
     }
@@ -83,7 +83,7 @@ public void testExactCountry() {
         String germanPolygonJson = "[9.921906,54.983104],[9.93958,54.596642],[10.950112,54.363607],[10.939467,54.008693],[11.956252,54.196486],[12.51844,54.470371],[13.647467,54.075511],[14.119686,53.757029],[14.353315,53.248171],[14.074521,52.981263],[14.4376,52.62485],[14.685026,52.089947],[14.607098,51.745188],[15.016996,51.106674],[14.570718,51.002339],[14.307013,51.117268],[14.056228,50.926918],[13.338132,50.733234],[12.966837,50.484076],[12.240111,50.266338],[12.415191,49.969121],[12.521024,49.547415],[13.031329,49.307068],[13.595946,48.877172],[13.243357,48.416115],[12.884103,48.289146],[13.025851,47.637584],[12.932627,47.467646],[12.62076,47.672388],[12.141357,47.703083],[11.426414,47.523766],[10.544504,47.566399],[10.402084,47.302488],[9.896068,47.580197],[9.594226,47.525058],[8.522612,47.830828],[8.317301,47.61358],[7.466759,47.620582],[7.593676,48.333019],[8.099279,49.017784],[6.65823,49.201958],[6.18632,49.463803],[6.242751,49.902226],[6.043073,50.128052],[6.156658,50.803721],[5.988658,51.851616],[6.589397,51.852029],[6.84287,52.22844],[7.092053,53.144043],[6.90514,53.482162],[7.100425,53.693932],[7.936239,53.748296],[8.121706,53.527792],[8.800734,54.020786],[8.572118,54.395646],[8.526229,54.962744],[9.282049,54.830865],[9.921906,54.983104]";
         Polygon germanPolygon = parsePolygonString(germanPolygonJson);
 
-        spatialRules.add(new DefaultSpatialRule(){
+        spatialRules.add(new DefaultSpatialRule() {
             @Override
             public String getId() {
                 return "DEU";
@@ -135,6 +135,21 @@ public void testSmallBoundsBigPolygon() {
         assertEquals("big", spatialRuleLookup.lookupRule(1.5, 1.5).getId());
     }
 
+    @Test
+    public void testSpatialRuleForId() {
+        List<SpatialRule> spatialRules = new ArrayList<>();
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1, 1, 1.5, 1.5}, new double[]{1, 2, 2, 1}), "1"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1.5, 1.5, 2, 2}, new double[]{1, 2, 2, 1}), "2"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1.5, 1.5, 2, 2}, new double[]{1, 2, 2, 1}), "3"));
+        spatialRules.add(getSpatialRule(new Polygon(new double[]{1.5, 1.5, 2, 2}, new double[]{1, 2, 2, 1}), "4"));
+
+        SpatialRuleLookup spatialRuleLookup = new SpatialRuleLookupArray(spatialRules, .1, false, new BBox(1, 2, 1, 2));
+
+        // Note index=0 is the EMPTY rule
+        assertEquals("1", spatialRuleLookup.getSpatialRule(1).getId());
+        assertEquals("4", spatialRuleLookup.getSpatialRule(4).getId());
+    }
+
     private Polygon parsePolygonString(String polygonString) {
         String[] germanPolygonArr = polygonString.split("\\],\\[");
         double[] lats = new double[germanPolygonArr.length];
@@ -159,8 +174,8 @@ public double getMaxSpeed(String highwayTag, double _default) {
             }
 
             @Override
-            public AccessValue getAccessValue(String highwayTag, TransportationMode transportationMode, AccessValue _default) {
-                return AccessValue.EVENTUALLY_ACCESSIBLE;
+            public RoadAccess getAccess(String highwayTag, TransportationMode transportationMode, RoadAccess _default) {
+                return RoadAccess.DESTINATION;
             }
 
             @Override
diff --git a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilderTest.java b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilderTest.java
index 93b635d822..5ecc488e5e 100644
--- a/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilderTest.java
+++ b/core/src/test/java/com/graphhopper/routing/util/spatialrules/SpatialRuleLookupBuilderTest.java
@@ -19,8 +19,8 @@
 
 import com.graphhopper.jackson.Jackson;
 import com.graphhopper.json.geo.JsonFeatureCollection;
+import com.graphhopper.routing.profiles.RoadAccess;
 import com.graphhopper.util.shapes.BBox;
-import org.junit.Assert;
 import org.junit.Test;
 
 import java.io.FileReader;
@@ -43,17 +43,17 @@ public void testIndex() throws IOException {
         SpatialRuleLookup spatialRuleLookup = SpatialRuleLookupBuilder.buildIndex(Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class), "ISO_A3", new CountriesSpatialRuleFactory());
 
         // Berlin
-        Assert.assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(52.5243700, 13.4105300).getAccessValue("track", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(52.5243700, 13.4105300).getAccessValue("primary", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
+        assertEquals(RoadAccess.DESTINATION, spatialRuleLookup.lookupRule(52.5243700, 13.4105300).getAccess("track", TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
+        assertEquals(RoadAccess.YES, spatialRuleLookup.lookupRule(52.5243700, 13.4105300).getAccess("primary", TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
 
         // Paris -> empty rule
-        assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(48.864716, 2.349014).getAccessValue("track", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(48.864716, 2.349014).getAccessValue("primary", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
+        assertEquals(RoadAccess.YES, spatialRuleLookup.lookupRule(48.864716, 2.349014).getAccess("track", TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
+        assertEquals(RoadAccess.YES, spatialRuleLookup.lookupRule(48.864716, 2.349014).getAccess("primary", TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
 
-        // Vienna
-        assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(48.210033, 16.363449).getAccessValue("track", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        assertEquals(AccessValue.ACCESSIBLE, spatialRuleLookup.lookupRule(48.210033, 16.363449).getAccessValue("primary", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
-        assertEquals(AccessValue.EVENTUALLY_ACCESSIBLE, spatialRuleLookup.lookupRule(48.210033, 16.363449).getAccessValue("living_street", TransportationMode.MOTOR_VEHICLE, AccessValue.ACCESSIBLE));
+        // Austria
+        assertEquals(RoadAccess.FORESTRY, spatialRuleLookup.lookupRule(48.204484,16.107888).getAccess("track", TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
+        assertEquals(RoadAccess.YES, spatialRuleLookup.lookupRule(48.210033, 16.363449).getAccess("primary", TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
+        assertEquals(RoadAccess.DESTINATION, spatialRuleLookup.lookupRule(48.210033, 16.363449).getAccess("living_street", TransportationMode.MOTOR_VEHICLE, RoadAccess.YES));
     }
 
     @Test
@@ -84,5 +84,4 @@ public void testNoIntersection() throws IOException {
         assertEquals(SpatialRuleLookup.EMPTY, spatialRuleLookup);
     }
 
-
 }
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
index 856a8a4b05..d9f9cafefa 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/BlockAreaWeightingTest.java
@@ -26,7 +26,7 @@
     @Before
     public void setUp() {
         encoder = new CarFlagEncoder();
-        em = new EncodingManager(Arrays.asList(encoder), 8);
+        em = EncodingManager.create(Arrays.asList(encoder), 8);
         graph = new GraphBuilder(em).create();
         // 0-1
         graph.edge(0, 1, 1, true);
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/FastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/FastestWeightingTest.java
index 42ccc9ad63..4169639913 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/FastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/FastestWeightingTest.java
@@ -23,12 +23,8 @@
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.GHUtility;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PMap;
-import com.graphhopper.util.Parameters;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.util.*;
 import com.graphhopper.util.Parameters.Routing;
 import org.junit.Test;
 
@@ -39,12 +35,13 @@
  * @author Peter Karich
  */
 public class FastestWeightingTest {
-    private final FlagEncoder encoder = new EncodingManager("car").getEncoder("car");
+    EncodingManager encodingManager = EncodingManager.create("car");
+    private final FlagEncoder encoder = encodingManager.getEncoder("car");
 
     @Test
     public void testMinWeightHasSameUnitAs_getWeight() {
         Weighting instance = new FastestWeighting(encoder);
-        long flags = encoder.setProperties(encoder.getMaxSpeed(), true, true);
+        IntsRef flags = GHUtility.setProperties(encodingManager.createEdgeFlags(), encoder, encoder.getMaxSpeed(), true, false);
         assertEquals(instance.getMinWeight(10), instance.calcWeight(createMockedEdgeIteratorState(10, flags), false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
@@ -52,8 +49,9 @@ public void testMinWeightHasSameUnitAs_getWeight() {
     public void testWeightWrongHeading() {
         Weighting instance = new FastestWeighting(encoder, new PMap().
                 put(Parameters.Routing.HEADING_PENALTY, "100"));
+
         VirtualEdgeIteratorState virtEdge = new VirtualEdgeIteratorState(0, 1, 1, 2, 10,
-                encoder.setProperties(10, true, true), "test", Helper.createPointList(51, 0, 51, 1));
+                GHUtility.setProperties(encodingManager.createEdgeFlags(), encoder, 10, true, false), "test", Helper.createPointList(51, 0, 51, 1), false);
         double time = instance.calcWeight(virtEdge, false, 0);
 
         virtEdge.setUnfavored(true);
@@ -75,21 +73,26 @@ public void testWeightWrongHeading() {
     @Test
     public void testSpeed0() {
         Weighting instance = new FastestWeighting(encoder);
-
-        assertEquals(1.0 / 0, instance.calcWeight(createMockedEdgeIteratorState(10, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
+        IntsRef edgeFlags = encodingManager.createEdgeFlags();
+        encoder.getAverageSpeedEnc().setDecimal(false, edgeFlags, 0);
+        assertEquals(1.0 / 0, instance.calcWeight(createMockedEdgeIteratorState(10, edgeFlags),
+                false, EdgeIterator.NO_EDGE), 1e-8);
 
         // 0 / 0 returns NaN but calcWeight should not return NaN!
-        assertEquals(1.0 / 0, instance.calcWeight(createMockedEdgeIteratorState(0, encoder.setProperties(0, true, true)), false, EdgeIterator.NO_EDGE), 1e-8);
+        assertEquals(1.0 / 0, instance.calcWeight(createMockedEdgeIteratorState(0, edgeFlags),
+                false, EdgeIterator.NO_EDGE), 1e-8);
     }
 
     @Test
     public void testTime() {
         FlagEncoder tmpEnc = new Bike2WeightFlagEncoder();
-        GraphHopperStorage g = new GraphBuilder(new EncodingManager(tmpEnc)).create();
+        GraphHopperStorage g = new GraphBuilder(EncodingManager.create(tmpEnc)).create();
         Weighting w = new FastestWeighting(tmpEnc);
 
-        long flags = tmpEnc.setSpeed(tmpEnc.setReverseSpeed(tmpEnc.setAccess(0, true, true), 10), 15);
-        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(100000, flags);
+        IntsRef edgeFlags = GHUtility.setProperties(g.getEncodingManager().createEdgeFlags(), tmpEnc, 15, true, true);
+        tmpEnc.getAverageSpeedEnc().setDecimal(true, edgeFlags, 10.0);
+
+        EdgeIteratorState edge = GHUtility.createMockedEdgeIteratorState(100000, edgeFlags);
 
         assertEquals(375 * 60 * 1000, w.calcMillis(edge, false, EdgeIterator.NO_EDGE));
         assertEquals(600 * 60 * 1000, w.calcMillis(edge, true, EdgeIterator.NO_EDGE));
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
index 7351679904..2a7404ae8a 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/GenericWeightingTest.java
@@ -22,23 +22,23 @@
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.HintsMap;
+import com.graphhopper.routing.util.parsers.OSMMaxHeightParser;
+import com.graphhopper.routing.util.parsers.OSMMaxWeightParser;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.PMap;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Arrays;
-
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
  */
 public class GenericWeightingTest {
-    private final PMap properties;
     private final DataFlagEncoder encoder;
     private final EncodingManager em;
     private Graph graph;
@@ -46,12 +46,9 @@
     private final double edgeWeight = 566111;
 
     public GenericWeightingTest() {
-        properties = new PMap();
-        properties.put("store_height", true);
-        properties.put("store_weight", true);
-        properties.put("store_width", true);
-        encoder = new DataFlagEncoder(properties);
-        em = new EncodingManager(Arrays.asList(encoder), 8);
+        encoder = new DataFlagEncoder();
+        em = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).add(new OSMMaxHeightParser()).
+                add(encoder).build();
     }
 
     @Before
@@ -66,7 +63,8 @@ public void setUp() {
         graph.edge(0, 1, 1, true);
         AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
         AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
-        graph.getEdgeIteratorState(0, 1).setFlags(encoder.handleWayTags(way, 1, 0));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay().put(encoder.toString(), EncodingManager.Access.WAY);
+        graph.getEdgeIteratorState(0, 1).setFlags(em.handleWayTags(way, map, 0));
     }
 
     @Test
@@ -89,7 +87,7 @@ public void testRoadAttributeRestriction() {
     @Test
     public void testDisabledRoadAttributes() {
         DataFlagEncoder simpleEncoder = new DataFlagEncoder();
-        EncodingManager simpleEncodingManager = new EncodingManager(simpleEncoder);
+        EncodingManager simpleEncodingManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).add(simpleEncoder).build();
         Graph simpleGraph = new GraphBuilder(simpleEncodingManager).create();
 
         ReaderWay way = new ReaderWay(27l);
@@ -101,7 +99,8 @@ public void testDisabledRoadAttributes() {
         simpleGraph.edge(0, 1, 1, true);
         AbstractRoutingAlgorithmTester.updateDistancesFor(simpleGraph, 0, 0.00, 0.00);
         AbstractRoutingAlgorithmTester.updateDistancesFor(simpleGraph, 1, 0.01, 0.01);
-        simpleGraph.getEdgeIteratorState(0, 1).setFlags(simpleEncoder.handleWayTags(way, 1, 0));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay().put(encoder.toString(), EncodingManager.Access.WAY);
+        simpleGraph.getEdgeIteratorState(0, 1).setFlags(simpleEncodingManager.handleWayTags(way, map, 0));
 
         Weighting instance = new GenericWeighting(simpleEncoder, new HintsMap().put(GenericWeighting.HEIGHT_LIMIT, 5.0));
         EdgeIteratorState edge = simpleGraph.getEdgeIteratorState(0, 1);
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/ShortFastestWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/ShortFastestWeightingTest.java
index ff983432c9..461ce33d8b 100644
--- a/core/src/test/java/com/graphhopper/routing/weighting/ShortFastestWeightingTest.java
+++ b/core/src/test/java/com/graphhopper/routing/weighting/ShortFastestWeightingTest.java
@@ -25,6 +25,7 @@
 import com.graphhopper.util.PMap;
 import org.junit.Test;
 
+import static com.graphhopper.util.GHUtility.createMockedEdgeIteratorState;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -32,11 +33,12 @@
  * @author Peter Karich
  */
 public class ShortFastestWeightingTest {
-    private final FlagEncoder encoder = new EncodingManager("car").getEncoder("car");
+    EncodingManager encodingManager = EncodingManager.create("car");
+    private final FlagEncoder encoder = encodingManager.getEncoder("car");
 
     @Test
     public void testShort() {
-        EdgeIteratorState edge = createEdge(10, encoder.setProperties(50, true, true));
+        EdgeIteratorState edge = createMockedEdgeIteratorState(10, GHUtility.setProperties(encodingManager.createEdgeFlags(), encoder, 50, true, false));
         Weighting instance = new ShortFastestWeighting(encoder, 0.03);
         assertEquals(1.02, instance.calcWeight(edge, false, EdgeIterator.NO_EDGE), 1e-8);
 
@@ -53,23 +55,4 @@ public void testTooSmall() {
         } catch (Exception ex) {
         }
     }
-
-    EdgeIterator createEdge(final double distance, final long flags) {
-        return new GHUtility.DisabledEdgeIterator() {
-            @Override
-            public double getDistance() {
-                return distance;
-            }
-
-            @Override
-            public long getFlags() {
-                return flags;
-            }
-
-            @Override
-            public boolean getBool(int key, boolean _default) {
-                return _default;
-            }
-        };
-    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java b/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java
new file mode 100644
index 0000000000..99163de6e4
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/weighting/TurnWeightingTest.java
@@ -0,0 +1,71 @@
+package com.graphhopper.routing.weighting;
+
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.TurnCostExtension;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.graphhopper.util.GHUtility.getEdge;
+import static org.junit.Assert.assertEquals;
+
+public class TurnWeightingTest {
+
+    private Graph graph;
+    private FlagEncoder encoder;
+    private EncodingManager encodingManager;
+    private Weighting weighting;
+    private TurnCostExtension turnCostExt;
+
+    @Before
+    public void setup() {
+        encoder = new CarFlagEncoder(5, 5, 10);
+        encodingManager = EncodingManager.create(encoder);
+        graph = new GraphBuilder(encodingManager).create();
+        weighting = new FastestWeighting(encoder);
+        turnCostExt = (TurnCostExtension) graph.getExtension();
+    }
+
+    @Test
+    public void calcWeightAndTime_withTurnCosts() {
+        graph.edge(0, 1, 100, true);
+        EdgeIteratorState edge = graph.edge(1, 2, 100, true);
+        // turn costs are given in seconds
+        addTurnCost(0, 1, 2, 5);
+        TurnWeighting turnWeighting = new TurnWeighting(weighting, turnCostExt);
+        assertEquals(6 + 5, turnWeighting.calcWeight(edge, false, 0), 1.e-6);
+        assertEquals(6000 + 5000, turnWeighting.calcMillis(edge, false, 0), 1.e-6);
+    }
+
+    @Test
+    public void calcWeightAndTime_defaultUTurn() {
+        // for u-turns default costs get applied
+        EdgeIteratorState edge = graph.edge(0, 1, 100, true);
+        TurnWeighting turnWeighting = new TurnWeighting(weighting, turnCostExt, 40);
+        assertEquals(6 + 40, turnWeighting.calcWeight(edge, false, 0), 1.e-6);
+        assertEquals((6 + 40) * 1000, turnWeighting.calcMillis(edge, false, 0), 1.e-6);
+    }
+
+    @Test
+    public void calcWeightAndTime_withTurnCosts_shortest() {
+        graph.edge(0, 1, 100, true);
+        EdgeIteratorState edge = graph.edge(1, 2, 100, true);
+        // turn costs are given in seconds
+        addTurnCost(0, 1, 2, 5);
+        TurnWeighting turnWeighting = new TurnWeighting(new ShortestWeighting(encoder), turnCostExt);
+        // todo: for the shortest weighting turn costs cannot be interpreted as seconds ? at least when they are added
+        // to the weight ? how much should they contribute ?
+//        assertEquals(105, turnWeighting.calcWeight(edge, false, 0), 1.e-6);
+        assertEquals(6000 + 5000, turnWeighting.calcMillis(edge, false, 0), 1.e-6);
+    }
+
+    private void addTurnCost(int from, int via, int to, double turnCost) {
+        long turnFlags = encoder.getTurnFlags(false, turnCost);
+        turnCostExt.addTurnInfo(getEdge(graph, from, via).getEdge(), via, getEdge(graph, via, to).getEdge(), turnFlags);
+    }
+
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
index 77e2d906bb..fff721bd3d 100644
--- a/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
+++ b/core/src/test/java/com/graphhopper/storage/AbstractGraphStorageTester.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.storage;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
@@ -31,6 +33,7 @@
 import java.util.Arrays;
 import java.util.List;
 
+import static com.graphhopper.routing.util.EncodingManager.getKey;
 import static com.graphhopper.util.GHUtility.count;
 import static org.junit.Assert.*;
 
@@ -45,8 +48,10 @@
     private final String locationParent = "./target/graphstorage";
     protected int defaultSize = 100;
     protected String defaultGraphLoc = "./target/graphstorage/default";
-    protected EncodingManager encodingManager = new EncodingManager("car,foot");
+    protected EncodingManager encodingManager = EncodingManager.create("car,foot");
     protected CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("car");
+    protected BooleanEncodedValue carAccessEnc = carEncoder.getAccessEnc();
+    protected DecimalEncodedValue carAvSpeedEnc = carEncoder.getAverageSpeedEnc();
     protected FootFlagEncoder footEncoder = (FootFlagEncoder) encodingManager.getEncoder("foot");
     protected GraphHopperStorage graph;
     EdgeFilter carOutFilter = DefaultEdgeFilter.outEdges(carEncoder);
@@ -106,7 +111,7 @@ public void setUp() {
 
     @After
     public void tearDown() {
-        Helper.close((Closeable) graph);
+        Helper.close(graph);
         Helper.removeDir(new File(locationParent));
     }
 
@@ -118,12 +123,9 @@ public void testSetTooBigDistance_435() {
         EdgeIteratorState edge1 = graph.edge(0, 1, maxDist, true);
         assertEquals(maxDist, edge1.getDistance(), 1);
 
-        // max out should NOT lead to infinity as this leads fast to NaN!
-        try {
-            graph.edge(0, 2, maxDist + 1, true);
-        } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Distance too large"));
-        }
+        // max out should NOT lead to infinity as this leads fast to NaN! -> we set dist to the maximum if its larger than desired
+        EdgeIteratorState edge2 = graph.edge(0, 2, maxDist + 1, true);
+        assertEquals(maxDist, edge2.getDistance(), 1);
     }
 
     @Test
@@ -141,7 +143,7 @@ public void testSetNodes() {
     @Test
     public void testPropertiesWithNoInit() {
         graph = createGHStorage();
-        assertEquals(0, graph.edge(0, 1).getFlags());
+        assertEquals(0, graph.edge(0, 1).getFlags().ints[0]);
         assertEquals(0, graph.edge(0, 2).getDistance(), 1e-6);
     }
 
@@ -284,7 +286,7 @@ public void testCopyProperties() {
         EdgeIteratorState edge = graph.edge(1, 3, 10, false).setName("testing").setWayGeometry(Helper.createPointList(1, 2));
 
         EdgeIteratorState newEdge = graph.edge(1, 3, 10, false);
-        edge.copyPropertiesTo(newEdge);
+        newEdge.copyPropertiesFrom(edge);
         assertEquals(edge.getName(), newEdge.getName());
         assertEquals(edge.getDistance(), newEdge.getDistance(), 1e-7);
         assertEquals(edge.getFlags(), newEdge.getFlags());
@@ -701,16 +703,20 @@ public void testBounds() {
     @Test
     public void testFlags() {
         graph = createGHStorage();
-        graph.edge(0, 1).setDistance(10).setFlags(carEncoder.setProperties(100, true, true));
-        graph.edge(2, 3).setDistance(10).setFlags(carEncoder.setProperties(10, true, false));
+        GHUtility.setProperties(graph.edge(0, 1), carEncoder, 100, true, true).setDistance(10);
+        GHUtility.setProperties(graph.edge(2, 3), carEncoder, 10, true, false).setDistance(10);
 
         EdgeIterator iter = carAllExplorer.setBaseNode(0);
         assertTrue(iter.next());
-        assertEquals(carEncoder.setProperties(100, true, true), iter.getFlags());
+        assertEquals(100, iter.get(carAvSpeedEnc), 1);
+        assertTrue(iter.get(carAccessEnc));
+        assertTrue(iter.getReverse(carAccessEnc));
 
         iter = carAllExplorer.setBaseNode(2);
         assertTrue(iter.next());
-        assertEquals(carEncoder.setProperties(10, true, false), iter.getFlags());
+        assertEquals(10, iter.get(carAvSpeedEnc), 1);
+        assertTrue(iter.get(carAccessEnc));
+        assertFalse(iter.getReverse(carAccessEnc));
 
         try {
             graph.edge(0, 1).setDistance(-1);
@@ -787,14 +793,14 @@ public void testCreateDuplicateEdges() {
         EdgeIteratorState oneIter = graph.getEdgeIteratorState(iter.getEdge(), 3);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(2, oneIter.getBaseNode());
-        assertTrue(carEncoder.isForward(oneIter.getFlags()));
-        assertFalse(carEncoder.isBackward(oneIter.getFlags()));
+        assertTrue(oneIter.get(carAccessEnc));
+        assertFalse(oneIter.getReverse(carAccessEnc));
 
         oneIter = graph.getEdgeIteratorState(iter.getEdge(), 2);
         assertEquals(13, oneIter.getDistance(), 1e-6);
         assertEquals(3, oneIter.getBaseNode());
-        assertFalse(carEncoder.isForward(oneIter.getFlags()));
-        assertTrue(carEncoder.isBackward(oneIter.getFlags()));
+        assertFalse(oneIter.get(carAccessEnc));
+        assertTrue(oneIter.getReverse(carAccessEnc));
 
         graph.edge(3, 2, 14, true);
         assertEquals(4, GHUtility.count(carOutExplorer.setBaseNode(2)));
@@ -818,10 +824,12 @@ public void testIdenticalNodes2() {
     @Test
     public void testEdgeReturn() {
         graph = createGHStorage();
-        EdgeIteratorState iter = graph.edge(4, 10).setDistance(100).setFlags(carEncoder.setProperties(10, true, false));
+        EdgeIteratorState iter = graph.edge(4, 10).setDistance(100);
+        GHUtility.setProperties(iter, carEncoder, 10, true, false);
         assertEquals(4, iter.getBaseNode());
         assertEquals(10, iter.getAdjNode());
-        iter = graph.edge(14, 10).setDistance(100).setFlags(carEncoder.setProperties(10, true, false));
+        iter = graph.edge(14, 10).setDistance(100);
+        GHUtility.setProperties(iter, carEncoder, 10, true, false);
         assertEquals(14, iter.getBaseNode());
         assertEquals(10, iter.getAdjNode());
     }
@@ -836,11 +844,14 @@ public void testPillarNodes() {
         na.setNode(10, 0.99, 0.99);
 
         PointList pointList = Helper.createPointList(1, 1, 1, 2, 1, 3);
-        graph.edge(0, 4).setDistance(100).setFlags(carEncoder.setProperties(10, true, false)).setWayGeometry(pointList);
+        EdgeIteratorState edge = graph.edge(0, 4).setDistance(100).setWayGeometry(pointList);
+        GHUtility.setProperties(edge, carEncoder, 10, true, false);
         pointList = Helper.createPointList(1, 5, 1, 6, 1, 7, 1, 8, 1, 9);
-        graph.edge(4, 10).setDistance(100).setFlags(carEncoder.setProperties(10, true, false)).setWayGeometry(pointList);
+        edge = graph.edge(4, 10).setDistance(100).setWayGeometry(pointList);
+        GHUtility.setProperties(edge, carEncoder, 10, true, false);
         pointList = Helper.createPointList(1, 13, 1, 12, 1, 11);
-        graph.edge(14, 0).setDistance(100).setFlags(carEncoder.setProperties(10, true, false)).setWayGeometry(pointList);
+        edge = graph.edge(14, 0).setDistance(100).setWayGeometry(pointList);
+        GHUtility.setProperties(edge, carEncoder, 10, true, false);
 
         EdgeIterator iter = carAllExplorer.setBaseNode(0);
         assertTrue(iter.next());
@@ -878,9 +889,11 @@ public void testPillarNodes() {
     @Test
     public void testFootMix() {
         graph = createGHStorage();
-        graph.edge(0, 1).setDistance(10).setFlags(footEncoder.setProperties(10, true, true));
-        graph.edge(0, 2).setDistance(10).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(0, 3).setDistance(10).setFlags(footEncoder.setProperties(10, true, true) | carEncoder.setProperties(10, true, true));
+        GHUtility.setProperties(graph.edge(0, 1).setDistance(10), footEncoder, 10, true, true);
+        GHUtility.setProperties(graph.edge(0, 2).setDistance(10), carEncoder, 10, true, true);
+        EdgeIteratorState edge = graph.edge(0, 3).setDistance(10);
+        GHUtility.setProperties(edge, footEncoder, 10, true, true);
+        GHUtility.setProperties(edge, carEncoder, 10, true, true);
         EdgeExplorer footOutExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(footEncoder));
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(footOutExplorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(3, 2), GHUtility.getNeighbors(carOutExplorer.setBaseNode(0)));
@@ -903,12 +916,12 @@ public void testGetAllEdges() {
         assertTrue(iter.next());
         int edgeId2 = iter.getEdge();
         assertEquals(1, edgeId2 - edgeId);
-        assertEquals(1, iter.getBaseNode());
-        assertEquals(3, iter.getAdjNode());
+        assertEquals(3, iter.getBaseNode());
+        assertEquals(1, iter.getAdjNode());
 
         assertTrue(iter.next());
-        assertEquals(2, iter.getBaseNode());
-        assertEquals(3, iter.getAdjNode());
+        assertEquals(3, iter.getBaseNode());
+        assertEquals(2, iter.getAdjNode());
 
         assertFalse(iter.next());
     }
@@ -963,45 +976,70 @@ public void testNameIndex() {
     }
 
     @Test
-    public void test8BytesFlags() {
+    public void test8AndMoreBytesForEdgeFlags() {
         Directory dir = new RAMDirectory();
         List<FlagEncoder> list = new ArrayList<>();
         list.add(new TmpCarFlagEncoder(29, 0.001, 0) {
             @Override
             public String toString() {
-                return "car2";
+                return "car0";
             }
         });
         list.add(new TmpCarFlagEncoder(29, 0.001, 0));
-        EncodingManager manager = new EncodingManager(list, 8);
+        EncodingManager manager = EncodingManager.create(list, 8);
         graph = new GraphHopperStorage(dir, manager, false, new GraphExtension.NoOpExtension()).create(defaultSize);
 
         EdgeIteratorState edge = graph.edge(0, 1);
-        edge.setFlags(Long.MAX_VALUE / 3);
+        IntsRef intsRef = manager.createEdgeFlags();
+        intsRef.ints[0] = Integer.MAX_VALUE / 3;
+        edge.setFlags(intsRef);
         // System.out.println(BitUtil.LITTLE.toBitString(Long.MAX_VALUE / 3) + "\n" + BitUtil.LITTLE.toBitString(edge.getFlags()));
-        assertEquals(Long.MAX_VALUE / 3, edge.getFlags());
+        assertEquals(Integer.MAX_VALUE / 3, edge.getFlags().ints[0]);
         graph.close();
 
         graph = new GraphHopperStorage(dir, manager, false, new GraphExtension.NoOpExtension()).create(defaultSize);
 
+        DecimalEncodedValue avSpeed0Enc = manager.getDecimalEncodedValue(getKey("car0", "average_speed"));
+        BooleanEncodedValue access0Enc = manager.getBooleanEncodedValue(getKey("car0", "access"));
+        DecimalEncodedValue avSpeed1Enc = manager.getDecimalEncodedValue(getKey("car", "average_speed"));
+        BooleanEncodedValue access1Enc = manager.getBooleanEncodedValue(getKey("car", "access"));
+
         edge = graph.edge(0, 1);
-        edge.setFlags(list.get(0).setProperties(99.123, true, true));
-        assertEquals(99.123, list.get(0).getSpeed(edge.getFlags()), 1e-3);
+        GHUtility.setProperties(edge, list.get(0), 99.123, true, true);
+        assertEquals(99.123, edge.get(avSpeed0Enc), 1e-3);
         EdgeIteratorState edgeIter = GHUtility.getEdge(graph, 1, 0);
-        long flags = edgeIter.getFlags();
-        assertEquals(99.123, list.get(0).getSpeed(flags), 1e-3);
-        assertTrue(edgeIter.isForward(list.get(0)));
-        assertTrue(edgeIter.isBackward(list.get(0)));
+        assertEquals(99.123, edgeIter.get(avSpeed0Enc), 1e-3);
+        assertTrue(edgeIter.get(access0Enc));
+        assertTrue(edgeIter.getReverse(access0Enc));
         edge = graph.edge(2, 3);
-        edge.setFlags(list.get(1).setProperties(44.123, true, false));
-        assertEquals(44.123, list.get(1).getSpeed(edge.getFlags()), 1e-3);
+        GHUtility.setProperties(edge, list.get(1), 44.123, true, false);
+        assertEquals(44.123, edge.get(avSpeed1Enc), 1e-3);
 
         edgeIter = GHUtility.getEdge(graph, 3, 2);
-        flags = edgeIter.getFlags();
-        assertEquals(44.123, list.get(1).getSpeed(flags), 1e-3);
-        assertEquals(44.123, list.get(1).getReverseSpeed(flags), 1e-3);
-        assertFalse(edgeIter.isForward(list.get(1)));
-        assertTrue(edgeIter.isBackward(list.get(1)));
+        assertEquals(44.123, edgeIter.get(avSpeed1Enc), 1e-3);
+        assertEquals(44.123, edgeIter.getReverse(avSpeed1Enc), 1e-3);
+        assertFalse(edgeIter.get(access1Enc));
+        assertTrue(edgeIter.getReverse(access1Enc));
+
+        list.clear();
+        list.add(new TmpCarFlagEncoder(29, 0.001, 0) {
+            @Override
+            public String toString() {
+                return "car0";
+            }
+        });
+        list.add(new TmpCarFlagEncoder(29, 0.001, 0));
+        list.add(new TmpCarFlagEncoder(30, 0.001, 0) {
+            @Override
+            public String toString() {
+                return "car2";
+            }
+        });
+        manager = EncodingManager.create(list, 20);
+        graph = new GraphHopperStorage(new RAMDirectory(), manager, false, new GraphExtension.NoOpExtension()).create(defaultSize);
+        edgeIter = graph.edge(0, 1).set(access0Enc, true).setReverse(access0Enc, false);
+        assertTrue(edgeIter.get(access0Enc));
+        assertFalse(edgeIter.getReverse(access0Enc));
     }
 
     @Test
@@ -1051,8 +1089,8 @@ public void testDontGrowOnUpdate() throws IOException {
     public void testDetachEdge() {
         graph = createGHStorage();
         graph.edge(0, 1, 2, true);
-        long flags = carEncoder.setProperties(10, true, false);
-        graph.edge(0, 2, 2, true).setWayGeometry(Helper.createPointList(1, 2, 3, 4)).setFlags(flags);
+        GHUtility.setProperties(graph.edge(0, 2, 2, true).setWayGeometry(Helper.createPointList(1, 2, 3, 4)),
+                carEncoder, 10, true, false);
         graph.edge(1, 2, 2, true);
 
         EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(0);
@@ -1068,13 +1106,13 @@ public void testDetachEdge() {
         assertEquals(2, iter.getAdjNode());
         assertEquals(1, edgeState02.fetchWayGeometry(0).getLatitude(0), 1e-1);
         assertEquals(2, edgeState02.getAdjNode());
-        assertTrue(carEncoder.isForward(edgeState02.getFlags()));
+        assertTrue(edgeState02.get(carAccessEnc));
 
         EdgeIteratorState edgeState20 = iter.detach(true);
         assertEquals(0, edgeState20.getAdjNode());
         assertEquals(2, edgeState20.getBaseNode());
         assertEquals(3, edgeState20.fetchWayGeometry(0).getLatitude(0), 1e-1);
-        assertFalse(carEncoder.isForward(edgeState20.getFlags()));
+        assertFalse(edgeState20.get(carAccessEnc));
         assertEquals(GHUtility.getEdge(graph, 0, 2).getFlags(), edgeState02.getFlags());
         assertEquals(GHUtility.getEdge(graph, 2, 0).getFlags(), edgeState20.getFlags());
 
@@ -1088,7 +1126,7 @@ public void testDetachEdge() {
         assertEquals(3, edgeState20.fetchWayGeometry(0).getLatitude(0), 1e-1);
 
         // #162 a directed self referencing edge should be able to reverse its state too
-        graph.edge(3, 3, 2, true).setFlags(flags);
+        GHUtility.setProperties(graph.edge(3, 3, 2, true), carEncoder, 10, true, false);
         EdgeIterator edgeState33 = graph.createEdgeExplorer().setBaseNode(3);
         edgeState33.next();
         assertEquals(3, edgeState33.getBaseNode());
diff --git a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
index 7e175b1c98..55982a04ea 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphEdgeIdFinderTest.java
@@ -42,7 +42,7 @@
     @Test
     public void testParseStringHints() {
         FlagEncoder encoder = new CarFlagEncoder();
-        EncodingManager em = new EncodingManager(encoder);
+        EncodingManager em = EncodingManager.create(encoder);
         GraphHopperStorage graph = new GraphBuilder(em).create();
         // 0-1-2
         // | |
@@ -82,7 +82,7 @@ public void testParseStringHints() {
     @Test
     public void testBlockAreasWithPolygon() {
         FlagEncoder encoder = new CarFlagEncoder();
-        EncodingManager em = new EncodingManager(encoder);
+        EncodingManager em = EncodingManager.create(encoder);
         GraphHopperStorage graph = new GraphBuilder(em).create();
 
         // 00-01-02-03
@@ -124,13 +124,13 @@ public void testBlockAreasWithPolygon() {
         GraphEdgeIdFinder.BlockArea blockArea = graphFinder.parseBlockArea("2,1, 0,2, 2,3", DefaultEdgeFilter.allEdges(encoder), 1000 * 1000);
 
         GHIntHashSet blockedEdges = new GHIntHashSet();
-        blockedEdges.addAll(new int[]{1, 2, 6, 7});
+        blockedEdges.addAll(1, 2, 6, 7);
         assertEquals(blockedEdges, blockArea.blockedEdges);
 
         blockArea = graphFinder.parseBlockArea("2,1, 1,3, 1,2, 0,1", DefaultEdgeFilter.allEdges(encoder), 1000 * 1000);
 
         blockedEdges = new GHIntHashSet();
-        blockedEdges.addAll(new int[]{4, 9, 6, 7});
+        blockedEdges.addAll(4, 9, 6, 7);
         assertEquals(blockedEdges, blockArea.blockedEdges);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
index 6336dc4465..f4b4443ce8 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageCHTest.java
@@ -19,8 +19,10 @@
 
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
@@ -30,8 +32,10 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
+import static com.graphhopper.routing.ch.NodeBasedNodeContractorTest.SC_ACCESS;
 import static org.junit.Assert.*;
 
 /**
@@ -39,17 +43,29 @@
  */
 public class GraphHopperStorageCHTest extends GraphHopperStorageTest {
     protected CHGraph getGraph(GraphHopperStorage ghStorage) {
-        return ghStorage.getGraph(CHGraph.class);
+        return ghStorage.getCHGraph();
     }
 
     @Override
     public GraphHopperStorage newGHStorage(Directory dir, boolean is3D) {
-        return new GraphHopperStorage(Arrays.asList(new FastestWeighting(carEncoder)), dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
+        return newGHStorage(dir, is3D, false);
+    }
+
+    private GraphHopperStorage newGHStorage(boolean is3D, boolean forEdgeBasedTraversal) {
+        return newGHStorage(new RAMDirectory(defaultGraphLoc, true), is3D, forEdgeBasedTraversal).create(defaultSize);
+    }
+
+    private GraphHopperStorage newGHStorage(Directory dir, boolean is3D, boolean forEdgeBasedTraversal) {
+        if (forEdgeBasedTraversal) {
+            return new GraphHopperStorage(Collections.<Weighting>emptyList(), Arrays.asList(new FastestWeighting(carEncoder)), dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
+        } else {
+            return new GraphHopperStorage(Arrays.asList(new FastestWeighting(carEncoder)), Collections.<Weighting>emptyList(), dir, encodingManager, is3D, new GraphExtension.NoOpExtension());
+        }
     }
 
     @Test
     public void testCannotBeLoadedWithNormalGraphHopperStorageClass() {
-        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), false).create(defaultSize);
+        graph = newGHStorage(false, false);
         graph.flush();
         graph.close();
 
@@ -93,11 +109,14 @@ public void testEdgeFilter() {
 
         graph.freeze();
         CHEdgeIteratorState tmpIter = g.shortcut(3, 4);
-        tmpIter.setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
+        tmpIter.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 0);
+        tmpIter.setDistance(40);
         assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge1());
         assertEquals(EdgeIterator.NO_EDGE, tmpIter.getSkippedEdge2());
 
-        g.shortcut(0, 4).setDistance(40).setFlags(carEncoder.setAccess(0, true, true));
+        tmpIter = g.shortcut(0, 4);
+        tmpIter.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 0);
+        tmpIter.setDistance(40);
         g.setLevel(0, 1);
         g.setLevel(4, 1);
 
@@ -115,7 +134,7 @@ public void testEdgeFilter() {
     @Test
     public void testDisconnectEdge() {
         graph = createGHStorage();
-        CHGraphImpl lg = (CHGraphImpl) getGraph(graph);
+        CHGraph lg = getGraph(graph);
 
         EdgeExplorer chCarOutExplorer = lg.createEdgeExplorer(carOutFilter);
         EdgeExplorer tmpCarInExplorer = lg.createEdgeExplorer(carInFilter);
@@ -123,18 +142,19 @@ public void testDisconnectEdge() {
         EdgeExplorer baseCarOutExplorer = graph.createEdgeExplorer(carOutFilter);
 
         // only remove edges
-        long flags = carEncoder.setProperties(60, true, true);
-        long flags2 = carEncoder.setProperties(60, true, false);
         lg.edge(4, 1, 30, true);
         graph.freeze();
         CHEdgeIteratorState tmp = lg.shortcut(1, 2);
-        tmp.setDistance(10).setFlags(flags);
+        tmp.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 0);
+        tmp.setDistance(10);
         tmp.setSkippedEdges(10, 11);
         tmp = lg.shortcut(1, 0);
-        tmp.setDistance(20).setFlags(flags2);
+        tmp.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 0);
+        tmp.setDistance(20);
         tmp.setSkippedEdges(12, 13);
         tmp = lg.shortcut(3, 1);
-        tmp.setDistance(30).setFlags(flags2);
+        tmp.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 0);
+        tmp.setDistance(30);
         tmp.setSkippedEdges(14, 15);
         // create everytime a new independent iterator for disconnect method
         EdgeIterator iter = lg.createEdgeExplorer().setBaseNode(1);
@@ -166,14 +186,14 @@ public void testDisconnectEdge() {
     @Test
     public void testGetWeight() {
         graph = createGHStorage();
-        CHGraphImpl g = (CHGraphImpl) getGraph(graph);
-        assertFalse(g.edge(0, 1).isShortcut());
-        assertFalse(g.edge(1, 2).isShortcut());
+        CHGraph g = getGraph(graph);
+        assertFalse(((CHEdgeIteratorState) g.edge(0, 1)).isShortcut());
+        assertFalse(((CHEdgeIteratorState) g.edge(1, 2)).isShortcut());
 
         graph.freeze();
 
         // only remove edges
-        long flags = carEncoder.setProperties(10, true, true);
+        int flags = PrepareEncoder.getScDirMask();
         CHEdgeIteratorState sc1 = g.shortcut(0, 1);
         assertTrue(sc1.isShortcut());
         sc1.setWeight(2.001);
@@ -183,39 +203,34 @@ public void testGetWeight() {
         sc1.setWeight(Double.MAX_VALUE);
         assertTrue(Double.isInfinite(sc1.getWeight()));
 
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
+        sc1.setFlagsAndWeight(flags, 100.123);
         assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertTrue(sc1.isForward(carEncoder));
-        assertTrue(sc1.isBackward(carEncoder));
+        assertTrue(sc1.get(SC_ACCESS));
+        assertTrue(sc1.getReverse(SC_ACCESS));
 
-        flags = carEncoder.setProperties(10, false, true);
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
+        flags = PrepareEncoder.getScBwdDir();
+        sc1.setFlagsAndWeight(flags, 100.123);
         assertEquals(100.123, sc1.getWeight(), 1e-3);
-        assertFalse(sc1.isForward(carEncoder));
-        assertTrue(sc1.isBackward(carEncoder));
+        assertFalse(sc1.get(SC_ACCESS));
+        assertTrue(sc1.getReverse(SC_ACCESS));
 
         // check min weight
-        sc1.setFlags(flags);
-        sc1.setWeight(1e-5);
+        sc1.setFlagsAndWeight(flags, 1e-5);
         assertEquals(1e-3, sc1.getWeight(), 1e-10);
     }
 
     @Test
     public void testGetWeightIfAdvancedEncoder() {
         FlagEncoder customEncoder = new Bike2WeightFlagEncoder();
-        EncodingManager em = new EncodingManager(customEncoder);
+        EncodingManager em = EncodingManager.create(customEncoder);
         FastestWeighting weighting = new FastestWeighting(customEncoder);
         GraphHopperStorage ghStorage = new GraphBuilder(em).setCHGraph(weighting).create();
         ghStorage.edge(0, 2);
         ghStorage.freeze();
 
-        CHGraphImpl lg = (CHGraphImpl) ghStorage.getGraph(CHGraph.class, weighting);
+        CHGraph lg = ghStorage.getCHGraph(weighting);
         CHEdgeIteratorState sc1 = lg.shortcut(0, 1);
-        long flags = customEncoder.setProperties(10, false, true);
-        sc1.setFlags(flags);
-        sc1.setWeight(100.123);
+        sc1.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 100.123);
 
         assertEquals(100.123, lg.getEdgeIteratorState(sc1.getEdge(), sc1.getAdjNode()).getWeight(), 1e-3);
         assertEquals(100.123, lg.getEdgeIteratorState(sc1.getEdge(), sc1.getBaseNode()).getWeight(), 1e-3);
@@ -224,11 +239,28 @@ public void testGetWeightIfAdvancedEncoder() {
 
         sc1 = lg.shortcut(1, 0);
         assertTrue(sc1.isShortcut());
-        sc1.setFlags(PrepareEncoder.getScDirMask());
-        sc1.setWeight(1.011011);
+        sc1.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 1.011011);
         assertEquals(1.011011, sc1.getWeight(), 1e-3);
     }
 
+    @Test
+    public void weightAndDistanceExact() {
+        graph = createGHStorage();
+        CHGraph chGraph = getGraph(graph);
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.freeze();
+
+        // we just make up some weights and distances, they do not really have to be related to our previous edges.
+        // 1.004+1.006 = 2.09999999999. we make sure this does not become 2.09 instead of 2.10 (due to truncation)
+        double x1 = 1.004;
+        double x2 = 1.006;
+        chGraph.shortcut(0, 2, PrepareEncoder.getScFwdDir(), x1 + x2, x1 + x2, 0, 1);
+        CHEdgeIteratorState sc = chGraph.getEdgeIteratorState(2, 2);
+        assertEquals(2.01, sc.getDistance(), 1.e-6);
+        assertEquals(2.01, sc.getWeight(), 1.e-6);
+    }
+
     @Test
     public void testQueryGraph() {
         graph = createGHStorage();
@@ -252,7 +284,7 @@ public void testQueryGraph() {
         EdgeExplorer explorer = baseGraph.createEdgeExplorer();
 
         assertTrue(chGraph.getNodes() < qGraph.getNodes());
-        assertTrue(baseGraph.getNodes() == qGraph.getNodes());
+        assertEquals(baseGraph.getNodes(), qGraph.getNodes());
 
         // traverse virtual edges and normal edges but no shortcuts!
         assertEquals(GHUtility.asSet(fromRes.getClosestNode()), GHUtility.getNeighbors(explorer.setBaseNode(0)));
@@ -280,8 +312,7 @@ public void testSave_and_Freeze() throws IOException {
         graph.close();
 
         // test freeze and shortcut creation & loading
-        graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true).
-                create(defaultSize);
+        graph = newGHStorage(true, false);
         graph.edge(1, 0);
         graph.edge(8, 9);
         graph.freeze();
@@ -309,8 +340,8 @@ public void testSave_and_Freeze() throws IOException {
 
         chGraph = getGraph(graph);
         assertEquals(10, chGraph.getNodes());
-        assertEquals(2, graph.getAllEdges().length());
-        assertEquals(3, chGraph.getAllEdges().length());
+        assertEquals(2, graph.getEdges());
+        assertEquals(3, chGraph.getEdges());
         assertEquals(1, GHUtility.count(chGraph.createEdgeExplorer().setBaseNode(2)));
 
         AllCHEdgesIterator iter = chGraph.getAllEdges();
@@ -335,8 +366,8 @@ public void testSimpleShortcutCreationAndTraversal() {
         graph.edge(3, 4, 10, true);
         graph.freeze();
 
-        CHGraph lg = graph.getGraph(CHGraph.class);
-        lg.shortcut(1, 4).setWeight(3).setFlags(carEncoder.setProperties(10, true, true));
+        CHGraph lg = graph.getCHGraph();
+        lg.shortcut(1, 4).setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 3);
 
         EdgeExplorer vehicleOutExplorer = lg.createEdgeExplorer(DefaultEdgeFilter.outEdges(carEncoder));
         // iteration should result in same nodes even if reusing the iterator
@@ -351,7 +382,7 @@ public void testAddShortcutSkippedEdgesWriteRead() {
         final EdgeIteratorState edge2 = graph.edge(3, 4, 10, true);
         graph.freeze();
 
-        CHGraph lg = graph.getGraph(CHGraph.class);
+        CHGraph lg = graph.getCHGraph();
         lg.shortcut(1, 4);
 
         AllCHEdgesIterator iter = lg.getAllEdges();
@@ -371,7 +402,7 @@ public void testAddShortcutSkippedEdgesWriteRead_writeWithCHEdgeIterator() {
         final EdgeIteratorState edge2 = graph.edge(3, 4, 10, true);
         graph.freeze();
 
-        CHGraph lg = graph.getGraph(CHGraph.class);
+        CHGraph lg = graph.getCHGraph();
         CHEdgeIteratorState shortcut = lg.shortcut(1, 4);
         shortcut.setSkippedEdges(edge1.getEdge(), edge2.getEdge());
 
@@ -384,49 +415,228 @@ public void testAddShortcutSkippedEdgesWriteRead_writeWithCHEdgeIterator() {
         assertEquals(edge2.getEdge(), iter.getSkippedEdge2());
     }
 
+    @Test(expected = IllegalStateException.class)
+    public void testAddShortcut_edgeBased_throwsIfNotConfiguredForEdgeBased() {
+        graph = newGHStorage(false, false);
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.freeze();
+        addShortcut(getGraph(graph), 0, 2, true, 0, 1, 0, 1, 2);
+    }
+
+    @Test
+    public void testAddShortcut_edgeBased() {
+        // 0 -> 1 -> 2
+        graph = newGHStorage(false, true);
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 3, false);
+        graph.freeze();
+        CHGraph lg = getGraph(this.graph);
+        addShortcut(lg, 0, 2, true, 0, 1, 0, 1, 4);
+        AllCHEdgesIterator iter = lg.getAllEdges();
+        iter.next();
+        iter.next();
+        iter.next();
+        assertEquals(0, iter.getOrigEdgeFirst());
+        assertEquals(1, iter.getOrigEdgeLast());
+    }
+
+    @Test
+    public void testGetEdgeIterator() {
+        graph = newGHStorage(false, true);
+        graph.edge(0, 1, 1, false);
+        graph.edge(1, 2, 1, false);
+        graph.freeze();
+        CHGraph lg = getGraph(graph);
+        addShortcut(lg, 0, 2, true, 0, 1, 0, 1, 2);
+
+        CHEdgeIteratorState sc02 = lg.getEdgeIteratorState(2, 2);
+        assertNotNull(sc02);
+        assertEquals(0, sc02.getBaseNode());
+        assertEquals(2, sc02.getAdjNode());
+        assertEquals(2, sc02.getEdge());
+        assertEquals(0, sc02.getSkippedEdge1());
+        assertEquals(1, sc02.getSkippedEdge2());
+        assertEquals(0, sc02.getOrigEdgeFirst());
+        assertEquals(1, sc02.getOrigEdgeLast());
+
+        CHEdgeIteratorState sc20 = lg.getEdgeIteratorState(2, 0);
+        assertNotNull(sc20);
+        assertEquals(2, sc20.getBaseNode());
+        assertEquals(0, sc20.getAdjNode());
+        assertEquals(2, sc20.getEdge());
+        // note these are not stateful! i.e. even though we are looking at the edge 2->0 the first skipped/orig edge
+        // is still edge 0 and the second skipped/last orig edge is edge 1
+        assertEquals(0, sc20.getSkippedEdge1());
+        assertEquals(1, sc20.getSkippedEdge2());
+        assertEquals(0, sc20.getOrigEdgeFirst());
+        assertEquals(1, sc20.getOrigEdgeLast());
+    }
+
+    private void addShortcut(CHGraph chGraph, int from, int to, boolean fwd, int firstOrigEdge, int lastOrigEdge,
+                             int skipEdge1, int skipEdge2, int distance) {
+        CHEdgeIteratorState shortcut = chGraph.shortcut(from, to);
+        shortcut.setFlagsAndWeight(fwd ? PrepareEncoder.getScFwdDir() : PrepareEncoder.getScBwdDir(), 0);
+        shortcut.setFirstAndLastOrigEdges(firstOrigEdge, lastOrigEdge).setSkippedEdges(skipEdge1, skipEdge2).setDistance(distance);
+    }
+
     @Test
     public void testShortcutCreationAndAccessForManyVehicles() {
         FlagEncoder tmpCar = new CarFlagEncoder();
         FlagEncoder tmpBike = new Bike2WeightFlagEncoder();
-        EncodingManager em = new EncodingManager(tmpCar, tmpBike);
+        EncodingManager em = EncodingManager.create(tmpCar, tmpBike);
         List<Weighting> chWeightings = new ArrayList<>();
         chWeightings.add(new FastestWeighting(tmpCar));
         chWeightings.add(new FastestWeighting(tmpBike));
+        BooleanEncodedValue tmpCarAccessEnc = tmpCar.getAccessEnc();
 
         graph = new GraphHopperStorage(chWeightings, new RAMDirectory(), em, false, new GraphExtension.NoOpExtension()).create(1000);
-        graph.edge(0, 1).setDistance(10).setFlags(tmpCar.setProperties(100, true, true) | tmpBike.setProperties(10, true, true));
-        graph.edge(1, 2).setDistance(10).setFlags(tmpCar.setProperties(100, true, true) | tmpBike.setProperties(10, true, true));
+        IntsRef edgeFlags = GHUtility.setProperties(em.createEdgeFlags(), tmpCar, 100, true, false);
+        graph.edge(0, 1).setDistance(10).setFlags(GHUtility.setProperties(edgeFlags, tmpBike, 10, true, true));
+        graph.edge(1, 2).setDistance(10).setFlags(edgeFlags);
 
         graph.freeze();
 
-        CHGraph carCHGraph = graph.getGraph(CHGraph.class, chWeightings.get(0));
+        CHGraph carCHGraph = graph.getCHGraph(chWeightings.get(0));
         // enable forward directions for car
-        EdgeIteratorState carSC02 = carCHGraph.shortcut(0, 2).setWeight(10).setFlags(PrepareEncoder.getScFwdDir()).setDistance(20);
+        CHEdgeIteratorState carSC02 = carCHGraph.shortcut(0, 2);
+        carSC02.setFlagsAndWeight(PrepareEncoder.getScFwdDir(), 10);
+        carSC02.setDistance(20);
 
-        CHGraph bikeCHGraph = graph.getGraph(CHGraph.class, chWeightings.get(1));
+        CHGraph bikeCHGraph = graph.getCHGraph(chWeightings.get(1));
+        CHEdgeIteratorState bikeSC02 = bikeCHGraph.shortcut(0, 2);
         // enable both directions for bike
-        EdgeIteratorState bikeSC02 = bikeCHGraph.shortcut(0, 2).setWeight(10).setFlags(PrepareEncoder.getScDirMask()).setDistance(20);
+        bikeSC02.setFlagsAndWeight(PrepareEncoder.getScDirMask(), 10);
+        bikeSC02.setDistance(20);
 
         // assert car CH graph
-        assertTrue(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isForward(tmpCar));
-        assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isBackward(tmpCar));
+        assertTrue(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).get(tmpCarAccessEnc));
+        assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).getReverse(tmpCarAccessEnc));
+
+        BooleanEncodedValue tmpBikeAccessEnc = tmpBike.getAccessEnc();
 
         // throw exception for wrong encoder
         try {
-            assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).isForward(tmpBike));
-            assertTrue(false);
+            assertFalse(carCHGraph.getEdgeIteratorState(carSC02.getEdge(), 2).get(tmpBikeAccessEnc));
+            fail();
         } catch (AssertionError ex) {
         }
 
         // assert bike CH graph
-        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isForward(tmpBike));
-        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isBackward(tmpBike));
+        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).get(tmpBikeAccessEnc));
+        assertTrue(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).getReverse(tmpBikeAccessEnc));
 
         // throw exception for wrong encoder
         try {
-            assertFalse(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).isBackward(tmpCar));
-            assertTrue(false);
+            assertFalse(bikeCHGraph.getEdgeIteratorState(bikeSC02.getEdge(), 2).getReverse(tmpCarAccessEnc));
+            fail();
         } catch (AssertionError ex) {
         }
     }
+
+    @Test(expected = IllegalStateException.class)
+    public void testLoadingWithWrongWeighting_node_throws() {
+        testLoadingWithWrongWeighting_throws(false);
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testLoadingWithWrongWeighting_edge_throws() {
+        testLoadingWithWrongWeighting_throws(true);
+    }
+
+    private void testLoadingWithWrongWeighting_throws(boolean edgeBased) {
+        // we start with one weighting
+        GraphHopperStorage ghStorage = newGHStorage(new GHDirectory(defaultGraphLoc, DAType.RAM_STORE), false, edgeBased);
+        ghStorage.create(defaultSize);
+        ghStorage.flush();
+
+        // but then configure another weighting and try to load the graph from disk -> error
+        GraphHopperStorage newGHStorage = createStorageWithWeightings(edgeBased, new ShortestWeighting(carEncoder));
+        newGHStorage.loadExisting();
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testLoadingWithExtraWeighting_throws() {
+        // we start with one weighting
+        GraphHopperStorage ghStorage = newGHStorage(new GHDirectory(defaultGraphLoc, DAType.RAM_STORE), false);
+        ghStorage.create(defaultSize);
+        ghStorage.flush();
+
+        // but then add an additional weighting and try to load the graph from disk -> error
+        GraphHopperStorage newGHStorage = createStorageWithWeightings(false,
+                new FastestWeighting(carEncoder), new ShortestWeighting(carEncoder));
+        newGHStorage.loadExisting();
+    }
+
+    @Test
+    public void testLoadingWithLessWeightings_node_works() {
+        testLoadingWithLessWeightings_works(false);
+    }
+
+    @Test
+    public void testLoadingWithLessWeightings_edge_works() {
+        testLoadingWithLessWeightings_works(true);
+    }
+
+    private void testLoadingWithLessWeightings_works(boolean edgeBased) {
+        // we start with a gh storage with two ch weightings and flush it to disk
+        FastestWeighting weighting1 = new FastestWeighting(carEncoder);
+        ShortestWeighting weighting2 = new ShortestWeighting(carEncoder);
+        GraphHopperStorage originalStorage = createStorageWithWeightings(edgeBased, weighting1, weighting2);
+        originalStorage.create(defaultSize);
+        originalStorage.flush();
+
+        // now we create a new storage but only use one of the weightings, which should be ok
+        GraphHopperStorage smallStorage = createStorageWithWeightings(edgeBased, weighting1);
+        smallStorage.loadExisting();
+        assertEquals(edgeBased ? 0 : 1, smallStorage.getNodeBasedCHWeightings().size());
+        assertEquals(edgeBased ? 1 : 0, smallStorage.getEdgeBasedCHWeightings().size());
+        smallStorage.flush();
+
+        // now we create yet another storage that uses both weightings again, which still works
+        GraphHopperStorage fullStorage = createStorageWithWeightings(edgeBased, weighting1, weighting2);
+        fullStorage.loadExisting();
+        assertEquals(edgeBased ? 0 : 2, fullStorage.getNodeBasedCHWeightings().size());
+        assertEquals(edgeBased ? 2 : 0, fullStorage.getEdgeBasedCHWeightings().size());
+        fullStorage.flush();
+    }
+
+    @Test
+    public void testLoadingWithLessWeightings_nodeAndEdge_works() {
+        // we start with a gh storage with two node-based and one edge-based ch weighting and flush it to disk
+        FastestWeighting weighting1 = new FastestWeighting(carEncoder);
+        ShortestWeighting weighting2 = new ShortestWeighting(carEncoder);
+        GraphHopperStorage originalStorage = createStorageWithWeightings(
+                Arrays.<Weighting>asList(weighting1, weighting2),
+                Arrays.<Weighting>asList(weighting2));
+        originalStorage.create(defaultSize);
+        originalStorage.flush();
+
+        // now we create a new storage but only use the edge weighting, which should be ok
+        GraphHopperStorage edgeStorage = createStorageWithWeightings(true, weighting2);
+        edgeStorage.loadExisting();
+        assertEquals(0, edgeStorage.getNodeBasedCHWeightings().size());
+        assertEquals(1, edgeStorage.getEdgeBasedCHWeightings().size());
+        edgeStorage.flush();
+
+        // now we create yet another storage that uses one of the node and the edge weighting, which still works
+        GraphHopperStorage mixedStorage = createStorageWithWeightings(
+                Arrays.<Weighting>asList(weighting1),
+                Arrays.<Weighting>asList(weighting2));
+        mixedStorage.loadExisting();
+        assertEquals(1, mixedStorage.getNodeBasedCHWeightings().size());
+        assertEquals(1, mixedStorage.getNodeBasedCHWeightings().size());
+        mixedStorage.flush();
+    }
+
+    private GraphHopperStorage createStorageWithWeightings(boolean edgeBased, Weighting... weightings) {
+        List<Weighting> nodeBasedCHWeightings = edgeBased ? Collections.<Weighting>emptyList() : Arrays.asList(weightings);
+        List<Weighting> edgeBasedCHWeightings = edgeBased ? Arrays.asList(weightings) : Collections.<Weighting>emptyList();
+        return createStorageWithWeightings(nodeBasedCHWeightings, edgeBasedCHWeightings);
+    }
+
+    private GraphHopperStorage createStorageWithWeightings(List<Weighting> nodeBasedCHWeightings, List<Weighting> edgeBasedCHWeightings) {
+        return new GraphHopperStorage(nodeBasedCHWeightings, edgeBasedCHWeightings,
+                new GHDirectory(defaultGraphLoc, DAType.RAM_STORE), encodingManager, false, new GraphExtension.NoOpExtension());
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
index ffe60f47fd..901d2fcaf2 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageForDataFlagEncoderTest.java
@@ -5,16 +5,19 @@
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.DataFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.EncodingManager.Access;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.parsers.OSMMaxHeightParser;
+import com.graphhopper.routing.util.parsers.OSMMaxWeightParser;
+import com.graphhopper.routing.util.parsers.OSMMaxWidthParser;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.PMap;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.io.Closeable;
 import java.io.File;
-import java.util.Arrays;
 
 import static org.junit.Assert.*;
 
@@ -23,7 +26,6 @@
  */
 public class GraphHopperStorageForDataFlagEncoderTest {
     private final String locationParent = "./target/graphstorage";
-    private int defaultSize = 100;
     private String defaultGraphLoc = "./target/graphstorage/default";
     private GraphHopperStorage graph;
 
@@ -33,11 +35,9 @@
 
     public GraphHopperStorageForDataFlagEncoderTest() {
         properties = new PMap();
-        properties.put("store_height", true);
-        properties.put("store_weight", true);
-        properties.put("store_width", false);
         encoder = new DataFlagEncoder(properties);
-        encodingManager = new EncodingManager(Arrays.asList(encoder), 8);
+        encodingManager = GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).
+                add(new OSMMaxWidthParser()).add(new OSMMaxHeightParser()).add(new OSMMaxWeightParser()).add(encoder).build();
     }
 
     @Before
@@ -47,7 +47,7 @@ public void setUp() {
 
     @After
     public void tearDown() {
-        Helper.close((Closeable) graph);
+        Helper.close(graph);
         Helper.removeDir(new File(locationParent));
     }
 
@@ -63,7 +63,8 @@ public void testStorageProperties() {
         graph.edge(0, 1, 1, true);
         AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
         AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
-        graph.getEdgeIteratorState(0, 1).setFlags(encoder.handleWayTags(way_0_1, 1, 0));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay().put(encoder.toString(), Access.WAY);
+        graph.getEdgeIteratorState(0, 1).setFlags(encodingManager.handleWayTags(way_0_1, map, 0));
 
         // 1-2
         ReaderWay way_1_2 = new ReaderWay(28l);
@@ -72,7 +73,7 @@ public void testStorageProperties() {
 
         graph.edge(1, 2, 1, true);
         AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.02, 0.02);
-        graph.getEdgeIteratorState(1, 2).setFlags(encoder.handleWayTags(way_1_2, 1, 0));
+        graph.getEdgeIteratorState(1, 2).setFlags(encodingManager.handleWayTags(way_1_2, map, 0));
 
         // 2-0
         ReaderWay way_2_0 = new ReaderWay(29l);
@@ -80,7 +81,7 @@ public void testStorageProperties() {
         way_2_0.setTag("maxwidth", "5");
 
         graph.edge(2, 0, 1, true);
-        graph.getEdgeIteratorState(2, 0).setFlags(encoder.handleWayTags(way_2_0, 1, 0));
+        graph.getEdgeIteratorState(2, 0).setFlags(encodingManager.handleWayTags(way_2_0, map, 0));
 
         graph.flush();
         graph.close();
@@ -92,10 +93,5 @@ public void testStorageProperties() {
 
         FlagEncoder flagEncoder = em.fetchEdgeEncoders().get(0);
         assertTrue(flagEncoder instanceof DataFlagEncoder);
-
-        DataFlagEncoder dataFlagEncoder = (DataFlagEncoder)flagEncoder;
-        assertTrue(dataFlagEncoder.isStoreHeight());
-        assertTrue(dataFlagEncoder.isStoreWeight());
-        assertFalse(dataFlagEncoder.isStoreWidth());
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageLMTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageLMTest.java
index b1bf9fae5a..e7fdb3c551 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageLMTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageLMTest.java
@@ -5,6 +5,7 @@
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.EncodingManager.Access;
 import com.graphhopper.util.Helper;
 import org.junit.Test;
 
@@ -20,7 +21,7 @@ public void testLoad() {
         String defaultGraphLoc = "./target/ghstorage_lm";
         Helper.removeDir(new File(defaultGraphLoc));
         CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(carFlagEncoder);
+        EncodingManager encodingManager = EncodingManager.create(carFlagEncoder);
         GraphHopperStorage graph = new GraphBuilder(encodingManager).setStore(true).
                 setLocation(defaultGraphLoc).create();
 
@@ -32,7 +33,7 @@ public void testLoad() {
         graph.edge(0, 1, 1, true);
         AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.00, 0.00);
         AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
-        graph.getEdgeIteratorState(0, 1).setFlags(carFlagEncoder.handleWayTags(way_0_1, 1, 0));
+        graph.getEdgeIteratorState(0, 1).setFlags(carFlagEncoder.handleWayTags(encodingManager.createEdgeFlags(), way_0_1, Access.WAY, 0));
 
         // 1-2
         ReaderWay way_1_2 = new ReaderWay(28l);
@@ -41,7 +42,7 @@ public void testLoad() {
 
         graph.edge(1, 2, 1, true);
         AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.02, 0.02);
-        graph.getEdgeIteratorState(1, 2).setFlags(carFlagEncoder.handleWayTags(way_1_2, 1, 0));
+        graph.getEdgeIteratorState(1, 2).setFlags(carFlagEncoder.handleWayTags(encodingManager.createEdgeFlags(), way_1_2, Access.WAY, 0));
 
         graph.flush();
         graph.close();
diff --git a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
index c4dcd24210..7dc9ce4898 100644
--- a/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
+++ b/core/src/test/java/com/graphhopper/storage/GraphHopperStorageTest.java
@@ -23,6 +23,7 @@
 
 import java.io.IOException;
 
+import static com.graphhopper.util.EdgeIteratorState.REVERSE_STATE;
 import static org.junit.Assert.*;
 
 /**
@@ -43,17 +44,14 @@ protected GraphHopperStorage newGHStorage(Directory dir, boolean enabled3D) {
     }
 
     @Test
-    public void testNoCreateCalled() throws IOException {
-        GraphHopperStorage gs = new GraphBuilder(encodingManager).build();
-        try {
-            ((BaseGraph) gs.getGraph(Graph.class)).ensureNodeIndex(123);
-            assertFalse("AssertionError should be raised", true);
+    public void testNoCreateCalled() {
+        try (GraphHopperStorage gs = new GraphBuilder(encodingManager).build()) {
+            ((BaseGraph) gs.getBaseGraph()).ensureNodeIndex(123);
+            fail("AssertionError should be raised");
         } catch (AssertionError err) {
-            assertTrue(true);
+            // ok
         } catch (Exception ex) {
-            assertFalse("AssertionError should be raised, but was " + ex.toString(), true);
-        } finally {
-            gs.close();
+            fail("AssertionError should be raised, but was " + ex.toString());
         }
     }
 
@@ -150,7 +148,7 @@ protected void checkGraph(Graph g) {
     @Test
     public void internalDisconnect() {
         GraphHopperStorage storage = createGHStorage();
-        BaseGraph graph = (BaseGraph) storage.getGraph(Graph.class);
+        BaseGraph graph = (BaseGraph) storage.getBaseGraph();
         EdgeIteratorState iter0 = graph.edge(0, 1, 10, true);
         EdgeIteratorState iter2 = graph.edge(1, 2, 10, true);
         EdgeIteratorState iter3 = graph.edge(0, 3, 10, true);
@@ -160,8 +158,7 @@ public void internalDisconnect() {
         assertEquals(GHUtility.asSet(3, 1), GHUtility.getNeighbors(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(2, 0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
         // remove edge "1-2" but only from 1 not from 2
-        graph.edgeAccess.internalEdgeDisconnect(iter2.getEdge(), -1,
-                iter2.getBaseNode(), iter2.getAdjNode());
+        graph.edgeAccess.internalEdgeDisconnect(iter2.getEdge(), -1, iter2.getBaseNode());
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
         assertEquals(GHUtility.asSet(1), GHUtility.getNeighbors(explorer.setBaseNode(2)));
         // let 0 unchanged -> no side effects
@@ -169,7 +166,7 @@ public void internalDisconnect() {
 
         // remove edge "0-1" but only from 0
         graph.edgeAccess.internalEdgeDisconnect(iter0.getEdge(), (long) iter3.getEdge() * graph.edgeEntryBytes,
-                iter0.getBaseNode(), iter0.getAdjNode());
+                iter0.getBaseNode());
         assertEquals(GHUtility.asSet(3), GHUtility.getNeighbors(explorer.setBaseNode(0)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(3)));
         assertEquals(GHUtility.asSet(0), GHUtility.getNeighbors(explorer.setBaseNode(1)));
@@ -181,7 +178,7 @@ public void testEnsureSize() {
         Directory dir = new RAMDirectory();
         graph = newGHStorage(dir, false).create(defaultSize);
         int roughEdgeRowLength = 4 * 8;
-        int testIndex = dir.find("edges").getSegmentSize() * 3 / roughEdgeRowLength;
+        int testIndex = dir.find("edges", DAType.RAM_INT).getSegmentSize() * 3 / roughEdgeRowLength;
         // we need a big node index to trigger multiple segments, but low enough to avoid OOM
         graph.edge(0, testIndex, 10, true);
 
@@ -194,7 +191,7 @@ public void testBigDataEdge() {
         Directory dir = new RAMDirectory();
         GraphHopperStorage graph = new GraphHopperStorage(dir, encodingManager, false, new GraphExtension.NoOpExtension());
         graph.create(defaultSize);
-        ((BaseGraph) graph.getGraph(Graph.class)).setEdgeCount(Integer.MAX_VALUE / 2);
+        ((BaseGraph) graph.getBaseGraph()).setEdgeCount(Integer.MAX_VALUE / 2);
         assertTrue(graph.getAllEdges().next());
         graph.close();
     }
@@ -209,7 +206,7 @@ public void testDoThrowExceptionIfDimDoesNotMatch() {
         graph = newGHStorage(new RAMDirectory(defaultGraphLoc, true), true);
         try {
             graph.loadExisting();
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
         }
     }
@@ -217,10 +214,70 @@ public void testDoThrowExceptionIfDimDoesNotMatch() {
     @Test
     public void testIdentical() {
         GraphHopperStorage store = new GraphHopperStorage(new RAMDirectory(), encodingManager, true, new GraphExtension.NoOpExtension());
-        assertEquals(store.getNodes(), store.getGraph(Graph.class).getNodes());
-        assertEquals(store.getAllEdges().length(), store.getGraph(Graph.class).getAllEdges().length());
+        assertEquals(store.getNodes(), store.getBaseGraph().getNodes());
+        assertEquals(store.getAllEdges().length(), store.getBaseGraph().getAllEdges().length());
+    }
+
+    @Test
+    public void testMultipleDecoupledEdges() {
+        // a typical usage where we create independent EdgeIteratorState's BUT due to the IntsRef reference they are no more independent
+        GraphHopperStorage storage = createGHStorage();
+        Graph graph = storage.getBaseGraph();
+        graph.edge(0, 1, 10, true);
+        graph.edge(1, 2, 10, true);
+
+        EdgeIteratorState edge0 = graph.getEdgeIteratorState(0, Integer.MIN_VALUE);
+        EdgeIteratorState edge1 = graph.getEdgeIteratorState(1, Integer.MIN_VALUE);
+        edge0.set(carAccessEnc, true).setReverse(carAccessEnc, false);
+        edge1.set(carAccessEnc, false).setReverse(carAccessEnc, true);
+
+        assertFalse(edge1.get(carAccessEnc));
+        assertTrue(edge1.getReverse(carAccessEnc));
+
+        // obviously this should pass but as the reference is shared and freshFlags=false the edge1 flags are returned!
+        // So we do not set the reference for _setFlags but just the value
+        // A better solution would be if we do not allow to create IntsRef outside of the EdgeIterator API
+        assertTrue(edge0.get(carAccessEnc));
+        assertFalse(edge0.getReverse(carAccessEnc));
+    }
+
+    @Test
+    public void testInternalReverse() {
+        GraphHopperStorage storage = createGHStorage();
+        EdgeIteratorState edge = storage.edge(1, 2);
+        assertFalse(edge.get(REVERSE_STATE));
+        assertTrue(edge.getReverse(REVERSE_STATE));
+        edge = storage.getEdgeIteratorState(edge.getEdge(), Integer.MIN_VALUE);
+        assertFalse(edge.get(REVERSE_STATE));
+
+        edge = storage.getEdgeIteratorState(edge.getEdge(), 1);
+        assertTrue(edge.get(REVERSE_STATE));
+        assertFalse(edge.getReverse(REVERSE_STATE));
     }
 
+    @Test
+    public void testDecoupledEdgeIteratorStates() {
+        GraphHopperStorage storage = createGHStorage();
+        Graph graph = storage.getBaseGraph();
+        IntsRef ref = encodingManager.createEdgeFlags();
+        ref.ints[0] = 12;
+        graph.edge(1, 2, 10, true).setFlags(ref);
+        ref.ints[0] = 13;
+        graph.edge(1, 3, 10, true).setFlags(ref);
+
+        EdgeIterator iter = graph.createEdgeExplorer().setBaseNode(1);
+        assertTrue(iter.next());
+        EdgeIteratorState edge1 = iter.detach(false);
+
+        assertTrue(iter.next());
+        ref.ints[0] = 44;
+        iter.setFlags(ref);
+
+        assertEquals(44, iter.getFlags().ints[0]);
+        assertEquals(13, edge1.getFlags().ints[0]);
+    }
+
+    @Test
     public void testAdditionalEdgeField() {
         GraphExtension extStorage = new GraphExtension() {
             @Override
diff --git a/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java b/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
new file mode 100644
index 0000000000..840434c7dc
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/storage/ShortcutUnpackerTest.java
@@ -0,0 +1,338 @@
+package com.graphhopper.storage;
+
+import com.carrotsearch.hppc.DoubleArrayList;
+import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.routing.ch.PrepareEncoder;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.MotorcycleFlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.TurnWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.util.EdgeIteratorState;
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import static org.junit.Assert.assertEquals;
+
+@RunWith(Parameterized.class)
+public class ShortcutUnpackerTest {
+    private final static int PREV_EDGE = 12;
+    private final static int NEXT_EDGE = 13;
+    private final boolean edgeBased;
+    private FlagEncoder encoder;
+    private Weighting weighting;
+    private GraphHopperStorage graph;
+    private CHGraph chGraph;
+    private TurnCostExtension turnCostExtension;
+
+    @Parameterized.Parameters(name = "{0}")
+    public static Object[] params() {
+        return new Object[]{
+                TraversalMode.NODE_BASED,
+                TraversalMode.EDGE_BASED
+        };
+    }
+
+    public ShortcutUnpackerTest(TraversalMode traversalMode) {
+        this.edgeBased = traversalMode.isEdgeBased();
+    }
+
+    @Before
+    public void init() {
+        // use motorcycle to be able to set different fwd/bwd speeds
+        encoder = new MotorcycleFlagEncoder(5, 5, 10);
+        EncodingManager encodingManager = EncodingManager.create(encoder);
+        weighting = new FastestWeighting(encoder);
+        graph = new GraphBuilder(encodingManager).setCHGraph(weighting).setEdgeBasedCH(edgeBased).create();
+        chGraph = graph.getCHGraph(weighting);
+        if (edgeBased) {
+            turnCostExtension = (TurnCostExtension) graph.getExtension();
+        }
+    }
+
+    @Test
+    public void testUnpacking() {
+        // 0-1-2-3-4-5-6
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(4, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(5, 6, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+        shortcut(0, 2, 0, 1, 0, 1);
+        shortcut(2, 4, 2, 3, 2, 3);
+        shortcut(4, 6, 4, 5, 4, 5);
+        shortcut(2, 6, 7, 8, 2, 5);
+        shortcut(0, 6, 6, 9, 0, 5);
+
+        {
+            // unpack the shortcut 0->6, traverse original edges in 'forward' order (from node 0 to 6)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 6, false, PREV_EDGE);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.baseNodes);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 5, 6), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            if (edgeBased) {
+                assertEquals(IntArrayList.from(PREV_EDGE, 0, 1, 2, 3, 4), visitor.prevOrNextEdgeIds);
+            }
+        }
+
+        {
+            // unpack the shortcut 0->6, traverse original edges in 'backward' order (from node 6 to 0)
+            // note that traversing in backward order does not mean the original edges are read in reverse (e.g. fwd speed still applies)
+            // -> only the order of the original edges is reversed
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 6, true, PREV_EDGE);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.baseNodes);
+            assertEquals(IntArrayList.from(6, 5, 4, 3, 2, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            if (edgeBased) {
+                assertEquals(IntArrayList.from(4, 3, 2, 1, 0, PREV_EDGE), visitor.prevOrNextEdgeIds);
+            }
+        }
+
+        {
+            // unpack the shortcut 6<-0 in reverse, i.e. with 6 as base node. traverse original edges in 'forward' order (from node 6 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, false, NEXT_EDGE);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(6, 5, 4, 3, 2, 1), visitor.baseNodes);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            if (edgeBased) {
+                assertEquals(IntArrayList.from(NEXT_EDGE, 5, 4, 3, 2, 1), visitor.prevOrNextEdgeIds);
+            }
+        }
+
+        {
+            // unpack the shortcut 6<-0 in reverse, i.e. with 60as base node. traverse original edges in 'backward' order (from node 0 to 6)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, true, NEXT_EDGE);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 5, 6), visitor.baseNodes);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            if (edgeBased) {
+                assertEquals(IntArrayList.from(1, 2, 3, 4, 5, NEXT_EDGE), visitor.prevOrNextEdgeIds);
+            }
+        }
+    }
+
+    @Test
+    public void loopShortcut() {
+        Assume.assumeTrue("loop shortcuts only exist for edge-based CH", edgeBased);
+        //     3
+        //    / \
+        //   2   4
+        //    \ /
+        // 0 - 1 - 5
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(4, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.edge(1, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+        shortcut(1, 3, 1, 2, 1, 2);
+        shortcut(3, 1, 3, 4, 3, 4);
+        shortcut(1, 1, 6, 7, 1, 4);
+        shortcut(0, 1, 0, 8, 0, 4);
+        shortcut(0, 5, 9, 5, 0, 5);
+
+        {
+            // unpack the shortcut 0->5, traverse original edges in 'forward' order (from node 0 to 5)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 5, false, PREV_EDGE);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 1), visitor.baseNodes);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 1, 5), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            assertEquals(IntArrayList.from(PREV_EDGE, 0, 1, 2, 3, 4), visitor.prevOrNextEdgeIds);
+        }
+
+        {
+            // unpack the shortcut 0->5, traverse original edges in 'backward' order (from node 5 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 5, true, PREV_EDGE);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 4, 3, 2, 1, 0), visitor.baseNodes);
+            assertEquals(IntArrayList.from(5, 1, 4, 3, 2, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            assertEquals(IntArrayList.from(4, 3, 2, 1, 0, PREV_EDGE), visitor.prevOrNextEdgeIds);
+        }
+
+        {
+            // unpack the shortcut 5<-0, traverse original edges in 'forward' order (from node 5 to 0)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, false, NEXT_EDGE);
+            assertEquals(IntArrayList.from(5, 4, 3, 2, 1, 0), visitor.edgeIds);
+            assertEquals(IntArrayList.from(5, 1, 4, 3, 2, 1), visitor.baseNodes);
+            assertEquals(IntArrayList.from(1, 4, 3, 2, 1, 0), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            assertEquals(IntArrayList.from(NEXT_EDGE, 5, 4, 3, 2, 1), visitor.prevOrNextEdgeIds);
+        }
+
+        {
+            // unpack the shortcut 5<-0, traverse original edges in 'backward' order (from node 0 to 5)
+            TestVisitor visitor = new TestVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, true, NEXT_EDGE);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 5), visitor.edgeIds);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 1, 5), visitor.baseNodes);
+            assertEquals(IntArrayList.from(0, 1, 2, 3, 4, 1), visitor.adjNodes);
+            assertEquals(DoubleArrayList.from(0.06, 0.06, 0.06, 0.06, 0.06, 0.06), visitor.weights);
+            assertEquals(DoubleArrayList.from(1, 1, 1, 1, 1, 1), visitor.distances);
+            assertEquals(DoubleArrayList.from(60, 60, 60, 60, 60, 60), visitor.times);
+            assertEquals(IntArrayList.from(1, 2, 3, 4, 5, NEXT_EDGE), visitor.prevOrNextEdgeIds);
+        }
+    }
+
+    @Test
+    public void withTurnWeighting() {
+        Assume.assumeTrue(edgeBased);
+        //      2 5 3 2 1 4 6      turn costs ->
+        // prev 0-1-2-3-4-5-6 next
+        //      1 0 1 4 2 3 2      turn costs <-
+        DecimalEncodedValue speedEnc = encoder.getAverageSpeedEnc();
+        double fwdSpeed = 60;
+        double bwdSpeed = 30;
+        EdgeIteratorState edge0 = graph.edge(0, 1, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge1 = graph.edge(1, 2, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge2 = graph.edge(2, 3, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge3 = graph.edge(3, 4, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge4 = graph.edge(4, 5, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        EdgeIteratorState edge5 = graph.edge(5, 6, 1, true).set(speedEnc, fwdSpeed).setReverse(speedEnc, bwdSpeed);
+        graph.freeze();
+
+        // turn costs ->
+        turnCostExtension.addTurnInfo(PREV_EDGE, 0, edge0.getEdge(), encoder.getTurnFlags(false, 2));
+        addTurnCost(edge0, edge1, 1, 5);
+        addTurnCost(edge1, edge2, 2, 3);
+        addTurnCost(edge2, edge3, 3, 2);
+        addTurnCost(edge3, edge4, 4, 1);
+        addTurnCost(edge4, edge5, 5, 4);
+        turnCostExtension.addTurnInfo(edge5.getEdge(), 6, NEXT_EDGE, encoder.getTurnFlags(false, 6));
+        // turn costs <-
+        turnCostExtension.addTurnInfo(NEXT_EDGE, 6, edge5.getEdge(), encoder.getTurnFlags(false, 2));
+        addTurnCost(edge5, edge4, 5, 3);
+        addTurnCost(edge4, edge3, 4, 2);
+        addTurnCost(edge3, edge2, 3, 4);
+        addTurnCost(edge2, edge1, 2, 1);
+        addTurnCost(edge1, edge0, 1, 0);
+        turnCostExtension.addTurnInfo(edge0.getEdge(), 0, PREV_EDGE, encoder.getTurnFlags(false, 1));
+
+        shortcut(0, 2, 0, 1, 0, 1);
+        shortcut(2, 4, 2, 3, 2, 3);
+        shortcut(4, 6, 4, 5, 4, 5);
+        shortcut(2, 6, 7, 8, 2, 5);
+        shortcut(0, 6, 6, 9, 0, 5);
+
+        {
+            // unpack the shortcut 0->6, traverse original edges in 'forward' order (from node 0 to 6)
+            TurnWeightingVisitor visitor = new TurnWeightingVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 6, false, PREV_EDGE);
+            assertEquals("wrong weight", 6 * 0.06 + 17, visitor.weight, 1.e-3);
+            assertEquals("wrong time", (6 * 60 + 17000), visitor.time);
+        }
+
+        {
+            // unpack the shortcut 0->6, traverse original edges in 'backward' order (from node 6 to 0)
+            TurnWeightingVisitor visitor = new TurnWeightingVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesFwd(10, 6, true, PREV_EDGE);
+            assertEquals("wrong weight", 6 * 0.06 + 17, visitor.weight, 1.e-3);
+            assertEquals("wrong time", (6 * 60 + 17000), visitor.time);
+        }
+
+        {
+            // unpack the shortcut 6<-0, traverse original edges in 'forward' order (from node 6 to 0)
+            TurnWeightingVisitor visitor = new TurnWeightingVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, false, NEXT_EDGE);
+            assertEquals("wrong weight", 6 * 0.06 + 21, visitor.weight, 1.e-3);
+            assertEquals("wrong time", (6 * 60 + 21000), visitor.time);
+        }
+
+        {
+            // unpack the shortcut 6<-0, traverse original edges in 'backward' order (from node 0 to 6)
+            TurnWeightingVisitor visitor = new TurnWeightingVisitor();
+            new ShortcutUnpacker(chGraph, visitor, edgeBased).visitOriginalEdgesBwd(10, 0, true, NEXT_EDGE);
+            assertEquals("wrong weight", 6 * 0.06 + 21, visitor.weight, 1.e-3);
+            assertEquals("wrong time", (6 * 60 + 21000), visitor.time);
+        }
+    }
+
+    private void addTurnCost(EdgeIteratorState inEdge, EdgeIteratorState outEdge, int viaNode, double costs) {
+        turnCostExtension.addTurnInfo(inEdge.getEdge(), viaNode, outEdge.getEdge(), encoder.getTurnFlags(false, costs));
+    }
+
+    private void shortcut(int baseNode, int adjNode, int skip1, int skip2, int origFirst, int origLast) {
+        // shortcut weight/distance is not important for us here
+        double weight = 1;
+        double distance = 1;
+        if (edgeBased) {
+            chGraph.shortcutEdgeBased(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2, origFirst, origLast);
+        } else {
+            chGraph.shortcut(baseNode, adjNode, PrepareEncoder.getScFwdDir(), weight, distance, skip1, skip2);
+        }
+    }
+
+    private class TestVisitor implements ShortcutUnpacker.Visitor {
+        private final IntArrayList edgeIds = new IntArrayList();
+        private final IntArrayList adjNodes = new IntArrayList();
+        private final IntArrayList baseNodes = new IntArrayList();
+        private final IntArrayList prevOrNextEdgeIds = new IntArrayList();
+        private final DoubleArrayList weights = new DoubleArrayList();
+        private final DoubleArrayList distances = new DoubleArrayList();
+        private final DoubleArrayList times = new DoubleArrayList();
+
+        @Override
+        public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+            edgeIds.add(edge.getEdge());
+            baseNodes.add(edge.getBaseNode());
+            adjNodes.add(edge.getAdjNode());
+            weights.add(weighting.calcWeight(edge, reverse, prevOrNextEdgeId));
+            distances.add(edge.getDistance());
+            times.add(weighting.calcMillis(edge, reverse, prevOrNextEdgeId));
+            prevOrNextEdgeIds.add(prevOrNextEdgeId);
+        }
+    }
+
+    private class TurnWeightingVisitor implements ShortcutUnpacker.Visitor {
+        private final TurnWeighting turnWeighting = new TurnWeighting(weighting, turnCostExtension);
+        private long time = 0;
+        private double weight = 0;
+
+        @Override
+        public void visit(EdgeIteratorState edge, boolean reverse, int prevOrNextEdgeId) {
+            time += turnWeighting.calcMillis(edge, reverse, prevOrNextEdgeId);
+            weight += turnWeighting.calcWeight(edge, reverse, prevOrNextEdgeId);
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/storage/TurnCostExtensionTest.java b/core/src/test/java/com/graphhopper/storage/TurnCostExtensionTest.java
index 5ffcd91529..b8857d19bb 100644
--- a/core/src/test/java/com/graphhopper/storage/TurnCostExtensionTest.java
+++ b/core/src/test/java/com/graphhopper/storage/TurnCostExtensionTest.java
@@ -31,7 +31,7 @@ public static void initGraph(Graph g) {
     public void testMultipleTurnCosts() {
         FlagEncoder carEncoder = new CarFlagEncoder(5, 5, 3);
         FlagEncoder bikeEncoder = new BikeFlagEncoder(5, 5, 3);
-        EncodingManager manager = new EncodingManager(carEncoder, bikeEncoder);
+        EncodingManager manager = EncodingManager.create(carEncoder, bikeEncoder);
         GraphHopperStorage g = new GraphBuilder(manager).create();
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
@@ -98,7 +98,7 @@ public void testMultipleTurnCosts() {
     public void testMergeFlagsBeforeAdding() {
         FlagEncoder carEncoder = new CarFlagEncoder(5, 5, 3);
         FlagEncoder bikeEncoder = new BikeFlagEncoder(5, 5, 3);
-        EncodingManager manager = new EncodingManager(carEncoder, bikeEncoder);
+        EncodingManager manager = EncodingManager.create(carEncoder, bikeEncoder);
         GraphHopperStorage g = new GraphBuilder(manager).create();
         initGraph(g);
         TurnCostExtension tcs = (TurnCostExtension) g.getExtension();
diff --git a/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java b/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
index c6d1fe45b4..3feea2b09b 100644
--- a/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
+++ b/core/src/test/java/com/graphhopper/storage/change/ChangeGraphHelperTest.java
@@ -1,10 +1,17 @@
 package com.graphhopper.storage.change;
 
+import com.graphhopper.jackson.Jackson;
 import com.graphhopper.json.geo.JsonFeatureCollection;
 import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
@@ -12,7 +19,6 @@
 import com.graphhopper.storage.index.LocationIndexTree;
 import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.Helper;
-import com.graphhopper.jackson.Jackson;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -31,7 +37,7 @@
 
     @Before
     public void setUp() {
-        encodingManager = new EncodingManager("car");
+        encodingManager = EncodingManager.create("car");
         graph = new GraphBuilder(encodingManager).create();
     }
 
@@ -53,12 +59,13 @@ public void testApplyChanges() throws IOException {
         LocationIndex locationIndex = new LocationIndexTree(graph, new RAMDirectory()).prepareIndex();
 
         FlagEncoder encoder = encodingManager.getEncoder("car");
-        double defaultSpeed = encoder.getSpeed(GHUtility.getEdge(graph, 0, 1).getFlags());
+        DecimalEncodedValue avSpeedEnc = encoder.getAverageSpeedEnc();
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
+        double defaultSpeed = GHUtility.getEdge(graph, 0, 1).get(avSpeedEnc);
         AllEdgesIterator iter = graph.getAllEdges();
         while (iter.next()) {
-            long flags = GHUtility.getEdge(graph, 0, 1).getFlags();
-            assertEquals(defaultSpeed, encoder.getSpeed(flags), .1);
-            assertTrue(encoder.isForward(flags));
+            assertEquals(defaultSpeed, iter.get(avSpeedEnc), .1);
+            assertTrue(iter.get(accessEnc));
         }
 
         Reader reader = new InputStreamReader(getClass().getResourceAsStream("overlaydata1.json"), Helper.UTF_CS);
@@ -68,9 +75,61 @@ public void testApplyChanges() throws IOException {
         assertEquals(2, updates);
 
         // assert changed speed and access
-        double newSpeed = encoder.getSpeed(GHUtility.getEdge(graph, 0, 1).getFlags());
+        double newSpeed = GHUtility.getEdge(graph, 0, 1).get(avSpeedEnc);
         assertEquals(10, newSpeed, .1);
         assertTrue(newSpeed < defaultSpeed);
-        assertFalse(encoder.isForward(GHUtility.getEdge(graph, 3, 4).getFlags()));
+        assertFalse(GHUtility.getEdge(graph, 3, 4).get(accessEnc));
+    }
+
+    @Test
+    public void testRevertChanges() throws IOException {
+        // 0-1-2
+        // | |
+        // 3-4
+        graph.edge(0, 1, 1, true);
+        graph.edge(1, 2, 1, true);
+        graph.edge(3, 4, 1, true);
+        graph.edge(0, 3, 1, true);
+        graph.edge(1, 4, 1, true);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 0, 0.01, 0.00);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 1, 0.01, 0.01);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 2, 0.01, 0.02);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 3, 0.00, 0.00);
+        AbstractRoutingAlgorithmTester.updateDistancesFor(graph, 4, 0.00, 0.01);
+        LocationIndex locationIndex = new LocationIndexTree(graph, new RAMDirectory()).prepareIndex();
+
+        FlagEncoder encoder = encodingManager.getEncoder("car");
+        Path p = new Dijkstra(graph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(0, 2);
+        assertTrue(p.isFound());
+
+        double distanceBeforeBlock = p.getDistance();
+        assertEquals(2223, distanceBeforeBlock, 1);
+
+        // Block the edge 0-1
+        Reader reader = new InputStreamReader(getClass().getResourceAsStream("overlaydata2.json"), Helper.UTF_CS);
+        ChangeGraphHelper instance = new ChangeGraphHelper(graph, locationIndex);
+        JsonFeatureCollection collection = Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class);
+        long updates = instance.applyChanges(encodingManager, collection.getFeatures());
+        assertEquals(1, updates);
+
+        p = new Dijkstra(graph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(0, 2);
+        assertTrue(p.isFound());
+
+        double distanceAfterBlock = p.getDistance();
+        assertEquals(4447, distanceAfterBlock, 1);
+
+        // Unblock the edge 0-1
+        reader = new InputStreamReader(getClass().getResourceAsStream("overlaydata3.json"), Helper.UTF_CS);
+        collection = Jackson.newObjectMapper().readValue(reader, JsonFeatureCollection.class);
+        updates = instance.applyChanges(encodingManager, collection.getFeatures());
+        assertEquals(1, updates);
+
+        p = new Dijkstra(graph, new ShortestWeighting(encoder), TraversalMode.NODE_BASED)
+                .calcPath(0, 2);
+        assertTrue(p.isFound());
+
+        assertEquals(distanceBeforeBlock, p.getDistance(), 1);
     }
 }
diff --git a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
index 2e0e1dff51..54fcaa2a57 100644
--- a/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
+++ b/core/src/test/java/com/graphhopper/storage/index/AbstractLocationIndexTester.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.storage.index;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.DistanceCalc;
@@ -73,7 +75,7 @@ public void tearDown() {
 
     @Test
     public void testSimpleGraph() {
-        Graph g = AbstractLocationIndexTester.this.createGHStorage(new EncodingManager("car"));
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(EncodingManager.create("car"));
         initSimpleGraph(g);
 
         idx = createIndex(g, -1);
@@ -123,7 +125,7 @@ public void initSimpleGraph(Graph g) {
 
     @Test
     public void testSimpleGraph2() {
-        Graph g = AbstractLocationIndexTester.this.createGHStorage(new EncodingManager("car"));
+        Graph g = AbstractLocationIndexTester.this.createGHStorage(EncodingManager.create("car"));
         initSimpleGraph(g);
 
         idx = createIndex(g, -1);
@@ -145,7 +147,7 @@ public void testSimpleGraph2() {
 
     @Test
     public void testGrid() {
-        Graph g = createSampleGraph(new EncodingManager("car"));
+        Graph g = createSampleGraph(EncodingManager.create("car"));
         int locs = g.getNodes();
 
         idx = createIndex(g, -1);
@@ -200,7 +202,7 @@ boolean testGridIgnore(int i) {
 
     @Test
     public void testSinglePoints120() {
-        Graph g = createSampleGraph(new EncodingManager("car"));
+        Graph g = createSampleGraph(EncodingManager.create("car"));
         idx = createIndex(g, -1);
 
         assertEquals(1, findID(idx, 1.637, 2.23));
@@ -215,7 +217,7 @@ public void testSinglePoints120() {
 
     @Test
     public void testSinglePoints32() {
-        Graph g = createSampleGraph(new EncodingManager("car"));
+        Graph g = createSampleGraph(EncodingManager.create("car"));
         idx = createIndex(g, -1);
 
         // 10 or 6
@@ -232,7 +234,7 @@ public void testSinglePoints32() {
 
     @Test
     public void testNoErrorOnEdgeCase_lastIndex() {
-        final EncodingManager encodingManager = new EncodingManager("car");
+        final EncodingManager encodingManager = EncodingManager.create("car");
         int locs = 10000;
         Graph g = AbstractLocationIndexTester.this.createGHStorage(new MMapDirectory(location), encodingManager, false);
         NodeAccess na = g.getNodeAccess();
@@ -325,7 +327,7 @@ public Graph createSampleGraph(EncodingManager encodingManager) {
 
     @Test
     public void testDifferentVehicles() {
-        final EncodingManager encodingManager = new EncodingManager("car,foot");
+        final EncodingManager encodingManager = EncodingManager.create("car,foot");
         Graph g = AbstractLocationIndexTester.this.createGHStorage(encodingManager);
         initSimpleGraph(g);
         idx = createIndex(g, -1);
@@ -333,9 +335,10 @@ public void testDifferentVehicles() {
 
         // now make all edges from node 1 accessible for CAR only
         EdgeIterator iter = g.createEdgeExplorer().setBaseNode(1);
-        CarFlagEncoder carEncoder = (CarFlagEncoder) encodingManager.getEncoder("car");
+        FlagEncoder encoder = encodingManager.getEncoder("foot");
+        BooleanEncodedValue accessEnc = encoder.getAccessEnc();
         while (iter.next()) {
-            iter.setFlags(carEncoder.setProperties(50, true, true));
+            iter.set(accessEnc, false).setReverse(accessEnc, false);
         }
         idx.close();
 
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
index b7052e1090..4506637f6d 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullIndexTest.java
@@ -39,7 +39,7 @@ public void testGrid() {
 
     @Test
     public void testFullIndex() {
-        LocationIndex tmpIdx = new Location2IDFullIndex(createSampleGraph(new EncodingManager("car")));
+        LocationIndex tmpIdx = new Location2IDFullIndex(createSampleGraph(EncodingManager.create("car")));
         assertEquals(5, findID(tmpIdx, 2, 3));
         assertEquals(10, findID(tmpIdx, 4, 1));
         assertEquals(10, findID(tmpIdx, 3.6, 1.4));
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
index c9b0c41e64..03ae5d3b8d 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDFullWithEdgesIndexTest.java
@@ -44,7 +44,7 @@ public void testGrid() {
 
     @Test
     public void testFullIndex() {
-        LocationIndex tmpIdx = new Location2IDFullWithEdgesIndex(createSampleGraph(new EncodingManager("car")));
+        LocationIndex tmpIdx = new Location2IDFullWithEdgesIndex(createSampleGraph(EncodingManager.create("car")));
         assertEquals(5, findID(tmpIdx, 2, 3));
         assertEquals(10, findID(tmpIdx, 4, 1));
         // 6, 9 or 10
diff --git a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
index 7b3ed2fa69..336e00f910 100644
--- a/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/Location2IDQuadtreeTest.java
@@ -39,7 +39,7 @@ public LocationIndex createIndex(Graph g, int resolution) {
 
     @Test
     public void testNormedDist() {
-        Location2IDQuadtree index = new Location2IDQuadtree(createGHStorage(new EncodingManager("car")), new RAMDirectory());
+        Location2IDQuadtree index = new Location2IDQuadtree(createGHStorage(EncodingManager.create("car")), new RAMDirectory());
         index.initAlgo(5, 6);
         assertEquals(1, index.getNormedDist(0, 1), 1e-6);
         assertEquals(2, index.getNormedDist(0, 7), 1e-6);
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
index 3694a75fe5..63a83f1162 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeCHTest.java
@@ -19,8 +19,8 @@
 
 import com.carrotsearch.hppc.IntSet;
 import com.graphhopper.coll.GHIntHashSet;
+import com.graphhopper.routing.ch.PrepareEncoder;
 import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.CHEdgeIteratorState;
@@ -62,7 +62,7 @@ GraphHopperStorage createGHStorage(Directory dir, EncodingManager encodingManage
     @Test
     public void testCHGraph() {
         GraphHopperStorage ghStorage = createGHStorage(new RAMDirectory(), encodingManager, false);
-        CHGraph lg = ghStorage.getGraph(CHGraph.class);
+        CHGraph lg = ghStorage.getCHGraph();
         // 0
         // 1
         // 2
@@ -82,16 +82,18 @@ public void testCHGraph() {
 
         // create shortcuts
         ghStorage.freeze();
-        FlagEncoder car = encodingManager.getEncoder("car");
-        long flags = car.setProperties(60, true, true);
+        int flags = PrepareEncoder.getScDirMask();
         CHEdgeIteratorState iter5 = lg.shortcut(0, 2);
-        iter5.setDistance(20).setFlags(flags);
+        iter5.setFlagsAndWeight(flags, 0);
+        iter5.setDistance(20);
         iter5.setSkippedEdges(iter1.getEdge(), iter2.getEdge());
         CHEdgeIteratorState iter6 = lg.shortcut(2, 4);
-        iter6.setDistance(28).setFlags(flags);
+        iter6.setFlagsAndWeight(flags, 0);
+        iter6.setDistance(28);
         iter6.setSkippedEdges(iter3.getEdge(), iter4.getEdge());
         CHEdgeIteratorState tmp = lg.shortcut(0, 4);
-        tmp.setDistance(40).setFlags(flags);
+        tmp.setFlagsAndWeight(flags, 0);
+        tmp.setDistance(40);
         tmp.setSkippedEdges(iter5.getEdge(), iter6.getEdge());
 
         LocationIndex index = createIndex(ghStorage, -1);
@@ -101,7 +103,7 @@ public void testCHGraph() {
     @Test
     public void testSortHighLevelFirst() {
         GraphHopperStorage g = createGHStorage(new RAMDirectory(), encodingManager, false);
-        final CHGraph lg = g.getGraph(CHGraph.class);
+        final CHGraph lg = g.getCHGraph();
         lg.getNodeAccess().ensureNode(4);
         lg.setLevel(1, 10);
         lg.setLevel(2, 30);
@@ -135,7 +137,7 @@ public void testCHGraphBug() {
         EdgeIteratorState iter1 = g.edge(1, 0, 100, true);
         g.edge(2, 3, 100, true);
 
-        CHGraphImpl lg = (CHGraphImpl) g.getGraph(CHGraph.class);
+        CHGraph lg = g.getCHGraph();
         g.freeze();
         lg.setLevel(0, 11);
         lg.setLevel(1, 10);
@@ -154,7 +156,7 @@ public void testCHGraphBug() {
         index.findNetworkEntries(0.51, 0.2, set, 0);
         index.findNetworkEntries(0.51, 0.2, set, 1);
         IntSet expectedSet = new GHIntHashSet();
-        expectedSet.add(0);
+        expectedSet.add(1);
         expectedSet.add(2);
         assertEquals(expectedSet, set);
 
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 34d68e3c94..4e280b1ca9 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -19,28 +19,26 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.graphhopper.coll.GHIntHashSet;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
 import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.Test;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
+import java.util.*;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 /**
  * @author Peter Karich
  */
 public class LocationIndexTreeTest extends AbstractLocationIndexTester {
-    protected final EncodingManager encodingManager = new EncodingManager("car");
+    protected final EncodingManager encodingManager = EncodingManager.create("car");
 
     @Override
     public LocationIndexTree createIndex(Graph g, int resolution) {
@@ -103,6 +101,22 @@ public void testSnappedPointAndGeometry() {
         assertEquals(new GHPoint(-0.441624, 0.317259), res.getSnappedPoint());
     }
 
+    @Test
+    public void testQuery() {
+        Graph graph = createTestGraph2();
+        LocationIndexTree index = createIndex(graph, 500);
+        final ArrayList set = new ArrayList();
+        index.query(new BBox(11.57314, 11.57614, 49.94553, 49.94853), new LocationIndex.Visitor() {
+            @Override
+            public void onNode(int nodeId) {
+                set.add(nodeId);
+            }
+        });
+        assertEquals(17, set.size());
+        assertTrue(set.containsAll(Arrays.asList(2, 3, 4, 5, 6)));
+        assertFalse(set.containsAll(Arrays.asList(17, 18, 25, 30)));
+    }
+
     @Test
     public void testInMemIndex() {
         Graph graph = createTestGraph(encodingManager);
@@ -195,11 +209,12 @@ public void testInMemIndex3() {
         LocationIndexTree index = createIndexNoPrepare(createTestGraph(encodingManager), 10000);
         index.prepareAlgo();
         LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
-        assertEquals(IntArrayList.from(new int[]{64, 4}), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{16, 4, 4}), index.getEntries());
 
-        assertEquals(33, inMemIndex.getEntriesOf(0).size());
-        assertEquals(69, inMemIndex.getEntriesOf(1).size());
-        assertEquals(0, inMemIndex.getEntriesOf(2).size());
+        assertEquals(13, inMemIndex.getEntriesOf(0).size());
+        assertEquals(33, inMemIndex.getEntriesOf(1).size());
+        assertEquals(69, inMemIndex.getEntriesOf(2).size());
+        assertEquals(0, inMemIndex.getEntriesOf(3).size());
 
         index.dataAccess.create(1024);
         inMemIndex.store(inMemIndex.root, LocationIndexTree.START_POINTER);
@@ -212,7 +227,7 @@ public void testInMemIndex3() {
     @Test
     public void testReverseSpatialKey() {
         LocationIndexTree index = createIndex(createTestGraph(encodingManager), 200);
-        assertEquals(IntArrayList.from(new int[]{64, 64, 64, 4}), index.getEntries());
+        assertEquals(IntArrayList.from(new int[]{16, 16, 16, 16, 4, 4}), index.getEntries());
 
         // 10111110111110101010
         String str44 = "00000000000000000000000000000000000000000000";
@@ -221,7 +236,7 @@ public void testReverseSpatialKey() {
 
     @Test
     public void testMoreReal() {
-        Graph graph = createGHStorage(new EncodingManager("car"));
+        Graph graph = createGHStorage(EncodingManager.create("car"));
         NodeAccess na = graph.getNodeAccess();
         na.setNode(1, 51.2492152, 9.4317166);
         na.setNode(0, 52, 9);
@@ -364,12 +379,12 @@ Graph createTestGraph2() {
         graph.edge(4, 5, 10, true);
         graph.edge(6, 7, 10, true);
 
-        graph.edge(8, 2, 10, true);
-        graph.edge(9, 2, 10, true);
-        graph.edge(10, 3, 10, true);
-        graph.edge(11, 4, 10, true);
-        graph.edge(12, 5, 10, true);
-        graph.edge(13, 6, 10, true);
+        graph.edge(2, 8, 10, true);
+        graph.edge(2, 9, 10, true);
+        graph.edge(3, 10, 10, true);
+        graph.edge(4, 11, 10, true);
+        graph.edge(5, 12, 10, true);
+        graph.edge(6, 13, 10, true);
 
         graph.edge(1, 14, 10, true);
         graph.edge(2, 15, 10, true);
@@ -434,7 +449,7 @@ public void testSearchWithFilter_issue318() {
         CarFlagEncoder carEncoder = new CarFlagEncoder();
         BikeFlagEncoder bikeEncoder = new BikeFlagEncoder();
 
-        EncodingManager tmpEM = new EncodingManager(carEncoder, bikeEncoder);
+        EncodingManager tmpEM = EncodingManager.create(carEncoder, bikeEncoder);
         Graph graph = createGHStorage(new RAMDirectory(), tmpEM, false);
         NodeAccess na = graph.getNodeAccess();
 
@@ -454,11 +469,12 @@ public void testSearchWithFilter_issue318() {
 
         // reduce access for bike to two edges only
         AllEdgesIterator iter = graph.getAllEdges();
+        BooleanEncodedValue accessEnc = bikeEncoder.getAccessEnc();
         while (iter.next()) {
-            iter.setFlags(bikeEncoder.setAccess(iter.getFlags(), false, false));
+            iter.set(accessEnc, false).setReverse(accessEnc, false);
         }
         for (EdgeIteratorState edge : Arrays.asList(GHUtility.getEdge(graph, 0, 1), GHUtility.getEdge(graph, 1, 2))) {
-            edge.setFlags(bikeEncoder.setAccess(edge.getFlags(), true, true));
+            edge.set(accessEnc, true).setReverse(accessEnc, true);
         }
 
         LocationIndexTree index = createIndexNoPrepare(graph, 500);
diff --git a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
index 2e55b26196..c1eeddb0f9 100644
--- a/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/BreadthFirstSearchTest.java
@@ -18,7 +18,9 @@
 package com.graphhopper.util;
 
 import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.coll.GHBitSet;
 import com.graphhopper.coll.GHIntHashSet;
+import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
@@ -44,6 +46,11 @@ public void setup() {
     @Test
     public void testBFS() {
         BreadthFirstSearch bfs = new BreadthFirstSearch() {
+            @Override
+            protected GHBitSet createBitSet() {
+                return new GHTBitSet();
+            }
+
             @Override
             public boolean goFurther(int v) {
                 counter++;
@@ -54,7 +61,7 @@ public boolean goFurther(int v) {
             }
         };
 
-        Graph g = new GraphBuilder(new EncodingManager("car")).create();
+        Graph g = new GraphBuilder(EncodingManager.create("car")).create();
         g.edge(0, 1, 85, true);
         g.edge(0, 2, 217, true);
         g.edge(0, 3, 173, true);
@@ -78,6 +85,11 @@ public boolean goFurther(int v) {
     @Test
     public void testBFS2() {
         BreadthFirstSearch bfs = new BreadthFirstSearch() {
+            @Override
+            protected GHBitSet createBitSet() {
+                return new GHTBitSet();
+            }
+
             @Override
             public boolean goFurther(int v) {
                 counter++;
@@ -88,7 +100,7 @@ public boolean goFurther(int v) {
             }
         };
 
-        Graph g = new GraphBuilder(new EncodingManager("car")).create();
+        Graph g = new GraphBuilder(EncodingManager.create("car")).create();
         g.edge(1, 2, 1, false);
         g.edge(2, 3, 1, false);
         g.edge(3, 4, 1, false);
diff --git a/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
index 8180f64f7d..02cfbb8e9f 100644
--- a/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
+++ b/core/src/test/java/com/graphhopper/util/CHEdgeIteratorTest.java
@@ -17,6 +17,8 @@
  */
 package com.graphhopper.util;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
@@ -28,6 +30,8 @@
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 /**
  * @author Peter Karich
@@ -36,23 +40,28 @@
     @Test
     public void testUpdateFlags() {
         CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(carFlagEncoder);
+        EncodingManager encodingManager = EncodingManager.create(carFlagEncoder);
         FastestWeighting weighting = new FastestWeighting(carFlagEncoder);
         EdgeFilter carOutFilter = DefaultEdgeFilter.outEdges(carFlagEncoder);
         GraphHopperStorage ghStorage = new GraphBuilder(encodingManager).setCHGraph(weighting).create();
-        CHGraph g = ghStorage.getGraph(CHGraph.class, weighting);
-        g.edge(0, 1).setDistance(12).setFlags(carFlagEncoder.setProperties(10, true, true));
-        g.edge(0, 2).setDistance(13).setFlags(carFlagEncoder.setProperties(20, true, true));
+        CHGraph g = ghStorage.getCHGraph(weighting);
+        BooleanEncodedValue accessEnc = carFlagEncoder.getAccessEnc();
+        DecimalEncodedValue avSpeedEnc = carFlagEncoder.getAverageSpeedEnc();
+        g.edge(0, 1).setDistance(12).set(accessEnc, true).setReverse(accessEnc, true).set(avSpeedEnc, 10.0);
+        g.edge(0, 2).setDistance(13).set(accessEnc, true).setReverse(accessEnc, true).set(avSpeedEnc, 20.0);
         ghStorage.freeze();
 
         assertEquals(2, GHUtility.count(g.getAllEdges()));
         assertEquals(1, GHUtility.count(g.createEdgeExplorer(carOutFilter).setBaseNode(1)));
         EdgeIteratorState iter = GHUtility.getEdge(g, 0, 1);
         assertEquals(1, iter.getAdjNode());
-        assertEquals(carFlagEncoder.setProperties(10, true, true), iter.getFlags());
+        assertTrue(iter.get(accessEnc));
+        assertTrue(iter.getReverse(accessEnc));
+        assertEquals(10.0, iter.get(avSpeedEnc), .1);
+        assertEquals(10.0, iter.getReverse(avSpeedEnc), .1);
 
         // update setProperties
-        iter.setFlags(carFlagEncoder.setProperties(20, true, false));
+        iter.set(accessEnc, true).setReverse(accessEnc, false).set(avSpeedEnc, 20.0);
         assertEquals(12, iter.getDistance(), 1e-4);
 
         // update distance
@@ -60,7 +69,11 @@ public void testUpdateFlags() {
         assertEquals(10, iter.getDistance(), 1e-4);
         assertEquals(0, GHUtility.count(g.createEdgeExplorer(carOutFilter).setBaseNode(1)));
         iter = GHUtility.getEdge(g, 0, 1);
-        assertEquals(carFlagEncoder.setProperties(20, true, false), iter.getFlags());
+
+        assertTrue(iter.get(accessEnc));
+        assertFalse(iter.getReverse(accessEnc));
+        assertEquals(20.0, iter.get(avSpeedEnc), .1);
+
         assertEquals(10, iter.getDistance(), 1e-4);
         assertEquals(1, GHUtility.getNeighbors(g.createEdgeExplorer().setBaseNode(1)).size());
         assertEquals(0, GHUtility.getNeighbors(g.createEdgeExplorer(carOutFilter).setBaseNode(1)).size());
diff --git a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
index 07b185f5b2..dff85427cd 100644
--- a/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
+++ b/core/src/test/java/com/graphhopper/util/DepthFirstSearchTest.java
@@ -18,7 +18,10 @@
 package com.graphhopper.util;
 
 import com.carrotsearch.hppc.IntArrayList;
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.coll.GHIntHashSet;
+import com.graphhopper.coll.GHTBitSet;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -47,6 +50,11 @@ public void setup() {
     @Test
     public void testDFS1() {
         DepthFirstSearch dfs = new DepthFirstSearch() {
+            @Override
+            protected GHBitSet createBitSet() {
+                return new GHBitSetImpl();
+            }
+
             @Override
             public boolean goFurther(int v) {
                 counter++;
@@ -57,7 +65,7 @@ public boolean goFurther(int v) {
             }
         };
 
-        EncodingManager em = new EncodingManager("car");
+        EncodingManager em = EncodingManager.create("car");
         FlagEncoder fe = em.getEncoder("car");
         Graph g = new GraphBuilder(em).create();
         g.edge(1, 2, 1, false);
@@ -77,6 +85,11 @@ public boolean goFurther(int v) {
     @Test
     public void testDFS2() {
         DepthFirstSearch dfs = new DepthFirstSearch() {
+            @Override
+            protected GHBitSet createBitSet() {
+                return new GHBitSetImpl();
+            }
+
             @Override
             public boolean goFurther(int v) {
                 counter++;
@@ -87,7 +100,7 @@ public boolean goFurther(int v) {
             }
         };
 
-        EncodingManager em = new EncodingManager("car");
+        EncodingManager em = EncodingManager.create("car");
         FlagEncoder fe = em.getEncoder("car");
         Graph g = new GraphBuilder(em).create();
         g.edge(1, 2, 1, false);
diff --git a/core/src/test/java/com/graphhopper/util/DistanceCalc2DTest.java b/core/src/test/java/com/graphhopper/util/DistanceCalc2DTest.java
new file mode 100644
index 0000000000..6ce67951cd
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/util/DistanceCalc2DTest.java
@@ -0,0 +1,51 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.util;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+public class DistanceCalc2DTest {
+
+    @Test
+    public void testCrossingPointToEdge() {
+        DistanceCalc2D distanceCalc = new DistanceCalc2D();
+        GHPoint point = distanceCalc.calcCrossingPointToEdge(0, 10, 0, 0, 10, 10);
+        Assert.assertEquals(5, point.getLat(), 0);
+        Assert.assertEquals(5, point.getLon(), 0);
+    }
+
+    @Test
+    public void testCalcNormalizedEdgeDistance() {
+        DistanceCalc2D distanceCalc = new DistanceCalc2D();
+        double distance = distanceCalc.calcNormalizedEdgeDistance(0, 10, 0, 0, 10, 10);
+        Assert.assertEquals(50, distance, 0);
+    }
+
+    @Test
+    public void testValidEdgeDistance() {
+        DistanceCalc2D distanceCalc = new DistanceCalc2D();
+        boolean validEdgeDistance = distanceCalc.validEdgeDistance(5, 15, 0, 0, 10, 10);
+        Assert.assertEquals(false, validEdgeDistance);
+        validEdgeDistance = distanceCalc.validEdgeDistance(15, 5, 0, 0, 10, 10);
+        Assert.assertEquals(false, validEdgeDistance);
+    }
+}
diff --git a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
index f5d0d96f37..76c74de1f5 100644
--- a/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
+++ b/core/src/test/java/com/graphhopper/util/GHUtilityTest.java
@@ -18,6 +18,7 @@
 package com.graphhopper.util;
 
 import com.graphhopper.coll.GHIntLongHashMap;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -32,7 +33,8 @@
  */
 public class GHUtilityTest {
     private final FlagEncoder carEncoder = new CarFlagEncoder();
-    private final EncodingManager encodingManager = new EncodingManager(carEncoder);
+    private final EncodingManager encodingManager = EncodingManager.create(carEncoder);
+    private final BooleanEncodedValue accessEnc = carEncoder.getAccessEnc();
 
     Graph createGraph() {
         return new GraphBuilder(encodingManager).create();
@@ -112,7 +114,7 @@ public void testCopyWithSelfRef() {
         CHGraph lg = new GraphBuilder(encodingManager).chGraphCreate(new FastestWeighting(carEncoder));
         GHUtility.copyTo(g, lg);
 
-        assertEquals(g.getAllEdges().length(), lg.getAllEdges().length());
+        assertEquals(g.getAllEdges().length(), lg.getEdges());
     }
 
     @Test
@@ -122,7 +124,7 @@ public void testCopy() {
         edgeState.setWayGeometry(Helper.createPointList(12, 10, -1, 3));
 
         GraphHopperStorage newStore = new GraphBuilder(encodingManager).setCHGraph(new FastestWeighting(carEncoder)).create();
-        CHGraph lg = newStore.getGraph(CHGraph.class);
+        CHGraph lg = newStore.getCHGraph();
         GHUtility.copyTo(g, lg);
         newStore.freeze();
 
@@ -140,12 +142,12 @@ public void testCopy() {
         EdgeIterator iter = lg.createEdgeExplorer().setBaseNode(8);
         iter.next();
         assertEquals(2.05, iter.getDistance(), 1e-6);
-        assertTrue(iter.isBackward(carEncoder));
-        assertTrue(iter.isForward(carEncoder));
+        assertTrue(iter.getReverse(accessEnc));
+        assertTrue(iter.get(accessEnc));
         iter.next();
         assertEquals(0.5, iter.getDistance(), 1e-6);
-        assertTrue(iter.isBackward(carEncoder));
-        assertTrue(iter.isForward(carEncoder));
+        assertTrue(iter.getReverse(accessEnc));
+        assertTrue(iter.get(accessEnc));
 
         iter = lg.createEdgeExplorer().setBaseNode(7);
         iter.next();
@@ -153,8 +155,8 @@ public void testCopy() {
 
         iter.next();
         assertEquals(2.1, iter.getDistance(), 1e-6);
-        assertFalse(iter.isBackward(carEncoder));
-        assertTrue(iter.isForward(carEncoder));
+        assertFalse(iter.getReverse(accessEnc));
+        assertTrue(iter.get(accessEnc));
         assertFalse(iter.next());
     }
 
@@ -168,6 +170,9 @@ public void testEdgeStuff() {
         assertEquals(8, GHUtility.createEdgeKey(1, 2, 4, false));
         assertEquals(9, GHUtility.createEdgeKey(2, 1, 4, false));
 
+        assertEquals(6, GHUtility.createEdgeKey(1, 1, 3, false));
+        assertEquals(6, GHUtility.createEdgeKey(1, 1, 3, true));
+
         assertTrue(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(1, 2, 4, false), GHUtility.createEdgeKey(1, 2, 4, false)));
         assertTrue(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(2, 1, 4, false), GHUtility.createEdgeKey(1, 2, 4, false)));
         assertFalse(GHUtility.isSameEdgeKeys(GHUtility.createEdgeKey(1, 2, 4, false), GHUtility.createEdgeKey(1, 2, 5, false)));
@@ -194,9 +199,9 @@ public void testZeroValue() {
 //        TIntLongHashMap map2 = new TIntLongHashMap(100, 0.7f, -1, -1);
 //        assertFalse(map2.containsKey(0));
 //        assertFalse(map2.containsValue(0));
-//        map2.put(0, 3);
-//        map2.put(1, 0);
-//        map2.put(2, 1);
+//        map2.add(0, 3);
+//        map2.add(1, 0);
+//        map2.add(2, 1);
 //        assertTrue(map2.containsKey(0));
 //        assertTrue(map2.containsValue(0));
 //        assertEquals(3, map2.get(0));
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 3af1ce51dd..b488f5f2fb 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -18,9 +18,10 @@
 package com.graphhopper.util;
 
 import com.carrotsearch.hppc.IntArrayList;
-import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.Roundabout;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -31,18 +32,10 @@
 import com.graphhopper.storage.NodeAccess;
 import org.junit.Before;
 import org.junit.Test;
-import org.xml.sax.SAXException;
-
-import javax.xml.XMLConstants;
-import javax.xml.transform.Source;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.validation.Schema;
-import javax.xml.validation.SchemaFactory;
-import javax.xml.validation.Validator;
-import java.io.StringReader;
+
 import java.util.*;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
 
 /**
  * @author Peter Karich
@@ -53,14 +46,27 @@
     private final TraversalMode tMode = TraversalMode.NODE_BASED;
     private EncodingManager carManager;
     private FlagEncoder carEncoder;
+    private BooleanEncodedValue roundaboutEnc;
 
     @Before
     public void setUp() {
         carEncoder = new CarFlagEncoder();
-        carManager = new EncodingManager(carEncoder);
+        carManager = EncodingManager.create(carEncoder);
+        roundaboutEnc = carManager.getBooleanEncodedValue(Roundabout.KEY);
+    }
+
+    private List<String> getTurnDescriptions(InstructionList instructionList) {
+        return getTurnDescriptions(instructionList, usTR);
+    }
+
+    private List<String> getTurnDescriptions(InstructionList instructionList, Translation tr) {
+        List<String> list = new ArrayList<>();
+        for (Instruction instruction : instructionList) {
+            list.add(instruction.getTurnDescription(tr));
+        }
+        return list;
     }
 
-    @SuppressWarnings("unchecked")
     @Test
     public void testWayList() {
         Graph g = new GraphBuilder(carManager).create();
@@ -108,95 +114,49 @@ public void testWayList() {
         iter2.setName("8-9");
         iter2.setWayGeometry(list);
 
-        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 10);
-        InstructionList wayList = p.calcInstructions(usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 0-1", "Turn right onto 1-4", "Turn left onto 7-8", "Arrive at destination"),
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(0, 10);
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 0-1", "turn right onto 1-4", "turn left onto 7-8", "arrive at destination"),
                 tmpList);
 
-        wayList = p.calcInstructions(trMap.getWithFallBack(Locale.GERMAN));
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Dem Straßenverlauf von 0-1 folgen", "Rechts abbiegen auf 1-4", "Links abbiegen auf 7-8", "Ziel erreicht"),
+        wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.GERMAN));
+        tmpList = getTurnDescriptions(wayList, trMap.getWithFallBack(Locale.GERMAN));
+        assertEquals(Arrays.asList("dem Straßenverlauf von 0-1 folgen", "rechts abbiegen auf 1-4", "links abbiegen auf 7-8", "Ziel erreicht"),
                 tmpList);
 
         assertEquals(70000.0, sumDistances(wayList), 1e-1);
 
-        List<GPXEntry> gpxes = wayList.createGPXList();
-        assertEquals(10, gpxes.size());
-        // check order of tower nodes        
-        assertEquals(1, gpxes.get(0).getLon(), 1e-6);
-        assertEquals(1.4, gpxes.get(gpxes.size() - 1).getLon(), 1e-6);
+        PointList points = p.calcPoints();
+        assertEquals(10, points.size());
+        // check order of tower nodes
+        assertEquals(1, points.getLon(0), 1e-6);
+        assertEquals(1.4, points.getLon(points.size() - 1), 1e-6);
 
-        // check order of pillar nodes        
-        assertEquals(1.15, gpxes.get(4).getLon(), 1e-6);
-        assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
-        assertEquals(1.16, gpxes.get(5).getLon(), 1e-6);
+        // check order of pillar nodes
+        assertEquals(1.15, points.getLon(4), 1e-6);
+        assertEquals(1.16, points.getLon(5), 1e-6);
 
         compare(Arrays.asList(asL(1.2d, 1.0d), asL(1.2d, 1.1), asL(1.0, 1.1), asL(1.1, 1.4)),
-                wayList.createStartPoints());
+                createStartPoints(wayList));
 
-        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(6, 2);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(6, 2);
         assertEquals(42000, p.getDistance(), 1e-2);
-        assertEquals(IntArrayList.from(new int[]{6, 7, 8, 5, 2}), p.calcNodes());
+        assertEquals(IntArrayList.from(6, 7, 8, 5, 2), p.calcNodes());
 
-        wayList = p.calcInstructions(usTR);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 6-7", "Turn left onto 5-8", "Arrive at destination"),
+        wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 6-7", "turn left onto 5-8", "arrive at destination"),
                 tmpList);
 
         compare(Arrays.asList(asL(1d, 1d), asL(1d, 1.2), asL(1.2, 1.2)),
-                wayList.createStartPoints());
+                createStartPoints(wayList));
 
         // special case of identical start and end
-        p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 0);
-        wayList = p.calcInstructions(usTR);
+        p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(0, 0);
+        wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
         assertEquals(1, wayList.size());
-        assertEquals("arrive at destination", wayList.get(0).getTurnDescription(usTR));
-    }
-
-    List<String> pick(String key, List<Map<String, Object>> instructionJson) {
-        List<String> list = new ArrayList<>();
-
-        for (Map<String, Object> json : instructionJson) {
-            list.add(json.get(key).toString());
-        }
-        return list;
-    }
-
-    List<List<Double>> createList(PointList pl, List<Integer> integs) {
-        List<List<Double>> list = new ArrayList<>();
-        for (int i : integs) {
-            List<Double> entryList = new ArrayList<>(2);
-            entryList.add(pl.getLatitude(i));
-            entryList.add(pl.getLongitude(i));
-            list.add(entryList);
-        }
-        return list;
-    }
-
-    void compare(List<List<Double>> expected, List<List<Double>> actual) {
-        for (int i = 0; i < expected.size(); i++) {
-            List<Double> e = expected.get(i);
-            List<Double> wasE = actual.get(i);
-            for (int j = 0; j < e.size(); j++) {
-                assertEquals("at index " + i + " value index " + j + " and value " + e + " vs " + wasE + "\n" + "Expected: " + expected + "\n" + "Actual: " + actual
-                        , e.get(j),
-                        wasE.get(j),
-                        1e-5d);
-            }
-        }
-    }
-
-    List<Double> asL(Double... list) {
-        return Arrays.asList(list);
-    }
-
-    double sumDistances(InstructionList il) {
-        double val = 0;
-        for (Instruction i : il) {
-            val += i.getDistance();
-        }
-        return val;
+        assertEquals("arrive at destination", wayList.get(0).getTurnDescription(trMap.getWithFallBack(Locale.US)));
     }
 
     @Test
@@ -224,15 +184,15 @@ public void testWayList2() {
 
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
 
-        InstructionList wayList = p.calcInstructions(usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 2-4", "Turn slight right onto 3-4", "Arrive at destination"),
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
+        List<String> tmpList = getTurnDescriptions(wayList);
+        assertEquals(Arrays.asList("continue onto 2-4", "turn slight right onto 3-4", "arrive at destination"),
                 tmpList);
 
         p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(3, 5);
-        wayList = p.calcInstructions(usTR);
-        tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto 3-4", "Keep right onto 4-5", "Arrive at destination"),
+        wayList = p.calcInstructions(roundaboutEnc, usTR);
+        tmpList = getTurnDescriptions( wayList);
+        assertEquals(Arrays.asList("continue onto 3-4", "keep right onto 4-5", "arrive at destination"),
                 tmpList);
     }
 
@@ -262,203 +222,17 @@ public void testNoInstructionIfSameStreet() {
         iter.setWayGeometry(list);
 
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(2, 3);
-        InstructionList wayList = p.calcInstructions(usTR);
-        List<String> tmpList = pick("text", wayList.createJson());
-        assertEquals(Arrays.asList("Continue onto street", "Turn right onto street", "Arrive at destination"), tmpList);
-    }
-
-    @Test
-    public void testInstructionsWithTimeAndPlace() {
-        Graph g = new GraphBuilder(carManager).create();
-        //   n-4-5   (n: pillar node)
-        //   |
-        // 7-3-2-6
-        //     |
-        //     1
-        NodeAccess na = g.getNodeAccess();
-        na.setNode(1, 15.0, 10);
-        na.setNode(2, 15.1, 10);
-        na.setNode(3, 15.1, 9.9);
-        na.setNode(4, 15.2, 9.9);
-        na.setNode(5, 15.2, 10);
-        na.setNode(6, 15.1, 10.1);
-        na.setNode(7, 15.1, 9.8);
-
-        g.edge(1, 2, 7000, true).setName("1-2").setFlags(flagsForSpeed(carManager, 70));
-        g.edge(2, 3, 8000, true).setName("2-3").setFlags(flagsForSpeed(carManager, 80));
-        g.edge(2, 6, 10000, true).setName("2-6").setFlags(flagsForSpeed(carManager, 10));
-        g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
-        g.edge(3, 7, 10000, true).setName("3-7").setFlags(flagsForSpeed(carManager, 10));
-        g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
-
-        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
-        InstructionList wayList = p.calcInstructions(usTR);
-        assertEquals(4, wayList.size());
-
-        List<GPXEntry> gpxList = wayList.createGPXList();
-        assertEquals(34000, p.getDistance(), 1e-1);
-        assertEquals(34000, sumDistances(wayList), 1e-1);
-        assertEquals(5, gpxList.size());
-        assertEquals(1604120, p.getTime());
-        assertEquals(1604120, gpxList.get(gpxList.size() - 1).getTime());
-
-        assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getSign());
-        assertEquals(15, wayList.get(0).getFirstLat(), 1e-3);
-        assertEquals(10, wayList.get(0).getFirstLon(), 1e-3);
-
-        assertEquals(Instruction.TURN_LEFT, wayList.get(1).getSign());
-        assertEquals(15.1, wayList.get(1).getFirstLat(), 1e-3);
-        assertEquals(10, wayList.get(1).getFirstLon(), 1e-3);
-
-        assertEquals(Instruction.TURN_RIGHT, wayList.get(2).getSign());
-        assertEquals(15.1, wayList.get(2).getFirstLat(), 1e-3);
-        assertEquals(9.9, wayList.get(2).getFirstLon(), 1e-3);
-
-        String gpxStr = wayList.createGPX("test", 0, Constants.VERSION);
-        verifyGPX(gpxStr);
-
-        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T00:00:00Z</time>"));
-        assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
-        assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
-        assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
-
-        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
-        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
-
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-    }
-
-    @Test
-    public void testCreateGPXIncludesRoundaboutExitNumber() {
-        InstructionList instructions = new InstructionList(usTR);
-
-        PointList pl = new PointList();
-        pl.add(52.555423473315, 13.43890086052345);
-        pl.add(52.555550691982, 13.43946393816465);
-        pl.add(52.555619423589, 13.43886994061328);
-        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
-                InstructionAnnotation.EMPTY, pl)
-                .setRadian(2.058006514284998d)
-                .setExitNumber(3)
-                .setExited();
-        instructions.add(instr);
-        instructions.add(new FinishInstruction(52.555619423589, 13.43886994061328, 0));
-
-        String gpxStr = instructions.createGPX("test", 0, true, true, false, false, Constants.VERSION);
-
-        assertTrue(gpxStr, gpxStr.contains("<gh:exit_number>3</gh:exit_number>"));
-        verifyGPX(gpxStr);
-    }
-
-    @Test
-    public void testCreateGPXCorrectFormattingSmallNumbers() {
-        InstructionList instructions = new InstructionList(usTR);
-
-        PointList pl = new PointList();
-        pl.add(0.000001, 0.000001);
-        pl.add(-0.000123, -0.000125);
-        Instruction instruction = new Instruction(0, "do it", null, pl);
-        instructions.add(instruction);
-        instructions.add(new FinishInstruction(0.000852, 0.000852, 0));
-
-        String gpxStr = instructions.createGPX("test", 0, true, true, true, true, Constants.VERSION);
-
-        assertFalse(gpxStr, gpxStr.contains("E-"));
-        assertTrue(gpxStr, gpxStr.contains("0.000001"));
-        assertTrue(gpxStr, gpxStr.contains("-0.000125"));
-        verifyGPX(gpxStr);
-    }
-
-    @Test
-    public void testCreateGPXWithEle() {
-        final List<GPXEntry> fakeList = new ArrayList<>();
-        fakeList.add(new GPXEntry(12, 13, 0));
-        fakeList.add(new GPXEntry(12.5, 13, 1000));
-        InstructionList il = new InstructionList(usTR) {
-            @Override
-            public List<GPXEntry> createGPXList() {
-                return fakeList;
-            }
-        };
-        String gpxStr = il.createGPX("test", 0, Constants.VERSION);
-        verifyGPX(gpxStr);
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-        assertFalse(gpxStr, gpxStr.contains("<ele>"));
-
-        fakeList.clear();
-        fakeList.add(new GPXEntry(12, 13, 11, 0));
-        fakeList.add(new GPXEntry(12.5, 13, 10, 1000));
-        gpxStr = il.createGPX("test", 0, true, true, true, true, Constants.VERSION);
-
-        assertTrue(gpxStr, gpxStr.contains("<ele>11.0</ele>"));
-        assertFalse(gpxStr, gpxStr.contains("NaN"));
-    }
-
-    @Test
-    public void testCreateGPX() {
-        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
-        InstructionList instructions = new InstructionList(usTR);
-        PointList pl = new PointList();
-        pl.add(49.942576, 11.580384);
-        pl.add(49.941858, 11.582422);
-        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
-
-        pl = new PointList();
-        pl.add(49.941575, 11.583501);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
-
-        pl = new PointList();
-        pl.add(49.941389, 11.584311);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
-        instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
-
-        List<GPXEntry> result = instructions.createGPXList();
-        assertEquals(5, result.size());
-
-        assertEquals(0, result.get(0).getTime());
-        assertEquals(10391, result.get(1).getTime());
-        assertEquals(15000, result.get(2).getTime());
-        assertEquals(19000, result.get(3).getTime());
-        assertEquals(22000, result.get(4).getTime());
-
-        verifyGPX(instructions.createGPX(Constants.VERSION));
-    }
-
-    private long flagsForSpeed(EncodingManager encodingManager, int speedKmPerHour) {
-        ReaderWay way = new ReaderWay(1);
-        way.setTag("highway", "motorway");
-        way.setTag("maxspeed", String.format("%d km/h", speedKmPerHour));
-        return encodingManager.handleWayTags(way, 1, 0);
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
+        List<String> tmpList = getTurnDescriptions( wayList);
+        assertEquals(Arrays.asList("continue onto street", "turn right onto street", "arrive at destination"), tmpList);
     }
 
     @Test
     public void testEmptyList() {
         Graph g = new GraphBuilder(carManager).create();
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 1);
-        InstructionList il = p.calcInstructions(usTR);
+        InstructionList il = p.calcInstructions(roundaboutEnc, usTR);
         assertEquals(0, il.size());
-        assertEquals(0, il.createStartPoints().size());
-    }
-
-    public void verifyGPX(String gpx) {
-        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
-        Schema schema = null;
-        try {
-            Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
-            schema = schemaFactory.newSchema(schemaFile);
-
-            // using more schemas: http://stackoverflow.com/q/1094893/194609
-        } catch (SAXException e1) {
-            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
-        }
-        Validator validator = schema.newValidator();
-        try {
-            validator.validate(new StreamSource(new StringReader(gpx)));
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
     }
 
     @Test
@@ -488,7 +262,7 @@ public void testFind() {
         g.edge(4, 5, 10000, true).setName("4-5");
 
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(1, 5);
-        InstructionList wayList = p.calcInstructions(usTR);
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, usTR);
 
         // query on first edge, get instruction for second edge
         assertEquals("2-3", wayList.find(15.05, 10, 1000).getName());
@@ -500,10 +274,46 @@ public void testFind() {
         assertEquals("3-4", wayList.find(15.099, 9.9, 1000).getName());
     }
 
-    @Test
-    public void testXMLEscape_issue572() {
-        assertEquals("_", InstructionList.simpleXMLEscape("<"));
-        assertEquals("_blup_", InstructionList.simpleXMLEscape("<blup>"));
-        assertEquals("a&amp;b", InstructionList.simpleXMLEscape("a&b"));
+    private List<String> pick(String key, List<Map<String, Object>> instructionJson) {
+        List<String> list = new ArrayList<>();
+
+        for (Map<String, Object> json : instructionJson) {
+            list.add(json.get(key).toString());
+        }
+        return list;
+    }
+
+    private void compare(List<List<Double>> expected, List<List<Double>> actual) {
+        for (int i = 0; i < expected.size(); i++) {
+            List<Double> e = expected.get(i);
+            List<Double> wasE = actual.get(i);
+            for (int j = 0; j < e.size(); j++) {
+                assertEquals("at index " + i + " value index " + j + " and value " + e + " vs " + wasE + "\n" + "Expected: " + expected + "\n" + "Actual: " + actual
+                        , e.get(j),
+                        wasE.get(j),
+                        1e-5d);
+            }
+        }
     }
+
+    private List<Double> asL(Double... list) {
+        return Arrays.asList(list);
+    }
+
+    private static List<List<Double>> createStartPoints(List<Instruction> instructions) {
+        List<List<Double>> res = new ArrayList<>(instructions.size());
+        for (Instruction instruction : instructions) {
+            res.add(Arrays.asList(instruction.getPoints().getLatitude(0), instruction.getPoints().getLongitude(0)));
+        }
+        return res;
+    }
+
+    private double sumDistances(InstructionList il) {
+        double val = 0;
+        for (Instruction i : il) {
+            val += i.getDistance();
+        }
+        return val;
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/PathSimplificationTest.java b/core/src/test/java/com/graphhopper/util/PathSimplificationTest.java
index c0b6b4c19f..89a6df9521 100644
--- a/core/src/test/java/com/graphhopper/util/PathSimplificationTest.java
+++ b/core/src/test/java/com/graphhopper/util/PathSimplificationTest.java
@@ -21,6 +21,7 @@
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.Path;
+import com.graphhopper.routing.profiles.Roundabout;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -29,7 +30,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphBuilder;
 import com.graphhopper.storage.NodeAccess;
-import com.graphhopper.util.Parameters.DETAILS;
+import com.graphhopper.util.Parameters.Details;
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.details.PathDetailsBuilderFactory;
 import org.junit.Before;
@@ -57,7 +58,7 @@
     @Before
     public void setUp() {
         carEncoder = new CarFlagEncoder();
-        carManager = new EncodingManager(carEncoder);
+        carManager = EncodingManager.create(carEncoder);
     }
 
     @Test
@@ -88,41 +89,43 @@ public void testScenario() {
 
         EdgeIteratorState tmpEdge;
         tmpEdge = g.edge(0, 1, 10000, true).setName("0-1");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        assertTrue(carManager.acceptWay(w, map));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
         tmpEdge = g.edge(1, 2, 11000, true).setName("1-2");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
 
         w.setTag("maxspeed", "20");
         tmpEdge = g.edge(0, 3, 11000, true);
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
         tmpEdge = g.edge(1, 4, 10000, true).setName("1-4");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
         tmpEdge = g.edge(2, 5, 11000, true).setName("5-2");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
 
         w.setTag("maxspeed", "30");
         tmpEdge = g.edge(3, 6, 11000, true).setName("3-6");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
         tmpEdge = g.edge(4, 7, 10000, true).setName("4-7");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
         tmpEdge = g.edge(5, 8, 10000, true).setName("5-8");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
 
         w.setTag("maxspeed", "40");
         tmpEdge = g.edge(6, 7, 11000, true).setName("6-7");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
         tmpEdge = g.edge(7, 8, 10000, true);
         PointList list = new PointList();
         list.add(1.0, 1.15);
         list.add(1.0, 1.16);
         tmpEdge.setWayGeometry(list);
         tmpEdge.setName("7-8");
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
 
         w.setTag("maxspeed", "50");
         // missing edge name
         tmpEdge = g.edge(9, 10, 10000, true);
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
         tmpEdge = g.edge(8, 9, 20000, true);
         list.clear();
         list.add(1.0, 1.3);
@@ -131,12 +134,12 @@ public void testScenario() {
         list.add(1.0, 1.3003);
         tmpEdge.setName("8-9");
         tmpEdge.setWayGeometry(list);
-        tmpEdge.setFlags(carManager.handleWayTags(w, carManager.acceptWay(w), 0));
+        tmpEdge.setFlags(carManager.handleWayTags(w, map, 0));
 
         // Path is: [0 0-1, 3 1-4, 6 4-7, 9 7-8, 11 8-9, 10 9-10]
         Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), tMode).calcPath(0, 10);
-        InstructionList wayList = p.calcInstructions(usTR);
-        Map<String, List<PathDetail>> details = p.calcDetails(Arrays.asList(DETAILS.AVERAGE_SPEED), new PathDetailsBuilderFactory(), 0);
+        InstructionList wayList = p.calcInstructions(carManager.getBooleanEncodedValue(Roundabout.KEY), usTR);
+        Map<String, List<PathDetail>> details = p.calcDetails(Arrays.asList(Details.AVERAGE_SPEED), new PathDetailsBuilderFactory(), 0);
 
         PathWrapper pathWrapper = new PathWrapper();
         pathWrapper.setInstructions(wayList);
diff --git a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
index b2d38c0711..215f782545 100644
--- a/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
+++ b/core/src/test/java/com/graphhopper/util/TranslationMapTest.java
@@ -59,7 +59,13 @@ public void testToString() {
         trMap = SINGLETON.get("iw");
         assertEquals("רגל", trMap.tr("web.FOOT"));
 
-        // indonesia assertEquals("in", new Locale("id").getLanguage());
+        // Indonesian
+        assertEquals("in", SINGLETON.get("in").getLanguage());
+        assertEquals("in", SINGLETON.get("in_ID").getLanguage());
+
+        // Vietnamese
+        assertEquals("vi", SINGLETON.get("vi").getLanguage());
+        assertEquals("vi", SINGLETON.get("vi_VN").getLanguage());
     }
 
     @Test
diff --git a/core/src/test/resources/com/graphhopper/storage/change/overlaydata2.json b/core/src/test/resources/com/graphhopper/storage/change/overlaydata2.json
new file mode 100644
index 0000000000..72253eba68
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/storage/change/overlaydata2.json
@@ -0,0 +1,14 @@
+{
+    "type": "FeatureCollection",
+    "features": [{
+        "type": "Feature",
+        "geometry": {
+            "type": "Point",
+            "coordinates": [0.005, 0.01]
+        },
+        "properties": {
+            "vehicles": ["car"],
+            "access": false
+        }
+    }]
+}
\ No newline at end of file
diff --git a/core/src/test/resources/com/graphhopper/storage/change/overlaydata3.json b/core/src/test/resources/com/graphhopper/storage/change/overlaydata3.json
new file mode 100644
index 0000000000..b1d42babec
--- /dev/null
+++ b/core/src/test/resources/com/graphhopper/storage/change/overlaydata3.json
@@ -0,0 +1,14 @@
+{
+    "type": "FeatureCollection",
+    "features": [{
+        "type": "Feature",
+        "geometry": {
+            "type": "Point",
+            "coordinates": [0.005, 0.01]
+        },
+        "properties": {
+            "vehicles": ["car"],
+            "access": true
+        }
+    }]
+}
\ No newline at end of file
diff --git a/docs/android/index.md b/docs/android/index.md
index 262e24afcf..455a919886 100644
--- a/docs/android/index.md
+++ b/docs/android/index.md
@@ -23,7 +23,7 @@ Please read [here](./android-studio-setup.md) for a detailed instruction.
 
 ## None-Android Studio
 
-Download the [Android SDK](http://developer.android.com/sdk/installing/index.html?pkg=tools) and go to the Android SDK Manager and install the latest SDK.
+You need to download the SDK tools and then install builds-tools and platform (both e.g. v27). The process is described in more details for linux [here](https://gist.github.com/karussell/86fa2554c552a204ae7be2964b870bab).
 
 ### Maven or NetBeans
  1. Download [Maven Android SDK Deployer](https://github.com/simpligility/maven-android-sdk-deployer) and execute `mvn install -P 5.1` - it uses [Android Maven Plugin](http://simpligility.github.io/android-maven-plugin/) under the hood where you need to set up `ANDROID_HOME`
diff --git a/docs/core/ch.md b/docs/core/ch.md
index c8c1540921..f69733bf7e 100644
--- a/docs/core/ch.md
+++ b/docs/core/ch.md
@@ -9,3 +9,5 @@ which allows to store shortcuts too.
 A prepared graph can also be used for normal graph traversal IF you use chGraph.getBaseGraph().
 
 If CH is enabled multiple vehicles will work.
+
+Details about the edge-based version of CH, that also allows taking into account turn costs and restrictions can be found [here](./edge-based-ch.md).
diff --git a/docs/core/change-graph.md b/docs/core/change-graph.md
new file mode 100644
index 0000000000..3f71166d62
--- /dev/null
+++ b/docs/core/change-graph.md
@@ -0,0 +1,51 @@
+# Change Graph Endpoint
+
+It is possible to change the graph without restarting GraphHopper. This is possible by using the `/change` endpoint.
+Currently, it is possible to change the speed of edges as well as the access value of edges.
+
+### Before you start
+
+You should be aware that changing either the access or the speed will not influence the results of ch requests.
+We recommend using `prepare.ch.weightings=no` or you should know what you are doing. This can be used in combination
+with [Landmarks](landmarks.md), but only if you increase the weight, decreasing the weight might lead to incorrect
+routing results. Per default the `/change` endpoint is disabled for security reasons, you can however enable the 
+endpoint first. Be aware that this endpoint is not secured and everybody can call it and change the graph. 
+You should also be aware that the changes are not persistent, when you restart the server the changes are lost,
+unless you call `graphHopperStorage.flush()`.
+
+### Getting started
+
+First, enable the `/change` endpoint. On a Unix system, open the terminal and go to the GraphHopper directory.
+Type `export GH_WEB_OPTS=-Dgraphhopper.web.change_graph.enabled=true`.
+Start graphhopper by typing `./graphhopper.sh -a web -i <your-pbf>`.
+In this example we use `baden-wuerttemberg-latest.osm.pbf`.
+
+You can view the test route [here](http://localhost:8989/maps/?point=48.69232%2C9.264393&point=48.683594%2C9.257913).
+
+For this example we will assume that you use the car profile. You can now send the following Geojson as POST to the 
+`/change` endpoint. This Geojson will change the access value of the road at `48.685266, 9.260648` to false.
+
+```
+{
+     "type": "FeatureCollection",
+     "features": [{
+       "type": "Feature",
+       "geometry": {
+         "type": "Point",
+         "coordinates": [9.260648, 48.685266]
+       },
+       "properties": {
+         "vehicles": ["car"],
+         "access": false
+        }
+     }]
+}
+```
+
+You can send the POST with curl like this: `curl -H "Content-Type: application/json" -X POST -d '{"type": "FeatureCollection","features": [{"type": "Feature","geometry": {"type": "Point","coordinates": [9.260648, 48.685266]},"properties": {"vehicles": ["car"],"access": false}}]}' http://localhost:8989/change`
+
+If you visit the test url from above again, you will see that the route changed and parts of the `L 1202` have become
+inaccessible for GraphHopper's car profile. Bike or Foot will still use this road (if you enabled them as well). 
+
+You can create more complicated Geojsons than the one shown in the example. We allow passing most Geojson Geometries,
+including Polygons, BBoxes, and Points.  
\ No newline at end of file
diff --git a/docs/core/create-new-flagencoder.md b/docs/core/create-new-flagencoder.md
index cfea45828b..3193d39b69 100644
--- a/docs/core/create-new-flagencoder.md
+++ b/docs/core/create-new-flagencoder.md
@@ -15,17 +15,16 @@ Use it e.g. just via `graphHopper.setEncodingManager(new EncodingManager(myEncod
 
 ## Different forward and backward weights?
 
-If you need to support two different speed values for one street (one edge) you need to create
-a separate EncodedDoubleValue instance (reverseSpeedEncoder) managing the reverse speed, 
-see Bike2WeightFlagEncoder for an example. You'll have to overwrite the following methods:
-
- * setReverseSpeed, getReverseSpeed to use the reverseSpeedEncoder
- * handleSpeed, to handle oneway tags correctly
- * flagsDefault 
- * setProperties
- * reverseFlags
- * setLowSpeed
- * always set reverse speed explicitely, see #665
+With 0.12 this is now simple. Specify speedTwoDirections = true in the constructor and overwrite handleSpeed:
+
+```java
+protected void handleSpeed(IntsRef edgeFlags, ReaderWay way, double speed) {
+        speedEncoder.setDecimal(true, edgeFlags, speed);
+        super.handleSpeed(edgeFlags, way, speed);
+}
+```
+
+See Bike2WeightFlagEncoder for an example that uses different weights: slower speeds uphill than downhill.
 
 ## Elevation
 
@@ -34,6 +33,5 @@ and call edge.fetchWayGeometry(3) or again, see Bike2WeightFlagEncoder.
 
 ## Add to the core
 
-If you want to include your FlagEncoder in GraphHopper you have to add the creation in
-EncodingManager.parseEncoderString to let the EncodingManager pick the correct class when faced
-with the string. The convention is that encoder.toString is identical to the string.
+If you want to include your FlagEncoder in GraphHopper and e.g. still want to use the config.yml
+you can use a subclass of DefaultFlagEncoderFactory and use the configuration object to change different properties.
diff --git a/docs/core/eclipse-setup.md b/docs/core/eclipse-setup.md
index 9e0a8c5b7f..fdba1fb9d4 100644
--- a/docs/core/eclipse-setup.md
+++ b/docs/core/eclipse-setup.md
@@ -5,7 +5,7 @@ Instructions for Android branch will be provided in future.
 
 This document covers configuring Eclipse for cloning and importing GraphHopper repository. 
 
-###1. Download Eclipse
+### 1. Download Eclipse
 
 The first step is to download latest version of Eclipse. We recommend that you download the ["Eclipse IDE for Java EE Developers"](http://www.eclipse.org/downloads/) package, instead of the package "for Java developers", as it includes many of the necessary plugins for webapp and API development.  
 
@@ -14,7 +14,7 @@ The first step is to download latest version of Eclipse. We recommend that you d
 **Note:** GraphHopper is set to run with JRE 1.6. This document is written based on setting Eclipse Luna using JRE 1.6.  It may also work with newer versions of JRE, but it has not been tested yet.
 
 
-###2.	Eclipse Addition al Plugins
+### 2.	Eclipse Addition al Plugins
 Before getting started, you'll need to have a few Eclipse plugins installed to help with development. GraphHopper is versioned using Git and its build process and dependencies are managed by Maven, so certain additional Eclipse components will be needed to tie everything together:
 
 *	A git plugin, a popular choice is [EGit](http://eclipse.org/egit/) which is an "Eclipse team provider" (i.e. version control system plugin) for Git.
@@ -23,10 +23,10 @@ Before getting started, you'll need to have a few Eclipse plugins installed to h
 
 **Note**: EGit, WTP, and m2eclipse (as of version 1.0) are hosted by the [Eclipse foundation](http://www.eclipse.org/org/), and they are bundled with some packages of Eclipse.
 
-###3.	Configuring Eclipse with additional plugins
+### 3.	Configuring Eclipse with additional plugins
 Depending on the Eclipse package you chose, you may need to install one or more of the Eclipse components mentioned previously. You should be able to add all the needed components using either the "Install new software" dialog or the "Eclipse marketplace" component available under Eclipse's help menu. 
 
-####3.1. Using Eclipse Marketplace
+#### 3.1. Using Eclipse Marketplace
 The Eclipse Marketplace seems to do a good job with EGit, m2eclipse (also referred to as m2e or "Maven Integration for Eclipse"), and m2e-wtp ("Maven Integration for Eclipse WTP").
 
 You should take the below steps to install your needed components:
@@ -48,7 +48,7 @@ You should take the below steps to install your needed components:
 *	The Web Tools components can in fact be installed via the Eclipse Marketplace system, but they will not be found in a search unless you switch to the "EclipseSource Yoxos Marketplace" instead of the "Eclipse marketplace". This is accomplished by clicking on the Orange circle icon next to the purple Eclipse icon at the bottom of the Marketplace dialog box. 
 
 
-####3.2. Using “Install New Software…” Option
+#### 3.2. Using “Install New Software…” Option
 Alternatively, you can use the “Install New Software” option under the _help_ menu to install the needed components. Also if you do happen to miss some web development components try “Install New Software Option” instead of the “Marketplace”. 
 
 Based on needed components take the below steps:
@@ -64,7 +64,7 @@ Based on needed components take the below steps:
 *	Also if you do happen to miss some web development components,   in the "Work with:" dialog box, type your eclipse server version (e.g. luna) address at http://download.eclipse.org/releases/luna and try  checking the "Web, XML, Java EE, and OSGi Enterprise Development" category, which should include everything you need.  
 
 
-###4.	Clone and import the GraphHopper Source
+### 4.	Clone and import the GraphHopper Source
 At this step you need to clone the GraphHopper GitHub repository locally (get a copy of the GraphHopper source code). Repository cloning can be done using one of the below approaches:
 
 1. EGit Repositories View from within Eclipse
@@ -80,7 +80,7 @@ At this step you need to clone the GraphHopper GitHub repository locally (get a
 Below we talk more about the first and third approaches of cloning.
 
 
-####4.1. Approach 1: Clone the GraphHopper repository with the EGit Repositories View
+#### 4.1. Approach 1: Clone the GraphHopper repository with the EGit Repositories View
 
 * Switch to the "Git Repository Exploring" perspective in Eclipse by selecting:  _Window -> Open Perspective -> Git Repositories_ .
 If you don't see this option under "Open Perspective", choose:  _Window -> Open Perspective -> Other..._ and select "Git Repository Exploring". 
@@ -107,7 +107,7 @@ The "Repository Exploring perspective" is preconfigured to contain the Git Repos
 
 
 
-####4.2. Importing existing GraphHopper Maven projects into Eclipse
+#### 4.2. Importing existing GraphHopper Maven projects into Eclipse
 
 If you used approach 1 or if you have downloaded the GraphHopper zip file directly form GitHub, you have cloned the GraphHopper repository but the GraphHopper Maven projects are not yet visible in Eclipse. To make the projects visible,cover the below steps:
 
@@ -121,7 +121,7 @@ If you used approach 1 or if you have downloaded the GraphHopper zip file direct
 
 * Click _Finish_. It may take a while to initially build all the projects in your workspace. In the background, the Maven plugin is downloading all the project dependencies. If everything works fine you should be able to see each GraphHopper maven module checked out as an individual Eclipse project in your workspace.
 
-####4.3. Approach 2: Clone the GraphHopper repository and import Maven projects all at once
+#### 4.3. Approach 2: Clone the GraphHopper repository and import Maven projects all at once
 To use this method follow the below steps:
 * In Eclipse, choose _File -> Import..._ then choose _Maven / Check out Maven projects from SCM_ in the dialog box, as shown below:
 
@@ -139,7 +139,7 @@ To use this method follow the below steps:
 
 * Click _Finish_, and m2eclipse should both clone the repository and import the Maven projects into your workspace. The Graphhopper top-level maven module, as well as all the other sub-modules, should then appear in your project explorer view. 
 
-####4.4 Making Eclipse aware of your local GraphHopper Git repository
+#### 4.4 Making Eclipse aware of your local GraphHopper Git repository
 
 If you use approach 2 or a command-line method, EGit will not be aware of the Git metadata in the new local repository. Therefore operations on the local Git repository will not automatically be possible from within Eclipse.You can choose to do all Git operations on the command line, or make EGit aware of the repository as follows: 
 
@@ -148,6 +148,3 @@ If you use approach 2 or a command-line method, EGit will not be aware of the Gi
 *	Specify Git as the repository type and check Use or create repository in parent folder of project on the next page. The .git metadata directory should be found and indicated in the dialog box. At this point you can click the _Finish_ button. An orange cylinder should appear on the GraphHopper folder icon in the "Package Explorer", indicating that it is under version control.
 
 Now, you should be able to open the Git repositories view: _Window -> Show View -> Other -> Git Repositories_, and do push, pull, and commit operations in Eclipse. The advantage of this method over the command line is using EGit's graphical diff window which allows you to review changes and select files to commit.
-
-
-
diff --git a/docs/core/edge-based-ch.md b/docs/core/edge-based-ch.md
new file mode 100644
index 0000000000..8bd577057d
--- /dev/null
+++ b/docs/core/edge-based-ch.md
@@ -0,0 +1,48 @@
+# How do edge-based Contraction Hierarchies work in GraphHopper ?
+
+## General Idea
+
+The idea for edge-based CH is the same as for node-based CH: In a pre-processing phase we want to 'contract' the graph which means that we remove nodes from the graph one by one and everytime we do this we have to make sure that all previous shortest path distances remain unchanged. So when we remove a node we might have to add helper edges (shortcuts) between the neighbor nodes of the node we want to remove. We assign a 'rank' (often also called a 'level') to each node as it is contracted (0 for the first node, 1 for the second and so on). Assigning these ranks induces a hierarchical ordering between the nodes which can be exploited to achieve fast queries on the prepared Graph: We only need to settle nodes with higher rank in the forward/backward Dijkstra searches. This is so because, in a CH graph each shortest path between two nodes is an 'up-down' path, i.e. starting from the source the rank of the nodes on the shortest path first only increase until the node with maximum rank is reached and then only decrease. The fwd/bwd searches meet at the node with the highest rank.
+
+## Node Ordering
+
+Just as in node-based CH the order in which we remove the nodes is not important for correctness, but for performance we need heuristics to find a good node ordering. The code for finding this node ordering lives in `PrepareContractionHierarchies` and is the same for node- and edge-based CH. The only difference is how the 'priority' for a node is calculated, which happens in `NodeBasedNodeContractor` or `EdgeBasedNodeContractor`, respectively. As their name suggests, the node contractors are not only responsible to calculate the priority for a node but also to actually contract it (i.e. introduce the necessary shortcuts). However, calculating the priority and contracting a node is very similar, because to calculate the priority we normally need to find all shortcuts (even though we do not add them to the graph in this case). The heuristics used to define the priority of a node are different in the edge-based case than in the node-based case as suggested in the literature [1, 2]. However, there might be potential to improve preparation and query time by using other heuristics or by changing the weights of the different terms entering the priority formula. For edge-based CH we currently use:
+
+* edge-quotient (same idea as edge-difference in node-based CH)
+* original-edge-quotient (like edge-quotient, but only taking into account original edge counts)
+* hierarchy depth (similar but not the same as in node-based CH)
+
+We use the same formula for the priority as in [2], but with different weights. So far trying different weights has not lead to considerable improvements. An unsolved, potential problem with the current implementation is that towards the end of the contraction the `originalEdgeQuotient` rises drastically and dominates the other terms, wich could be an explanation why changing the weights of the terms does not change much and might also lead to too many shortcuts.
+
+## Node Contraction
+For edge-based CH the most effort has to be spent on implementing the `EdgeBasedNodeContractor` which is considerably more complex than `NodeBasedNodeContractor`. The first major difference is that for edge-based routing we obviously need an edge-based shortest path algorithm and this means that when we contract a node we not only have to make sure that the shortest path distance between neighbor *nodes* remains invariant, but we have to assert this for neighboring *edges*. So instead of asking "well we just removed node x, can we still go from u to v with the same weight or do we need to add shortcuts" we have to ask "can we still go from edge e to edge f or do we need to add shortcuts". The next obvious question is then which edges e and f we are talking about. It turns out that it is sufficient to look at the original edges that are in/outgoing at the neighboring nodes of the node we want to contract. This is the idea of the 'aggressive' search in [1] compared to the 'simple' search. Importantly, we are only concerned with original edges. We do not have to look at shortcuts adjacent to the neighbor nodes. This saves us from doing many additional witness path searches. Another important thing to recognize is that there can be many edges going from a neighboring node to the node to be contracted. When we start at the original edges incoming to the neighboring node we basically do all the witness searches needed for these edges at once.
+  
+![image](./images/edge-based-ch.png)
+*Fig.1 In edge-based CH we need to check for shortcuts for all pairs of original edges (here e and f) that are adjacent to neighboring nodes of the node we want to contract (x in the picture). We do not need to perform the check for all pairs of shortcuts adjacent to the neighboring nodes (dashed lines).*
+
+Another very important idea is that to be able to calculate turn costs at a given node we need the edge ids of the incoming and outgoing edge that are part of the turn. This sounds trivial, but what if the incoming or outgoing edge is a shortcut ? Since we use a table lookup to obtain the turn costs the ids of the shortcuts will be of no help. We would have to increase the turncost tables with every shortcut we introduce which would be a lot of redundant information and does not scale on larger maps (this is the way it was done in #912). The solution to this problem is that we store the ids of the first and last original edges with the shortcut. This is also needed for the edge-based shortest path query. When we discover an edge during the edge-based Dijkstra expansion we want to only keep track of the tentative weights for the original edges, not for all shortcut edges.
+
+Also different than in node-based CH is the fact that with edge-based traversal it is possible (and wanted) that we reach a node more than once. This is needed for example when there is a left-turn restriction at a junction and we need to go straight at the junction and then go right a few times until we reach the same junction from another side. However, this also means that there will be loop-shortcuts, which have to be handled specifically in many cases. One important case are loop shortcuts that appear
+at the node to be contracted. In this case the shortcuts we introduce when we contract a node do not simply have a first and second 'skipped edge', but there are is in fact a first skipped edge, a second skipped edge and loops at the node to be contracted. To deal with this case we insert multiple nested shortcuts if this happens as suggested in [3] (but this is done differently in [2]). Another consequence of the fact that nodes can be visited multiple times is that when running witness path searches the source- and target-neighbor-node can be the same. See `EdgeBasedNodeContractor` and the related tests for many more details and specific cases with (and without) loops.
+
+Originally we implemented the turn-replacement algorithm described in [2] to obtain the necessary shortcuts, but this introduces a lot more shortcuts than the current implementation, see tests in `EdgeBasedNodeContractorTest`.
+
+## Witness Path Searches
+
+What is also specific for edge-based CH is how we are able to limit witness path searches. What is a witness path search ? When we want to decide if we need a shortcut for a given pair of neighbor edges (or neighbor nodes in node-based CH) we need to run a search that tells us whether or not there is a shortest path between the two that works without the node we want to contract or not. If there is such a path it witnesses (or proofs) that we can safely remove the node without adding a shortcut, because to go the shortest path we would not need it anyway. If there is no such path we have to insert one or multiple shortcuts in exchange of removing the node. Doing these witness searches means that we need to run many local Dijkstra searches and for performance it is very important to limit the search space of these searches. For node-based CH there is an obvious abort criterion, because we know how long it would take us from start to target when we go directly via the node we want to contract, which means we can set a maximum weight for the local searches. However, for edge-based CH this is not the case because of the loops (and possible turn costs/restrictions) at the node we want to contract. Because the witness path searches that are done by `DijkstraOneToMany` for node-based CH are quite different for edge-based CH they are done by a dedicated class `WitnessPathSearcher` in the GraphHopper implementation. To be able to limit the local search spaces in `WitnessPathSearcher` we limit the searches by the number of settled edges. However, for good performance this limit has to be adjusted dynamically during the contraction (see usages of `OnFlyStatisticsCalculator` in `WitnessPathSearcher`). The number of settled edges is determined by the `sigmaFactor` parameter. Small values mean short witness path searches (=fast contraction), but many shortcuts (=slow queries).
+
+Witness path searches in edge-based CH are done by a one-to-many Dijkstra search. However, there is a special twist. To prevent unnecessary shortcuts we have to decide for each witness path that we find if it was using the node to be contracted or not. To do this we assign a special flag to each shortest path entry (isPathToCenter). Note that a path that goes from the source edge to another neighbor node and then via the node to be contracted to the target edge (s->a->x->t) also counts as witness path, because the shortcut will be introduced when we run the witness path searches between a and t. The same is true for the case s->x->b->t. For details see javadocs in `WitnessPathSearcher`. In principle this concept should also reduce unnecessary shortcuts in node-based CH. 
+
+## Shortcut Insertion
+
+In node-based CH the shortcuts for a given node are first collected and then inserted all at once. This means that consecutive witness searches can not use the shortcuts the previous searches have inserted. In edge-based CH the shortcuts are inserted right away at the moment. Another important difference is that in edge-based CH all shortcuts have forward direction only while in node-based internal 'edges' are re-used for both directions. This is another potential performance improvement for edge-based CH that nobody has really tried doing so far. It might be more complicated than in the edge-based case because of loop-shortcuts ?
+
+## CH Query Algorithm
+
+The edge-based CH algorithm is similar to the one in node-based CH in that it is also a bidirectional Dijkstra search that goes along nodes of increasing rank. However, when the fwd/bwd searches connect with each other we still have to take care of the turn costs at the bridge node (where the searches meet). Also it has been found that AStar speeds up the CH query in the edge-based case (in contrast to node-based CH). Probably, because with edge-based traversing there are more entries to explore and the AStar overhead is amortized earlier. So far there is no stall-on-demand implemented for edge-based CH, mostly because the literature suggests that AStar is more promising [3]. It might be worth trying anyway.
+
+## Literature
+
+- [1] *Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks*, R.Geisberger, 2008
+- [2] *Efficient Routing in Road Networks with Turn Costs*, R.Geisberger and C.Vetter, 2011
+- [3] *Schnelle Wegsucheverfahren auf digitalen Straßenkarten – Entwicklung, Implementierung und Anwendungsbeispiel bei einem Logistikdienstleister*, Dissertation C. Nowak, 2014
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
index 349e816816..5d31ab1c2c 100644
--- a/docs/core/elevation.md
+++ b/docs/core/elevation.md
@@ -1,7 +1,7 @@
 # Elevation
 
 Per default elevation is disabled. But you can easily enable it e.g. via
-`graph.elevation.provider=cgiar`. Or use other possibilities `srtm`, `gmted`
+`graph.elevation.provider: cgiar`. Or use other possibilities `srtm`, `gmted`
 or `multi` (combined cgiar and gmted).
 
 Then GraphHopper will automatically download the necessary data for the area and include elevation 
@@ -9,7 +9,7 @@ for all vehicles - making also the distances a bit more precise.
 
 The default cache directory `/tmp/<provider name>` will be used. For large areas it is highly recommended to 
 use a SSD disc, thus you need to specify the cache directory:
-`graph.elevation.cache_dir=/myssd/ele_cache/`
+`graph.elevation.cache_dir: /myssd/ele_cache/`
 
 ## What to download and where to store it? 
 
@@ -23,7 +23,7 @@ where the last one is only accessibly if you specify the
 [full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
 
 If the geographical area is small and you need a faster import you can change the default MMAP setting to:
-`graph.elevation.dataaccess=RAM_STORE`
+`graph.elevation.dataaccess: RAM_STORE`
 
 ## CGIAR vs. SRTM
 
@@ -36,4 +36,4 @@ Using SRTM instead CGIAR has the minor advantage of a faster download, especiall
 
 Integrating your own elevation data is easy and just requires you to implement the
 ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
-Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
diff --git a/docs/core/images/edge-based-ch.png b/docs/core/images/edge-based-ch.png
new file mode 100644
index 0000000000..31c0141e6e
Binary files /dev/null and b/docs/core/images/edge-based-ch.png differ
diff --git a/docs/core/images/wiki-graph.png b/docs/core/images/wiki-graph.png
new file mode 100755
index 0000000000..436dad79f6
Binary files /dev/null and b/docs/core/images/wiki-graph.png differ
diff --git a/docs/core/low-level-api.md b/docs/core/low-level-api.md
index c0b6d3e8bb..4cada3cae0 100644
--- a/docs/core/low-level-api.md
+++ b/docs/core/low-level-api.md
@@ -46,7 +46,7 @@ create new virtual nodes or if close enough use the existing junction node.
 
 ```java
 FlagEncoder encoder = new CarFlagEncoder();
-EncodingManager em = new EncodingManager(encoder);
+EncodingManager em = EncodingManager.create(encoder);
 GraphBuilder gb = new GraphBuilder(em).setLocation("graphhopper_folder").setStore(true);
 GraphStorage graph = gb.create();
 // Make a weighted edge between two nodes.
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index 4189c69686..6105a36830 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -6,23 +6,33 @@
 
 For a start which requires only the JRE have a look [here](../web/quickstart.md). 
 Windows user can find a quick guide [here](./windows-setup.md).
-People with IDE knowledge can directly jump to [Start Development](#start-development)
+People with IDE knowledge can directly jump to [Start Development](#start-development).
 
-Now, before you proceed install git and jdk8, then do:
+To proceed install `git` and `openjdk8` or `openjdk11`. Get the a jdk from your package manager, 
+[AdoptOpenJDK](https://adoptopenjdk.net/) or [Red Hat](https://github.com/ojdkbuild/ojdkbuild/releases).
+
+Then do:
 
 ```bash
-$ git clone git://github.com/graphhopper/graphhopper.git
-$ cd graphhopper; git checkout master
-$ ./graphhopper.sh -a web -i europe_germany_berlin.pbf
-now go to http://localhost:8989/
+git clone git://github.com/graphhopper/graphhopper.git
+cd graphhopper; git checkout master
+# fetches main.js, can be omitted if no UI is needed
+cd web/src/main/resources/ && ZFILE=/tmp/gh.jar && wget -O $ZFILE "https://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.graphhopper&a=graphhopper-web&v=LATEST" && unzip $ZFILE assets/js/main.js && rm $ZFILE && cd ../../../..
+./graphhopper.sh -a web -i europe_germany_berlin.pbf
+# now go to http://localhost:8989/ and you should see something similar to GraphHopper Maps: https://graphhopper.com/maps/
 ```
 
-  1. These steps make the Berlin area routable. It'll download and unzip the osm file for you.
-  2. It builds the graphhopper jars. If Maven is not available it will automatically download it.
-  3. Then it creates routable files for graphhopper in the folder europe_germany_berlin-gh. It'll skip this step if files are already present.
-  4. Also check the instructions for [Android](../android/index.md)
+In the last step the data is created to get routes within the Berlin area:
+
+  1. The script downloads the OpenStreetMap data of that area
+  2. It builds the graphhopper jar. If Maven is not available it will automatically download it.
+  3. Then it creates routable files for graphhopper in the folder europe_germany_berlin-gh. 
+  4. It will create data for a special routing algorithm to dramatically improve query speed. It skips step 3. and 4. if these files are already present.
+  5. It starts the web service to service the UI and also the many endpoints like /route
+
+See also the instructions for [Android](../android/index.md)
 
-For you favourite area do
+For you favourite area do e.g.:
 
 ```bash
 $ ./graphhopper.sh -a web -i europe_france.pbf -o france-gh
@@ -30,7 +40,7 @@ $ ./graphhopper.sh -a web -i north-america_us_new-york.pbf -o new-york-gh
 # the format follows the link structure at http://download.geofabrik.de
 ```
 
-For larger maps you might need to allow the JVM to access more memory. For example for 2GB you can do this using:
+For larger maps you need to allow the JVM to access more memory. For example for 2GB you can do this using:
 ```bash
 $ export JAVA_OPTS="-Xmx2g -Xms2g"
 ```
@@ -40,20 +50,17 @@ before running `graphhopper.sh`.
 
 Open the project in your IDE, first class IDEs are NetBeans and IntelliJ where no further setup is required.
 
-### Running / Debbuging with IntelliJ
+### Running & Debbuging with IntelliJ
 
 ![intelliJ run config](./images/intellij-run-config.png)
 
 Go to `Run->Edit Configurations...` and set the following to run GraphHopper from within IntelliJ:
 ```
 Main class: com.graphhopper.http.GraphHopperApplication
-VM options: -Xms1000m -Xmx1000m -server -Dgraphhopper.datareader.file=[your-area].osm.pbf -Dgraphhopper.graph.location=./[your-area].osm-gh
+VM options: -Xms1g -Xmx1g -server -Dgraphhopper.datareader.file=[your-area].osm.pbf -Dgraphhopper.graph.location=./[your-area].osm-gh
 Program arguments: server config.yml
 ```
 
-Note:  you might need to modify Xms and Xmx values, for larger areas you might want to use higher values.
-
-
 ### Contribute
 
 See this [guide](https://github.com/graphhopper/graphhopper/blob/master/.github/CONTRIBUTING.md) on how to contribute.
@@ -63,7 +70,7 @@ See this [guide](https://github.com/graphhopper/graphhopper/blob/master/.github/
 Have a look into the [Java API documentation](../index.md#developer) for further details e.g. how [GraphHopper can
 be embedded](./routing.md) into your application and how you create a [custom weighting](./weighting.md).
 
-Look [here](http://graphhopper.com/#community) for the maven snippet to use GraphHopper in your
+Look [here](https://github.com/graphhopper/graphhopper#maven) for the maven snippet to use GraphHopper in your
 application. To use an unreleased snapshot version of GraphHopper you need the following snippet in your pom.xml
 as those versions are not in maven central:
 
@@ -93,34 +100,19 @@ assets:
     /maps: web/src/main/resources/assets/
 ```
 
-The run the graphhopper.sh script with the web action and open the browser at
-`localhost:8989`. You should see something like [GraphHopper Maps](https://graphhopper.com/maps/).
+To setup the JavaScript development environment install the [node package
+manager](https://github.com/nvm-sh/nvm):
 
-To setup the JavaScript environment install the node package manager (npm):
-
-For linux do
 ```bash
-curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.9/install.sh | bash
-# close and reopen terminal now
-nvm install --lts
-nvm use --lts
+wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash && \. $HOME/.nvm/nvm.sh && nvm install
+# create main.js via npm
+cd web && npm install && npm run bundleProduction && cd ..
 ```
 
-For windows download either [nvm](https://github.com/coreybutler/nvm-windows) or [node](https://nodejs.org/en/download/) directly.
-
-Then generate the main.js
-```bash
-# git clone https://github.com/graphhopper/graphhopper.git
-cd graphhopper/web
-# download required packages:
-npm install
-npm test
-# overwrites main.js
-npm run bundle
-```
+For windows use [nvm-windows](https://github.com/coreybutler/nvm-windows).
 
-There are more npm commands e.g. to change the main.js on the fly or create an uglified main.js for
-production.
+There are more npm commands to e.g. change the main.js on the fly or create an uglified main.js for
+production:
 
 ```bash
 cd web
diff --git a/docs/core/routing.md b/docs/core/routing.md
index fcb130c68b..038bb0b06e 100644
--- a/docs/core/routing.md
+++ b/docs/core/routing.md
@@ -11,7 +11,7 @@ GraphHopper hopper = new GraphHopperOSM().forServer();
 hopper.setDataReaderFile(osmFile);
 // where to store graphhopper files?
 hopper.setGraphHopperLocation(graphFolder);
-hopper.setEncodingManager(new EncodingManager("car"));
+hopper.setEncodingManager(EncodingManager.create("car"));
 
 // now this can take minutes if it imports or a few seconds for loading
 // of course this is dependent on the area you import
@@ -60,7 +60,7 @@ config.yml `prepare.ch.weightings=no`) or on a per request base by adding `ch.di
 (see config.yml `prepare.lm.weightings=fastest`).
 
 If you need multiple vehicle profiles you can specify a list of vehicle profiles (see
-config.yml e.g. `graph.flag_encoders=car,bike` or use `new EncodingManager("car,bike")`). 
+config.yml e.g. `graph.flag_encoders=car,bike` or use `EncodingManager.create("car,bike")`). 
 
 To calculate a route you have to pick one vehicle and optionally an algorithm like `bidirectional_astar`:
 
@@ -69,7 +69,7 @@ GraphHopper hopper = new GraphHopperOSM().forServer();
 hopper.setCHEnabled(false);
 hopper.setOSMFile(osmFile);
 hopper.setGraphHopperLocation(graphFolder);
-hopper.setEncodingManager(new EncodingManager("car,bike"));
+hopper.setEncodingManager(EncodingManager.create("car,bike"));
 
 hopper.importOrLoad();
 
@@ -80,8 +80,9 @@ GHResponse res = hopper.route(req);
 
 ## Heading
 
-The flexibile and hybrid mode allows to add a desired heading (north based azimuth between 0 and 360 degree)
-to any point. Adding a heading makes it more likely that a route starts towards the provided direction:
+The flexible and hybrid modes allow adding a desired heading (north based azimuth between 0 and 360 degree)
+to any point. Adding a heading makes it more likely that a route starts towards the provided direction, because
+roads going into other directions are penalized (see the Routing.HEADING_PENALTY parameter)
 ```java
 GHRequest req = new GHRequest().addPoint(new GHPoint (latFrom, lonFrom), favoredHeading).addPoint(new GHPoint (latTo, lonTo));
 ```
diff --git a/docs/core/technical.md b/docs/core/technical.md
index c2b0d75828..1a9910180a 100644
--- a/docs/core/technical.md
+++ b/docs/core/technical.md
@@ -31,7 +31,7 @@ it is currently the case.
 
 The data layout for the DataAccess objects in GraphHopperStorage called 'nodes' and 'edges' is the following:
 
-![storage layout](http://karussell.files.wordpress.com/2013/08/wiki-graph.png)
+![storage layout](./images/wiki-graph.png)
 
 Some explanations:
  * One 'node row' consists of latitude,longitude (not shown) and the first edgeID
diff --git a/docs/core/turn-restrictions.md b/docs/core/turn-restrictions.md
index eb1a971b90..68a03613aa 100644
--- a/docs/core/turn-restrictions.md
+++ b/docs/core/turn-restrictions.md
@@ -1,9 +1,6 @@
 # How to work with Turn Restrictions
 
 GraphHopper supports [turn restrictions](http://wiki.openstreetmap.org/wiki/Relation:restriction).
-Currently, it is not possible to use turn restrictions with the 'speed mode' (contraction hierarchies),
-but it's possible using the 'hybrid mode' (landmarks) and with the 'flexible mode', 
-[see this link for details about the different modes](https://github.com/graphhopper/graphhopper#technical-overview).
 Turn restrictions are crucial for correct vehicle navigation and help to avoid forbidden turns.
 
 [Without turn restrictions](https://graphhopper.com/maps/?point=23.1047%2C-82.44319&point=23.10544%2C-82.44316) (the turn is not allowed):
@@ -18,5 +15,12 @@ Turn restrictions have to be enabled on a vehicle basis. To enable it for one ve
 `|turn_costs=true` in the config, for example: `graph.flag_encoders=car|turn_costs=true`.
 Turn restrictions are not available for every vehicle as they have low relevance
 for some vehicles like `foot`. 
-If you enabled the 'speed mode' on import e.g. with `prepare.ch.weightings=fastest` in the configuration, then you'll 
-need to disable the 'speed mode' per request by adding `ch.disable=true` as URL parameter.
\ No newline at end of file
+To enable turn restrictions when using the 'speed mode' additional graph preparation is required, because turn restrictions
+require edge-based (vs. node-based) traversal of the graph. First you have to set the weightings for which the graph 
+preparation should be run using e.g. `prepare.ch.weightings=fastest`, just like when you use the 'speed mode' without 
+turn restrictions. Additionally you need to set `prepare.ch.turn_costs` to `edge_or_node` or `edge_and_node`
+(see `config-example.yml` for further details). At request time you need to add `edge_based=true` as URL parameter to 
+enable turn restricted routing and to disable the 'speed mode' per request you can add `ch.disable=true`.
+
+While OSM data only contains turn *restrictions*, the GraphHopper routing engine can also deal with turn *costs*, i.e.
+you can specify custom turn costs for each turn at each junction.
\ No newline at end of file
diff --git a/docs/core/weighting.md b/docs/core/weighting.md
index 3805e25d65..ec46ee2313 100644
--- a/docs/core/weighting.md
+++ b/docs/core/weighting.md
@@ -36,11 +36,11 @@ class MyGraphHopper extends GraphHopper {
     @Override
     public Weighting createWeighting(HintsMap hintsMap, FlagEncoder encoder, Graph graph) {
         String weightingStr = hintsMap.getWeighting().toLowerCase();
-        if ("my_custom_weighting".equals(weighting)) {
+        if ("my_custom_weighting".equals(weightingStr)) {
             return new MyCustomWeighting(encoder);
         } else {
             return super.createWeighting(hintsMap, encoder, graph);
         }
     }
 }
-```
\ No newline at end of file
+```
diff --git a/docs/index.md b/docs/index.md
index 27bf02ebe4..e27b0efb19 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -63,7 +63,8 @@ Various topics are explained in more detail separately:
  * [Spatial Rules](./core/spatial-rules.md): Instruction on how to use and create new SpatialRules. SpatialRules are used to enforce country-specific routing rules.
  * [Turn Restrictions](./core/turn-restrictions.md): Details on how to enable and use turn restrictions.
  * [Isochrone generation in Java](./isochrone/java.md): Instruction on how to create isochrones using the low-level Java API.
- * [Postgis query script](./core/files/postgis)
+ * [Change Graph](./core/change-graph.md): Details about changing values of the graph without restarting GraphHopper.
+ * [Postgis query script](../core/files/postgis)
 
 
 #### Other links
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index 8b06a1cbf9..2cd4c7959a 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -26,7 +26,8 @@ debug            | false   | If true, the output will be formated.
 calc_points      | true    | If the points for the route should be calculated at all printing out only distance and time.
 type             | json    | Specifies the resulting format of the route, for `json` the content type will be application/json. Other possible format options: <br> `gpx`, the content type will be application/gpx+xml, see below for more parameters.
 point_hint       | -       | Optional parameter. Specifies a hint for each `point` parameter to prefer a certain street for the closest location lookup. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
-details          | -       | Optional parameter. You can request additional details for the route: `average_speed`, `street_name`, `edge_id`, and `time`. The returned format for one details is `[fromRef, toRef, value]`. The `ref` references the points of the response.
+snap_prevention  | -       | Optional parameter to avoid snapping to a certain road class or road environment. Current supported values: `motorway`, `trunk`, `ferry`, `tunnel`, `bridge` and `ford`. Multiple values are specified like `snap_prevention=ferry&snap_prevention=motorway`
+details          | -       | Optional parameter. You can request additional details for the route: `average_speed`, `street_name`, `edge_id`, `road_class`, `road_environment`, `max_speed` and `time` (and see which other values are configured in `graph.encoded_values`).  Multiple values are specified like `details=average_speed&details=time`. The returned format for one detail segment is `[fromRef, toRef, value]`. The `ref` references the points of the response. Value can also be `null` if the property does not exist for one detail segment.
 
 ### GPX
 
diff --git a/docs/web/quickstart.md b/docs/web/quickstart.md
index ac47f822b8..a28bd1fc1a 100644
--- a/docs/web/quickstart.md
+++ b/docs/web/quickstart.md
@@ -3,14 +3,15 @@
 If you want to build GraphHopper from source look at the [Developers page](../core/quickstart-from-source.md). 
 The following steps are simpler and only need the JRE, a jar file and an OSM file.
 
- 1. Install the latest JRE and get the [GraphHopper Web Service](https://github.com/graphhopper/graphhopper/blob/master/README.md#get-started)
-as jar file
- 2. Copy an OSM file to the same directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
- 3. Start GraphHopper Maps via: 
+ 1. Install the latest JRE 
+ 2. Get the [GraphHopper Web Service](https://github.com/graphhopper/graphhopper/blob/master/README.md#get-started)
+as jar file and download this [config-example.yml](https://raw.githubusercontent.com/graphhopper/graphhopper/master/config-example.yml)
+ 3. Copy an OSM file to the same directory. For example [berlin-latest.osm.pbf](http://download.geofabrik.de/europe/germany/berlin.html)
+ 4. Start GraphHopper Maps via: 
     ```bash
     java -Dgraphhopper.datareader.file=berlin-latest.osm.pbf -jar *.jar server config-example.yml
     ```
- 4. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
+ 5. After you see 'Started server at HTTP 8989' go to [http://localhost:8989/](http://localhost:8989/) and you should see a map of Berlin. You should be able to click on the map and a route appears.
 
 See [here](./../core/elevation.md) how to easily enable elevation data. To see how GraphHopper is configured for production usage, see the [deployment guide](./../core/deploy.md).
 
diff --git a/isochrone/pom.xml b/isochrone/pom.xml
index 803a338902..60a772c4ff 100644
--- a/isochrone/pom.xml
+++ b/isochrone/pom.xml
@@ -6,17 +6,16 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-isochrone</artifactId>
     <packaging>jar</packaging>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <name>GraphHopper Isochrone</name>
     <description>Isochrone calculation with GraphHopper</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
 
-
     <dependencies>
         <dependency>
             <groupId>com.graphhopper</groupId>
@@ -24,6 +23,25 @@
             <version>${project.parent.version}</version>
         </dependency>
 
+        <dependency>
+            <groupId>com.wdtinc</groupId>
+            <artifactId>mapbox-vector-tile</artifactId>
+            <version>3.1.0</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-log4j12</artifactId>
+            <version>${slf4j.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>log4j</groupId>
+            <artifactId>log4j</artifactId>
+            <version>${log4j.version}</version>
+            <scope>test</scope>
+        </dependency>
+
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
@@ -31,7 +49,6 @@
             <scope>test</scope>
         </dependency>
     </dependencies>
-
 </project>
 
 
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/ContourBuilder.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/ContourBuilder.java
index 593c24a68a..ae612cba4b 100644
--- a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/ContourBuilder.java
+++ b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/ContourBuilder.java
@@ -13,10 +13,10 @@
 
 package com.graphhopper.isochrone.algorithm;
 
-import com.vividsolutions.jts.algorithm.CGAlgorithms;
-import com.vividsolutions.jts.geom.*;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdge;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdgeSubdivision;
+import org.locationtech.jts.algorithm.CGAlgorithms;
+import org.locationtech.jts.geom.*;
+import org.locationtech.jts.triangulate.quadedge.QuadEdge;
+import org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision;
 
 import java.util.*;
 
@@ -40,7 +40,7 @@ public ContourBuilder(QuadEdgeSubdivision triangulation) {
         this.triangulation = triangulation;
     }
 
-    public Geometry computeIsoline(double z0) {
+    public MultiPolygon computeIsoline(double z0) {
         Set<QuadEdge> processed = new HashSet<>();
         List<LinearRing> rings = new ArrayList<>();
 
@@ -107,8 +107,8 @@ private Coordinate moveEpsilonTowards(Coordinate coordinate, Coordinate distantF
     }
 
     private int cut(double za, double zb, double z0) {
-        if (za < z0 && zb > z0) return 1;
-        if (za > z0 && zb < z0) return -1;
+        if (za <= z0 && zb > z0) return 1;
+        if (za > z0 && zb <= z0) return -1;
         return 0;
     }
 
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilder.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilder.java
new file mode 100644
index 0000000000..75b66bcca4
--- /dev/null
+++ b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilder.java
@@ -0,0 +1,87 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.isochrone.algorithm;
+
+import org.locationtech.jts.geom.*;
+import org.locationtech.jts.triangulate.ConformingDelaunayTriangulator;
+import org.locationtech.jts.triangulate.ConstraintVertex;
+import org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision;
+import org.locationtech.jts.triangulate.quadedge.Vertex;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * @author Peter Karich
+ * @author Michael Zilske
+ */
+public class DelaunayTriangulationIsolineBuilder {
+
+    /**
+     * @return a list of polygons wrapping the specified points
+     */
+    @SuppressWarnings("unchecked")
+    public List<Coordinate[]> calcList(List<List<Coordinate>> pointLists, int maxIsolines) {
+
+        if (maxIsolines > pointLists.size()) {
+            throw new IllegalStateException("maxIsolines can only be smaller or equals to pointsList");
+        }
+
+        Collection<ConstraintVertex> sites = new ArrayList<>();
+        for (int i = 0; i < pointLists.size(); i++) {
+            List<Coordinate> level = pointLists.get(i);
+            for (Coordinate coord : level) {
+                ConstraintVertex site = new ConstraintVertex(coord);
+                site.setZ((double) i);
+                sites.add(site);
+            }
+        }
+        ConformingDelaunayTriangulator conformingDelaunayTriangulator = new ConformingDelaunayTriangulator(sites, 0.0);
+        conformingDelaunayTriangulator.setConstraints(new ArrayList(), new ArrayList());
+        conformingDelaunayTriangulator.formInitialDelaunay();
+        QuadEdgeSubdivision tin = conformingDelaunayTriangulator.getSubdivision();
+        for (Vertex vertex : (Collection<Vertex>) tin.getVertices(true)) {
+            if (tin.isFrameVertex(vertex)) {
+                vertex.setZ(Double.MAX_VALUE);
+            }
+        }
+        ArrayList<Coordinate[]> polygonShells = new ArrayList<>();
+        ContourBuilder contourBuilder = new ContourBuilder(tin);
+        // ignore the last isoline as it forms just the convex hull
+        for (int i = 0; i < maxIsolines; i++) {
+            MultiPolygon multiPolygon = contourBuilder.computeIsoline((double) i + 0.5);
+            int maxPoints = 0;
+            Polygon maxPolygon = null;
+            for (int j = 0; j < multiPolygon.getNumGeometries(); j++) {
+                Polygon polygon = (Polygon) multiPolygon.getGeometryN(j);
+                if (polygon.getNumPoints() > maxPoints) {
+                    maxPoints = polygon.getNumPoints();
+                    maxPolygon = polygon;
+                }
+            }
+            if (maxPolygon == null) {
+                throw new IllegalStateException("no maximum polygon was found?");
+            } else {
+                polygonShells.add(maxPolygon.getExteriorRing().getCoordinates());
+            }
+        }
+        return polygonShells;
+    }
+
+}
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
index 771191ad39..cd0da7f7a9 100644
--- a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
+++ b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/Isochrone.java
@@ -29,6 +29,8 @@
 import com.graphhopper.storage.SPTEntry;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
+import com.graphhopper.util.shapes.GHPoint;
+import org.locationtech.jts.geom.Coordinate;
 
 import java.util.*;
 
@@ -102,14 +104,61 @@ public void setDistanceLimit(double limit) {
         this.finishLimit = limit + Math.max(limit * 0.14, 2_000);
     }
 
-    public List<List<Double[]>> searchGPS(int from, final int bucketCount) {
+    public static class IsoLabelWithCoordinates {
+        public final int nodeId;
+        public int edgeId, prevEdgeId, prevNodeId;
+        public int timeInSec, prevTimeInSec;
+        public int distance, prevDistance;
+        public GHPoint coordinate, prevCoordinate;
+
+        public IsoLabelWithCoordinates(int nodeId) {
+            this.nodeId = nodeId;
+        }
+    }
+
+    public interface Callback {
+        void add(IsoLabelWithCoordinates label);
+    }
+
+    public void search(int from, final Callback callback) {
+        searchInternal(from);
+
+        final NodeAccess na = graph.getNodeAccess();
+        fromMap.forEach(new IntObjectProcedure<IsoLabel>() {
+
+            @Override
+            public void apply(int nodeId, IsoLabel label) {
+                double lat = na.getLatitude(nodeId);
+                double lon = na.getLongitude(nodeId);
+                IsoLabelWithCoordinates isoLabelWC = new IsoLabelWithCoordinates(nodeId);
+                isoLabelWC.coordinate = new GHPoint(lat, lon);
+                isoLabelWC.timeInSec = Math.round(label.time);
+                isoLabelWC.distance = (int) Math.round(label.distance);
+                isoLabelWC.edgeId = label.edge;
+                if (label.parent != null) {
+                    IsoLabel prevLabel = (IsoLabel) label.parent;
+                    nodeId = prevLabel.adjNode;
+                    double prevLat = na.getLatitude(nodeId);
+                    double prevLon = na.getLongitude(nodeId);
+                    isoLabelWC.prevNodeId = nodeId;
+                    isoLabelWC.prevEdgeId = prevLabel.edge;
+                    isoLabelWC.prevCoordinate = new GHPoint(prevLat, prevLon);
+                    isoLabelWC.prevDistance = (int) Math.round(prevLabel.distance);
+                    isoLabelWC.prevTimeInSec = Math.round(prevLabel.time);
+                }
+                callback.add(isoLabelWC);
+            }
+        });
+    }
+
+    public List<List<Coordinate>> searchGPS(int from, final int bucketCount) {
         searchInternal(from);
 
         final double bucketSize = limit / bucketCount;
-        final List<List<Double[]>> buckets = new ArrayList<>(bucketCount);
+        final List<List<Coordinate>> buckets = new ArrayList<>(bucketCount);
 
         for (int i = 0; i < bucketCount + 1; i++) {
-            buckets.add(new ArrayList<Double[]>());
+            buckets.add(new ArrayList<Coordinate>());
         }
         final NodeAccess na = graph.getNodeAccess();
         fromMap.forEach(new IntObjectProcedure<IsoLabel>() {
@@ -125,14 +174,14 @@ public void apply(int nodeId, IsoLabel label) {
 
                 double lat = na.getLatitude(nodeId);
                 double lon = na.getLongitude(nodeId);
-                buckets.get(bucketIndex).add(new Double[]{lon, lat});
+                buckets.get(bucketIndex).add(new Coordinate(lon, lat));
 
                 // guess center of road to increase precision a bit for longer roads
                 if (label.parent != null) {
                     nodeId = label.parent.adjNode;
                     double lat2 = na.getLatitude(nodeId);
                     double lon2 = na.getLongitude(nodeId);
-                    buckets.get(bucketIndex).add(new Double[]{(lon + lon2) / 2, (lat + lat2) / 2});
+                    buckets.get(bucketIndex).add(new Coordinate((lon + lon2) / 2, (lat + lat2) / 2));
                 }
             }
         });
@@ -189,15 +238,11 @@ private void searchInternal(int from) {
                 if (!accept(iter, currEdge.edge)) {
                     continue;
                 }
-                // minor speed up
-                if (currEdge.edge == iter.getEdge()) {
-                    continue;
-                }
 
                 double tmpWeight = weighting.calcWeight(iter, reverseFlow, currEdge.edge) + currEdge.weight;
                 if (Double.isInfinite(tmpWeight))
                     continue;
-                
+
                 double tmpDistance = iter.getDistance() + currEdge.distance;
                 long tmpTime = weighting.calcMillis(iter, reverseFlow, currEdge.edge) + currEdge.time;
                 int tmpNode = iter.getAdjNode();
diff --git a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/RasterHullBuilder.java b/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/RasterHullBuilder.java
deleted file mode 100644
index c54f0b7670..0000000000
--- a/isochrone/src/main/java/com/graphhopper/isochrone/algorithm/RasterHullBuilder.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.isochrone.algorithm;
-
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.Geometry;
-import com.vividsolutions.jts.geom.LineString;
-import com.vividsolutions.jts.geom.MultiPolygon;
-import com.vividsolutions.jts.geom.Point;
-import com.vividsolutions.jts.geom.Polygon;
-import com.vividsolutions.jts.triangulate.ConformingDelaunayTriangulator;
-import com.vividsolutions.jts.triangulate.ConstraintVertex;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdgeSubdivision;
-import com.vividsolutions.jts.triangulate.quadedge.Vertex;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * @author Peter Karich
- * @author Michael Zilske
- */
-public class RasterHullBuilder {
-
-    /**
-     * @return a list of polygons wrapping the specified points
-     */
-    @SuppressWarnings("unchecked")
-    public List<List<Double[]>> calcList(List<List<Double[]>> pointsList, int maxIsolines) {
-
-        if (maxIsolines > pointsList.size()) {
-            throw new IllegalStateException("maxIsolines can only be smaller or equals to pointsList");
-        }
-
-        Collection<ConstraintVertex> sites = new ArrayList<>();
-        for (int i = 0; i < pointsList.size(); i++) {
-            List<Double[]> level = pointsList.get(i);
-            for (Double[] xy : level) {
-                ConstraintVertex site = new ConstraintVertex(new Coordinate(xy[0], xy[1]));
-                site.setZ((double) i);
-                sites.add(site);
-            }
-        }
-        ConformingDelaunayTriangulator conformingDelaunayTriangulator = new ConformingDelaunayTriangulator(sites, 0.0);
-        conformingDelaunayTriangulator.setConstraints(new ArrayList(), new ArrayList());
-        conformingDelaunayTriangulator.formInitialDelaunay();
-        QuadEdgeSubdivision tin = conformingDelaunayTriangulator.getSubdivision();
-        for (Vertex vertex : (Collection<Vertex>) tin.getVertices(true)) {
-            if (tin.isFrameVertex(vertex)) {
-                vertex.setZ(Double.MAX_VALUE);
-            }
-        }
-        ArrayList<List<Double[]>> polygons = new ArrayList<>();
-        ContourBuilder contourBuilder = new ContourBuilder(tin);
-        // ignore the last polygon as it forms just the convex hull
-        for (int i = 0; i < maxIsolines; i++) {
-            Geometry geometry = contourBuilder.computeIsoline((double) i + 0.5);
-            List<Double[]> coords = new ArrayList<Double[]>();
-            if (geometry instanceof MultiPolygon) {
-                MultiPolygon mPoly = (MultiPolygon) geometry;
-                int maxPoints = 0;
-                Geometry maxGeo = null;
-                for (int j = 0; j < mPoly.getNumGeometries(); j++) {
-                    Geometry geo = mPoly.getGeometryN(j);
-                    if (geo.getNumPoints() > maxPoints) {
-                        maxPoints = geo.getNumPoints();
-                        maxGeo = geo;
-                    }
-                }
-
-                if (maxGeo == null) {
-                    throw new IllegalStateException("no maximum polygon was found?");
-                } else {
-                    fillExteriorRing(coords, maxGeo);
-                }
-            } else if (geometry instanceof Polygon) {
-                fillExteriorRing(coords, geometry);
-            } else {
-                throw new IllegalStateException("geometry no (multi)polygon");
-            }
-
-            polygons.add(coords);
-        }
-
-        return polygons;
-    }
-
-    private void fillExteriorRing(List<Double[]> coords, Geometry geo) {
-        if (geo instanceof Polygon) {
-            // normally this will be picked
-            Polygon poly = (Polygon) geo;
-            LineString ls = poly.getExteriorRing();
-            for (int j = 0; j < ls.getNumPoints(); j++) {
-                Point p = ls.getPointN(j);
-                coords.add(new Double[]{p.getX(), p.getY()});
-            }
-        } else {
-            int len = geo.getCoordinates().length;
-            Coordinate first = geo.getCoordinates()[0];
-            for (int j = 0; j < len; j++) {
-                Coordinate coord = geo.getCoordinates()[j];
-                // lon, lat
-                coords.add(new Double[]{coord.x, coord.y});
-
-                if (j > 10 && coord.x == first.x && coord.y == first.y) {
-                    break;
-                }
-            }
-        }
-    }
-
-}
diff --git a/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilderTest.java b/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilderTest.java
new file mode 100644
index 0000000000..a03241a981
--- /dev/null
+++ b/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/DelaunayTriangulationIsolineBuilderTest.java
@@ -0,0 +1,32 @@
+package com.graphhopper.isochrone.algorithm;
+
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.Assert;
+import org.junit.Test;
+import org.locationtech.jts.geom.Coordinate;
+
+/**
+ *
+ * @author Peter Karich
+ */
+public class DelaunayTriangulationIsolineBuilderTest {
+
+    @Test
+    public void testCalc() {
+        DelaunayTriangulationIsolineBuilder instance = new DelaunayTriangulationIsolineBuilder();
+        List<List<Coordinate>> listOfList = new ArrayList<>();
+        List<Coordinate> list = new ArrayList<>();
+        listOfList.add(list);
+        // lon,lat!
+        list.add(new Coordinate(0.000, 0.000));
+        list.add(new Coordinate(0.001, 0.000));
+        list.add(new Coordinate(0.001, 0.001));
+        list.add(new Coordinate(0.001, 0.002));
+        list.add(new Coordinate(0.000, 0.002));
+
+        List<Coordinate[]> res = instance.calcList(listOfList, listOfList.size());
+        Coordinate[] geometry = res.get(0);
+        Assert.assertEquals(9, geometry.length);
+    }
+}
diff --git a/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/IsochroneTest.java b/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/IsochroneTest.java
index e43d24d7f7..2169078b6c 100644
--- a/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/IsochroneTest.java
+++ b/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/IsochroneTest.java
@@ -8,6 +8,7 @@
 import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.util.GHUtility;
 import com.graphhopper.util.PMap;
 import org.junit.After;
 import org.junit.Before;
@@ -24,7 +25,7 @@
  */
 public class IsochroneTest {
 
-    private final EncodingManager encodingManager = new EncodingManager("car");
+    private final EncodingManager encodingManager = EncodingManager.create("car");
     private final FlagEncoder carEncoder = encodingManager.getEncoder("car");
     private GraphHopperStorage graph;
 
@@ -46,26 +47,26 @@ public void tearDown() {
     // |/ \--7
     // 6----/
     private void initDirectedAndDiffSpeed(Graph graph) {
-        graph.edge(0, 1).setDistance(70).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(0, 4).setDistance(50).setFlags(carEncoder.setProperties(20, true, false));
+        GHUtility.setProperties(graph.edge(0, 1).setDistance(70), carEncoder, 10, true, false);
+        GHUtility.setProperties(graph.edge(0, 4).setDistance(50), carEncoder, 20, true, false);
 
-        graph.edge(1, 4).setDistance(70).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 5).setDistance(70).setFlags(carEncoder.setProperties(10, true, true));
-        graph.edge(1, 2).setDistance(200).setFlags(carEncoder.setProperties(10, true, true));
+        GHUtility.setProperties(graph.edge(1, 4).setDistance(70), carEncoder, 10, true, true);
+        GHUtility.setProperties(graph.edge(1, 5).setDistance(70), carEncoder, 10, true, true);
+        GHUtility.setProperties(graph.edge(1, 2).setDistance(200), carEncoder, 10, true, true);
 
-        graph.edge(5, 2).setDistance(50).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(2, 3).setDistance(50).setFlags(carEncoder.setProperties(10, true, false));
+        GHUtility.setProperties(graph.edge(5, 2).setDistance(50), carEncoder, 10, true, false);
+        GHUtility.setProperties(graph.edge(2, 3).setDistance(50), carEncoder, 10, true, false);
 
-        graph.edge(5, 3).setDistance(110).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(3, 7).setDistance(70).setFlags(carEncoder.setProperties(10, true, false));
+        GHUtility.setProperties(graph.edge(5, 3).setDistance(110), carEncoder, 20, true, false);
+        GHUtility.setProperties(graph.edge(3, 7).setDistance(70), carEncoder, 10, true, false);
 
-        graph.edge(4, 6).setDistance(50).setFlags(carEncoder.setProperties(20, true, false));
-        graph.edge(5, 4).setDistance(70).setFlags(carEncoder.setProperties(10, true, false));
+        GHUtility.setProperties(graph.edge(4, 6).setDistance(50), carEncoder, 20, true, false);
+        GHUtility.setProperties(graph.edge(5, 4).setDistance(70), carEncoder, 10, true, false);
 
-        graph.edge(5, 6).setDistance(70).setFlags(carEncoder.setProperties(10, true, false));
-        graph.edge(7, 5).setDistance(50).setFlags(carEncoder.setProperties(20, true, false));
+        GHUtility.setProperties(graph.edge(5, 6).setDistance(70), carEncoder, 10, true, false);
+        GHUtility.setProperties(graph.edge(7, 5).setDistance(50), carEncoder, 20, true, false);
 
-        graph.edge(6, 7).setDistance(50).setFlags(carEncoder.setProperties(20, true, true));
+        GHUtility.setProperties(graph.edge(6, 7).setDistance(50), carEncoder, 20, true, true);
     }
 
     @Test
diff --git a/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/RasterHullBuilderTest.java b/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/RasterHullBuilderTest.java
deleted file mode 100644
index 98609c3b45..0000000000
--- a/isochrone/src/test/java/com/graphhopper/isochrone/algorithm/RasterHullBuilderTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package com.graphhopper.isochrone.algorithm;
-
-import java.util.ArrayList;
-import java.util.List;
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- *
- * @author Peter Karich
- */
-public class RasterHullBuilderTest {
-
-    @Test
-    public void testCalc() {
-        RasterHullBuilder instance = new RasterHullBuilder();
-        List<List<Double[]>> listOfList = new ArrayList<List<Double[]>>();
-        List<Double[]> list = new ArrayList<Double[]>();
-        listOfList.add(list);
-        // lon,lat!
-        list.add(new Double[]{0.000, 0.000});
-        list.add(new Double[]{0.001, 0.000});
-        list.add(new Double[]{0.001, 0.001});
-        list.add(new Double[]{0.001, 0.002});
-        list.add(new Double[]{0.000, 0.002});
-
-        List<List<Double[]>> res = instance.calcList(listOfList, listOfList.size());
-        List<Double[]> geometry = res.get(0);
-        Assert.assertEquals(9, geometry.size());
-    }
-}
diff --git a/pom.xml b/pom.xml
index d6ddc10bdb..d8f3aa82b7 100644
--- a/pom.xml
+++ b/pom.xml
@@ -6,7 +6,7 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-parent</artifactId>
     <name>GraphHopper Parent Project</name>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <packaging>pom</packaging>
     <url>https://www.graphhopper.com</url>
     <inceptionYear>2012</inceptionYear>
@@ -15,10 +15,17 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-        <slf4j.version>1.7.25</slf4j.version>
+        <slf4j.version>1.7.26</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
-        <commons-compress.version>1.12</commons-compress.version>
-        <jackson.version>2.9.1</jackson.version>
+        <commons-compress.version>1.18</commons-compress.version>
+
+        <!-- for the correct jackson and guava versions see https://github.com/dropwizard/dropwizard/blob/release/1.3.x/dropwizard-bom/pom.xml -->
+        <!-- make also sure that the dropwizard version is working with 1.3.5 of dropwizard-configurable-assets-bundle used in web -->
+        <dropwizard.version>1.3.12</dropwizard.version>
+        <jackson.version>2.9.9</jackson.version>
+        <guava.version>24.1.1-jre</guava.version>
+
+        <directions-api-client.version>0.10.1-3</directions-api-client.version>
         <maven.compiler.target>1.8</maven.compiler.target>
 
         <org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>4</org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>
@@ -88,7 +95,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
+                <version>3.8.1</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
@@ -107,7 +114,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.19.1</version>
+                <version>2.22.2</version>
                 <configuration>
                     <argLine>-Xmx100m -Xms100m</argLine>
                 </configuration>
@@ -116,7 +123,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-failsafe-plugin</artifactId>
-                <version>2.19.1</version>
+                <version>2.22.2</version>
                 <executions>
                     <execution>
                         <goals>
@@ -130,18 +137,18 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>3.1.0</version>
+                <version>3.1.1</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-jar-plugin</artifactId>
-                <version>3.0.2</version>
+                <version>3.1.1</version>
             </plugin>
             <!-- example https://github.com/tananaev/traccar/blob/master/checkstyle.xml -->
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-checkstyle-plugin</artifactId>
-                <version>2.17</version>
+                <version>3.1.0</version>
                 <configuration>
                     <configLocation>${user.dir}/core/files/checkstyle.xml</configLocation>
                     <failsOnError>true</failsOnError>
@@ -151,19 +158,19 @@
             </plugin>
 
             <plugin>
-                <groupId>org.codehaus.mojo</groupId>
-                <artifactId>findbugs-maven-plugin</artifactId>
-                <version>3.0.5</version>
+                <groupId>com.github.spotbugs</groupId>
+                <artifactId>spotbugs-maven-plugin</artifactId>
+                <version>3.1.11</version>
                 <configuration>
                     <maxRank>4</maxRank>
                     <failOnError>true</failOnError>
-                    <excludeFilterFile>core/files/findbugs-exclude.xml</excludeFilterFile>
+                    <excludeFilterFile>core/files/spotbugs-exclude.xml</excludeFilterFile>
                 </configuration>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-pmd-plugin</artifactId>
-                <version>3.7</version>
+                <version>3.12.0</version>
                 <!-- e.g. under core/target/site/pmd.html
                 <configuration>
                     <format>html</format>
@@ -173,7 +180,7 @@
             <plugin>
                 <groupId>de.thetaphi</groupId>
                 <artifactId>forbiddenapis</artifactId>
-                <version>2.5</version>
+                <version>2.6</version>
                 <configuration>
                     <!--
                       if the used Java version is too new,
@@ -218,12 +225,6 @@
             <activation>
                 <activeByDefault>false</activeByDefault>
             </activation>
-            <!-- this exception is valid for jdk8 profile below too -->
-            <modules>
-                <!-- See https://github.com/graphhopper/graphhopper/pull/874#issuecomment-261231518
-                Currently works for jdk8 only -->
-                <module>reader-shp</module>
-            </modules>
             <build>
                 <plugins>
                     <plugin>
@@ -243,7 +244,7 @@
                     <plugin>
                         <groupId>org.sonatype.plugins</groupId>
                         <artifactId>nexus-staging-maven-plugin</artifactId>
-                        <version>1.6.7</version>
+                        <version>1.6.8</version>
                         <extensions>true</extensions>
                         <configuration>
                             <serverId>ossrh</serverId>
@@ -255,7 +256,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-javadoc-plugin</artifactId>
-                        <version>2.10.4</version>
+                        <version>3.1.0</version>
                         <configuration>
                           <quiet>true</quiet>
                         </configuration>
@@ -271,7 +272,7 @@
                     <plugin>
                         <groupId>org.apache.maven.plugins</groupId>
                         <artifactId>maven-source-plugin</artifactId>
-                        <version>3.0.1</version>
+                        <version>3.1.0</version>
                         <executions>
                             <execution>
                                 <id>attach-sources</id>
@@ -293,17 +294,6 @@
                 <module>android/app</module>
             </modules>
         </profile>
-	<profile>
-            <id>jdk10</id>
-            <activation>
-                <activeByDefault>false</activeByDefault>
-                <jdk>10</jdk>
-            </activation>
-            <properties>
-              <maven.compiler.source>10</maven.compiler.source>
-              <maven.compiler.target>10</maven.compiler.target>
-            </properties>
-        </profile>
 
     </profiles>
 
diff --git a/reader-gtfs/files/another-sample-feed.zip b/reader-gtfs/files/another-sample-feed.zip
index eae66fb3b3..30692dc568 100644
Binary files a/reader-gtfs/files/another-sample-feed.zip and b/reader-gtfs/files/another-sample-feed.zip differ
diff --git a/reader-gtfs/files/sample-feed.zip b/reader-gtfs/files/sample-feed.zip
index ac51e28a03..4649503352 100644
Binary files a/reader-gtfs/files/sample-feed.zip and b/reader-gtfs/files/sample-feed.zip differ
diff --git a/reader-gtfs/pom.xml b/reader-gtfs/pom.xml
index 51011d4c04..bc34354627 100644
--- a/reader-gtfs/pom.xml
+++ b/reader-gtfs/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-gtfs</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Reader for Gtfs Data</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -21,29 +21,35 @@
             <artifactId>graphhopper-core</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
+        <dependency>
+            <groupId>com.graphhopper</groupId>
+            <artifactId>graphhopper-web-api</artifactId>
+            <version>${project.parent.version}</version>
+        </dependency>
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>graphhopper-reader-osm</artifactId>
             <version>${project.parent.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.conveyal</groupId>
-            <artifactId>gtfs-lib</artifactId>
-            <version>2.1.0</version>
-            <exclusions>
-                <exclusion> 
-                    <groupId>org.slf4j</groupId>
-                    <artifactId>slf4j-simple</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>com.vividsolutions</groupId>
-                    <artifactId>jts</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>com.amazonaws</groupId>
-                    <artifactId>aws-java-sdk-s3</artifactId>
-                </exclusion>
-            </exclusions>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+            <version>${guava.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>net.sourceforge.javacsv</groupId>
+            <artifactId>javacsv</artifactId>
+            <version>2.0</version>
+        </dependency>
+        <dependency>
+            <groupId>commons-io</groupId>
+            <artifactId>commons-io</artifactId>
+            <version>2.4</version>
+        </dependency>
+        <dependency>
+            <groupId>org.mapdb</groupId>
+            <artifactId>mapdb</artifactId>
+            <version>1.0.8</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
@@ -51,21 +57,30 @@
             <version>${slf4j.version}</version>
         </dependency>   
         <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-log4j12</artifactId>
-            <version>${slf4j.version}</version>
-            <scope>test</scope>
+            <groupId>com.google.transit</groupId>
+            <artifactId>gtfs-realtime-bindings</artifactId>
+            <version>0.0.4</version>
         </dependency>
         <dependency>
-            <groupId>log4j</groupId>
-            <artifactId>log4j</artifactId>
-            <version>${log4j.version}</version>
-            <scope>test</scope>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-core</artifactId>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.google.transit</groupId>
-            <artifactId>gtfs-realtime-bindings</artifactId>
-            <version>0.0.4</version>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-client</artifactId>
+            <version>${dropwizard.version}</version>
+        </dependency>
+        <!-- see #1606 HK2 service reification failed -->
+        <dependency>
+            <groupId>javax.activation</groupId>
+            <artifactId>activation</artifactId>
+            <version>1.1.1</version>
+        </dependency>
+	<dependency>
+            <groupId>javax.xml.bind</groupId>
+            <artifactId>jaxb-api</artifactId>
+            <version>2.3.0</version>
         </dependency>
 
         <dependency>
@@ -81,6 +96,12 @@
             <version>4.12</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>io.dropwizard</groupId>
+            <artifactId>dropwizard-testing</artifactId>
+            <version>${dropwizard.version}</version>
+            <scope>test</scope>
+        </dependency>
         <dependency>
             <groupId>org.hamcrest</groupId>
             <artifactId>hamcrest-library</artifactId>
@@ -96,7 +117,7 @@
         <dependency>
             <groupId>org.mockito</groupId>
             <artifactId>mockito-core</artifactId>
-            <version>1.10.19</version>
+            <version>2.23.0</version>
             <scope>test</scope>
         </dependency>
     </dependencies>
@@ -105,7 +126,6 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
                 <configuration>
                     <!--
                     <compilerArgument>-Xlint:unchecked</compilerArgument>
@@ -122,10 +142,9 @@
             <plugin>                
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
-                <version>2.19.1</version>
                 <!-- Currently we need a bit more memory than for other tests -->
                 <configuration>
-                    <argLine>-Xmx2000m -Xms2000m</argLine>
+                    <argLine>-Xmx1200m -Xms1200m</argLine>
                 </configuration>
             </plugin>
         </plugins>
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/GTFSFeed.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/GTFSFeed.java
new file mode 100644
index 0000000000..6fbf2940d0
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/GTFSFeed.java
@@ -0,0 +1,470 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs;
+
+import com.conveyal.gtfs.error.GTFSError;
+import com.conveyal.gtfs.error.GeneralError;
+import com.conveyal.gtfs.model.Calendar;
+import com.conveyal.gtfs.model.*;
+import com.google.common.collect.Iterables;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.CoordinateList;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
+import org.mapdb.BTreeMap;
+import org.mapdb.DB;
+import org.mapdb.DBMaker;
+import org.mapdb.Fun;
+import org.mapdb.Fun.Tuple2;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.time.LocalDate;
+import java.time.format.DateTimeFormatter;
+import java.util.*;
+import java.util.concurrent.ConcurrentNavigableMap;
+import java.util.stream.Collectors;
+import java.util.stream.StreamSupport;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+/**
+ * All entities must be from a single feed namespace.
+ * Composed of several GTFSTables.
+ */
+public class GTFSFeed implements Cloneable, Closeable {
+
+    private static final Logger LOG = LoggerFactory.getLogger(GTFSFeed.class);
+
+    private DB db;
+
+    public String feedId = null;
+
+    public final Map<String, Agency> agency;
+    public final Map<String, FeedInfo> feedInfo;
+    // This is how you do a multimap in mapdb: https://github.com/jankotek/MapDB/blob/release-1.0/src/test/java/examples/MultiMap.java
+    public final NavigableSet<Tuple2<String, Frequency>> frequencies;
+    public final Map<String, Route> routes;
+    public final Map<String, Stop> stops;
+    public final Map<String, Transfer> transfers;
+    public final BTreeMap<String, Trip> trips;
+
+    /** CRC32 of the GTFS file this was loaded from */
+    public long checksum;
+
+    /* Map from 2-tuples of (shape_id, shape_pt_sequence) to shape points */
+    public final ConcurrentNavigableMap<Tuple2<String, Integer>, ShapePoint> shape_points;
+
+    /* Map from 2-tuples of (trip_id, stop_sequence) to stoptimes. */
+    public final BTreeMap<Tuple2, StopTime> stop_times;
+
+    /* A fare is a fare_attribute and all fare_rules that reference that fare_attribute. */
+    public final Map<String, Fare> fares;
+
+    /* A service is a calendar entry and all calendar_dates that modify that calendar entry. */
+    public final BTreeMap<String, Service> services;
+
+    /* A place to accumulate errors while the feed is loaded. Tolerate as many errors as possible and keep on loading. */
+    public final NavigableSet<GTFSError> errors;
+
+    /* Create geometry factory to produce LineString geometries. */
+    private GeometryFactory gf = new GeometryFactory();
+
+    private boolean loaded = false;
+
+    /**
+     * The order in which we load the tables is important for two reasons.
+     * 1. We must load feed_info first so we know the feed ID before loading any other entities. This could be relaxed
+     * by having entities point to the feed object rather than its ID String.
+     * 2. Referenced entities must be loaded before any entities that reference them. This is because we check
+     * referential integrity while the files are being loaded. This is done on the fly during loading because it allows
+     * us to associate a line number with errors in objects that don't have any other clear identifier.
+     *
+     * Interestingly, all references are resolvable when tables are loaded in alphabetical order.
+     */
+    public void loadFromFile(ZipFile zip, String fid) throws IOException {
+        if (this.loaded) throw new UnsupportedOperationException("Attempt to load GTFS into existing database");
+
+        // NB we don't have a single CRC for the file, so we combine all the CRCs of the component files. NB we are not
+        // simply summing the CRCs because CRCs are (I assume) uniformly randomly distributed throughout the width of a
+        // long, so summing them is a convolution which moves towards a Gaussian with mean 0 (i.e. more concentrated
+        // probability in the center), degrading the quality of the hash. Instead we XOR. Assuming each bit is independent,
+        // this will yield a nice uniformly distributed result, because when combining two bits there is an equal
+        // probability of any input, which means an equal probability of any output. At least I think that's all correct.
+        // Repeated XOR is not commutative but zip.stream returns files in the order they are in the central directory
+        // of the zip file, so that's not a problem.
+        checksum = zip.stream().mapToLong(ZipEntry::getCrc).reduce((l1, l2) -> l1 ^ l2).getAsLong();
+
+        db.getAtomicLong("checksum").set(checksum);
+
+        new FeedInfo.Loader(this).loadTable(zip);
+        // maybe we should just point to the feed object itself instead of its ID, and null out its stoptimes map after loading
+        if (fid != null) {
+            feedId = fid;
+            LOG.info("Feed ID is undefined, pester maintainers to include a feed ID. Using file name {}.", feedId); // TODO log an error, ideally feeds should include a feedID
+        }
+        else if (feedId == null || feedId.isEmpty()) {
+            feedId = new File(zip.getName()).getName().replaceAll("\\.zip$", "");
+            LOG.info("Feed ID is undefined, pester maintainers to include a feed ID. Using file name {}.", feedId); // TODO log an error, ideally feeds should include a feedID
+        }
+        else {
+            LOG.info("Feed ID is '{}'.", feedId);
+        }
+
+        db.getAtomicString("feed_id").set(feedId);
+
+        new Agency.Loader(this).loadTable(zip);
+        if (agency.isEmpty()) {
+            errors.add(new GeneralError("agency", 0, "agency_id", "Need at least one agency."));
+        }
+
+        // calendars and calendar dates are joined into services. This means a lot of manipulating service objects as
+        // they are loaded; since mapdb keys/values are immutable, load them in memory then copy them to MapDB once
+        // we're done loading them
+        Map<String, Service> serviceTable = new HashMap<>();
+        new Calendar.Loader(this, serviceTable).loadTable(zip);
+        new CalendarDate.Loader(this, serviceTable).loadTable(zip);
+        this.services.putAll(serviceTable);
+        serviceTable = null; // free memory
+
+        // Same deal
+        Map<String, Fare> fares = new HashMap<>();
+        new FareAttribute.Loader(this, fares).loadTable(zip);
+        new FareRule.Loader(this, fares).loadTable(zip);
+        this.fares.putAll(fares);
+        fares = null; // free memory
+
+        new Route.Loader(this).loadTable(zip);
+        new ShapePoint.Loader(this).loadTable(zip);
+        new Stop.Loader(this).loadTable(zip);
+        new Transfer.Loader(this).loadTable(zip);
+        new Trip.Loader(this).loadTable(zip);
+        new Frequency.Loader(this).loadTable(zip);
+        new StopTime.Loader(this).loadTable(zip); // comment out this line for quick testing using NL feed
+        loaded = true;
+    }
+
+    public void loadFromFileAndLogErrors(ZipFile zip) throws IOException {
+        loadFromFile(zip, null);
+        for (GTFSError error : errors) {
+            LOG.error(error.getMessageWithContext());
+        }
+    }
+
+    public boolean hasFeedInfo () {
+        return !this.feedInfo.isEmpty();
+    }
+
+    public FeedInfo getFeedInfo () {
+        return this.hasFeedInfo() ? this.feedInfo.values().iterator().next() : null;
+    }
+
+    /**
+     * For the given trip ID, fetch all the stop times in order of increasing stop_sequence.
+     * This is an efficient iteration over a tree map.
+     */
+    public Iterable<StopTime> getOrderedStopTimesForTrip (String trip_id) {
+        Map<Fun.Tuple2, StopTime> tripStopTimes =
+                stop_times.subMap(
+                        Fun.t2(trip_id, null),
+                        Fun.t2(trip_id, Fun.HI)
+                );
+        return tripStopTimes.values();
+    }
+
+    /** Get the shape for the given shape ID */
+    public Shape getShape (String shape_id) {
+        Shape shape = new Shape(this, shape_id);
+        return shape.shape_dist_traveled.length > 0 ? shape : null;
+    }
+
+    /**
+     * For the given trip ID, fetch all the stop times in order, and interpolate stop-to-stop travel times.
+     */
+    public Iterable<StopTime> getInterpolatedStopTimesForTrip (String trip_id) throws FirstAndLastStopsDoNotHaveTimes {
+        // clone stop times so as not to modify base GTFS structures
+        StopTime[] stopTimes = StreamSupport.stream(getOrderedStopTimesForTrip(trip_id).spliterator(), false)
+                .map(st -> st.clone())
+                .toArray(i -> new StopTime[i]);
+
+        // avoid having to make sure that the array has length below.
+        if (stopTimes.length == 0) return Collections.emptyList();
+
+        // first pass: set all partially filled stop times
+        for (StopTime st : stopTimes) {
+            if (st.arrival_time != Entity.INT_MISSING && st.departure_time == Entity.INT_MISSING) {
+                st.departure_time = st.arrival_time;
+            }
+
+            if (st.arrival_time == Entity.INT_MISSING && st.departure_time != Entity.INT_MISSING) {
+                st.arrival_time = st.departure_time;
+            }
+        }
+
+        // quick check: ensure that first and last stops have times.
+        // technically GTFS requires that both arrival_time and departure_time be filled at both the first and last stop,
+        // but we are slightly more lenient and only insist that one of them be filled at both the first and last stop.
+        // The meaning of the first stop's arrival time is unclear, and same for the last stop's departure time (except
+        // in the case of interlining).
+
+        // it's fine to just check departure time, as the above pass ensures that all stop times have either both
+        // arrival and departure times, or neither
+        if (stopTimes[0].departure_time == Entity.INT_MISSING || stopTimes[stopTimes.length - 1].departure_time == Entity.INT_MISSING) {
+            throw new FirstAndLastStopsDoNotHaveTimes();
+        }
+
+        // second pass: fill complete stop times
+        int startOfInterpolatedBlock = -1;
+        for (int stopTime = 0; stopTime < stopTimes.length; stopTime++) {
+
+            if (stopTimes[stopTime].departure_time == Entity.INT_MISSING && startOfInterpolatedBlock == -1) {
+                startOfInterpolatedBlock = stopTime;
+            }
+            else if (stopTimes[stopTime].departure_time != Entity.INT_MISSING && startOfInterpolatedBlock != -1) {
+                throw new RuntimeException("Missing stop times not supported.");
+            }
+        }
+
+        return Arrays.asList(stopTimes);
+    }
+
+    public Collection<Frequency> getFrequencies (String trip_id) {
+        // IntelliJ tells me all these casts are unnecessary, and that's also my feeling, but the code won't compile
+        // without them
+        return (List<Frequency>) frequencies.subSet(new Fun.Tuple2(trip_id, null), new Fun.Tuple2(trip_id, Fun.HI)).stream()
+                .map(t2 -> ((Tuple2<String, Frequency>) t2).b)
+                .collect(Collectors.toList());
+    }
+
+    public LineString getStraightLineForStops(String trip_id) {
+        CoordinateList coordinates = new CoordinateList();
+        LineString ls = null;
+        Trip trip = trips.get(trip_id);
+
+        Iterable<StopTime> stopTimes;
+        stopTimes = getOrderedStopTimesForTrip(trip.trip_id);
+        if (Iterables.size(stopTimes) > 1) {
+            for (StopTime stopTime : stopTimes) {
+                Stop stop = stops.get(stopTime.stop_id);
+                Double lat = stop.stop_lat;
+                Double lon = stop.stop_lon;
+                coordinates.add(new Coordinate(lon, lat));
+            }
+            ls = gf.createLineString(coordinates.toCoordinateArray());
+        }
+        // set ls equal to null if there is only one stopTime to avoid an exception when creating linestring
+        else{
+            ls = null;
+        }
+        return ls;
+    }
+
+    /**
+     * Returns a trip geometry object (LineString) for a given trip id.
+     * If the trip has a shape reference, this will be used for the geometry.
+     * Otherwise, the ordered stoptimes will be used.
+     *
+     * @param   trip_id   trip id of desired trip geometry
+     * @return          the LineString representing the trip geometry.
+     * @see             LineString
+     */
+    public LineString getTripGeometry(String trip_id){
+
+        CoordinateList coordinates = new CoordinateList();
+        LineString ls = null;
+        Trip trip = trips.get(trip_id);
+
+        // If trip has shape_id, use it to generate geometry.
+        if (trip.shape_id != null) {
+            Shape shape = getShape(trip.shape_id);
+            if (shape != null) ls = shape.geometry;
+        }
+
+        // Use the ordered stoptimes.
+        if (ls == null) {
+            ls = getStraightLineForStops(trip_id);
+        }
+
+        return ls;
+    }
+
+    /**
+     * Cloning can be useful when you want to make only a few modifications to an existing feed.
+     * Keep in mind that this is a shallow copy, so you'll have to create new maps in the clone for tables you want
+     * to modify.
+     */
+    @Override
+    public GTFSFeed clone() {
+        try {
+            return (GTFSFeed) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public void close () {
+        db.close();
+    }
+
+    /** Thrown when we cannot interpolate stop times because the first or last stops do not have times */
+    public class FirstAndLastStopsDoNotHaveTimes extends RuntimeException {
+        /** do nothing */
+    }
+
+    /** Create a GTFS feed in a temp file */
+    public GTFSFeed () {
+        // calls to this must be first operation in constructor - why, Java?
+        this(DBMaker.newTempFileDB()
+                .transactionDisable()
+                .mmapFileEnable()
+                .asyncWriteEnable()
+                .deleteFilesAfterClose()
+                .compressionEnable()
+                // .cacheSize(1024 * 1024) this bloats memory consumption
+                .make()); // TODO db.close();
+    }
+
+    /** Create a GTFS feed connected to a particular DB, which will be created if it does not exist. */
+    public GTFSFeed(File file) {
+        this(constructDB(file));
+    }
+
+    private static DB constructDB(File file) {
+        return DBMaker.newFileDB(file)
+                .transactionDisable()
+                .mmapFileEnable()
+                .asyncWriteEnable()
+                .compressionEnable()
+                .make();
+    }
+
+    private GTFSFeed (DB db) {
+        this.db = db;
+
+        agency = db.getTreeMap("agency");
+        feedInfo = db.getTreeMap("feed_info");
+        routes = db.getTreeMap("routes");
+        trips = db.getTreeMap("trips");
+        stop_times = db.getTreeMap("stop_times");
+        frequencies = db.getTreeSet("frequencies");
+        transfers = db.getTreeMap("transfers");
+        stops = db.getTreeMap("stops");
+        fares = db.getTreeMap("fares");
+        services = db.getTreeMap("services");
+        shape_points = db.getTreeMap("shape_points");
+
+        feedId = db.getAtomicString("feed_id").get();
+        checksum = db.getAtomicLong("checksum").get();
+
+        errors = db.getTreeSet("errors");
+    }
+
+    public LocalDate getStartDate() {
+        LocalDate startDate = null;
+
+        if (hasFeedInfo()) startDate = getFeedInfo().feed_start_date;
+        if (startDate == null) startDate = getCalendarServiceRangeStart();
+        if (startDate == null) startDate = getCalendarDateStart();
+
+        return startDate;
+    }
+
+    public LocalDate getCalendarServiceRangeStart() {
+
+        int startDate = 0;
+        for (Service service : services.values()) {
+            if (service.calendar == null)
+                continue;
+            if (startDate == 0 || service.calendar.start_date < startDate) {
+                startDate = service.calendar.start_date;
+            }
+        }
+        if (startDate == 0)
+            return null;
+
+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd", Locale.getDefault());
+        return LocalDate.parse(String.valueOf(startDate), formatter);
+    }
+
+
+    public LocalDate getCalendarDateStart() {
+        LocalDate startDate = null;
+        for (Service service : services.values()) {
+            for (LocalDate date : service.calendar_dates.keySet()) {
+                if (startDate == null
+                        || date.isBefore(startDate))
+                    startDate = date;
+            }
+        }
+        return startDate;
+    }
+
+    public LocalDate getCalendarServiceRangeEnd() {
+
+        int endDate = 0;
+
+        for (Service service : services.values()) {
+            if (service.calendar == null)
+                continue;
+
+            if (endDate == 0 || service.calendar.end_date > endDate) {
+                endDate = service.calendar.end_date;
+            }
+        }
+        if (endDate == 0)
+            return null;
+
+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd", Locale.getDefault());
+        return LocalDate.parse(String.valueOf(endDate), formatter);
+    }
+
+    public LocalDate getEndDate() {
+        LocalDate endDate = null;
+
+        if (hasFeedInfo()) endDate = getFeedInfo().feed_end_date;
+        if (endDate == null) endDate = getCalendarServiceRangeEnd();
+        if (endDate == null) endDate = getCalendarDateEnd();
+
+        return endDate;
+    }
+
+    public LocalDate getCalendarDateEnd() {
+        LocalDate endDate = null;
+        for (Service service : services.values()) {
+            for (LocalDate date : service.calendar_dates.keySet()) {
+                if (endDate == null
+                        || date.isAfter(endDate))
+                    endDate = date;
+            }
+        }
+        return endDate;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/TripPatternKey.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/TripPatternKey.java
new file mode 100644
index 0000000000..15ea8bec8d
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/TripPatternKey.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs;
+
+import com.carrotsearch.hppc.IntArrayList;
+import com.conveyal.gtfs.model.StopTime;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Used as a map key when grouping trips by stop pattern. Note that this includes the routeId, so the same sequence of
+ * stops on two different routes makes two different patterns.
+ * These objects are not intended for use outside the grouping process.
+ */
+public class TripPatternKey {
+
+    public String routeId;
+    public List<String> stops = new ArrayList<>();
+    public IntArrayList pickupTypes = new IntArrayList();
+    public IntArrayList dropoffTypes = new IntArrayList();
+
+    public TripPatternKey (String routeId) {
+        this.routeId = routeId;
+    }
+
+    public void addStopTime (StopTime st) {
+        stops.add(st.stop_id);
+        pickupTypes.add(st.pickup_type);
+        dropoffTypes.add(st.drop_off_type);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        TripPatternKey that = (TripPatternKey) o;
+
+        if (dropoffTypes != null ? !dropoffTypes.equals(that.dropoffTypes) : that.dropoffTypes != null) return false;
+        if (pickupTypes != null ? !pickupTypes.equals(that.pickupTypes) : that.pickupTypes != null) return false;
+        if (routeId != null ? !routeId.equals(that.routeId) : that.routeId != null) return false;
+        if (stops != null ? !stops.equals(that.stops) : that.stops != null) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = routeId != null ? routeId.hashCode() : 0;
+        result = 31 * result + (stops != null ? stops.hashCode() : 0);
+        result = 31 * result + (pickupTypes != null ? pickupTypes.hashCode() : 0);
+        result = 31 * result + (dropoffTypes != null ? dropoffTypes.hashCode() : 0);
+        return result;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DateParseError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DateParseError.java
new file mode 100644
index 0000000000..ef2da04e0e
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DateParseError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Represents a problem parsing a date field from a GTFS feed. */
+public class DateParseError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public DateParseError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return "Could not parse date (format should be YYYYMMDD).";
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DuplicateKeyError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DuplicateKeyError.java
new file mode 100644
index 0000000000..4d79e1a542
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/DuplicateKeyError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Indicates that a GTFS entity was not added to a table because another object already exists with the same primary key. */
+public class DuplicateKeyError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public DuplicateKeyError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return "Duplicate primary key.";
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/EmptyFieldError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/EmptyFieldError.java
new file mode 100644
index 0000000000..24f56b9e06
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/EmptyFieldError.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that a field marked as required is not present in a GTFS feed on a particular line. */
+public class EmptyFieldError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public EmptyFieldError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "No value supplied for a required column.");
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GTFSError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GTFSError.java
new file mode 100644
index 0000000000..cc6fe4123a
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GTFSError.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/**
+ * Represents an error encountered
+ */
+public abstract class GTFSError implements Comparable<GTFSError>, Serializable {
+
+    public final String file; // TODO GTFSTable enum? Or simply use class objects.
+    public final long   line;
+    public final String field;
+    public final String affectedEntityId;
+    public final String errorType;
+
+    public GTFSError(String file, long line, String field) {
+        this(file, line, field, null);
+    }
+
+    public GTFSError(String file, long line, String field, String affectedEntityId) {
+        this.file  = file;
+        this.line  = line;
+        this.field = field;
+        this.affectedEntityId = affectedEntityId;
+        this.errorType = this.getClass().getSimpleName();
+    }
+
+    public String getMessage() {
+        return "no message";
+    }
+
+    public String getMessageWithContext() {
+        StringBuilder sb = new StringBuilder();
+        sb.append(file);
+        sb.append(' ');
+        if (line >= 0) {
+            sb.append("line ");
+            sb.append(line);
+        } else {
+            sb.append("(no line)");
+        }
+        if (field != null) {
+            sb.append(", field '");
+            sb.append(field);
+            sb.append('\'');
+        }
+        sb.append(": ");
+        sb.append(getMessage());
+        return sb.toString();
+    }
+
+    /** must be comparable to put into mapdb */
+    public int compareTo (GTFSError o) {
+        if (this.file == null && o.file != null) return -1;
+        else if (this.file != null && o.file == null) return 1;
+
+        int file = this.file == null && o.file == null ? 0 : String.CASE_INSENSITIVE_ORDER.compare(this.file, o.file);
+        if (file != 0) return file;
+        int errorType = String.CASE_INSENSITIVE_ORDER.compare(this.errorType, o.errorType);
+        if (errorType != 0) return errorType;
+        int affectedEntityId = this.affectedEntityId == null && o.affectedEntityId == null ? 0 : String.CASE_INSENSITIVE_ORDER.compare(this.affectedEntityId, o.affectedEntityId);
+        if (affectedEntityId != 0) return affectedEntityId;
+        else return Long.compare(this.line, o.line);
+    }
+
+    @Override
+    public String toString() {
+        return "GTFSError: " + getMessageWithContext();
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GeneralError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GeneralError.java
new file mode 100644
index 0000000000..3b479492b7
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/GeneralError.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Represents any GTFS loading problem that does not have its own class, with a free-text message. */
+public class GeneralError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    private String message;
+
+    public GeneralError(String file, long line, String field, String message) {
+        super(file, line, field);
+        this.message = message;
+    }
+
+    @Override public String getMessage() {
+        return message;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingColumnError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingColumnError.java
new file mode 100644
index 0000000000..ca580373c2
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingColumnError.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that a column marked as required is entirely missing from a GTFS feed. */
+public class MissingColumnError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public MissingColumnError(String file, String field) {
+        super(file, 1, field);
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "Missing required column.");
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingTableError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingTableError.java
new file mode 100644
index 0000000000..851ffb13f8
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/MissingTableError.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that a table marked as required is not present in a GTFS feed. */
+public class MissingTableError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public MissingTableError(String file) {
+        super(file, 0, null);
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "This table is required by the GTFS specification but is missing.");
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/NumberParseError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/NumberParseError.java
new file mode 100644
index 0000000000..d6d4e88e02
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/NumberParseError.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Represents a problem parsing an integer field of GTFS feed. */
+public class NumberParseError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public NumberParseError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "Error parsing a number from a string.");
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/Priority.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/Priority.java
new file mode 100644
index 0000000000..9fdf2f49c6
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/Priority.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+public enum Priority {
+    /** 
+     * Something that is likely to break routing results,
+     * e.g. stop times out of sequence or high-speed travel
+     */
+    HIGH,
+    
+    /** 
+     * Something that is likely to break display, but still give accurate routing results,
+     * e.g. broken shapes or route long name containing route short name.
+     */
+    MEDIUM,
+    
+    /**
+     * Something that will not affect user experience but should be corrected as time permits,
+     * e.g. unused stops.
+     */
+    LOW,
+    
+    /**
+     * An error for which we do not have a priority
+     */
+    UNKNOWN
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/RangeError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/RangeError.java
new file mode 100644
index 0000000000..fcc99c9087
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/RangeError.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that a number is out of the acceptable range. */
+public class RangeError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    final double min, max, actual;
+
+    public RangeError(String file, long line, String field, double min, double max, double actual) {
+        super(file, line, field);
+        this.min = min;
+        this.max = max;
+        this.actual = actual;
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "Number %s outside of acceptable range [%s,%s].", actual, min, max);
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/ReferentialIntegrityError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/ReferentialIntegrityError.java
new file mode 100644
index 0000000000..85c22decb1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/ReferentialIntegrityError.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/** Indicates that an entity referenced another entity that does not exist. */
+public class ReferentialIntegrityError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    // TODO: maybe also store the entity ID of the entity which contained the bad reference, in addition to the row number
+    public final String badReference;
+
+    public ReferentialIntegrityError(String tableName, long row, String field, String badReference) {
+        super(tableName, row, field);
+        this.badReference = badReference;
+    }
+
+    /** must be comparable to put into mapdb */
+    @Override
+    public int compareTo (GTFSError o) {
+        int compare = super.compareTo(o);
+        if (compare != 0) return compare;
+        return this.badReference.compareTo((((ReferentialIntegrityError) o).badReference));
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), badReference);
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TableInSubdirectoryError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TableInSubdirectoryError.java
new file mode 100644
index 0000000000..b225dbe7d9
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TableInSubdirectoryError.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+/**
+ * Created by landon on 10/14/16.
+ */
+public class TableInSubdirectoryError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public final String directory;
+    public final Priority priority = Priority.HIGH;
+
+    public TableInSubdirectoryError(String file, String directory) {
+        super(file, 0, null);
+        this.directory = directory;
+    }
+
+    @Override public String getMessage() {
+        return String.format(Locale.getDefault(), "All GTFS files (including %s.txt) should be at root of zipfile, not nested in subdirectory (%s)", file, directory);
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TimeParseError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TimeParseError.java
new file mode 100644
index 0000000000..3c0d007a92
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/TimeParseError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Represents a problem parsing a time of day field of GTFS feed. */
+public class TimeParseError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public TimeParseError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return "Could not parse time (format should be HH:MM:SS).";
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/error/URLParseError.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/URLParseError.java
new file mode 100644
index 0000000000..d5b4df0da5
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/error/URLParseError.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.error;
+
+import java.io.Serializable;
+
+/** Represents a problem parsing a URL field from a GTFS feed. */
+public class URLParseError extends GTFSError implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public URLParseError(String file, long line, String field) {
+        super(file, line, field);
+    }
+
+    @Override public String getMessage() {
+        return "Could not parse URL (format should be <scheme>://<authority><path>?<query>#<fragment>).";
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Agency.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Agency.java
new file mode 100644
index 0000000000..926cf3a643
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Agency.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.Iterator;
+
+public class Agency extends Entity {
+
+    private static final long serialVersionUID = -2825890165823575940L;
+    public String agency_id;
+    public String agency_name;
+    public URL    agency_url;
+    public String agency_timezone;
+    public String agency_lang;
+    public String agency_phone;
+    public URL    agency_fare_url;
+    public URL    agency_branding_url;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<Agency> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "agency");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Agency a = new Agency();
+            a.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            a.agency_id    = getStringField("agency_id", false); // can only be absent if there is a single agency -- requires a special validator.
+            a.agency_name  = getStringField("agency_name", true);
+            a.agency_url   = getUrlField("agency_url", true);
+            a.agency_lang  = getStringField("agency_lang", false);
+            a.agency_phone = getStringField("agency_phone", false);
+            a.agency_timezone = getStringField("agency_timezone", true);
+            a.agency_fare_url = getUrlField("agency_fare_url", false);
+            a.agency_branding_url = getUrlField("agency_branding_url", false);
+            a.feed = feed;
+            a.feed_id = feed.feedId;
+
+            // TODO clooge due to not being able to have null keys in mapdb
+            if (a.agency_id == null) a.agency_id = "NONE";
+
+            feed.agency.put(a.agency_id, a);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Agency> {
+        public Writer(GTFSFeed feed) {
+            super(feed, "agency");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"agency_id", "agency_name", "agency_url", "agency_lang",
+                    "agency_phone", "agency_timezone", "agency_fare_url", "agency_branding_url"});
+        }
+
+        @Override
+        public void writeOneRow(Agency a) throws IOException {
+            writeStringField(a.agency_id);
+            writeStringField(a.agency_name);
+            writeUrlField(a.agency_url);
+            writeStringField(a.agency_lang);
+            writeStringField(a.agency_phone);
+            writeStringField(a.agency_timezone);
+            writeUrlField(a.agency_fare_url);
+            writeUrlField(a.agency_branding_url);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<Agency> iterator() {
+            return this.feed.agency.values().iterator();
+        }
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Calendar.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Calendar.java
new file mode 100644
index 0000000000..595a1c3d81
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Calendar.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.DuplicateKeyError;
+import com.google.common.base.Function;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Iterators;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Iterator;
+import java.util.Map;
+
+public class Calendar extends Entity implements Serializable {
+
+    private static final long serialVersionUID = 6634236680822635875L;
+    public int monday;
+    public int tuesday;
+    public int wednesday;
+    public int thursday;
+    public int friday;
+    public int saturday;
+    public int sunday;
+    public int start_date;
+    public int end_date;
+    public String feed_id;
+    public String service_id;
+
+    public static class Loader extends Entity.Loader<Calendar> {
+
+        private final Map<String, Service> services;
+
+        /**
+         * Create a loader. The map parameter should be an in-memory map that will be modified. We can't write directly
+         * to MapDB because we modify services as we load calendar dates, and this creates concurrentmodificationexceptions.
+         */
+        public Loader(GTFSFeed feed, Map<String, Service> services) {
+            super(feed, "calendar");
+            this.services = services;
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+
+            /* Calendars and Fares are special: they are stored as joined tables rather than simple maps. */
+            String service_id = getStringField("service_id", true); // TODO service_id can reference either calendar or calendar_dates.
+            Service service = services.computeIfAbsent(service_id, Service::new);
+            if (service.calendar != null) {
+                feed.errors.add(new DuplicateKeyError(tableName, row, "service_id"));
+            } else {
+                Calendar c = new Calendar();
+                c.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+                c.service_id = service.service_id;
+                c.monday = getIntField("monday", true, 0, 1);
+                c.tuesday = getIntField("tuesday", true, 0, 1);
+                c.wednesday = getIntField("wednesday", true, 0, 1);
+                c.thursday = getIntField("thursday", true, 0, 1);
+                c.friday = getIntField("friday", true, 0, 1);
+                c.saturday = getIntField("saturday", true, 0, 1);
+                c.sunday = getIntField("sunday", true, 0, 1);
+                // TODO check valid dates
+                c.start_date = getIntField("start_date", true, 18500101, 22001231);
+                c.end_date = getIntField("end_date", true, 18500101, 22001231);
+                c.feed = feed;
+                c.feed_id = feed.feedId;
+                service.calendar = c;
+            }
+
+        }    
+    }
+
+    public static class Writer extends Entity.Writer<Calendar> {
+        public Writer(GTFSFeed feed) {
+            super(feed, "calendar");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"service_id", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday", "start_date", "end_date"});
+        }
+
+        @Override
+        protected void writeOneRow(Calendar c) throws IOException {
+            writeStringField(c.service_id);
+            writeIntField(c.monday);
+            writeIntField(c.tuesday);
+            writeIntField(c.wednesday);
+            writeIntField(c.thursday);
+            writeIntField(c.friday);
+            writeIntField(c.saturday);
+            writeIntField(c.sunday);
+            writeIntField(c.start_date);
+            writeIntField(c.end_date);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<Calendar> iterator() {
+            // wrap an iterator over services
+            Iterator<Calendar> calIt = Iterators.transform(feed.services.values().iterator(), new Function<Service, Calendar> () {
+                @Override
+                public Calendar apply (Service s) {
+                    return s.calendar;
+                }
+            });
+            
+            // not every service has a calendar (e.g. TriMet has no calendars, just calendar dates).
+            // This is legal GTFS, so skip services with no calendar
+            return Iterators.filter(calIt, new Predicate<Calendar> () {
+                @Override
+                public boolean apply(Calendar c) {
+                    return c != null;
+                }
+            });
+            
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/CalendarDate.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/CalendarDate.java
new file mode 100644
index 0000000000..af6acfcd82
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/CalendarDate.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.DuplicateKeyError;
+import com.google.common.base.Function;
+import com.google.common.collect.Iterators;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.time.LocalDate;
+import java.util.Iterator;
+import java.util.Map;
+
+public class CalendarDate extends Entity implements Cloneable, Serializable {
+
+    private static final long serialVersionUID = 6936614582249119431L;
+    public String    service_id;
+    public LocalDate date;
+    public int       exception_type;
+
+    public CalendarDate clone () {
+        try {
+            return (CalendarDate) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static class Loader extends Entity.Loader<CalendarDate> {
+
+        private final Map<String, Service> services;
+
+        /**
+         * Create a loader. The map parameter should be an in-memory map that will be modified. We can't write directly
+         * to MapDB because we modify services as we load calendar dates, and this creates concurrentmodificationexceptions.
+         */
+        public Loader(GTFSFeed feed, Map<String, Service> services) {
+            super(feed, "calendar_dates");
+            this.services = services;
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            /* Calendars and Fares are special: they are stored as joined tables rather than simple maps. */
+            String service_id = getStringField("service_id", true);
+            Service service = services.computeIfAbsent(service_id, Service::new);
+            LocalDate date = getDateField("date", true);
+            if (service.calendar_dates.containsKey(date)) {
+                feed.errors.add(new DuplicateKeyError(tableName, row, "(service_id, date)"));
+            } else {
+                CalendarDate cd = new CalendarDate();
+                cd.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+                cd.service_id = service_id;
+                cd.date = date;
+                cd.exception_type = getIntField("exception_type", true, 1, 2);
+                cd.feed = feed;
+                service.calendar_dates.put(date, cd);
+            }
+        }
+    }
+
+    public static class Writer extends Entity.Writer<CalendarDate> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "calendar_dates");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"service_id", "date", "exception_type"});
+        }
+
+        @Override
+        protected void writeOneRow(CalendarDate d) throws IOException {
+            writeStringField(d.service_id);
+            writeDateField(d.date);
+            writeIntField(d.exception_type);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<CalendarDate> iterator() {
+            Iterator<Service> serviceIterator = feed.services.values().iterator();
+            return Iterators.concat(Iterators.transform(serviceIterator, new Function<Service, Iterator<CalendarDate>> () {
+                @Override
+                public Iterator<CalendarDate> apply(Service service) {
+                    return service.calendar_dates.values().iterator();
+                }
+            }));
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Entity.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Entity.java
new file mode 100644
index 0000000000..91552eb164
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Entity.java
@@ -0,0 +1,448 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.*;
+import com.csvreader.CsvReader;
+import com.csvreader.CsvWriter;
+import org.apache.commons.io.input.BOMInputStream;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.time.LocalDate;
+import java.time.format.DateTimeFormatter;
+import java.util.*;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * An abstract base class that represents a row in a GTFS table, e.g. a Stop, Trip, or Agency.
+ * One concrete subclass is defined for each table in a GTFS feed.
+ */
+// TODO K is the key type for this table
+public abstract class Entity implements Serializable {
+
+    private static final long serialVersionUID = -3576441868127607448L;
+    public static final int INT_MISSING = Integer.MIN_VALUE;
+    public long sourceFileLine;
+
+    /* The feed from which this entity was loaded. */
+    transient GTFSFeed feed;
+
+    /* A class that can produce Entities from CSV, and record errors that occur in the process. */
+    // This is almost a GTFSTable... rename?
+    public static abstract class Loader<E extends Entity> {
+
+        private static final Logger LOG = LoggerFactory.getLogger(Loader.class);
+
+        protected final GTFSFeed feed;    // the feed into which we are loading the entities
+        protected final String tableName; // name of corresponding table without .txt
+        protected final Set<String> missingRequiredColumns = new HashSet<>();
+
+        protected CsvReader reader;
+        protected long      row;
+        // TODO "String column" that is set before any calls to avoid passing around the column name
+
+        public Loader(GTFSFeed feed, String tableName) {
+            this.feed = feed;
+            this.tableName = tableName;
+        }
+
+        /** @return whether the number actual is in the range [min, max] */
+        protected boolean checkRangeInclusive(double min, double max, double actual) {
+            if (actual < min || actual > max) {
+                feed.errors.add(new RangeError(tableName, row, null, min, max, actual)); // TODO set column name in loader so it's available in methods
+                return false;
+            }
+            return true;
+        }
+
+        /**
+         * Fetch the value from the given column of the current row. Record an error the first time a column is
+         * seen to be missing, and whenever empty values are encountered.
+         * I was originally just calling getStringField from the other getXField functions as a first step to get
+         * the missing-field check. But we don't want deduplication performed on strings that aren't being retained.
+         * Therefore the missing-field behavior is this separate function.
+         * @return null if column was missing or field is empty
+         */
+        private String getFieldCheckRequired(String column, boolean required) throws IOException {
+            String str = reader.get(column);
+            if (str == null) {
+                if (!missingRequiredColumns.contains(column)) {
+                    feed.errors.add(new MissingColumnError(tableName, column));
+                    missingRequiredColumns.add(column);
+                }
+            } else if (str.isEmpty()) {
+                if (required) {
+                    feed.errors.add(new EmptyFieldError(tableName, row, column));
+                }
+                str = null;
+            }
+            return str;
+        }
+
+        /** @return the given column from the current row as a deduplicated String. */
+        protected String getStringField(String column, boolean required) throws IOException {
+            return getFieldCheckRequired(column, required);
+        }
+
+        protected int getIntField(String column, boolean required, int min, int max) throws IOException {
+            return getIntField(column, required, min, max, 0);
+        }
+
+        protected int getIntField(String column, boolean required, int min, int max, int defaultValue) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            int val = INT_MISSING;
+            if (str == null) {
+                val = defaultValue; // defaults to 0 per overloaded function, unless provided.
+            } else try {
+                val = Integer.parseInt(str);
+                checkRangeInclusive(min, max, val);
+            } catch (NumberFormatException nfe) {
+                feed.errors.add(new NumberParseError(tableName, row, column));
+            }
+            return val;
+        }
+
+        /**
+         * Fetch the given column of the current row, and interpret it as a time in the format HH:MM:SS.
+         * @return the time value in seconds since midnight
+         */
+        protected int getTimeField(String column, boolean required) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            int val = INT_MISSING;
+            
+            if (str != null) {
+                String[] fields = str.split(":");
+                if (fields.length != 3) {
+                    feed.errors.add(new TimeParseError(tableName, row, column));
+                } else {
+                    try {
+                        int hours = Integer.parseInt(fields[0]);
+                        int minutes = Integer.parseInt(fields[1]);
+                        int seconds = Integer.parseInt(fields[2]);
+                        checkRangeInclusive(0, 72, hours); // GTFS hours can go past midnight. Some trains run for 3 days.
+                        checkRangeInclusive(0, 59, minutes);
+                        checkRangeInclusive(0, 59, seconds);
+                        val = (hours * 60 * 60) + minutes * 60 + seconds;
+                    } catch (NumberFormatException nfe) {
+                        feed.errors.add(new TimeParseError(tableName, row, column));
+                    }
+                }
+            }
+            
+            return val;
+        }
+
+        /**
+         * Fetch the given column of the current row, and interpret it as a date in the format YYYYMMDD.
+         * @return the date value as Java LocalDate, or null if it could not be parsed.
+         */
+        protected LocalDate getDateField(String column, boolean required) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            LocalDate dateTime = null;
+            if (str != null) try {
+                dateTime = LocalDate.parse(str, DateTimeFormatter.BASIC_ISO_DATE);
+                checkRangeInclusive(2000, 2100, dateTime.getYear());
+            } catch (IllegalArgumentException iae) {
+                feed.errors.add(new DateParseError(tableName, row, column));
+            }
+            return dateTime;
+        }
+
+        /**
+         * Fetch the given column of the current row, and interpret it as a URL.
+         * @return the URL, or null if the field was missing or empty.
+         */
+        protected URL getUrlField(String column, boolean required) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            URL url = null;
+            if (str != null) try {
+                url = new URL(str);
+            } catch (MalformedURLException mue) {
+                feed.errors.add(new URLParseError(tableName, row, column));
+            }
+            return url;
+        }
+
+        protected double getDoubleField(String column, boolean required, double min, double max) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            double val = Double.NaN;
+            if (str != null) try {
+                val = Double.parseDouble(str);
+                checkRangeInclusive(min, max, val);
+            } catch (NumberFormatException nfe) {
+                feed.errors.add(new NumberParseError(tableName, row, column));
+            }
+            return val;
+        }
+
+        /**
+         * Used to check referential integrity.
+         * Return value is not used, but could allow entities to point to each other directly rather than
+         * using indirection through string-keyed maps.
+         */
+        protected <K, V> V getRefField(String column, boolean required, Map<K, V> target) throws IOException {
+            String str = getFieldCheckRequired(column, required);
+            V val = null;
+            if (str != null) {
+                val = target.get(str);
+            }
+            return val;
+        }
+
+        protected abstract boolean isRequired();
+
+        /** Implemented by subclasses to read one row, produce one GTFS entity, and store that entity in a map. */
+        protected abstract void loadOneRow() throws IOException;
+
+        /**
+         * The main entry point into an Entity.Loader. Interprets each row of a CSV file within a zip file as a sinle
+         * GTFS entity, and loads them into a table.
+         *
+         * @param zip the zip file from which to read a table
+         */
+        public void loadTable(ZipFile zip) throws IOException {
+            ZipEntry entry = zip.getEntry(tableName + ".txt");
+            if (entry == null) {
+                Enumeration<? extends ZipEntry> entries = zip.entries();
+                // check if table is contained within sub-directory
+                while (entries.hasMoreElements()) {
+                    ZipEntry e = entries.nextElement();
+                    if (e.getName().endsWith(tableName + ".txt")) {
+                        entry = e;
+                        feed.errors.add(new TableInSubdirectoryError(tableName, entry.getName().replace(tableName + ".txt", "")));
+                    }
+                }
+                /* This GTFS table did not exist in the zip. */
+                if (this.isRequired()) {
+                    feed.errors.add(new MissingTableError(tableName));
+                } else {
+                    LOG.info("Table {} was missing but it is not required.", tableName);
+                }
+
+                if (entry == null) return;
+            }
+            LOG.info("Loading GTFS table {} from {}", tableName, entry);
+            InputStream zis = zip.getInputStream(entry);
+            // skip any byte order mark that may be present. Files must be UTF-8,
+            // but the GTFS spec says that "files that include the UTF byte order mark are acceptable"
+            InputStream bis = new BOMInputStream(zis);
+            CsvReader reader = new CsvReader(bis, ',', Charset.forName("UTF8"));
+            this.reader = reader;
+            reader.readHeaders();
+            while (reader.readRecord()) {
+                // reader.getCurrentRecord() is zero-based and does not include the header line, keep our own row count
+                if (++row % 500000 == 0) {
+                    LOG.info("Record number {}", human(row));
+                }
+                loadOneRow(); // Call subclass method to produce an entity from the current row.
+            }
+        }
+
+    }
+
+    /**
+     * An output stream that cannot be closed. CSVWriters try to close their output streams when they are garbage-collected,
+     * which breaks if another CSV writer is still writing to the ZIP file.
+     *
+     * Apache Commons has something similar but it seemed silly to import another large dependency. Eventually Guava will have this,
+     * see Guava issue 1367. At that point we should switch to using Guava.
+     */
+    private static class UncloseableOutputStream extends FilterOutputStream {
+        public UncloseableOutputStream(OutputStream out) {
+            super(out);
+        }
+
+        @Override
+        public void close () {
+            // no-op
+            return;
+        }
+    }
+
+    /**
+     * Write this entity to a CSV file. This should be subclassed in subclasses of Entity.
+     * The following (abstract) methods should be overridden in a subclass:
+     * 
+     * writeHeaders(): write the headers to the CsvWriter writer.
+     * writeRow(E): write the passed-in object to the CsvWriter writer, potentially using the write*Field methods.
+     * iterator(): return an iterator over objects of this class (note that the feed is available at this.feed
+     * public Writer (GTFSFeed feed): this should super to Writer(GTFSFeed feed, String tableName), with the table name
+     * defined. 
+     * 
+     * @author mattwigway
+     */
+    public static abstract class Writer<E extends Entity> {
+        private static final Logger LOG = LoggerFactory.getLogger(Writer.class);
+
+        protected final GTFSFeed feed;    // the feed into which we are loading the entities
+        protected final String tableName; // name of corresponding table without .txt
+
+        protected CsvWriter writer;
+
+        /**
+         * one-based to match reader.
+         */
+        protected long row;
+
+        protected Writer(GTFSFeed feed, String tableName) {
+            this.feed = feed;
+            this.tableName = tableName;
+        }
+
+        /**
+         * Write the CSV header.
+         */
+        protected abstract void writeHeaders() throws IOException;
+
+        /**
+         * Write one row of the CSV from the passed-in object.
+         */
+        protected abstract void writeOneRow(E obj) throws IOException;
+
+        /**
+         * Get an iterator over objects of this type.
+         */
+        protected abstract Iterator<E> iterator();
+
+        public void writeTable (ZipOutputStream zip) throws IOException {
+            LOG.info("Writing GTFS table {}", tableName);
+
+            ZipEntry zipEntry = new ZipEntry(tableName + ".txt");
+            zip.putNextEntry(zipEntry);
+
+            // don't let CSVWriter close the stream when it is garbage-collected
+            OutputStream protectedOut = new UncloseableOutputStream(zip);
+            this.writer = new CsvWriter(protectedOut, ',', Charset.forName("UTF8"));
+
+            this.writeHeaders();
+
+            // write rows until there are none left.
+            row = 0;        	
+            Iterator<E> iter = this.iterator();
+            while (iter.hasNext()) {
+                if (++row % 500000 == 0) {
+                    LOG.info("Record number {}", human(row));
+                }
+
+                writeOneRow(iter.next());
+            }
+
+            // closing the writer closes the underlying output stream, so we don't do that.
+            writer.flush();
+            zip.closeEntry();
+
+            LOG.info("Wrote {} rows", human(row));
+        }
+
+        protected void writeStringField(String str) throws IOException {
+            writer.write(str);
+        }
+
+        protected void writeUrlField(URL obj) throws IOException {
+            writeStringField(obj != null ? obj.toString() : "");
+        }
+
+        /**
+         * Writes date as YYYYMMDD
+         */
+        protected void writeDateField (LocalDate d) throws IOException {
+            writeStringField(d.format(DateTimeFormatter.BASIC_ISO_DATE));
+        }
+
+        /**
+         * Take a time expressed in seconds since noon - 12h (midnight, usually) and write it in HH:MM:SS format.
+         */
+        protected void writeTimeField (int secsSinceMidnight) throws IOException {
+            if (secsSinceMidnight == INT_MISSING) {
+                writeStringField("");
+                return;
+            }
+            
+            writeStringField(convertToGtfsTime(secsSinceMidnight));
+        }
+
+        public static String convertToGtfsTime (int secsSinceMidnight) {
+            int seconds = secsSinceMidnight % 60;
+            secsSinceMidnight -= seconds;
+            // note that the minute and hour values are still expressed in seconds until we write it out, to avoid unnecessary division.
+            int minutes = (secsSinceMidnight % 3600);
+            // secsSinceMidnight now represents hours
+            secsSinceMidnight -= minutes;
+
+            // integer divide is fine as we've subtracted off remainders
+            return String.format(Locale.getDefault(), "%02d:%02d:%02d", secsSinceMidnight / 3600, minutes / 60, seconds);
+        }
+
+        protected void writeIntField (Integer val) throws IOException {
+            if (val.equals(INT_MISSING))
+                writeStringField("");
+            else
+                writeStringField(val.toString());
+        }
+
+        /**
+         * Write a double value, with precision 10^-7. NaN is written as "".
+         */
+        protected void writeDoubleField (double val) throws IOException {
+            // NaN's represent missing values
+            if (Double.isNaN(val))
+                writeStringField("");
+            
+            // control file size: don't use unnecessary precision
+            // This is usually used for coordinates; one ten-millionth of a degree at the equator is 1.1cm,
+            // and smaller elsewhere on earth, plenty precise enough.
+            // On Jupiter, however, it's a different story.
+            // Use the US locale so that . is used as the decimal separator
+            else
+                writeStringField(String.format(Locale.US, "%.7f", val));
+        }
+
+        /**
+         * End a row.
+         * This is just a proxy to the writer, but could be used for hooks in the future.
+         */
+        public void endRecord () throws IOException {
+            writer.endRecord();
+        }
+    }
+
+
+    // shared code between reading and writing
+    private static final String human (long n) {
+        if (n >= 1000000) return String.format(Locale.getDefault(), "%.1fM", n/1000000.0);
+        if (n >= 1000) return String.format(Locale.getDefault(), "%.1fk", n/1000.0);
+        else return String.format(Locale.getDefault(), "%d", n);
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Fare.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Fare.java
new file mode 100644
index 0000000000..3e76b70bbe
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Fare.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.google.common.collect.Lists;
+
+import java.io.Serializable;
+import java.util.List;
+
+/**
+ * This table does not exist in GTFS. It is a join of fare_attributes and fare_rules on fare_id.
+ * There should only be one fare_attribute per fare_id, but there can be many fare_rules per fare_id.
+ */
+public class Fare implements Serializable {
+    public static final long serialVersionUID = 1L;
+
+    public String         fare_id;
+    public FareAttribute  fare_attribute;
+    public List<FareRule> fare_rules = Lists.newArrayList();
+
+    public Fare(String fare_id) {
+        this.fare_id = fare_id;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareAttribute.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareAttribute.java
new file mode 100644
index 0000000000..f033101548
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareAttribute.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.DuplicateKeyError;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+
+public class FareAttribute extends Entity {
+
+    private static final long serialVersionUID = 2157859372072056891L;
+    public String fare_id;
+    public double price;
+    public String currency_type;
+    public int payment_method;
+    public int transfers;
+    public int transfer_duration;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<FareAttribute> {
+        private final Map<String, Fare> fares;
+
+        public Loader(GTFSFeed feed, Map<String, Fare> fares) {
+            super(feed, "fare_attributes");
+            this.fares = fares;
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+
+            /* Calendars and Fares are special: they are stored as joined tables rather than simple maps. */
+            String fareId = getStringField("fare_id", true);
+            Fare fare = fares.computeIfAbsent(fareId, Fare::new);
+            if (fare.fare_attribute != null) {
+                feed.errors.add(new DuplicateKeyError(tableName, row, "fare_id"));
+            } else {
+                FareAttribute fa = new FareAttribute();
+                fa.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+                fa.fare_id = fareId;
+                fa.price = getDoubleField("price", true, 0, Integer.MAX_VALUE);
+                fa.currency_type = getStringField("currency_type", true);
+                fa.payment_method = getIntField("payment_method", true, 0, 1);
+                fa.transfers = getIntField("transfers", false, 0, 10); // TODO missing means "unlimited" in this case (rather than 0), supply default value or just use the NULL to mean unlimited
+                fa.transfer_duration = getIntField("transfer_duration", false, 0, 24 * 60 * 60);
+                fa.feed = feed;
+                fa.feed_id = feed.feedId;
+                fare.fare_attribute = fa;
+            }
+
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<FareAttribute> {
+        public Writer(GTFSFeed feed) {
+            super(feed, "fare_attributes");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"fare_id", "price", "currency_type", "payment_method",
+                    "transfers", "transfer_duration"});
+        }
+
+        @Override
+        public void writeOneRow(FareAttribute fa) throws IOException {
+            writeStringField(fa.fare_id);
+            writeDoubleField(fa.price);
+            writeStringField(fa.currency_type);
+            writeIntField(fa.payment_method);
+            writeIntField(fa.transfers);
+            writeIntField(fa.transfer_duration);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<FareAttribute> iterator() {
+            return feed.fares.values().stream()
+                    .map(f -> f.fare_attribute)
+                    .iterator();
+        }
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareRule.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareRule.java
new file mode 100644
index 0000000000..616fe295ec
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FareRule.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.ReferentialIntegrityError;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+
+public class FareRule extends Entity {
+
+    private static final long serialVersionUID = 3209660216692732272L;
+    public String fare_id;
+    public String route_id;
+    public String origin_id;
+    public String destination_id;
+    public String contains_id;
+
+    public static class Loader extends Entity.Loader<FareRule> {
+
+        private final Map<String, Fare> fares;
+
+        public Loader(GTFSFeed feed, Map<String, Fare> fares) {
+            super(feed, "fare_rules");
+            this.fares = fares;
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+
+            /* Calendars and Fares are special: they are stored as joined tables rather than simple maps. */
+            String fareId = getStringField("fare_id", true);
+
+            /* Referential integrity check for fare id */
+            if (!fares.containsKey(fareId)) {
+                this.feed.errors.add(new ReferentialIntegrityError(tableName, row, "fare_id", fareId));
+            }
+
+            Fare fare = fares.computeIfAbsent(fareId, Fare::new);
+            FareRule fr = new FareRule();
+            fr.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            fr.fare_id = fare.fare_id;
+            fr.route_id = getStringField("route_id", false);
+            fr.origin_id = getStringField("origin_id", false);
+            fr.destination_id = getStringField("destination_id", false);
+            fr.contains_id = getStringField("contains_id", false);
+            fr.feed = feed;
+            fare.fare_rules.add(fr);
+
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<FareRule> {
+        public Writer(GTFSFeed feed) {
+            super(feed, "fare_rules");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"fare_id", "route_id", "origin_id", "destination_id",
+                    "contains_id"});
+        }
+
+        @Override
+        public void writeOneRow(FareRule fr) throws IOException {
+            writeStringField(fr.fare_id);
+            writeStringField(fr.route_id);
+            writeStringField(fr.origin_id);
+            writeStringField(fr.destination_id);
+            writeStringField(fr.contains_id);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<FareRule> iterator() {
+            return feed.fares.values().stream()
+                    .map(f -> f.fare_rules)
+                    .flatMap(fr -> fr.stream())
+                    .iterator();
+        }
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FeedInfo.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FeedInfo.java
new file mode 100644
index 0000000000..18632e5054
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/FeedInfo.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import com.conveyal.gtfs.error.GeneralError;
+
+import java.io.IOException;
+import java.net.URL;
+import java.time.LocalDate;
+import java.util.Iterator;
+
+public class FeedInfo extends Entity implements Cloneable {
+
+    private static final long serialVersionUID = 8718856987299076452L;
+    public String    feed_id = "NONE";
+    public String    feed_publisher_name;
+    public URL       feed_publisher_url;
+    public String    feed_lang;
+    public LocalDate feed_start_date;
+    public LocalDate feed_end_date;
+    public String    feed_version;
+
+    public FeedInfo clone () {
+        try {
+            return (FeedInfo) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static class Loader extends Entity.Loader<FeedInfo> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "feed_info");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            FeedInfo fi = new FeedInfo();
+            fi.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            fi.feed_id = getStringField("feed_id", false);
+            fi.feed_publisher_name = getStringField("feed_publisher_name", true);
+            fi.feed_publisher_url = getUrlField("feed_publisher_url", true);
+            fi.feed_lang = getStringField("feed_lang", true);
+            fi.feed_start_date = getDateField("feed_start_date", false);
+            fi.feed_end_date = getDateField("feed_end_date", false);
+            fi.feed_version = getStringField("feed_version", false);
+            fi.feed = feed;
+            if (feed.feedInfo.isEmpty()) {
+                feed.feedInfo.put("NONE", fi);
+                feed.feedId = fi.feed_id;
+            } else {
+                feed.errors.add(new GeneralError(tableName, row, null, "FeedInfo contains more than one record."));
+            }
+        }
+    }
+
+    public static class Writer extends Entity.Writer<FeedInfo> {
+
+        public Writer(GTFSFeed feed) {
+            super(feed, "feed_info");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"feed_id", "feed_publisher_name", "feed_publisher_url", "feed_lang",
+                    "feed_start_date", "feed_end_date", "feed_version"});
+        }
+
+        @Override
+        public void writeOneRow(FeedInfo i) throws IOException {
+            writeStringField(i.feed_id != null && i.feed_id.equals("NONE") ? "" : i.feed_id);
+            writeStringField(i.feed_publisher_name);
+            writeUrlField(i.feed_publisher_url);
+            writeStringField(i.feed_lang);
+
+            if (i.feed_start_date != null) writeDateField(i.feed_start_date);
+            else writeStringField("");
+
+            if (i.feed_end_date != null) writeDateField(i.feed_end_date);
+            else writeStringField("");
+
+            writeStringField(i.feed_version);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<FeedInfo> iterator() {
+            return feed.feedInfo.values().iterator();
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Frequency.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Frequency.java
new file mode 100644
index 0000000000..8d7bfd14c1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Frequency.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import org.mapdb.Fun;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Locale;
+
+import static com.conveyal.gtfs.model.Entity.Writer.convertToGtfsTime;
+
+public class Frequency extends Entity implements Comparable<Frequency> {
+    /**
+     * Frequency entries have no ID in GTFS so we define one based on the fields in the frequency entry.
+     *
+     * It is possible to have two identical frequency entries in the GTFS, which under our understanding of the situation
+     * would mean that two sets of vehicles were randomly running the same trip at the same headway, but uncorrelated
+     * with each other, which is almost certain to be an error.
+     */
+     public String getId() {
+        StringBuilder sb = new StringBuilder();
+         sb.append(trip_id);
+         sb.append('_');
+         sb.append(convertToGtfsTime(start_time));
+         sb.append("_to_");
+         sb.append(convertToGtfsTime(end_time));
+         sb.append("_every_");
+         sb.append(String.format(Locale.getDefault(), "%dm%02ds", headway_secs / 60, headway_secs % 60));
+         if (exact_times == 1) sb.append("_exact");
+         return sb.toString();
+     }
+
+    private static final long serialVersionUID = -7182161664471704133L;
+    public String trip_id;
+    public int start_time;
+    public int end_time;
+    public int headway_secs;
+    public int exact_times;
+
+    /** must have a comparator since they go in a navigable set that is serialized */
+    @Override
+    public int compareTo(Frequency o) {
+        return this.start_time - o.start_time;
+    }
+
+    public static class Loader extends Entity.Loader<Frequency> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "frequencies");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Frequency f = new Frequency();
+            Trip trip = getRefField("trip_id", true, feed.trips);
+            f.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            f.trip_id = trip.trip_id;
+            f.start_time = getTimeField("start_time", true);
+            f.end_time = getTimeField("end_time", true);
+            f.headway_secs = getIntField("headway_secs", true, 1, 24 * 60 * 60);
+            f.exact_times = getIntField("exact_times", false, 0, 1);
+            f.feed = feed;
+            feed.frequencies.add(Fun.t2(f.trip_id, f));
+        }
+    }
+
+    public static class Writer extends Entity.Writer<Frequency> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "frequencies");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"trip_id", "start_time", "end_time", "headway_secs", "exact_times"});
+        }
+
+        @Override
+        public void writeOneRow(Frequency f) throws IOException {
+            writeStringField(f.trip_id);
+            writeTimeField(f.start_time);
+            writeTimeField(f.end_time);
+            writeIntField(f.headway_secs);
+            writeIntField(f.exact_times);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<Frequency> iterator() {
+            return feed.frequencies.stream()
+                    .map(t2 -> t2.b)
+                    .iterator();
+        }
+
+
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Route.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Route.java
new file mode 100644
index 0000000000..be8097771e
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Route.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.Iterator;
+
+public class Route extends Entity { // implements Entity.Factory<Route>
+
+    private static final long serialVersionUID = -819444896818029068L;
+
+    public static final int TRAM = 0;
+    public static final int SUBWAY = 1;
+    public static final int RAIL = 2;
+    public static final int BUS = 3;
+    public static final int FERRY = 4;
+    public static final int CABLE_CAR = 4;
+    public static final int GONDOLA = 4;
+    public static final int FUNICULAR = 5;
+
+    public String route_id;
+    public String agency_id;
+    public String route_short_name;
+    public String route_long_name;
+    public String route_desc;
+    public int    route_type;
+    public URL    route_url;
+    public String route_color;
+    public String route_text_color;
+    public URL route_branding_url;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<Route> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "routes");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Route r = new Route();
+            r.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            r.route_id = getStringField("route_id", true);
+            Agency agency = getRefField("agency_id", false, feed.agency);
+
+            // if there is only one agency, associate with it automatically
+            if (agency == null && feed.agency.size() == 1) {
+                agency = feed.agency.values().iterator().next();
+            }
+
+            // If we still haven't got an agency, it's because we have a bad reference, or because there is no agency
+            if (agency != null) {
+                r.agency_id = agency.agency_id;
+            }
+
+            r.route_short_name = getStringField("route_short_name", false); // one or the other required, needs a special validator
+            r.route_long_name = getStringField("route_long_name", false);
+            r.route_desc = getStringField("route_desc", false);
+            r.route_type = getIntField("route_type", true, 0, 7);
+            r.route_url = getUrlField("route_url", false);
+            r.route_color = getStringField("route_color", false);
+            r.route_text_color = getStringField("route_text_color", false);
+            r.route_branding_url = getUrlField("route_branding_url", false);
+            r.feed = feed;
+            r.feed_id = feed.feedId;
+            feed.routes.put(r.route_id, r);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Route> {    	
+        public Writer (GTFSFeed feed) {
+            super(feed, "routes");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writeStringField("agency_id");
+            writeStringField("route_id");
+            writeStringField("route_short_name");
+            writeStringField("route_long_name");
+            writeStringField("route_desc");
+            writeStringField("route_type");
+            writeStringField("route_url");
+            writeStringField("route_color");
+            writeStringField("route_text_color");
+            writeStringField("route_branding_url");
+            endRecord();
+        }
+
+        @Override
+        public void writeOneRow(Route r) throws IOException {
+            writeStringField(r.agency_id);
+            writeStringField(r.route_id);
+            writeStringField(r.route_short_name);
+            writeStringField(r.route_long_name);
+            writeStringField(r.route_desc);
+            writeIntField(r.route_type);
+            writeUrlField(r.route_url);
+            writeStringField(r.route_color);
+            writeStringField(r.route_text_color);
+            writeUrlField(r.route_branding_url);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<Route> iterator() {
+            return feed.routes.values().iterator();
+        }   	
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Service.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Service.java
new file mode 100644
index 0000000000..16039075a1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Service.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.google.common.collect.Maps;
+
+import java.io.Serializable;
+import java.time.DayOfWeek;
+import java.time.LocalDate;
+import java.util.EnumSet;
+import java.util.Map;
+
+import static java.time.DayOfWeek.*;
+
+/**
+ * This table does not exist in GTFS. It is a join of calendars and calendar_dates on service_id.
+ * There should only be one Calendar per service_id. There should only be one calendar_date per tuple of
+ * (service_id, date), which means there can be many calendar_dates per service_id.
+ */
+public class Service implements Serializable {
+
+    private static final long serialVersionUID = 7966238549509747091L;
+    public String   service_id;
+    public Calendar calendar;
+    public Map<LocalDate, CalendarDate> calendar_dates = Maps.newHashMap();
+
+    public Service(String service_id) {
+        this.service_id = service_id;
+    }
+
+    /**
+     * @param service_id the service_id to assign to the newly created copy.
+     * @param daysToRemove the days of the week on which to deactivate service in the copy.
+     * @return a copy of this Service with any service on the specified days of the week deactivated.
+     */
+    public Service removeDays(String service_id, EnumSet<DayOfWeek> daysToRemove) {
+        Service service = new Service(service_id);
+        // First, duplicate any Calendar in this Service, minus the specified days of the week.
+        if (this.calendar != null) {
+            Calendar calendar = new Calendar();
+            //  TODO calendar.getDaysOfWeek/setDaysOfWeek which allow simplifying this section and activeOn below.
+            calendar.monday    = daysToRemove.contains(MONDAY)    ? 0 : this.calendar.monday;
+            calendar.tuesday   = daysToRemove.contains(TUESDAY)   ? 0 : this.calendar.tuesday;
+            calendar.wednesday = daysToRemove.contains(WEDNESDAY) ? 0 : this.calendar.wednesday;
+            calendar.thursday  = daysToRemove.contains(THURSDAY)  ? 0 : this.calendar.thursday;
+            calendar.friday    = daysToRemove.contains(FRIDAY)    ? 0 : this.calendar.friday;
+            calendar.saturday  = daysToRemove.contains(SATURDAY)  ? 0 : this.calendar.saturday;
+            calendar.sunday    = daysToRemove.contains(SUNDAY)    ? 0 : this.calendar.sunday;
+            // The new calendar should cover exactly the same time range as the existing one.
+            calendar.start_date = this.calendar.start_date;
+            calendar.end_date   = this.calendar.end_date;
+            // Create the bidirectional reference between Calendar and Service.
+            service.calendar = calendar;
+        }
+        // Copy over all exceptions whose dates fall on days of the week that are retained.
+        this.calendar_dates.forEach((date, exception) -> {
+            DayOfWeek dow = date.getDayOfWeek();
+            if (!daysToRemove.contains(dow)) {
+                CalendarDate newException = exception.clone();
+                service.calendar_dates.put(date, newException);
+            }
+        });
+        return service;
+    }
+
+    /**
+     * @return whether this Service is ever active at all, either from calendar or calendar_dates.
+     */
+    public boolean hasAnyService() {
+
+        // Look for any service defined in calendar (on days of the week).
+        boolean hasAnyService = calendar != null && (
+                calendar.monday == 1 ||
+                calendar.tuesday == 1 ||
+                calendar.wednesday == 1 ||
+                calendar.thursday == 1 ||
+                calendar.friday == 1 ||
+                calendar.saturday == 1 ||
+                calendar.sunday == 1 );
+
+        // Also look for any exceptions of type 1 (added service).
+        hasAnyService |= calendar_dates.values().stream().anyMatch(cd -> cd.exception_type == 1);
+
+        return hasAnyService;
+    }
+
+    /**
+     * Is this service active on the specified date?
+     */
+    public boolean activeOn (LocalDate date) {
+        // first check for exceptions
+        CalendarDate exception = calendar_dates.get(date);
+
+        if (exception != null)
+            return exception.exception_type == 1;
+
+        else if (calendar == null)
+            return false;
+
+        else {
+            int gtfsDate = date.getYear() * 10000 + date.getMonthValue() * 100 + date.getDayOfMonth();
+            boolean withinValidityRange = calendar.end_date >= gtfsDate && calendar.start_date <= gtfsDate;
+
+            if (!withinValidityRange) return false;
+
+            switch (date.getDayOfWeek()) {
+                case MONDAY:
+                    return calendar.monday == 1;
+                case TUESDAY:
+                    return calendar.tuesday == 1;
+                case WEDNESDAY:
+                    return calendar.wednesday == 1;
+                case THURSDAY:
+                    return calendar.thursday == 1;
+                case FRIDAY:
+                    return calendar.friday == 1;
+                case SATURDAY:
+                    return calendar.saturday == 1;
+                case SUNDAY:
+                    return calendar.sunday == 1;
+                default:
+                    throw new IllegalArgumentException("unknown day of week constant!");
+            }
+        }
+    }
+
+    /**
+     * Checks for overlapping days of week between two service calendars
+     * @param s1
+     * @param s2
+     * @return true if both calendars simultaneously operate on at least one day of the week
+     */
+    public static boolean checkOverlap (Service s1, Service s2) {
+        if (s1.calendar == null || s2.calendar == null) {
+            return false;
+        }
+        // overlap exists if at least one day of week is shared by two calendars
+        boolean overlappingDays = s1.calendar.monday == 1 && s2.calendar.monday == 1 ||
+                s1.calendar.tuesday == 1 && s2.calendar.tuesday == 1 ||
+                s1.calendar.wednesday == 1 && s2.calendar.wednesday == 1 ||
+                s1.calendar.thursday == 1 && s2.calendar.thursday == 1 ||
+                s1.calendar.friday == 1 && s2.calendar.friday == 1 ||
+                s1.calendar.saturday == 1 && s2.calendar.saturday == 1 ||
+                s1.calendar.sunday == 1 && s2.calendar.sunday == 1;
+        return overlappingDays;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Shape.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Shape.java
new file mode 100644
index 0000000000..44723c6bce
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Shape.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
+import org.mapdb.Fun;
+
+import java.util.Map;
+
+/**
+ * Represents a collection of GTFS shape points. Never saved in MapDB but constructed on the fly.
+ */
+public class Shape {
+    public static GeometryFactory geometryFactory = new GeometryFactory();
+    /** The shape itself */
+    public LineString geometry;
+
+    /** shape_dist_traveled for each point in the geometry. TODO how to handle shape dist traveled not specified, or not specified on all stops? */
+    public double[] shape_dist_traveled;
+
+    public Shape (GTFSFeed feed, String shape_id) {
+        Map<Fun.Tuple2<String, Integer>, ShapePoint> points =
+                feed.shape_points.subMap(new Fun.Tuple2(shape_id, null), new Fun.Tuple2(shape_id, Fun.HI));
+
+        Coordinate[] coords = points.values().stream()
+                .map(point -> new Coordinate(point.shape_pt_lon, point.shape_pt_lat))
+                .toArray(i -> new Coordinate[i]);
+        geometry = geometryFactory.createLineString(coords);
+        shape_dist_traveled = points.values().stream().mapToDouble(point -> point.shape_dist_traveled).toArray();
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/ShapePoint.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/ShapePoint.java
new file mode 100644
index 0000000000..2691a2783f
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/ShapePoint.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import org.mapdb.Fun.Tuple2;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+public class ShapePoint extends Entity {
+
+    private static final long serialVersionUID = 6751814959971086070L;
+    public final String shape_id;
+    public final double shape_pt_lat;
+    public final double shape_pt_lon;
+    public final int    shape_pt_sequence;
+    public final double shape_dist_traveled;
+
+    // Similar to stoptime, we have to have a constructor, because fields are final so as to be immutable for storage in MapDB.
+    public ShapePoint(String shape_id, double shape_pt_lat, double shape_pt_lon, int shape_pt_sequence, double shape_dist_traveled) {
+        this.shape_id = shape_id;
+        this.shape_pt_lat = shape_pt_lat;
+        this.shape_pt_lon = shape_pt_lon;
+        this.shape_pt_sequence = shape_pt_sequence;
+        this.shape_dist_traveled = shape_dist_traveled;
+    }
+
+    public static class Loader extends Entity.Loader<ShapePoint> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "shapes");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            String shape_id = getStringField("shape_id", true);
+            double shape_pt_lat = getDoubleField("shape_pt_lat", true, -90D, 90D);
+            double shape_pt_lon = getDoubleField("shape_pt_lon", true, -180D, 180D);
+            int shape_pt_sequence = getIntField("shape_pt_sequence", true, 0, Integer.MAX_VALUE);
+            double shape_dist_traveled = getDoubleField("shape_dist_traveled", false, 0D, Double.MAX_VALUE);
+
+            ShapePoint s = new ShapePoint(shape_id, shape_pt_lat, shape_pt_lon, shape_pt_sequence, shape_dist_traveled);
+            s.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            s.feed = null; // since we're putting this into MapDB, we don't want circular serialization
+            feed.shape_points.put(new Tuple2<String, Integer>(s.shape_id, s.shape_pt_sequence), s);
+        }
+    }
+
+    public static class Writer extends Entity.Writer<ShapePoint> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "shapes");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"shape_id", "shape_pt_lat", "shape_pt_lon", "shape_pt_sequence", "shape_dist_traveled"});
+        }
+
+        @Override
+        protected void writeOneRow(ShapePoint s) throws IOException {
+            writeStringField(s.shape_id);
+            writeDoubleField(s.shape_pt_lat);
+            writeDoubleField(s.shape_pt_lon);
+            writeIntField(s.shape_pt_sequence);
+            writeDoubleField(s.shape_dist_traveled);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<ShapePoint> iterator() {
+            return feed.shape_points.values().iterator();
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Stop.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Stop.java
new file mode 100644
index 0000000000..f35303ee15
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Stop.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.Iterator;
+
+public class Stop extends Entity {
+
+    private static final long serialVersionUID = 464065335273514677L;
+    public String stop_id;
+    public String stop_code;
+    public String stop_name;
+    public String stop_desc;
+    public double stop_lat;
+    public double stop_lon;
+    public String zone_id;
+    public URL    stop_url;
+    public int    location_type;
+    public String parent_station;
+    public String stop_timezone;
+    // TODO should be int
+    public String wheelchair_boarding;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<Stop> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "stops");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Stop s = new Stop();
+            s.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            s.stop_id   = getStringField("stop_id", true);
+            s.stop_code = getStringField("stop_code", false);
+            s.stop_name = getStringField("stop_name", true);
+            s.stop_desc = getStringField("stop_desc", false);
+            s.stop_lat  = getDoubleField("stop_lat", true, -90D, 90D);
+            s.stop_lon  = getDoubleField("stop_lon", true, -180D, 180D);
+            s.zone_id   = getStringField("zone_id", false);
+            s.stop_url  = getUrlField("stop_url", false);
+            s.location_type  = getIntField("location_type", false, 0, 1);
+            s.parent_station = getStringField("parent_station", false);
+            s.stop_timezone  = getStringField("stop_timezone", false);
+            s.wheelchair_boarding = getStringField("wheelchair_boarding", false);
+            s.feed = feed;
+            s.feed_id = feed.feedId;
+            /* TODO check ref integrity later, this table self-references via parent_station */
+
+            feed.stops.put(s.stop_id, s);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Stop> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "stops");
+        }
+
+        @Override
+        public void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"stop_id", "stop_code", "stop_name", "stop_desc", "stop_lat", "stop_lon", "zone_id",					
+                    "stop_url", "location_type", "parent_station", "stop_timezone", "wheelchair_boarding"});
+        }
+
+        @Override
+        public void writeOneRow(Stop s) throws IOException {
+            writeStringField(s.stop_id);
+            writeStringField(s.stop_code);
+            writeStringField(s.stop_name);
+            writeStringField(s.stop_desc);
+            writeDoubleField(s.stop_lat);
+            writeDoubleField(s.stop_lon);
+            writeStringField(s.zone_id);
+            writeUrlField(s.stop_url);
+            writeIntField(s.location_type);
+            writeStringField(s.parent_station);
+            writeStringField(s.stop_timezone);
+            writeStringField(s.wheelchair_boarding);
+            endRecord();
+        }
+
+        @Override
+        public Iterator<Stop> iterator() {
+            return feed.stops.values().iterator();
+        }   	
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/StopTime.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/StopTime.java
new file mode 100644
index 0000000000..943a50641e
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/StopTime.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+import org.mapdb.Fun;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.Iterator;
+
+/**
+ * Represents a GTFS StopTime. Note that once created and saved in a feed, stop times are by convention immutable
+ * because they are in a MapDB.
+ */
+public class StopTime extends Entity implements Cloneable, Serializable {
+
+    private static final long serialVersionUID = -8883780047901081832L;
+    /* StopTime cannot directly reference Trips or Stops because they would be serialized into the MapDB. */
+    public String trip_id;
+    public int    arrival_time = INT_MISSING;
+    public int    departure_time = INT_MISSING;
+    public String stop_id;
+    public int    stop_sequence;
+    public String stop_headsign;
+    public int    pickup_type;
+    public int    drop_off_type;
+    public double shape_dist_traveled;
+    public int    timepoint = INT_MISSING;
+
+    public static class Loader extends Entity.Loader<StopTime> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "stop_times");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            StopTime st = new StopTime();
+            st.sourceFileLine = row + 1; // offset line number by 1 to account for 0-based row index
+            st.trip_id        = getStringField("trip_id", true);
+            // TODO: arrival_time and departure time are not required, but if one is present the other should be
+            // also, if this is the first or last stop, they are both required
+            st.arrival_time   = getTimeField("arrival_time", false);
+            st.departure_time = getTimeField("departure_time", false);
+            st.stop_id        = getStringField("stop_id", true);
+            st.stop_sequence  = getIntField("stop_sequence", true, 0, Integer.MAX_VALUE);
+            st.stop_headsign  = getStringField("stop_headsign", false);
+            st.pickup_type    = getIntField("pickup_type", false, 0, 3); // TODO add ranges as parameters
+            st.drop_off_type  = getIntField("drop_off_type", false, 0, 3);
+            st.shape_dist_traveled = getDoubleField("shape_dist_traveled", false, 0D, Double.MAX_VALUE); // FIXME using both 0 and NaN for "missing", define DOUBLE_MISSING
+            st.timepoint      = getIntField("timepoint", false, 0, 1, INT_MISSING);
+            st.feed           = null; // this could circular-serialize the whole feed
+            feed.stop_times.put(new Fun.Tuple2(st.trip_id, st.stop_sequence), st);
+
+            /*
+              Check referential integrity without storing references. StopTime cannot directly reference Trips or
+              Stops because they would be serialized into the MapDB.
+             */
+            getRefField("trip_id", true, feed.trips);
+            getRefField("stop_id", true, feed.stops);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<StopTime> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "stop_times");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"trip_id", "arrival_time", "departure_time", "stop_id", "stop_sequence", "stop_headsign",
+                    "pickup_type", "drop_off_type", "shape_dist_traveled", "timepoint"});
+        }
+
+        @Override
+        protected void writeOneRow(StopTime st) throws IOException {
+            writeStringField(st.trip_id);
+            writeTimeField(st.arrival_time);
+            writeTimeField(st.departure_time);
+            writeStringField(st.stop_id);
+            writeIntField(st.stop_sequence);
+            writeStringField(st.stop_headsign);
+            writeIntField(st.pickup_type);
+            writeIntField(st.drop_off_type);
+            writeDoubleField(st.shape_dist_traveled);
+            writeIntField(st.timepoint);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<StopTime> iterator() {
+            return feed.stop_times.values().iterator();
+        }
+
+
+    }
+
+    @Override
+    public StopTime clone () {
+        try {
+            return (StopTime) super.clone();
+        } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Transfer.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Transfer.java
new file mode 100644
index 0000000000..4fe43fb881
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Transfer.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+public class Transfer extends Entity {
+
+    private static final long serialVersionUID = -4944512120812641063L;
+    public String from_stop_id;
+    public String to_stop_id;
+    public int  transfer_type;
+    public int  min_transfer_time;
+    public String from_route_id;
+    public String to_route_id;
+    public String from_trip_id;
+    public String to_trip_id;
+
+    public static class Loader extends Entity.Loader<Transfer> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "transfers");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return false;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Transfer tr = new Transfer();
+            tr.sourceFileLine    = row + 1; // offset line number by 1 to account for 0-based row index
+            tr.from_stop_id      = getStringField("from_stop_id", true);
+            tr.to_stop_id        = getStringField("to_stop_id", true);
+            tr.transfer_type     = getIntField("transfer_type", true, 0, 3);
+            tr.min_transfer_time = getIntField("min_transfer_time", false, 0, Integer.MAX_VALUE);
+            tr.from_route_id     = getStringField("from_route_id", false);
+            tr.to_route_id       = getStringField("to_route_id", false);
+            tr.from_trip_id      = getStringField("from_trip_id", false);
+            tr.to_trip_id        = getStringField("to_trip_id", false);
+
+            getRefField("from_stop_id", true, feed.stops);
+            getRefField("to_stop_id", true, feed.stops);
+            getRefField("from_route_id", false, feed.routes);
+            getRefField("to_route_id", false, feed.routes);
+            getRefField("from_trip_id", false, feed.trips);
+            getRefField("to_trip_id", false, feed.trips);
+
+            tr.feed = feed;
+            feed.transfers.put(Long.toString(row), tr);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Transfer> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "transfers");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            writer.writeRecord(new String[] {"from_stop_id", "to_stop_id", "transfer_type", "min_transfer_time"});
+        }
+
+        @Override
+        protected void writeOneRow(Transfer t) throws IOException {
+            writeStringField(t.from_stop_id);
+            writeStringField(t.to_stop_id);
+            writeIntField(t.transfer_type);
+            writeIntField(t.min_transfer_time);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<Transfer> iterator() {
+            return feed.transfers.values().iterator();
+        }
+
+
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Trip.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Trip.java
new file mode 100644
index 0000000000..b7c4b06e87
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/model/Trip.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.model;
+
+import com.conveyal.gtfs.GTFSFeed;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+public class Trip extends Entity {
+
+    private static final long serialVersionUID = -4869384750974542712L;
+    public String route_id;
+    public String service_id;
+    public String trip_id;
+    public String trip_headsign;
+    public String trip_short_name;
+    public int    direction_id;
+    public String block_id;
+    public String shape_id;
+    public int    bikes_allowed;
+    public int    wheelchair_accessible;
+    public String feed_id;
+
+    public static class Loader extends Entity.Loader<Trip> {
+
+        public Loader(GTFSFeed feed) {
+            super(feed, "trips");
+        }
+
+        @Override
+        protected boolean isRequired() {
+            return true;
+        }
+
+        @Override
+        public void loadOneRow() throws IOException {
+            Trip t = new Trip();
+
+            t.sourceFileLine  = row + 1; // offset line number by 1 to account for 0-based row index
+            t.route_id        = getStringField("route_id", true);
+            t.service_id      = getStringField("service_id", true);
+            t.trip_id         = getStringField("trip_id", true);
+            t.trip_headsign   = getStringField("trip_headsign", false);
+            t.trip_short_name = getStringField("trip_short_name", false);
+            t.direction_id    = getIntField("direction_id", false, 0, 1);
+            t.block_id        = getStringField("block_id", false); // make a blocks multimap
+            t.shape_id        = getStringField("shape_id", false);
+            t.bikes_allowed   = getIntField("bikes_allowed", false, 0, 2);
+            t.wheelchair_accessible = getIntField("wheelchair_accessible", false, 0, 2);
+            t.feed = feed;
+            t.feed_id = feed.feedId;
+            feed.trips.put(t.trip_id, t);
+
+            /*
+              Check referential integrity without storing references. Trip cannot directly reference Services or
+              Routes because they would be serialized into the MapDB.
+             */
+            // TODO confirm existence of shape ID
+            getRefField("service_id", true, feed.services);
+            getRefField("route_id", true, feed.routes);
+        }
+
+    }
+
+    public static class Writer extends Entity.Writer<Trip> {
+        public Writer (GTFSFeed feed) {
+            super(feed, "trips");
+        }
+
+        @Override
+        protected void writeHeaders() throws IOException {
+            // TODO: export shapes
+            writer.writeRecord(new String[] {"route_id", "trip_id", "trip_headsign", "trip_short_name", "direction_id", "block_id",
+                    "shape_id", "bikes_allowed", "wheelchair_accessible", "service_id"});
+        }
+
+        @Override
+        protected void writeOneRow(Trip t) throws IOException {
+            writeStringField(t.route_id);
+            writeStringField(t.trip_id);
+            writeStringField(t.trip_headsign);
+            writeStringField(t.trip_short_name);
+            writeIntField(t.direction_id);
+            writeStringField(t.block_id);
+            writeStringField(t.shape_id);
+            writeIntField(t.bikes_allowed);
+            writeIntField(t.wheelchair_accessible);
+            writeStringField(t.service_id);
+            endRecord();
+        }
+
+        @Override
+        protected Iterator<Trip> iterator() {
+            return feed.trips.values().iterator();
+        }
+
+
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/conveyal/gtfs/util/Deduplicator.java b/reader-gtfs/src/main/java/com/conveyal/gtfs/util/Deduplicator.java
new file mode 100644
index 0000000000..54defdb1a3
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/conveyal/gtfs/util/Deduplicator.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2015, Conveyal
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  Redistributions of source code must retain the above copyright notice, this
+ *   list of conditions and the following disclaimer.
+ *
+ *  Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.conveyal.gtfs.util;
+
+import com.google.common.collect.Maps;
+
+import java.io.Serializable;
+import java.util.Map;
+
+/**
+ * Does the same thing as String.intern, but for several different types.
+ * Java's String.intern uses perm gen space and is broken anyway.
+ */
+public class Deduplicator implements Serializable {
+    private static final long serialVersionUID = 20140524L;
+
+    private final Map<String, String> canonicalStrings = Maps.newHashMap();
+
+    /** Free up any memory used by the deduplicator. */
+    public void reset() {
+        canonicalStrings.clear();
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java
new file mode 100644
index 0000000000..4bab2c1be1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/FeedConfiguration.java
@@ -0,0 +1,63 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.google.transit.realtime.GtfsRealtime;
+
+import java.io.IOException;
+import java.net.URL;
+
+public class FeedConfiguration {
+
+    private URL url;
+    private String agencyId;
+    private String feedId;
+
+    @JsonProperty
+    public URL getUrl() {
+        return url;
+    }
+
+    @JsonProperty
+    public void setUrl(URL url) {
+        this.url = url;
+    }
+
+    @JsonProperty
+    public String getAgencyId() {
+        return agencyId;
+    }
+
+    @JsonProperty
+    public void setAgencyId(String agencyId) {
+        this.agencyId = agencyId;
+    }
+
+    @JsonProperty
+    public String getFeedId() {
+        return feedId;
+    }
+
+    @JsonProperty
+    public void setFeedId(String feedId) {
+        this.feedId = feedId;
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java
new file mode 100644
index 0000000000..a61fbd6c95
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundle.java
@@ -0,0 +1,52 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.graphhopper.reader.gtfs.RealtimeFeed;
+import io.dropwizard.ConfiguredBundle;
+import io.dropwizard.client.HttpClientBuilder;
+import io.dropwizard.setup.Bootstrap;
+import io.dropwizard.setup.Environment;
+import org.apache.http.client.HttpClient;
+import org.glassfish.hk2.utilities.binding.AbstractBinder;
+
+import javax.inject.Singleton;
+
+public class RealtimeBundle implements ConfiguredBundle<RealtimeBundleConfiguration> {
+
+    @Override
+    public void initialize(Bootstrap<?> bootstrap) {
+    }
+
+    @Override
+    public void run(RealtimeBundleConfiguration configuration, Environment environment) {
+        final HttpClient httpClient = new HttpClientBuilder(environment)
+                .using(configuration.gtfsrealtime().getHttpClientConfiguration())
+                .build("gtfs-realtime-feed-loader");
+        environment.jersey().register(new AbstractBinder() {
+            @Override
+            protected void configure() {
+                bind(httpClient).to(HttpClient.class);
+                bind(configuration).to(RealtimeBundleConfiguration.class);
+                bindFactory(RealtimeFeedLoadingCache.class, Singleton.class).to(RealtimeFeed.class);
+            }
+        });
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/util/spatialrules/AccessValue.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java
similarity index 79%
rename from core/src/main/java/com/graphhopper/routing/util/spatialrules/AccessValue.java
rename to reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java
index 34f1c219a6..b772b43b9d 100644
--- a/core/src/main/java/com/graphhopper/routing/util/spatialrules/AccessValue.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeBundleConfiguration.java
@@ -15,17 +15,13 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.util.spatialrules;
 
-/**
- * Enum defining AccessValues
- *
- * @author Robin Boldt
- */
-public enum AccessValue {
+package com.graphhopper.gtfs.dropwizard;
+
+import java.util.List;
+
+public interface RealtimeBundleConfiguration {
 
-    ACCESSIBLE,
-    EVENTUALLY_ACCESSIBLE,
-    NOT_ACCESSIBLE
+    RealtimeConfiguration gtfsrealtime();
 
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java
new file mode 100644
index 0000000000..cf22843005
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeConfiguration.java
@@ -0,0 +1,49 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.google.transit.realtime.GtfsRealtime;
+import io.dropwizard.client.HttpClientConfiguration;
+
+import javax.validation.Valid;
+import javax.validation.constraints.NotNull;
+import java.io.IOException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+
+public class RealtimeConfiguration {
+
+    @Valid
+    @NotNull
+    @JsonProperty
+    private HttpClientConfiguration httpClient = new HttpClientConfiguration();
+
+    @JsonProperty
+    private List<FeedConfiguration> feeds = new ArrayList<>();
+
+    public List<FeedConfiguration> getFeeds() {
+        return feeds;
+    }
+
+    public HttpClientConfiguration getHttpClientConfiguration() {
+        return httpClient;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java
new file mode 100644
index 0000000000..b1c0634243
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/dropwizard/RealtimeFeedLoadingCache.java
@@ -0,0 +1,108 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.dropwizard;
+
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import com.google.transit.realtime.GtfsRealtime;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.RealtimeFeed;
+import com.graphhopper.storage.GraphHopperStorage;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.glassfish.hk2.api.Factory;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+import java.io.IOException;
+import java.net.URISyntaxException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+public class RealtimeFeedLoadingCache implements Factory<RealtimeFeed> {
+
+    private final HttpClient httpClient;
+    private final GraphHopperStorage graphHopperStorage;
+    private final GtfsStorage gtfsStorage;
+    private final PtFlagEncoder ptFlagEncoder;
+    private final RealtimeBundleConfiguration bundleConfiguration;
+    private final ExecutorService executor = Executors.newSingleThreadExecutor();
+    private final LoadingCache<String, RealtimeFeed> cache;
+
+    @Inject
+    RealtimeFeedLoadingCache(GraphHopperStorage graphHopperStorage, GtfsStorage gtfsStorage, PtFlagEncoder ptFlagEncoder, HttpClient httpClient, RealtimeBundleConfiguration bundleConfiguration) {
+        this.graphHopperStorage = graphHopperStorage;
+        this.gtfsStorage = gtfsStorage;
+        this.ptFlagEncoder = ptFlagEncoder;
+        this.bundleConfiguration = bundleConfiguration;
+        this.httpClient = httpClient;
+        this.cache = CacheBuilder.newBuilder()
+                .maximumSize(1)
+                .refreshAfterWrite(1, TimeUnit.MINUTES)
+                .build(new CacheLoader<String, RealtimeFeed>() {
+                    public RealtimeFeed load(String key) {
+                        return fetchFeedsAndCreateGraph();
+                    }
+
+                    @Override
+                    public ListenableFuture<RealtimeFeed> reload(String key, RealtimeFeed oldValue) {
+                        ListenableFutureTask<RealtimeFeed> task = ListenableFutureTask.create(() -> fetchFeedsAndCreateGraph());
+                        executor.execute(task);
+                        return task;
+                    }
+                });
+    }
+
+    @Override
+    public RealtimeFeed provide() {
+        try {
+            return cache.get("pups");
+        } catch (ExecutionException | RuntimeException e) {
+            e.printStackTrace();
+            return RealtimeFeed.empty(gtfsStorage);
+        }
+    }
+
+    @Override
+    public void dispose(RealtimeFeed instance) {
+
+    }
+
+    private RealtimeFeed fetchFeedsAndCreateGraph() {
+        Map<String, GtfsRealtime.FeedMessage> feedMessageMap = new HashMap<>();
+        for (FeedConfiguration configuration : bundleConfiguration.gtfsrealtime().getFeeds()) {
+            try {
+                GtfsRealtime.FeedMessage feedMessage = GtfsRealtime.FeedMessage.parseFrom(httpClient.execute(new HttpGet(configuration.getUrl().toURI())).getEntity().getContent());
+                feedMessageMap.put(configuration.getFeedId(), feedMessage);
+            } catch (IOException | URISyntaxException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return RealtimeFeed.fromProtobuf(graphHopperStorage, gtfsStorage, ptFlagEncoder, feedMessageMap);
+    }
+
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java b/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java
new file mode 100644
index 0000000000..05de238812
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/gtfs/ws/LocationConverterProvider.java
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.gtfs.ws;
+
+import com.graphhopper.MultiException;
+import com.graphhopper.reader.gtfs.GHLocation;
+
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ParamConverter;
+import javax.ws.rs.ext.ParamConverterProvider;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+public class LocationConverterProvider implements ParamConverterProvider {
+
+    @Override
+    public <T> ParamConverter<T> getConverter(Class<T> rawType, Type genericType, Annotation[] annotations) {
+        if (rawType.equals(GHLocation.class)) {
+            return new ParamConverter<T>() {
+                @Override
+                public T fromString(String value) {
+                    try {
+                        return (T) GHLocation.fromString(value);
+                    } catch (IllegalArgumentException ex) {
+                        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
+                                .entity(new MultiException(ex))
+                                .build());
+                    }
+                }
+
+                @Override
+                public String toString(T value) {
+                    return value.toString();
+                }
+            };
+        }
+        return null;
+    }
+}
+
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
index 4226826eaf..fa317e8539 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/EmptyLocationIndex.java
@@ -21,6 +21,7 @@
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.shapes.BBox;
 
 class EmptyLocationIndex implements LocationIndex {
     @Override
@@ -38,6 +39,10 @@ public QueryResult findClosest(double lat, double lon, EdgeFilter edgeFilter) {
         return new QueryResult(lat, lon);
     }
 
+    @Override
+    public void query(BBox queryBBox, Visitor function) {
+    }
+
     @Override
     public LocationIndex setApproximation(boolean approxDist) {
         return this;
@@ -45,7 +50,6 @@ public LocationIndex setApproximation(boolean approxDist) {
 
     @Override
     public void setSegmentSize(int bytes) {
-
     }
 
     @Override
@@ -60,12 +64,10 @@ public LocationIndex create(long byteCount) {
 
     @Override
     public void flush() {
-
     }
 
     @Override
     public void close() {
-
     }
 
     @Override
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java
new file mode 100644
index 0000000000..d2dc2c6719
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHLocation.java
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class GHLocation {
+
+    private static final Pattern PATTERN = Pattern.compile("^Stop\\((.*)\\)$");
+
+    public static GHLocation fromString(String s) {
+        final Matcher matcher = PATTERN.matcher(s);
+        if (matcher.find()) {
+            return new GHStationLocation(matcher.group(1));
+        } else {
+            return new GHPointLocation(GHPoint.fromString(s));
+        }
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java
new file mode 100644
index 0000000000..ab64514de5
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHPointLocation.java
@@ -0,0 +1,34 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.shapes.GHPoint;
+
+public class GHPointLocation extends GHLocation {
+    public final GHPoint ghPoint;
+
+    public GHPointLocation(GHPoint ghPoint) {
+        this.ghPoint = ghPoint;
+    }
+
+    @Override
+    public String toString() {
+        return ghPoint.toString();
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java
new file mode 100644
index 0000000000..29d47a06c1
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GHStationLocation.java
@@ -0,0 +1,27 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+public class GHStationLocation extends GHLocation {
+    public final String stop_id;
+
+    public GHStationLocation(String ghPoint) {
+        this.stop_id = ghPoint;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 08d025ff91..978b5770d4 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -18,12 +18,10 @@
 
 package com.graphhopper.reader.gtfs;
 
-import com.google.common.collect.ArrayListMultimap;
-import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
@@ -31,76 +29,85 @@
 import java.time.Instant;
 import java.time.ZoneId;
 import java.time.temporal.ChronoUnit;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Spliterators;
+import java.util.*;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
-final class GraphExplorer {
+public final class GraphExplorer {
 
     private final EdgeExplorer edgeExplorer;
     private final PtFlagEncoder flagEncoder;
     private final GtfsStorage gtfsStorage;
     private final RealtimeFeed realtimeFeed;
     private final boolean reverse;
-    private final List<EdgeIteratorState> extraEdges = new ArrayList<>();
-    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
-    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
-    private final Graph graph;
     private final Weighting accessEgressWeighting;
     private final boolean walkOnly;
     private double walkSpeedKmH;
 
 
-    GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, double walkSpeedKmh) {
-        this.graph = graph;
+    public GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, boolean walkOnly, double walkSpeedKmh) {
         this.accessEgressWeighting = accessEgressWeighting;
-        this.edgeExplorer = graph.createEdgeExplorer(reverse ? DefaultEdgeFilter.inEdges(flagEncoder) : DefaultEdgeFilter.outEdges(flagEncoder));
+        DefaultEdgeFilter accessEgressIn = DefaultEdgeFilter.inEdges(accessEgressWeighting.getFlagEncoder());
+        DefaultEdgeFilter accessEgressOut = DefaultEdgeFilter.outEdges(accessEgressWeighting.getFlagEncoder());
+        DefaultEdgeFilter ptIn = DefaultEdgeFilter.inEdges(flagEncoder);
+        DefaultEdgeFilter ptOut = DefaultEdgeFilter.outEdges(flagEncoder);
+        EdgeFilter in = edgeState -> accessEgressIn.accept(edgeState) || ptIn.accept(edgeState);
+        EdgeFilter out = edgeState -> accessEgressOut.accept(edgeState) || ptOut.accept(edgeState);
+        this.edgeExplorer = graph.createEdgeExplorer(reverse ? in : out);
         this.flagEncoder = flagEncoder;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
         this.reverse = reverse;
-        this.extraEdges.addAll(extraEdges);
-        for (VirtualEdgeIteratorState extraEdge : extraEdges) {
-            if (extraEdge == null) {
-                throw new RuntimeException();
-            }
-            extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
-            extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalTraversalKey(), extraEdge.getEdge(), extraEdge.getAdjNode(), extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3)));
-        }
         this.walkOnly = walkOnly;
         this.walkSpeedKmH = walkSpeedKmh;
     }
 
     Stream<EdgeIteratorState> exploreEdgesAround(Label label) {
-        final List<VirtualEdgeIteratorState> extraEdges = reverse ? extraEdgesByDestination.get(label.adjNode) : extraEdgesBySource.get(label.adjNode);
-        return Stream.concat(
-                label.adjNode < graph.getNodes() ? mainEdgesAround(label) : Stream.empty(),
-                extraEdges.stream()).filter(new EdgeIteratorStatePredicate(label));
+        return allEdgesAround(label).filter(new EdgeIteratorStatePredicate(label));
     }
 
-    private Stream<EdgeIteratorState> mainEdgesAround(Label label) {
+    private Stream<EdgeIteratorState> allEdgesAround(Label label) {
         return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
             EdgeIterator edgeIterator = edgeExplorer.setBaseNode(label.adjNode);
 
             @Override
             public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
                 if (edgeIterator.next()) {
+                    GtfsStorage.EdgeType edgeType = edgeIterator.get(flagEncoder.getTypeEnc());
+
+                    // Optimization (around 20% in Swiss network):
+                    // Only use the (single) least-wait-time edge to enter the
+                    // time expanded network. Later departures are reached via
+                    // WAIT edges. Algorithmically not necessary, and does not
+                    // reduce total number of relaxed nodes, but takes stress
+                    // off the priority queue.
+                    if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
+                        action.accept(findEnterEdge()); // fully consumes edgeIterator
+                        return true;
+                    }
+
                     action.accept(edgeIterator);
                     return true;
                 }
                 return false;
             }
 
+            private EdgeIteratorState findEnterEdge() {
+                ArrayList<EdgeIteratorState> allEnterEdges = new ArrayList<>();
+                allEnterEdges.add(edgeIterator.detach(false));
+                while (edgeIterator.next()) {
+                    allEnterEdges.add(edgeIterator.detach(false));
+                }
+                return allEnterEdges.stream().min(Comparator.comparingLong(e -> calcTravelTimeMillis(e, label.currentTime))).get();
+            }
 
         }, false);
     }
 
     long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
-        GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
+        GtfsStorage.EdgeType edgeType = edge.get(flagEncoder.getTypeEnc());
         switch (edgeType) {
             case HIGHWAY:
                 return (long) (accessEgressWeighting.calcMillis(edge, reverse, -1) * (5.0 / walkSpeedKmH));
@@ -117,7 +124,7 @@ long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
                     return 0;
                 }
             default:
-                return flagEncoder.getTime(edge.getFlags()) * 1000;
+                return edge.get(flagEncoder.getTimeEnc()) * 1000;
         }
     }
 
@@ -134,24 +141,24 @@ long getDelayFromAlightEdge(EdgeIteratorState edge, long currentTime) {
     }
 
     private long waitingTime(EdgeIteratorState edge, long earliestStartTime) {
-        long l = flagEncoder.getTime(edge.getFlags()) * 1000 - millisOnTravelDay(edge, earliestStartTime);
+        long l = edge.get(flagEncoder.getTimeEnc()) * 1000 - millisOnTravelDay(edge, earliestStartTime);
         if (!reverse) {
-            if (l < 0) l = l + 24*60*60*1000;
+            if (l < 0) l = l + 24 * 60 * 60 * 1000;
         } else {
-            if (l > 0) l = l - 24*60*60*1000;
+            if (l > 0) l = l - 24 * 60 * 60 * 1000;
         }
         return l;
     }
 
     private long millisOnTravelDay(EdgeIteratorState edge, long instant) {
-        final ZoneId zoneId = gtfsStorage.getTimeZones().get(flagEncoder.getValidityId(edge.getFlags())).zoneId;
+        final ZoneId zoneId = gtfsStorage.getTimeZones().get(edge.get(flagEncoder.getValidityIdEnc())).zoneId;
         return Instant.ofEpochMilli(instant).atZone(zoneId).toLocalTime().toNanoOfDay() / 1000000L;
     }
 
     private boolean isValidOn(EdgeIteratorState edge, long instant) {
-        GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
+        GtfsStorage.EdgeType edgeType = edge.get(flagEncoder.getTypeEnc());
         if (edgeType == GtfsStorage.EdgeType.BOARD || edgeType == GtfsStorage.EdgeType.ALIGHT) {
-            final int validityId = flagEncoder.getValidityId(edge.getFlags());
+            final int validityId = edge.get(flagEncoder.getValidityIdEnc());
             final GtfsStorage.Validity validity = realtimeFeed.getValidity(validityId);
             final int trafficDay = (int) ChronoUnit.DAYS.between(validity.start, Instant.ofEpochMilli(instant).atZone(validity.zoneId).toLocalDate());
             return trafficDay >= 0 && validity.validity.get(trafficDay);
@@ -161,34 +168,7 @@ private boolean isValidOn(EdgeIteratorState edge, long instant) {
     }
 
     int calcNTransfers(EdgeIteratorState edge) {
-        return flagEncoder.getTransfers(edge.getFlags());
-    }
-
-    EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
-        if (edgeId == -1) {
-            throw new RuntimeException();
-        }
-        for (EdgeIteratorState extraEdge : extraEdges) {
-            if (extraEdge.getEdge() == edgeId) {
-                if (extraEdge.getAdjNode() != adjNode) {
-                    throw new IllegalStateException();
-                }
-                return extraEdge;
-            }
-        }
-        EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, adjNode);
-        if (edge.getAdjNode() != adjNode) {
-            throw new IllegalStateException();
-        }
-        return edge;
-    }
-
-    NodeAccess getNodeAccess() {
-        return graph.getNodeAccess();
-    }
-
-    public Graph getGraph() {
-        return graph;
+        return edge.get(flagEncoder.getTransfersEnc());
     }
 
     private class EdgeIteratorStatePredicate implements Predicate<EdgeIteratorState> {
@@ -202,12 +182,12 @@ public Graph getGraph() {
 
         @Override
         public boolean test(EdgeIteratorState edgeIterator) {
-            final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
+            final GtfsStorage.EdgeType edgeType = edgeIterator.get(flagEncoder.getTypeEnc());
             if (edgeType == GtfsStorage.EdgeType.HIGHWAY) {
                 if (reverse) {
-                    return accessEgressWeighting.getFlagEncoder().isBackward(edgeIterator.getFlags());
+                    return edgeIterator.getReverse(accessEgressWeighting.getFlagEncoder().getAccessEnc());
                 } else {
-                    return accessEgressWeighting.getFlagEncoder().isForward(edgeIterator.getFlags());
+                    return edgeIterator.get(accessEgressWeighting.getFlagEncoder().getAccessEnc());
                 }
             }
             if (walkOnly && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index 294a4244a3..df65883599 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -20,8 +20,12 @@
 
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Transfer;
+import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.google.transit.realtime.GtfsRealtime;
-import com.graphhopper.*;
+import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.Trip;
+import com.graphhopper.http.WebHelper;
 import com.graphhopper.reader.osm.OSMReader;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
@@ -39,6 +43,9 @@
 import com.graphhopper.util.exceptions.PointNotFoundException;
 import com.graphhopper.util.shapes.GHPoint;
 
+import javax.inject.Inject;
+import javax.ws.rs.*;
+import javax.ws.rs.core.MediaType;
 import java.io.File;
 import java.io.IOException;
 import java.time.Instant;
@@ -48,9 +55,8 @@
 import java.util.stream.Stream;
 import java.util.zip.ZipFile;
 
-import static com.graphhopper.util.Parameters.PT.PROFILE_QUERY;
-
-public final class GraphHopperGtfs implements GraphHopperAPI {
+@Path("route")
+public final class GraphHopperGtfs {
 
     public static class Factory {
         private final TranslationMap translationMap;
@@ -67,7 +73,7 @@ private Factory(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphH
             this.gtfsStorage = gtfsStorage;
         }
 
-        public GraphHopperGtfs createWith(GtfsRealtime.FeedMessage realtimeFeed, String agencyId) {
+        public GraphHopperGtfs createWith(GtfsRealtime.FeedMessage realtimeFeed) {
             Map<String, GtfsRealtime.FeedMessage> realtimeFeeds = new HashMap<>();
             realtimeFeeds.put("gtfs_0", realtimeFeed);
             return new GraphHopperGtfs(flagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.fromProtobuf(graphHopperStorage, gtfsStorage, flagEncoder, realtimeFeeds));
@@ -103,8 +109,8 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final double walkSpeedKmH;
         private final double maxWalkDistancePerLeg;
         private final int blockedRouteTypes;
-        private final GHPoint enter;
-        private final GHPoint exit;
+        private final GHLocation enter;
+        private final GHLocation exit;
         private final Translation translation;
         private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>(realtimeFeed.getAdditionalEdges());
 
@@ -114,43 +120,58 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private GraphExplorer graphExplorer;
         private int visitedNodes;
 
-        RequestHandler(GHRequest request) {
-            maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, 1_000_000);
-            profileQuery = request.getHints().getBool(PROFILE_QUERY, false);
-            ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, profileQuery);
-            betaTransfers = request.getHints().getDouble("beta_transfers", 0.0);
-            betaWalkTime = request.getHints().getDouble("beta_walk_time", 1.0);
-            limitSolutions = request.getHints().getInt(Parameters.PT.LIMIT_SOLUTIONS, profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
-            final String departureTimeString = request.getHints().get(Parameters.PT.EARLIEST_DEPARTURE_TIME, "");
-            try {
-                initialTime = Instant.parse(departureTimeString);
-            } catch (DateTimeParseException e) {
-                throw new IllegalArgumentException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
-            }
-            arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
-            walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
-            blockedRouteTypes = request.getHints().getInt(Parameters.PT.BLOCKED_ROUTE_TYPES, 0);
+        RequestHandler(Request request) {
+            maxVisitedNodesForRequest = request.getMaxVisitedNodes();
+            profileQuery = request.isProfileQuery();
+            ignoreTransfers = Optional.ofNullable(request.getIgnoreTransfers()).orElse(request.isProfileQuery());
+            betaTransfers = request.getBetaTransfers();
+            betaWalkTime = request.getBetaWalkTime();
+            limitSolutions = Optional.ofNullable(request.getLimitSolutions()).orElse(profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
+            initialTime = request.getEarliestDepartureTime();
+            arriveBy = request.isArriveBy();
+            walkSpeedKmH = request.getWalkSpeedKmH();
+            blockedRouteTypes = request.getBlockedRouteTypes();
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
                 throw new IllegalArgumentException("Exactly 2 points have to be specified, but was:" + request.getPoints().size());
             }
             enter = request.getPoints().get(0);
             exit = request.getPoints().get(1);
-            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, Integer.MAX_VALUE);
+            maxWalkDistancePerLeg = request.getMaxWalkDistancePerLeg();
         }
 
         GHResponse route() {
             StopWatch stopWatch = new StopWatch().start();
-
+            ArrayList<QueryResult> pointQueryResults = new ArrayList<>();
             ArrayList<QueryResult> allQueryResults = new ArrayList<>();
-
-            QueryResult source = findClosest(enter, 0);
-            QueryResult dest = findClosest(exit, 1);
-            allQueryResults.add(source);
-            allQueryResults.add(dest);
-            queryGraph.lookup(Arrays.asList(source, dest)); // modifies queryGraph, source and dest!
-
-            PointList startAndEndpoint = pointListFrom(Arrays.asList(source, dest));
+            PointList points = new PointList(2, false);
+            if (enter instanceof GHPointLocation) {
+                final QueryResult closest = findClosest(((GHPointLocation) enter).ghPoint, 0);
+                pointQueryResults.add(closest);
+                allQueryResults.add(closest);
+                points.add(closest.getSnappedPoint());
+            } else if (enter instanceof GHStationLocation) {
+                final String stop_id = ((GHStationLocation) enter).stop_id;
+                final int node = gtfsStorage.getStationNodes().get(stop_id);
+                final QueryResult station = new QueryResult(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+                station.setClosestNode(node);
+                allQueryResults.add(station);
+                points.add(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+            }
+            if (exit instanceof GHPointLocation) {
+                final QueryResult closest = findClosest(((GHPointLocation) exit).ghPoint, 1);
+                pointQueryResults.add(closest);
+                allQueryResults.add(closest);
+                points.add(closest.getSnappedPoint());
+            } else if (exit instanceof GHStationLocation) {
+                final String stop_id = ((GHStationLocation) exit).stop_id;
+                final int node = gtfsStorage.getStationNodes().get(stop_id);
+                final QueryResult station = new QueryResult(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+                station.setClosestNode(node);
+                allQueryResults.add(station);
+                points.add(graphHopperStorage.getNodeAccess().getLat(node), graphHopperStorage.getNodeAccess().getLon(node));
+            }
+            queryGraph.lookup(pointQueryResults); // modifies queryGraph and queryResults!
             response.addDebugInfo("idLookup:" + stopWatch.stop().getSeconds() + "s");
 
             int startNode;
@@ -163,7 +184,7 @@ GHResponse route() {
                 destNode = allQueryResults.get(1).getClosestNode();
             }
             List<List<Label.Transition>> solutions = findPaths(startNode, destNode);
-            parseSolutionsAndAddToResponse(solutions, startAndEndpoint);
+            parseSolutionsAndAddToResponse(solutions, points);
             return response;
         }
 
@@ -173,18 +194,18 @@ private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
             if (!source.isValid()) {
                 throw new PointNotFoundException("Cannot find point: " + point, indexForErrorMessage);
             }
-            if (flagEncoder.getEdgeType(source.getClosestEdge().getFlags()) != GtfsStorage.EdgeType.HIGHWAY) {
-                throw new RuntimeException(flagEncoder.getEdgeType(source.getClosestEdge().getFlags()).name());
+            if (source.getClosestEdge().get(flagEncoder.getTypeEnc()) != GtfsStorage.EdgeType.HIGHWAY) {
+                throw new RuntimeException(source.getClosestEdge().get(flagEncoder.getTypeEnc()).name());
             }
             return source;
         }
 
         private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutions, PointList waypoints) {
             for (List<Label.Transition> solution : solutions) {
-                final List<Trip.Leg> legs = tripFromLabel.getTrip(translation, graphExplorer, accessEgressWeighting, solution);
+                final List<Trip.Leg> legs = tripFromLabel.getTrip(translation, queryGraph, accessEgressWeighting, solution);
                 final PathWrapper pathWrapper = tripFromLabel.createPathWrapper(translation, waypoints, legs);
                 pathWrapper.setImpossible(solution.stream().anyMatch(t -> t.label.impossible));
-                pathWrapper.setTime((solution.get(solution.size()-1).label.currentTime - solution.get(0).label.currentTime));
+                pathWrapper.setTime((solution.get(solution.size() - 1).label.currentTime - solution.get(0).label.currentTime));
                 response.add(pathWrapper);
             }
             Comparator<PathWrapper> c = Comparator.comparingInt(p -> (p.isImpossible() ? 1 : 0));
@@ -194,7 +215,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
 
         private List<List<Label.Transition>> findPaths(int startNode, int destNode) {
             StopWatch stopWatch = new StopWatch().start();
-            final GraphExplorer accessEgressGraphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, !arriveBy, extraEdges, true, walkSpeedKmH);
+            final GraphExplorer accessEgressGraphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, !arriveBy, true, walkSpeedKmH);
             boolean reverse = !arriveBy;
             GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
             MultiCriteriaLabelSetting stationRouter = new MultiCriteriaLabelSetting(accessEgressGraphExplorer, flagEncoder, reverse, maxWalkDistancePerLeg, false, false, false, maxVisitedNodesForRequest, new ArrayList<>());
@@ -206,7 +227,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                 if (label.adjNode == startNode) {
                     stationLabels.add(label);
                     break;
-                } else if (label.edge != -1 && flagEncoder.getEdgeType(accessEgressGraphExplorer.getEdgeIteratorState(label.edge, label.parent.adjNode).getFlags()) == edgeType) {
+                } else if (label.edge != -1 && queryGraph.getEdgeIteratorState(label.edge, label.parent.adjNode).get(flagEncoder.getTypeEnc()) == edgeType) {
                     stationLabels.add(label);
                 }
             }
@@ -217,7 +238,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                 reverseSettledSet.put(stationLabel.adjNode, stationLabel);
             }
 
-            graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false, walkSpeedKmH);
+            graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, false, walkSpeedKmH);
             List<Label> discoveredSolutions = new ArrayList<>();
             final long smallestStationLabelWeight;
             MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, arriveBy, maxWalkDistancePerLeg, true, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest, discoveredSolutions);
@@ -235,7 +256,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
             while (iterator.hasNext()) {
                 Label label = iterator.next();
                 final long weight = router.weight(label);
-                if ( (!profileQuery || discoveredSolutions.size() >= limitSolutions) && weight + smallestStationLabelWeight > highestWeightForDominationTest) {
+                if ((!profileQuery || discoveredSolutions.size() >= limitSolutions) && weight + smallestStationLabelWeight > highestWeightForDominationTest) {
                     break;
                 }
                 Label reverseLabel = reverseSettledSet.get(label.adjNode);
@@ -247,7 +268,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                             discoveredSolutions.add(combinedSolution);
                             originalSolutions.put(combinedSolution, label);
                             if (profileQuery) {
-                                highestWeightForDominationTest = router.weight(discoveredSolutions.get(discoveredSolutions.size()-1));
+                                highestWeightForDominationTest = router.weight(discoveredSolutions.get(discoveredSolutions.size() - 1));
                             } else {
                                 highestWeightForDominationTest = discoveredSolutions.stream().filter(s -> !s.impossible && (ignoreTransfers || s.nTransfers <= 1)).mapToLong(router::weight).min().orElse(Long.MAX_VALUE);
                             }
@@ -258,12 +279,12 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
 
             List<List<Label.Transition>> pathsToStations = discoveredSolutions.stream()
                     .map(originalSolutions::get)
-                    .map(l -> new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(arriveBy, flagEncoder, graphExplorer, l)).collect(Collectors.toList());
+                    .map(l -> tripFromLabel.getTransitions(arriveBy, flagEncoder, queryGraph, l)).collect(Collectors.toList());
 
             List<List<Label.Transition>> paths = pathsToStations.stream().map(p -> {
                 if (arriveBy) {
                     List<Label.Transition> pp = new ArrayList<>(p.subList(1, p.size()));
-                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(0).label.adjNode));
+                    List<Label.Transition> pathFromStation = pathFromStation(reverseSettledSet.get(p.get(0).label.adjNode));
                     long diff = p.get(0).label.currentTime - pathFromStation.get(pathFromStation.size() - 1).label.currentTime;
                     List<Label.Transition> patchedPathFromStation = pathFromStation.stream().map(t -> {
                         return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
@@ -272,7 +293,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
                     return pp;
                 } else {
                     List<Label.Transition> pp = new ArrayList<>(p);
-                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(p.size() - 1).label.adjNode));
+                    List<Label.Transition> pathFromStation = pathFromStation(reverseSettledSet.get(p.get(p.size() - 1).label.adjNode));
                     long diff = p.get(p.size() - 1).label.currentTime - pathFromStation.get(0).label.currentTime;
                     List<Label.Transition> patchedPathFromStation = pathFromStation.subList(1, pathFromStation.size()).stream().map(t -> {
                         return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
@@ -285,7 +306,7 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
             visitedNodes += router.getVisitedNodes();
             response.addDebugInfo("routing:" + stopWatch.stop().getSeconds() + "s");
             if (discoveredSolutions.isEmpty() && router.getVisitedNodes() >= maxVisitedNodesForRequest) {
-                throw new IllegalArgumentException("No path found - maximum number of nodes exceeded: " + maxVisitedNodesForRequest);
+                response.addError(new IllegalArgumentException("No path found - maximum number of nodes exceeded: " + maxVisitedNodesForRequest));
             }
             response.getHints().put("visited_nodes.sum", visitedNodes);
             response.getHints().put("visited_nodes.average", visitedNodes);
@@ -295,11 +316,12 @@ private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutio
             return paths;
         }
 
-        private List<Label.Transition> pathFromStation(GraphExplorer accessEgressGraphExplorer, Label l) {
-            return new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(!arriveBy, flagEncoder, accessEgressGraphExplorer, l);
+        private List<Label.Transition> pathFromStation(Label l) {
+            return tripFromLabel.getTransitions(!arriveBy, flagEncoder, queryGraph, l);
         }
     }
 
+    @Inject
     public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphHopperStorage graphHopperStorage, LocationIndex locationIndex, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed) {
         this.flagEncoder = flagEncoder;
         this.accessEgressWeighting = new FastestWeighting(graphHopperStorage.getEncodingManager().getEncoder("foot"));
@@ -339,7 +361,7 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                     throw new RuntimeException(e);
                 }
             }
-            new PrepareRoutingSubnetworks(graphHopperStorage, Collections.singletonList(ptFlagEncoder)).doWork();
+            new PrepareRoutingSubnetworks(graphHopperStorage, Collections.singletonList(encodingManager.getEncoder("foot"))).doWork();
 
             int id = 0;
             for (String gtfsFile : gtfsFiles) {
@@ -366,7 +388,11 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                             t.transfer.min_transfer_time = (int) (t.time / 1000L);
                             gtfsFeed.transfers.put(t.id, t.transfer);
                         });
-                gtfsReader.readGraph();
+                try {
+                    gtfsReader.buildPtNetwork();
+                } catch (Exception e) {
+                    throw new RuntimeException("Error while constructing transit network. Is your GTFS file valid? Please check log for possible causes.", e);
+                }
             }
             graphHopperStorage.flush();
             return graphHopperStorage;
@@ -384,12 +410,36 @@ public static LocationIndex createOrLoadIndex(GHDirectory directory, GraphHopper
         return locationIndex;
     }
 
-    public boolean load(String graphHopperFolder) {
-        throw new IllegalStateException("We are always loaded, or we wouldn't exist.");
+    @GET
+    @Produces(MediaType.APPLICATION_JSON)
+    public ObjectNode route(@QueryParam("point") List<GHLocation> requestPoints,
+                            @QueryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME) String departureTimeString,
+                            @QueryParam("locale") String localeStr,
+                            @QueryParam(Parameters.PT.IGNORE_TRANSFERS) Boolean ignoreTransfers,
+                            @QueryParam(Parameters.PT.PROFILE_QUERY) Boolean profileQuery,
+                            @QueryParam(Parameters.PT.LIMIT_SOLUTIONS) Integer limitSolutions) {
+
+        if (departureTimeString == null) {
+            throw new BadRequestException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+        }
+        Instant departureTime;
+        try {
+            departureTime = Instant.parse(departureTimeString);
+        } catch (DateTimeParseException e) {
+            throw new BadRequestException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+        }
+
+        Request request = new Request(requestPoints, departureTime);
+        Optional.ofNullable(profileQuery).ifPresent(request::setProfileQuery);
+        Optional.ofNullable(ignoreTransfers).ifPresent(request::setIgnoreTransfers);
+        Optional.ofNullable(localeStr).ifPresent(s -> request.setLocale(Helper.getLocale(s)));
+        Optional.ofNullable(limitSolutions).ifPresent(request::setLimitSolutions);
+
+        GHResponse route = new RequestHandler(request).route();
+        return WebHelper.jsonObject(route, true, true, false, false, 0.0f);
     }
 
-    @Override
-    public GHResponse route(GHRequest request) {
+    public GHResponse route(Request request) {
         return new RequestHandler(request).route();
     }
 
@@ -417,27 +467,27 @@ public GHResponse route(GHRequest request) {
 
                     QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
                     queryGraph.lookup(Collections.emptyList());
-                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, Collections.emptyList(), true, 5.0);
+                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, true, 5.0);
 
                     MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, false, Double.MAX_VALUE, false, false, false, Integer.MAX_VALUE, new ArrayList<>());
-                    final Stream<Label> labels = router.calcLabels(fromnode, tonode, Instant.ofEpochMilli(0), 0);
-                    List<Label> solutions = labels
-                            .filter(current -> tonode == current.adjNode)
-                            .collect(Collectors.toList());
+                    Iterator<Label> iterator = router.calcLabels(fromnode, tonode, Instant.ofEpochMilli(0), 0).iterator();
+                    Label solution = null;
+                    while (iterator.hasNext()) {
+                        Label label = iterator.next();
+                        if (tonode == label.adjNode) {
+                            solution = label;
+                            break;
+                        }
+                    }
+                    if (solution == null) {
+                        throw new RuntimeException("Can't find a transfer walk route.");
+                    }
                     TransferWithTime transferWithTime = new TransferWithTime();
                     transferWithTime.id = e.getKey();
                     transferWithTime.transfer = e.getValue();
-                    transferWithTime.time = solutions.get(0).currentTime;
+                    transferWithTime.time = solution.currentTime;
                     return transferWithTime;
                 });
     }
 
-    private PointList pointListFrom(List<QueryResult> queryResults) {
-        PointList waypoints = new PointList(queryResults.size(), true);
-        for (QueryResult qr : queryResults) {
-            waypoints.add(qr.getSnappedPoint());
-        }
-        return waypoints;
-    }
-
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java
index 2bd8f8ce60..ad73a38a63 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphSupport.java
@@ -18,13 +18,13 @@
 
 package com.graphhopper.reader.gtfs;
 
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.IntEncodedValue;
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphExtension;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.*;
 import com.graphhopper.util.EdgeExplorer;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
@@ -32,17 +32,18 @@
 
 class GraphSupport {
 
-    private GraphSupport() {}
+    private GraphSupport() {
+    }
 
 
     /**
      * Creates a read-only view of a Graph, presenting the sub-graph consisting of all the nodes; and those
      * edges accepted by edgeFilter.
-     *
+     * <p>
      * Devised to pass into LocationIndexTree, and works fine there (because LocationIndexTree doesn't index nodes
      * directly, but only goes through the edges). Probably not useful in other contexts.
      *
-     * @param baseGraph The graph to construct a view for.
+     * @param baseGraph  The graph to construct a view for.
      * @param edgeFilter The filter to filter with.
      * @return The filtered view.
      */
@@ -58,6 +59,11 @@ public int getNodes() {
                 return baseGraph.getNodes();
             }
 
+            @Override
+            public int getEdges() {
+                return baseGraph.getEdges();
+            }
+
             @Override
             public NodeAccess getNodeAccess() {
                 return baseGraph.getNodeAccess();
@@ -107,6 +113,16 @@ public int getEdge() {
                         return edge.getEdge();
                     }
 
+                    @Override
+                    public int getOrigEdgeFirst() {
+                        return getEdge();
+                    }
+
+                    @Override
+                    public int getOrigEdgeLast() {
+                        return getEdge();
+                    }
+
                     @Override
                     public int getBaseNode() {
                         return edge.getBaseNode();
@@ -140,12 +156,12 @@ public EdgeIteratorState setDistance(double dist) {
                     }
 
                     @Override
-                    public long getFlags() {
+                    public IntsRef getFlags() {
                         return edge.getFlags();
                     }
 
                     @Override
-                    public EdgeIteratorState setFlags(long flags) {
+                    public EdgeIteratorState setFlags(IntsRef flags) {
                         edge.setFlags(flags);
                         return this;
                     }
@@ -162,38 +178,111 @@ public EdgeIteratorState setAdditionalField(int value) {
                     }
 
                     @Override
-                    public boolean isForward(FlagEncoder encoder) {
-                        return edge.isForward(encoder);
+                    public String getName() {
+                        return edge.getName();
                     }
 
                     @Override
-                    public boolean isBackward(FlagEncoder encoder) {
-                        return edge.isBackward(encoder);
+                    public EdgeIteratorState setName(String name) {
+                        edge.setName(name);
+                        return this;
                     }
 
                     @Override
-                    public boolean getBool(int key, boolean _default) {
-                        return edge.getBool(key, _default);
+                    public EdgeIteratorState detach(boolean reverse) {
+                        return edge.detach(reverse);
                     }
 
                     @Override
-                    public String getName() {
-                        return edge.getName();
+                    public boolean get(BooleanEncodedValue property) {
+                        return edge.get(property);
                     }
 
                     @Override
-                    public EdgeIteratorState setName(String name) {
-                        edge.setName(name);
+                    public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
+                        edge.set(property, value);
                         return this;
                     }
 
                     @Override
-                    public EdgeIteratorState detach(boolean reverse) {
-                        return edge.detach(reverse);
+                    public boolean getReverse(BooleanEncodedValue property) {
+                        return edge.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+                        edge.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public int get(IntEncodedValue property) {
+                        return edge.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(IntEncodedValue property, int value) {
+                        edge.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public int getReverse(IntEncodedValue property) {
+                        return edge.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+                        edge.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public double get(DecimalEncodedValue property) {
+                        return edge.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+                        edge.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public double getReverse(DecimalEncodedValue property) {
+                        return edge.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+                        edge.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public <T extends Enum> T get(EnumEncodedValue<T> property) {
+                        return edge.get(property);
                     }
 
                     @Override
-                    public EdgeIteratorState copyPropertiesTo(EdgeIteratorState e) {
+                    public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+                        edge.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+                        return edge.getReverse(property);
+                    }
+
+                    @Override
+                    public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
+                        edge.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e) {
                         throw new UnsupportedOperationException();
                     }
                 };
@@ -218,6 +307,16 @@ public Graph copyTo(Graph g) {
             public GraphExtension getExtension() {
                 throw new UnsupportedOperationException();
             }
+
+            @Override
+            public int getOtherNode(int edge, int node) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean isAdjacentToNode(int edge, int node) {
+                throw new UnsupportedOperationException();
+            }
         };
     }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
index bee02ff8eb..68e43af17d 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsHelper.java
@@ -19,6 +19,7 @@
 
 import java.text.SimpleDateFormat;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.util.Date;
 import java.util.Locale;
 
@@ -47,7 +48,11 @@ public static int time(int hours, int minutes) {
     }
     
     public static int time(LocalDateTime localDateTime) {
-        return time(localDateTime.getHour(), localDateTime.getMinute(), 0);
+        return time(localDateTime.getHour(), localDateTime.getMinute(), localDateTime.getSecond());
+    }
+
+    public static int time(LocalTime localTime) {
+        return time(localTime.getHour(), localTime.getMinute(), localTime.getSecond());
     }
 
     public static LocalDateTime localDateTimeFromDate(Date date) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index bf0290d28e..04ce0bf650 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -20,16 +20,11 @@
 
 import com.carrotsearch.hppc.IntArrayList;
 import com.conveyal.gtfs.GTFSFeed;
-import com.conveyal.gtfs.model.Frequency;
-import com.conveyal.gtfs.model.Route;
-import com.conveyal.gtfs.model.Service;
-import com.conveyal.gtfs.model.Stop;
-import com.conveyal.gtfs.model.StopTime;
-import com.conveyal.gtfs.model.Transfer;
-import com.conveyal.gtfs.model.Trip;
+import com.conveyal.gtfs.model.*;
 import com.google.common.collect.HashMultimap;
-import com.google.common.collect.SetMultimap;
 import com.google.transit.realtime.GtfsRealtime;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.IntEncodedValue;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -42,32 +37,14 @@
 import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.Helper;
-import gnu.trove.map.hash.TIntIntHashMap;
 import org.mapdb.Fun;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.time.LocalDate;
 import java.time.ZoneId;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.ListIterator;
-import java.util.Map;
-import java.util.NavigableSet;
-import java.util.Optional;
-import java.util.Set;
-import java.util.SortedSet;
-import java.util.Spliterators;
-import java.util.TreeSet;
-import java.util.function.Consumer;
+import java.util.*;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
 
 import static com.conveyal.gtfs.model.Entity.Writer.convertToGtfsTime;
 import static java.time.temporal.ChronoUnit.DAYS;
@@ -78,7 +55,7 @@
     private LocalDate endDate;
 
     static class TripWithStopTimes {
-        public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay, Set<Integer> cancelledArrivals, Set<Integer> cancelledDepartures) {
+        TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay, Set<Integer> cancelledArrivals, Set<Integer> cancelledDepartures) {
             this.trip = trip;
             this.stopTimes = stopTimes;
             this.validOnDay = validOnDay;
@@ -93,18 +70,6 @@ public TripWithStopTimes(Trip trip, List<StopTime> stopTimes, BitSet validOnDay,
         Set<Integer> cancelledDeparture;
     }
 
-    private static class TimelineNodeIdWithTripId {
-        final String tripId;
-        final String routeId;
-        final int timelineNodeId;
-
-        private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String routeId) {
-            this.tripId = tripId;
-            this.routeId = routeId;
-            this.timelineNodeId = timelineNodeId;
-        }
-    }
-
     private static final Logger LOGGER = LoggerFactory.getLogger(GtfsReader.class);
 
     private final Graph graph;
@@ -117,10 +82,12 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String route
     private final String id;
     private int i;
     private GTFSFeed feed;
-    private final TIntIntHashMap times = new TIntIntHashMap();
-    private final SetMultimap<String, TimelineNodeIdWithTripId> departureTimelineNodes = HashMultimap.create();
-    private final SetMultimap<String, TimelineNodeIdWithTripId> arrivalTimelineNodes = HashMultimap.create();
+    private final Map<String, Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>>> departureTimelinesByStop = new HashMap<>();
+    private final Map<String, Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>>> arrivalTimelinesByStop = new HashMap<>();
     private final PtFlagEncoder encoder;
+    private final BooleanEncodedValue accessEnc;
+    private final IntEncodedValue timeEnc;
+    private final IntEncodedValue validityIdEnc;
 
     GtfsReader(String id, Graph graph, GtfsStorageI gtfsStorage, PtFlagEncoder encoder, LocationIndex walkNetworkIndex) {
         this.id = id;
@@ -129,47 +96,57 @@ private TimelineNodeIdWithTripId(int timelineNodeId, String tripId, String route
         this.nodeAccess = graph.getNodeAccess();
         this.walkNetworkIndex = walkNetworkIndex;
         this.encoder = encoder;
+        this.accessEnc = encoder.getAccessEnc();
+        this.timeEnc = encoder.getTimeEnc();
+        this.validityIdEnc = encoder.getValidityIdEnc();
         this.feed = this.gtfsStorage.getGtfsFeeds().get(id);
         this.transfers = this.gtfsStorage.getTransfers().get(id);
         this.i = graph.getNodes();
-        this.startDate = feed.calculateStats().getStartDate();
-        this.endDate = feed.calculateStats().getEndDate();
-    }
-
-    void readGraph() {
-        gtfsStorage.getFares().putAll(feed.fares);
-        transfers = new Transfers(feed);
-        gtfsStorage.getTransfers().put(id, transfers);
-        buildPtNetwork();
+        this.startDate = feed.getStartDate();
+        this.endDate = feed.getEndDate();
     }
 
     void connectStopsToStreetNetwork() {
         FlagEncoder footEncoder = ((GraphHopperStorage) graph).getEncodingManager().getEncoder("foot");
         final EdgeFilter filter = DefaultEdgeFilter.allEdges(footEncoder);
         for (Stop stop : feed.stops.values()) {
-            QueryResult locationQueryResult = walkNetworkIndex.findClosest(stop.stop_lat, stop.stop_lon, filter);
-            int streetNode;
-            if (!locationQueryResult.isValid()) {
-                streetNode = i++;
-                nodeAccess.setNode(streetNode, stop.stop_lat, stop.stop_lon);
-                EdgeIteratorState edge = graph.edge(streetNode, streetNode);
-                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                edge.setFlags(footEncoder.setAccess(edge.getFlags(), true, false));
-                edge.setFlags(footEncoder.setSpeed(edge.getFlags(), 5.0));
-            } else {
-                streetNode = locationQueryResult.getClosestNode();
+            if (stop.location_type == 0) { // Only stops. Not interested in parent stations for now.
+                QueryResult locationQueryResult = walkNetworkIndex.findClosest(stop.stop_lat, stop.stop_lon, filter);
+                int streetNode;
+                if (!locationQueryResult.isValid()) {
+                    streetNode = i++;
+                    nodeAccess.setNode(streetNode, stop.stop_lat, stop.stop_lon);
+                    EdgeIteratorState edge = graph.edge(streetNode, streetNode);
+                    edge.set(accessEnc, true).setReverse(accessEnc, false);
+                    edge.set(footEncoder.getAccessEnc(), true).setReverse(footEncoder.getAccessEnc(), false);
+                    edge.set(footEncoder.getAverageSpeedEnc(), 5.0);
+                } else {
+                    streetNode = locationQueryResult.getClosestNode();
+                }
+                Integer prev = gtfsStorage.getStationNodes().put(stop.stop_id, streetNode);
+                if (prev != null) {
+                    throw new RuntimeException("Duplicate stop id: "+stop.stop_id);
+                }
             }
-            gtfsStorage.getStationNodes().put(stop.stop_id, streetNode);
         }
     }
 
-    private void buildPtNetwork() {
+    void buildPtNetwork() {
+        gtfsStorage.getFares().putAll(feed.fares);
+        transfers = new Transfers(feed);
+        gtfsStorage.getTransfers().put(id, transfers);
+        createTrips();
+        wireUpStops();
+        insertTransfers();
+    }
+
+    private void createTrips() {
         HashMultimap<String, Trip> blockTrips = HashMultimap.create();
         for (Trip trip : feed.trips.values()) {
             if (trip.block_id != null) {
                 blockTrips.put(trip.block_id, trip);
             } else {
-                blockTrips.put("non-block-trip"+trip.trip_id, trip);
+                blockTrips.put("non-block-trip" + trip.trip_id, trip);
             }
         }
         blockTrips.asMap().values().forEach(unsortedTrips -> {
@@ -183,7 +160,7 @@ private void buildPtNetwork() {
                             }
                         }
                         ArrayList<StopTime> stopTimes = new ArrayList<>();
-                        getInterpolatedStopTimesForTrip(trip.trip_id).forEach(stopTimes::add);
+                        feed.getInterpolatedStopTimesForTrip(trip.trip_id).forEach(stopTimes::add);
                         return new TripWithStopTimes(trip, stopTimes, validOnDay, Collections.emptySet(), Collections.emptySet());
                     })
                     .sorted(Comparator.comparingInt(trip -> trip.stopTimes.iterator().next().departure_time))
@@ -203,219 +180,51 @@ private void buildPtNetwork() {
                 }
             }
         });
-
-        wireUpStops();
-    }
-
-    void wireUpStops() {
-        for (Stop stop : feed.stops.values()) {
-            if (stop.location_type == 0) { // Only stops. Not interested in parent stations for now.
-                int streetNode = gtfsStorage.getStationNodes().get(stop.stop_id);
-
-                if (arrivalTimelineNodes.containsKey(stop.stop_id)) {
-                    final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
-
-                    arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                        Route route = feed.routes.get(routeId);
-                        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                        int stopExitNode = i-1;
-                        nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
-
-                        EdgeIteratorState exitEdge = graph.edge(stopExitNode, streetNode);
-                        exitEdge.setFlags(encoder.setAccess(exitEdge.getFlags(), true, false));
-                        setEdgeTypeAndClearDistance(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
-                        exitEdge.setFlags(encoder.setValidityId(exitEdge.getFlags(), route.route_type));
-                        exitEdge.setName(stop.stop_name);
-                        gtfsStorage.getRoutes().put(exitEdge.getEdge(), routeId);
-
-                        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-                        wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
-                    });
-
-                }
-
-                if (departureTimelineNodes.containsKey(stop.stop_id)) {
-                    final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
-
-                    departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                        Route route = feed.routes.get(routeId);
-                        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                        int stopEnterNode = i-1;
-                        nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
-
-                        EdgeIteratorState entryEdge = graph.edge(streetNode, stopEnterNode);
-                        entryEdge.setFlags(encoder.setAccess(entryEdge.getFlags(), true, false));
-                        setEdgeTypeAndClearDistance(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
-                        entryEdge.setFlags(encoder.setValidityId(entryEdge.getFlags(), route.route_type));
-                        entryEdge.setName(stop.stop_name);
-                        gtfsStorage.getRoutes().put(entryEdge.getEdge(), routeId);
-
-                        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-                        wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
-                    });
-                }
-            }
-        }
-        insertTransfers();
     }
 
-    void wireUpAdditionalDepartures(ZoneId zoneId) {
-        for (Stop stop : feed.stops.values()) {
-            int stationNode = gtfsStorage.getStationNodes().get(stop.stop_id);
-            final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
-            departureTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                int platformNode = findPlatformEnterNode(stationNode, routeId);
-                if (platformNode != -1) {
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-                    Iterator<Fun.Tuple2<Integer, Integer>> realtimeTimelineIterator = timeNodes.iterator();
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> staticTimelineNodesForRoute = findDepartureTimelineNodesForRoute(stationNode, routeId).collect(Collectors.toCollection(TreeSet::new));
-                    realtimeTimelineIterator.forEachRemaining(timelineNode -> {
-                        SortedSet<Fun.Tuple2<Integer, Integer>> headSet = staticTimelineNodesForRoute.headSet(timelineNode);
-                        if(!headSet.isEmpty()) {
-                            Fun.Tuple2<Integer, Integer> before = headSet.last();
-                            EdgeIteratorState edge = graph.edge(before.b, timelineNode.b);
-                            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
-                            edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a-before.a));
-                        }
-                        SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = staticTimelineNodesForRoute.tailSet(timelineNode);
-                        if (!tailSet.isEmpty()) {
-                            Fun.Tuple2<Integer, Integer> after = tailSet.first();
-                            EdgeIteratorState edge = graph.edge(timelineNode.b, after.b);
-                            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
-                            edge.setFlags(encoder.setTime(edge.getFlags(), after.a-timelineNode.a));
-
-//                            System.out.println(" "+ after);
-//                            EdgeIterator ei = graph.getBaseGraph().createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder)).setBaseNode(after.b);
-//                            while(ei.next()) {
-//                                if (encoder.getEdgeType(ei.getFlags()) == GtfsStorage.EdgeType.TRANSFER) {
-//                                    System.out.println("   "+ei+"   @"+Long.toString(after.a-encoder.getTime(ei.getFlags())));
-//                                }
-//                            }
-
-                        }
-
-                        EdgeIteratorState edge = graph.edge(platformNode, timelineNode.b);
-                        edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                        setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
-                        edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
-                        setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
-                    });
-                } else {
-                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                    int stopEnterNode = i-1;
-                    nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
-                    EdgeIteratorState entryEdge = graph.edge(stationNode, stopEnterNode);
-                    entryEdge.setFlags(encoder.setAccess(entryEdge.getFlags(), true, false));
-                    setEdgeTypeAndClearDistance(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
-                    entryEdge.setName(stop.stop_name);
-                    NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-                    wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
-                }
-            });
-            final Map<String, List<TimelineNodeIdWithTripId>> arrivalTimelineNodesByRoute = arrivalTimelineNodes.get(stop.stop_id).stream().collect(Collectors.groupingBy(t -> t.routeId));
-            arrivalTimelineNodesByRoute.forEach((routeId, timelineNodesWithTripId) -> {
-                int platformNode = findPlatformExitNode(stationNode, routeId);
-                NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
-
-                if (platformNode != -1) {
-                    Iterator<Fun.Tuple2<Integer, Integer>> realtimeTimelineIterator = timeNodes.iterator();
-                    realtimeTimelineIterator.forEachRemaining(timelineNode -> {
-                        EdgeIteratorState edge = graph.edge(timelineNode.b, platformNode);
-                        edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                        setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
-                        edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
-                        setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
-                    });
-                } else {
-                    nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                    int stopExitNode = i-1;
-                    nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
-                    EdgeIteratorState exitEdge = graph.edge(stopExitNode, stationNode);
-                    exitEdge.setFlags(encoder.setAccess(exitEdge.getFlags(), true, false));
-                    setEdgeTypeAndClearDistance(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
-                    exitEdge.setName(stop.stop_name);
-                    wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
-                }
-                final Optional<Transfer> withinStationTransfer = transfers.getTransfersFromStop(stop.stop_id, routeId).stream().filter(t -> t.from_stop_id.equals(stop.stop_id)).findAny();
-                if (!withinStationTransfer.isPresent()) {
-                    insertOutboundTransfers(stop.stop_id, null, 0, timeNodes);
-                }
-                transfers.getTransfersFromStop(stop.stop_id, routeId).forEach(transfer -> {
-                    insertOutboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, timeNodes);
-                });
-            });
-        }
+    private void wireUpStops() {
+        arrivalTimelinesByStop.forEach((stopId, arrivalTimelines) -> {
+            int streetNode = gtfsStorage.getStationNodes().get(stopId);
+            Stop stop = feed.stops.get(stopId);
+            arrivalTimelines.forEach(((platformDescriptor, arrivalTimeline) ->
+                    wireUpArrivalTimeline(streetNode, stop, arrivalTimeline, routeType(platformDescriptor), platformDescriptor)));
+        });
+        departureTimelinesByStop.forEach((stopId, departureTimelines) -> {
+            int streetNode = gtfsStorage.getStationNodes().get(stopId);
+            Stop stop = feed.stops.get(stopId);
+            departureTimelines.forEach(((platformDescriptor, departureTimeline) ->
+                    wireUpDepartureTimeline(streetNode, stop, departureTimeline, routeType(platformDescriptor), platformDescriptor)));
+        });
     }
 
-    private Stream<Fun.Tuple2<Integer, Integer>> findDepartureTimelineNodesForRoute(int stationNode, String routeId) {
-        int node = findPlatformEnterNode(stationNode, routeId);
-        if (node == -1) {
-            return Stream.empty();
-        }
-        return StreamSupport.stream(new Spliterators.AbstractSpliterator<EdgeIteratorState>(0, 0) {
-            EdgeIterator edgeIterator = graph.getBaseGraph().createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder)).setBaseNode(node);
-            @Override
-            public boolean tryAdvance(Consumer<? super EdgeIteratorState> action) {
-                if (edgeIterator.next()) {
-                    action.accept(edgeIterator);
-                    return true;
-                } else {
-                    return false;
-                }
-            }
-        }, false)
-                .filter(edge -> encoder.getEdgeType(edge.getFlags()) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK)
-                .map(edge -> new Fun.Tuple2<>((int) encoder.getTime(edge.getFlags()), edge.getAdjNode()));
+    private void insertTransfers() {
+        departureTimelinesByStop.forEach((toStopId, departureTimelines) ->
+                departureTimelines.forEach(((platformDescriptor, departureTimeline) ->
+                        insertTransfers(toStopId, routeIdOrNull(platformDescriptor), departureTimeline))));
     }
 
-    private int findPlatformEnterNode(int stationNode, String routeId) {
-        EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder)).setBaseNode(stationNode);
-        while (i.next()) {
-            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
-            if (edgeType == GtfsStorage.EdgeType.ENTER_PT) {
-                if (routeId.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
-                    return i.getAdjNode();
-                }
-            }
-        }
-        return -1;
-    }
 
-    private int findPlatformExitNode(int stationNode, String routeId) {
-        EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder)).setBaseNode(stationNode);
-        while (i.next()) {
-            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
-            if (edgeType == GtfsStorage.EdgeType.EXIT_PT) {
-                if (routeId.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
-                    return i.getAdjNode();
-                }
-            }
+    private void insertTransfers(String toStopId, String toRouteId, NavigableMap<Integer, Integer> departureTimeline) {
+        final Optional<Transfer> withinStationTransfer = transfers.getTransfersToStop(toStopId, toRouteId).stream().filter(t -> t.from_stop_id.equals(toStopId)).findAny();
+        if (!withinStationTransfer.isPresent()) {
+            insertInboundTransfers(toStopId, null, 0, departureTimeline);
         }
-        return -1;
-    }
-
-    private NavigableSet<Fun.Tuple2<Integer, Integer>> sorted(List<TimelineNodeIdWithTripId> timelineNodesWithTripId) {
-        NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = new TreeSet<>();
-        timelineNodesWithTripId.stream().map(t -> t.timelineNodeId)
-                .forEach(nodeId -> timeNodes.add(new Fun.Tuple2<>(times.get(nodeId) % (24*60*60), nodeId)));
-        return timeNodes;
+        transfers.getTransfersToStop(toStopId, toRouteId).forEach(transfer ->
+                insertInboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, departureTimeline));
     }
 
-    void insertTransfers() {
-        departureTimelineNodes.asMap().forEach((toStopId, timelineNodesWithTripId) -> {
-            final Map<String, List<TimelineNodeIdWithTripId>> departureTimelineNodesByRoute = departureTimelineNodes.get(toStopId).stream().collect(Collectors.groupingBy(t -> t.routeId));
-            departureTimelineNodesByRoute.forEach((toRouteId, timelineNodesByRoute) -> {
-                NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesByRoute);
-                final Optional<Transfer> withinStationTransfer = transfers.getTransfersToStop(toStopId, toRouteId).stream().filter(t -> t.from_stop_id.equals(toStopId)).findAny();
-                if (!withinStationTransfer.isPresent()) {
-                    insertInboundTransfers(toStopId, null, 0, timeNodes);
-                }
-                transfers.getTransfersToStop(toStopId, toRouteId).forEach(transfer -> {
-                    insertInboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, timeNodes);
-                });
-            });
+    void wireUpAdditionalDeparturesAndArrivals(ZoneId zoneId) {
+        departureTimelinesByStop.forEach((stopId, departureTimelines) -> {
+            int stationNode = gtfsStorage.getStationNodes().get(stopId);
+            Stop stop = feed.stops.get(stopId);
+            departureTimelines.forEach(((platformDescriptor, timeline) ->
+                    wireUpOrPatchDepartureTimeline(zoneId, stationNode, stop, timeline, platformDescriptor)));
+        });
+        arrivalTimelinesByStop.forEach((stopId, arrivalTimelines) -> {
+            int stationNode = gtfsStorage.getStationNodes().get(stopId);
+            Stop stop = feed.stops.get(stopId);
+            arrivalTimelines.forEach(((platformDescriptor, timeline) ->
+                    wireUpOrPatchArrivalTimeline(zoneId, stationNode, stop, routeIdOrNull(platformDescriptor), timeline, platformDescriptor)));
         });
     }
 
@@ -435,6 +244,7 @@ private void addTrips(ZoneId zoneId, List<TripWithStopTimes> trips, int time, bo
     private static class TripWithStopTimeAndArrivalNode {
         TripWithStopTimes tripWithStopTimes;
         int arrivalNode;
+        int arrivalTime;
     }
 
     void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arrivalNodes, TripWithStopTimes trip, GtfsRealtime.TripDescriptor tripDescriptor, boolean frequencyBased) {
@@ -442,13 +252,14 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
         IntArrayList alightEdges = new IntArrayList();
         StopTime prev = null;
         int arrivalNode = -1;
+        int arrivalTime = -1;
         int departureNode = -1;
         for (StopTime stopTime : trip.stopTimes) {
             Stop stop = feed.stops.get(stopTime.stop_id);
             arrivalNode = i++;
             nodeAccess.setNode(arrivalNode, stop.stop_lat, stop.stop_lon);
             nodeAccess.setAdditionalNodeField(arrivalNode, NodeType.INTERNAL_PT.ordinal());
-            times.put(arrivalNode, stopTime.arrival_time + time);
+            arrivalTime = stopTime.arrival_time + time;
             if (prev != null) {
                 Stop fromStop = feed.stops.get(prev.stop_id);
                 double distance = distCalc.calcDist(
@@ -458,26 +269,43 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
                         stop.stop_lon);
                 EdgeIteratorState edge = graph.edge(departureNode, arrivalNode);
                 edge.setDistance(distance);
-                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                edge.set(accessEnc, true).setReverse(accessEnc, false);
                 edge.setName(stop.stop_name);
                 setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.HOP);
-                edge.setFlags(encoder.setTime(edge.getFlags(), stopTime.arrival_time - prev.departure_time));
+                edge.set(timeEnc, stopTime.arrival_time - prev.departure_time);
                 gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
             }
-            final int departureTimelineNode = i++;
-            nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
-            nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
-            times.put(departureTimelineNode, stopTime.departure_time + time);
-            departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, trip.trip.trip_id, trip.trip.route_id));
-            final int arrivalTimelineNode = i++;
-            nodeAccess.setNode(arrivalTimelineNode, stop.stop_lat, stop.stop_lon);
-            nodeAccess.setAdditionalNodeField(arrivalTimelineNode, NodeType.INTERNAL_PT.ordinal());
-            times.put(arrivalTimelineNode, stopTime.arrival_time + time);
-            arrivalTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(arrivalTimelineNode, trip.trip.trip_id, trip.trip.route_id));
+            Route route = feed.routes.get(trip.trip.route_id);
+            Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>> departureTimelines = departureTimelinesByStop.computeIfAbsent(stopTime.stop_id, s -> new HashMap<>());
+            NavigableMap<Integer, Integer> departureTimeline;
+            if (transfers.hasNoRouteSpecificDepartureTransferRules(stopTime.stop_id)) {
+                departureTimeline = departureTimelines.computeIfAbsent(GtfsStorageI.PlatformDescriptor.routeType(route.route_type), s -> new TreeMap<>());
+            } else {
+                departureTimeline = departureTimelines.computeIfAbsent(GtfsStorageI.PlatformDescriptor.route(route.route_id), s -> new TreeMap<>());
+            }
+            int departureTimelineNode = departureTimeline.computeIfAbsent((stopTime.departure_time + time) % (24 * 60 * 60), t -> {
+                final int _departureTimelineNode = i++;
+                nodeAccess.setNode(_departureTimelineNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(_departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
+                return _departureTimelineNode;
+            });
+
+            Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>> arrivalTimelines = arrivalTimelinesByStop.computeIfAbsent(stopTime.stop_id, s -> new HashMap<>());
+            NavigableMap<Integer, Integer> arrivalTimeline;
+            if (transfers.hasNoRouteSpecificArrivalTransferRules(stopTime.stop_id)) {
+                arrivalTimeline = arrivalTimelines.computeIfAbsent(GtfsStorageI.PlatformDescriptor.routeType(route.route_type), s -> new TreeMap<>());
+            } else {
+                arrivalTimeline = arrivalTimelines.computeIfAbsent(GtfsStorageI.PlatformDescriptor.route(route.route_id), s -> new TreeMap<>());
+            }
+            int arrivalTimelineNode = arrivalTimeline.computeIfAbsent((stopTime.arrival_time + time) % (24 * 60 * 60), t -> {
+                final int _arrivalTimelineNode = i++;
+                nodeAccess.setNode(_arrivalTimelineNode, stop.stop_lat, stop.stop_lon);
+                nodeAccess.setAdditionalNodeField(_arrivalTimelineNode, NodeType.INTERNAL_PT.ordinal());
+                return _arrivalTimelineNode;
+            });
             departureNode = i++;
             nodeAccess.setNode(departureNode, stop.stop_lat, stop.stop_lon);
             nodeAccess.setAdditionalNodeField(departureNode, NodeType.INTERNAL_PT.ordinal());
-            times.put(departureNode, stopTime.departure_time + time);
             int dayShift = stopTime.departure_time / (24 * 60 * 60);
             GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(trip.validOnDay, dayShift), zoneId, startDate);
             int validityId;
@@ -489,39 +317,38 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
             }
 
             EdgeIteratorState boardEdge = graph.edge(departureTimelineNode, departureNode);
-            boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
             boardEdge.setName(getRouteName(feed, trip.trip));
             setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
+            boardEdge.set(accessEnc, true).setReverse(accessEnc, false);
             while (boardEdges.size() < stopTime.stop_sequence) {
                 boardEdges.add(-1); // Padding, so that index == stop_sequence
             }
             boardEdges.add(boardEdge.getEdge());
             gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
             gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
-            boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
-            boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
+            boardEdge.set(validityIdEnc, validityId);
+            boardEdge.set(encoder.getTransfersEnc(), 1);
 
             EdgeIteratorState alightEdge = graph.edge(arrivalNode, arrivalTimelineNode);
-            alightEdge.setFlags(encoder.setAccess(alightEdge.getFlags(), true, false));
             alightEdge.setName(getRouteName(feed, trip.trip));
             setEdgeTypeAndClearDistance(alightEdge, GtfsStorage.EdgeType.ALIGHT);
+            alightEdge.set(accessEnc, true).setReverse(accessEnc, false);
             while (alightEdges.size() < stopTime.stop_sequence) {
                 alightEdges.add(-1);
             }
             alightEdges.add(alightEdge.getEdge());
             gtfsStorage.getStopSequences().put(alightEdge.getEdge(), stopTime.stop_sequence);
             gtfsStorage.getTripDescriptors().put(alightEdge.getEdge(), tripDescriptor.toByteArray());
-            alightEdge.setFlags(encoder.setValidityId(alightEdge.getFlags(), validityId));
-//                            alightEdge.setFlags(encoder.setTransfers(alightEdge.getFlags(), 1));
-
+            alightEdge.set(validityIdEnc, validityId);
 
             EdgeIteratorState dwellEdge = graph.edge(arrivalNode, departureNode);
-            dwellEdge.setFlags(encoder.setAccess(dwellEdge.getFlags(), true, false));
+            dwellEdge.set(accessEnc, true).setReverse(accessEnc, false);
             dwellEdge.setName(getRouteName(feed, trip.trip));
             setEdgeTypeAndClearDistance(dwellEdge, GtfsStorage.EdgeType.DWELL);
-            dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
+            dwellEdge.set(timeEnc, stopTime.departure_time - stopTime.arrival_time);
+
             if (prev == null) {
-                insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime, stop, validOn, zoneId);
+                insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime.departure_time + time, stopTime, stop, validOn, zoneId);
             }
             prev = stopTime;
         }
@@ -530,18 +357,146 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
         TripWithStopTimeAndArrivalNode tripWithStopTimeAndArrivalNode = new TripWithStopTimeAndArrivalNode();
         tripWithStopTimeAndArrivalNode.tripWithStopTimes = trip;
         tripWithStopTimeAndArrivalNode.arrivalNode = arrivalNode;
+        tripWithStopTimeAndArrivalNode.arrivalTime = arrivalTime;
         arrivalNodes.add(tripWithStopTimeAndArrivalNode);
     }
 
+    private void wireUpDepartureTimeline(int streetNode, Stop stop, NavigableMap<Integer, Integer> departureTimeline, int route_type, GtfsStorageI.PlatformDescriptor platformDescriptorIfStatic) {
+        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+        int stopEnterNode = i - 1;
+        nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
+        EdgeIteratorState entryEdge = graph.edge(streetNode, stopEnterNode);
+        entryEdge.set(accessEnc, true).setReverse(accessEnc, false);
+        setEdgeTypeAndClearDistance(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
+        entryEdge.set(encoder.getValidityIdEnc(), route_type);
+        entryEdge.setName(stop.stop_name);
+        if (platformDescriptorIfStatic != null) {
+            gtfsStorage.getRoutes().put(entryEdge.getEdge(), platformDescriptorIfStatic);
+        }
+        wireUpAndConnectTimeline(stop, stopEnterNode, departureTimeline, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK, GtfsStorage.EdgeType.WAIT);
+    }
+
+    private void wireUpArrivalTimeline(int streetNode, Stop stop, NavigableMap<Integer, Integer> arrivalTimeline, int route_type, GtfsStorageI.PlatformDescriptor platformDescriptorIfStatic) {
+        nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
+        int stopExitNode = i - 1;
+        nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
+        EdgeIteratorState exitEdge = graph.edge(stopExitNode, streetNode);
+        exitEdge.set(accessEnc, true).setReverse(accessEnc, false);
+        setEdgeTypeAndClearDistance(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
+        exitEdge.set(encoder.getValidityIdEnc(), route_type);
+        exitEdge.setName(stop.stop_name);
+        if (platformDescriptorIfStatic != null) {
+            gtfsStorage.getRoutes().put(exitEdge.getEdge(), platformDescriptorIfStatic);
+        }
+        wireUpAndConnectTimeline(stop, stopExitNode, arrivalTimeline, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK, GtfsStorage.EdgeType.WAIT_ARRIVAL);
+    }
+
+    private void wireUpOrPatchDepartureTimeline(ZoneId zoneId, int stationNode, Stop stop, NavigableMap<Integer, Integer> timeline, GtfsStorageI.PlatformDescriptor route) {
+        int platformEnterNode = findPlatformNode(stationNode, route, GtfsStorage.EdgeType.ENTER_PT);
+        if (platformEnterNode != -1) {
+            patchDepartureTimeline(zoneId, timeline, platformEnterNode);
+        } else {
+            wireUpDepartureTimeline(stationNode, stop, timeline, 0, null);
+        }
+    }
+
+    private void wireUpOrPatchArrivalTimeline(ZoneId zoneId, int stationNode, Stop stop, String routeId, NavigableMap<Integer, Integer> timeline, GtfsStorageI.PlatformDescriptor route) {
+        int platformExitNode = findPlatformNode(stationNode, route, GtfsStorage.EdgeType.EXIT_PT);
+        if (platformExitNode != -1) {
+            patchArrivalTimeline(zoneId, timeline, platformExitNode);
+        } else {
+            wireUpArrivalTimeline(stationNode, stop, timeline, 0, null);
+        }
+        final Optional<Transfer> withinStationTransfer = transfers.getTransfersFromStop(stop.stop_id, routeId).stream().filter(t -> t.from_stop_id.equals(stop.stop_id)).findAny();
+        if (!withinStationTransfer.isPresent()) {
+            insertOutboundTransfers(stop.stop_id, null, 0, timeline);
+        }
+        transfers.getTransfersFromStop(stop.stop_id, routeId).forEach(transfer ->
+                insertOutboundTransfers(transfer.from_stop_id, transfer.from_route_id, transfer.min_transfer_time, timeline));
+    }
+
+    private void patchDepartureTimeline(ZoneId zoneId, NavigableMap<Integer, Integer> timeline, int platformNode) {
+        NavigableMap<Integer, Integer> staticDepartureTimelineForRoute = findDepartureTimelineForPlatform(platformNode);
+        timeline.forEach((time, node) -> {
+            SortedMap<Integer, Integer> headMap = staticDepartureTimelineForRoute.headMap(time);
+            if (!headMap.isEmpty()) {
+                EdgeIteratorState edge = graph.edge(headMap.get(headMap.lastKey()), node);
+                edge.set(accessEnc, true).setReverse(accessEnc, false);
+                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
+                edge.set(timeEnc, time - headMap.lastKey());
+            }
+            SortedMap<Integer, Integer> tailMap = staticDepartureTimelineForRoute.tailMap(time);
+            if (!tailMap.isEmpty()) {
+                EdgeIteratorState edge = graph.edge(node, tailMap.get(tailMap.firstKey()));
+                edge.set(accessEnc, true).setReverse(accessEnc, false);
+                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
+                edge.set(timeEnc, tailMap.firstKey() - time);
+            }
+
+            EdgeIteratorState edge = graph.edge(platformNode, node);
+            edge.set(accessEnc, true).setReverse(accessEnc, false);
+            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
+            edge.set(timeEnc, time);
+            setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
+        });
+    }
+
+    private void patchArrivalTimeline(ZoneId zoneId, NavigableMap<Integer, Integer> timeline, int platformExitNode) {
+        timeline.forEach((time, node) -> {
+            EdgeIteratorState edge = graph.edge(node, platformExitNode);
+            edge.set(accessEnc, true).setReverse(accessEnc, false);
+            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
+            edge.set(timeEnc, time);
+            setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
+        });
+    }
+
+    private NavigableMap<Integer, Integer> findDepartureTimelineForPlatform(int platformEnterNode) {
+        TreeMap<Integer, Integer> result = new TreeMap<>();
+        if (platformEnterNode == -1) {
+            return result;
+        }
+        EdgeIterator edge = graph.getBaseGraph().createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder)).setBaseNode(platformEnterNode);
+        while (edge.next()) {
+            if (edge.get(encoder.getTypeEnc()) == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
+                result.put(edge.get(timeEnc), edge.getAdjNode());
+            }
+        }
+        return result;
+    }
+
+    private int findPlatformNode(int stationNode, GtfsStorageI.PlatformDescriptor platformDescriptor, GtfsStorage.EdgeType edgeType) {
+        DefaultEdgeFilter filter;
+        if (edgeType == GtfsStorage.EdgeType.ENTER_PT) {
+            filter = DefaultEdgeFilter.outEdges(encoder);
+        } else if (edgeType == GtfsStorage.EdgeType.EXIT_PT) {
+            filter = DefaultEdgeFilter.inEdges(encoder);
+        } else {
+            throw new RuntimeException();
+        }
+        EdgeIterator i = graph.getBaseGraph().createEdgeExplorer(filter).setBaseNode(stationNode);
+        while (i.next()) {
+            if (i.get(encoder.getTypeEnc()) == edgeType) {
+                if (platformDescriptor.equals(gtfsStorage.getRoutes().get(i.getEdge()))) {
+                    return i.getAdjNode();
+                }
+            }
+        }
+        return -1;
+    }
+
     int addDelayedBoardEdge(ZoneId zoneId, GtfsRealtime.TripDescriptor tripDescriptor, int stopSequence, int departureTime, int departureNode, BitSet validOnDay) {
         Trip trip = feed.trips.get(tripDescriptor.getTripId());
-        final int departureTimelineNode = i++;
         StopTime stopTime = feed.stop_times.get(new Fun.Tuple2(tripDescriptor.getTripId(), stopSequence));
         Stop stop = feed.stops.get(stopTime.stop_id);
-        nodeAccess.setNode(departureTimelineNode, stop.stop_lat, stop.stop_lon);
-        nodeAccess.setAdditionalNodeField(departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
-        times.put(departureTimelineNode, departureTime);
-        departureTimelineNodes.put(stopTime.stop_id, new TimelineNodeIdWithTripId(departureTimelineNode, tripDescriptor.getTripId(), trip.route_id));
+        Map<GtfsStorageI.PlatformDescriptor, NavigableMap<Integer, Integer>> departureTimelineNodesByRoute = departureTimelinesByStop.computeIfAbsent(stopTime.stop_id, s -> new HashMap<>());
+        NavigableMap<Integer, Integer> departureTimelineNodes = departureTimelineNodesByRoute.computeIfAbsent(GtfsStorageI.PlatformDescriptor.route(trip.route_id), s -> new TreeMap<>());
+        int departureTimelineNode = departureTimelineNodes.computeIfAbsent(departureTime % (24 * 60 * 60), t -> {
+            final int _departureTimelineNode = i++;
+            nodeAccess.setNode(_departureTimelineNode, stop.stop_lat, stop.stop_lon);
+            nodeAccess.setAdditionalNodeField(_departureTimelineNode, NodeType.INTERNAL_PT.ordinal());
+            return _departureTimelineNode;
+        });
 
         int dayShift = departureTime / (24 * 60 * 60);
         GtfsStorage.Validity validOn = new GtfsStorage.Validity(getValidOn(validOnDay, dayShift), zoneId, startDate);
@@ -554,36 +509,51 @@ int addDelayedBoardEdge(ZoneId zoneId, GtfsRealtime.TripDescriptor tripDescripto
         }
 
         EdgeIteratorState boardEdge = graph.edge(departureTimelineNode, departureNode);
-        boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
+        boardEdge.set(accessEnc, true).setReverse(accessEnc, false);
         boardEdge.setName(getRouteName(feed, trip));
         setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
         gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopSequence);
         gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
-        boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
-        boardEdge.setFlags(encoder.setTransfers(boardEdge.getFlags(), 1));
+        boardEdge.set(validityIdEnc, validityId);
+        boardEdge.set(encoder.getTransfersEnc(), 1);
         return boardEdge.getEdge();
     }
 
-    private void wireUpAndAndConnectArrivalTimeline(Stop toStop, String routeId, int stopExitNode, NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes) {
-        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(routeId).agency_id).agency_timezone);
+    private void wireUpAndConnectTimeline(Stop toStop, int platformNode, NavigableMap<Integer, Integer> timeNodes, GtfsStorage.EdgeType timeExpandedNetworkEdgeType, GtfsStorage.EdgeType waitEdgeType) {
+        ZoneId zoneId = ZoneId.of(feed.agency.values().iterator().next().agency_timezone);
         int time = 0;
         int prev = -1;
-        for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
-            EdgeIteratorState leaveTimeExpandedNetworkEdge = graph.edge(e.b, stopExitNode);
-            leaveTimeExpandedNetworkEdge.setFlags(encoder.setAccess(leaveTimeExpandedNetworkEdge.getFlags(), true, false));
-            setEdgeTypeAndClearDistance(leaveTimeExpandedNetworkEdge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
-            int arrivalTime = e.a;
-            leaveTimeExpandedNetworkEdge.setFlags(encoder.setTime(leaveTimeExpandedNetworkEdge.getFlags(), arrivalTime));
-            setFeedIdWithTimezone(leaveTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
+        for (Map.Entry<Integer, Integer> e : timeNodes.descendingMap().entrySet()) {
+            EdgeIteratorState timeExpandedNetworkEdge;
+            if (timeExpandedNetworkEdgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
+                timeExpandedNetworkEdge = graph.edge(e.getValue(), platformNode);
+            } else if (timeExpandedNetworkEdgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
+                timeExpandedNetworkEdge = graph.edge(platformNode, e.getValue());
+            } else {
+                throw new RuntimeException();
+            }
+            timeExpandedNetworkEdge.set(accessEnc, true).setReverse(accessEnc, false);
+            timeExpandedNetworkEdge.setName(toStop.stop_name);
+            setEdgeTypeAndClearDistance(timeExpandedNetworkEdge, timeExpandedNetworkEdgeType);
+            timeExpandedNetworkEdge.set(timeEnc, e.getKey());
+            setFeedIdWithTimezone(timeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
             if (prev != -1) {
-                EdgeIteratorState edge = graph.edge(e.b, prev);
-                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT_ARRIVAL);
-                edge.setName(toStop.stop_name);
-                edge.setFlags(encoder.setTime(edge.getFlags(), time-e.a));
+                EdgeIteratorState waitEdge = graph.edge(e.getValue(), prev);
+                waitEdge.set(accessEnc, true).setReverse(accessEnc, false);
+                setEdgeTypeAndClearDistance(waitEdge, waitEdgeType);
+                waitEdge.setName(toStop.stop_name);
+                waitEdge.set(timeEnc, time - e.getKey());
             }
-            time = e.a;
-            prev = e.b;
+            time = e.getKey();
+            prev = e.getValue();
+        }
+        if (!timeNodes.isEmpty()) {
+            EdgeIteratorState edge = graph.edge(timeNodes.get(timeNodes.lastKey()), timeNodes.get(timeNodes.firstKey()));
+            edge.set(accessEnc, true).setReverse(accessEnc, false);
+            int rolloverTime = 24 * 60 * 60 - timeNodes.lastKey() + timeNodes.firstKey();
+            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.OVERNIGHT);
+            edge.setName(toStop.stop_name);
+            edge.set(timeEnc, rolloverTime);
         }
     }
 
@@ -595,47 +565,16 @@ private void setFeedIdWithTimezone(EdgeIteratorState leaveTimeExpandedNetworkEdg
             validityId = gtfsStorage.getWritableTimeZones().size();
             gtfsStorage.getWritableTimeZones().put(validOn, validityId);
         }
-        leaveTimeExpandedNetworkEdge.setFlags(encoder.setValidityId(leaveTimeExpandedNetworkEdge.getFlags(), validityId));
+        leaveTimeExpandedNetworkEdge.set(validityIdEnc, validityId);
     }
 
-    private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId, int stopEnterNode, NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes) {
-        ZoneId zoneId = ZoneId.of(feed.agency.get(feed.routes.get(toRouteId).agency_id).agency_timezone);
-        int time = 0;
-        int prev = -1;
-        for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
-            EdgeIteratorState enterTimeExpandedNetworkEdge = graph.edge(stopEnterNode, e.b);
-            enterTimeExpandedNetworkEdge.setFlags(encoder.setAccess(enterTimeExpandedNetworkEdge.getFlags(), true, false));
-            enterTimeExpandedNetworkEdge.setName(toStop.stop_name);
-            setEdgeTypeAndClearDistance(enterTimeExpandedNetworkEdge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
-            enterTimeExpandedNetworkEdge.setFlags(encoder.setTime(enterTimeExpandedNetworkEdge.getFlags(), e.a));
-            setFeedIdWithTimezone(enterTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
-            if (prev != -1) {
-                EdgeIteratorState edge = graph.edge(e.b, prev);
-                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
-                edge.setName(toStop.stop_name);
-                edge.setFlags(encoder.setTime(edge.getFlags(), time-e.a));
-            }
-            time = e.a;
-            prev = e.b;
-        }
-        if (!timeNodes.isEmpty()) {
-            EdgeIteratorState edge = graph.edge(timeNodes.last().b, timeNodes.first().b);
-            edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-            int rolloverTime = 24 * 60 * 60 - timeNodes.last().a + timeNodes.first().a;
-            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.OVERNIGHT);
-            edge.setName(toStop.stop_name);
-            edge.setFlags(encoder.setTime(edge.getFlags(), rolloverTime));
-        }
-    }
-
-    private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, StopTime stopTime, Stop stop, GtfsStorage.Validity validOn, ZoneId zoneId) {
+    private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> arrivalNodes, GtfsRealtime.TripDescriptor tripDescriptor, int departureNode, int departureTime, StopTime stopTime, Stop stop, GtfsStorage.Validity validOn, ZoneId zoneId) {
         BitSet accumulatorValidity = new BitSet(validOn.validity.size());
         accumulatorValidity.or(validOn.validity);
         ListIterator<TripWithStopTimeAndArrivalNode> li = arrivalNodes.listIterator(arrivalNodes.size());
-        while(li.hasPrevious() && accumulatorValidity.cardinality() > 0) {
+        while (li.hasPrevious() && accumulatorValidity.cardinality() > 0) {
             TripWithStopTimeAndArrivalNode lastTrip = li.previous();
-            int dwellTime = times.get(departureNode) - times.get(lastTrip.arrivalNode);
+            int dwellTime = departureTime - lastTrip.arrivalTime;
             if (dwellTime >= 0 && accumulatorValidity.intersects(lastTrip.tripWithStopTimes.validOnDay)) {
                 BitSet blockTransferValidity = new BitSet(validOn.validity.size());
                 blockTransferValidity.or(validOn.validity);
@@ -649,15 +588,15 @@ private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> ar
                     gtfsStorage.getOperatingDayPatterns().put(blockTransferValidOn, blockTransferValidityId);
                 }
                 nodeAccess.setNode(i++, stop.stop_lat, stop.stop_lon);
-                nodeAccess.setAdditionalNodeField(i-1, NodeType.INTERNAL_PT.ordinal());
-                EdgeIteratorState transferEdge = graph.edge(lastTrip.arrivalNode,i-1);
-                transferEdge.setFlags(encoder.setAccess(transferEdge.getFlags(), true, false));
+                nodeAccess.setAdditionalNodeField(i - 1, NodeType.INTERNAL_PT.ordinal());
+                EdgeIteratorState transferEdge = graph.edge(lastTrip.arrivalNode, i - 1);
+                transferEdge.set(accessEnc, true).setReverse(accessEnc, false);
                 setEdgeTypeAndClearDistance(transferEdge, GtfsStorage.EdgeType.TRANSFER);
-                transferEdge.setFlags(encoder.setTime(transferEdge.getFlags(), dwellTime));
-                EdgeIteratorState boardEdge = graph.edge(i-1, departureNode);
-                boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
+                transferEdge.set(timeEnc, dwellTime);
+                EdgeIteratorState boardEdge = graph.edge(i - 1, departureNode);
+                boardEdge.set(accessEnc, true).setReverse(accessEnc, false);
                 setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
-                boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), blockTransferValidityId));
+                boardEdge.set(validityIdEnc, blockTransferValidityId);
                 gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
                 gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
                 accumulatorValidity.andNot(lastTrip.tripWithStopTimes.validOnDay);
@@ -665,34 +604,23 @@ private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> ar
         }
     }
 
-    private Iterable<StopTime> getInterpolatedStopTimesForTrip(String trip_id) {
-        try {
-            return feed.getInterpolatedStopTimesForTrip(trip_id);
-        } catch (GTFSFeed.FirstAndLastStopsDoNotHaveTimes e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private void insertInboundTransfers(String fromStopId, String from_route_id, int minimumTransferTime, SortedSet<Fun.Tuple2<Integer, Integer>> toStopTimelineNode) {
+    private void insertInboundTransfers(String fromStopId, String from_route_id, int minimumTransferTime, NavigableMap<Integer, Integer> toStopTimelineNode) {
         int stationNode = gtfsStorage.getStationNodes().get(fromStopId);
         EdgeIterator i = graph.createEdgeExplorer().setBaseNode(stationNode);
         while (i.next()) {
-            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
-            if (edgeType == GtfsStorage.EdgeType.EXIT_PT) {
-                String routeId = gtfsStorage.getRoutes().get(i.getEdge());
-                if (from_route_id == null || from_route_id.equals(routeId)) {
+            if (i.get(encoder.getTypeEnc()) == GtfsStorage.EdgeType.EXIT_PT) {
+                GtfsStorageI.PlatformDescriptor routeId = gtfsStorage.getRoutes().get(i.getEdge());
+                if (from_route_id == null || GtfsStorageI.PlatformDescriptor.route(from_route_id).equals(routeId)) {
                     EdgeIterator j = graph.createEdgeExplorer().setBaseNode(i.getAdjNode());
                     while (j.next()) {
-                        GtfsStorage.EdgeType edgeType2 = encoder.getEdgeType(j.getFlags());
-                        if (edgeType2 == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
-                            int arrivalTime = (int) encoder.getTime(j.getFlags());
-                            SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = toStopTimelineNode.tailSet(new Fun.Tuple2<>(arrivalTime + minimumTransferTime, -1));
+                        if (j.get(encoder.getTypeEnc()) == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK) {
+                            int arrivalTime = j.get(timeEnc);
+                            SortedMap<Integer, Integer> tailSet = toStopTimelineNode.tailMap(arrivalTime + minimumTransferTime);
                             if (!tailSet.isEmpty()) {
-                                Fun.Tuple2<Integer, Integer> e = tailSet.first();
-                                EdgeIteratorState edge = graph.edge(j.getAdjNode(), e.b);
-                                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                                EdgeIteratorState edge = graph.edge(j.getAdjNode(), tailSet.get(tailSet.firstKey()));
+                                edge.set(accessEnc, true).setReverse(accessEnc, false);
                                 setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.TRANSFER);
-                                edge.setFlags(encoder.setTime(edge.getFlags(), e.a - arrivalTime));
+                                edge.set(timeEnc, tailSet.firstKey() - arrivalTime);
                             }
                         }
                     }
@@ -701,27 +629,27 @@ private void insertInboundTransfers(String fromStopId, String from_route_id, int
         }
     }
 
-    private void insertOutboundTransfers(String toStopId, String toRouteId, int minimumTransferTime, SortedSet<Fun.Tuple2<Integer, Integer>> fromStopTimelineNodes) {
+    private void insertOutboundTransfers(String toStopId, String toRouteId, int minimumTransferTime, NavigableMap<Integer, Integer> fromStopTimelineNodes) {
         int stationNode = gtfsStorage.getStationNodes().get(toStopId);
         EdgeIterator i = graph.getBaseGraph().createEdgeExplorer().setBaseNode(stationNode);
         while (i.next()) {
-            GtfsStorage.EdgeType edgeType = encoder.getEdgeType(i.getFlags());
+            GtfsStorage.EdgeType edgeType = i.get(encoder.getTypeEnc());
             if (edgeType == GtfsStorage.EdgeType.ENTER_PT) {
-                String routeId = gtfsStorage.getRoutes().get(i.getEdge());
-                if (toRouteId == null || toRouteId.equals(routeId)) {
-                    fromStopTimelineNodes.forEach(e -> {
+                GtfsStorageI.PlatformDescriptor routeId = gtfsStorage.getRoutes().get(i.getEdge());
+                if (toRouteId == null || routeId instanceof GtfsStorageI.RouteTypePlatform || GtfsStorageI.PlatformDescriptor.route(toRouteId).equals(routeId)) {
+                    fromStopTimelineNodes.forEach((time, e) -> {
                         EdgeIterator j = graph.getBaseGraph().createEdgeExplorer().setBaseNode(i.getAdjNode());
                         while (j.next()) {
-                            GtfsStorage.EdgeType edgeType2 = encoder.getEdgeType(j.getFlags());
+                            GtfsStorage.EdgeType edgeType2 = j.get(encoder.getTypeEnc());
                             if (edgeType2 == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK) {
-                                int departureTime = (int) encoder.getTime(j.getFlags());
-                                if (departureTime < e.a + minimumTransferTime) {
+                                int departureTime = j.get(timeEnc);
+                                if (departureTime < time + minimumTransferTime) {
                                     continue;
                                 }
-                                EdgeIteratorState edge = graph.edge(e.b, j.getAdjNode());
-                                edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
+                                EdgeIteratorState edge = graph.edge(e, j.getAdjNode());
+                                edge.set(accessEnc, true).setReverse(accessEnc, false);
                                 setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.TRANSFER);
-                                edge.setFlags(encoder.setTime(edge.getFlags(), departureTime - e.a));
+                                edge.set(timeEnc, departureTime - time);
                                 break;
                             }
                         }
@@ -733,12 +661,13 @@ private void insertOutboundTransfers(String toStopId, String toRouteId, int mini
 
     private String getRouteName(GTFSFeed feed, Trip trip) {
         Route route = feed.routes.get(trip.route_id);
-        return (route.route_long_name != null ? route.route_long_name : route.route_short_name) + " " + trip.trip_headsign;
+        String routePart = route != null ? (route.route_long_name != null ? route.route_long_name : route.route_short_name) : "extra";
+        return routePart + " " + trip.trip_headsign;
     }
 
     private void setEdgeTypeAndClearDistance(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
         edge.setDistance(0.0);
-        edge.setFlags(encoder.setEdgeType(edge.getFlags(), edgeType));
+        edge.set(encoder.getTypeEnc(), edgeType);
     }
 
     private BitSet getValidOn(BitSet validOnDay, int dayShift) {
@@ -746,13 +675,29 @@ private BitSet getValidOn(BitSet validOnDay, int dayShift) {
             return validOnDay;
         } else {
             BitSet bitSet = new BitSet(validOnDay.length() + 1);
-            for (int i=0; i<validOnDay.length(); i++) {
+            for (int i = 0; i < validOnDay.length(); i++) {
                 if (validOnDay.get(i)) {
-                    bitSet.set(i+1);
+                    bitSet.set(i + 1);
                 }
             }
             return bitSet;
         }
     }
 
+    private int routeType(GtfsStorageI.PlatformDescriptor platformDescriptor) {
+        if (platformDescriptor instanceof GtfsStorageI.RouteTypePlatform) {
+            return ((GtfsStorageI.RouteTypePlatform) platformDescriptor).route_type;
+        } else {
+            return feed.routes.get(((GtfsStorageI.RoutePlatform) platformDescriptor).route_id).route_type;
+        }
+    }
+
+    private String routeIdOrNull(GtfsStorageI.PlatformDescriptor platformDescriptor) {
+        if (platformDescriptor instanceof GtfsStorageI.RouteTypePlatform) {
+            return null;
+        } else {
+            return ((GtfsStorageI.RoutePlatform) platformDescriptor).route_id;
+        }
+    }
+
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
index 8e94eaf6e3..2f75cc1ac6 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorage.java
@@ -26,14 +26,18 @@
 import com.graphhopper.storage.Directory;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphExtension;
-import org.mapdb.*;
-
-import java.io.*;
+import org.mapdb.Bind;
+import org.mapdb.DB;
+import org.mapdb.DBMaker;
+import org.mapdb.HTreeMap;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Serializable;
+import java.nio.file.Files;
 import java.time.LocalDate;
 import java.time.ZoneId;
-import java.nio.file.Files;
 import java.util.*;
-import java.util.concurrent.ExecutionException;
 import java.util.zip.ZipFile;
 
 public class GtfsStorage implements GraphExtension, GtfsStorageI {
@@ -96,7 +100,7 @@ public int hashCode() {
 	private Map<Integer, byte[]> tripDescriptors;
 	private Map<Integer, Integer> stopSequences;
 
-	private Map<Integer, String> routes;
+	private Map<Integer, PlatformDescriptor> routes;
 
 	private Map<String, Fare> fares;
 	private Map<String, int[]> boardEdgesForTrip;
@@ -104,7 +108,7 @@ public int hashCode() {
 
 	private Map<String, Integer> stationNodes;
 
-	enum EdgeType {
+	public enum EdgeType {
 		HIGHWAY, ENTER_TIME_EXPANDED_NETWORK, LEAVE_TIME_EXPANDED_NETWORK, ENTER_PT, EXIT_PT, HOP, DWELL, BOARD, ALIGHT, OVERNIGHT, TRANSFER, WAIT, WAIT_ARRIVAL
     }
 
@@ -150,13 +154,9 @@ public boolean loadExisting() {
 		this.data = DBMaker.newFileDB(new File(dir.getLocation() + "/transit_schedule")).transactionDisable().mmapFileEnable().readOnly().make();
 		init();
 		for (String gtfsFeedId : this.gtfsFeedIds) {
-			try {
-				GTFSFeed feed = new GTFSFeed(dir.getLocation() + "/" + gtfsFeedId);
-				this.gtfsFeeds.put(gtfsFeedId, feed);
-				this.transfers.put(gtfsFeedId, new Transfers(feed));
-			} catch (IOException | ExecutionException e) {
-				throw new RuntimeException(e);
-			}
+			GTFSFeed feed = new GTFSFeed(new File(dir.getLocation() + "/" + gtfsFeedId));
+			this.gtfsFeeds.put(gtfsFeedId, feed);
+			this.transfers.put(gtfsFeedId, new Transfers(feed));
 		}
 		return true;
 	}
@@ -194,12 +194,14 @@ private void init() {
 	}
 
 	void loadGtfsFromFile(String id, ZipFile zip) {
+		File file = new File(dir.getLocation() + "/" + id);
 		try {
-			GTFSFeed feed = new GTFSFeed(dir.getLocation() + "/" + id);
-			feed.loadFromFile(zip);
+			Files.deleteIfExists(file.toPath());
+			GTFSFeed feed = new GTFSFeed(file);
+			feed.loadFromFileAndLogErrors(zip);
 			fixFares(feed, zip);
 			this.gtfsFeeds.put(id, feed);
-		} catch (Exception e) {
+		} catch (IOException e) {
 			throw new RuntimeException(e);
 		}
 		this.gtfsFeedIds.add(id);
@@ -277,7 +279,7 @@ public long getCapacity() {
 	}
 
     @Override
-    public Map<Integer, String> getRoutes() {
+    public Map<Integer, PlatformDescriptor> getRoutes() {
         return routes;
     }
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorageI.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorageI.java
index 3b03cb553c..5d8b0fb8ed 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorageI.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsStorageI.java
@@ -20,15 +20,69 @@
 
 import com.conveyal.gtfs.GTFSFeed;
 import com.conveyal.gtfs.model.Fare;
+import com.conveyal.gtfs.model.Route;
 import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.storage.StorableProperties;
 
+import java.io.Serializable;
 import java.util.Map;
+import java.util.Objects;
 
 // Used to mock GtfsStorage for GtfsReader, to reuse it for realtime updates.
 // GtfsReader basically emits things to be added as a stream of events.
 // TODO: Make that explicit
 public interface GtfsStorageI {
+
+    public abstract class PlatformDescriptor implements Serializable {
+
+        public static PlatformDescriptor route(String route_id) {
+            RoutePlatform routePlatform = new RoutePlatform();
+            routePlatform.route_id = route_id;
+            return routePlatform;
+        }
+
+        public static RouteTypePlatform routeType(int route_type) {
+            RouteTypePlatform routeTypePlatform = new RouteTypePlatform();
+            routeTypePlatform.route_type = route_type;
+            return routeTypePlatform;
+        }
+
+    }
+
+    class RoutePlatform extends PlatformDescriptor {
+        String route_id;
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            RoutePlatform that = (RoutePlatform) o;
+            return Objects.equals(route_id, that.route_id);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(route_id);
+        }
+    }
+
+    class RouteTypePlatform extends PlatformDescriptor {
+        int route_type;
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            RouteTypePlatform that = (RouteTypePlatform) o;
+            return route_type == that.route_type;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(route_type);
+        }
+    }
+
     Map<String, Fare> getFares();
 
     Map<GtfsStorage.Validity, Integer> getOperatingDayPatterns();
@@ -49,5 +103,5 @@
 
     Map<String, Integer> getStationNodes();
 
-    Map<Integer, String> getRoutes();
+    Map<Integer, PlatformDescriptor> getRoutes();
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index 4a9ea82d7e..d584c7020a 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -23,7 +23,7 @@
 import java.time.Instant;
 import java.util.Iterator;
 
-class Label {
+public class Label {
 
     static class Transition {
         final Label label;
@@ -62,22 +62,23 @@ public String toString() {
         }
     }
 
-    final long currentTime;
+    public final long currentTime;
 
-    final int edge;
-    final int adjNode;
+    public final int edge;
+    public final int adjNode;
 
-    final int nTransfers;
-    final int nWalkDistanceConstraintViolations;
+    public final int nTransfers;
+    public final int nWalkDistanceConstraintViolations;
 
-    final double walkDistanceOnCurrentLeg;
-    final Long departureTime;
-    final long walkTime;
+    public final double walkDistanceOnCurrentLeg;
+    public final Long departureTime;
+    public final long walkTime;
 
     final long residualDelay;
     final boolean impossible;
 
-    final Label parent;
+    public final Label parent;
+    public boolean deleted = false;
 
     Label(long currentTime, int edgeId, int adjNode, int nTransfers, int nWalkDistanceConstraintViolations, double walkDistance, Long departureTime, long walkTime, long residualDelay, boolean impossible, Label parent) {
         this.currentTime = currentTime;
@@ -98,7 +99,7 @@ public String toString() {
         return adjNode + " " + Instant.ofEpochMilli(currentTime) + " " + nTransfers + " " + nWalkDistanceConstraintViolations + " " +  (departureTime != null ? Instant.ofEpochMilli(departureTime) : "");
     }
 
-    static Iterable<Transition> reverseEdges(Label leaf, GraphExplorer graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
+    static Iterable<Transition> reverseEdges(Label leaf, Graph graph, PtFlagEncoder flagEncoder, boolean reverseEdgeFlags) {
         return new Iterable<Transition>() {
             @Override
             public Iterator<Transition> iterator() {
@@ -141,7 +142,8 @@ public Transition next() {
     }
 
     private static EdgeLabel getEdgeLabel(EdgeIteratorState edgeIteratorState, PtFlagEncoder flagEncoder) {
-        return new EdgeLabel(edgeIteratorState, flagEncoder.getEdgeType(edgeIteratorState.getFlags()), flagEncoder.getValidityId(edgeIteratorState.getFlags()), flagEncoder.getTransfers(edgeIteratorState.getFlags()), edgeIteratorState.getDistance());
+        return new EdgeLabel(edgeIteratorState, edgeIteratorState.get(flagEncoder.getTypeEnc()), edgeIteratorState.get(flagEncoder.getValidityIdEnc()),
+                edgeIteratorState.get(flagEncoder.getTransfersEnc()), edgeIteratorState.getDistance());
     }
 
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index 89afa87e61..869e42c5fc 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -1,6 +1,6 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
  *  GraphHopper GmbH licenses this file to you under the Apache License,
@@ -17,14 +17,15 @@
  */
 package com.graphhopper.reader.gtfs;
 
-import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.Multimap;
+import com.carrotsearch.hppc.IntObjectHashMap;
+import com.carrotsearch.hppc.IntObjectMap;
+import com.graphhopper.routing.profiles.IntEncodedValue;
 import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
 
 import java.time.Instant;
 import java.util.*;
 import java.util.function.Consumer;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
@@ -37,14 +38,18 @@
  * @author Peter Karich
  * @author Wesam Herbawi
  */
-class MultiCriteriaLabelSetting {
+public class MultiCriteriaLabelSetting {
+
+    public interface SPTVisitor {
+        void visit(Label label);
+    }
 
     private final Comparator<Label> queueComparator;
     private final List<Label> targetLabels;
     private long startTime;
     private int blockedRouteTypes;
     private final PtFlagEncoder flagEncoder;
-    private final Multimap<Integer, Label> fromMap;
+    private final IntObjectMap<List<Label>> fromMap;
     private final PriorityQueue<Label> fromHeap;
     private final int maxVisitedNodes;
     private final boolean reverse;
@@ -57,7 +62,7 @@
     private double betaTransfers;
     private double betaWalkTime = 1.0;
 
-    MultiCriteriaLabelSetting(GraphExplorer explorer, PtFlagEncoder flagEncoder, boolean reverse, double maxWalkDistancePerLeg, boolean ptOnly, boolean mindTransfers, boolean profileQuery, int maxVisitedNodes, List<Label> solutions) {
+    public MultiCriteriaLabelSetting(GraphExplorer explorer, PtFlagEncoder flagEncoder, boolean reverse, double maxWalkDistancePerLeg, boolean ptOnly, boolean mindTransfers, boolean profileQuery, int maxVisitedNodes, List<Label> solutions) {
         this.flagEncoder = flagEncoder;
         this.maxVisitedNodes = maxVisitedNodes;
         this.explorer = explorer;
@@ -68,12 +73,14 @@
         this.profileQuery = profileQuery;
         this.targetLabels = solutions;
 
-        queueComparator = Comparator.<Label>comparingLong(l2 -> weight(l2))
-                .thenComparing(Comparator.comparingLong(l1 -> l1.nTransfers))
-                .thenComparing(Comparator.comparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0))
-                .thenComparing(Comparator.comparingLong(l2 -> l2.impossible ? 1 : 0));
+        queueComparator = Comparator
+                .comparingLong(this::weight)
+                .thenComparingLong(l -> l.nTransfers)
+                .thenComparingLong(l -> l.walkTime)
+                .thenComparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0)
+                .thenComparingLong(l -> l.impossible ? 1 : 0);
         fromHeap = new PriorityQueue<>(queueComparator);
-        fromMap = ArrayListMultimap.create();
+        fromMap = new IntObjectHashMap<>();
     }
 
     Stream<Label> calcLabels(int from, int to, Instant startTime, int blockedRouteTypes) {
@@ -84,6 +91,30 @@
                 .peek(label -> visitedNodes++);
     }
 
+    public void calcLabels(int from, int to, Instant startTime, int blockedRouteTypes, SPTVisitor visitor, Predicate<Label> predicate) {
+        this.startTime = startTime.toEpochMilli();
+        this.blockedRouteTypes = blockedRouteTypes;
+        Iterator<Label> iterator = StreamSupport.stream(new MultiCriteriaLabelSettingSpliterator(from, to), false).iterator();
+        Label l;
+        while (iterator.hasNext() && predicate.test(l = iterator.next())) {
+            visitor.visit(l);
+        }
+    }
+
+
+    public void calcLabelsAndNeighbors(int from, int to, Instant startTime, int blockedRouteTypes, SPTVisitor visitor, Predicate<Label> predicate) {
+        this.startTime = startTime.toEpochMilli();
+        this.blockedRouteTypes = blockedRouteTypes;
+        Iterator<Label> iterator = StreamSupport.stream(new MultiCriteriaLabelSettingSpliterator(from, to), false).iterator();
+        Label l;
+        while (iterator.hasNext() && predicate.test(l = iterator.next())) {
+            visitor.visit(l);
+        }
+        for (Label label : fromHeap) {
+            visitor.visit(label);
+        }
+    }
+
     // experimental
     void setBetaTransfers(double betaTransfers) {
         this.betaTransfers = betaTransfers;
@@ -103,8 +134,10 @@ void setBetaWalkTime(double betaWalkTime) {
             super(0, 0);
             this.from = from;
             this.to = to;
-            Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, null, 0, 0,false,null);
-            fromMap.put(from, label);
+            Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, null, 0, 0, false, null);
+            ArrayList<Label> labels = new ArrayList<>(1);
+            labels.add(label);
+            fromMap.put(from, labels);
             fromHeap.add(label);
         }
 
@@ -115,11 +148,13 @@ public boolean tryAdvance(Consumer<? super Label> action) {
             } else {
                 Label label = fromHeap.poll();
                 action.accept(label);
+                final IntEncodedValue validityEnc = flagEncoder.getValidityIdEnc();
                 explorer.exploreEdgesAround(label).forEach(edge -> {
-                    GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
+                    GtfsStorage.EdgeType edgeType = edge.get(flagEncoder.getTypeEnc());
                     if (edgeType == GtfsStorage.EdgeType.ENTER_PT && reverse && ptOnly) return;
                     if (edgeType == GtfsStorage.EdgeType.EXIT_PT && !reverse && ptOnly) return;
-                    if ((edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT) && (blockedRouteTypes & (1 << flagEncoder.getValidityId(edge.getFlags()))) != 0) return;
+                    if ((edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT) && (blockedRouteTypes & (1 << edge.get(validityEnc))) != 0)
+                        return;
                     long nextTime;
                     if (reverse) {
                         nextTime = label.currentTime - explorer.calcTravelTimeMillis(edge, label.currentTime);
@@ -142,7 +177,11 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                     long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY || edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT ? ((reverse ? -1 : 1) * (nextTime - label.currentTime)) : 0);
                     int nWalkDistanceConstraintViolations = Math.min(1, label.nWalkDistanceConstraintViolations + (
                             isTryingToReEnterPtAfterWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
-                    Collection<Label> sptEntries = fromMap.get(edge.getAdjNode());
+                    List<Label> sptEntries = fromMap.get(edge.getAdjNode());
+                    if (sptEntries == null) {
+                        sptEntries = new ArrayList<>(1);
+                        fromMap.put(edge.getAdjNode(), sptEntries);
+                    }
                     boolean impossible = label.impossible
                             || explorer.isBlocked(edge)
                             || (!reverse) && edgeType == GtfsStorage.EdgeType.BOARD && label.residualDelay > 0
@@ -167,25 +206,25 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                     }
                     if (!reverse && edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && residualDelay > 0) {
                         Label newImpossibleLabelForDelayedTrip = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, true, label);
-                        insertIfNotDominated(edge, sptEntries, newImpossibleLabelForDelayedTrip);
+                        insertIfNotDominated(sptEntries, newImpossibleLabelForDelayedTrip);
                         nextTime += residualDelay;
                         residualDelay = 0;
                         Label newLabel = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, impossible, label);
-                        insertIfNotDominated(edge, sptEntries, newLabel);
+                        insertIfNotDominated(sptEntries, newLabel);
                     } else {
                         Label newLabel = new Label(nextTime, edge.getEdge(), edge.getAdjNode(), nTransfers, nWalkDistanceConstraintViolations, walkDistanceOnCurrentLeg, firstPtDepartureTime, walkTime, residualDelay, impossible, label);
-                        insertIfNotDominated(edge, sptEntries, newLabel);
+                        insertIfNotDominated(sptEntries, newLabel);
                     }
                 });
                 return true;
             }
         }
 
-        private void insertIfNotDominated(EdgeIteratorState edge, Collection<Label> sptEntries, Label label) {
+        private void insertIfNotDominated(Collection<Label> sptEntries, Label label) {
             if (isNotDominatedByAnyOf(label, sptEntries)) {
                 if (isNotDominatedByAnyOf(label, targetLabels)) {
                     removeDominated(label, sptEntries);
-                    fromMap.put(edge.getAdjNode(), label);
+                    sptEntries.add(label);
                     fromHeap.add(label);
                 }
             }
@@ -204,9 +243,8 @@ boolean isNotDominatedByAnyOf(Label me, Collection<Label> sptEntries) {
         return true;
     }
 
-
     void removeDominated(Label me, Collection<Label> sptEntries) {
-        for (Iterator<Label> iterator = sptEntries.iterator(); iterator.hasNext();) {
+        for (Iterator<Label> iterator = sptEntries.iterator(); iterator.hasNext(); ) {
             Label sptEntry = iterator.next();
             if (dominates(me, sptEntry)) {
                 fromHeap.remove(sptEntry);
@@ -231,7 +269,7 @@ private boolean dominates(Label me, Label they) {
 
         if (mindTransfers && me.nTransfers > they.nTransfers)
             return false;
-        if (me.nWalkDistanceConstraintViolations  > they.nWalkDistanceConstraintViolations)
+        if (me.nWalkDistanceConstraintViolations > they.nWalkDistanceConstraintViolations)
             return false;
         if (me.impossible && !they.impossible)
             return false;
@@ -247,12 +285,12 @@ private boolean dominates(Label me, Label they) {
                     return true;
             }
         }
-        if (mindTransfers && me.nTransfers  < they.nTransfers)
+        if (mindTransfers && me.nTransfers < they.nTransfers)
             return true;
         if (me.nWalkDistanceConstraintViolations < they.nWalkDistanceConstraintViolations)
             return true;
 
-        return queueComparator.compare(me,they) <= 0;
+        return queueComparator.compare(me, they) <= 0;
     }
 
     private Long departureTimeCriterion(Label label) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
index dd1cb35e1e..56200346d9 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
@@ -20,105 +20,75 @@
 
 import com.graphhopper.reader.ReaderRelation;
 import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.profiles.EncodedValue;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.IntEncodedValue;
+import com.graphhopper.routing.profiles.UnsignedIntEncodedValue;
 import com.graphhopper.routing.util.AbstractFlagEncoder;
-import com.graphhopper.routing.util.EncodedDoubleValue;
-import com.graphhopper.routing.util.EncodedValue;
-import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.IntsRef;
+
+import java.util.List;
 
 public class PtFlagEncoder extends AbstractFlagEncoder {
 
-	private final FootFlagEncoder footFlagEncoder;
-	private EncodedValue time;
-	private EncodedValue transfers;
-	private EncodedValue validityId;
-	private EncodedValue type;
-
-	public PtFlagEncoder() {
-		super(0, 1, 0);
-
-		// I use the foot flag encoder only as a delegate to filter by OSM tags,
-		// not to encode flags.
-		footFlagEncoder = new FootFlagEncoder();
-		// Still, I have to do this. Otherwise 'acceptWay' returns 0 even though
-		// it wants to accept. Basically, I have to tell it what 'true' means.
-		footFlagEncoder.defineWayBits(1, 0);
-		footFlagEncoder.defineRelationBits(1, 0);
-	}
-
-	@Override
-	public int defineWayBits(int index, int shift) {
-		shift = super.defineWayBits(index, shift);
-
-		// I have to set super.speedEncoder even though
-		// super already knows speedBits and speedFactor because they are constructor parameters.
-		speedEncoder = new EncodedDoubleValue("Speed", shift, speedBits, speedFactor, 0, 0);
-		shift += speedEncoder.getBits();
-
-		time = new EncodedValue("time", shift, 17, 1.0, 0, 24*60*60);
-		shift += time.getBits();
-		transfers = new EncodedValue("transfers", shift, 1, 1.0, 0, 1);
-		shift += transfers.getBits();
-		validityId = new EncodedValue("validityId", shift, 20, 1.0, 0, 1048575);
-		shift += validityId.getBits();
-		GtfsStorage.EdgeType[] edgeTypes = GtfsStorage.EdgeType.values();
-		type = new EncodedValue("type", shift, 4, 1.0, GtfsStorage.EdgeType.HIGHWAY.ordinal(), edgeTypes[edgeTypes.length-1].ordinal());
-		shift += type.getBits();
-		return shift;
-	}
-
-	@Override
-	public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
-		return footFlagEncoder.handleRelationTags(relation, oldRelationFlags);
-	}
-
-	@Override
-	public long acceptWay(ReaderWay way) {
-		return footFlagEncoder.acceptWay(way);
-	}
-
-	@Override
-	public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
-		return footFlagEncoder.handleWayTags(way, allowed, relationFlags);
-	}
-
-	long getTime(long flags) {
-        return time.getValue(flags);
+    private IntEncodedValue timeEnc;
+    private IntEncodedValue transfersEnc;
+    private IntEncodedValue validityIdEnc;
+    private EnumEncodedValue<GtfsStorage.EdgeType> typeEnc;
+
+    public PtFlagEncoder() {
+        super(0, 1, 0);
     }
 
-    long setTime(long flags, long time) {
-        return this.time.setValue(flags, time);
+    @Override
+    public void createEncodedValues(List<EncodedValue> list, String prefix, int index) {
+        // do we really need 2 bits for pt.access?
+        super.createEncodedValues(list, prefix, index);
+
+        list.add(validityIdEnc = new UnsignedIntEncodedValue(prefix + "validity_id", 20, false));
+        list.add(transfersEnc = new UnsignedIntEncodedValue(prefix + "transfers", 1, false));
+        list.add(typeEnc = new EnumEncodedValue<>(prefix + "type", GtfsStorage.EdgeType.class));
+        list.add(timeEnc = new UnsignedIntEncodedValue(prefix + "time", 17, false));
     }
 
-    int getTransfers(long flags) {
-		return (int) transfers.getValue(flags);
-	}
+    @Override
+    public long handleRelationTags(long oldRelationFlags, ReaderRelation relation) {
+        return oldRelationFlags;
+    }
 
-	long setTransfers(long flags, int transfers) {
-		return this.transfers.setValue(flags, transfers);
-	}
+    @Override
+    public EncodingManager.Access getAccess(ReaderWay way) {
+        return EncodingManager.Access.CAN_SKIP;
+    }
 
-	int getValidityId(long flags) {
-		return (int) validityId.getValue(flags);
-	}
+    @Override
+    public IntsRef handleWayTags(IntsRef edgeFlags, ReaderWay way, EncodingManager.Access access, long relationFlags) {
+        return edgeFlags;
+    }
 
-	long setValidityId(long flags, int validityId) {
-		return this.validityId.setValue(flags, validityId);
-	}
+    public IntEncodedValue getTimeEnc() {
+        return timeEnc;
+    }
 
-	GtfsStorage.EdgeType getEdgeType(long flags) {
-		return GtfsStorage.EdgeType.values()[(int) type.getValue(flags)];
-	}
+    public IntEncodedValue getTransfersEnc() {
+        return transfersEnc;
+    }
+
+    public IntEncodedValue getValidityIdEnc() {
+        return validityIdEnc;
+    }
 
-	long setEdgeType(long flags, GtfsStorage.EdgeType edgeType) {
-		return type.setValue(flags, edgeType.ordinal());
-	}
+    public EnumEncodedValue<GtfsStorage.EdgeType> getTypeEnc() {
+        return typeEnc;
+    }
 
-	public String toString() {
-		return "pt";
-	}
+    public String toString() {
+        return "pt";
+    }
 
-	@Override
-	public int getVersion() {
-		return 0;
-	}
+    @Override
+    public int getVersion() {
+        return 1;
+    }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index 714f7436d8..e605759a3c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -30,6 +30,7 @@
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphExtension;
 import com.graphhopper.storage.GraphHopperStorage;
@@ -42,24 +43,13 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.time.Duration;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.LocalTime;
-import java.time.ZoneId;
-import java.time.ZonedDateTime;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.time.*;
 import java.time.temporal.ChronoUnit;
-import java.util.ArrayList;
-import java.util.BitSet;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Set;
+import java.util.*;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.StreamSupport;
@@ -114,6 +104,7 @@ public static RealtimeFeed fromProtobuf(GraphHopperStorage graphHopperStorage, G
         final LinkedList<VirtualEdgeIteratorState> additionalEdges = new LinkedList<>();
         final Graph overlayGraph = new Graph() {
             int firstEdge = graphHopperStorage.getAllEdges().length();
+            EncodingManager encodingManager = graphHopperStorage.getEncodingManager();
             final NodeAccess nodeAccess = new NodeAccess() {
                 IntIntHashMap additionalNodeFields = new IntIntHashMap();
 
@@ -182,6 +173,7 @@ public double getEle(int nodeId) {
                     return 0;
                 }
             };
+
             @Override
             public Graph getBaseGraph() {
                 return graphHopperStorage;
@@ -190,9 +182,14 @@ public Graph getBaseGraph() {
             @Override
             public int getNodes() {
                 return IntStream.concat(
-                        IntStream.of(graphHopperStorage.getNodes()-1),
+                        IntStream.of(graphHopperStorage.getNodes() - 1),
                         additionalEdges.stream().flatMapToInt(edge -> IntStream.of(edge.getBaseNode(), edge.getAdjNode())))
-                        .max().getAsInt()+1;
+                        .max().getAsInt() + 1;
+            }
+
+            @Override
+            public int getEdges() {
+                return getAllEdges().length();
             }
 
             @Override
@@ -209,9 +206,9 @@ public BBox getBounds() {
             public EdgeIteratorState edge(int a, int b) {
                 int edge = firstEdge++;
                 final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(-1,
-                        edge, a, b, 0.0, 0, "", new PointList());
+                        edge, a, b, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
                 final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(-1,
-                        edge, b, a, 0.0, 0, "", new PointList());
+                        edge, b, a, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), true);
                 newEdge.setReverseEdge(reverseNewEdge);
                 reverseNewEdge.setReverseEdge(newEdge);
                 additionalEdges.push(newEdge);
@@ -252,6 +249,16 @@ public Graph copyTo(Graph g) {
             public GraphExtension getExtension() {
                 throw new RuntimeException();
             }
+
+            @Override
+            public int getOtherNode(int edge, int node) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public boolean isAdjacentToNode(int edge, int node) {
+                throw new UnsupportedOperationException();
+            }
         };
 
         Map<GtfsStorage.Validity, Integer> operatingDayPatterns = new HashMap<>(staticGtfs.getOperatingDayPatterns());
@@ -319,7 +326,7 @@ public GraphExtension getExtension() {
                 }
 
                 @Override
-                public Map<Integer, String> getRoutes() {
+                public Map<Integer, PlatformDescriptor> getRoutes() {
                     return staticGtfs.getRoutes();
                 }
             };
@@ -327,7 +334,7 @@ public GraphExtension getExtension() {
             Instant timestamp = Instant.ofEpochSecond(feedMessage.getHeader().getTimestamp());
             LocalDate dateToChange = timestamp.atZone(timezone).toLocalDate(); //FIXME
             BitSet validOnDay = new BitSet();
-            LocalDate startDate = feed.calculateStats().getStartDate();
+            LocalDate startDate = feed.getStartDate();
             validOnDay.set((int) DAYS.between(startDate, dateToChange));
             feedMessage.getEntityList().stream()
                     .filter(GtfsRealtime.FeedEntity::hasTripUpdate)
@@ -352,8 +359,8 @@ public GraphExtension getExtension() {
                                 });
                         GtfsReader.TripWithStopTimes tripWithStopTimes = toTripWithStopTimes(feed, tripUpdate);
                         tripWithStopTimes.stopTimes.forEach(stopTime -> {
-                            if (stopTime.stop_sequence > leaveEdges.length-1) {
-                                logger.warn("Stop sequence number too high {} vs {}",stopTime.stop_sequence, leaveEdges.length);
+                            if (stopTime.stop_sequence > leaveEdges.length - 1) {
+                                logger.warn("Stop sequence number too high {} vs {}", stopTime.stop_sequence, leaveEdges.length);
                                 return;
                             }
                             final StopTime originalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), stopTime.stop_sequence));
@@ -392,7 +399,7 @@ public GraphExtension getExtension() {
                         GtfsReader.TripWithStopTimes tripWithStopTimes = new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay, Collections.emptySet(), Collections.emptySet());
                         gtfsReader.addTrip(timezone, 0, new ArrayList<>(), tripWithStopTimes, tripUpdate.getTrip(), false);
                     });
-            gtfsReader.wireUpAdditionalDepartures(timezone);
+            gtfsReader.wireUpAdditionalDeparturesAndArrivals(timezone);
         });
 
         return new RealtimeFeed(staticGtfs, feedMessages, blockedEdges, delaysForBoardEdges, delaysForAlightEdges, additionalEdges, tripDescriptors, stopSequences, operatingDayPatterns, writableTimeZones);
@@ -407,17 +414,28 @@ boolean isBlocked(int edgeId) {
     }
 
     public Optional<GtfsReader.TripWithStopTimes> getTripUpdate(GTFSFeed staticFeed, GtfsRealtime.TripDescriptor tripDescriptor, Label.Transition boardEdge, Instant boardTime) {
-        logger.trace("getTripUpdate {}", tripDescriptor);
-        if (!isThisRealtimeUpdateAboutThisLineRun(boardEdge.edge.edgeIteratorState, boardTime)) {
+        try {
+            logger.trace("getTripUpdate {}", tripDescriptor);
+            if (!isThisRealtimeUpdateAboutThisLineRun(boardEdge.edge.edgeIteratorState, boardTime)) {
+                return Optional.empty();
+            } else {
+                GtfsRealtime.TripDescriptor normalizedTripDescriptor = normalize(tripDescriptor);
+                return feedMessages.values().stream().flatMap(feedMessage -> feedMessage.getEntityList().stream()
+                        .filter(e -> e.hasTripUpdate())
+                        .map(e -> e.getTripUpdate())
+                        .filter(tu -> normalize(tu.getTrip()).equals(normalizedTripDescriptor))
+                        .map(tu -> toTripWithStopTimes(staticFeed, tu)))
+                        .findFirst();
+            }
+        } catch (RuntimeException e) {
+            feedMessages.forEach((name, feed) -> {
+                try (OutputStream s = new FileOutputStream(name+".gtfsdump")) {
+                    feed.writeTo(s);
+                } catch (IOException e1) {
+                    throw new RuntimeException();
+                }
+            });
             return Optional.empty();
-        } else {
-            GtfsRealtime.TripDescriptor normalizedTripDescriptor = normalize(tripDescriptor);
-            return feedMessages.values().stream().flatMap(feedMessage -> feedMessage.getEntityList().stream()
-                    .filter(e -> e.hasTripUpdate())
-                    .map(e -> e.getTripUpdate())
-                    .filter(tu -> normalize(tu.getTrip()).equals(normalizedTripDescriptor))
-                    .map(tu -> toTripWithStopTimes(staticFeed, tu)))
-                    .findFirst();
         }
     }
 
@@ -454,8 +472,8 @@ boolean isBlocked(int edgeId) {
         ) + 1;
         stopTimeUpdateListWithSentinel.add(GtfsRealtime.TripUpdate.StopTimeUpdate.newBuilder().setStopSequence(stopSequenceCeiling).setScheduleRelationship(NO_DATA).build());
         for (GtfsRealtime.TripUpdate.StopTimeUpdate stopTimeUpdate : stopTimeUpdateListWithSentinel) {
-            int nextStopSequence = stopTimes.isEmpty() ? 1 : stopTimes.get(stopTimes.size()-1).stop_sequence+1;
-            for (int i=nextStopSequence; i<stopTimeUpdate.getStopSequence(); i++) {
+            int nextStopSequence = stopTimes.isEmpty() ? 1 : stopTimes.get(stopTimes.size() - 1).stop_sequence + 1;
+            for (int i = nextStopSequence; i < stopTimeUpdate.getStopSequence(); i++) {
                 StopTime previousOriginalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), i));
                 if (previousOriginalStopTime == null) {
                     continue; // This can and does happen. Stop sequence numbers can be left out.
@@ -508,6 +526,9 @@ boolean isBlocked(int edgeId) {
                 stopTimes.add(stopTime);
                 logger.trace("Number of stop times: {}", stopTimes.size());
             } else {
+                // http://localhost:3000/route?point=45.51043713898763%2C-122.68381118774415&point=45.522104713562825%2C-122.6455307006836&weighting=fastest&pt.earliest_departure_time=2018-08-24T16%3A56%3A17Z&arrive_by=false&pt.max_walk_distance_per_leg=1000&pt.limit_solutions=5&locale=en-US&vehicle=pt&elevation=false&use_miles=false&points_encoded=false&pt.profile=true
+                // long query:
+                // http://localhost:3000/route?point=45.518526513612244%2C-122.68612861633302&point=45.52908004573869%2C-122.6862144470215&weighting=fastest&pt.earliest_departure_time=2018-08-24T16%3A51%3A20Z&arrive_by=false&pt.max_walk_distance_per_leg=10000&pt.limit_solutions=4&locale=en-US&vehicle=pt&elevation=false&use_miles=false&points_encoded=false&pt.profile=true
                 throw new RuntimeException();
             }
         }
@@ -562,7 +583,7 @@ public int getStopSequence(int edge) {
     public StopTime getStopTime(GTFSFeed staticFeed, GtfsRealtime.TripDescriptor tripDescriptor, Label.Transition t, Instant boardTime, int stopSequence) {
         StopTime stopTime = staticFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
         if (stopTime == null) {
-            return getTripUpdate(staticFeed, tripDescriptor, t, boardTime).get().stopTimes.get(stopSequence-1);
+            return getTripUpdate(staticFeed, tripDescriptor, t, boardTime).get().stopTimes.get(stopSequence - 1);
         } else {
             return stopTime;
         }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java
new file mode 100644
index 0000000000..c328a55d93
--- /dev/null
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Request.java
@@ -0,0 +1,152 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.shapes.GHPoint;
+
+import java.time.Instant;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+
+public class Request {
+    private List<GHLocation> points;
+    private Instant earliestDepartureTime;
+    private int maxVisitedNodes = 1_000_000;
+    private boolean profileQuery;
+    private Boolean ignoreTransfers;
+    private double betaTransfers = 0.0;
+    private double betaWalkTime = 1.0;
+    private Integer limitSolutions;
+    private boolean arriveBy;
+    private double walkSpeedKmH = 5.0;
+    private int blockedRouteTypes;
+    private Locale locale = Helper.getLocale("en");
+    private double maxWalkDistancePerLeg = Integer.MAX_VALUE;
+
+    public Request(List<GHLocation> points, Instant departureTime) {
+        this.points = points;
+        this.earliestDepartureTime = departureTime;
+    }
+
+    public Request(double from_lat, double from_lon, double to_lat, double to_lon) {
+        this.points = Arrays.asList(new GHPointLocation(new GHPoint(from_lat, from_lon)), new GHPointLocation(new GHPoint(to_lat, to_lon)));
+    }
+
+    public int getMaxVisitedNodes() {
+        return maxVisitedNodes;
+    }
+
+    public void setMaxVisitedNodes(int maxVisitedNodes) {
+        this.maxVisitedNodes = maxVisitedNodes;
+    }
+
+    public boolean isProfileQuery() {
+        return profileQuery;
+    }
+
+    public void setProfileQuery(boolean profileQuery) {
+        this.profileQuery = profileQuery;
+    }
+
+    public Boolean getIgnoreTransfers() {
+        return ignoreTransfers;
+    }
+
+    public void setIgnoreTransfers(Boolean ignoreTransfers) {
+        this.ignoreTransfers = ignoreTransfers;
+    }
+
+    public double getBetaTransfers() {
+        return betaTransfers;
+    }
+
+    public void setBetaTransfers(double betaTransfers) {
+        this.betaTransfers = betaTransfers;
+    }
+
+    public double getBetaWalkTime() {
+        return betaWalkTime;
+    }
+
+    public void setBetaWalkTime(double betaWalkTime) {
+        this.betaWalkTime = betaWalkTime;
+    }
+
+    public Integer getLimitSolutions() {
+        return limitSolutions;
+    }
+
+    public void setLimitSolutions(Integer limitSolutions) {
+        this.limitSolutions = limitSolutions;
+    }
+
+    public Instant getEarliestDepartureTime() {
+        return earliestDepartureTime;
+    }
+
+    public void setEarliestDepartureTime(Instant earliestDepartureTime) {
+        this.earliestDepartureTime = earliestDepartureTime;
+    }
+
+    public boolean isArriveBy() {
+        return arriveBy;
+    }
+
+    public void setArriveBy(boolean arriveBy) {
+        this.arriveBy = arriveBy;
+    }
+
+    public double getWalkSpeedKmH() {
+        return walkSpeedKmH;
+    }
+
+    public void setWalkSpeedKmH(double walkSpeedKmH) {
+        this.walkSpeedKmH = walkSpeedKmH;
+    }
+
+    public int getBlockedRouteTypes() {
+        return blockedRouteTypes;
+    }
+
+    public void setBlockedRouteTypes(int blockedRouteTypes) {
+        this.blockedRouteTypes = blockedRouteTypes;
+    }
+
+    public Locale getLocale() {
+        return locale;
+    }
+
+    public void setLocale(Locale locale) {
+        this.locale = locale;
+    }
+
+    public List<GHLocation> getPoints() {
+        return points;
+    }
+
+    public double getMaxWalkDistancePerLeg() {
+        return maxWalkDistancePerLeg;
+    }
+
+    public void setMaxWalkDistancePerLeg(double maxWalkDistancePerLeg) {
+        this.maxWalkDistancePerLeg = maxWalkDistancePerLeg;
+    }
+}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
index b819541b94..4577bacada 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Transfers.java
@@ -94,10 +94,10 @@ private Transfer findMostSpecificRule(List<Transfer> transfers, String fromRoute
         final ArrayList<Transfer> transfersBySpecificity = new ArrayList<>(transfers);
         transfersBySpecificity.sort(Comparator.comparingInt(t -> {
             int score = 0;
-            if (fromRouteId.equals(t.from_route_id)) {
+            if (Objects.equals(fromRouteId, t.from_route_id)) {
                 score++;
             }
-            if (toRouteId.equals(t.to_route_id)) {
+            if (Objects.equals(toRouteId, t.to_route_id)) {
                 score++;
             }
             return -score;
@@ -108,4 +108,11 @@ private Transfer findMostSpecificRule(List<Transfer> transfers, String fromRoute
         return transfersBySpecificity.get(0);
     }
 
+    public boolean hasNoRouteSpecificDepartureTransferRules(String stop_id) {
+        return transfersToStop.getOrDefault(stop_id, Collections.emptyList()).stream().allMatch(transfer -> transfer.to_route_id == null);
+    }
+
+    public boolean hasNoRouteSpecificArrivalTransferRules(String stop_id) {
+        return transfersFromStop.getOrDefault(stop_id, Collections.emptyList()).stream().allMatch(transfer -> transfer.from_route_id == null);
+    }
 }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 70b9f4550e..c34a7cd7a8 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -27,11 +27,13 @@
 import com.graphhopper.Trip;
 import com.graphhopper.gtfs.fare.Fares;
 import com.graphhopper.routing.InstructionsFromEdges;
+import com.graphhopper.routing.profiles.Roundabout;
 import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
 import com.graphhopper.util.*;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.Geometry;
-import com.vividsolutions.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.Geometry;
+import org.locationtech.jts.geom.GeometryFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -59,11 +61,6 @@
         this.realtimeFeed = realtimeFeed;
     }
 
-    PathWrapper parseSolutionIntoPath(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution, PointList waypoints) {
-        final List<Trip.Leg> legs = getTrip(arriveBy, encoder, tr, queryGraph, weighting, solution);
-        return createPathWrapper(tr, waypoints, legs);
-    }
-
     PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg> legs) {
         if (legs.size() > 1 && legs.get(0) instanceof Trip.WalkLeg) {
             final Trip.WalkLeg accessLeg = (Trip.WalkLeg) legs.get(0);
@@ -119,18 +116,13 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return path;
     }
 
-    List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution) {
-        List<Label.Transition> transitions = getTransitions(arriveBy, encoder, queryGraph, solution);
-        return getTrip(tr, queryGraph, weighting, transitions);
-    }
-
-    List<Trip.Leg> getTrip(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<Label.Transition> transitions) {
+    List<Trip.Leg> getTrip(Translation tr, Graph queryGraph, Weighting weighting, List<Label.Transition> transitions) {
         final List<List<Label.Transition>> partitions = getPartitions(transitions);
         final List<Trip.Leg> legs = getLegs(tr, queryGraph, weighting, partitions);
         return legs;
     }
 
-    List<Label.Transition> getTransitions(boolean arriveBy, PtFlagEncoder encoder, GraphExplorer queryGraph, Label solution) {
+    List<Label.Transition> getTransitions(boolean arriveBy, PtFlagEncoder encoder, Graph queryGraph, Label solution) {
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
             reverseEdges(solution, queryGraph, encoder, false)
@@ -161,7 +153,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
         return partitions;
     }
 
-    private List<Trip.Leg> getLegs(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<List<Label.Transition>> partitions) {
+    private List<Trip.Leg> getLegs(Translation tr, Graph queryGraph, Weighting weighting, List<List<Label.Transition>> partitions) {
         return partitions.stream().flatMap(partition -> parsePathIntoLegs(partition, queryGraph, weighting, tr).stream()).collect(Collectors.toList());
     }
 
@@ -193,7 +185,7 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
                 arrivalPointList.add(arrivalStop.geometry.getY(), arrivalStop.geometry.getX());
                 Instruction arrivalInstruction = new Instruction(Instruction.PT_END_TRIP, arrivalStop.stop_name, InstructionAnnotation.EMPTY, arrivalPointList);
                 if (ptLeg.isInSameVehicleAsPrevious) {
-                    instructions.replaceLast(arrivalInstruction);
+                    instructions.set(instructions.size() - 1, arrivalInstruction);
                 } else {
                     instructions.add(arrivalInstruction);
                 }
@@ -329,7 +321,7 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
     // One could argue that one should never write a parser
     // by hand, because it is always ugly, but use a parser library.
     // The code would then read like a specification of what paths through the graph mean.
-    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, GraphExplorer graph, Weighting weighting, Translation tr) {
+    private List<Trip.Leg> parsePathIntoLegs(List<Label.Transition> path, Graph graph, Weighting weighting, Translation tr) {
         if (path.size() <= 1) {
             return Collections.emptyList();
         }
@@ -378,8 +370,8 @@ private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
             return result;
         } else {
             InstructionList instructions = new InstructionList(tr);
-            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph.getGraph(),
-                    weighting, weighting.getFlagEncoder(), graph.getNodeAccess(), tr, instructions);
+            InstructionsFromEdges instructionsFromEdges = new InstructionsFromEdges(path.get(1).edge.edgeIteratorState.getBaseNode(), graph,
+                    weighting, weighting.getFlagEncoder(), weighting.getFlagEncoder().getBooleanEncodedValue(Roundabout.KEY), graph.getNodeAccess(), tr, instructions);
             int prevEdgeId = -1;
             for (int i = 1; i < path.size(); i++) {
                 if (path.get(i).edge.edgeType != GtfsStorage.EdgeType.HIGHWAY) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
index 3255171196..adbb9bc776 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
@@ -18,57 +18,85 @@
 
 package com.graphhopper.reader.gtfs;
 
+import com.carrotsearch.hppc.IntObjectHashMap;
+import com.carrotsearch.hppc.IntObjectMap;
+import com.google.common.collect.ArrayListMultimap;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
+import com.graphhopper.routing.profiles.EnumEncodedValue;
+import com.graphhopper.routing.profiles.IntEncodedValue;
 import com.graphhopper.routing.util.AllEdgesIterator;
 import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.IntsRef;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIterator;
 import com.graphhopper.util.EdgeIteratorState;
 import com.graphhopper.util.PointList;
 import com.graphhopper.util.shapes.BBox;
 
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.stream.IntStream;
+import java.util.stream.StreamSupport;
 
 public class WrapperGraph implements Graph {
 
-    private final Graph baseGraph;
-    private final List<VirtualEdgeIteratorState> extraEdges;
+    private final Graph mainGraph;
+    private final IntObjectMap<EdgeIteratorState> extraEdges = new IntObjectHashMap<>();
+    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
+    private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
 
-    public WrapperGraph(Graph baseGraph, List<VirtualEdgeIteratorState> extraEdges) {
-        this.baseGraph = baseGraph;
-        this.extraEdges = extraEdges;
+
+    public WrapperGraph(Graph mainGraph, List<VirtualEdgeIteratorState> extraEdges) {
+        this.mainGraph = mainGraph;
+        extraEdges.forEach(e -> this.extraEdges.put(e.getEdge(), e));
+        for (VirtualEdgeIteratorState extraEdge : extraEdges) {
+            if (extraEdge == null) {
+                throw new RuntimeException();
+            }
+            extraEdgesBySource.put(extraEdge.getBaseNode(), extraEdge);
+            extraEdgesByDestination.put(extraEdge.getAdjNode(), new VirtualEdgeIteratorState(extraEdge.getOriginalEdgeKey(), extraEdge.getEdge(), extraEdge.getAdjNode(),
+                    extraEdge.getBaseNode(), extraEdge.getDistance(), extraEdge.getFlags(), extraEdge.getName(), extraEdge.fetchWayGeometry(3), true));
+        }
     }
 
     @Override
     public Graph getBaseGraph() {
-        return baseGraph;
+        return this;
     }
 
     @Override
     public int getNodes() {
         return IntStream.concat(
-                IntStream.of(baseGraph.getNodes()-1),
-                extraEdges.stream().flatMapToInt(edge -> IntStream.of(edge.getBaseNode(), edge.getAdjNode())))
-                .max().getAsInt()+1;
+                IntStream.of(mainGraph.getNodes() - 1),
+                StreamSupport.stream(extraEdges.values().spliterator(), false)
+                        .flatMapToInt(cursor -> IntStream.of(cursor.value.getBaseNode(), cursor.value.getAdjNode()))
+        ).max().getAsInt() + 1;
+    }
+
+    @Override
+    public int getEdges() {
+        return getAllEdges().length();
     }
 
     @Override
     public NodeAccess getNodeAccess() {
-        return baseGraph.getNodeAccess();
+        return mainGraph.getNodeAccess();
     }
 
     @Override
     public BBox getBounds() {
-        return baseGraph.getBounds();
+        return mainGraph.getBounds();
     }
 
     @Override
     public EdgeIteratorState edge(int a, int b) {
-        return baseGraph.getEdgeIteratorState(a, b);
+        throw new RuntimeException();
     }
 
     @Override
@@ -78,7 +106,12 @@ public EdgeIteratorState edge(int a, int b, double distance, boolean bothDirecti
 
     @Override
     public EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
-        return baseGraph.getEdgeIteratorState(edgeId, adjNode);
+        EdgeIteratorState edgeIteratorState = extraEdges.get(edgeId);
+        if (edgeIteratorState != null) {
+            return edgeIteratorState;
+        } else {
+            return mainGraph.getEdgeIteratorState(edgeId, adjNode);
+        }
     }
 
     @Override
@@ -87,9 +120,9 @@ public AllEdgesIterator getAllEdges() {
             @Override
             public int length() {
                 return IntStream.concat(
-                        IntStream.of(baseGraph.getAllEdges().length() - 1),
-                        extraEdges.stream().mapToInt(VirtualEdgeIteratorState::getEdge))
-                        .max().getAsInt();
+                        IntStream.of(mainGraph.getAllEdges().length() - 1),
+                        StreamSupport.stream(extraEdges.values().spliterator(), false).mapToInt(cursor -> cursor.value.getEdge()))
+                        .max().getAsInt() + 1;
             }
 
             @Override
@@ -102,6 +135,16 @@ public int getEdge() {
                 throw new UnsupportedOperationException();
             }
 
+            @Override
+            public int getOrigEdgeFirst() {
+                return getEdge();
+            }
+
+            @Override
+            public int getOrigEdgeLast() {
+                return getEdge();
+            }
+
             @Override
             public int getBaseNode() {
                 throw new UnsupportedOperationException();
@@ -133,12 +176,12 @@ public EdgeIteratorState setDistance(double dist) {
             }
 
             @Override
-            public long getFlags() {
+            public IntsRef getFlags() {
                 throw new UnsupportedOperationException();
             }
 
             @Override
-            public EdgeIteratorState setFlags(long flags) {
+            public EdgeIteratorState setFlags(IntsRef flags) {
                 throw new UnsupportedOperationException();
             }
 
@@ -153,17 +196,82 @@ public EdgeIteratorState setAdditionalField(int value) {
             }
 
             @Override
-            public boolean isForward(FlagEncoder encoder) {
+            public boolean get(BooleanEncodedValue property) {
                 throw new UnsupportedOperationException();
             }
 
             @Override
-            public boolean isBackward(FlagEncoder encoder) {
+            public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
                 throw new UnsupportedOperationException();
             }
 
             @Override
-            public boolean getBool(int key, boolean _default) {
+            public boolean getReverse(BooleanEncodedValue property) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int get(IntEncodedValue property) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public int getReverse(IntEncodedValue property) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState set(IntEncodedValue property, int value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public double get(DecimalEncodedValue property) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public double getReverse(DecimalEncodedValue property) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public <T extends Enum> T get(EnumEncodedValue<T> property) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+                throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
                 throw new UnsupportedOperationException();
             }
 
@@ -183,7 +291,7 @@ public EdgeIteratorState detach(boolean reverse) {
             }
 
             @Override
-            public EdgeIteratorState copyPropertiesTo(EdgeIteratorState e) {
+            public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e) {
                 throw new UnsupportedOperationException();
             }
         };
@@ -191,12 +299,235 @@ public EdgeIteratorState copyPropertiesTo(EdgeIteratorState e) {
 
     @Override
     public EdgeExplorer createEdgeExplorer(EdgeFilter filter) {
-        return baseGraph.createEdgeExplorer(filter);
+        EdgeExplorer baseGraphEdgeExplorer = mainGraph.createEdgeExplorer(filter);
+        return new EdgeExplorer() {
+            @Override
+            public EdgeIterator setBaseNode(int baseNode) {
+                final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+                extraEdges.addAll(extraEdgesBySource.get(baseNode));
+                extraEdges.addAll(extraEdgesByDestination.get(baseNode));
+                Iterator<VirtualEdgeIteratorState> iterator = extraEdges.iterator();
+                return new EdgeIterator() {
+
+                    EdgeIteratorState current = null;
+                    EdgeIterator baseGraphEdgeIterator = baseGraphIterator();
+                    private EdgeIterator baseGraphIterator() {
+                        if (baseNode < mainGraph.getNodes()) {
+                            return baseGraphEdgeExplorer.setBaseNode(baseNode);
+                        } else {
+                            return null;
+                        }
+                    }
+
+                    @Override
+                    public boolean next() {
+                        if (baseGraphEdgeIterator != null) {
+                            if (baseGraphEdgeIterator.next()) {
+                                current = baseGraphEdgeIterator;
+                                return true;
+                            } else {
+                                baseGraphEdgeIterator = null;
+                            }
+                        }
+                        while(iterator.hasNext()) {
+                            current = iterator.next();
+                            if (filter.accept(current)) {
+                                return true;
+                            }
+                        }
+                        return false;
+                    }
+
+                    @Override
+                    public int getEdge() {
+                        return current.getEdge();
+                    }
+
+                    @Override
+                    public int getOrigEdgeFirst() {
+                        return current.getOrigEdgeFirst();
+                    }
+
+                    @Override
+                    public int getOrigEdgeLast() {
+                        return current.getOrigEdgeLast();
+                    }
+
+                    @Override
+                    public int getBaseNode() {
+                        return current.getBaseNode();
+                    }
+
+                    @Override
+                    public int getAdjNode() {
+                        return current.getAdjNode();
+                    }
+
+                    @Override
+                    public PointList fetchWayGeometry(int mode) {
+                        return current.fetchWayGeometry(mode);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setWayGeometry(PointList list) {
+                        current.setWayGeometry(list);
+                        return this;
+                    }
+
+                    @Override
+                    public double getDistance() {
+                        return current.getDistance();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setDistance(double dist) {
+                        current.setDistance(dist);
+                        return this;
+                    }
+
+                    @Override
+                    public IntsRef getFlags() {
+                        return current.getFlags();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setFlags(IntsRef edgeFlags) {
+                        current.setFlags(edgeFlags);
+                        return this;
+                    }
+
+                    @Override
+                    public int getAdditionalField() {
+                        return current.getAdditionalField();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setAdditionalField(int value) {
+                        current.setAdditionalField(value);
+                        return this;
+                    }
+
+                    @Override
+                    public boolean get(BooleanEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(BooleanEncodedValue property, boolean value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public boolean getReverse(BooleanEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(BooleanEncodedValue property, boolean value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public int get(IntEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(IntEncodedValue property, int value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public int getReverse(IntEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(IntEncodedValue property, int value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public double get(DecimalEncodedValue property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState set(DecimalEncodedValue property, double value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public double getReverse(DecimalEncodedValue property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public EdgeIteratorState setReverse(DecimalEncodedValue property, double value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public <T extends Enum> T get(EnumEncodedValue<T> property) {
+                        return current.get(property);
+                    }
+
+                    @Override
+                    public <T extends Enum> EdgeIteratorState set(EnumEncodedValue<T> property, T value) {
+                        current.set(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public <T extends Enum> T getReverse(EnumEncodedValue<T> property) {
+                        return current.getReverse(property);
+                    }
+
+                    @Override
+                    public <T extends Enum> EdgeIteratorState setReverse(EnumEncodedValue<T> property, T value) {
+                        current.setReverse(property, value);
+                        return this;
+                    }
+
+                    @Override
+                    public String getName() {
+                        return current.getName();
+                    }
+
+                    @Override
+                    public EdgeIteratorState setName(String name) {
+                        current.setName(name);
+                        return this;
+                    }
+
+                    @Override
+                    public EdgeIteratorState detach(boolean reverse) {
+                        return current.detach(reverse);
+                    }
+
+                    @Override
+                    public EdgeIteratorState copyPropertiesFrom(EdgeIteratorState e) {
+                        return current.copyPropertiesFrom(e);
+                    }
+
+                    @Override
+                    public String toString() {
+                        return current.toString();
+                    }
+                };
+            }
+        };
     }
 
     @Override
     public EdgeExplorer createEdgeExplorer() {
-        return baseGraph.createEdgeExplorer();
+        return createEdgeExplorer(EdgeFilter.ALL_EDGES);
     }
 
     @Override
@@ -206,6 +537,16 @@ public Graph copyTo(Graph g) {
 
     @Override
     public GraphExtension getExtension() {
-        return baseGraph.getExtension();
+        return mainGraph.getExtension();
+    }
+
+    @Override
+    public int getOtherNode(int edge, int node) {
+        return mainGraph.getOtherNode(edge, node);
+    }
+
+    @Override
+    public boolean isAdjacentToNode(int edge, int node) {
+        return mainGraph.isAdjacentToNode(edge, node);
     }
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
index 686e1c46b2..97eaa2cf1d 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
@@ -18,9 +18,7 @@
 
 package com.graphhopper;
 
-import com.graphhopper.reader.gtfs.GraphHopperGtfs;
-import com.graphhopper.reader.gtfs.GtfsStorage;
-import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.*;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
@@ -28,6 +26,7 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.GHPoint;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -55,7 +54,7 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Arrays.asList("files/sample-feed.zip", "files/another-sample-feed.zip"), Collections.emptyList());
@@ -74,12 +73,12 @@ public static void close() {
     public void testRoute1() {
         final double FROM_LAT = 36.9010208, FROM_LON = -116.7659466;
         final double TO_LAT =  36.9059371, TO_LON = -116.7618071;
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,9,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,9,0,0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index dc19f9e50f..c35bbf9b46 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -21,6 +21,7 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
@@ -29,7 +30,6 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Instruction;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.Assume;
 import org.junit.BeforeClass;
@@ -47,9 +47,7 @@
 import java.util.stream.Stream;
 
 import static com.graphhopper.reader.gtfs.GtfsHelper.time;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.*;
 
 public class GraphHopperGtfsIT {
 
@@ -67,7 +65,7 @@ public static void init() {
         final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
         final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
 
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(carFlagEncoder, footFlagEncoder, ptFlagEncoder), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(carFlagEncoder, ptFlagEncoder, footFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
@@ -86,12 +84,12 @@ public static void close() {
     public void testRoute1() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -103,11 +101,11 @@ public void testRoute1() {
     public void testRoute1DoesNotGoAt654() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,54).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 54).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -119,13 +117,13 @@ public void testRoute1DoesNotGoAt654() {
     public void testRoute1GoesAt744() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,7,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.BLOCKED_ROUTE_TYPES, 1); // Blocking trams shouldn't matter, this is a bus.
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setBlockedRouteTypes(1); // Blocking trams shouldn't matter, this is a bus.
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -137,12 +135,12 @@ public void testRoute1GoesAt744() {
     public void testNoSolutionIfIDontLikeBusses() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,7,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.BLOCKED_ROUTE_TYPES, 8);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 44).atZone(zoneId).toInstant());
+        ghRequest.setBlockedRouteTypes(8);
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -153,12 +151,12 @@ public void testNoSolutionIfIDontLikeBusses() {
     public void testRoute1ArriveBy() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6, 49).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 49).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse route = graphHopper.route(ghRequest);
 
@@ -172,13 +170,13 @@ public void testRoute1ArriveBy() {
     public void testRoute1ArriveBy2() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
         // Tests that it also works when the query arrival time is not exactly the scheduled arrival time of the solution
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6, 50).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 50).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse route = graphHopper.route(ghRequest);
 
@@ -193,14 +191,14 @@ public void testRoute1ArriveBy2() {
     public void testRoute1ProfileEarliestArrival() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 21);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(21);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -218,14 +216,14 @@ public void testRoute1ProfileEarliestArrival() {
     public void testRoute1ProfileOvernight() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,23,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 21);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 23, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(21);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -243,15 +241,15 @@ public void testRoute1ProfileOvernight() {
     public void testRoute1ProfileLatestDeparture() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,13,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 4);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 13, 0).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
+        ghRequest.setProfileQuery(true);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setLimitSolutions(4);
 
         GHResponse response = graphHopper.route(ghRequest);
         List<LocalTime> actualDepartureTimes = response.getAll().stream()
@@ -289,14 +287,14 @@ public void testRoute4() {
     public void testRoute5() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
         GHResponse route = graphHopper.route(ghRequest);
 
-        assertFalse(route.hasErrors());
+        assertFalse(route.toString(), route.hasErrors());
         assertFalse(route.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(8, 10), route.getBest().getTime(), 0.1);
         assertEquals("Using expected route", "STBA", (((Trip.PtLeg) route.getBest().getLegs().get(0)).trip_id));
@@ -308,12 +306,12 @@ public void testRoute5() {
     public void testRoute5Arrival() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,10).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 8, 10).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -335,12 +333,12 @@ public void testRouteWithLaterDepartureTime() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.914894, TO_LON = -116.76821; // NADAV stop
         // Missed the bus at 10 by one minute, will have to use the 10:30 one.
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,10, 1).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 10, 1).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -352,11 +350,11 @@ public void testRouteWithLaterDepartureTime() {
     public void testWeekendRouteWorksOnlyOnWeekend() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.641496, TO_LON = -116.40094; // AMV stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant()); // Monday morning
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant()); // Monday morning
 
 
         GHResponse route = graphHopper.route(ghRequest);
@@ -364,11 +362,11 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
         // On Mondays, there is only a complicated evening trip.
         assertEquals("Expected travel time == scheduled travel time", time(22, 0), route.getBest().getTime());
 
-        ghRequest = new GHRequest(
+        ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,0,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 0, 0).atZone(zoneId).toInstant());
         route = graphHopper.route(ghRequest);
         assertFalse(route.getAll().isEmpty());
         assertEquals("Expected travel time == scheduled travel time", time(9, 0), route.getBest().getTime());
@@ -381,14 +379,14 @@ public void testWeekendRouteWorksOnlyOnWeekend() {
     public void testBlockTrips() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.425288, TO_LON = -117.133162; // FUR_CREEK_RES stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 8, 0).atZone(zoneId).toInstant());
         GHResponse response = graphHopper.route(ghRequest);
         assertEquals("Only find one solution. If blocks wouldn't work, there would be two. (There is a slower alternative without transfer.)", 1, response.getAll().size());
-        assertEquals("Expected travel time == scheduled travel time", time(1,20), response.getBest().getTime());
+        assertEquals("Expected travel time == scheduled travel time", time(1, 20), response.getBest().getTime());
         assertEquals("Two legs: pt, pt, but the two pt legs are in one vehicle, so...", 2, response.getBest().getLegs().size());
         assertEquals("...one boarding instruction", 1, response.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_START_TRIP).count());
         assertEquals("...and one alighting instruction", 1, response.getBest().getInstructions().stream().filter(i -> i.getSign() == Instruction.PT_END_TRIP).count());
@@ -398,11 +396,11 @@ public void testBlockTrips() {
     public void testBlockWithComplicatedValidityIntersections() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.641496, TO_LON = -116.40094; // AMV stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,18,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 18, 0).atZone(zoneId).toInstant());
         GHResponse response = graphHopper.route(ghRequest);
         PathWrapper mondayTrip = response.getBest();
         assertEquals("Monday trip has no transfers", 0, mondayTrip.getNumChanges());
@@ -411,7 +409,7 @@ public void testBlockWithComplicatedValidityIntersections() {
         assertEquals("FUNNY_BLOCK_BFC1", (((Trip.PtLeg) mondayTrip.getLegs().get(1)).trip_id));
         assertEquals("FUNNY_BLOCK_FCAMV1", (((Trip.PtLeg) mondayTrip.getLegs().get(2)).trip_id));
 
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,7,18,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 7, 18, 0).atZone(zoneId).toInstant());
         response = graphHopper.route(ghRequest);
         PathWrapper sundayTrip = response.getBest();
         assertEquals("Sunday trip has no transfers", 0, sundayTrip.getNumChanges());
@@ -431,38 +429,29 @@ public void testTransferRules() {
         final double TO1_LAT = 36.641496, TO1_LON = -116.40094; // AMV stop
         final double TO2_LAT = 36.88108, TO2_LON = -116.81797; // BULLFROG stop
 
-        GHRequest request = new GHRequest(
+        Request request = new Request(
                 FROM_LAT, FROM_LON,
                 TO1_LAT, TO1_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
 
         GHResponse response = graphHopper.route(request);
         assertEquals("Transfer rule: 11 minutes. Will miss connection, and be there at 14.", time(6, 30), response.getBest().getTime());
 
-        request = new GHRequest(
-                FROM_LAT, FROM_LON,
-                TO2_LAT, TO2_LON
-        );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
-
-        response = graphHopper.route(request);
-        assertEquals("Ignoring transfer rules (free walking): Will be there at 8:10.", time(0, 40), response.getBest().getTime());
-
-        request = new GHRequest(
+        request = new Request(
                 FROM_LAT, FROM_LON,
                 TO2_LAT, TO2_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,7,30).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 7, 30).atZone(zoneId).toInstant());
 
         response = graphHopper.route(request);
         assertEquals("Will still be there at 8:10 because there is a route-specific exception for this route.", time(0, 40), response.getBest().getTime());
 
-        request = new GHRequest(
+        request = new Request(
                 TO2_LAT, TO2_LON,
                 FROM_LAT, FROM_LON
         );
-        request.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,6,12,5).atZone(zoneId).toInstant());
+        request.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 6, 12, 5).atZone(zoneId).toInstant());
 
         response = graphHopper.route(request);
         assertEquals("Will take 1:15 because of a 'from route' exception with a longer transfer time.", time(1, 15), response.getBest().getTime());
@@ -470,12 +459,12 @@ public void testTransferRules() {
 
 
     private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double FROM_LAT, double FROM_LON, double TO_LAT, double TO_LON, int expectedWeight) {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
@@ -484,12 +473,12 @@ private void assertTravelTimeIs(GraphHopperGtfs graphHopper, double FROM_LAT, do
     }
 
     private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double from_lon, double to_lat, double to_lon) {
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 from_lat, from_lon,
                 to_lat, to_lon
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 0, 0).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         GHResponse route = graphHopper.route(ghRequest);
         assertTrue(route.getAll().isEmpty());
@@ -499,36 +488,36 @@ private void assertNoRoute(GraphHopperGtfs graphHopper, double from_lat, double
     public void testTransferByArrival() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to be there at 7:20
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,7,20).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 7, 20).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
 
         GHResponse response = graphHopper.route(ghRequest);
 
-        Trip.PtLeg lastLeg = ((Trip.PtLeg) response.getBest().getLegs().get(response.getBest().getLegs().size()-1));
-        Trip.Stop lastStop = lastLeg.stops.get(lastLeg.stops.size()-1);
+        Trip.PtLeg lastLeg = ((Trip.PtLeg) response.getBest().getLegs().get(response.getBest().getLegs().size() - 1));
+        Trip.Stop lastStop = lastLeg.stops.get(lastLeg.stops.size() - 1);
         assertEquals("Arrive at 7:20", LocalDateTime.parse("2007-01-01T07:20:00").atZone(zoneId).toInstant(), lastStop.plannedArrivalTime.toInstant());
     }
 
     @Test
     public void testCustomObjectiveFunction() {
-        GHRequest ghRequest = new GHRequest(
-                36.868446,-116.784582,  // BEATTY_AIRPORT stop
-                36.425288,-117.133162       // FUR_CREEK_RES stop
+        Request ghRequest = new Request(
+                36.868446, -116.784582,  // BEATTY_AIRPORT stop
+                36.425288, -117.133162       // FUR_CREEK_RES stop
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,14,0,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 14, 0, 0).atZone(zoneId).toInstant());
 
         GHResponse response = graphHopper.route(ghRequest);
 
         PathWrapper solutionWithTransfer = response.getAll().get(0);
         PathWrapper solutionWithoutTransfer = response.getAll().get(1);
 
-        Assume.assumeTrue("First solution has one transfer",solutionWithTransfer.getNumChanges() == 1);
+        Assume.assumeTrue("First solution has one transfer", solutionWithTransfer.getNumChanges() == 1);
         Assume.assumeTrue("Second solution has no transfers", solutionWithoutTransfer.getNumChanges() == 0);
         Assume.assumeTrue("With transfers is faster than without", solutionWithTransfer.getTime() < solutionWithoutTransfer.getTime());
 
@@ -537,20 +526,20 @@ public void testCustomObjectiveFunction() {
         // Wiggle it by epsilon, and I should prefer one over the other.
         double betaTransfers = solutionWithoutTransfer.getTime() - solutionWithTransfer.getTime();
 
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.setIgnoreTransfers(true);
         // Well, not actually ignore them, but don't do multi-criteria search
 
-        ghRequest.getHints().put("beta_transfers", betaTransfers - 10);
+        ghRequest.setBetaTransfers(betaTransfers - 10);
         response = graphHopper.route(ghRequest);
 
-        assertEquals("Get exactly one solution",1, response.getAll().size());
+        assertEquals("Get exactly one solution", 1, response.getAll().size());
         assertEquals("Prefer solution with transfers when I give the smaller beta", solutionWithTransfer.getTime(), response.getBest().getTime());
 
-        ghRequest.getHints().put("beta_transfers", betaTransfers + 10);
+        ghRequest.setBetaTransfers(betaTransfers + 10);
 
         response = graphHopper.route(ghRequest);
 
-        assertEquals("Get exactly one solution",1, response.getAll().size());
+        assertEquals("Get exactly one solution", 1, response.getAll().size());
         assertEquals("Prefer solution without transfers when I give the higher beta", solutionWithoutTransfer.getTime(), response.getBest().getTime());
     }
 
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index 82ab0d73fc..7a9c7eb406 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -21,15 +21,14 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
 import com.graphhopper.storage.GHDirectory;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
-import org.junit.Assume;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -41,7 +40,6 @@
 import java.util.Collections;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
 
 public class GraphHopperMultimodalIT {
 
@@ -55,7 +53,7 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
@@ -72,44 +70,44 @@ public static void close() {
 
     @Test
     public void testDepartureTimeOfAccessLegInProfileQuery() {
-        GHRequest ghRequest = new GHRequest(
-                36.91311729030539,-116.76769495010377,
-                36.91260259593356,-116.76149368286134
+        Request ghRequest = new Request(
+                36.91311729030539, -116.76769495010377,
+                36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setProfileQuery(true);
 
         GHResponse response = graphHopper.route(ghRequest);
-        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(247);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(243);
 
         PathWrapper firstTransitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get(); // There can be a walk-only trip.
         assertThat(firstTransitSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
-                .isEqualTo(LocalTime.parse("06:41:04.834"));
+                .isEqualTo(LocalTime.parse("06:41:04.833"));
         assertThat(firstTransitSolution.getLegs().get(0).getArrivalTime().toInstant())
                 .isEqualTo(firstTransitSolution.getLegs().get(1).getDepartureTime().toInstant());
         assertThat(firstTransitSolution.getLegs().get(2).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
-                .isEqualTo(LocalTime.parse("06:52:02.728"));
+                .isEqualTo(LocalTime.parse("06:52:02.729"));
     }
 
     @Test
     public void testDepartureTimeOfAccessLeg() {
-        GHRequest ghRequest = new GHRequest(
-                36.91311729030539,-116.76769495010377,
-                36.91260259593356,-116.76149368286134
+        Request ghRequest = new Request(
+                36.91311729030539, -116.76769495010377,
+                36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put("beta_walk_time", 2.0); // I somewhat dislike walking
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setBetaWalkTime(2.0); // I somewhat dislike walking
 
         GHResponse response = graphHopper.route(ghRequest);
-        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(130);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(129);
 
         PathWrapper firstTransitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get(); // There can be a walk-only trip.
         assertThat(firstTransitSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
-                .isEqualTo(LocalTime.parse("06:41:04.834"));
+                .isEqualTo(LocalTime.parse("06:41:04.833"));
         assertThat(firstTransitSolution.getLegs().get(0).getArrivalTime().toInstant())
                 .isEqualTo(firstTransitSolution.getLegs().get(1).getDepartureTime().toInstant());
         assertThat(firstTransitSolution.getLegs().get(2).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
-                .isEqualTo(LocalTime.parse("06:52:02.728"));
+                .isEqualTo(LocalTime.parse("06:52:02.729"));
 
         PathWrapper walkSolution = response.getAll().stream().filter(p -> p.getLegs().size() == 1).findFirst().get();
         assertThat(walkSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
@@ -117,26 +115,26 @@ public void testDepartureTimeOfAccessLeg() {
         // In principle, this would dominate the transit solution, since it's faster, but
         // by default, walking gets a slight penalty.
         assertThat(walkSolution.getLegs().get(0).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
-                .isEqualTo(LocalTime.parse("06:51:10.367"));
+                .isEqualTo(LocalTime.parse("06:51:10.370"));
         assertThat(walkSolution.getLegs().size()).isEqualTo(1);
         assertThat(walkSolution.getNumChanges()).isEqualTo(-1);
 
         // I like walking exactly as I like riding a bus (per travel time unit)
         // Now, the walk solution dominates, and we get no transit solution.
-        ghRequest.getHints().put("beta_walk_time",1.0);
+        ghRequest.setBetaWalkTime(1.0);
         response = graphHopper.route(ghRequest);
-        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(139);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(138);
         assertThat(response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst()).isEmpty();
     }
 
     @Test
     public void testFastWalking() {
-        GHRequest ghRequest = new GHRequest(
-                36.91311729030539,-116.76769495010377,
-                36.91260259593356,-116.76149368286134
+        Request ghRequest = new Request(
+                36.91311729030539, -116.76769495010377,
+                36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -151,13 +149,13 @@ public void testFastWalking() {
 
     @Test
     public void testFastWalkingInProfileQuery() {
-        GHRequest ghRequest = new GHRequest(
-                36.91311729030539,-116.76769495010377,
-                36.91260259593356,-116.76149368286134
+        Request ghRequest = new Request(
+                36.91311729030539, -116.76769495010377,
+                36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setProfileQuery(true);
 
         GHResponse response = graphHopper.route(ghRequest);
 
@@ -172,43 +170,42 @@ public void testFastWalkingInProfileQuery() {
 
     @Test
     public void testProfileQueryDoesntEndPrematurely() {
-        GHRequest ghRequest = new GHRequest(
-                36.91311729030539,-116.76769495010377,
-                36.91260259593356,-116.76149368286134
+        Request ghRequest = new Request(
+                36.91311729030539, -116.76769495010377,
+                36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
         // Provoke a situation where solutions which are later dominated will be found early.
         // If everything is right, the n-th solution should be the same, no matter if I ask for n, or for n+m solutions.
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 1); // No, I cannot walk very fast, 1 km/h. Problem?
-        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.setWalkSpeedKmH(1); // No, I cannot walk very fast, 1 km/h. Problem?
+        ghRequest.setProfileQuery(true);
 
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 1);
+        ghRequest.setLimitSolutions(1);
         GHResponse response1 = graphHopper.route(ghRequest);
-        assertThat(response1.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(143);
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 3);
+        assertThat(response1.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(142);
+        ghRequest.setLimitSolutions(3);
         GHResponse response3 = graphHopper.route(ghRequest);
-        assertThat(response3.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(248);
+        assertThat(response3.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(230);
         assertThat(response1.getAll().get(0).getTime()).isEqualTo(response3.getAll().get(0).getTime());
-        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 5);
+        ghRequest.setLimitSolutions(5);
         GHResponse response5 = graphHopper.route(ghRequest);
-        assertThat(response5.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(362);
+        assertThat(response5.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(334);
         assertThat(response3.getAll().get(2).getTime()).isEqualTo(response5.getAll().get(2).getTime());
     }
 
     @Test
     public void testHighDisutilityOfWalking() {
-        GHRequest ghRequest = new GHRequest(
-                36.91311729030539,-116.76769495010377,
-                36.91260259593356,-116.76149368286134
+        Request ghRequest = new Request(
+                36.91311729030539, -116.76769495010377,
+                36.91260259593356, -116.76149368286134
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
-        ghRequest.getHints().put("beta_walk_time", 20); // But I dislike walking a lot.
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007, 1, 1, 6, 40, 0).atZone(zoneId).toInstant());
+        ghRequest.setWalkSpeedKmH(50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.setBetaWalkTime(20); // But I dislike walking a lot.
 
         GHResponse response = graphHopper.route(ghRequest);
 
         PathWrapper transitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get();
         assertThat(transitSolution.getLegs().size()).isEqualTo(3);
     }
-
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java b/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
new file mode 100644
index 0000000000..da31774cc7
--- /dev/null
+++ b/reader-gtfs/src/test/java/com/graphhopper/PtRouteResourceIT.java
@@ -0,0 +1,97 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper;
+
+import com.graphhopper.gtfs.ws.LocationConverterProvider;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.reader.gtfs.GraphHopperGtfs;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Parameters;
+import io.dropwizard.testing.junit.ResourceTestRule;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collections;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public class PtRouteResourceIT {
+
+    private static final String GRAPH_LOC = "target/PtRouteResourceIT";
+    private static GraphHopperGtfs graphHopper;
+
+    static {
+        Helper.removeDir(new File(GRAPH_LOC));
+        final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
+        final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
+
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(carFlagEncoder, ptFlagEncoder, footFlagEncoder), 8);
+        GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
+        GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
+        GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
+        LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
+        graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
+                .createWithoutRealtimeFeed();
+    }
+
+    @ClassRule
+    public static final ResourceTestRule resources = ResourceTestRule.builder()
+            .addProvider(new LocationConverterProvider())
+            .setMapper(Jackson.newObjectMapper())
+            .addResource(graphHopper)
+            .build();
+
+    @Test
+    public void testStationStationQuery() {
+        final Response response = resources.target("/route")
+                .queryParam("point", "Stop(NADAV)")
+                .queryParam("point", "Stop(NANAA)")
+                .queryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME, "2007-01-01T08:00:00Z")
+                .request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        GHResponse ghResponse = response.readEntity(GHResponse.class);
+        assertFalse(ghResponse.hasErrors());
+    }
+
+    @Test
+    public void testPointPointQuery() {
+        final Response response = resources.target("/route")
+                .queryParam("point","36.914893,-116.76821") // NADAV stop
+                .queryParam("point","36.914944,-116.761472") //NANAA stop
+                .queryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME, "2007-01-01T08:00:00Z")
+                .request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        GHResponse ghResponse = response.readEntity(GHResponse.class);
+        assertFalse(ghResponse.hasErrors());
+    }
+
+}
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 9b8988f323..8940037718 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -22,6 +22,7 @@
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.reader.gtfs.Request;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FootFlagEncoder;
@@ -29,20 +30,13 @@
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
 import java.math.BigDecimal;
-import java.time.Duration;
-import java.time.Instant;
-import java.time.LocalDate;
-import java.time.LocalDateTime;
-import java.time.LocalTime;
-import java.time.ZoneId;
-import java.time.ZonedDateTime;
+import java.time.*;
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -65,7 +59,7 @@
     public static void init() {
         Helper.removeDir(new File(GRAPH_LOC));
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new FootFlagEncoder(), ptFlagEncoder), 8);
+        EncodingManager encodingManager = EncodingManager.create(Arrays.asList(new CarFlagEncoder(), ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
@@ -90,14 +84,14 @@ public static void close() {
     public void testSkipDepartureStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my departure stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -112,7 +106,7 @@ public void testSkipDepartureStop() {
                 .setStopSequence(3)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         PathWrapper possibleAlternative = response.getAll().stream().filter(a -> !a.isImpossible()).findFirst().get();
         assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
@@ -127,14 +121,14 @@ public void testSkipDepartureStop() {
     public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be super-late :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -150,7 +144,7 @@ public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
                 .setStopSequence(3)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(3600).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         PathWrapper best = response.getBest();
@@ -169,14 +163,14 @@ public void testHeavyDelayWhereWeShouldTakeOtherTripInstead() {
     public void testCanUseDelayedTripWhenIAmLateToo() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be super-late :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -192,7 +186,7 @@ public void testCanUseDelayedTripWhenIAmLateToo() {
                 .setStopSequence(3)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(120).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         assertEquals("I am two minutes late for my bus, but the bus is two minutes late, too, so I catch it!", time(0, 5), response.getBest().getTime(), 0.1);
     }
@@ -201,14 +195,14 @@ public void testCanUseDelayedTripWhenIAmLateToo() {
     public void testSkipArrivalStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my arrival stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -223,7 +217,7 @@ public void testSkipArrivalStop() {
                 .setStopSequence(4)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(3, response.getAll().size());
 
         assertEquals("I have to continue to STAGECOACH and then go back one stop with the 07:00 bus.", time(0, 21), response.getBest().getTime(), 0.1);
@@ -237,14 +231,14 @@ public void testSkipArrivalStop() {
     public void testSkipTransferStop() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -259,7 +253,7 @@ public void testSkipTransferStop() {
                 .setStopSequence(5)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will not call at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
@@ -273,15 +267,15 @@ public void testSkipTransferStop() {
     public void testExtraTrip() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -319,7 +313,7 @@ public void testExtraTrip() {
 
         }
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("Luckily, there is an extra service directly from my stop to the airport, at 6:45, taking 30 minutes", time(0, 31), response.getBest().getTime(), 0.1);
@@ -333,15 +327,15 @@ public void testExtraTrip() {
     public void testExtraTripWorksOnlyOnSpecifiedDay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:45, but tomorrow
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,2,6,45).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,2,6,45).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
         feedMessageBuilder.setHeader(GtfsRealtime.FeedHeader.newBuilder()
@@ -367,7 +361,7 @@ public void testExtraTripWorksOnlyOnSpecifiedDay() {
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).atZone(zoneId).toEpochSecond()));
 
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("There is an extra trip at 6:45 tomorrow, but that doesn't concern me today.", time(1, 5), response.getBest().getTime(), 0.1);
@@ -377,15 +371,15 @@ public void testExtraTripWorksOnlyOnSpecifiedDay() {
     public void testZeroDelay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         GHResponse responseWithoutRealtimeUpdate = graphHopperFactory.createWithoutRealtimeFeed().route(ghRequest);
 
@@ -401,7 +395,7 @@ public void testZeroDelay() {
                 .setScheduleRelationship(SCHEDULED)
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(0).build());
 
-        GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, responseWithRealtimeUpdate.getAll().size());
 
         Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(0);
@@ -417,16 +411,16 @@ public void testZeroDelay() {
     public void testDelayWithoutTransfer() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
         Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(initialTime);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // The 6:00 departure of my line is going to be late by 3 minutes
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -440,7 +434,7 @@ public void testDelayWithoutTransfer() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         assertEquals("My line run is 3 minutes late.", time(0, 8), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant().toEpochMilli() - initialTime.toEpochMilli(), 0.1);
@@ -451,16 +445,16 @@ public void testDelayWithoutTransfer() {
     public void testDelayFromBeginningWithoutTransfer() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
         Instant initialTime = LocalDateTime.of(2007, 1, 1, 6, 44).atZone(zoneId).toInstant();
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, initialTime);
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(initialTime);
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // The 6:00 departure of my line is going to be "late" by 0 minutes
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -476,7 +470,7 @@ public void testDelayFromBeginningWithoutTransfer() {
                 .setScheduleRelationship(SCHEDULED)
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(180).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
         Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(0));
@@ -488,13 +482,13 @@ public void testDelayFromBeginningWithoutTransfer() {
     public void testBlockTrips() {
         final double FROM_LAT = 36.868446, FROM_LON = -116.784582; // BEATTY_AIRPORT stop
         final double TO_LAT = 36.425288, TO_LON = -117.133162; // FUR_CREEK_RES stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,8,0).atZone(zoneId).toInstant());
+        ghRequest.setIgnoreTransfers(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // My line does not stop at Bullfrog today. If this was a real transfer, I would not be
         // able to change lines there. But it is not a real transfer, so I can go on as planned.
@@ -508,7 +502,7 @@ public void testBlockTrips() {
                 .setStopSequence(2)
                 .setScheduleRelationship(SKIPPED);
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals("I can still use the AB1 trip", "AB1", (((Trip.PtLeg) response.getBest().getLegs().get(0)).trip_id));
         assertEquals("It takes", time(1,20), response.getBest().getTime());
     }
@@ -529,12 +523,12 @@ public void testBlockTripSkipsStop() {
 
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
-        GHResponse route = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        GHResponse route = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 
         assertFalse(route.hasErrors());
         assertTrue(route.getAll().get(route.getAll().size()-1).isImpossible());
@@ -551,14 +545,14 @@ public void testBlockTripSkipsStop() {
     public void testMissedTransferBecauseOfDelay() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -572,7 +566,7 @@ public void testMissedTransferBecauseOfDelay() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, so I will be 30 min late at the airport.", time(1, 6), response.getBest().getTime(), 0.1);
@@ -587,14 +581,14 @@ public void testMissedTransferBecauseOfDelay() {
     public void testMissedTransferButExtraTripOnFirstLeg() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -625,7 +619,7 @@ public void testMissedTransferButExtraTripOnFirstLeg() {
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toEpochSecond()))
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,46).atZone(zoneId).toEpochSecond()));
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 //        assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, but I won't be late because there's an extra trip.", time(0, 36), response.getBest().getTime(), 0.1);
@@ -635,14 +629,14 @@ public void testMissedTransferButExtraTripOnFirstLeg() {
     public void testMissedTransferButExtraTripOnSecondLeg() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to go at 6:44
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,6,44).atZone(zoneId).toInstant());
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to be 5 minutes late at my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -673,7 +667,7 @@ public void testMissedTransferButExtraTripOnSecondLeg() {
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,20).atZone(zoneId).toEpochSecond()))
                 .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,20).atZone(zoneId).toEpochSecond()));
 
-        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
+        GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
 //        assertEquals(2, response.getAll().size());
 
         assertEquals("The 6:44 bus will be late at STAGECOACH, but I won't be late because there's an extra trip.", time(0, 36), response.getBest().getTime(), 0.1);
@@ -685,15 +679,15 @@ public void testMissedTransferButExtraTripOnSecondLeg() {
     public void testMissedTransferBecauseOfDelayBackwards() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
         final double TO_LAT = 36.868446, TO_LON = -116.784582; // BEATTY_AIRPORT stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
 
         // I want to be there at 7:20
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,8,20).atZone(zoneId).toInstant());
-        ghRequest.getHints().put(Parameters.PT.ARRIVE_BY, true);
-        ghRequest.getHints().put(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 30);
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,8,20).atZone(zoneId).toInstant());
+        ghRequest.setArriveBy(true);
+        ghRequest.setMaxWalkDistancePerLeg(30);
 
         // But the 6:00 departure of my line is going to skip my transfer stop :-(
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
@@ -707,7 +701,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId);
+        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build());
         GHResponse response = graphHopper.route(ghRequest);
         assertEquals(2, response.getAll().size());
 
@@ -719,7 +713,7 @@ public void testMissedTransferBecauseOfDelayBackwards() {
         assertEquals("Five minutes late", 300, Duration.between(delayedStop.plannedArrivalTime.toInstant(), delayedStop.predictedArrivalTime.toInstant()).getSeconds());
 
         // But when I ask about tomorrow, it works as planned
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,2,8,20).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,2,8,20).atZone(zoneId).toInstant());
         response = graphHopper.route(ghRequest);
         assertEquals(1, response.getAll().size());
 
@@ -732,11 +726,11 @@ public void testMissedTransferBecauseOfDelayBackwards() {
     public void testDelayAtEndForNonFrequencyBasedTrip() {
         final double FROM_LAT = 36.915682, FROM_LON = -116.751677; // STAGECOACH stop
         final double TO_LAT = 36.88108, TO_LON = -116.81797; // BULLFROG stop
-        GHRequest ghRequest = new GHRequest(
+        Request ghRequest = new Request(
                 FROM_LAT, FROM_LON,
                 TO_LAT, TO_LON
         );
-        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
+        ghRequest.setEarliestDepartureTime(LocalDateTime.of(2007,1,1,0,0).atZone(zoneId).toInstant());
 
         final GtfsRealtime.FeedMessage.Builder feedMessageBuilder = GtfsRealtime.FeedMessage.newBuilder();
         feedMessageBuilder.setHeader(header());
@@ -749,7 +743,7 @@ public void testDelayAtEndForNonFrequencyBasedTrip() {
                 .setScheduleRelationship(SCHEDULED)
                 .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setDelay(300).build());
 
-        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId);
+        GraphHopperGtfs graphHopper = graphHopperFactory.createWith(feedMessageBuilder.build());
         GHResponse route = graphHopper.route(ghRequest);
 
         assertFalse(route.hasErrors());
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
index 6a5a2edf28..5aba5806ed 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
@@ -34,6 +34,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.collection.IsEmptyIterable.emptyIterable;
@@ -51,18 +52,7 @@
     public GraphExplorerTest() {
         pt = new PtFlagEncoder();
         foot = new FootFlagEncoder();
-        encodingManager = new EncodingManager(Arrays.asList(pt, foot), 8);
-    }
-
-    @Test
-    public void testEverythingEmpty() {
-        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
-        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
-        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
-        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
-        assertThat((Iterable<EdgeIteratorState>) () -> testee.exploreEdgesAround(new Label(0, 0, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).iterator(),
-                emptyIterable());
+        encodingManager = EncodingManager.create(Arrays.asList(pt, foot), 8);
     }
 
     @Test
@@ -70,14 +60,16 @@ public void testNonEmptyGraph() {
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
         graph.create(0);
         EdgeIteratorState d = graph.edge(4, 5);
-        d.setFlags(pt.setAccess(d.getFlags(), true, false));
-        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+        d.set(pt.getAccessEnc(), true);
+        d.set(foot.getAccessEnc(), true);
 
         GtfsStorage gtfsStorage = mock(GtfsStorage.class);
         RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
         List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        QueryGraph queryGraph = new QueryGraph(graph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
 
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(d.toString()));
@@ -90,22 +82,24 @@ public void testExtraEdgesWithEmptyGraph() {
         GtfsStorage gtfsStorage = mock(GtfsStorage.class);
         RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
         List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
-        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(0, 0, 0, 1, 0.0, 0L, "", new PointList());
-        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(0, 0, 0, 1, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        e.set(foot.getAccessEnc(), true);
         extraEdges.add(e);
-        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(1, 1, 1, 2, 0.0, 0L, "", new PointList());
-        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(1, 1, 1, 2, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        f.set(foot.getAccessEnc(), true);
         extraEdges.add(f);
-        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(2, 2, 1, 3, 0.0, 0L, "", new PointList());
-        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(2, 2, 1, 3, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        g.set(foot.getAccessEnc(), true);
         extraEdges.add(g);
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
+        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(e.toString()));
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(f.toString(), g.toString()));
-
     }
 
     @Test
@@ -113,34 +107,40 @@ public void testExtraEdgesWithNonEmptyGraph() {
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
         graph.create(0);
         EdgeIteratorState d = graph.edge(4, 5);
-        d.setFlags(pt.setAccess(d.getFlags(), true, false));
-        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+        d.set(pt.getAccessEnc(), true);
+        d.set(foot.getAccessEnc(), true);
 
         int edgeId = graph.getAllEdges().length();
 
         GtfsStorage gtfsStorage = mock(GtfsStorage.class);
         RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
         List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
-        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(-1, edgeId++, 0, 1, 0.0, 0L, "", new PointList());
-        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(-1, edgeId++, 0, 1, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        e.set(foot.getAccessEnc(), true);
         extraEdges.add(e);
-        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(-1, edgeId++, 1, 2, 0.0, 0L, "", new PointList());
-        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(-1, edgeId++, 1, 2, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        f.set(foot.getAccessEnc(), true);
         extraEdges.add(f);
-        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(-1, edgeId++, 1, 3, 0.0, 0L, "", new PointList());
-        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(-1, edgeId++, 1, 3, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        g.set(foot.getAccessEnc(), true);
         extraEdges.add(g);
-        VirtualEdgeIteratorState h = new VirtualEdgeIteratorState(-1, edgeId++, 4, 7, 0.0, 0L, "", new PointList());
-        h.setFlags(foot.setAccess(h.getFlags(), true, false));
+        VirtualEdgeIteratorState h = new VirtualEdgeIteratorState(-1, edgeId++, 4, 7, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        h.set(foot.getAccessEnc(), true);
         extraEdges.add(h);
 
-        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(e.toString()));
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(f.toString(), g.toString()));
-        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
-                contains(d.toString(), h.toString()));
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
+        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
+        queryGraph.lookup(Collections.emptyList());
+        GraphExplorer forward = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("0->1"));
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("1->2", "1->3"));
+        assertThat(() -> forward.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("0 4-5", "4->7"));
+        GraphExplorer backward = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, true, false, 5.0);
+        assertThat(() -> backward.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains("1->0"));
     }
 
     @Test
@@ -148,13 +148,13 @@ public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
         graph.create(0);
         EdgeIteratorState c = graph.edge(4, 3);
-        c.setFlags(pt.setAccess(c.getFlags(), true, false));
-        c.setFlags(foot.setAccess(c.getFlags(), true, false));
+        c.set(pt.getAccessEnc(), true);
+        c.set(foot.getAccessEnc(), true);
         PointList cp = new PointList();
         c.setWayGeometry(cp);
         EdgeIteratorState d = graph.edge(4, 5);
-        d.setFlags(pt.setAccess(d.getFlags(), true, false));
-        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+        d.set(pt.getAccessEnc(), true);
+        d.set(foot.getAccessEnc(), true);
         PointList dp = new PointList();
         d.setWayGeometry(dp);
         graph.getNodeAccess().setNode(3, 3.0, 3.0);
@@ -167,17 +167,17 @@ public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
         GtfsStorage gtfsStorage = mock(GtfsStorage.class);
         RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
         List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
-        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(-1, edgeId++, 0, 1, 0.0, 0L, "", new PointList());
-        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(-1, edgeId++, 0, 1, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        e.set(foot.getAccessEnc(), true);
         extraEdges.add(e);
-        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(-1, edgeId++, 1, 2, 0.0, 0L, "", new PointList());
-        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(-1, edgeId++, 1, 2, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        f.set(foot.getAccessEnc(), true);
         extraEdges.add(f);
-        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(-1, edgeId++, 1, 3, 0.0, 0L, "", new PointList());
-        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(-1, edgeId++, 1, 3, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        g.set(foot.getAccessEnc(), true);
         extraEdges.add(g);
-        VirtualEdgeIteratorState h = new VirtualEdgeIteratorState(-1, edgeId++, 4, 7, 0.0, 0L, "", new PointList());
-        h.setFlags(foot.setAccess(h.getFlags(), true, false));
+        VirtualEdgeIteratorState h = new VirtualEdgeIteratorState(-1, edgeId++, 4, 7, 0.0, encodingManager.createEdgeFlags(), "", new PointList(), false);
+        h.set(foot.getAccessEnc(), true);
         extraEdges.add(h);
 
         WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
@@ -197,7 +197,7 @@ public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
         point2.calcSnappedPoint(new DistanceCalc2D());
         queryGraph.lookup(point1, point2);
 
-        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, false, 5.0);
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
                 contains(e.toString()));
         assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java
new file mode 100644
index 0000000000..9fd42f3775
--- /dev/null
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/WrapperGraphTest.java
@@ -0,0 +1,55 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import org.junit.Test;
+
+import java.util.Arrays;
+import java.util.Collections;
+
+import static org.junit.Assert.assertEquals;
+
+public class WrapperGraphTest {
+
+    private final PtFlagEncoder pt;
+    private final FootFlagEncoder foot;
+    private final EncodingManager encodingManager;
+
+    public WrapperGraphTest() {
+        pt = new PtFlagEncoder();
+        foot = new FootFlagEncoder();
+        encodingManager = EncodingManager.create(Arrays.asList(pt, foot), 8);
+    }
+
+    @Test
+    public void testEternalOffByOneError() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        assertEquals(0, graph.getNodes());
+        assertEquals(0, graph.getAllEdges().length());
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, Collections.emptyList());
+        assertEquals(0, wrapperGraph.getNodes());
+        assertEquals(0, wrapperGraph.getAllEdges().length());
+    }
+
+}
diff --git a/reader-osm/pom.xml b/reader-osm/pom.xml
index f7d2e4c0fe..03d0a48b3e 100644
--- a/reader-osm/pom.xml
+++ b/reader-osm/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-osm</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Reader for OpenStreetMap Data</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -25,7 +25,7 @@
         <dependency>
             <groupId>org.openstreetmap.osmosis</groupId>
             <artifactId>osmosis-osm-binary</artifactId>
-            <version>0.46</version>
+            <version>0.47</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
index 52d49d695a..e865a2a0d6 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReader.java
@@ -24,6 +24,7 @@
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.GraphElevationSmoothing;
 import com.graphhopper.reader.osm.OSMTurnRelation.TurnCostTableEntry;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.FlagEncoder;
@@ -221,9 +222,7 @@ private IntLongMap getEdgeIdToOsmWayIdMap() {
     }
 
     /**
-     * Filter ways but do not analyze properties wayNodes will be filled with participating node
-     * ids.
-     * <p>
+     * Filter ways but do not analyze properties wayNodes will be filled with participating node ids.
      *
      * @return true the current xml entry is a way entry and has nodes
      */
@@ -236,7 +235,7 @@ boolean filterWay(ReaderWay item) {
         if (!item.hasTags())
             return false;
 
-        return encodingManager.acceptWay(item) > 0;
+        return encodingManager.acceptWay(item, new EncodingManager.AcceptWay());
     }
 
     /**
@@ -317,8 +316,8 @@ void processWay(ReaderWay way) {
 
         long wayOsmId = way.getId();
 
-        long includeWay = encodingManager.acceptWay(way);
-        if (includeWay == 0)
+        EncodingManager.AcceptWay acceptWay = new EncodingManager.AcceptWay();
+        if (!encodingManager.acceptWay(way, acceptWay))
             return;
 
         long relationFlags = getRelFlagsMap().get(way.getId());
@@ -326,22 +325,20 @@ void processWay(ReaderWay way) {
         // TODO move this after we have created the edge and know the coordinates => encodingManager.applyWayTags
         LongArrayList osmNodeIds = way.getNodes();
         // Estimate length of ways containing a route tag e.g. for ferry speed calculation
-        if (osmNodeIds.size() > 1) {
-            int first = getNodeMap().get(osmNodeIds.get(0));
-            int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
-            double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
-            double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
-            if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
-                double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
-                // Add artificial tag for the estimated distance and center
-                way.setTag("estimated_distance", estimatedDist);
-                way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
-            }
+        int first = getNodeMap().get(osmNodeIds.get(0));
+        int last = getNodeMap().get(osmNodeIds.get(osmNodeIds.size() - 1));
+        double firstLat = getTmpLatitude(first), firstLon = getTmpLongitude(first);
+        double lastLat = getTmpLatitude(last), lastLon = getTmpLongitude(last);
+        if (!Double.isNaN(firstLat) && !Double.isNaN(firstLon) && !Double.isNaN(lastLat) && !Double.isNaN(lastLon)) {
+            double estimatedDist = distCalc.calcDist(firstLat, firstLon, lastLat, lastLon);
+            // Add artificial tag for the estimated distance and center
+            way.setTag("estimated_distance", estimatedDist);
+            way.setTag("estimated_center", new GHPoint((firstLat + lastLat) / 2, (firstLon + lastLon) / 2));
         }
 
         if (way.getTag("duration") != null) {
             try {
-                long dur = OSMTagParser.parseDuration(way.getTag("duration"));
+                long dur = OSMReaderUtility.parseDuration(way.getTag("duration"));
                 // Provide the duration value in seconds in an artificial graphhopper specific tag:
                 way.setTag("duration:seconds", Long.toString(dur));
             } catch (Exception ex) {
@@ -349,8 +346,8 @@ void processWay(ReaderWay way) {
             }
         }
 
-        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
-        if (wayFlags == 0)
+        IntsRef edgeFlags = encodingManager.handleWayTags(way, acceptWay, relationFlags);
+        if (edgeFlags.isEmpty())
             return;
 
         List<EdgeIteratorState> createdEdges = new ArrayList<>();
@@ -360,9 +357,9 @@ void processWay(ReaderWay way) {
         for (int i = 0; i < size; i++) {
             long nodeId = osmNodeIds.get(i);
             long nodeFlags = getNodeFlagsMap().get(nodeId);
-            // barrier was spotted and way is otherwise passable for that mode of travel
+            // barrier was spotted and the way is passable for that mode of travel
             if (nodeFlags > 0) {
-                if ((nodeFlags & wayFlags) > 0) {
+                if (isOnePassable(encodingManager.getAccessEncFromNodeFlags(nodeFlags), edgeFlags)) {
                     // remove barrier to avoid duplicates
                     getNodeFlagsMap().put(nodeId, 0);
 
@@ -378,13 +375,13 @@ void processWay(ReaderWay way) {
                         LongArrayList partNodeIds = new LongArrayList();
                         partNodeIds.add(osmNodeIds.buffer, lastBarrier, length);
                         partNodeIds.set(length - 1, newNodeId);
-                        createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
+                        createdEdges.addAll(addOSMWay(partNodeIds, edgeFlags, wayOsmId));
 
                         // create zero length edge for barrier
-                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, wayFlags, nodeFlags, wayOsmId));
+                        createdEdges.addAll(addBarrierEdge(newNodeId, nodeId, edgeFlags, nodeFlags, wayOsmId));
                     } else {
                         // run edge from real first node to shadow node
-                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, wayFlags, nodeFlags, wayOsmId));
+                        createdEdges.addAll(addBarrierEdge(nodeId, newNodeId, edgeFlags, nodeFlags, wayOsmId));
 
                         // exchange first node for created barrier node
                         osmNodeIds.set(0, newNodeId);
@@ -400,11 +397,11 @@ void processWay(ReaderWay way) {
             if (lastBarrier < size - 1) {
                 LongArrayList partNodeIds = new LongArrayList();
                 partNodeIds.add(osmNodeIds.buffer, lastBarrier, size - lastBarrier);
-                createdEdges.addAll(addOSMWay(partNodeIds, wayFlags, wayOsmId));
+                createdEdges.addAll(addOSMWay(partNodeIds, edgeFlags, wayOsmId));
             }
         } else {
             // no barriers - simply add the whole way
-            createdEdges.addAll(addOSMWay(way.getNodes(), wayFlags, wayOsmId));
+            createdEdges.addAll(addOSMWay(way.getNodes(), edgeFlags, wayOsmId));
         }
 
         for (EdgeIteratorState edge : createdEdges) {
@@ -412,7 +409,7 @@ void processWay(ReaderWay way) {
         }
     }
 
-    public void processRelation(ReaderRelation relation) throws XMLStreamException {
+    public void processRelation(ReaderRelation relation) {
         if (relation.hasTag("type", "restriction")) {
             OSMTurnRelation turnRelation = createTurnRelation(relation);
             if (turnRelation != null) {
@@ -547,13 +544,25 @@ boolean addNode(ReaderNode node) {
         return true;
     }
 
+    /**
+     * The nodeFlags store the encoders to check for accessibility in edgeFlags. E.g. if nodeFlags==3, then the
+     * accessibility of the first two encoders will be check in edgeFlags
+     */
+    private static boolean isOnePassable(List<BooleanEncodedValue> checkEncoders, IntsRef edgeFlags) {
+        for (BooleanEncodedValue accessEnc : checkEncoders) {
+            if (accessEnc.getBool(false, edgeFlags) || accessEnc.getBool(true, edgeFlags))
+                return true;
+        }
+        return false;
+    }
+
     protected double getElevation(ReaderNode node) {
         return eleProvider.getEle(node.getLat(), node.getLon());
     }
 
     void prepareWaysWithRelationInfo(ReaderRelation osmRelation) {
         // is there at least one tag interesting for the registed encoders?
-        if (encodingManager.handleRelationTags(osmRelation, 0) == 0)
+        if (encodingManager.handleRelationTags(0, osmRelation) == 0)
             return;
 
         for (ReaderRelation.Member member : osmRelation.getMembers()) {
@@ -564,7 +573,7 @@ void prepareWaysWithRelationInfo(ReaderRelation osmRelation) {
             long oldRelationFlags = getRelFlagsMap().get(osmId);
 
             // Check if our new relation data is better comparated to the the last one
-            long newRelationFlags = encodingManager.handleRelationTags(osmRelation, oldRelationFlags);
+            long newRelationFlags = encodingManager.handleRelationTags(oldRelationFlags, osmRelation);
             if (oldRelationFlags != newRelationFlags)
                 getRelFlagsMap().put(osmId, newRelationFlags);
         }
@@ -598,7 +607,7 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
     /**
      * This method creates from an OSM way (via the osm ids) one or more edges in the graph.
      */
-    Collection<EdgeIteratorState> addOSMWay(final LongIndexedContainer osmNodeIds, final long flags, final long wayOsmId) {
+    Collection<EdgeIteratorState> addOSMWay(final LongIndexedContainer osmNodeIds, final IntsRef flags, final long wayOsmId) {
         PointList pointList = new PointList(osmNodeIds.size(), nodeAccess.is3D());
         List<EdgeIteratorState> newEdges = new ArrayList<>(5);
         int firstNode = -1;
@@ -606,8 +615,8 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
         int lastInBoundsPillarNode = -1;
         try {
             for (int i = 0; i < osmNodeIds.size(); i++) {
-                long osmId = osmNodeIds.get(i);
-                int tmpNode = getNodeMap().get(osmId);
+                long osmNodeId = osmNodeIds.get(i);
+                int tmpNode = getNodeMap().get(osmNodeId);
                 if (tmpNode == EMPTY_NODE)
                     continue;
 
@@ -622,7 +631,7 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                     if (!pointList.isEmpty() && lastInBoundsPillarNode > -TOWER_NODE) {
                         // transform the pillar node to a tower node
                         tmpNode = lastInBoundsPillarNode;
-                        tmpNode = handlePillarNode(tmpNode, osmId, null, true);
+                        tmpNode = handlePillarNode(tmpNode, osmNodeId, null, true);
                         tmpNode = -tmpNode - 3;
                         if (pointList.getSize() > 1 && firstNode >= 0) {
                             // TOWER node
@@ -637,7 +646,7 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                 }
 
                 if (tmpNode <= -TOWER_NODE && tmpNode >= TOWER_NODE)
-                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmId);
+                    throw new AssertionError("Mapped index not in correct bounds " + tmpNode + ", " + osmNodeId);
 
                 if (tmpNode > -TOWER_NODE) {
                     boolean convertToTowerNode = i == 0 || i == lastIndex;
@@ -646,12 +655,30 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
                     }
 
                     // PILLAR node, but convert to towerNode if end-standing
-                    tmpNode = handlePillarNode(tmpNode, osmId, pointList, convertToTowerNode);
+                    tmpNode = handlePillarNode(tmpNode, osmNodeId, pointList, convertToTowerNode);
                 }
 
                 if (tmpNode < TOWER_NODE) {
                     // TOWER node
                     tmpNode = -tmpNode - 3;
+
+                    if (firstNode >= 0 && firstNode == tmpNode) {
+                        // loop detected. See #1525 and #1533. Insert last OSM ID as tower node. Do this for all loops so that users can manipulate loops later arbitrarily.
+                        long lastOsmNodeId = osmNodeIds.get(i - 1);
+                        int lastGHNodeId = getNodeMap().get(lastOsmNodeId);
+                        if (lastGHNodeId < TOWER_NODE) {
+                            LOGGER.warn("Pillar node " + lastOsmNodeId + " is already a tower node and used in loop, see #1533. " +
+                                    "Fix mapping for way " + wayOsmId + ", nodes:" + osmNodeIds);
+                            break;
+                        }
+
+                        int newEndNode = -handlePillarNode(lastGHNodeId, lastOsmNodeId, pointList, true) - 3;
+                        newEdges.add(addEdge(firstNode, newEndNode, pointList, flags, wayOsmId));
+                        pointList.clear();
+                        pointList.add(nodeAccess, newEndNode);
+                        firstNode = newEndNode;
+                    }
+
                     pointList.add(nodeAccess, tmpNode);
                     if (firstNode >= 0) {
                         newEdges.add(addEdge(firstNode, tmpNode, pointList, flags, wayOsmId));
@@ -669,7 +696,7 @@ int addTowerNode(long osmId, double lat, double lon, double ele) {
         return newEdges;
     }
 
-    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, long flags, long wayOsmId) {
+    EdgeIteratorState addEdge(int fromIndex, int toIndex, PointList pointList, IntsRef flags, long wayOsmId) {
         // sanity checks
         if (fromIndex < 0 || toIndex < 0)
             throw new AssertionError("to or from index is invalid for this edge " + fromIndex + "->" + toIndex + ", points:" + pointList);
@@ -770,7 +797,7 @@ private int handlePillarNode(int tmpNode, long osmId, PointList pointList, boole
         else
             pointList.add(lat, lon);
 
-        return (int) tmpNode;
+        return tmpNode;
     }
 
     protected void finishedReading() {
@@ -811,14 +838,18 @@ private long createNewNodeId() {
     /**
      * Add a zero length edge with reduced routing options to the graph.
      */
-    Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, long flags, long nodeFlags, long wayOsmId) {
-        // clear barred directions from routing flags
-        flags &= ~nodeFlags;
+    Collection<EdgeIteratorState> addBarrierEdge(long fromId, long toId, IntsRef inEdgeFlags, long nodeFlags, long wayOsmId) {
+        IntsRef edgeFlags = IntsRef.deepCopyOf(inEdgeFlags);
+        // clear blocked directions from flags
+        for (BooleanEncodedValue accessEnc : encodingManager.getAccessEncFromNodeFlags(nodeFlags)) {
+            accessEnc.setBool(false, edgeFlags, false);
+            accessEnc.setBool(true, edgeFlags, false);
+        }
         // add edge
         barrierNodeIds.clear();
         barrierNodeIds.add(fromId);
         barrierNodeIds.add(toId);
-        return addOSMWay(barrierNodeIds, flags, wayOsmId);
+        return addOSMWay(barrierNodeIds, edgeFlags, wayOsmId);
     }
 
     /**
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTagParser.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReaderUtility.java
similarity index 99%
rename from reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTagParser.java
rename to reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReaderUtility.java
index 6a4d8236cf..cb9757abb0 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTagParser.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMReaderUtility.java
@@ -26,7 +26,7 @@
  *
  * @author ratrun
  */
-public class OSMTagParser {
+public class OSMReaderUtility {
     // use a day somewhere within July 1970 which then makes two identical long months ala 31 days, see #588
     private final static Date STATIC_DATE = new Date((31 * 6) * 24 * 3600 * 1000);
 
diff --git a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java
index 8319df53d4..966702bf88 100644
--- a/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java
+++ b/reader-osm/src/main/java/com/graphhopper/reader/osm/OSMTurnRelation.java
@@ -79,7 +79,7 @@ long getOsmIdTo() {
                 }
             }
 
-            if (edgeIdFrom == EdgeIterator.NO_EDGE)
+            if (!EdgeIterator.Edge.isValid(edgeIdFrom))
                 return Collections.emptyList();
 
             final Collection<TurnCostTableEntry> entries = new ArrayList<>();
diff --git a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
index 1729b19b26..336dea3e5f 100644
--- a/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/GraphHopperIT.java
@@ -19,6 +19,9 @@
 
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.DefaultFlagEncoderFactory;
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.util.*;
 import com.graphhopper.util.Parameters.CH;
@@ -27,13 +30,11 @@
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.PointDistanceExceededException;
 import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.GHPoint3D;
 import org.junit.*;
 
 import java.io.File;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 import static com.graphhopper.util.Parameters.Algorithms.*;
 import static org.junit.Assert.*;
@@ -63,7 +64,7 @@ public static void beforeClass() {
                 setStoreOnFlush(true).
                 setCHEnabled(false).
                 setGraphHopperLocation(graphFileFoot).
-                setEncodingManager(new EncodingManager(importVehicles)).
+                setEncodingManager(EncodingManager.create(importVehicles)).
                 importOrLoad();
     }
 
@@ -83,7 +84,7 @@ public void tearDown() {
     }
 
     @Test
-    public void testMonacoWithInstructions() throws Exception {
+    public void testMonacoWithInstructions() {
         GHResponse rsp = hopper.route(new GHRequest(43.727687, 7.418737, 43.74958, 7.436566).
                 setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr));
 
@@ -100,33 +101,29 @@ public void testMonacoWithInstructions() throws Exception {
         InstructionList il = arsp.getInstructions();
         assertEquals(21, il.size());
 
-        List<Map<String, Object>> resultJson = il.createJson();
         // TODO roundabout fine tuning -> enter + leave roundabout (+ two rounabouts -> is it necessary if we do not leave the street?)
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(4).get("text"));
-        assertEquals("Turn left", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
-
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(96, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(178, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(13, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(42, (Double) resultJson.get(5).get("distance"), 1);
-
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(69, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(128, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(9, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(5).get("time") / 1000);
-
-        List<GPXEntry> list = arsp.getInstructions().createGPXList();
-        assertEquals(87, list.size());
-        final long lastEntryMillis = list.get(list.size() - 1).getTime();
-        final long totalResponseMillis = arsp.getTime();
-        assertEquals(totalResponseMillis, lastEntryMillis);
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
+        assertEquals("continue onto Avenue des Guelfes", il.get(0).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Papalins", il.get(1).getTurnDescription(tr));
+        assertEquals("turn sharp right onto Quai Jean-Charles Rey", il.get(4).getTurnDescription(tr));
+        assertEquals("turn left", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Avenue Albert II", il.get(6).getTurnDescription(tr));
+
+        assertEquals(11, il.get(0).getDistance(), 1);
+        assertEquals(96, il.get(1).getDistance(), 1);
+        assertEquals(178, il.get(2).getDistance(), 1);
+        assertEquals(13, il.get(3).getDistance(), 1);
+        assertEquals(10, il.get(4).getDistance(), 1);
+        assertEquals(42, il.get(5).getDistance(), 1);
+
+        assertEquals(7, il.get(0).getTime() / 1000);
+        assertEquals(69, il.get(1).getTime() / 1000);
+        assertEquals(128, il.get(2).getTime() / 1000);
+        assertEquals(9, il.get(3).getTime() / 1000);
+        assertEquals(7, il.get(4).getTime() / 1000);
+        assertEquals(30, il.get(5).getTime() / 1000);
+
+        assertEquals(87, arsp.getPoints().size());
     }
 
     @Test
@@ -151,8 +148,9 @@ public void testUTurn() {
                 setOSMFile(DIR + "/monaco.osm.gz").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
         tmpHopper.importOrLoad();
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
 
         GHRequest request = new GHRequest();
         //Force initial U-Turn
@@ -167,11 +165,10 @@ public void testUTurn() {
         InstructionList il = arsp.getInstructions();
         assertEquals(3, il.size());
 
-        List<Map<String, Object>> resultJson = il.createJson();
         // Initial U-turn
-        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(0).get("text"));
+        assertEquals("make a U-turn onto Avenue Princesse Grace", il.get(0).getTurnDescription(tr));
         // Second U-turn to get to destination
-        assertEquals("Make a U-turn onto Avenue Princesse Grace", resultJson.get(1).get("text"));
+        assertEquals("make a U-turn onto Avenue Princesse Grace", il.get(1).getTurnDescription(tr));
     }
 
     @Test
@@ -203,7 +200,7 @@ public void testAlternativeRoutesBikeAndCar() {
                 setOSMFile(DIR + "/north-bayreuth.osm.gz").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("bike, car"));
+                setEncodingManager(EncodingManager.create("bike, car"));
         tmpHopper.importOrLoad();
 
         GHRequest req = new GHRequest(50.028917, 11.496506, 49.985228, 11.600876).
@@ -241,7 +238,7 @@ public void testPointHint() {
                 setOSMFile(DIR + "/Laufamholzstrasse.osm.xml").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
         tmpHopper.importOrLoad();
 
         GHRequest req = new GHRequest(49.46553, 11.154669, 49.465244, 11.152577).
@@ -250,14 +247,14 @@ public void testPointHint() {
         req.setPointHints(new ArrayList<>(Arrays.asList("Laufamholzstraße, 90482, Nürnberg, Deutschland", "")));
         GHResponse rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        GHPoint snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        GHPoint snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465686, snappedPoint.getLat(), .000001);
         assertEquals(11.154605, snappedPoint.getLon(), .000001);
 
         req.setPointHints(new ArrayList<>(Arrays.asList("", "")));
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465502, snappedPoint.getLat(), .000001);
         assertEquals(11.154498, snappedPoint.getLon(), .000001);
 
@@ -265,7 +262,7 @@ public void testPointHint() {
         req.setPointHints(new ArrayList<>(Arrays.asList("xy", "")));
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        snappedPoint = rsp.getBest().getWaypoints().toGHPoint(0);
+        snappedPoint = rsp.getBest().getWaypoints().get(0);
         assertEquals(49.465502, snappedPoint.getLat(), .000001);
         assertEquals(11.154498, snappedPoint.getLon(), .000001);
     }
@@ -276,7 +273,7 @@ public void testNorthBayreuthDestination() {
                 setOSMFile(DIR + "/north-bayreuth.osm.gz").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car,generic", 8));
+                setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).addAll(new DefaultFlagEncoderFactory(), "car,generic").build());
         tmpHopper.importOrLoad();
 
         GHRequest req = new GHRequest(49.985307, 11.50628, 49.985731, 11.507465).
@@ -295,16 +292,15 @@ public void testNorthBayreuthDestination() {
     }
 
     @Test
-    public void testNorthBayreuthBlockeEdges() {
+    public void testNorthBayreuthBlockedEdges() {
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(DIR + "/north-bayreuth.osm.gz").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("generic,car", 8));
+                setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).add(new CarFlagEncoder()).build());
         tmpHopper.importOrLoad();
 
-        GHRequest req = new GHRequest(49.985272, 11.506151, 49.986107, 11.507202).
-                setVehicle("generic").setWeighting("generic");
+        GHRequest req = new GHRequest(49.985272, 11.506151, 49.986107, 11.507202);
 
         GHResponse rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
@@ -317,7 +313,7 @@ public void testNorthBayreuthBlockeEdges() {
         assertEquals(365, rsp.getBest().getDistance(), 1);
 
         req = new GHRequest(49.975845, 11.522598, 50.026821, 11.497364).
-                setVehicle("generic").setWeighting("generic");
+                setWeighting("fastest");
 
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
@@ -334,7 +330,7 @@ public void testNorthBayreuthBlockeEdges() {
         req.getHints().put(Routing.BLOCK_AREA, "50.017578,11.547527;" + someArea);
         rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
-        assertEquals(16674, rsp.getBest().getDistance(), 1);
+        assertEquals(12787, rsp.getBest().getDistance(), 1);
 
         // block by edge IDs -> i.e. use small circular area
         req.getHints().put(Routing.BLOCK_AREA, "49.981599,11.517448,100");
@@ -364,6 +360,7 @@ public void testNorthBayreuthBlockeEdges() {
 
     @Test
     public void testMonacoVia() {
+        Translation tr = hopper.getTranslationMap().getWithFallBack(Locale.US);
         GHResponse rsp = hopper.route(new GHRequest().
                 addPoint(new GHPoint(43.727687, 7.418737)).
                 addPoint(new GHPoint(43.74958, 7.436566)).
@@ -376,36 +373,35 @@ public void testMonacoVia() {
 
         InstructionList il = arsp.getInstructions();
         assertEquals(38, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(0).get("text"));
-        assertEquals("Continue onto Avenue des Papalins", resultJson.get(1).get("text"));
-        assertEquals("Turn sharp right onto Quai Jean-Charles Rey", resultJson.get(4).get("text"));
-        assertEquals("Turn left", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Avenue Albert II", resultJson.get(6).get("text"));
-
-        assertEquals("Waypoint 1", resultJson.get(20).get("text"));
-        assertEquals(Instruction.U_TURN_UNKNOWN, resultJson.get(21).get("sign"));
-
-        assertEquals("Continue onto Avenue Albert II", resultJson.get(31).get("text"));
-        assertEquals("Turn left", resultJson.get(32).get("text"));
-        assertEquals("Turn right onto Quai Jean-Charles Rey", resultJson.get(33).get("text"));
-        assertEquals("Turn sharp left onto Avenue des Papalins", resultJson.get(34).get("text"));
-        assertEquals("Continue onto Avenue des Guelfes", resultJson.get(36).get("text"));
-        assertEquals("Arrive at destination", resultJson.get(37).get("text"));
-
-        assertEquals(11, (Double) resultJson.get(0).get("distance"), 1);
-        assertEquals(97, (Double) resultJson.get(1).get("distance"), 1);
-        assertEquals(178, (Double) resultJson.get(2).get("distance"), 1);
-        assertEquals(13, (Double) resultJson.get(3).get("distance"), 1);
-        assertEquals(10, (Double) resultJson.get(4).get("distance"), 1);
-        assertEquals(42, (Double) resultJson.get(5).get("distance"), 1);
-
-        assertEquals(7, (Long) resultJson.get(0).get("time") / 1000);
-        assertEquals(69, (Long) resultJson.get(1).get("time") / 1000);
-        assertEquals(128, (Long) resultJson.get(2).get("time") / 1000);
-        assertEquals(9, (Long) resultJson.get(3).get("time") / 1000);
-        assertEquals(7, (Long) resultJson.get(4).get("time") / 1000);
-        assertEquals(30, (Long) resultJson.get(5).get("time") / 1000);
+        assertEquals("continue onto Avenue des Guelfes", il.get(0).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Papalins", il.get(1).getTurnDescription(tr));
+        assertEquals("turn sharp right onto Quai Jean-Charles Rey", il.get(4).getTurnDescription(tr));
+        assertEquals("turn left", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Avenue Albert II", il.get(6).getTurnDescription(tr));
+
+        assertEquals("waypoint 1", il.get(20).getTurnDescription(tr));
+        assertEquals(Instruction.U_TURN_UNKNOWN, il.get(21).getSign());
+
+        assertEquals("continue onto Avenue Albert II", il.get(31).getTurnDescription(tr));
+        assertEquals("turn left", il.get(32).getTurnDescription(tr));
+        assertEquals("turn right onto Quai Jean-Charles Rey", il.get(33).getTurnDescription(tr));
+        assertEquals("turn sharp left onto Avenue des Papalins", il.get(34).getTurnDescription(tr));
+        assertEquals("continue onto Avenue des Guelfes", il.get(36).getTurnDescription(tr));
+        assertEquals("arrive at destination", il.get(37).getTurnDescription(tr));
+
+        assertEquals(11, il.get(0).getDistance(), 1);
+        assertEquals(97, il.get(1).getDistance(), 1);
+        assertEquals(178, il.get(2).getDistance(), 1);
+        assertEquals(13, il.get(3).getDistance(), 1);
+        assertEquals(10, il.get(4).getDistance(), 1);
+        assertEquals(42, il.get(5).getDistance(), 1);
+
+        assertEquals(7, il.get(0).getTime() / 1000);
+        assertEquals(69, il.get(1).getTime() / 1000);
+        assertEquals(128, il.get(2).getTime() / 1000);
+        assertEquals(9, il.get(3).getTime() / 1000);
+        assertEquals(7, il.get(4).getTime() / 1000);
+        assertEquals(30, il.get(5).getTime() / 1000);
 
         // special case of identical start and end point
         rsp = hopper.route(new GHRequest().
@@ -418,8 +414,8 @@ public void testMonacoVia() {
         assertEquals(0, arsp.getRouteWeight(), .1);
         assertEquals(1, arsp.getPoints().getSize());
         assertEquals(1, arsp.getInstructions().size());
-        assertEquals("Arrive at destination", arsp.getInstructions().createJson().get(0).get("text"));
-        assertEquals(Instruction.FINISH, arsp.getInstructions().createJson().get(0).get("sign"));
+        assertEquals("arrive at destination", arsp.getInstructions().get(0).getTurnDescription(tr));
+        assertEquals(Instruction.FINISH, arsp.getInstructions().get(0).getSign());
 
         rsp = hopper.route(new GHRequest().
                 addPoint(new GHPoint(43.727687, 7.418737)).
@@ -432,8 +428,8 @@ public void testMonacoVia() {
         assertEquals(0, arsp.getRouteWeight(), .1);
         assertEquals(1, arsp.getPoints().getSize());
         assertEquals(2, arsp.getInstructions().size());
-        assertEquals(Instruction.REACHED_VIA, arsp.getInstructions().createJson().get(0).get("sign"));
-        assertEquals(Instruction.FINISH, arsp.getInstructions().createJson().get(1).get("sign"));
+        assertEquals(Instruction.REACHED_VIA, arsp.getInstructions().get(0).getSign());
+        assertEquals(Instruction.FINISH, arsp.getInstructions().get(1).getSign());
     }
 
     @Test
@@ -443,14 +439,14 @@ public void testMonacoPathDetails() {
         request.addPoint(new GHPoint(43.74958, 7.436566));
         request.addPoint(new GHPoint(43.727687, 7.418737));
         request.setAlgorithm(ASTAR).setVehicle(vehicle).setWeighting(weightCalcStr);
-        request.setPathDetails(Arrays.asList(Parameters.DETAILS.AVERAGE_SPEED));
+        request.setPathDetails(Arrays.asList(Parameters.Details.AVERAGE_SPEED));
 
         GHResponse rsp = hopper.route(request);
 
         PathWrapper arsp = rsp.getBest();
         Map<String, List<PathDetail>> details = arsp.getPathDetails();
         assertTrue(details.size() == 1);
-        List<PathDetail> detailList = details.get(Parameters.DETAILS.AVERAGE_SPEED);
+        List<PathDetail> detailList = details.get(Parameters.Details.AVERAGE_SPEED);
         assertEquals(1, detailList.size());
         assertEquals(5.0, detailList.get(0).getValue());
         assertEquals(0, detailList.get(0).getFirst());
@@ -575,7 +571,7 @@ public void testSRTMWithInstructions() throws Exception {
                 setStoreOnFlush(true).
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager(importVehicles));
+                setEncodingManager(EncodingManager.create(importVehicles));
 
         tmpHopper.setElevationProvider(new SRTMProvider(DIR));
         tmpHopper.importOrLoad();
@@ -610,22 +606,20 @@ public void testSRTMWithInstructions() throws Exception {
         assertEquals(99, arsp.getAscend(), 1e-1);
         assertEquals(150, arsp.getDescend(), 1e-1);
 
-        List<GPXEntry> list = arsp.getInstructions().createGPXList();
-        assertEquals(54, list.size());
-        final long lastEntryMillis = list.get(list.size() - 1).getTime();
-        assertEquals(new GPXEntry(43.73068455771767, 7.421283689825812, 62.0, 0), list.get(0));
-        assertEquals(new GPXEntry(43.727680946587874, 7.4191987684222065, 11.0, lastEntryMillis), list.get(list.size() - 1));
+        assertEquals(54, arsp.getPoints().size());
+        assertEquals(new GHPoint3D(43.73068455771767, 7.421283689825812, 62.0), arsp.getPoints().get(0));
+        assertEquals(new GHPoint3D(43.727680946587874, 7.4191987684222065, 11.0), arsp.getPoints().get(arsp.getPoints().size()-1));
 
-        assertEquals(62, il.createGPXList().get(0).getElevation(), 1e-2);
-        assertEquals(66, il.createGPXList().get(1).getElevation(), 1e-2);
-        assertEquals(52, il.createGPXList().get(10).getElevation(), 1e-2);
+        assertEquals(62, arsp.getPoints().get(0).getElevation(), 1e-2);
+        assertEquals(66, arsp.getPoints().get(1).getElevation(), 1e-2);
+        assertEquals(52, arsp.getPoints().get(10).getElevation(), 1e-2);
     }
 
     @Test
-    public void testSRTMWithoutTunnelInterpolation() throws Exception {
+    public void testSRTMWithoutTunnelInterpolation() {
         GraphHopper tmpHopper = new GraphHopperOSM().setOSMFile(osmFile).setStoreOnFlush(true)
                 .setCHEnabled(false).setGraphHopperLocation(tmpGraphFile)
-                .setEncodingManager(new EncodingManager(importVehicles, 8));
+                .setEncodingManager(EncodingManager.create(importVehicles, 8));
 
         tmpHopper.setElevationProvider(new SRTMProvider(DIR));
         tmpHopper.importOrLoad();
@@ -648,10 +642,10 @@ public void testSRTMWithoutTunnelInterpolation() throws Exception {
     }
 
     @Test
-    public void testSRTMWithTunnelInterpolation() throws Exception {
+    public void testSRTMWithTunnelInterpolation() {
         GraphHopper tmpHopper = new GraphHopperOSM().setOSMFile(osmFile).setStoreOnFlush(true)
                 .setCHEnabled(false).setGraphHopperLocation(tmpGraphFile)
-                .setEncodingManager(new EncodingManager(genericImportVehicles, 8));
+                .setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).addAll(new DefaultFlagEncoderFactory(), genericImportVehicles).build());
 
         tmpHopper.setElevationProvider(new SRTMProvider(DIR));
         tmpHopper.importOrLoad();
@@ -661,12 +655,12 @@ public void testSRTMWithTunnelInterpolation() throws Exception {
                 .setVehicle(vehicle).setWeighting(weightCalcStr));
         PathWrapper arsp = rsp.getBest();
         // Without interpolation: 356.5
-        assertEquals(351.4, arsp.getDistance(), .1);
+        assertEquals(351, arsp.getDistance(), .1);
         PointList pointList = arsp.getPoints();
         assertEquals(6, pointList.getSize());
         assertTrue(pointList.is3D());
 
-        assertEquals(17, pointList.getEle(0), .1);
+        assertEquals(18, pointList.getEle(0), .1);
         assertEquals(19.04, pointList.getEle(1), .1);
         assertEquals(21.67, pointList.getEle(2), .1);
         assertEquals(25.03, pointList.getEle(3), .1);
@@ -686,9 +680,10 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
                 setStoreOnFlush(true).
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                setEncodingManager(EncodingManager.create(tmpImportVehicles)).
                 importOrLoad();
 
+        Translation tr = tmpHopper.getTranslationMap().getWithFallBack(Locale.US);
         GHResponse rsp = tmpHopper.route(new GHRequest(48.410987, 15.599492, 48.383419, 15.659294).
                 setAlgorithm(ASTAR).setVehicle(tmpVehicle).setWeighting(tmpWeightCalcStr));
 
@@ -698,25 +693,24 @@ public void testKremsCyclewayInstructionsWithWayTypeInfo() {
 
         InstructionList il = arsp.getInstructions();
         assertEquals(24, il.size());
-        List<Map<String, Object>> resultJson = il.createJson();
-
-        assertEquals("Continue onto Obere Landstraße", resultJson.get(0).get("text"));
-        assertEquals("get off the bike", resultJson.get(0).get("annotation_text"));
-        assertEquals(69.28, (Double) resultJson.get(0).get("heading"), .01);
-        assertEquals("Turn left onto Kirchengasse", resultJson.get(1).get("text"));
-        assertEquals("get off the bike", resultJson.get(1).get("annotation_text"));
-
-        assertEquals("Turn right onto Pfarrplatz", resultJson.get(2).get("text"));
-        assertEquals("Turn right onto Margarethenstraße", resultJson.get(3).get("text"));
-        assertEquals("Keep left onto Hoher Markt", resultJson.get(5).get("text"));
-        assertEquals("Turn right onto Wegscheid", resultJson.get(7).get("text"));
-        assertEquals("Turn right onto Ringstraße, L73", resultJson.get(9).get("text"));
-        assertEquals("Keep left onto Eyblparkstraße", resultJson.get(10).get("text"));
-        assertEquals("Keep left onto Austraße", resultJson.get(11).get("text"));
-        assertEquals("Keep left onto Rechte Kremszeile", resultJson.get(12).get("text"));
+
+        assertEquals("continue onto Obere Landstraße", il.get(0).getTurnDescription(tr));
+        assertEquals("get off the bike", il.get(0).getAnnotation().getMessage());
+        assertEquals(69.28, (Double) il.get(0).getExtraInfoJSON().get("heading"), .01);
+        assertEquals("turn left onto Kirchengasse", il.get(1).getTurnDescription(tr));
+        assertEquals("get off the bike", il.get(1).getAnnotation().getMessage());
+
+        assertEquals("turn right onto Pfarrplatz", il.get(2).getTurnDescription(tr));
+        assertEquals("turn right onto Margarethenstraße", il.get(3).getTurnDescription(tr));
+        assertEquals("keep left onto Hoher Markt", il.get(5).getTurnDescription(tr));
+        assertEquals("turn right onto Wegscheid", il.get(7).getTurnDescription(tr));
+        assertEquals("turn right onto Ringstraße, L73", il.get(9).getTurnDescription(tr));
+        assertEquals("keep left onto Eyblparkstraße", il.get(10).getTurnDescription(tr));
+        assertEquals("keep left onto Austraße", il.get(11).getTurnDescription(tr));
+        assertEquals("keep left onto Rechte Kremszeile", il.get(12).getTurnDescription(tr));
         //..
-        assertEquals("Turn right onto Treppelweg", resultJson.get(19).get("text"));
-        assertEquals("cycleway", resultJson.get(19).get("annotation_text"));
+        assertEquals("turn right onto Treppelweg", il.get(19).getTurnDescription(tr));
+        assertEquals("cycleway", il.get(19).getAnnotation().getMessage());
     }
 
     @Test
@@ -730,7 +724,7 @@ public void testRoundaboutInstructionsWithCH() {
                 setOSMFile(tmpOsmFile).
                 setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                setEncodingManager(EncodingManager.create(tmpImportVehicles)).
                 importOrLoad();
 
         assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle().toString());
@@ -770,7 +764,7 @@ public void testCircularJunctionInstructionsWithCH() {
                 setOSMFile(tmpOsmFile).
                 setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager(tmpImportVehicles)).
+                setEncodingManager(EncodingManager.create(tmpImportVehicles)).
                 importOrLoad();
 
         assertEquals(tmpVehicle, tmpHopper.getDefaultVehicle().toString());
@@ -793,7 +787,7 @@ public void testMultipleVehiclesWithCH() {
                 setOSMFile(tmpOsmFile).
                 setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("bike,car")).
+                setEncodingManager(EncodingManager.create("bike,car")).
                 importOrLoad();
         assertEquals("bike", tmpHopper.getDefaultVehicle().toString());
         checkMultiVehiclesWithCH(tmpHopper);
@@ -805,7 +799,7 @@ public void testMultipleVehiclesWithCH() {
                 setOSMFile(tmpOsmFile).
                 setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car,bike")).
+                setEncodingManager(EncodingManager.create("car,bike")).
                 importOrLoad();
         assertEquals("car", tmpHopper.getDefaultVehicle().toString());
         checkMultiVehiclesWithCH(tmpHopper);
@@ -858,7 +852,7 @@ private void executeCHFootRoute() {
                 setOSMFile(tmpOsmFile).
                 setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager(tmpImportVehicles));
+                setEncodingManager(EncodingManager.create(tmpImportVehicles));
         tmpHopper.getCHFactoryDecorator().setWeightingsAsStrings(weightCalcStr);
         tmpHopper.importOrLoad();
 
@@ -901,7 +895,7 @@ public void testPathDetails1216() {
                 setOSMFile(DIR + "/north-bayreuth.osm.gz").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
         tmpHopper.importOrLoad();
 
         GHRequest req = new GHRequest().
@@ -910,7 +904,7 @@ public void testPathDetails1216() {
                         addPoint(new GHPoint(49.984565, 11.499188)).
                         addPoint(new GHPoint(49.9847, 11.499612)).
                         setVehicle("car").setWeighting("fastest").
-                        setPathDetails(Arrays.asList(Parameters.DETAILS.AVERAGE_SPEED));
+                        setPathDetails(Arrays.asList(Parameters.Details.AVERAGE_SPEED));
 
         GHResponse rsp = tmpHopper.route(req);
 
@@ -923,14 +917,14 @@ public void testPathDetailsSamePoint() {
                 setOSMFile(DIR + "/north-bayreuth.osm.gz").
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
         tmpHopper.importOrLoad();
 
         GHRequest req = new GHRequest().
                 addPoint(new GHPoint(49.984352, 11.498802)).
                 addPoint(new GHPoint(49.984352, 11.498802)).
                 setVehicle("car").setWeighting("fastest").
-                setPathDetails(Arrays.asList(Parameters.DETAILS.AVERAGE_SPEED));
+                setPathDetails(Arrays.asList(Parameters.Details.AVERAGE_SPEED));
 
         GHResponse rsp = tmpHopper.route(req);
 
@@ -945,14 +939,14 @@ public void testFlexMode_631() {
                 setOSMFile(tmpOsmFile).
                 setStoreOnFlush(true).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
 
         tmpHopper.getCHFactoryDecorator().setEnabled(true).
                 setWeightingsAsStrings(Arrays.asList("fastest")).
                 setDisablingAllowed(true);
 
         tmpHopper.getLMFactoryDecorator().setEnabled(true).
-                setWeightingsAsStrings(Arrays.asList("fastest")).
+                setWeightingsAsStrings(Arrays.asList("fastest|maximum=2000")).
                 setDisablingAllowed(true);
 
         tmpHopper.importOrLoad();
@@ -1005,10 +999,10 @@ public void testTurnCostsOnOff() {
                 setStoreOnFlush(true).
                 setCHEnabled(false).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car|turn_costs=true"));
+                setEncodingManager(EncodingManager.create("car|turn_costs=true"));
         tmpHopper.importOrLoad();
 
-        // with turn costs (default if none-CH and turn cost enabled)
+        // with turn costs (default if non-CH and turn cost enabled)
         GHRequest req = new GHRequest(55.813357, 37.5958585, 55.811042, 37.594689);
         GHResponse rsp = tmpHopper.route(req);
         assertEquals(1044, rsp.getBest().getDistance(), 1);
@@ -1025,25 +1019,60 @@ public void testTurnCostsOnOff() {
     }
 
     @Test
-    public void testCHAndTurnCostsWithFlexmode() {
+    public void testTurnCostsOnOffCH() {
         GraphHopper tmpHopper = new GraphHopperOSM().
                 setOSMFile(DIR + "/moscow.osm.gz").
                 setStoreOnFlush(true).
+                setCHEnabled(true).
                 setGraphHopperLocation(tmpGraphFile).
-                setEncodingManager(new EncodingManager("car|turn_costs=true"));
+                setEncodingManager(EncodingManager.create("car|turn_costs=true"));
         tmpHopper.getCHFactoryDecorator().setDisablingAllowed(true);
+        tmpHopper.getCHFactoryDecorator().setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_AND_NODE);
         tmpHopper.importOrLoad();
 
-        // without turn costs (default for CH)
+        // without turn costs
         GHRequest req = new GHRequest(55.813357, 37.5958585, 55.811042, 37.594689);
+        req.getHints().put(Routing.EDGE_BASED, "false");
         GHResponse rsp = tmpHopper.route(req);
         assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
         assertEquals(400, rsp.getBest().getDistance(), 1);
 
         // with turn costs                
-        req.getHints().put(CH.DISABLE, "true");
         req.getHints().put(Routing.EDGE_BASED, "true");
         rsp = tmpHopper.route(req);
+        assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
         assertEquals(1044, rsp.getBest().getDistance(), 1);
     }
+
+    @Test
+    public void testCHOnOffWithTurnCosts() {
+        GraphHopper tmpHopper = new GraphHopperOSM().
+                setOSMFile(DIR + "/moscow.osm.gz").
+                setStoreOnFlush(true).
+                setCHEnabled(true).
+                setGraphHopperLocation(tmpGraphFile).
+                setEncodingManager(EncodingManager.create("car|turn_costs=true"));
+        tmpHopper.getCHFactoryDecorator()
+                .setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE)
+                .setDisablingAllowed(true);
+        tmpHopper.importOrLoad();
+
+        // with CH
+        GHRequest req = new GHRequest(55.813357, 37.5958585, 55.811042, 37.594689);
+        req.getHints().put(Routing.EDGE_BASED, "true");
+        req.getHints().put(CH.DISABLE, "false");
+        GHResponse rsp1 = tmpHopper.route(req);
+        assertFalse(rsp1.getErrors().toString(), rsp1.hasErrors());
+        assertEquals(1044, rsp1.getBest().getDistance(), 1);
+
+        // without CH      
+        req.getHints().put(Routing.EDGE_BASED, "true");
+        req.getHints().put(CH.DISABLE, "true");
+        GHResponse rsp2 = tmpHopper.route(req);
+        assertFalse(rsp2.getErrors().toString(), rsp2.hasErrors());
+        assertEquals(1044, rsp2.getBest().getDistance(), 1);
+        // just a quick check that we did not run the same algorithm twice
+        assertNotEquals(rsp1.getHints().get("visited_nodes.sum", "_"), rsp2.getHints().get("visited_nodes.sum", "_"));
+    }
+
 }
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index befe7ae6aa..214cf585fe 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -22,6 +22,8 @@
 import com.graphhopper.GHResponse;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.PathWrapper;
+import com.graphhopper.coll.GHBitSet;
+import com.graphhopper.coll.GHBitSetImpl;
 import com.graphhopper.reader.DataReader;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
@@ -32,11 +34,10 @@
 import com.graphhopper.routing.weighting.FastestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.CmdArgs;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.Instruction;
-import com.graphhopper.util.Parameters;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.util.*;
 import com.graphhopper.util.Parameters.Routing;
+import com.graphhopper.util.shapes.BBox;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.After;
 import org.junit.Before;
@@ -44,10 +45,7 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
+import java.util.*;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -82,7 +80,7 @@ public void tearDown() {
     public void testLoadOSM() {
         GraphHopper closableInstance = new GraphHopperOSM().
                 setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         closableInstance.importOrLoad();
@@ -103,14 +101,14 @@ public void testLoadOSM() {
         closableInstance.close();
         try {
             rsp = closableInstance.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertEquals("You need to create a new GraphHopper instance as it is already closed", ex.getMessage());
         }
 
         try {
             closableInstance.getLocationIndex().findClosest(51.2492152, 9.4317166, EdgeFilter.ALL_EDGES);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertEquals("You need to create a new LocationIndex instance as it is already closed", ex.getMessage());
         }
@@ -119,7 +117,7 @@ public void testLoadOSM() {
     @Test
     public void testLoadOSMNoCH() {
         GraphHopper gh = new GraphHopperOSM().setStoreOnFlush(true).setCHEnabled(false).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         gh.importOrLoad();
@@ -132,7 +130,7 @@ public void testLoadOSMNoCH() {
 
         gh.close();
         gh = new GraphHopperOSM().setStoreOnFlush(true).setCHEnabled(false).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
         assertTrue(gh.load(ghLoc));
         rsp = gh.route(new GHRequest(51.2492152, 9.4317166, 51.2, 9.4));
         assertFalse(rsp.hasErrors());
@@ -149,11 +147,70 @@ public void testLoadOSMNoCH() {
         gh.close();
     }
 
+    @Test
+    public void testQueryLocationIndexWithBBox() {
+        final GraphHopper gh = new GraphHopperOSM().setStoreOnFlush(true).
+                setEncodingManager(EncodingManager.create("car")).
+                setCHEnabled(false).
+                setGraphHopperLocation(ghLoc).
+                setDataReaderFile("../core/files/monaco.osm.gz");
+        gh.importOrLoad();
+
+        final NodeAccess na = gh.getGraphHopperStorage().getNodeAccess();
+        final Collection<Integer> indexNodeList = new TreeSet<>();
+        LocationIndexTree index = (LocationIndexTree) gh.getLocationIndex();
+        final EdgeExplorer edgeExplorer = gh.getGraphHopperStorage().createEdgeExplorer();
+        final BBox bbox = new BBox(7.422, 7.429, 43.729, 43.734);
+        index.query(bbox, new LocationIndexTree.EdgeVisitor(edgeExplorer) {
+            @Override
+            public void onTile(BBox bbox, int width) {
+            }
+
+            @Override
+            public void onEdge(EdgeIteratorState edge, int nodeA, int nodeB) {
+                for (int i = 0; i < 2; i++) {
+                    int nodeId = i == 0 ? nodeA : nodeB;
+                    double lat = na.getLatitude(nodeId);
+                    double lon = na.getLongitude(nodeId);
+                    if (bbox.contains(lat, lon))
+                        indexNodeList.add(nodeId);
+                }
+            }
+        });
+
+        assertEquals(57, indexNodeList.size());
+        for (int nodeId : indexNodeList) {
+            if (!bbox.contains(na.getLatitude(nodeId), na.getLongitude(nodeId)))
+                fail("bbox " + bbox + " should contain " + nodeId);
+        }
+
+        final Collection<Integer> bfsNodeList = new TreeSet<>();
+        new BreadthFirstSearch() {
+            @Override
+            protected GHBitSet createBitSet() {
+                return new GHBitSetImpl(gh.getGraphHopperStorage().getNodes());
+            }
+
+            @Override
+            protected boolean goFurther(int nodeId) {
+                double lat = na.getLatitude(nodeId);
+                double lon = na.getLongitude(nodeId);
+                if (bbox.contains(lat, lon))
+                    bfsNodeList.add(nodeId);
+
+                return true;
+            }
+        }.start(edgeExplorer, index.findClosest(43.731, 7.425, EdgeFilter.ALL_EDGES).getClosestNode());
+
+        assertTrue("index size: " + indexNodeList.size() + ", bfs size: " + bfsNodeList.size(), indexNodeList.size() >= bfsNodeList.size());
+        assertTrue("index size: " + indexNodeList.size() + ", bfs size: " + bfsNodeList.size(), indexNodeList.containsAll(bfsNodeList));
+    }
+
     @Test
     public void testLoadingWithDifferentCHConfig_issue471() {
         // with CH should not be loadable without CH configured
         GraphHopper gh = new GraphHopperOSM().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         gh.importOrLoad();
@@ -163,19 +220,19 @@ public void testLoadingWithDifferentCHConfig_issue471() {
         gh.close();
 
         gh = new GraphHopperOSM().setStoreOnFlush(true).setCHEnabled(false).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
         try {
             gh.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.ch.weightings:"));
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("You loaded a CH graph, but you did not specify graph.ch.weightings"));
         }
 
         Helper.removeDir(new File(ghLoc));
 
         // without CH should not be loadable with CH enabled
         gh = new GraphHopperOSM().setStoreOnFlush(true).setCHEnabled(false).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         gh.importOrLoad();
@@ -185,30 +242,30 @@ public void testLoadingWithDifferentCHConfig_issue471() {
         gh.close();
 
         gh = new GraphHopperOSM().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
         try {
             gh.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
-            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.ch.weightings:"));
+            assertTrue(ex.getMessage(), ex.getMessage().contains("is not contained in loaded weightings"));
         }
     }
 
     @Test
     public void testAllowMultipleReadingInstances() {
         GraphHopper instance1 = new GraphHopperOSM().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         instance1.importOrLoad();
 
         GraphHopper instance2 = new GraphHopperOSM().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setDataReaderFile(testOsm);
         instance2.load(ghLoc);
 
         GraphHopper instance3 = new GraphHopperOSM().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setDataReaderFile(testOsm);
         instance3.load(ghLoc);
 
@@ -233,7 +290,7 @@ protected DataReader importData() throws IOException {
                 return super.importData();
             }
         }.setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         final AtomicReference<Exception> ar = new AtomicReference<>();
@@ -250,14 +307,14 @@ public void run() {
         thread.start();
 
         GraphHopper instance2 = new GraphHopperOSM().setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setDataReaderFile(testOsm);
         try {
             // let thread reach the CountDownLatch
             latch2.await(3, TimeUnit.SECONDS);
             // now importOrLoad should have create a lock which this load call does not like
             instance2.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (RuntimeException ex) {
             assertNotNull(ex);
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("To avoid reading partial data"));
@@ -277,7 +334,7 @@ public void run() {
     public void testPrepare() {
         instance = new GraphHopperOSM().
                 setStoreOnFlush(false).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         instance.getCHFactoryDecorator().setWeightingsAsStrings("shortest");
@@ -293,7 +350,7 @@ public void testPrepare() {
     public void testSortedGraph_noCH() {
         instance = new GraphHopperOSM().setStoreOnFlush(false).
                 setSortGraph(true).
-                setEncodingManager(new EncodingManager("car")).setCHEnabled(false).
+                setEncodingManager(EncodingManager.create("car")).setCHEnabled(false).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm);
         instance.importOrLoad();
@@ -301,26 +358,26 @@ public void testSortedGraph_noCH() {
                 setAlgorithm(DIJKSTRA_BI)).getBest();
         assertFalse(rsp.hasErrors());
         assertEquals(3, rsp.getPoints().getSize());
-        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().toGHPoint(0));
-        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().toGHPoint(1));
-        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().toGHPoint(2));
+        assertEquals(new GHPoint(51.24921503475044, 9.431716451757769), rsp.getPoints().get(0));
+        assertEquals(new GHPoint(52.0, 9.0), rsp.getPoints().get(1));
+        assertEquals(new GHPoint(51.199999850988384, 9.39999970197677), rsp.getPoints().get(2));
 
         GHRequest req = new GHRequest(51.2492152, 9.4317166, 51.2, 9.4);
-        boolean old = instance.isEnableInstructions();
+        boolean old = instance.getEncodingManager().isEnableInstructions();
         req.getHints().put("instructions", true);
         instance.route(req);
-        assertEquals(old, instance.isEnableInstructions());
+        assertEquals(old, instance.getEncodingManager().isEnableInstructions());
 
         req.getHints().put("instructions", false);
         instance.route(req);
-        assertEquals("route method should not change instance field", old, instance.isEnableInstructions());
+        assertEquals("route method should not change instance field", old, instance.getEncodingManager().isEnableInstructions());
     }
 
     @Test
     public void testFootAndCar() {
         // now all ways are imported
         instance = new GraphHopperOSM().setStoreOnFlush(false).
-                setEncodingManager(new EncodingManager("car,foot")).setCHEnabled(false).
+                setEncodingManager(EncodingManager.create("car,foot")).setCHEnabled(false).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm3);
         instance.importOrLoad();
@@ -362,7 +419,7 @@ public void testFootAndCar() {
     }
 
     @Test
-    public void testFailsForWrongConfig() throws IOException {
+    public void testFailsForWrongConfig() {
         instance = new GraphHopperOSM().init(
                 new CmdArgs().
                         put("datareader.file", testOsm3).
@@ -384,7 +441,7 @@ public void testFailsForWrongConfig() throws IOException {
                             put(Parameters.CH.PREPARE + "weightings", "no")).
                     setDataReaderFile(testOsm3);
             tmpGH.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
         }
@@ -400,7 +457,7 @@ public void testFailsForWrongConfig() throws IOException {
                 setDataReaderFile(testOsm3);
         try {
             instance.load(ghLoc);
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Configured graph.bytes_for_flags (8) is not equal to loaded 4"));
         }
@@ -414,23 +471,91 @@ public void testFailsForWrongConfig() throws IOException {
                     put("graph.flag_encoders", "car,foot")).
                     setDataReaderFile(testOsm3);
             tmpGH.load(ghLoc);
-            assertTrue(false);
+            fail();
+        } catch (Exception ex) {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
+        }
+
+        // different encoded values should fail to load
+        instance = new GraphHopperOSM().init(
+                new CmdArgs().
+                        put("datareader.file", testOsm3).
+                        put("datareader.dataaccess", "RAM").
+                        put("graph.encoded_values", "road_class").
+                        put("graph.flag_encoders", "foot,car").
+                        put(Parameters.CH.PREPARE + "weightings", "no")).
+                setDataReaderFile(testOsm3);
+        try {
+            instance.load(ghLoc);
+            fail();
+        } catch (Exception ex) {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoded values do not match"));
+        }
+
+        // different version for car should fail
+        instance = new GraphHopperOSM().setEncodingManager(EncodingManager.create(new FootFlagEncoder(), new CarFlagEncoder() {
+            @Override
+            public int getVersion() {
+                return 0;
+            }
+        })).init(
+                new CmdArgs().
+                        put("datareader.file", testOsm3).
+                        put("datareader.dataaccess", "RAM").
+                        put(Parameters.CH.PREPARE + "weightings", "no")).
+                setDataReaderFile(testOsm3);
+        try {
+            instance.load(ghLoc);
+            fail();
         } catch (Exception ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoding does not match"));
         }
     }
 
+    @Test
+    public void testFailsForWrongEVConfig() {
+        instance = new GraphHopperOSM().init(
+                new CmdArgs().
+                        put("datareader.file", testOsm3).
+                        put("datareader.dataaccess", "RAM").
+                        put("graph.flag_encoders", "foot,car").
+                        put(Parameters.CH.PREPARE + "weightings", "no")).
+                setGraphHopperLocation(ghLoc);
+        instance.importOrLoad();
+        // older versions <= 0.12 did not store this property, ensure that we fail to load it
+        instance.getGraphHopperStorage().getProperties().remove("graph.encoded_values");
+        instance.getGraphHopperStorage().flush();
+        assertEquals(5, instance.getGraphHopperStorage().getNodes());
+        instance.close();
+
+        // different encoded values should fail to load
+        instance = new GraphHopperOSM().init(
+                new CmdArgs().
+                        put("datareader.file", testOsm3).
+                        put("datareader.dataaccess", "RAM").
+                        put("graph.encoded_values", "road_environment,road_class").
+                        put("graph.flag_encoders", "foot,car").
+                        put(Parameters.CH.PREPARE + "weightings", "no")).
+                setDataReaderFile(testOsm3);
+        try {
+            instance.load(ghLoc);
+            fail();
+        } catch (Exception ex) {
+            assertTrue(ex.getMessage(), ex.getMessage().startsWith("Encoded values do not match"));
+        }
+    }
+
     @Test
     public void testNoNPE_ifLoadNotSuccessful() {
         instance = new GraphHopperOSM().
                 setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
         try {
             // loading from empty directory
             new File(ghLoc).mkdirs();
             assertFalse(instance.load(ghLoc));
             instance.route(new GHRequest(10, 40, 12, 32));
-            assertTrue(false);
+            fail();
         } catch (IllegalStateException ex) {
             assertEquals("Do a successful call to load or importOrLoad before routing", ex.getMessage());
         }
@@ -439,7 +564,7 @@ public void testNoNPE_ifLoadNotSuccessful() {
     @Test
     public void testDoesNotCreateEmptyFolderIfLoadingFromNonExistingPath() {
         instance = new GraphHopperOSM().
-                setEncodingManager(new EncodingManager("car"));
+                setEncodingManager(EncodingManager.create("car"));
 
         assertFalse(instance.load(ghLoc));
         assertFalse(new File(ghLoc).exists());
@@ -459,7 +584,7 @@ public DataReader importData() throws IOException {
         try {
             tmp.setDataReaderFile(testOsm);
             tmp.importData();
-            assertTrue(false);
+            fail();
         } catch (IllegalStateException ex) {
             assertEquals("Load graph before importing OSM data", ex.getMessage());
         }
@@ -468,7 +593,7 @@ public DataReader importData() throws IOException {
         instance = new GraphHopperOSM();
         try {
             instance.importOrLoad();
-            assertTrue(false);
+            fail();
         } catch (IllegalStateException ex) {
             assertEquals("GraphHopperLocation is not specified. Call setGraphHopperLocation or init before", ex.getMessage());
         }
@@ -476,11 +601,11 @@ public DataReader importData() throws IOException {
         // missing OSM file to import
         instance = new GraphHopperOSM().
                 setStoreOnFlush(true).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc);
         try {
             instance.importOrLoad();
-            assertTrue(false);
+            fail();
         } catch (IllegalStateException ex) {
             assertEquals("Couldn't load from existing folder: " + ghLoc
                     + " but also cannot use file for DataReader as it wasn't specified!", ex.getMessage());
@@ -493,7 +618,7 @@ public DataReader importData() throws IOException {
                 setDataReaderFile(testOsm3);
         try {
             instance.importOrLoad();
-            assertTrue(false);
+            fail();
         } catch (IllegalStateException ex) {
             assertTrue(ex.getMessage(), ex.getMessage().startsWith("Cannot load properties to fetch EncodingManager"));
         }
@@ -501,11 +626,11 @@ public DataReader importData() throws IOException {
         // Import is possible even if no storeOnFlush is specified BUT here we miss the OSM file
         instance = new GraphHopperOSM().
                 setStoreOnFlush(false).
-                setEncodingManager(new EncodingManager("car")).
+                setEncodingManager(EncodingManager.create("car")).
                 setGraphHopperLocation(ghLoc);
         try {
             instance.importOrLoad();
-            assertTrue(false);
+            fail();
         } catch (Exception ex) {
             assertEquals("Couldn't load from existing folder: " + ghLoc
                     + " but also cannot use file for DataReader as it wasn't specified!", ex.getMessage());
@@ -516,7 +641,7 @@ public DataReader importData() throws IOException {
     public void testFootOnly() {
         // now only footable ways are imported => no A D C and B D E => the other both ways have pillar nodes!
         instance = new GraphHopperOSM().setStoreOnFlush(false).
-                setEncodingManager(new EncodingManager("foot")).
+                setEncodingManager(EncodingManager.create("foot")).
                 setGraphHopperLocation(ghLoc).
                 setDataReaderFile(testOsm3);
         instance.importOrLoad();
@@ -683,7 +808,7 @@ public void testGetPathsDirectionEnforcement6() {
 
     private GraphHopper createSquareGraphInstance(boolean withCH) {
         CarFlagEncoder carEncoder = new CarFlagEncoder();
-        EncodingManager encodingManager = new EncodingManager(carEncoder);
+        EncodingManager encodingManager = EncodingManager.create(carEncoder);
         Weighting weighting = new FastestWeighting(carEncoder);
         GraphHopperStorage g = new GraphHopperStorage(Collections.singletonList(weighting), new RAMDirectory(), encodingManager,
                 false, new GraphExtension.NoOpExtension()).
@@ -732,7 +857,7 @@ private GraphHopper createSquareGraphInstance(boolean withCH) {
     @Test
     public void testCustomFactoryForNoneCH() {
         CarFlagEncoder carEncoder = new CarFlagEncoder();
-        EncodingManager em = new EncodingManager(carEncoder);
+        EncodingManager em = EncodingManager.create(carEncoder);
         // Weighting weighting = new FastestWeighting(carEncoder);
         instance = new GraphHopperOSM().setStoreOnFlush(false).setCHEnabled(false).
                 setEncodingManager(em).
@@ -756,7 +881,7 @@ public boolean isEnabled() {
         });
         instance.importOrLoad();
 
-        assertTrue(af == instance.getAlgorithmFactory(null));
+        assertSame(af, instance.getAlgorithmFactory(null));
 
         // test that hints are passed to algorithm opts
         final AtomicInteger cnt = new AtomicInteger(0);
@@ -792,7 +917,7 @@ public void testMultipleCHPreparationsInParallel() {
         HashMap<String, Long> shortcutCountMap = new HashMap<>();
         // try all parallelization modes        
         for (int threadCount = 1; threadCount < 6; threadCount++) {
-            EncodingManager em = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
+            EncodingManager em = EncodingManager.create(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
                     new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder(), new FootFlagEncoder()), 8);
 
             GraphHopper tmpGH = new GraphHopperOSM().
@@ -809,7 +934,7 @@ public void testMultipleCHPreparationsInParallel() {
                 PrepareContractionHierarchies pch = (PrepareContractionHierarchies) raf;
                 assertTrue("Preparation wasn't run! [" + threadCount + "]", pch.isPrepared());
 
-                String name = AbstractWeighting.weightingToFileName(pch.getWeighting());
+                String name = AbstractWeighting.weightingToFileName(pch.getWeighting(), pch.isEdgeBased());
                 Long singleThreadShortcutCount = shortcutCountMap.get(name);
                 if (singleThreadShortcutCount == null)
                     shortcutCountMap.put(name, pch.getShortcuts());
@@ -833,7 +958,7 @@ public void testMultipleLMPreparationsInParallel() {
         HashMap<String, Integer> landmarkCount = new HashMap<>();
         // try all parallelization modes
         for (int threadCount = 1; threadCount < 6; threadCount++) {
-            EncodingManager em = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
+            EncodingManager em = EncodingManager.create(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
                     new MountainBikeFlagEncoder(), new RacingBikeFlagEncoder(), new FootFlagEncoder()), 8);
 
             GraphHopper tmpGH = new GraphHopperOSM().
@@ -853,7 +978,7 @@ public void testMultipleLMPreparationsInParallel() {
             for (PrepareLandmarks prepLM : tmpGH.getLMFactoryDecorator().getPreparations()) {
                 assertTrue("Preparation wasn't run! [" + threadCount + "]", prepLM.isPrepared());
 
-                String name = AbstractWeighting.weightingToFileName(prepLM.getWeighting());
+                String name = AbstractWeighting.weightingToFileName(prepLM.getWeighting(), false);
                 Integer singleThreadShortcutCount = landmarkCount.get(name);
                 if (singleThreadShortcutCount == null)
                     landmarkCount.put(name, prepLM.getSubnetworksWithLandmarks());
@@ -878,16 +1003,16 @@ public void testGetWeightingForCH() {
         TestEncoder simpleTruck = new TestEncoder("simple_truck");
 
         // use simple truck first
-        EncodingManager em = new EncodingManager(simpleTruck, truck);
+        EncodingManager em = EncodingManager.create(simpleTruck, truck);
         CHAlgoFactoryDecorator decorator = new CHAlgoFactoryDecorator();
         Weighting fwSimpleTruck = new FastestWeighting(simpleTruck);
         Weighting fwTruck = new FastestWeighting(truck);
         RAMDirectory ramDir = new RAMDirectory();
         GraphHopperStorage storage = new GraphHopperStorage(Arrays.asList(fwSimpleTruck, fwTruck), ramDir, em, false, new GraphExtension.NoOpExtension());
-        decorator.addWeighting(fwSimpleTruck);
-        decorator.addWeighting(fwTruck);
-        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleTruck), fwSimpleTruck, TraversalMode.NODE_BASED));
-        decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwTruck), fwTruck, TraversalMode.NODE_BASED));
+        decorator.addNodeBasedWeighting(fwSimpleTruck);
+        decorator.addNodeBasedWeighting(fwTruck);
+        decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, fwSimpleTruck, TraversalMode.NODE_BASED));
+        decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, fwTruck, TraversalMode.NODE_BASED));
 
         HintsMap wMap = new HintsMap("fastest");
         wMap.put("vehicle", "truck");
@@ -896,18 +1021,18 @@ public void testGetWeightingForCH() {
         assertEquals("fastest|simple_truck", ((PrepareContractionHierarchies) decorator.getDecoratedAlgorithmFactory(null, wMap)).getWeighting().toString());
 
         // make sure weighting cannot be mixed
-        decorator.addWeighting(fwTruck);
-        decorator.addWeighting(fwSimpleTruck);
+        decorator.addNodeBasedWeighting(fwTruck);
+        decorator.addNodeBasedWeighting(fwSimpleTruck);
         try {
-            decorator.addPreparation(new PrepareContractionHierarchies(ramDir, storage, storage.getGraph(CHGraph.class, fwSimpleTruck), fwSimpleTruck, TraversalMode.NODE_BASED));
-            assertTrue(false);
+            decorator.addPreparation(PrepareContractionHierarchies.fromGraphHopperStorage(storage, fwSimpleTruck, TraversalMode.NODE_BASED));
+            fail();
         } catch (Exception ex) {
         }
     }
 
     @Test
     public void testGetMultipleWeightingsForCH() {
-        EncodingManager em = new EncodingManager(Arrays.asList(new CarFlagEncoder()), 8);
+        EncodingManager em = EncodingManager.create(Arrays.asList(new CarFlagEncoder()), 8);
 
         GraphHopper tmpGH = new GraphHopperOSM().
                 setStoreOnFlush(false).
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
index 4d5be3fa0b..1a25f0f1c3 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderTest.java
@@ -28,11 +28,17 @@
 import com.graphhopper.reader.ReaderWay;
 import com.graphhopper.reader.dem.ElevationProvider;
 import com.graphhopper.reader.dem.SRTMProvider;
+import com.graphhopper.routing.profiles.*;
 import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.util.parsers.OSMMaxHeightParser;
+import com.graphhopper.routing.util.parsers.OSMMaxWeightParser;
+import com.graphhopper.routing.util.parsers.OSMMaxWidthParser;
+import com.graphhopper.routing.util.parsers.OSMRoadClassParser;
 import com.graphhopper.storage.*;
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.*;
+import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.shapes.GHPoint;
 import org.junit.After;
 import org.junit.Before;
@@ -40,7 +46,6 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.URISyntaxException;
 import java.util.*;
 
@@ -48,7 +53,6 @@
 
 /**
  * Tests the OSMReader with the normal helper initialized.
- * <p>
  *
  * @author Peter Karich
  */
@@ -67,6 +71,7 @@
     private final String fileRoadAttributes = "test-road-attributes.xml";
     private final String dir = "./target/tmp/test-db";
     private CarFlagEncoder carEncoder;
+    private BooleanEncodedValue carAccessEnc;
     private BikeFlagEncoder bikeEncoder;
     private FlagEncoder footEncoder;
     private EdgeExplorer carOutExplorer;
@@ -87,10 +92,6 @@ GraphHopperStorage newGraph(String directory, EncodingManager encodingManager, b
                 turnRestrictionsImport ? new TurnCostExtension() : new GraphExtension.NoOpExtension());
     }
 
-    InputStream getResource(String file) {
-        return getClass().getResourceAsStream(file);
-    }
-
     @Test
     public void testMain() {
         GraphHopper hopper = new GraphHopperFacade(file1).importOrLoad();
@@ -115,8 +116,8 @@ public void testMain() {
         assertEquals("street 123, B 122", iter.getName());
         assertEquals(n50, iter.getAdjNode());
         AbstractGraphStorageTester.assertPList(Helper.createPointList(51.25, 9.43), iter.fetchWayGeometry(0));
-        assertTrue(iter.isForward(carEncoder));
-        assertTrue(iter.isBackward(carEncoder));
+        assertTrue(iter.get(carAccessEnc));
+        assertTrue(iter.getReverse(carAccessEnc));
 
         assertTrue(iter.next());
         assertEquals("route 666", iter.getName());
@@ -128,8 +129,8 @@ public void testMain() {
         assertEquals(n10, iter.getAdjNode());
         assertEquals(88643, iter.getDistance(), 1);
 
-        assertTrue(iter.isForward(carEncoder));
-        assertTrue(iter.isBackward(carEncoder));
+        assertTrue(iter.get(carAccessEnc));
+        assertTrue(iter.getReverse(carAccessEnc));
         assertFalse(iter.next());
 
         // get third added location id=30
@@ -229,31 +230,30 @@ public void testOneWay() {
         assertTrue(iter.next());
         assertEquals(n30, iter.getAdjNode());
 
-        FlagEncoder encoder = carEncoder;
         iter = carAllExplorer.setBaseNode(n20);
         assertTrue(iter.next());
         assertEquals(n23, iter.getAdjNode());
-        assertTrue(iter.isForward(encoder));
-        assertFalse(iter.isBackward(encoder));
+        assertTrue(iter.get(carAccessEnc));
+        assertFalse(iter.getReverse(carAccessEnc));
 
         assertTrue(iter.next());
         assertEquals(n22, iter.getAdjNode());
-        assertFalse(iter.isForward(encoder));
-        assertTrue(iter.isBackward(encoder));
+        assertFalse(iter.get(carAccessEnc));
+        assertTrue(iter.getReverse(carAccessEnc));
 
         assertTrue(iter.next());
-        assertFalse(iter.isForward(encoder));
-        assertTrue(iter.isBackward(encoder));
+        assertFalse(iter.get(carAccessEnc));
+        assertTrue(iter.getReverse(carAccessEnc));
 
         assertTrue(iter.next());
         assertEquals(n30, iter.getAdjNode());
-        assertTrue(iter.isForward(encoder));
-        assertFalse(iter.isBackward(encoder));
+        assertTrue(iter.get(carAccessEnc));
+        assertFalse(iter.getReverse(carAccessEnc));
 
         assertTrue(iter.next());
         assertEquals(n10, iter.getAdjNode());
-        assertFalse(iter.isForward(encoder));
-        assertTrue(iter.isBackward(encoder));
+        assertFalse(iter.get(carAccessEnc));
+        assertTrue(iter.getReverse(carAccessEnc));
     }
 
     @Test
@@ -273,13 +273,13 @@ public void cleanUp() {
         int n80 = AbstractGraphStorageTester.getIdOf(graph, 54.1);
         EdgeIterator iter = carOutExplorer.setBaseNode(n80);
         iter.next();
-        assertEquals(5, carEncoder.getSpeed(iter.getFlags()), 1e-1);
+        assertEquals(5, iter.get(carEncoder.getAverageSpeedEnc()), 1e-1);
 
         // duration 01:10 is given => more precise speed calculation!
         // ~111km (from 54.0,10.1 to 55.0,10.2) in duration=70 minutes => 95km/h => / 1.4 => 71km/h
         iter = carOutExplorer.setBaseNode(n40);
         iter.next();
-        assertEquals(70, carEncoder.getSpeed(iter.getFlags()), 1e-1);
+        assertEquals(70, iter.get(carEncoder.getAverageSpeedEnc()), 1e-1);
     }
 
     @Test
@@ -294,7 +294,7 @@ public void cleanUp() {
         int n60 = AbstractGraphStorageTester.getIdOf(graph, 56.0);
         EdgeIterator iter = carOutExplorer.setBaseNode(n60);
         iter.next();
-        assertEquals(35, carEncoder.getSpeed(iter.getFlags()), 1e-1);
+        assertEquals(35, iter.get(carEncoder.getAverageSpeedEnc()), 1e-1);
     }
 
     @Test
@@ -392,6 +392,55 @@ public void testBarriers() {
         assertFalse(iter.next());
     }
 
+    @Test
+    public void avoidsLoopEdges_1525() {
+        // loops in OSM should be avoided by adding additional tower node (see #1525, #1531)
+        //     C - D
+        //      \ /
+        //   A - B - E
+        GraphHopper hopper = new GraphHopperFacade("test-avoid-loops.xml").importOrLoad();
+        checkLoop(hopper);
+    }
+
+    void checkLoop(GraphHopper hopper) {
+        GraphHopperStorage graph = hopper.getGraphHopperStorage();
+
+        // A, B, E and one of C or D should be tower nodes, in any case C and D should not be collapsed entirely
+        // into a loop edge from B to B.
+        assertEquals(4, graph.getNodes());
+        // two edges going to A and E and two edges going to C or D
+        AllEdgesIterator iter = graph.getAllEdges();
+        assertEquals(4, iter.length());
+        while (iter.next()) {
+            assertTrue("found a loop", iter.getAdjNode() != iter.getBaseNode());
+        }
+        int nodeB = AbstractGraphStorageTester.getIdOf(graph, 12);
+        assertTrue("could not find OSM node B", nodeB > -1);
+        assertEquals(4, GHUtility.count(graph.createEdgeExplorer().setBaseNode(nodeB)));
+    }
+
+    @Test
+    public void avoidsLoopEdgesIdenticalLatLon_1533() {
+        checkLoop(new GraphHopperFacade("test-avoid-loops2.xml").importOrLoad());
+    }
+
+    @Test
+    public void avoidsLoopEdgesIdenticalNodeIds_1533() {
+        // We can handle the following case with the proper result:
+        checkLoop(new GraphHopperFacade("test-avoid-loops3.xml").importOrLoad());
+        // We cannot handle the following case, i.e. no loop is created. so we only check that there are no loops
+        GraphHopper hopper = new GraphHopperFacade("test-avoid-loops4.xml").importOrLoad();
+        GraphHopperStorage graph = hopper.getGraphHopperStorage();
+        AllEdgesIterator iter = graph.getAllEdges();
+        assertEquals(2, iter.length());
+        while (iter.next()) {
+            assertTrue("found a loop", iter.getAdjNode() != iter.getBaseNode());
+        }
+        int nodeB = AbstractGraphStorageTester.getIdOf(graph, 12);
+        assertTrue("could not find OSM node B", nodeB > -1);
+        assertEquals(2, GHUtility.count(graph.createEdgeExplorer().setBaseNode(nodeB)));
+    }
+
     @Test
     public void testBarriersOnTowerNodes() {
         GraphHopper hopper = new GraphHopperFacade(fileBarriers).
@@ -417,7 +466,7 @@ public void testBarriersOnTowerNodes() {
 
     @Test
     public void testRelation() {
-        EncodingManager manager = new EncodingManager("bike");
+        EncodingManager manager = EncodingManager.create("bike");
         GraphHopperStorage ghStorage = new GraphHopperStorage(new RAMDirectory(), manager, false, new GraphExtension.NoOpExtension());
         OSMReader reader = new OSMReader(ghStorage);
         ReaderRelation osmRel = new ReaderRelation(1);
@@ -446,7 +495,7 @@ public void testRelation() {
 
     @Test
     public void testTurnRestrictions() {
-        GraphHopper hopper = new GraphHopperFacade(fileTurnRestrictions, true).
+        GraphHopper hopper = new GraphHopperFacade(fileTurnRestrictions, true, "").
                 importOrLoad();
 
         Graph graph = hopper.getGraphHopperStorage();
@@ -514,10 +563,16 @@ public void testTurnRestrictions() {
     @Test
     public void testRoadAttributes() {
         GraphHopper hopper = new GraphHopperFacade(fileRoadAttributes);
-        DataFlagEncoder dataFlagEncoder = (new DataFlagEncoder()).setStoreHeight(true).setStoreWeight(true).setStoreWidth(true);
-        hopper.setEncodingManager(new EncodingManager(Arrays.asList(dataFlagEncoder), 8));
+        DataFlagEncoder dataFlagEncoder = new DataFlagEncoder();
+        hopper.setEncodingManager(GHUtility.addDefaultEncodedValues(new EncodingManager.Builder(8)).
+                add(new OSMMaxWidthParser()).add(new OSMMaxHeightParser()).add(new OSMMaxWeightParser()).
+                add(dataFlagEncoder).build());
         hopper.importOrLoad();
 
+        DecimalEncodedValue widthEnc = hopper.getEncodingManager().getDecimalEncodedValue(MaxWidth.KEY);
+        DecimalEncodedValue heightEnc = hopper.getEncodingManager().getDecimalEncodedValue(MaxHeight.KEY);
+        DecimalEncodedValue weightEnc = hopper.getEncodingManager().getDecimalEncodedValue(MaxWeight.KEY);
+
         Graph graph = hopper.getGraphHopperStorage();
         DataFlagEncoder encoder = (DataFlagEncoder) hopper.getEncodingManager().getEncoder("generic");
         assertEquals(5, graph.getNodes());
@@ -526,7 +581,7 @@ public void testRoadAttributes() {
         int nb = AbstractGraphStorageTester.getIdOf(graph, 12, 51);
         int nc = AbstractGraphStorageTester.getIdOf(graph, 11.2, 52);
         int nd = AbstractGraphStorageTester.getIdOf(graph, 11.3, 51);
-        int ne = AbstractGraphStorageTester.getIdOf( graph, 10, 51 );
+        int ne = AbstractGraphStorageTester.getIdOf(graph, 10, 51);
 
         EdgeIteratorState edge_ab = GHUtility.getEdge(graph, na, nb);
         EdgeIteratorState edge_ad = GHUtility.getEdge(graph, na, nd);
@@ -537,32 +592,32 @@ public void testRoadAttributes() {
         EdgeIteratorState edge_ce = GHUtility.getEdge(graph, nc, ne);
         EdgeIteratorState edge_de = GHUtility.getEdge(graph, nd, ne);
 
-        assertEquals(4.0, encoder.getHeight(edge_ab), 1e-5);
-        assertEquals(2.5, encoder.getWidth(edge_ab), 1e-5);
-        assertEquals(4.4, encoder.getWeight(edge_ab), 1e-5);
+        assertEquals(4.0, edge_ab.get(heightEnc), 1e-5);
+        assertEquals(2.5, edge_ab.get(widthEnc), 1e-5);
+        assertEquals(4.4, edge_ab.get(weightEnc), 1e-5);
 
-        assertEquals(4.0, encoder.getHeight(edge_bc), 1e-5);
-        assertEquals(2.5, encoder.getWidth(edge_bc), 1e-5);
-        assertEquals(4.4, encoder.getWeight(edge_bc), 1e-5);
+        assertEquals(4.0, edge_bc.get(heightEnc), 1e-5);
+        assertEquals(2.5, edge_bc.get(widthEnc), 1e-5);
+        assertEquals(4.4, edge_bc.get(weightEnc), 1e-5);
 
-        assertEquals(4.4, encoder.getHeight(edge_ad), 1e-5);
-        assertEquals(3.5, encoder.getWidth(edge_ad), 1e-5);
-        assertEquals(17.5, encoder.getWeight(edge_ad), 1e-5);
+        assertEquals(4.4, edge_ad.get(heightEnc), 1e-5);
+        assertEquals(3.5, edge_ad.get(widthEnc), 1e-5);
+        assertEquals(17.5, edge_ad.get(weightEnc), 1e-5);
 
-        assertEquals(4.4, encoder.getHeight(edge_cd), 1e-5);
-        assertEquals(3.5, encoder.getWidth(edge_cd), 1e-5);
-        assertEquals(17.5, encoder.getWeight(edge_cd), 1e-5);
+        assertEquals(4.4, edge_cd.get(heightEnc), 1e-5);
+        assertEquals(3.5, edge_cd.get(widthEnc), 1e-5);
+        assertEquals(17.5, edge_cd.get(weightEnc), 1e-5);
     }
 
     @Test
     public void testEstimatedCenter() {
         final CarFlagEncoder encoder = new CarFlagEncoder() {
-            private EncodedValue objectEncoder;
+            private EncodedValueOld objectEncoder;
 
             @Override
             public int defineNodeBits(int index, int shift) {
                 shift = super.defineNodeBits(index, shift);
-                objectEncoder = new EncodedValue("oEnc", shift, 2, 1, 0, 3, true);
+                objectEncoder = new EncodedValueOld("oEnc", shift, 2, 1, 0, 3, true);
                 return shift + 2;
             }
 
@@ -573,7 +628,7 @@ public long handleNodeTags(ReaderNode node) {
                 return 0;
             }
         };
-        EncodingManager manager = new EncodingManager(encoder);
+        EncodingManager manager = EncodingManager.create(encoder);
         GraphHopperStorage ghStorage = newGraph(dir, manager, false, false);
         final Map<Integer, Double> latMap = new HashMap<>();
         final Map<Integer, Double> lonMap = new HashMap<>();
@@ -596,7 +651,7 @@ public long handleNodeTags(ReaderNode node) {
             }
 
             @Override
-            Collection<EdgeIteratorState> addOSMWay(LongIndexedContainer osmNodeIds, long wayFlags, long osmId) {
+            Collection<EdgeIteratorState> addOSMWay(LongIndexedContainer osmNodeIds, IntsRef wayFlags, long osmId) {
                 return Collections.emptyList();
             }
         };
@@ -677,7 +732,7 @@ public void testTurnFlagCombination() {
         CarFlagEncoder car = new CarFlagEncoder(5, 5, 24);
         FootFlagEncoder foot = new FootFlagEncoder();
         BikeFlagEncoder bike = new BikeFlagEncoder(4, 2, 24);
-        EncodingManager manager = new EncodingManager(Arrays.asList(bike, foot, car), 4);
+        EncodingManager manager = EncodingManager.create(Arrays.asList(bike, foot, car), 4);
 
         GraphHopperStorage ghStorage = new GraphBuilder(manager).create();
         OSMReader reader = new OSMReader(ghStorage) {
@@ -747,14 +802,14 @@ public void testTurnFlagCombination() {
 
     @Test
     public void testPreferredLanguage() {
-        GraphHopper hopper = new GraphHopperFacade(file1).setPreferredLanguage("de").importOrLoad();
+        GraphHopper hopper = new GraphHopperFacade(file1, false, "de").importOrLoad();
         GraphHopperStorage graph = hopper.getGraphHopperStorage();
         int n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
         EdgeIterator iter = carOutExplorer.setBaseNode(n20);
         assertTrue(iter.next());
         assertEquals("straße 123, B 122", iter.getName());
 
-        hopper = new GraphHopperFacade(file1).setPreferredLanguage("el").importOrLoad();
+        hopper = new GraphHopperFacade(file1, false, "el").importOrLoad();
         graph = hopper.getGraphHopperStorage();
         n20 = AbstractGraphStorageTester.getIdOf(graph, 52);
         iter = carOutExplorer.setBaseNode(n20);
@@ -791,7 +846,7 @@ public void testCrossBoundary_issue667() {
     public void testRoutingRequestFails_issue665() {
         GraphHopper hopper = new GraphHopperOSM()
                 .setDataReaderFile(getClass().getResource(file7).getFile())
-                .setEncodingManager(new EncodingManager("car,motorcycle"))
+                .setEncodingManager(EncodingManager.create("car,motorcycle"))
                 .setGraphHopperLocation(dir);
         hopper.getCHFactoryDecorator().setEnabled(false);
         hopper.importOrLoad();
@@ -803,16 +858,43 @@ public void testRoutingRequestFails_issue665() {
         assertFalse(ghRsp.getErrors().toString(), ghRsp.hasErrors());
     }
 
+    @Test
+    public void testRoadClassInfo() {
+        GraphHopper gh = new GraphHopperOSM() {
+
+            @Override
+            protected DataReader importData() {
+                try {
+                    DataReader reader = new OSMReader(getGraphHopperStorage()).setFile(new File(getClass().getResource(file2).toURI()));
+                    reader.readGraph();
+                    return reader;
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        }.setEncodingManager(new EncodingManager.Builder(4).add(carEncoder = new CarFlagEncoder()).add(new OSMRoadClassParser()).build()).
+                setGraphHopperLocation(dir).setCHEnabled(false).
+                importOrLoad();
+
+        GHResponse response = gh.route(new GHRequest(51.2492152, 9.4317166, 52.133, 9.1).setPathDetails(Arrays.asList(RoadClass.KEY)));
+        List<PathDetail> list = response.getBest().getPathDetails().get(RoadClass.KEY);
+        assertEquals(3, list.size());
+        assertEquals(RoadClass.MOTORWAY.toString(), list.get(0).getValue());
+
+        response = gh.route(new GHRequest(51.2492152, 9.4317166, 52.133, 9.1).setPathDetails(Arrays.asList(RoadAccess.KEY)));
+        Throwable ex = response.getErrors().get(0);
+        assertTrue(ex.getMessage(), ex.getMessage().contains("You requested the details [road_access]"));
+    }
+
     class GraphHopperFacade extends GraphHopperOSM {
         public GraphHopperFacade(String osmFile) {
-            this(osmFile, false);
+            this(osmFile, false, "");
         }
 
-        public GraphHopperFacade(String osmFile, boolean turnCosts) {
+        public GraphHopperFacade(String osmFile, boolean turnCosts, String prefLang) {
             setStoreOnFlush(false);
             setOSMFile(osmFile);
             setGraphHopperLocation(dir);
-            setEncodingManager(new EncodingManager("car,foot"));
             setCHEnabled(false);
 
             if (turnCosts) {
@@ -824,8 +906,9 @@ public GraphHopperFacade(String osmFile, boolean turnCosts) {
             }
 
             footEncoder = new FootFlagEncoder();
-
-            setEncodingManager(new EncodingManager(footEncoder, carEncoder, bikeEncoder));
+            setEncodingManager(new EncodingManager.Builder(4).add(footEncoder).add(carEncoder).add(bikeEncoder).
+                    setPreferredLanguage(prefLang).build());
+            carAccessEnc = carEncoder.getAccessEnc();
         }
 
         @Override
@@ -835,7 +918,6 @@ protected DataReader createReader(GraphHopperStorage tmpGraph) {
 
         @Override
         protected DataReader importData() throws IOException {
-            getEncodingManager().setPreferredLanguage(getPreferredLanguage());
             GraphHopperStorage tmpGraph = newGraph(dir, getEncodingManager(), hasElevation(),
                     getEncodingManager().needsTurnCostsSupport());
             setGraphHopperStorage(tmpGraph);
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTagParserTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderUtilityTest.java
similarity index 64%
rename from reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTagParserTest.java
rename to reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderUtilityTest.java
index d6a93988a6..fc71fb1e52 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTagParserTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMReaderUtilityTest.java
@@ -26,42 +26,42 @@
  * @author Peter Karich
  * @author ratrun
  */
-public class OSMTagParserTest {
+public class OSMReaderUtilityTest {
     @Test
     public void testParseDuration() {
-        assertEquals(10 * 60, OSMTagParser.parseDuration("00:10"));
-        assertEquals(35 * 60, OSMTagParser.parseDuration("35"));
-        assertEquals(70 * 60, OSMTagParser.parseDuration("01:10"));
-        assertEquals(70 * 60 + 2, OSMTagParser.parseDuration("01:10:02"));
-        assertEquals(0, OSMTagParser.parseDuration(null));
-        assertEquals(60 * 20 * 60, OSMTagParser.parseDuration("20:00"));
-        assertEquals(20 * 60, OSMTagParser.parseDuration("0:20:00"));
-        assertEquals((60 * 2 + 20) * 60 + 2, OSMTagParser.parseDuration("02:20:02"));
+        assertEquals(10 * 60, OSMReaderUtility.parseDuration("00:10"));
+        assertEquals(35 * 60, OSMReaderUtility.parseDuration("35"));
+        assertEquals(70 * 60, OSMReaderUtility.parseDuration("01:10"));
+        assertEquals(70 * 60 + 2, OSMReaderUtility.parseDuration("01:10:02"));
+        assertEquals(0, OSMReaderUtility.parseDuration(null));
+        assertEquals(60 * 20 * 60, OSMReaderUtility.parseDuration("20:00"));
+        assertEquals(20 * 60, OSMReaderUtility.parseDuration("0:20:00"));
+        assertEquals((60 * 2 + 20) * 60 + 2, OSMReaderUtility.parseDuration("02:20:02"));
 
         // two months
-        assertEquals(31 + 31, OSMTagParser.parseDuration("P2M") / (24 * 60 * 60));
+        assertEquals(31 + 31, OSMReaderUtility.parseDuration("P2M") / (24 * 60 * 60));
 
         // two minutes
-        assertEquals(2 * 60, OSMTagParser.parseDuration("PT2M"));
-        assertEquals((5 * 60 + 12) * 60 + 36, OSMTagParser.parseDuration("PT5H12M36S"));
+        assertEquals(2 * 60, OSMReaderUtility.parseDuration("PT2M"));
+        assertEquals((5 * 60 + 12) * 60 + 36, OSMReaderUtility.parseDuration("PT5H12M36S"));
     }
 
     @Test
     public void testWrongDurationFormats() {
         try {
-            OSMTagParser.parseDuration("PT5h12m36s");
+            OSMReaderUtility.parseDuration("PT5h12m36s");
             fail("parseDuration didn't throw when I expected it to");
         } catch (IllegalArgumentException expectedException) {
             assertEquals(expectedException.getMessage(), "Cannot parse duration tag value: PT5h12m36s");
         }
         try {
-            OSMTagParser.parseDuration("oh");
+            OSMReaderUtility.parseDuration("oh");
             fail("parseDuration didn't throw when I expected it to");
         } catch (IllegalArgumentException expectedException) {
             assertEquals(expectedException.getMessage(), "Cannot parse duration tag value: oh");
         }
         try {
-            OSMTagParser.parseDuration("01:10:2");
+            OSMReaderUtility.parseDuration("01:10:2");
             fail("parseDuration didn't throw when I expected it to");
         } catch (IllegalArgumentException expectedException) {
             assertEquals(expectedException.getMessage(), "Cannot parse duration tag value: 01:10:2");
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
index b159ca15da..9faf348c72 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/OSMTurnRelationTest.java
@@ -48,7 +48,7 @@ public void testGetRestrictionAsEntries() {
         internalToOSMEdge.put(3, 3L);
         internalToOSMEdge.put(4, 4L);
 
-        GraphHopperStorage ghStorage = new GraphBuilder(new EncodingManager(encoder)).create();
+        GraphHopperStorage ghStorage = new GraphBuilder(EncodingManager.create(encoder)).create();
         EdgeBasedRoutingAlgorithmTest.initGraph(ghStorage);
         OSMReader osmReader = new OSMReader(ghStorage) {
 
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
index b6c16f73cf..1ea121c3d8 100644
--- a/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
+++ b/reader-osm/src/test/java/com/graphhopper/routing/RoutingAlgorithmWithOSMIT.java
@@ -20,6 +20,7 @@
 import com.graphhopper.GraphHopper;
 import com.graphhopper.reader.dem.SRTMProvider;
 import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.util.TestAlgoCollector.AlgoHelperEntry;
 import com.graphhopper.routing.util.TestAlgoCollector.OneRun;
@@ -47,7 +48,6 @@
 
 /**
  * Try algorithms, indices and graph storages with real data
- * <p>
  *
  * @author Peter Karich
  */
@@ -173,14 +173,35 @@ public void testMoscowTurnCosts() {
         List<OneRun> list = new ArrayList<>();
         list.add(new OneRun(55.813357, 37.5958585, 55.811042, 37.594689, 1043.99, 12));
         list.add(new OneRun(55.813159, 37.593884, 55.811278, 37.594217, 1048, 13));
-        // TODO include CH
-        boolean testAlsoCH = false, is3D = false;
+        boolean testAlsoCH = true, is3D = false;
         runAlgo(testCollector, DIR + "/moscow.osm.gz", "target/graph-moscow",
                 list, "car|turn_costs=true", testAlsoCH, "car", "fastest", is3D);
 
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    @Test
+    public void testSimpleTurnCosts() {
+        List<OneRun> list = new ArrayList<>();
+        list.add(new OneRun(-0.5, 0.0, 0.0, -0.5, 301015.98099, 6));
+        boolean testAlsoCH = true, is3D = false;
+        runAlgo(testCollector, DIR + "/test_simple_turncosts.osm.xml", "target/graph-simple_turncosts",
+                list, "car|turn_costs=true", testAlsoCH, "car", "fastest", is3D);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
+    @Test
+    public void testSimplePTurn() {
+        List<OneRun> list = new ArrayList<>();
+        list.add(new OneRun(0, 1, -1, 0, 667.08, 6));
+        boolean testAlsoCH = true, is3D = false;
+        runAlgo(testCollector, DIR + "/test_simple_pturn.osm.xml", "target/graph-simple_turncosts",
+                list, "car|turn_costs=true", testAlsoCH, "car", "fastest", is3D);
+
+        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+    }
+
     @Test
     public void testSidewalkNo() {
         List<OneRun> list = new ArrayList<>();
@@ -303,13 +324,28 @@ public void testMonacoBike3D_twoSpeedsPerEdge() {
         assertEquals(testCollector.toString(), 0, testCollector.errors.size());
     }
 
+    // TODO fix later, see #1525, #1531
+//    @Test
+//    public void testLandmarkBug() {
+//        List<OneRun> list = new ArrayList<>();
+//        OneRun run = new OneRun();
+//        run.add(50.016923, 11.514187, 0, 0);
+//        run.add(50.019129, 11.500325, 0, 0);
+//        run.add(50.023623, 11.56929, 7069, 178);
+//        list.add(run);
+//
+//        runAlgo(testCollector, DIR + "/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
+//                list, "bike", true, "bike", "fastest", false);
+//        assertEquals(testCollector.toString(), 0, testCollector.errors.size());
+//    }
+
     @Test
     public void testBug1014() {
         List<OneRun> list = new ArrayList<>();
         OneRun run = new OneRun();
-        run.add(50.016923, 11.514187, 0, 0);
+        run.add(50.015861, 11.51041, 0, 0);
         run.add(50.019129, 11.500325, 0, 0);
-        run.add(50.023623, 11.56929, 7069, 178);
+        run.add(50.023623, 11.56929, 6777, 175);
         list.add(run);
 
         runAlgo(testCollector, DIR + "/north-bayreuth.osm.gz", "target/north-bayreuth-gh",
@@ -500,7 +536,7 @@ public void testDisconnectedAreaAndMultiplePoints() {
     }
 
     /**
-     * @param withCH if true also the CH and LM algorithms will be tested which need
+     * @param withCH if true also the CH and LM algorithms will be tested which needs
      *               preparation and takes a bit longer
      */
     Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
@@ -517,23 +553,26 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
             Helper.removeDir(new File(graphFile));
             GraphHopper hopper = new GraphHopperOSM().
                     setStoreOnFlush(true).
-                    setCHEnabled(false).
+                    setCHEnabled(withCH).
                     setDataReaderFile(osmFile).
                     setGraphHopperLocation(graphFile).
-                    setEncodingManager(new EncodingManager(importVehicles));
+                    setEncodingManager(new EncodingManager.Builder(8).addAll(new DefaultFlagEncoderFactory(), importVehicles).build());
 
             if (osmFile.contains("krautsand"))
                 hopper.setMinNetworkSize(0, 0);
             // avoid that path.getDistance is too different to path.getPoint.calcDistance
             hopper.setWayPointMaxDistance(0);
 
-            // always enable landmarks
-            hopper.getLMFactoryDecorator().addWeighting(weightStr).
+            // always enable landmarks, add maximum information to reduce warnings
+            hopper.getLMFactoryDecorator().addWeighting(weightStr + "|maximum=60000").
                     setEnabled(true).setDisablingAllowed(true);
 
             if (withCH)
-                hopper.getCHFactoryDecorator().addWeighting(weightStr).
-                        setEnabled(true).setDisablingAllowed(true);
+                hopper.getCHFactoryDecorator().
+                        addWeighting(weightStr).
+                        setEnabled(true).
+                        setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE).
+                        setDisablingAllowed(true);
 
             if (is3D)
                 hopper.setElevationProvider(new SRTMProvider(DIR));
@@ -541,7 +580,7 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
             hopper.importOrLoad();
 
             TraversalMode tMode = importVehicles.contains("turn_costs=true")
-                    ? TraversalMode.EDGE_BASED_2DIR : TraversalMode.NODE_BASED;
+                    ? TraversalMode.EDGE_BASED : TraversalMode.NODE_BASED;
             FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicle);
             HintsMap hints = new HintsMap().setWeighting(weightStr).setVehicle(vehicle);
 
@@ -549,12 +588,15 @@ Graph runAlgo(TestAlgoCollector testCollector, String osmFile,
 
             EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
             for (AlgoHelperEntry entry : prepares) {
+                if (entry.getExpectedAlgo().startsWith("astarbi|ch")) {
+                    continue;
+                }
                 algoEntry = entry;
                 LocationIndex idx = entry.getIdx();
                 for (OneRun oneRun : forEveryAlgo) {
                     tmpOneRun = oneRun;
                     List<QueryResult> list = oneRun.getList(idx, edgeFilter);
-                    testCollector.assertDistance(algoEntry, list, oneRun);
+                    testCollector.assertDistance(hopper.getEncodingManager(), algoEntry, list, oneRun);
                 }
             }
 
@@ -575,7 +617,7 @@ public void testMonacoParallel() throws IOException {
         System.out.println("testMonacoParallel takes a bit time...");
         String graphFile = "target/monaco-gh";
         Helper.removeDir(new File(graphFile));
-        final EncodingManager encodingManager = new EncodingManager("car");
+        final EncodingManager encodingManager = EncodingManager.create("car");
         final GraphHopper hopper = new GraphHopperOSM().
                 setStoreOnFlush(true).
                 setEncodingManager(encodingManager).setCHEnabled(false).
@@ -609,7 +651,7 @@ public void testMonacoParallel() throws IOException {
                         public void run() {
                             OneRun oneRun = instances.get(instanceIndex);
                             AlgorithmOptions opts = AlgorithmOptions.start().weighting(weighting).algorithm(algoStr).build();
-                            testCollector.assertDistance(new AlgoHelperEntry(g, opts, idx, algoStr + "|" + weighting),
+                            testCollector.assertDistance(encodingManager, new AlgoHelperEntry(g, opts, idx, algoStr + "|" + weighting),
                                     oneRun.getList(idx, filter), oneRun);
                             integ.addAndGet(1);
                         }
diff --git a/reader-osm/src/test/java/com/graphhopper/routing/TrafficChangeWithNodeOrderingReusingTest.java b/reader-osm/src/test/java/com/graphhopper/routing/TrafficChangeWithNodeOrderingReusingTest.java
new file mode 100644
index 0000000000..d4c9d95dd0
--- /dev/null
+++ b/reader-osm/src/test/java/com/graphhopper/routing/TrafficChangeWithNodeOrderingReusingTest.java
@@ -0,0 +1,220 @@
+package com.graphhopper.routing;
+
+import com.graphhopper.reader.osm.OSMReader;
+import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.CHEdgeIteratorState;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.MiniPerfTest;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Locale;
+import java.util.Random;
+
+import static java.lang.System.nanoTime;
+import static org.junit.Assert.assertEquals;
+import static org.junit.runners.Parameterized.Parameters;
+
+/**
+ * Tests CH contraction and query performance when re-using the node ordering after random changes
+ * have been applied to the edge weights (like when considering traffic).
+ */
+@Ignore("for performance testing only")
+@RunWith(Parameterized.class)
+public class TrafficChangeWithNodeOrderingReusingTest {
+    private static final Logger LOGGER = LoggerFactory.getLogger(TrafficChangeWithNodeOrderingReusingTest.class);
+    // make sure to increase xmx/xms for the JVM created by the surefire plugin in parent pom.xml
+    private static final String OSM_FILE = "../local/maps/berlin-latest.osm.pbf";
+
+    private final Weighting baseWeighting;
+    private final Weighting trafficWeighting;
+    private final GraphHopperStorage ghStorage;
+    private final CHGraph baseCHGraph;
+    private final CHGraph trafficCHGraph;
+    private int maxDeviationPercentage;
+
+    @Parameters(name = "maxDeviationPercentage = {0}")
+    public static Object[] data() {
+        return new Object[]{0, 1, 5, 10, 50};
+    }
+
+    public TrafficChangeWithNodeOrderingReusingTest(int maxDeviationPercentage) {
+        this.maxDeviationPercentage = maxDeviationPercentage;
+        FlagEncoder encoder = new CarFlagEncoder();
+        EncodingManager em = EncodingManager.create(encoder);
+        baseWeighting = new FastestWeighting(encoder);
+        trafficWeighting = new RandomDeviationWeighting(baseWeighting, maxDeviationPercentage);
+        Directory dir = new RAMDirectory("traffic-change-test");
+        ghStorage = new GraphHopperStorage(Arrays.asList(baseWeighting, trafficWeighting), dir, em, false, new GraphExtension.NoOpExtension());
+        baseCHGraph = ghStorage.getCHGraph(baseWeighting);
+        trafficCHGraph = ghStorage.getCHGraph(trafficWeighting);
+    }
+
+    @Test
+    public void testPerformanceForRandomTrafficChange() throws IOException {
+        final long seed = 2139960664L;
+        final int numQueries = 50_000;
+
+        LOGGER.info("Running performance test, max deviation percentage: " + this.maxDeviationPercentage);
+        // read osm
+        OSMReader reader = new OSMReader(ghStorage);
+        reader.setFile(new File(OSM_FILE));
+        reader.setCreateStorage(true);
+        reader.readGraph();
+        ghStorage.freeze();
+
+        // create CH
+        PrepareContractionHierarchies basePch = new PrepareContractionHierarchies(baseCHGraph, baseWeighting, TraversalMode.NODE_BASED);
+        basePch.doWork();
+
+        // check correctness & performance
+        checkCorrectness(ghStorage, baseCHGraph, basePch, seed, 100);
+        runPerformanceTest(ghStorage, baseCHGraph, basePch, seed, numQueries);
+
+        // now we re-use the contraction order from the previous contraction and re-run it with the traffic weighting
+        PrepareContractionHierarchies trafficPch = new PrepareContractionHierarchies(trafficCHGraph, trafficWeighting, TraversalMode.NODE_BASED)
+                .useFixedNodeOrdering(baseCHGraph.getNodeOrderingProvider());
+        trafficPch.doWork();
+
+        // check correctness & performance
+        checkCorrectness(ghStorage, trafficCHGraph, trafficPch, seed, 100);
+        runPerformanceTest(ghStorage, trafficCHGraph, trafficPch, seed, numQueries);
+    }
+
+    private static void checkCorrectness(GraphHopperStorage ghStorage, CHGraph chGraph, PrepareContractionHierarchies pch, long seed, long numQueries) {
+        LOGGER.info("checking correctness");
+        Random rnd = new Random(seed);
+        int numFails = 0;
+        for (int i = 0; i < numQueries; ++i) {
+            Dijkstra dijkstra = new Dijkstra(ghStorage, pch.getWeighting(), TraversalMode.NODE_BASED);
+            RoutingAlgorithm chAlgo = pch.createAlgo(chGraph, AlgorithmOptions.start().weighting(pch.getWeighting()).build());
+
+            int from = rnd.nextInt(ghStorage.getNodes());
+            int to = rnd.nextInt(ghStorage.getNodes());
+            double dijkstraWeight = dijkstra.calcPath(from, to).getWeight();
+            double chWeight = chAlgo.calcPath(from, to).getWeight();
+            double error = Math.abs(dijkstraWeight - chWeight);
+            if (error > 1) {
+                System.out.println("failure from " + from + " to " + to + " dijkstra: " + dijkstraWeight + " ch: " + chWeight);
+                numFails++;
+            }
+        }
+        LOGGER.info("number of failed queries: " + numFails);
+        assertEquals(0, numFails);
+    }
+
+    private static void runPerformanceTest(final GraphHopperStorage ghStorage, final CHGraph chGraph, final PrepareContractionHierarchies pch,
+                                           long seed, final int iterations) {
+        final int numNodes = ghStorage.getNodes();
+        final Random random = new Random(seed);
+
+        LOGGER.info("Running performance test, seed = {}", seed);
+        final double[] distAndWeight = {0.0, 0.0};
+        MiniPerfTest performanceTest = new MiniPerfTest() {
+            private long queryTime;
+
+            @Override
+            public int doCalc(boolean warmup, int run) {
+                if (!warmup && run % 1000 == 0) {
+                    LOGGER.debug("Finished {} of {} runs. {}", run, iterations,
+                            run > 0 ? String.format(Locale.ROOT, " Time: %6.2fms", queryTime * 1.e-6 / run) : "");
+                }
+                if (run == iterations - 1) {
+                    String avg = fmt(queryTime * 1.e-6 / run);
+                    LOGGER.debug("Finished all ({}) runs, avg time: {}ms", iterations, avg);
+                }
+                int from = random.nextInt(numNodes);
+                int to = random.nextInt(numNodes);
+                long start = nanoTime();
+                RoutingAlgorithm algo = pch.createAlgo(chGraph, AlgorithmOptions.start().weighting(pch.getWeighting()).build());
+                Path path = algo.calcPath(from, to);
+                if (!warmup && !path.isFound())
+                    return 1;
+
+                if (!warmup) {
+                    queryTime += nanoTime() - start;
+                    double distance = path.getDistance();
+                    double weight = path.getWeight();
+                    distAndWeight[0] += distance;
+                    distAndWeight[1] += weight;
+                }
+                return 0;
+            }
+        };
+        performanceTest.setIterations(iterations).start();
+        if (performanceTest.getDummySum() > 0.5 * iterations) {
+            throw new IllegalStateException("too many errors, probably something is wrong");
+        }
+        LOGGER.info("Total distance: {}, total weight: {}", distAndWeight[0], distAndWeight[1]);
+        LOGGER.info("Average query time: {}ms", performanceTest.getMean());
+    }
+
+    private static String fmt(double number) {
+        return String.format(Locale.ROOT, "%.2f", number);
+    }
+
+    /**
+     * Wraps another weighting and applies random weight deviations to it.
+     * Do not use with AStar/Landmarks!
+     */
+    private static class RandomDeviationWeighting extends AbstractWeighting {
+        private final Weighting baseWeighting;
+        private final double maxDeviationPercentage;
+
+        public RandomDeviationWeighting(Weighting baseWeighting, double maxDeviationPercentage) {
+            super(baseWeighting.getFlagEncoder());
+            this.baseWeighting = baseWeighting;
+            this.maxDeviationPercentage = maxDeviationPercentage;
+        }
+
+        @Override
+        public double getMinWeight(double distance) {
+            // left as is, ok for now, but do not use with astar, at least as long as deviations can be negative!!
+            return this.baseWeighting.getMinWeight(distance);
+        }
+
+        @Override
+        public double calcWeight(EdgeIteratorState edgeState, boolean reverse, int prevOrNextEdgeId) {
+            double baseWeight = this.baseWeighting.calcWeight(edgeState, reverse, prevOrNextEdgeId);
+            if (edgeState instanceof CHEdgeIteratorState) {
+                // important! we may not change weights of shortcuts (the deviations are already included in their weight)
+                if (((CHEdgeIteratorState) edgeState).isShortcut()) {
+                    return baseWeight;
+                }
+            }
+            if (Double.isInfinite(baseWeight)) {
+                // we are not touching this, might happen when speed is 0 ?
+                return baseWeight;
+            }
+            // apply a random (but deterministic) weight deviation - deviation may not depend on reverse flag!
+            long seed = edgeState.getEdge();
+            Random rnd = new Random(seed);
+            double deviation = 2 * (rnd.nextDouble() - 0.5) * baseWeight * maxDeviationPercentage / 100;
+            double result = baseWeight + deviation;
+            if (result < 0) {
+                throw new IllegalStateException("negative weights are not allowed: " + result);
+            }
+            return result;
+        }
+
+        @Override
+        public String getName() {
+            return "random_deviation";
+        }
+    }
+}
diff --git a/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops.xml b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops.xml
new file mode 100644
index 0000000000..bf3ca2cc76
--- /dev/null
+++ b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops.xml
@@ -0,0 +1,43 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm">
+
+    <!--
+      C - D
+       \ /
+    A - B - E
+    -->
+
+    <node id="1" lat="11" lon="50" uid="A">
+        <tag k="name" v="A"/>
+    </node>
+    <node id="2" lat="12" lon="51" uid="B">
+        <tag k="name" v="B"/>
+    </node>
+    <node id="3" lat="13" lon="52" uid="C">
+        <tag k="name" v="C"/>
+    </node>
+    <node id="4" lat="14" lon="51" uid="D">
+        <tag k="name" v="D"/>
+    </node>
+    <node id="5" lat="15" lon="51" uid="E">
+        <tag k="name" v="E"/>
+    </node>
+
+    <way id="10" uid="85761">
+        <nd ref="1"/>
+        <nd ref="2"/>
+        <nd ref="5"/>
+        <tag k="name" v="A B E"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+    <way id="12" uid="85762">
+        <nd ref="2"/>
+        <nd ref="3"/>
+        <nd ref="4"/>
+        <nd ref="2"/>
+        <tag k="name" v="B C D B"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+</osm>
\ No newline at end of file
diff --git a/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops2.xml b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops2.xml
new file mode 100644
index 0000000000..592b426cab
--- /dev/null
+++ b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops2.xml
@@ -0,0 +1,47 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm">
+
+    <!--
+      C - D
+       \ /
+    A - B - E
+    -->
+
+    <node id="1" lat="11" lon="50" uid="A">
+        <tag k="name" v="A"/>
+    </node>
+    <node id="2" lat="12" lon="51" uid="B">
+        <tag k="name" v="B"/>
+    </node>
+    <node id="6" lat="12" lon="51" uid="B2">
+        <tag k="name" v="B2"/>
+    </node>
+    <node id="3" lat="13" lon="52" uid="C">
+        <tag k="name" v="C"/>
+    </node>
+    <node id="4" lat="14" lon="51" uid="D">
+        <tag k="name" v="D"/>
+    </node>
+    <node id="5" lat="15" lon="51" uid="E">
+        <tag k="name" v="E"/>
+    </node>
+
+    <way id="10" uid="85761">
+        <nd ref="1"/>
+        <nd ref="2"/>
+        <nd ref="5"/>
+        <tag k="name" v="A B E"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+    <way id="12" uid="85762">
+        <nd ref="2"/>
+        <nd ref="6"/>
+        <nd ref="3"/>
+        <nd ref="4"/>
+        <nd ref="2"/>
+        <tag k="name" v="B B2 C D B"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+</osm>
\ No newline at end of file
diff --git a/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops3.xml b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops3.xml
new file mode 100644
index 0000000000..cf891b59bc
--- /dev/null
+++ b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops3.xml
@@ -0,0 +1,46 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm">
+
+    <!--
+      C - D
+       \ /
+    A - B - E
+       / \
+       ~~~
+    -->
+
+    <node id="1" lat="11" lon="50" uid="A">
+        <tag k="name" v="A"/>
+    </node>
+    <node id="2" lat="12" lon="51" uid="B">
+        <tag k="name" v="B"/>
+    </node>
+    <node id="3" lat="13" lon="52" uid="C">
+        <tag k="name" v="C"/>
+    </node>
+    <node id="4" lat="14" lon="51" uid="D">
+        <tag k="name" v="D"/>
+    </node>
+    <node id="5" lat="15" lon="51" uid="E">
+        <tag k="name" v="E"/>
+    </node>
+
+    <way id="10" uid="85761">
+        <nd ref="1"/>
+        <nd ref="2"/>
+        <nd ref="5"/>
+        <tag k="name" v="A B E"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+    <way id="12" uid="85762">
+        <nd ref="2"/>
+        <nd ref="4"/>
+        <nd ref="3"/>
+        <nd ref="2"/>
+        <nd ref="2"/>
+        <tag k="name" v="B D C B B"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+</osm>
\ No newline at end of file
diff --git a/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops4.xml b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops4.xml
new file mode 100644
index 0000000000..da0b1d5baa
--- /dev/null
+++ b/reader-osm/src/test/resources/com/graphhopper/reader/osm/test-avoid-loops4.xml
@@ -0,0 +1,46 @@
+<?xml version='1.0' encoding='UTF-8'?>
+<osm version="0.6" generator="pbf2osm">
+
+    <!--
+      C - D
+       \ /
+    A - B - E
+       / \
+       ~~~
+    -->
+
+    <node id="1" lat="11" lon="50" uid="A">
+        <tag k="name" v="A"/>
+    </node>
+    <node id="2" lat="12" lon="51" uid="B">
+        <tag k="name" v="B"/>
+    </node>
+    <node id="3" lat="13" lon="52" uid="C">
+        <tag k="name" v="C"/>
+    </node>
+    <node id="4" lat="14" lon="51" uid="D">
+        <tag k="name" v="D"/>
+    </node>
+    <node id="5" lat="15" lon="51" uid="E">
+        <tag k="name" v="E"/>
+    </node>
+
+    <way id="10" uid="85761">
+        <nd ref="1"/>
+        <nd ref="2"/>
+        <nd ref="5"/>
+        <tag k="name" v="A B E"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+    <way id="12" uid="85762">
+        <nd ref="2"/>
+        <nd ref="2"/>
+        <nd ref="3"/>
+        <nd ref="4"/>
+        <nd ref="2"/>
+        <tag k="name" v="B B C D B"/>
+        <tag k="highway" v="secondary"/>
+    </way>
+
+</osm>
\ No newline at end of file
diff --git a/reader-shp/pom.xml b/reader-shp/pom.xml
deleted file mode 100644
index 9247e4a145..0000000000
--- a/reader-shp/pom.xml
+++ /dev/null
@@ -1,86 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-
-    <groupId>com.graphhopper</groupId>
-    <artifactId>graphhopper-reader-shp</artifactId>
-    <version>0.11-SNAPSHOT</version>
-    <packaging>jar</packaging>
-    <name>GraphHopper Reader for Shapefile Data</name>
-	
-    <properties>      
-        <geotools.version>19.0</geotools.version>
-    </properties>
-    	
-    <parent>
-        <groupId>com.graphhopper</groupId>
-        <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
-    </parent>
-
-    <dependencies>
-        <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-core</artifactId>
-            <version>${project.parent.version}</version>
-        </dependency>
-        
-        <dependency>
-            <groupId>org.geotools</groupId>
-            <artifactId>gt-shapefile</artifactId>
-            <version>${geotools.version}</version>
-        </dependency>
-		
-        <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-api</artifactId>
-            <version>${slf4j.version}</version>
-        </dependency>   
-        <dependency>
-            <groupId>org.slf4j</groupId>
-            <artifactId>slf4j-log4j12</artifactId>
-            <version>${slf4j.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>log4j</groupId>
-            <artifactId>log4j</artifactId>
-            <version>${log4j.version}</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
-            <version>4.12</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>com.graphhopper</groupId>
-            <artifactId>graphhopper-reader-osm</artifactId>
-            <version>${project.parent.version}</version>
-            <scope>test</scope>
-        </dependency>        
-    </dependencies>
-    <build>
-        <plugins>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
-                <configuration>
-                    <source>1.8</source>
-                    <target>1.8</target>
-                </configuration>
-            </plugin>
-        </plugins>
-    </build>
-    <repositories>
-        <repository>
-            <id>osgeo</id>
-            <name>Open Source Geospatial Foundation Repository</name>
-            <url>http://download.osgeo.org/webdav/geotools/</url>
-        </repository>
-    </repositories>
-	
-</project>
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java
deleted file mode 100644
index 296923156e..0000000000
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/GraphHopperSHP.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import java.util.HashSet;
-
-import com.graphhopper.GraphHopper;
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.shp.OSMShapeFileReader.EdgeAddedListener;
-import com.graphhopper.storage.GraphHopperStorage;
-
-/**
- * This class is the main entry point to import from OpenStreetMap shape files similar to GraphHopperOSM which imports
- * OSM xml and pbf files.
- *
- * @author Phil
- */
-public class GraphHopperSHP extends GraphHopper {
-    private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
-
-    @Override
-    protected DataReader createReader(GraphHopperStorage ghStorage) {
-        OSMShapeFileReader reader = new OSMShapeFileReader(ghStorage);
-        for (EdgeAddedListener l : edgeAddedListeners) {
-            reader.addListener(l);
-        }
-        return initDataReader(reader);
-    }
-
-    public void addListener(EdgeAddedListener l) {
-        edgeAddedListeners.add(l);
-    }
-
-}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
deleted file mode 100644
index 1228591d35..0000000000
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/OSMShapeFileReader.java
+++ /dev/null
@@ -1,362 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import com.graphhopper.coll.GHObjectIntHashMap;
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.reader.ReaderWay;
-import com.graphhopper.reader.dem.ElevationProvider;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.geom.LineString;
-import com.vividsolutions.jts.geom.MultiLineString;
-import org.geotools.data.DataStore;
-import org.geotools.feature.FeatureIterator;
-import org.opengis.feature.simple.SimpleFeature;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.HashSet;
-import java.util.List;
-
-import static com.graphhopper.util.Helper.*;
-
-/**
- * OSMShapeFileReader for files present at : http://download.geofabrik.de/ It
- * extracts the data as per the structure of shape files
- *
- * @author Vikas Veshishth
- * @author Philip Welch
- */
-public class OSMShapeFileReader extends ShapeFileReader {
-    private static final int COORD_STATE_UNKNOWN = 0;
-    private static final int COORD_STATE_PILLAR = -2;
-    private static final int FIRST_NODE_ID = 1;
-    private static final String[] DIRECT_COPY_TAGS = new String[]{"name"};
-    private File roadsFile;
-    private final GHObjectIntHashMap<Coordinate> coordState = new GHObjectIntHashMap<>(1000, 0.7f);
-    private final DistanceCalc distCalc = DIST_EARTH;
-    private static final Logger LOGGER = LoggerFactory.getLogger(OSMShapeFileReader.class);
-    private final HashSet<EdgeAddedListener> edgeAddedListeners = new HashSet<>();
-    private int nextNodeId = FIRST_NODE_ID;
-    private final String encoding = "utf8";
-
-    public OSMShapeFileReader(GraphHopperStorage ghStorage) {
-        super(ghStorage);
-    }
-
-    private List<Coordinate[]> getCoords(Object o) {
-        ArrayList<Coordinate[]> ret = new ArrayList<>();
-        if (o == null) {
-            return ret;
-        }
-
-        if (o instanceof LineString) {
-            ret.add(((LineString) o).getCoordinates());
-        } else if (o instanceof MultiLineString) {
-            MultiLineString mls = (MultiLineString) o;
-            int n = mls.getNumGeometries();
-            for (int i = 0; i < n; i++) {
-                ret.add(mls.getGeometryN(i).getCoordinates());
-            }
-        }
-
-        return ret;
-    }
-
-    @Override
-    void processJunctions() {
-        DataStore dataStore = null;
-        FeatureIterator<SimpleFeature> roads = null;
-
-        try {
-            dataStore = openShapefileDataStore(roadsFile, encoding);
-            roads = getFeatureIterator(dataStore);
-
-            HashSet<Coordinate> tmpSet = new HashSet<>();
-            while (roads.hasNext()) {
-                SimpleFeature road = roads.next();
-
-                for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
-                    tmpSet.clear();
-                    for (int i = 0; i < points.length; i++) {
-                        Coordinate c = points[i];
-
-                        // don't add the same coord twice for the same edge - happens with bad geometry, i.e.
-                        // duplicate coords or a road which forms a circle (e.g. roundabout)
-                        if (tmpSet.contains(c))
-                            continue;
-
-                        tmpSet.add(c);
-
-                        // skip if its already a node
-                        int state = coordState.get(c);
-                        if (state >= FIRST_NODE_ID) {
-                            continue;
-                        }
-
-                        if (i == 0 || i == points.length - 1 || state == COORD_STATE_PILLAR) {
-                            // turn into a node if its the first or last
-                            // point, or already appeared in another edge
-                            int nodeId = nextNodeId++;
-                            coordState.put(c, nodeId);
-                            saveTowerPosition(nodeId, c);
-                        } else if (state == COORD_STATE_UNKNOWN) {
-                            // mark it as a pillar (which may get upgraded
-                            // to an edge later)
-                            coordState.put(c, COORD_STATE_PILLAR);
-                        }
-                    }
-                }
-
-            }
-        } finally {
-            if (roads != null) {
-                roads.close();
-            }
-            if (dataStore != null) {
-                dataStore.dispose();
-            }
-        }
-
-        if (nextNodeId == FIRST_NODE_ID)
-            throw new IllegalArgumentException("No data found for roads file " + roadsFile);
-
-        LOGGER.info("Number of junction points : " + (nextNodeId - FIRST_NODE_ID));
-    }
-
-    @Override
-    void processRoads() {
-
-        DataStore dataStore = null;
-        FeatureIterator<SimpleFeature> roads = null;
-
-        try {
-            dataStore = openShapefileDataStore(roadsFile, encoding);
-            roads = getFeatureIterator(dataStore);
-
-            while (roads.hasNext()) {
-                SimpleFeature road = roads.next();
-
-                for (Coordinate[] points : getCoords(road.getDefaultGeometry())) {
-
-                    // Parse all points in the geometry, splitting into
-                    // individual graphhopper edges
-                    // whenever we find a node in the list of points
-                    Coordinate startTowerPnt = null;
-                    List<Coordinate> pillars = new ArrayList<Coordinate>();
-                    for (Coordinate point : points) {
-                        if (startTowerPnt == null) {
-                            startTowerPnt = point;
-                        } else {
-                            int state = coordState.get(point);
-                            if (state >= FIRST_NODE_ID) {
-                                int fromTowerNodeId = coordState.get(startTowerPnt);
-                                int toTowerNodeId = state;
-
-                                // get distance and estimated centres
-                                double distance = getWayLength(startTowerPnt, pillars, point);
-                                GHPoint estmCentre = new GHPoint(
-                                        0.5 * (lat(startTowerPnt) + lat(point)),
-                                        0.5 * (lng(startTowerPnt) + lng(point)));
-                                PointList pillarNodes = new PointList(pillars.size(), false);
-
-                                for (Coordinate pillar : pillars) {
-                                    pillarNodes.add(lat(pillar), lng(pillar));
-                                }
-
-                                addEdge(fromTowerNodeId, toTowerNodeId, road, distance, estmCentre,
-                                        pillarNodes);
-                                startTowerPnt = point;
-                                pillars.clear();
-                            } else {
-                                pillars.add(point);
-                            }
-                        }
-                    }
-                }
-
-            }
-        } finally {
-            if (roads != null) {
-                roads.close();
-            }
-
-            if (dataStore != null) {
-                dataStore.dispose();
-            }
-        }
-    }
-
-    private double getWayLength(Coordinate start, List<Coordinate> pillars, Coordinate end) {
-        double distance = 0;
-
-        Coordinate previous = start;
-        for (Coordinate point : pillars) {
-            distance += distCalc.calcDist(lat(previous), lng(previous), lat(point), lng(point));
-            previous = point;
-        }
-        distance += distCalc.calcDist(lat(previous), lng(previous), lat(end), lng(end));
-
-        return distance;
-    }
-
-    @Override
-    public DataReader setFile(File file) {
-        this.roadsFile = file;
-        return this;
-    }
-
-    @Override
-    public DataReader setElevationProvider(ElevationProvider ep) {
-        // Elevation not supported
-        return this;
-    }
-
-    @Override
-    public DataReader setWorkerThreads(int workerThreads) {
-        // Its only single-threaded
-        return this;
-    }
-
-    @Override
-    public DataReader setWayPointMaxDistance(double wayPointMaxDistance) {
-        // TODO Auto-generated method stub
-        return this;
-    }
-
-    @Override
-    public DataReader setSmoothElevation(boolean smoothElevation) {
-        // TODO implement elevation smoothing for shape files
-        return this;
-    }
-
-    @Override
-    public Date getDataDate() {
-        return null;
-    }
-
-    public static interface EdgeAddedListener {
-        void edgeAdded(ReaderWay way, EdgeIteratorState edge);
-    }
-
-    private void addEdge(int fromTower, int toTower, SimpleFeature road, double distance,
-                         GHPoint estmCentre, PointList pillarNodes) {
-        EdgeIteratorState edge = graph.edge(fromTower, toTower);
-
-        // read the OSM id, should never be null
-        long id = getOSMId(road);
-
-        // Make a temporary ReaderWay object with the properties we need so we
-        // can use the enocding manager
-        // We (hopefully don't need the node structure on here as we're only
-        // calling the flag
-        // encoders, which don't use this...
-        ReaderWay way = new ReaderWay(id);
-
-        way.setTag("estimated_distance", distance);
-        way.setTag("estimated_center", estmCentre);
-
-        // read the highway type
-        Object type = road.getAttribute("fclass");
-        if (type != null) {
-            way.setTag("highway", type.toString());
-        }
-
-        // read maxspeed filtering for 0 which for Geofabrik shapefiles appears
-        // to correspond to no tag
-        Object maxSpeed = road.getAttribute("maxspeed");
-        if (maxSpeed != null && !maxSpeed.toString().trim().equals("0")) {
-            way.setTag("maxspeed", maxSpeed.toString());
-        }
-
-        for (String tag : DIRECT_COPY_TAGS) {
-            Object val = road.getAttribute(tag);
-            if (val != null) {
-                way.setTag(tag, val.toString());
-            }
-        }
-
-        // read oneway
-        Object oneway = road.getAttribute("oneway");
-        if (oneway != null) {
-            // Geofabrik is using an odd convention for oneway field in
-            // shapefile.
-            // We map back to the standard convention so that tag can be dealt
-            // with correctly by the flag encoder.
-            String val = toLowerCase(oneway.toString().trim());
-            if (val.equals("b")) {
-                // both ways
-                val = "no";
-            } else if (val.equals("t")) {
-                // one way against the direction of digitisation
-                val = "-1";
-            } else if (val.equals("f")) {
-                // one way Forward in the direction of digitisation
-                val = "yes";
-            } else {
-                throw new RuntimeException("Unrecognised value of oneway field \"" + val
-                        + "\" found in road with OSM id " + id);
-            }
-
-            way.setTag("oneway", val);
-        }
-
-        // Process the flags using the encoders
-        long includeWay = encodingManager.acceptWay(way);
-        if (includeWay == 0) {
-            return;
-        }
-
-        // TODO we're not using the relation flags
-        long relationFlags = 0;
-
-        long wayFlags = encodingManager.handleWayTags(way, includeWay, relationFlags);
-        if (wayFlags == 0)
-            return;
-
-        edge.setDistance(distance);
-        edge.setFlags(wayFlags);
-        edge.setWayGeometry(pillarNodes);
-
-        if (edgeAddedListeners.size() > 0) {
-            // check size first so we only allocate the iterator if we have
-            // listeners
-            for (EdgeAddedListener l : edgeAddedListeners) {
-                l.edgeAdded(way, edge);
-            }
-        }
-    }
-
-    private long getOSMId(SimpleFeature road) {
-        long id = Long.parseLong(road.getAttribute("osm_id").toString());
-        return id;
-    }
-
-    public void addListener(EdgeAddedListener l) {
-        edgeAddedListeners.add(l);
-    }
-}
diff --git a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java b/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
deleted file mode 100644
index 27f7bfc343..0000000000
--- a/reader-shp/src/main/java/com/graphhopper/reader/shp/ShapeFileReader.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import java.io.File;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.geotools.data.DataStore;
-import org.geotools.data.DataStoreFinder;
-import org.geotools.data.FeatureSource;
-import org.geotools.feature.FeatureCollection;
-import org.geotools.feature.FeatureIterator;
-import org.opengis.feature.simple.SimpleFeature;
-import org.opengis.feature.simple.SimpleFeatureType;
-import org.opengis.filter.Filter;
-
-import com.graphhopper.reader.DataReader;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.storage.GraphStorage;
-import com.graphhopper.storage.NodeAccess;
-import com.vividsolutions.jts.geom.Coordinate;
-
-/**
- * ShapeFileReader takes care of reading a shape file and writing it to a road network graph
- *
- * @author Vikas Veshishth
- * @author Philip Welch
- */
-public abstract class ShapeFileReader implements DataReader {
-
-    private final GraphStorage graphStorage;
-    private final NodeAccess nodeAccess;
-    protected final Graph graph;
-    protected EncodingManager encodingManager;
-
-    public ShapeFileReader(GraphHopperStorage ghStorage) {
-        this.graphStorage = ghStorage;
-        this.graph = ghStorage;
-        this.nodeAccess = graph.getNodeAccess();
-        this.encodingManager = ghStorage.getEncodingManager();
-    }
-
-    @Override
-    public void readGraph() {
-        graphStorage.create(1000);
-        processJunctions();
-        processRoads();
-    }
-
-    abstract void processJunctions();
-
-    abstract void processRoads();
-
-    protected FeatureIterator<SimpleFeature> getFeatureIterator(DataStore dataStore) {
-        if (dataStore == null)
-            throw new IllegalArgumentException("DataStore cannot be null for getFeatureIterator");
-
-        try {
-            String typeName = dataStore.getTypeNames()[0];
-            FeatureSource<SimpleFeatureType, SimpleFeature> source = dataStore.getFeatureSource(typeName);
-            Filter filter = Filter.INCLUDE;
-            FeatureCollection<SimpleFeatureType, SimpleFeature> collection = source.getFeatures(filter);
-
-            FeatureIterator<SimpleFeature> features = collection.features();
-            return features;
-
-        } catch (Exception e) {
-            throw Utils.asUnchecked(e);
-        }
-    }
-
-    protected DataStore openShapefileDataStore(File file, String encoding) {
-        try {
-            Map<String, Object> map = new HashMap<String, Object>();
-            map.put("url", file.toURI().toURL());
-            map.put("charset", encoding);
-            DataStore ds = DataStoreFinder.getDataStore(map);
-            if (ds == null)
-                throw new IllegalArgumentException("Cannot find DataStore at " + file);
-            return ds;
-
-        } catch (Exception e) {
-            throw Utils.asUnchecked(e);
-        }
-    }
-
-    /*
-     * Get longitude using the current long-lat order convention
-     */
-    protected double lng(Coordinate coordinate) {
-        return coordinate.getOrdinate(0);
-    }
-
-    /*
-	 * Get latitude using the current long-lat order convention
-     */
-    protected double lat(Coordinate coordinate) {
-        return coordinate.getOrdinate(1);
-    }
-
-    protected void saveTowerPosition(int nodeId, Coordinate point) {
-        nodeAccess.setNode(nodeId, lat(point), lng(point));
-    }
-}
diff --git a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java b/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
deleted file mode 100644
index 8bddc0545c..0000000000
--- a/reader-shp/src/test/java/com/graphhopper/reader/shp/ShapeFileReaderTest.java
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.reader.shp;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-import java.io.File;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.util.DoubleSummaryStatistics;
-import java.util.Random;
-
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import com.graphhopper.GHRequest;
-import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
-import com.graphhopper.PathWrapper;
-import com.graphhopper.reader.osm.GraphHopperOSM;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.PointList;
-import com.graphhopper.util.shapes.GHPoint;
-
-/**
- * @author Vikas Veshishth
- * @author Philip Welch
- */
-public class ShapeFileReaderTest {
-
-    private static final String shapefile = "/data/gis.osm_roads_free_1.shp";
-    private static final String pbf = "/data/malta-latest.osm.pbf";
-    private static final String tempOutputDirFromShp = "target/test-db-shp";
-    private static final String tempOutputDirFromPbf = "target/test-db-pbf";
-    private static GraphHopper hopperShp;
-    private static GraphHopper hopperPbf;
-    private final DistanceCalc distCalc = Helper.DIST_EARTH;
-    private static Exception BEFORE_CLASS_EXCEPTION = null;
-
-    private static class FromToPair {
-        final GHPoint from;
-        final GHPoint to;
-
-        FromToPair(double fromLat, double fromLng, double toLat, double toLng) {
-            this(new GHPoint(fromLat, fromLng), new GHPoint(toLat, toLng));
-        }
-
-        FromToPair(GHPoint from, GHPoint to) {
-            this.from = from;
-            this.to = to;
-        }
-
-        PathWrapper getPath(GraphHopper hopper, boolean assertNoErrors) {
-            GHRequest request = new GHRequest(from, to).setVehicle("car");
-            GHResponse response = hopper.route(request);
-
-            if (assertNoErrors) {
-                assertFalse(response.hasErrors());
-            }
-
-            if (!response.hasErrors()) {
-                return response.getBest();
-            }
-            return null;
-        }
-
-    }
-
-    private static class ExpectedDuration extends FromToPair {
-        final double minSecs;
-        final double maxSecs;
-
-        private ExpectedDuration(double fromLat, double fromLng, double toLat, double toLng,
-                                 double minSecs, double maxSecs) {
-            super(fromLat, fromLng, toLat, toLng);
-            this.minSecs = minSecs;
-            this.maxSecs = maxSecs;
-        }
-    }
-
-    private static GraphHopper initHopper(GraphHopper gh, String inputFile, String outDir) {
-        URL resourceURL = ShapeFileReaderTest.class.getResource(inputFile);
-        try {
-            inputFile = new File(resourceURL.toURI()).getAbsolutePath();
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-
-        // turn off geometry simplification so geometry should be the same
-        // between pbf and shapefile readers
-        gh.setWayPointMaxDistance(0);
-        return gh.setStoreOnFlush(false).setDataReaderFile(inputFile)
-                .setGraphHopperLocation(new File(outDir).getAbsolutePath())
-                .setEncodingManager(new EncodingManager(new CarFlagEncoder()))
-                .setCHEnabled(false).importOrLoad();
-
-    }
-
-    /**
-     * Build the graphs once only for the various tests
-     */
-    @BeforeClass
-    public static void setupBeforeClass() {
-        try {
-            new File(tempOutputDirFromShp).mkdirs();
-            new File(tempOutputDirFromPbf).mkdirs();
-
-            hopperShp = initHopper(new GraphHopperSHP(), shapefile, tempOutputDirFromShp);
-
-            hopperPbf = initHopper(new GraphHopperOSM(), pbf, tempOutputDirFromPbf);
-
-        } catch (Exception e) {
-            // Junit silently fails if we get an exception in the setup before
-            // class,
-            // so we record it here and explicitly rethrow it
-            BEFORE_CLASS_EXCEPTION = e;
-        }
-
-    }
-
-    @AfterClass
-    public static void teardownAfterClass() {
-        try {
-            hopperShp.close();
-            hopperShp.clean();
-        } catch (Exception e) {
-        }
-
-        try {
-            hopperPbf.close();
-            hopperPbf.clean();
-        } catch (Exception e) {
-        }
-
-    }
-
-    @Before
-    public void beforeTest() throws Exception {
-        // Rethrow the exception from @BeforeClass here so it doesn't silently
-        // fail.
-        // (Junit silently fails on exceptions thrown in @BeforeClass but not
-        // for
-        // exceptions thrown in @Before)
-        if (BEFORE_CLASS_EXCEPTION != null) {
-            throw BEFORE_CLASS_EXCEPTION;
-        }
-    }
-
-    @Test
-    public void testOneWay() {
-        // We setup 2 points very close together on a one-way street.
-        // As its a one way street, the ordering of the start and end requires
-        // going around the block to serve them.
-        // As the scenario is simple, we should get the same results from both
-        // shapefile and pbf.
-        // We should also get route distance to be many times physical distance
-        FromToPair pair = new FromToPair(35.898324, 14.510729, 35.898328, 14.510681);
-        PathWrapper shp = pair.getPath(hopperShp, true);
-        PathWrapper pbf = pair.getPath(hopperPbf, true);
-        double metresShp = shp.getDistance();
-        double metresPbf = pbf.getDistance();
-
-        // should be many times the physical separation between the points (as
-        // we had to go round the block)
-        double straightLineDistMetres = distCalc.calcDist(pair.from.lat, pair.from.lon, pair.to.lat,
-                pair.to.lon);
-        assertTrue(metresShp > straightLineDistMetres * 25);
-
-        // should be the same to within 1 cm
-        assertEquals(metresShp, metresPbf, 0.01);
-
-    }
-
-    @Test
-    public void testGeometrySingleEdgePath() {
-        // We choose a path along a single edge with a couple of minor bends,
-        // which we expect to give identical results...
-        FromToPair pair = new FromToPair(35.911694, 14.492303, 35.911494, 14.490489);
-        PointList shp = pair.getPath(hopperShp, true).getPoints();
-        PointList pbf = pair.getPath(hopperPbf, true).getPoints();
-
-        assertTrue("The chosen edge had a couple of bends!", shp.getSize() >= 2);
-        assertSameGeometry(shp, pbf);
-    }
-
-    private void assertSameGeometry(PointList shp, PointList pbf) {
-        assertEquals(shp.getSize(), pbf.getSize());
-
-        for (int i = 0; i < shp.getSize(); i++) {
-            assertEquals(shp.getLat(i), pbf.getLat(i), 0.0000001);
-            assertEquals(shp.getLon(i), pbf.getLon(i), 0.0000001);
-        }
-    }
-
-    @Test
-    public void testTravelTimesBetweenRandomLocations() {
-        int nTests = 200;
-        final Random random = new Random(123);
-        final GHPoint min = new GHPoint(35.882931, 14.403076);
-        final GHPoint max = new GHPoint(35.913523, 14.448566);
-
-        class RandPointGenerator {
-            double rand(double min, double max) {
-                return min + random.nextDouble() * (max - min);
-            }
-
-            GHPoint randPoint() {
-                return new GHPoint(rand(min.lat, max.lat), rand(min.lon, max.lon));
-            }
-
-        }
-        RandPointGenerator pointGenerator = new RandPointGenerator();
-
-        int nbFails = 0;
-        DoubleSummaryStatistics stats = new DoubleSummaryStatistics();
-        for (int i = 0; i < nTests; i++) {
-            FromToPair pair = new FromToPair(pointGenerator.randPoint(),
-                    pointGenerator.randPoint());
-
-            // paths from random points can fail to don't assert on failure
-            PathWrapper shpPath = pair.getPath(hopperShp, false);
-            PathWrapper pbfPath = pair.getPath(hopperPbf, false);
-
-            // paths between random points can fail to find a route (i.e. be off
-            // the road network)
-            if (shpPath == null || pbfPath == null) {
-                nbFails++;
-                continue;
-            }
-            double shpSecs = getSecondsTravel(shpPath);
-            double pbfSecs = getSecondsTravel(pbfPath);
-
-            double frac = shpSecs / pbfSecs;
-            double percentageDeviation = Math.abs(1.0 - frac) * 100;
-            stats.accept(percentageDeviation);
-        }
-
-        assertTrue("Number of fails should be small for the chosen box", nbFails < nTests / 3);
-
-        // Test mean fraction. There will be some deviation as not all tags are
-        // considered etc,
-        // but we expect it to be small for a large number of tests
-        double mean = stats.getAverage();
-        assertTrue("Should have a mean deviation in travel times of less than 1%", mean < 1.0);
-    }
-
-    @Test
-    public void testTravelTimesBetweenPredefinedLocations() throws URISyntaxException {
-
-        // try a couple of test points, with an expected time range that will
-        // only fail if something is really bad...
-        ExpectedDuration[] expected = new ExpectedDuration[]{
-                new ExpectedDuration(35.899167, 14.515171, 35.894126, 14.502983, 60,
-                        60 * 6),
-                new ExpectedDuration(35.899167, 14.515171, 35.877645, 14.398956, 8 * 60,
-                        25 * 60),
-                new ExpectedDuration(35.85817, 14.561348, 35.877645, 14.398956, 10 * 60,
-                        30 * 60),
-                new ExpectedDuration(35.812802, 14.528732, 35.979673, 14.335785, 20 * 60,
-                        50 * 60),};
-
-        // The chosen locations should have small deviations in travel times
-        double tolDiffFromPbf = 0.01;
-
-        for (ExpectedDuration ed : expected) {
-            double secsShp = getSecondsTravel(ed.getPath(hopperShp, true));
-            double secsPbf = getSecondsTravel(ed.getPath(hopperPbf, true));
-            double frac = secsShp / secsPbf;
-
-            String message = "From (" + ed.from + ") to (" + ed.to + ") expected " + ed.minSecs
-                    + " <= travelsecs <= " + ed.maxSecs + ", found " + secsShp
-                    + " secs, pbf was " + secsPbf + " secs, frac diff=" + frac;
-            assertTrue(message, secsShp >= ed.minSecs);
-            assertTrue(message, secsShp <= ed.maxSecs);
-
-            // we also use a tolerance difference with the pbf
-            assertTrue(frac > 1 - tolDiffFromPbf);
-            assertTrue(frac < 1 + tolDiffFromPbf);
-
-        }
-
-    }
-
-    private static double getSecondsTravel(PathWrapper pw) {
-        long millis = pw.getTime();
-        double secs = 0.001 * millis;
-        return secs;
-    }
-
-}
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.cpg b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.cpg
deleted file mode 100644
index 7edc66b06a..0000000000
--- a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.cpg
+++ /dev/null
@@ -1 +0,0 @@
-UTF-8
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.dbf b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.dbf
deleted file mode 100644
index 116ff9c648..0000000000
Binary files a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.dbf and /dev/null differ
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.prj b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.prj
deleted file mode 100644
index 8f73f480ff..0000000000
--- a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.prj
+++ /dev/null
@@ -1 +0,0 @@
-GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shp b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shp
deleted file mode 100644
index 491be81e73..0000000000
Binary files a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shp and /dev/null differ
diff --git a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shx b/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shx
deleted file mode 100644
index 25718abea1..0000000000
Binary files a/reader-shp/src/test/resources/data/gis.osm_roads_free_1.shx and /dev/null differ
diff --git a/reader-shp/src/test/resources/data/malta-latest.osm.pbf b/reader-shp/src/test/resources/data/malta-latest.osm.pbf
deleted file mode 100644
index 6b84456772..0000000000
Binary files a/reader-shp/src/test/resources/data/malta-latest.osm.pbf and /dev/null differ
diff --git a/reader-shp/src/test/resources/log4j.xml b/reader-shp/src/test/resources/log4j.xml
deleted file mode 100644
index a9bb71c09f..0000000000
--- a/reader-shp/src/test/resources/log4j.xml
+++ /dev/null
@@ -1,21 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
-<log4j:configuration>
-    <appender name="stdout" class="org.apache.log4j.ConsoleAppender">
-        <layout class="org.apache.log4j.PatternLayout">
-            <param name="ConversionPattern" value="%d [%t] %-5p %c - %m%n"/>
-        </layout>
-    </appender>
-    <appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
-        <param name="BufferSize" value="500"/>
-        <appender-ref ref="stdout"/>
-    </appender>    
-    <logger name="com.graphhopper" additivity="false">
-        <level value="warn" />
-        <appender-ref ref="ASYNC" />
-    </logger>
-    <root>
-        <priority value="warn"></priority>
-        <appender-ref ref="ASYNC"/>
-    </root>
-</log4j:configuration>
\ No newline at end of file
diff --git a/tools/pom.xml b/tools/pom.xml
index 0c23f1b7e5..bc70bbb8bb 100644
--- a/tools/pom.xml
+++ b/tools/pom.xml
@@ -5,14 +5,14 @@
 
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-tools</artifactId>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <packaging>jar</packaging>
     <name>GraphHopper Tools</name>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>    	
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -60,7 +60,7 @@
                 <configuration>
                     <archive>
                         <manifest>
-                            <mainClass>com.graphhopper.tools.Import</mainClass>
+                            <mainClass>com.graphhopper.tools.Measurement</mainClass>
                         </manifest>
                     </archive>
                         	                    
diff --git a/tools/src/main/java/com/graphhopper/tools/CHMeasurement.java b/tools/src/main/java/com/graphhopper/tools/CHMeasurement.java
new file mode 100644
index 0000000000..266337c9dc
--- /dev/null
+++ b/tools/src/main/java/com/graphhopper/tools/CHMeasurement.java
@@ -0,0 +1,367 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.tools;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.ch.CHAlgoFactoryDecorator;
+import com.graphhopper.routing.lm.LMAlgoFactoryDecorator;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.*;
+import com.graphhopper.util.exceptions.ConnectionNotFoundException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.*;
+import java.nio.charset.StandardCharsets;
+import java.util.*;
+
+import static com.graphhopper.routing.ch.CHParameters.*;
+import static com.graphhopper.util.Parameters.Algorithms.ASTAR_BI;
+import static com.graphhopper.util.Parameters.Algorithms.DIJKSTRA_BI;
+import static java.lang.System.nanoTime;
+
+public class CHMeasurement {
+    private static final Logger LOGGER = LoggerFactory.getLogger(CHMeasurement.class);
+
+    public static void main(String[] args) {
+        testPerformanceAutomaticNodeOrdering(args);
+    }
+
+    /**
+     * Parses a given osm file, contracts the graph and runs random routing queries on it. This is useful to test
+     * the node contraction heuristics with regards to the performance of the automatic graph contraction (the node
+     * contraction order determines how many and which shortcuts will be introduced) and the resulting query speed.
+     * The queries are compared with a normal AStar search for comparison and to ensure correctness.
+     */
+    private static void testPerformanceAutomaticNodeOrdering(String[] args) {
+        // example args:
+        // map=berlin.pbf stats_file=stats.dat period_updates=0 lazy_updates=100 neighbor_updates=0 contract_nodes=100 log_messages=20 edge_quotient_weight=1.0 orig_edge_quotient_weight=3.0 hierarchy_depth_weight=2.0 sigma_factor=3.0 min_max_settled_edges=100 reset_interval=10000 landmarks=0 cleanup=true turncosts=true threshold=0.1 seed=456 comp_iterations=10 perf_iterations=100 quick=false
+        long start = nanoTime();
+        CmdArgs cmdArgs = CmdArgs.read(args);
+        LOGGER.info("Running analysis with parameters {}", cmdArgs);
+        String osmFile = cmdArgs.get("map", "local/maps/unterfranken-latest.osm.pbf");
+        cmdArgs.put("datareader.file", osmFile);
+        final String statsFile = cmdArgs.get("stats_file", null);
+        final int periodicUpdates = cmdArgs.getInt("period_updates", 0);
+        final int lazyUpdates = cmdArgs.getInt("lazy_updates", 100);
+        final int neighborUpdates = cmdArgs.getInt("neighbor_updates", 0);
+        final int contractedNodes = cmdArgs.getInt("contract_nodes", 100);
+        final int logMessages = cmdArgs.getInt("log_messages", 20);
+        final float edgeQuotientWeight = cmdArgs.getFloat("edge_quotient_weight", 1.0f);
+        final float origEdgeQuotientWeight = cmdArgs.getFloat("orig_edge_quotient_weight", 3.0f);
+        final float hierarchyDepthWeight = cmdArgs.getFloat("hierarchy_depth_weight", 2.0f);
+        final double sigmaFactor = cmdArgs.getFloat("sigma_factor", 3.0f);
+        final int minMaxSettledEdges = cmdArgs.getInt("min_max_settled_edges", 100);
+        final int resetInterval = cmdArgs.getInt("reset_interval", 10_000);
+        final int landmarks = cmdArgs.getInt("landmarks", 0);
+        final boolean cleanup = cmdArgs.getBool("cleanup", true);
+        final boolean withTurnCosts = cmdArgs.getBool("turncosts", true);
+        final double errorThreshold = cmdArgs.getDouble("threshold", 0.1);
+        final long seed = cmdArgs.getLong("seed", 456);
+        final int compIterations = cmdArgs.getInt("comp_iterations", 100);
+        final int perfIterations = cmdArgs.getInt("perf_iterations", 1000);
+        final boolean quick = cmdArgs.getBool("quick", false);
+
+        final GraphHopper graphHopper = new GraphHopperOSM();
+        if (withTurnCosts) {
+            cmdArgs.put("graph.flag_encoders", "car|turn_costs=true");
+            cmdArgs.put("prepare.ch.weightings", "fastest");
+            cmdArgs.put("prepare.ch.edge_based", "edge_or_node");
+            if (landmarks > 0) {
+                cmdArgs.put("prepare.lm.weightings", "fastest");
+                cmdArgs.put("prepare.lm.landmarks", landmarks);
+            }
+        } else {
+            cmdArgs.put("graph.flag_encoders", "car");
+            cmdArgs.put("prepare.ch.weightings", "no");
+        }
+        CHAlgoFactoryDecorator chDecorator = graphHopper.getCHFactoryDecorator();
+        chDecorator.setDisablingAllowed(true);
+        cmdArgs.put(PERIODIC_UPDATES, periodicUpdates);
+        cmdArgs.put(LAST_LAZY_NODES_UPDATES, lazyUpdates);
+        cmdArgs.put(NEIGHBOR_UPDATES, neighborUpdates);
+        cmdArgs.put(CONTRACTED_NODES, contractedNodes);
+        cmdArgs.put(LOG_MESSAGES, logMessages);
+        cmdArgs.put(EDGE_QUOTIENT_WEIGHT, edgeQuotientWeight);
+        cmdArgs.put(ORIGINAL_EDGE_QUOTIENT_WEIGHT, origEdgeQuotientWeight);
+        cmdArgs.put(HIERARCHY_DEPTH_WEIGHT, hierarchyDepthWeight);
+        cmdArgs.put(SIGMA_FACTOR, sigmaFactor);
+        cmdArgs.put(MIN_MAX_SETTLED_EDGES, minMaxSettledEdges);
+        cmdArgs.put(SETTLED_EDGES_RESET_INTERVAL, resetInterval);
+
+        LMAlgoFactoryDecorator lmDecorator = graphHopper.getLMFactoryDecorator();
+        lmDecorator.setEnabled(landmarks > 0);
+        lmDecorator.setDisablingAllowed(true);
+
+        LOGGER.info("Initializing graph hopper with args: {}", cmdArgs);
+        graphHopper.init(cmdArgs);
+
+        if (cleanup) {
+            graphHopper.clean();
+        }
+
+        PMap results = new PMap(cmdArgs);
+
+        StopWatch sw = new StopWatch();
+        sw.start();
+        graphHopper.importOrLoad();
+        sw.stop();
+        results.put("_prepare_time", sw.getSeconds());
+        LOGGER.info("Import and preparation took {}s", sw.getMillis() / 1000);
+
+        if (!quick) {
+            runCompareTest(DIJKSTRA_BI, graphHopper, withTurnCosts, seed, compIterations, errorThreshold, results);
+            runCompareTest(ASTAR_BI, graphHopper, withTurnCosts, seed, compIterations, errorThreshold, results);
+        }
+
+        if (!quick) {
+            runPerformanceTest(DIJKSTRA_BI, graphHopper, withTurnCosts, seed, perfIterations, results);
+        }
+
+        runPerformanceTest(ASTAR_BI, graphHopper, withTurnCosts, seed, perfIterations, results);
+
+        if (!quick && landmarks > 0) {
+            runPerformanceTest("lm", graphHopper, withTurnCosts, seed, perfIterations, results);
+        }
+
+        graphHopper.close();
+
+        Map<String, String> resultMap = results.toMap();
+        TreeSet<String> sortedKeys = new TreeSet<>(resultMap.keySet());
+        for (String key : sortedKeys) {
+            LOGGER.info(key + "=" + resultMap.get(key));
+        }
+
+        if (statsFile != null) {
+            File f = new File(statsFile);
+            boolean writeHeader = !f.exists();
+            try (OutputStream os = new FileOutputStream(f, true);
+                 Writer writer = new OutputStreamWriter(os, StandardCharsets.UTF_8)) {
+                if (writeHeader)
+                    writer.write(getHeader(sortedKeys));
+                writer.write(getStatLine(sortedKeys, resultMap));
+            } catch (IOException e) {
+                LOGGER.error("Could not write summary to file '{}'", statsFile, e);
+            }
+        }
+
+        // output to be used by external caller
+        StringBuilder sb = new StringBuilder();
+        for (String key : sortedKeys) {
+            sb.append(key).append(":").append(resultMap.get(key)).append(";");
+        }
+        sb.deleteCharAt(sb.lastIndexOf(";"));
+        System.out.println(sb.toString());
+
+        LOGGER.info("Total time: {}s", fmt((nanoTime() - start) * 1.e-9));
+    }
+
+    private static String getHeader(TreeSet<String> keys) {
+        StringBuilder sb = new StringBuilder("#");
+        for (String key : keys) {
+            sb.append(key).append(";");
+        }
+        sb.append("\n");
+        return sb.toString();
+    }
+
+    private static String getStatLine(TreeSet<String> keys, Map<String, String> results) {
+        StringBuilder sb = new StringBuilder();
+        for (String key : keys) {
+            sb.append(results.get(key)).append(";");
+        }
+        sb.append("\n");
+        return sb.toString();
+    }
+
+    private static void runCompareTest(final String algo, final GraphHopper graphHopper, final boolean withTurnCosts,
+                                       long seed, final int iterations, final double threshold, final PMap results) {
+        LOGGER.info("Running compare test for {}, using seed {}", algo, seed);
+        Graph g = graphHopper.getGraphHopperStorage();
+        final int numNodes = g.getNodes();
+        final NodeAccess nodeAccess = g.getNodeAccess();
+        final Random random = new Random(seed);
+
+        MiniPerfTest compareTest = new MiniPerfTest() {
+            long chTime = 0;
+            long noChTime = 0;
+            long chErrors = 0;
+            long noChErrors = 0;
+            long chDeviations = 0;
+
+            @Override
+            public int doCalc(boolean warmup, int run) {
+                if (!warmup && run % 100 == 0) {
+                    LOGGER.info("Finished {} of {} runs. {}", run, iterations,
+                            run > 0 ? String.format(Locale.ROOT, " CH: %6.2fms, without CH: %6.2fms",
+                                    chTime * 1.e-6 / run, noChTime * 1.e-6 / run) : "");
+                }
+                if (run == iterations - 1) {
+                    String avgChTime = fmt(chTime * 1.e-6 / run);
+                    String avgNoChTime = fmt(noChTime * 1.e-6 / run);
+                    LOGGER.info("Finished all ({}) runs, CH: {}ms, without CH: {}ms", iterations, avgChTime, avgNoChTime);
+                    results.put("_" + algo + ".time_comp_ch", avgChTime);
+                    results.put("_" + algo + ".time_comp", avgNoChTime);
+                    results.put("_" + algo + ".errors_ch", chErrors);
+                    results.put("_" + algo + ".errors", noChErrors);
+                    results.put("_" + algo + ".deviations", chDeviations);
+                }
+                GHRequest req = buildRandomRequest(random, numNodes, nodeAccess);
+                req.getHints().put(Parameters.Routing.EDGE_BASED, withTurnCosts);
+                req.getHints().put(Parameters.CH.DISABLE, false);
+                req.getHints().put(Parameters.Landmark.DISABLE, true);
+                req.setAlgorithm(algo);
+                long start = nanoTime();
+                GHResponse chRoute = graphHopper.route(req);
+                if (!warmup)
+                    chTime += (nanoTime() - start);
+
+                req.getHints().put(Parameters.CH.DISABLE, true);
+                start = nanoTime();
+                GHResponse nonChRoute = graphHopper.route(req);
+                if (!warmup)
+                    noChTime += nanoTime() - start;
+
+                if (connectionNotFound(chRoute) && connectionNotFound(nonChRoute)) {
+                    // random query was not well defined -> ignore
+                    return 0;
+                }
+
+                if (!chRoute.getErrors().isEmpty() || !nonChRoute.getErrors().isEmpty()) {
+                    LOGGER.warn("there were errors for {}: \n with CH: {} \n without CH: {}", algo, chRoute.getErrors(), nonChRoute.getErrors());
+                    if (!chRoute.getErrors().isEmpty()) {
+                        chErrors++;
+                    }
+                    if (!nonChRoute.getErrors().isEmpty()) {
+                        noChErrors++;
+                    }
+                    return chRoute.getErrors().size();
+                }
+
+                double chWeight = chRoute.getBest().getRouteWeight();
+                double nonCHWeight = nonChRoute.getBest().getRouteWeight();
+                if (Math.abs(chWeight - nonCHWeight) > threshold) {
+                    LOGGER.warn("error for {}: difference between best paths with and without CH is above threshold ({}), {}",
+                            algo, threshold, getWeightDifferenceString(chWeight, nonCHWeight));
+                    chDeviations++;
+                }
+                if (!chRoute.getBest().getPoints().equals(nonChRoute.getBest().getPoints())) {
+                    // small negative deviations are due to weight truncation when shortcuts are stored
+                    LOGGER.warn("error for {}: found different points for query from {} to {}, {}", algo,
+                            req.getPoints().get(0).toShortString(), req.getPoints().get(1).toShortString(),
+                            getWeightDifferenceString(chWeight, nonCHWeight));
+                }
+                return chRoute.getErrors().size();
+            }
+        };
+        compareTest.setIterations(iterations).start();
+    }
+
+    private static void runPerformanceTest(final String algo, final GraphHopper graphHopper, final boolean withTurnCosts,
+                                           long seed, final int iterations, final PMap results) {
+        Graph g = graphHopper.getGraphHopperStorage();
+        final int numNodes = g.getNodes();
+        final NodeAccess nodeAccess = g.getNodeAccess();
+        final Random random = new Random(seed);
+        final boolean lm = "lm".equals(algo);
+
+        LOGGER.info("Running performance test for {}, seed = {}", algo, seed);
+        final long[] numVisitedNodes = {0};
+        MiniPerfTest performanceTest = new MiniPerfTest() {
+            private long queryTime;
+
+            @Override
+            public int doCalc(boolean warmup, int run) {
+                if (!warmup && run % 100 == 0) {
+                    LOGGER.info("Finished {} of {} runs. {}", run, iterations,
+                            run > 0 ? String.format(Locale.ROOT, " Time: %6.2fms", queryTime * 1.e-6 / run) : "");
+                }
+                if (run == iterations - 1) {
+                    String avg = fmt(queryTime * 1.e-6 / run);
+                    LOGGER.info("Finished all ({}) runs, avg time: {}ms", iterations, avg);
+                    results.put("_" + algo + ".time_ch", avg);
+                }
+                GHRequest req = buildRandomRequest(random, numNodes, nodeAccess);
+                req.getHints().put(Parameters.Routing.EDGE_BASED, withTurnCosts);
+                req.getHints().put(Parameters.CH.DISABLE, lm);
+                req.getHints().put(Parameters.Landmark.DISABLE, !lm);
+                if (!lm) {
+                    req.setAlgorithm(algo);
+                } else {
+                    req.getHints().put(Parameters.Landmark.ACTIVE_COUNT, "8");
+                    req.setWeighting("fastest"); // why do we need this for lm, but not ch ?
+                }
+                long start = nanoTime();
+                GHResponse route = graphHopper.route(req);
+                numVisitedNodes[0] += route.getHints().getInt("visited_nodes.sum", 0);
+                if (!warmup)
+                    queryTime += nanoTime() - start;
+                return getRealErrors(route).size();
+            }
+        };
+        performanceTest.setIterations(iterations).start();
+        if (performanceTest.getDummySum() > 0.01 * iterations) {
+            throw new IllegalStateException("too many errors, probably something is wrong");
+        }
+        LOGGER.info("Average query time for {}: {}ms", algo, performanceTest.getMean());
+        LOGGER.info("Visited nodes for {}: {}", algo, Helper.nf(numVisitedNodes[0]));
+    }
+
+    private static String getWeightDifferenceString(double chWeight, double noChWeight) {
+        return String.format(Locale.ROOT, "route weight: %.6f (CH) vs. %.6f (no CH) (diff = %.6f)",
+                chWeight, noChWeight, (chWeight - noChWeight));
+    }
+
+    private static boolean connectionNotFound(GHResponse response) {
+        for (Throwable t : response.getErrors()) {
+            if (t instanceof ConnectionNotFoundException) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static List<Throwable> getRealErrors(GHResponse response) {
+        List<Throwable> realErrors = new ArrayList<>();
+        for (Throwable t : response.getErrors()) {
+            if (!(t instanceof ConnectionNotFoundException)) {
+                realErrors.add(t);
+            }
+        }
+        return realErrors;
+    }
+
+    private static GHRequest buildRandomRequest(Random random, int numNodes, NodeAccess nodeAccess) {
+        int from = random.nextInt(numNodes);
+        int to = random.nextInt(numNodes);
+        double fromLat = nodeAccess.getLat(from);
+        double fromLon = nodeAccess.getLon(from);
+        double toLat = nodeAccess.getLat(to);
+        double toLon = nodeAccess.getLon(to);
+        return new GHRequest(fromLat, fromLon, toLat, toLon);
+    }
+
+    private static String fmt(double number) {
+        return String.format(Locale.ROOT, "%.2f", number);
+    }
+
+}
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index c6d7fbedd0..76932bbd59 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -82,7 +82,7 @@ void start(CmdArgs args) {
         }
 
         seed = args.getLong("measurement.seed", 123);
-        String gitCommit = args.get("measurement.gitinfo", "");
+        put("measurement.gitinfo", args.get("measurement.gitinfo", ""));
         int count = args.getInt("measurement.count", 5000);
 
         GraphHopper hopper = new GraphHopperOSM() {
@@ -90,12 +90,18 @@ void start(CmdArgs args) {
             protected void prepareCH() {
                 StopWatch sw = new StopWatch().start();
                 super.prepareCH();
+                // note that we measure the total time of all (possibly edge&node) CH preparations
                 put(Parameters.CH.PREPARE + "time", sw.stop().getMillis());
-                int edges = getGraphHopperStorage().getAllEdges().length();
-                if (getCHFactoryDecorator().hasWeightings()) {
-                    Weighting weighting = getCHFactoryDecorator().getWeightings().get(0);
-                    int edgesAndShortcuts = getGraphHopperStorage().getGraph(CHGraph.class, weighting).getAllEdges().length();
-                    put(Parameters.CH.PREPARE + "shortcuts", edgesAndShortcuts - edges);
+                int edges = getGraphHopperStorage().getEdges();
+                if (!getCHFactoryDecorator().getNodeBasedWeightings().isEmpty()) {
+                    Weighting weighting = getCHFactoryDecorator().getNodeBasedWeightings().get(0);
+                    int edgesAndShortcuts = getGraphHopperStorage().getCHGraph(weighting).getEdges();
+                    put(Parameters.CH.PREPARE + "node.shortcuts", edgesAndShortcuts - edges);
+                }
+                if (!getCHFactoryDecorator().getEdgeBasedWeightings().isEmpty()) {
+                    Weighting weighting = getCHFactoryDecorator().getEdgeBasedWeightings().get(0);
+                    int edgesAndShortcuts = getGraphHopperStorage().getCHGraph(weighting).getEdges();
+                    put(Parameters.CH.PREPARE + "edge.shortcuts", edgesAndShortcuts - edges);
                 }
             }
 
@@ -103,7 +109,7 @@ protected void prepareCH() {
             protected void loadOrPrepareLM() {
                 StopWatch sw = new StopWatch().start();
                 super.loadOrPrepareLM();
-                put(Parameters.Landmark.PREPARE + "time", sw.stop().getMillis());
+                put(Landmark.PREPARE + "time", sw.stop().getMillis());
             }
 
             @Override
@@ -126,8 +132,12 @@ protected DataReader importData() throws IOException {
         hopper.importOrLoad();
 
         GraphHopperStorage g = hopper.getGraphHopperStorage();
-        String vehicleStr = args.get("graph.flag_encoders", "car");
-        FlagEncoder encoder = hopper.getEncodingManager().getEncoder(vehicleStr);
+        EncodingManager encodingManager = hopper.getEncodingManager();
+        if (encodingManager.fetchEdgeEncoders().size() != 1) {
+            throw new IllegalArgumentException("There has to be exactly one encoder for each measurement");
+        }
+        FlagEncoder encoder = encodingManager.fetchEdgeEncoders().get(0);
+        String vehicleStr = encoder.toString();
 
         StopWatch sw = new StopWatch().start();
         try {
@@ -137,14 +147,14 @@ protected DataReader importData() throws IOException {
             GHBitSet allowedEdges = printGraphDetails(g, vehicleStr);
             printMiscUnitPerfTests(g, isCH, encoder, count * 100, allowedEdges);
             printLocationIndexQuery(g, hopper.getLocationIndex(), count);
-            printTimeOfRouteQuery(hopper, isCH, isLM, count / 20, "routing", vehicleStr, true, -1, true);
+            printTimeOfRouteQuery(hopper, isCH, isLM, count / 20, "routing", vehicleStr, true, -1, true, false);
 
             if (hopper.getLMFactoryDecorator().isEnabled()) {
                 System.gc();
                 isLM = true;
                 int activeLMCount = 12;
                 for (; activeLMCount > 3; activeLMCount -= 4) {
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count / 4, "routingLM" + activeLMCount, vehicleStr, true, activeLMCount, true);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count / 4, "routingLM" + activeLMCount, vehicleStr, true, activeLMCount, true, false);
                 }
 
                 // compareRouting(hopper, vehicleStr, count / 5);
@@ -158,24 +168,30 @@ protected DataReader importData() throws IOException {
                     System.gc();
                     // try just one constellation, often ~4-6 is best
                     int lmCount = 5;
-                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCHLM" + lmCount, vehicleStr, true, lmCount, true);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCHLM" + lmCount, vehicleStr, true, lmCount, true, false);
                 }
 
                 isLM = false;
                 System.gc();
-                Weighting weighting = hopper.getCHFactoryDecorator().getWeightings().get(0);
-                CHGraph lg = g.getGraph(CHGraph.class, weighting);
-                fillAllowedEdges(lg.getAllEdges(), allowedEdges);
-                printMiscUnitPerfTests(lg, isCH, encoder, count * 100, allowedEdges);
-                printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH", vehicleStr, true, -1, true);
-                printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_sod", vehicleStr, true, -1, false);
-                printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_instr", vehicleStr, false, -1, true);
+                if (!hopper.getCHFactoryDecorator().getNodeBasedWeightings().isEmpty()) {
+                    Weighting weighting = hopper.getCHFactoryDecorator().getNodeBasedWeightings().get(0);
+                    CHGraph lg = g.getCHGraph(weighting);
+                    fillAllowedEdges(lg.getAllEdges(), allowedEdges);
+                    printMiscUnitPerfTests(lg, isCH, encoder, count * 100, allowedEdges);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH", vehicleStr, true, -1, true, false);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_sod", vehicleStr, true, -1, false, false);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_no_instr", vehicleStr, false, -1, true, false);
+                }
+                if (!hopper.getCHFactoryDecorator().getEdgeBasedWeightings().isEmpty()) {
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_edge", vehicleStr, true, -1, false, true);
+                    printTimeOfRouteQuery(hopper, isCH, isLM, count, "routingCH_edge_no_instr", vehicleStr, false, -1, false, true);
+                }
             }
         } catch (Exception ex) {
             logger.error("Problem while measuring " + graphLocation, ex);
             put("error", ex.toString());
         } finally {
-            put("measurement.gitinfo", gitCommit);
+            put("gh.gitinfo", Constants.GIT_INFO);
             put("measurement.count", count);
             put("measurement.seed", seed);
             put("measurement.time", sw.stop().getMillis());
@@ -395,7 +411,7 @@ private void compareCHWithAndWithoutSOD(final GraphHopper hopper, String vehicle
 
     private void printTimeOfRouteQuery(final GraphHopper hopper, final boolean ch, final boolean lm,
                                        int count, String prefix, final String vehicle,
-                                       final boolean withInstructions, final int activeLandmarks, final boolean sod) {
+                                       final boolean withInstructions, final int activeLandmarks, final boolean sod, final boolean edgeBased) {
         final Graph g = hopper.getGraphHopperStorage();
         final AtomicLong maxDistance = new AtomicLong(0);
         final AtomicLong minDistance = new AtomicLong(Long.MAX_VALUE);
@@ -427,12 +443,13 @@ public int doCalc(boolean warmup, int run) {
 
                 req.getHints().put(CH.DISABLE, !ch).
                         put("stall_on_demand", sod).
+                        put(Parameters.Routing.EDGE_BASED, edgeBased).
                         put(Landmark.DISABLE, !lm).
                         put(Landmark.ACTIVE_COUNT, activeLandmarks).
                         put("instructions", withInstructions);
 
                 if (withInstructions)
-                    req.setPathDetails(Arrays.asList(Parameters.DETAILS.AVERAGE_SPEED));
+                    req.setPathDetails(Arrays.asList(Parameters.Details.AVERAGE_SPEED));
 
                 // put(algo + ".approximation", "BeelineSimplification").
                 // put(algo + ".epsilon", 2);
@@ -485,7 +502,7 @@ else if (!toLowerCase(rsp.getErrors().get(0).getMessage()).contains("not found")
         count -= failedCount.get();
 
         // if using non-bidirectional algorithm make sure you exclude CH routing
-        String algoStr = ch ? Algorithms.DIJKSTRA_BI : Algorithms.ASTAR_BI;
+        String algoStr = (ch && !edgeBased) ? Algorithms.DIJKSTRA_BI : Algorithms.ASTAR_BI;
         if (ch && !sod) {
             algoStr += "_no_sod";
         }
@@ -544,15 +561,27 @@ private void writeSummary(String summaryLocation, String propLocation) {
         String[] properties = {
                 "graph.nodes",
                 "graph.edges",
-                "measurement.seed",
+                "graph.import_time",
                 CH.PREPARE + "time",
-                CH.PREPARE + "shortcuts",
+                CH.PREPARE + "node.shortcuts",
+                CH.PREPARE + "edge.shortcuts",
+                Landmark.PREPARE + "time",
                 "routing.distance_mean",
                 "routing.mean",
                 "routing.visited_nodes_mean",
                 "routingCH.distance_mean",
                 "routingCH.mean",
                 "routingCH.visited_nodes_mean",
+                "routingCH_no_instr.mean",
+                "routingCH_edge.distance_mean",
+                "routingCH_edge.mean",
+                "routingCH_edge.visited_nodes_mean",
+                "routingCH_edge_no_instr.mean",
+                "routingLM8.distance_mean",
+                "routingLM8.mean",
+                "routingLM8.visited_nodes_mean",
+                "measurement.seed",
+                "measurement.gitinfo",
                 "measurement.timestamp"
         };
         File f = new File(summaryLocation);
@@ -596,12 +625,12 @@ private String getFormattedProperty(String property) {
         try {
             double doubleValue = Double.parseDouble(result.trim());
             if (doubleValue != (long) doubleValue) {
-                result = String.format("%.2f", doubleValue);
+                result = String.format(Locale.US, "%.2f", doubleValue);
             }
         } catch (NumberFormatException e) {
             // its not a number, never mind
         }
-        return String.format("%" + getSummaryColumnWidth(property) + "s, ", result);
+        return String.format(Locale.US, "%" + getSummaryColumnWidth(property) + "s, ", result);
     }
 
     private int getSummaryColumnWidth(String p) {
diff --git a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
index dee0c9ee9a..55a98fcd39 100644
--- a/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
+++ b/tools/src/main/java/com/graphhopper/ui/MiniGraphUI.java
@@ -25,6 +25,8 @@
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.ch.PreparationWeighting;
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.DecimalEncodedValue;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.CHGraph;
@@ -64,6 +66,8 @@
     private final MapLayer pathLayer;
     private final Weighting weighting;
     private final FlagEncoder encoder;
+    private final DecimalEncodedValue avSpeedEnc;
+    private final BooleanEncodedValue accessEnc;
     private final RoutingAlgorithmFactory algoFactory;
     private final AlgorithmOptions algoOpts;
     // for moving
@@ -85,14 +89,16 @@ public MiniGraphUI(GraphHopper hopper, boolean debug) {
         final Graph graph = hopper.getGraphHopperStorage();
         this.na = graph.getNodeAccess();
         encoder = hopper.getEncodingManager().getEncoder("car");
+        avSpeedEnc = encoder.getAverageSpeedEnc();
+        accessEnc = encoder.getAccessEnc();
         HintsMap map = new HintsMap("fastest").
                 setVehicle("car");
 
         boolean ch = true;
         if (ch) {
             map.put(Parameters.Landmark.DISABLE, true);
-            weighting = hopper.getCHFactoryDecorator().getWeightings().get(0);
-            routingGraph = hopper.getGraphHopperStorage().getGraph(CHGraph.class, weighting);
+            weighting = hopper.getCHFactoryDecorator().getNodeBasedWeightings().get(0);
+            routingGraph = hopper.getGraphHopperStorage().getCHGraph(weighting);
 
             final RoutingAlgorithmFactory tmpFactory = hopper.getAlgorithmFactory(map);
             algoFactory = new RoutingAlgorithmFactory() {
@@ -101,8 +107,8 @@ public MiniGraphUI(GraphHopper hopper, boolean debug) {
                     private final GraphicsWrapper mg;
                     private Graphics2D g2;
 
-                    public TmpAlgo(Graph graph, Weighting type, TraversalMode tMode, GraphicsWrapper mg) {
-                        super(graph, type, tMode);
+                    public TmpAlgo(Graph graph, Weighting type, GraphicsWrapper mg) {
+                        super(graph, type);
                         this.mg = mg;
                     }
 
@@ -124,7 +130,7 @@ public void updateBestPath(EdgeIteratorState es, SPTEntry entry, int traversalId
                 public RoutingAlgorithm createAlgo(Graph g, AlgorithmOptions opts) {
                     // doable but ugly
                     Weighting w = ((PrepareContractionHierarchies) tmpFactory).getWeighting();
-                    return new TmpAlgo(g, new PreparationWeighting(w), TraversalMode.NODE_BASED, mg).
+                    return new TmpAlgo(g, new PreparationWeighting(w), mg).
                             setEdgeFilter(new LevelEdgeFilter((CHGraph) routingGraph));
                 }
             };
@@ -193,7 +199,7 @@ protected void paintComponent(Graphics g) {
             Random rand = new Random();
 
             @Override
-            public void paintComponent(Graphics2D g2) {
+            public void paintComponent(final Graphics2D g2) {
                 clearGraphics(g2);
                 int locs = graph.getNodes();
                 Rectangle d = getBounds();
@@ -213,7 +219,7 @@ public void paintComponent(Graphics2D g2) {
 //
 //                g2.setColor(Color.RED.brighter().brighter());
 //                path = prepare.createAlgo().calcPath(from, to);
-//                System.out.println("now: " + path.toDetailsString());
+//                System.out.println("now: " + path.toFlagEncodersAsString());
 //                plotPath(path, g2, 1);
                 g2.setColor(Color.black);
 
@@ -244,7 +250,7 @@ public void paintComponent(Graphics2D g2) {
 
                     // mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, iter.getName());
                     //mg.plotText(g2, lat * 0.9 + lat2 * 0.1, lon * 0.9 + lon2 * 0.1, "s:" + (int) encoder.getSpeed(iter.getFlags()));
-                    double speed = encoder.getSpeed(edge.getFlags());
+                    double speed = edge.get(avSpeedEnc);
                     Color color;
                     if (speed >= 120) {
                         // red
@@ -266,16 +272,41 @@ public void paintComponent(Graphics2D g2) {
                     }
 
                     g2.setColor(color);
-                    boolean fwd = encoder.isForward(edge.getFlags());
-                    boolean bwd = encoder.isBackward(edge.getFlags());
+                    boolean fwd = edge.get(accessEnc);
+                    boolean bwd = edge.getReverse(accessEnc);
                     float width = speed > 90 ? 1f : 0.8f;
-                    if (fwd && !bwd) {
-                        mg.plotDirectedEdge(g2, lat, lon, lat2, lon2, width);
-                    } else {
-                        mg.plotEdge(g2, lat, lon, lat2, lon2, width);
+                    PointList pl = edge.fetchWayGeometry(3);
+                    for (int i = 1; i < pl.size(); i++) {
+                        if (fwd && !bwd) {
+                            mg.plotDirectedEdge(g2, pl.getLatitude(i - 1), pl.getLongitude(i - 1), pl.getLatitude(i), pl.getLongitude(i), width);
+                        } else {
+                            mg.plotEdge(g2, pl.getLatitude(i - 1), pl.getLongitude(i - 1), pl.getLatitude(i), pl.getLongitude(i), width);
+                        }
                     }
                 }
 
+                index.query(graph.getBounds(), new LocationIndexTree.Visitor() {
+                    @Override
+                    public boolean isTileInfo() {
+                        return true;
+                    }
+
+                    @Override
+                    public void onTile(BBox bbox, int depth) {
+                        int width = Math.max(1, Math.min(4, 4 - depth));
+                        g2.setColor(Color.GRAY);
+                        mg.plotEdge(g2, bbox.minLat, bbox.minLon, bbox.minLat, bbox.maxLon, width);
+                        mg.plotEdge(g2, bbox.minLat, bbox.maxLon, bbox.maxLat, bbox.maxLon, width);
+                        mg.plotEdge(g2, bbox.maxLat, bbox.maxLon, bbox.maxLat, bbox.minLon, width);
+                        mg.plotEdge(g2, bbox.maxLat, bbox.minLon, bbox.minLat, bbox.minLon, width);
+                    }
+
+                    @Override
+                    public void onNode(int node) {
+                        // mg.plotNode(g2, node, Color.BLUE);
+                    }
+                });
+
                 g2.setColor(Color.WHITE);
                 g2.fillRect(0, 0, 1000, 20);
                 for (int i = 4; i < speedColors.length; i++) {
diff --git a/web-api/pom.xml b/web-api/pom.xml
index 89c3cbecfe..4e251a56c4 100644
--- a/web-api/pom.xml
+++ b/web-api/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web-api</artifactId>
     <packaging>jar</packaging>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <name>GraphHopper Web API</name>
     <description>JSON Representation of the API classes</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -23,39 +23,24 @@
             <version>${project.parent.version}</version>
         </dependency>
         <dependency>
-            <groupId>io.dropwizard</groupId>
-            <artifactId>dropwizard-jackson</artifactId>
-            <version>1.3.2</version>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-core</artifactId>
+            <version>${jackson.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+            <version>${jackson.version}</version>
         </dependency>
         <dependency>
-            <groupId>com.bedatadriven</groupId>
+            <groupId>com.graphhopper.external</groupId>
             <artifactId>jackson-datatype-jts</artifactId>
-            <version>2.4</version>
-            <exclusions>
-                <exclusion>
-                    <groupId>com.vividsolutions</groupId>
-                    <artifactId>jts</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>com.fasterxml.jackson.core</groupId>
-                    <artifactId>jackson-annotations</artifactId>
-                </exclusion>
-                <exclusion>
-                    <groupId>com.fasterxml.jackson.core</groupId>
-                    <artifactId>jackson-databind</artifactId>
-                </exclusion>
-            </exclusions>
+            <version>0.12-2.5-1</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-testing</artifactId>
-            <version>1.3.2</version>
-            <scope>test</scope>
-        </dependency>
-        <dependency>
-            <groupId>org.mockito</groupId>
-            <artifactId>mockito-core</artifactId>
-            <version>1.10.19</version>
+            <version>${dropwizard.version}</version>
             <scope>test</scope>
         </dependency>
     </dependencies>
@@ -65,7 +50,6 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
                 <configuration>
                     <source>1.8</source>
                     <target>1.8</target>
diff --git a/web-api/src/main/java/com/graphhopper/http/WebHelper.java b/web-api/src/main/java/com/graphhopper/http/WebHelper.java
index 4d2e4d179c..1b691ea50f 100644
--- a/web-api/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web-api/src/main/java/com/graphhopper/http/WebHelper.java
@@ -28,6 +28,8 @@
 import java.io.UnsupportedEncodingException;
 import java.net.URLEncoder;
 import java.text.NumberFormat;
+import java.util.Arrays;
+import java.util.List;
 import java.util.Locale;
 
 /**
@@ -141,17 +143,24 @@ private static void encodeNumber(StringBuilder sb, int num) {
         sb.append((char) (num));
     }
 
+    /**
+     * This includes the required attribution for OpenStreetMap.
+     * Do not hesitate to you mention us and link us in your about page
+     * https://support.graphhopper.com/support/search/solutions?term=attribution
+     */
+    public static final List<String> COPYRIGHTS = Arrays.asList("GraphHopper", "OpenStreetMap contributors");
+
+    public static ObjectNode jsonResponsePutInfo(ObjectNode json, float took) {
+        final ObjectNode info = json.putObject("info");
+        info.putPOJO("copyrights", COPYRIGHTS);
+        info.put("took", Math.round(took * 1000));
+        return json;
+    }
 
     public static ObjectNode jsonObject(GHResponse ghRsp, boolean enableInstructions, boolean calcPoints, boolean enableElevation, boolean pointsEncoded, float took) {
         ObjectNode json = JsonNodeFactory.instance.objectNode();
         json.putPOJO("hints", ghRsp.getHints().toMap());
-        // If you replace GraphHopper with your own brand name, this is fine.
-        // Still it would be highly appreciated if you mention us in your about page!
-        final ObjectNode info = json.putObject("info");
-        info.putArray("copyrights")
-                .add("GraphHopper")
-                .add("OpenStreetMap contributors");
-        info.put("took", Math.round(took * 1000));
+        jsonResponsePutInfo(json, took);
         ArrayNode jsonPathList = json.putArray("paths");
         for (PathWrapper ar : ghRsp.getAll()) {
             ObjectNode jsonPath = jsonPathList.addObject();
diff --git a/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java b/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java
new file mode 100644
index 0000000000..5391637a66
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/http/api/JsonErrorEntity.java
@@ -0,0 +1,60 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http.api;
+
+import com.fasterxml.jackson.annotation.JsonValue;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import com.graphhopper.util.exceptions.GHException;
+
+import java.util.List;
+
+public class JsonErrorEntity {
+
+    private final List<Throwable> errors;
+
+    public JsonErrorEntity(List<Throwable> t) {
+        this.errors = t;
+    }
+
+    @JsonValue
+    ObjectNode jsonErrorResponse() {
+        ObjectNode json = JsonNodeFactory.instance.objectNode();
+        json.put("message", getMessage(errors.get(0)));
+        ArrayNode errorHintList = json.putArray("hints");
+        for (Throwable t : errors) {
+            ObjectNode error = errorHintList.addObject();
+            error.put("message", getMessage(t));
+            error.put("details", t.getClass().getName());
+            if (t instanceof GHException) {
+                ((GHException) t).getDetails().forEach(error::putPOJO);
+            }
+        }
+        return json;
+    }
+
+    private String getMessage(Throwable t) {
+        if (t.getMessage() == null)
+            return t.getClass().getSimpleName();
+        else
+            return t.getMessage();
+    }
+
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java
new file mode 100644
index 0000000000..52057d0c89
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/GHResponseDeserializer.java
@@ -0,0 +1,42 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.GHResponse;
+import com.graphhopper.PathWrapper;
+
+import java.io.IOException;
+
+public class GHResponseDeserializer extends JsonDeserializer<GHResponse> {
+    @Override
+    public GHResponse deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+        GHResponse ghResponse = new GHResponse();
+        JsonNode treeNode = p.readValueAsTree();
+        for (JsonNode path : treeNode.get("paths")) {
+            PathWrapper pathWrapper = ((ObjectMapper) p.getCodec()).convertValue(path, PathWrapper.class);
+            ghResponse.add(pathWrapper);
+        }
+        return ghResponse;
+    }
+}
diff --git a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
index c26a46e270..3c5ef5049d 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/GraphHopperModule.java
@@ -1,7 +1,9 @@
 package com.graphhopper.jackson;
 
 import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.graphhopper.GHResponse;
 import com.graphhopper.MultiException;
+import com.graphhopper.PathWrapper;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.details.PathDetail;
@@ -11,6 +13,8 @@
 public class GraphHopperModule extends SimpleModule {
 
     public GraphHopperModule() {
+        addDeserializer(GHResponse.class, new GHResponseDeserializer());
+        addDeserializer(PathWrapper.class, new PathWrapperDeserializer());
         addDeserializer(BBox.class, new BBoxDeserializer());
         addSerializer(BBox.class, new BBoxSerializer());
         addDeserializer(GHPoint.class, new GHPointDeserializer());
diff --git a/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
index f584c82d15..92965c465f 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/InstructionListSerializer.java
@@ -3,13 +3,44 @@
 import com.fasterxml.jackson.core.JsonGenerator;
 import com.fasterxml.jackson.databind.JsonSerializer;
 import com.fasterxml.jackson.databind.SerializerProvider;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.Instruction;
+import com.graphhopper.util.InstructionAnnotation;
 import com.graphhopper.util.InstructionList;
 
 import java.io.IOException;
+import java.util.*;
 
 public class InstructionListSerializer extends JsonSerializer<InstructionList> {
     @Override
     public void serialize(InstructionList instructions, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
-        jsonGenerator.writeObject(instructions.createJson());
+        List<Map<String, Object>> instrList = new ArrayList<>(instructions.size());
+        int pointsIndex = 0;
+        for (Instruction instruction : instructions) {
+            Map<String, Object> instrJson = new HashMap<>();
+            instrList.add(instrJson);
+
+            InstructionAnnotation ia = instruction.getAnnotation();
+            String text = instruction.getTurnDescription(instructions.getTr());
+            if (Helper.isEmpty(text))
+                text = ia.getMessage();
+            instrJson.put("text", Helper.firstBig(text));
+            if (!ia.isEmpty()) {
+                instrJson.put("annotation_text", ia.getMessage());
+                instrJson.put("annotation_importance", ia.getImportance());
+            }
+
+            instrJson.put("street_name", instruction.getName());
+            instrJson.put("time", instruction.getTime());
+            instrJson.put("distance", Helper.round(instruction.getDistance(), 3));
+            instrJson.put("sign", instruction.getSign());
+            instrJson.putAll(instruction.getExtraInfoJSON());
+
+            int tmpIndex = pointsIndex + instruction.getLength();
+            instrJson.put("interval", Arrays.asList(pointsIndex, tmpIndex));
+            pointsIndex = tmpIndex;
+
+        }
+        jsonGenerator.writeObject(instrList);
     }
 }
diff --git a/web-api/src/main/java/com/graphhopper/jackson/Jackson.java b/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
index 1663d4cc12..15f8532eb5 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
@@ -18,13 +18,15 @@
 package com.graphhopper.jackson;
 
 import com.bedatadriven.jackson.datatype.jts.JtsModule;
+import com.fasterxml.jackson.annotation.JsonInclude;
 import com.fasterxml.jackson.databind.*;
 
 public class Jackson {
     public static ObjectMapper newObjectMapper() {
-        ObjectMapper objectMapper = io.dropwizard.jackson.Jackson.newObjectMapper();
+        ObjectMapper objectMapper = new ObjectMapper();
         objectMapper.registerModule(new GraphHopperModule());
         objectMapper.registerModule(new JtsModule());
+        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
         return objectMapper;
     }
 }
diff --git a/web-api/src/main/java/com/graphhopper/jackson/PathDetailSerializer.java b/web-api/src/main/java/com/graphhopper/jackson/PathDetailSerializer.java
index db718902a2..f1d118f81d 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/PathDetailSerializer.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/PathDetailSerializer.java
@@ -27,6 +27,8 @@ else if (value.getValue() instanceof Boolean)
             gen.writeBoolean((Boolean) value.getValue());
         else if (value.getValue() instanceof String)
             gen.writeString((String) value.getValue());
+        else if (value.getValue() == null)
+            gen.writeNull();
         else
             throw new JsonGenerationException("Unsupported type for PathDetail.value" + value.getValue().getClass(), gen);
 
diff --git a/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java b/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
new file mode 100644
index 0000000000..dd3a8775ff
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/jackson/PathWrapperDeserializer.java
@@ -0,0 +1,254 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.jackson;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.http.WebHelper;
+import com.graphhopper.util.*;
+import com.graphhopper.util.details.PathDetail;
+import com.graphhopper.util.exceptions.*;
+import org.locationtech.jts.geom.LineString;
+
+import java.io.IOException;
+import java.util.*;
+
+public class PathWrapperDeserializer extends JsonDeserializer<PathWrapper> {
+    @Override
+    public PathWrapper deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+        return createPathWrapper((ObjectMapper) p.getCodec(), p.readValueAsTree(), false, true);
+    }
+
+    public static PathWrapper createPathWrapper(ObjectMapper objectMapper, JsonNode path, boolean hasElevation, boolean turnDescription) {
+        PathWrapper pathWrapper = new PathWrapper();
+        pathWrapper.addErrors(readErrors(objectMapper, path));
+        if (pathWrapper.hasErrors())
+            return pathWrapper;
+
+        if (path.has("snapped_waypoints")) {
+            JsonNode snappedWaypoints = path.get("snapped_waypoints");
+            PointList snappedPoints = deserializePointList(objectMapper, snappedWaypoints, hasElevation);
+            pathWrapper.setWaypoints(snappedPoints);
+        }
+
+        if (path.has("ascend")) {
+            pathWrapper.setAscend(path.get("ascend").asDouble());
+        }
+        if (path.has("descend")) {
+            pathWrapper.setDescend(path.get("descend").asDouble());
+        }
+        if (path.has("weight")) {
+            pathWrapper.setRouteWeight(path.get("weight").asDouble());
+        }
+        if (path.has("description")) {
+            JsonNode descriptionNode = path.get("description");
+            if (descriptionNode.isArray()) {
+                List<String> description = new ArrayList<>(descriptionNode.size());
+                for (JsonNode descNode : descriptionNode) {
+                    description.add(descNode.asText());
+                }
+                pathWrapper.setDescription(description);
+            } else {
+                throw new IllegalStateException("Description has to be an array");
+            }
+        }
+
+        if (path.has("points")) {
+            final PointList pointList = deserializePointList(objectMapper, path.get("points"), hasElevation);
+            pathWrapper.setPoints(pointList);
+
+            if (path.has("instructions")) {
+                JsonNode instrArr = path.get("instructions");
+
+                InstructionList il = new InstructionList(null);
+                int viaCount = 1;
+                for (JsonNode jsonObj : instrArr) {
+                    double instDist = jsonObj.get("distance").asDouble();
+                    String text = turnDescription ? jsonObj.get("text").asText() : jsonObj.get("street_name").asText();
+                    long instTime = jsonObj.get("time").asLong();
+                    int sign = jsonObj.get("sign").asInt();
+                    JsonNode iv = jsonObj.get("interval");
+                    int from = iv.get(0).asInt();
+                    int to = iv.get(1).asInt();
+                    PointList instPL = new PointList(to - from, hasElevation);
+                    for (int j = from; j <= to; j++) {
+                        instPL.add(pointList, j);
+                    }
+
+                    InstructionAnnotation ia = InstructionAnnotation.EMPTY;
+                    if (jsonObj.has("annotation_importance") && jsonObj.has("annotation_text")) {
+                        ia = new InstructionAnnotation(jsonObj.get("annotation_importance").asInt(), jsonObj.get("annotation_text").asText());
+                    }
+
+                    Instruction instr;
+                    if (sign == Instruction.USE_ROUNDABOUT || sign == Instruction.LEAVE_ROUNDABOUT) {
+                        RoundaboutInstruction ri = new RoundaboutInstruction(sign, text, ia, instPL);
+
+                        if (jsonObj.has("exit_number")) {
+                            ri.setExitNumber(jsonObj.get("exit_number").asInt());
+                        }
+
+                        if (jsonObj.has("exited")) {
+                            if (jsonObj.get("exited").asBoolean())
+                                ri.setExited();
+                        }
+
+                        if (jsonObj.has("turn_angle")) {
+                            // TODO provide setTurnAngle setter
+                            double angle = jsonObj.get("turn_angle").asDouble();
+                            ri.setDirOfRotation(angle);
+                            ri.setRadian((angle < 0 ? -Math.PI : Math.PI) - angle);
+                        }
+
+                        instr = ri;
+                    } else if (sign == Instruction.REACHED_VIA) {
+                        ViaInstruction tmpInstr = new ViaInstruction(text, ia, instPL);
+                        tmpInstr.setViaCount(viaCount);
+                        viaCount++;
+                        instr = tmpInstr;
+                    } else if (sign == Instruction.FINISH) {
+                        instr = new FinishInstruction(text, instPL, 0);
+                    } else {
+                        instr = new Instruction(sign, text, ia, instPL);
+                        if (sign == Instruction.CONTINUE_ON_STREET) {
+                            if (jsonObj.has("heading")) {
+                                instr.setExtraInfo("heading", jsonObj.get("heading").asDouble());
+                            }
+                        }
+                    }
+
+                    // Usually, the translation is done from the routing service so just use the provided string
+                    // instead of creating a combination with sign and name etc.
+                    // This is called the turn description.
+                    // This can be changed by passing <code>turn_description=false</code>.
+                    if (turnDescription)
+                        instr.setUseRawName();
+
+                    instr.setDistance(instDist).setTime(instTime);
+                    il.add(instr);
+                }
+                pathWrapper.setInstructions(il);
+            }
+
+            if (path.has("details")) {
+                JsonNode details = path.get("details");
+                Map<String, List<PathDetail>> pathDetails = new HashMap<>(details.size());
+                Iterator<Map.Entry<String, JsonNode>> detailIterator = details.fields();
+                while (detailIterator.hasNext()) {
+                    Map.Entry<String, JsonNode> detailEntry = detailIterator.next();
+                    List<PathDetail> pathDetailList = new ArrayList<>();
+                    for (JsonNode pathDetail : detailEntry.getValue()) {
+                        PathDetail pd = objectMapper.convertValue(pathDetail, PathDetail.class);
+                        pathDetailList.add(pd);
+                    }
+                    pathDetails.put(detailEntry.getKey(), pathDetailList);
+                }
+                pathWrapper.addPathDetails(pathDetails);
+            }
+        }
+
+        if (path.has("points_order")) {
+            pathWrapper.setPointsOrder((List<Integer>) objectMapper.convertValue(path.get("points_order"), List.class));
+        } else {
+            List<Integer> list = new ArrayList<>(pathWrapper.getWaypoints().size());
+            for (int i = 0; i < pathWrapper.getWaypoints().size(); i++) {
+                list.add(i);
+            }
+            pathWrapper.setPointsOrder(list);
+        }
+
+        double distance = path.get("distance").asDouble();
+        long time = path.get("time").asLong();
+        pathWrapper.setDistance(distance).setTime(time);
+        return pathWrapper;
+    }
+
+    private static PointList deserializePointList(ObjectMapper objectMapper, JsonNode jsonNode, boolean hasElevation) {
+        PointList snappedPoints;
+        if (jsonNode.isTextual()) {
+            snappedPoints = WebHelper.decodePolyline(jsonNode.asText(), 5, hasElevation);
+        } else {
+            LineString lineString = objectMapper.convertValue(jsonNode, LineString.class);
+            snappedPoints = PointList.fromLineString(lineString);
+        }
+        return snappedPoints;
+    }
+
+    public static List<Throwable> readErrors(ObjectMapper objectMapper, JsonNode json) {
+        List<Throwable> errors = new ArrayList<>();
+        JsonNode errorJson;
+
+        if (json.has("message")) {
+            if (json.has("hints")) {
+                errorJson = json.get("hints");
+            } else {
+                // should not happen
+                errors.add(new RuntimeException(json.get("message").asText()));
+                return errors;
+            }
+        } else
+            return errors;
+
+        for (JsonNode error : errorJson) {
+            String exClass = "";
+            if (error.has("details"))
+                exClass = error.get("details").asText();
+
+            String exMessage = error.get("message").asText();
+
+            if (exClass.equals(UnsupportedOperationException.class.getName()))
+                errors.add(new UnsupportedOperationException(exMessage));
+            else if (exClass.equals(IllegalStateException.class.getName()))
+                errors.add(new IllegalStateException(exMessage));
+            else if (exClass.equals(RuntimeException.class.getName()))
+                errors.add(new DetailedRuntimeException(exMessage, toMap(objectMapper, error)));
+            else if (exClass.equals(IllegalArgumentException.class.getName()))
+                errors.add(new DetailedIllegalArgumentException(exMessage, toMap(objectMapper, error)));
+            else if (exClass.equals(ConnectionNotFoundException.class.getName())) {
+                errors.add(new ConnectionNotFoundException(exMessage, toMap(objectMapper, error)));
+            } else if (exClass.equals(PointNotFoundException.class.getName())) {
+                int pointIndex = error.get("point_index").asInt();
+                errors.add(new PointNotFoundException(exMessage, pointIndex));
+            } else if (exClass.equals(PointOutOfBoundsException.class.getName())) {
+                int pointIndex = error.get("point_index").asInt();
+                errors.add(new PointOutOfBoundsException(exMessage, pointIndex));
+            } else if (exClass.isEmpty())
+                errors.add(new DetailedRuntimeException(exMessage, toMap(objectMapper, error)));
+            else
+                errors.add(new DetailedRuntimeException(exClass + " " + exMessage, toMap(objectMapper, error)));
+        }
+
+        if (json.has("message") && errors.isEmpty())
+            errors.add(new RuntimeException(json.get("message").asText()));
+
+        return errors;
+    }
+
+    // Credits to: http://stackoverflow.com/a/24012023/194609
+    private static Map<String, Object> toMap(ObjectMapper objectMapper, JsonNode object) {
+        return objectMapper.convertValue(object, new TypeReference<Map<String, Object>>() {
+        });
+    }
+
+}
diff --git a/api/src/main/java/com/graphhopper/util/GPXEntry.java b/web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
similarity index 52%
rename from api/src/main/java/com/graphhopper/util/GPXEntry.java
rename to web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
index 49a1e0a803..27847c1705 100644
--- a/api/src/main/java/com/graphhopper/util/GPXEntry.java
+++ b/web-api/src/main/java/com/graphhopper/util/gpx/GPXEntry.java
@@ -15,62 +15,55 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.util;
+package com.graphhopper.util.gpx;
 
 import com.graphhopper.util.shapes.GHPoint;
-import com.graphhopper.util.shapes.GHPoint3D;
+
+import java.util.Objects;
 
 /**
  * @author Peter Karich
  */
-public class GPXEntry extends GHPoint3D {
-    private long time;
-
-    public GPXEntry(GHPoint p, long millis) {
-        this(p.lat, p.lon, millis);
-    }
-
-    public GPXEntry(double lat, double lon, long millis) {
-        super(lat, lon, Double.NaN);
-        this.time = millis;
-    }
+public class GPXEntry {
+    private GHPoint point;
+    private Long time;
 
-    public GPXEntry(double lat, double lon, double ele, long millis) {
-        super(lat, lon, ele);
-        this.time = millis;
+    public GPXEntry(GHPoint p) {
+        this.point = p;
     }
 
-    boolean is3D() {
-        return !Double.isNaN(ele);
+    public GPXEntry(GHPoint p, long time) {
+        this.point = p;
+        this.time = time;
     }
 
-    /**
-     * The time relative to the start time in milli seconds.
-     */
-    public long getTime() {
+    public Long getTime() {
         return time;
     }
 
-    public void setTime(long time) {
-        this.time = time;
+    public GHPoint getPoint() {
+        return point;
     }
 
     @Override
-    public int hashCode() {
-        return 59 * super.hashCode() + (int) (time ^ (time >>> 32));
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        GPXEntry gpxEntry = (GPXEntry) o;
+        return Objects.equals(point, gpxEntry.point) &&
+                Objects.equals(time, gpxEntry.time);
     }
 
     @Override
-    public boolean equals(Object obj) {
-        if (obj == null)
-            return false;
-
-        final GPXEntry other = (GPXEntry) obj;
-        return time == other.time && super.equals(obj);
+    public int hashCode() {
+        return Objects.hash(point, time);
     }
 
     @Override
     public String toString() {
-        return super.toString() + ", " + time;
+        return "GPXEntry{" +
+                "point=" + point +
+                ", time=" + time +
+                '}';
     }
 }
diff --git a/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java b/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java
new file mode 100644
index 0000000000..29522f0994
--- /dev/null
+++ b/web-api/src/main/java/com/graphhopper/util/gpx/GpxFromInstructions.java
@@ -0,0 +1,173 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.util.gpx;
+
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint3D;
+
+import java.text.DateFormat;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+public class GpxFromInstructions {
+
+    static String simpleXMLEscape(String str) {
+        // We could even use the 'more flexible' CDATA section but for now do the following. The 'and' could be important sometimes:
+        return str.replaceAll("&", "&amp;").
+                // but do not care for:
+                        replaceAll("[\\<\\>]", "_");
+    }
+
+    public static List<GPXEntry> createGPXList(InstructionList instructions) {
+        List<GPXEntry> gpxList = new ArrayList<>();
+        long timeOffset = 0;
+        for (Instruction instruction : instructions) {
+            int i = 0;
+            for (GHPoint3D point : instruction.getPoints()) {
+                GPXEntry gpxEntry;
+                if (i == 0) {
+                    gpxEntry = new GPXEntry(point, timeOffset);
+                } else {
+                    // We don't have timestamps for pillar nodes
+                    gpxEntry = new GPXEntry(point);
+                }
+                gpxList.add(gpxEntry);
+                i++;
+            }
+            timeOffset = timeOffset + instruction.getTime();
+        }
+        return gpxList;
+    }
+
+    private static void createWayPointBlock(StringBuilder output, Instruction instruction, DecimalFormat decimalFormat, Translation tr) {
+        output.append("\n<wpt ");
+        output.append("lat=\"").append(decimalFormat.format(instruction.getPoints().getLatitude(0)));
+        output.append("\" lon=\"").append(decimalFormat.format(instruction.getPoints().getLongitude(0))).append("\">");
+        String name;
+        if (instruction.getName().isEmpty())
+            name = instruction.getTurnDescription(tr);
+        else
+            name = instruction.getName();
+
+        output.append(" <name>").append(simpleXMLEscape(name)).append("</name>");
+        output.append("</wpt>");
+    }
+
+    public static String createGPX(InstructionList instructions, String trackName, long startTimeMillis, boolean includeElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version, Translation tr) {
+        DateFormat formatter = Helper.createFormatter();
+
+        DecimalFormat decimalFormat = new DecimalFormat("#", DecimalFormatSymbols.getInstance(Locale.ROOT));
+        decimalFormat.setMinimumFractionDigits(1);
+        decimalFormat.setMaximumFractionDigits(6);
+        decimalFormat.setMinimumIntegerDigits(1);
+
+        String header = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>"
+                + "<gpx xmlns=\"http://www.topografix.com/GPX/1/1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\""
+                + " creator=\"Graphhopper version " + version + "\" version=\"1.1\""
+                // This xmlns:gh acts only as ID, no valid URL necessary.
+                // Use a separate namespace for custom extensions to make basecamp happy.
+                + " xmlns:gh=\"https://graphhopper.com/public/schema/gpx/1.1\">"
+                + "\n<metadata>"
+                + "<copyright author=\"OpenStreetMap contributors\"/>"
+                + "<link href=\"http://graphhopper.com\">"
+                + "<text>GraphHopper GPX</text>"
+                + "</link>"
+                + "<time>" + formatter.format(startTimeMillis) + "</time>"
+                + "</metadata>";
+        StringBuilder gpxOutput = new StringBuilder(header);
+        if (!instructions.isEmpty()) {
+            if (withWayPoints) {
+                createWayPointBlock(gpxOutput, instructions.get(0), decimalFormat, tr);   // Start
+                for (Instruction currInstr : instructions) {
+                    if ((currInstr.getSign() == Instruction.REACHED_VIA) // Via
+                            || (currInstr.getSign() == Instruction.FINISH)) // End
+                    {
+                        createWayPointBlock(gpxOutput, currInstr, decimalFormat, tr);
+                    }
+                }
+            }
+            if (withRoute) {
+                gpxOutput.append("\n<rte>");
+                Instruction nextInstr = null;
+                for (Instruction currInstr : instructions) {
+                    if (null != nextInstr)
+                        createRteptBlock(gpxOutput, nextInstr, currInstr, decimalFormat, tr);
+
+                    nextInstr = currInstr;
+                }
+                createRteptBlock(gpxOutput, nextInstr, null, decimalFormat, tr);
+                gpxOutput.append("\n</rte>");
+            }
+        }
+        if (withTrack) {
+            gpxOutput.append("\n<trk><name>").append(trackName).append("</name>");
+
+            gpxOutput.append("<trkseg>");
+            for (GPXEntry entry : createGPXList(instructions)) {
+                gpxOutput.append("\n<trkpt lat=\"").append(decimalFormat.format(entry.getPoint().getLat()));
+                gpxOutput.append("\" lon=\"").append(decimalFormat.format(entry.getPoint().getLon())).append("\">");
+                if (includeElevation)
+                    gpxOutput.append("<ele>").append(Helper.round2(((GHPoint3D) entry.getPoint()).getEle())).append("</ele>");
+                if (entry.getTime() != null)
+                    gpxOutput.append("<time>").append(formatter.format(startTimeMillis + entry.getTime())).append("</time>");
+                gpxOutput.append("</trkpt>");
+            }
+            gpxOutput.append("\n</trkseg>");
+            gpxOutput.append("\n</trk>");
+        }
+
+        // we could now use 'wpt' for via points
+        gpxOutput.append("\n</gpx>");
+        return gpxOutput.toString();
+    }
+
+    private static void createRteptBlock(StringBuilder output, Instruction instruction, Instruction nextI, DecimalFormat decimalFormat, Translation tr) {
+        output.append("\n<rtept lat=\"").append(decimalFormat.format(instruction.getPoints().getLatitude(0))).
+                append("\" lon=\"").append(decimalFormat.format(instruction.getPoints().getLongitude(0))).append("\">");
+
+        if (!instruction.getName().isEmpty())
+            output.append("<desc>").append(simpleXMLEscape(instruction.getTurnDescription(tr))).append("</desc>");
+
+        output.append("<extensions>");
+        output.append("<gh:distance>").append(Helper.round(instruction.getDistance(), 1)).append("</gh:distance>");
+        output.append("<gh:time>").append(instruction.getTime()).append("</gh:time>");
+
+        String direction = instruction.calcDirection(nextI);
+        if (!direction.isEmpty())
+            output.append("<gh:direction>").append(direction).append("</gh:direction>");
+
+        double azimuth = instruction.calcAzimuth(nextI);
+        if (!Double.isNaN(azimuth))
+            output.append("<gh:azimuth>").append(Helper.round2(azimuth)).append("</gh:azimuth>");
+
+        if (instruction instanceof RoundaboutInstruction) {
+            RoundaboutInstruction ri = (RoundaboutInstruction) instruction;
+
+            output.append("<gh:exit_number>").append(ri.getExitNumber()).append("</gh:exit_number>");
+        }
+
+        output.append("<gh:sign>").append(instruction.getSign()).append("</gh:sign>");
+        output.append("</extensions>");
+        output.append("</rtept>");
+    }
+
+}
diff --git a/web-api/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java b/web-api/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
index 094627e1c2..b013019705 100644
--- a/web-api/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
+++ b/web-api/src/test/java/com/graphhopper/json/geo/JsonFeatureCollectionTest.java
@@ -20,11 +20,16 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.jackson.Jackson;
 import com.graphhopper.util.PointList;
-import com.vividsolutions.jts.geom.LineString;
+import com.graphhopper.util.shapes.BBox;
 import org.junit.Assert;
 import org.junit.Test;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
 
 import java.io.IOException;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
 import static io.dropwizard.testing.FixtureHelpers.fixture;
@@ -36,6 +41,52 @@
 public class JsonFeatureCollectionTest {
     private final ObjectMapper objectMapper = Jackson.newObjectMapper();
 
+    @Test
+    public void testSerialization() throws IOException {
+        GeometryFactory geometryFactory = new GeometryFactory();
+
+        JsonFeatureCollection jsonFeatureCollection = new JsonFeatureCollection();
+        {
+            JsonFeature jsonFeature = new JsonFeature();
+            jsonFeature.setId("1");
+            HashMap<String, Object> properties = new HashMap<>();
+            properties.put("prop0", "value0");
+            jsonFeature.setProperties(properties);
+            jsonFeature.setGeometry(geometryFactory.createPoint(new Coordinate(102.0,0.5)));
+            jsonFeatureCollection.getFeatures().add(jsonFeature);
+        }
+        {
+            JsonFeature jsonFeature = new JsonFeature();
+            jsonFeature.setId("2");
+            Map<String, Object> properties = new LinkedHashMap<>();
+            properties.put("prop0", "value1");
+            properties.put("prop1", 2);
+            jsonFeature.setProperties(properties);
+            jsonFeature.setGeometry(geometryFactory.createLineString(new Coordinate[]{
+                    new Coordinate(102.0, 0.0),
+                    new Coordinate(103.0, 1.0),
+                    new Coordinate(104.0, 0.0),
+                    new Coordinate(105.0, 1.0)}));
+            jsonFeatureCollection.getFeatures().add(jsonFeature);
+        }
+        {
+            JsonFeature jsonFeature = new JsonFeature();
+            jsonFeature.setId("3");
+            Map<String, Object> properties = new LinkedHashMap<>();
+            properties.put("prop0", "value0");
+            Map<String, String> prop1 = new LinkedHashMap<>();
+            prop1.put("test", "a");
+            properties.put("prop1", prop1);
+            jsonFeature.setProperties(properties);
+            jsonFeature.setBbox(new BBox(102.0, 103.0, 0.0, 1));
+            jsonFeatureCollection.getFeatures().add(jsonFeature);
+        }
+
+        String expected = objectMapper.writeValueAsString(
+                objectMapper.readValue(fixture("fixtures/geojson1.json"), JsonFeatureCollection.class));
+        assertEquals(objectMapper.writeValueAsString(jsonFeatureCollection), expected);
+    }
+
     @Test
     public void testDeserialization() throws IOException {
         JsonFeatureCollection data = objectMapper.readValue(fixture("fixtures/geojson1.json"), JsonFeatureCollection.class);
@@ -57,7 +108,11 @@ public void testDeserialization() throws IOException {
         assertEquals(103.0, PointList.fromLineString((LineString) f2.getGeometry()).getLon(1), .1);
 
         JsonFeature f3 = data.getFeatures().get(2);
-        Assert.assertEquals("0.0,102.0,1.0,103.0", f3.getBBox().toString());
+        assertEquals(0.0, f3.getBBox().minLat, 0.0);
+        assertEquals(102.0, f3.getBBox().minLon, 0.0);
+        assertEquals(1.0, f3.getBBox().maxLat, 0.0);
+        assertEquals(103.0, f3.getBBox().maxLon, 0.0);
+
         assertEquals("a", ((Map) f3.getProperty("prop1")).get("test"));
     }
 
diff --git a/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java b/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
index 7f2bf49710..73f50ef9f7 100644
--- a/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
+++ b/web-api/src/test/java/com/graphhopper/util/InstructionListRepresentationTest.java
@@ -1,31 +1,22 @@
 package com.graphhopper.util;
 
-import com.fasterxml.jackson.core.JsonProcessingException;
 import com.fasterxml.jackson.databind.ObjectMapper;
-import org.junit.Rule;
+import com.graphhopper.jackson.Jackson;
 import org.junit.Test;
-import org.mockito.Mock;
-import org.mockito.junit.MockitoJUnit;
-import org.mockito.junit.MockitoRule;
 
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Locale;
 import java.util.Map;
 
-import static org.junit.Assert.*;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mockingDetails;
-import static org.mockito.Mockito.when;
+import static io.dropwizard.testing.FixtureHelpers.fixture;
+import static org.junit.Assert.assertEquals;
 
 public class InstructionListRepresentationTest {
 
-    @Mock
-    Translation usTR;
-
-    @Rule
-    public MockitoRule mockitoRule = MockitoJUnit.rule();
-
     @Test
-    public void testRoundaboutJsonIntegrity() {
-        when(usTR.tr("roundabout_exit_onto", 2, "streetname")).thenReturn("At roundabout, take exit 2 onto streetname");
+    public void testRoundaboutJsonIntegrity() throws IOException {
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
         InstructionList il = new InstructionList(usTR);
 
         PointList pl = new PointList();
@@ -39,28 +30,14 @@ public void testRoundaboutJsonIntegrity() {
                 .setExitNumber(2)
                 .setExited();
         il.add(instr);
-
-        Map<String, Object> json = il.createJson().get(0);
-        // assert that all information is present in map for JSON
-        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
-        assertEquals(-1, (Double) json.get("turn_angle"), 0.01);
-        assertEquals("2", json.get("exit_number").toString());
-        // assert that a valid JSON object can be written
-        assertNotNull(write(json));
+        assertEquals(objectMapper.readTree(fixture("fixtures/roundabout1.json")).toString(), objectMapper.valueToTree(il).toString());
     }
 
-    private String write(Map<String, Object> json) {
-        try {
-            return new ObjectMapper().writeValueAsString(json);
-        } catch (JsonProcessingException e) {
-            throw new RuntimeException(e);
-        }
-    }
 
     // Roundabout with unknown dir of rotation
     @Test
-    public void testRoundaboutJsonNaN() {
-        when(usTR.tr("roundabout_exit_onto", 2, "streetname")).thenReturn("At roundabout, take exit 2 onto streetname");
+    public void testRoundaboutJsonNaN() throws IOException {
+        ObjectMapper objectMapper = Jackson.newObjectMapper();
         InstructionList il = new InstructionList(usTR);
 
         PointList pl = new PointList();
@@ -73,13 +50,30 @@ public void testRoundaboutJsonNaN() {
                 .setExitNumber(2)
                 .setExited();
         il.add(instr);
-
-        Map<String, Object> json = il.createJson().get(0);
-        assertEquals("At roundabout, take exit 2 onto streetname", json.get("text").toString());
-        assertNull(json.get("turn_angle"));
-        // assert that a valid JSON object can be written
-        assertNotNull(write(json));
+        assertEquals(objectMapper.readTree(fixture("fixtures/roundabout2.json")).toString(), objectMapper.valueToTree(il).toString());
     }
 
+    private static Translation usTR = new Translation() {
+        @Override
+        public String tr(String key, Object... params) {
+            if (key.equals("roundabout_exit_onto"))
+                return "At roundabout, take exit 2 onto streetname";
+            return key;
+        }
+
+        @Override
+        public Map<String, String> asMap() {
+            return Collections.emptyMap();
+        }
 
+        @Override
+        public Locale getLocale() {
+            return Locale.US;
+        }
+
+        @Override
+        public String getLanguage() {
+            return "en";
+        }
+    };
 }
diff --git a/web-api/src/test/resources/fixtures/geojson1.json b/web-api/src/test/resources/fixtures/geojson1.json
index d951eddd08..492aaac9a1 100644
--- a/web-api/src/test/resources/fixtures/geojson1.json
+++ b/web-api/src/test/resources/fixtures/geojson1.json
@@ -27,7 +27,7 @@
         {
             "id": 3,
             "type": "Feature",
-            "bbox": [0.0, 1, 102.0, 103.0],
+            "bbox": [102.0, 0.0, 103.0, 1],
             "properties": {
                 "prop0": "value0",
                 "prop1": {
diff --git a/web-api/src/test/resources/fixtures/roundabout1.json b/web-api/src/test/resources/fixtures/roundabout1.json
new file mode 100644
index 0000000000..1502f85039
--- /dev/null
+++ b/web-api/src/test/resources/fixtures/roundabout1.json
@@ -0,0 +1,11 @@
+[ {
+    "exit_number" : 2,
+    "distance" : 0.0,
+    "sign" : 6,
+    "exited" : true,
+    "turn_angle" : -1.0,
+    "interval" : [ 0, 3 ],
+    "text" : "At roundabout, take exit 2 onto streetname",
+    "time" : 0,
+    "street_name" : "streetname"
+} ]
\ No newline at end of file
diff --git a/web-api/src/test/resources/fixtures/roundabout2.json b/web-api/src/test/resources/fixtures/roundabout2.json
new file mode 100644
index 0000000000..5139688ceb
--- /dev/null
+++ b/web-api/src/test/resources/fixtures/roundabout2.json
@@ -0,0 +1,10 @@
+[ {
+    "exit_number" : 2,
+    "distance" : 0.0,
+    "sign" : 6,
+    "exited" : true,
+    "interval" : [ 0, 3 ],
+    "text" : "At roundabout, take exit 2 onto streetname",
+    "time" : 0,
+    "street_name" : "streetname"
+} ]
\ No newline at end of file
diff --git a/web-bundle/pom.xml b/web-bundle/pom.xml
index e0d305d8f4..44c2fed1b7 100644
--- a/web-bundle/pom.xml
+++ b/web-bundle/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web-bundle</artifactId>
     <packaging>jar</packaging>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <name>GraphHopper Dropwizard Bundle</name>
     <description>Use the GraphHopper routing engine as a web-service</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -43,23 +43,23 @@
         <dependency>
             <groupId>javax.xml.ws</groupId>
             <artifactId>jaxws-api</artifactId>
-            <version>2.3.0</version>
+            <version>2.3.1</version>
         </dependency>
         <!-- required for dropwizard -->
         <dependency>
             <groupId>com.google.guava</groupId>
             <artifactId>guava</artifactId>
-            <version>21.0</version>
+            <version>${guava.version}</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-core</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-testing</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
             <scope>test</scope>
         </dependency>
 
@@ -73,7 +73,7 @@
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>directions-api-client</artifactId>
-            <version>0.10.0</version>
+            <version>${directions-api-client.version}</version>
             <scope>test</scope>
         </dependency>
 
@@ -84,7 +84,6 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
                 <configuration>
                     <source>1.8</source>
                     <target>1.8</target>
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
index ce9f5e0250..1d0a0b8d9d 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
@@ -27,17 +27,16 @@
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
 import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
-import com.fasterxml.jackson.databind.util.ISO8601DateFormat;
+import com.fasterxml.jackson.databind.util.StdDateFormat;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.http.health.GraphHopperHealthCheck;
 import com.graphhopper.http.health.GraphHopperStorageHealthCheck;
-import com.graphhopper.isochrone.algorithm.RasterHullBuilder;
+import com.graphhopper.isochrone.algorithm.DelaunayTriangulationIsolineBuilder;
 import com.graphhopper.jackson.GraphHopperModule;
 import com.graphhopper.reader.gtfs.GraphHopperGtfs;
 import com.graphhopper.reader.gtfs.GtfsStorage;
 import com.graphhopper.reader.gtfs.PtFlagEncoder;
-import com.graphhopper.reader.gtfs.RealtimeFeed;
 import com.graphhopper.resources.*;
 import com.graphhopper.routing.util.CarFlagEncoder;
 import com.graphhopper.routing.util.EncodingManager;
@@ -55,10 +54,7 @@
 import org.glassfish.hk2.utilities.binding.AbstractBinder;
 
 import javax.inject.Inject;
-import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.ext.WriterInterceptor;
-import javax.ws.rs.ext.WriterInterceptorContext;
-import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -146,23 +142,23 @@ public void dispose(Boolean instance) {
         }
     }
 
-    static class RasterHullBuilderFactory implements Factory<RasterHullBuilder> {
+    static class RasterHullBuilderFactory implements Factory<DelaunayTriangulationIsolineBuilder> {
 
-        RasterHullBuilder builder = new RasterHullBuilder();
+        DelaunayTriangulationIsolineBuilder builder = new DelaunayTriangulationIsolineBuilder();
 
         @Override
-        public RasterHullBuilder provide() {
+        public DelaunayTriangulationIsolineBuilder provide() {
             return builder;
         }
 
         @Override
-        public void dispose(RasterHullBuilder rasterHullBuilder) {
+        public void dispose(DelaunayTriangulationIsolineBuilder delaunayTriangulationIsolineBuilder) {
         }
     }
 
     @Override
     public void initialize(Bootstrap<?> bootstrap) {
-        bootstrap.getObjectMapper().setDateFormat(new ISO8601DateFormat());
+        bootstrap.getObjectMapper().setDateFormat(new StdDateFormat());
         bootstrap.getObjectMapper().registerModule(new JtsModule());
         bootstrap.getObjectMapper().registerModule(new GraphHopperModule());
         bootstrap.getObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);
@@ -212,29 +208,29 @@ private void runPtGraphHopper(CmdArgs configuration, Environment environment) {
         final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
         final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.get("graph.location", "target/tmp"));
         final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        final EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()), 8);
+        final EncodingManager encodingManager = new EncodingManager.Builder(configuration.getInt("graph.bytes_for_flags", 8)).add(ptFlagEncoder).add(new FootFlagEncoder()).add(new CarFlagEncoder()).build();
         final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
                 configuration.has("gtfs.file") ? Arrays.asList(configuration.get("gtfs.file", "").split(",")) : Collections.emptyList(),
                 configuration.has("datareader.file") ? Arrays.asList(configuration.get("datareader.file", "").split(",")) : Collections.emptyList());
         final TranslationMap translationMap = GraphHopperGtfs.createTranslationMap();
         final LocationIndex locationIndex = GraphHopperGtfs.createOrLoadIndex(ghDirectory, graphHopperStorage);
-        final GraphHopperAPI graphHopper = new GraphHopperGtfs(ptFlagEncoder, translationMap, graphHopperStorage, locationIndex, gtfsStorage, RealtimeFeed.empty(gtfsStorage));
         environment.jersey().register(new AbstractBinder() {
             @Override
             protected void configure() {
                 bind(configuration).to(CmdArgs.class);
-                bind(graphHopper).to(GraphHopperAPI.class);
                 bind(false).to(Boolean.class).named("hasElevation");
                 bind(locationIndex).to(LocationIndex.class);
                 bind(translationMap).to(TranslationMap.class);
                 bind(encodingManager).to(EncodingManager.class);
+                bind(ptFlagEncoder).to(PtFlagEncoder.class);
                 bind(graphHopperStorage).to(GraphHopperStorage.class);
-                bindFactory(RasterHullBuilderFactory.class).to(RasterHullBuilder.class);
+                bind(gtfsStorage).to(GtfsStorage.class);
+                bindFactory(RasterHullBuilderFactory.class).to(DelaunayTriangulationIsolineBuilder.class);
             }
         });
         environment.jersey().register(NearestResource.class);
-        environment.jersey().register(RouteResource.class);
-        environment.jersey().register(IsochroneResource.class);
+        environment.jersey().register(GraphHopperGtfs.class);
+        environment.jersey().register(new PtIsochroneResource(gtfsStorage, encodingManager, graphHopperStorage, locationIndex));
         environment.jersey().register(I18NResource.class);
         environment.jersey().register(InfoResource.class);
         // Say we only support pt, even though we now have several flag encoders. Yes, I know, we're almost there.
@@ -278,16 +274,19 @@ protected void configure() {
                 bindFactory(TranslationMapFactory.class).to(TranslationMap.class);
                 bindFactory(EncodingManagerFactory.class).to(EncodingManager.class);
                 bindFactory(GraphHopperStorageFactory.class).to(GraphHopperStorage.class);
-                bindFactory(RasterHullBuilderFactory.class).to(RasterHullBuilder.class);
+                bindFactory(RasterHullBuilderFactory.class).to(DelaunayTriangulationIsolineBuilder.class);
             }
         });
 
         if (configuration.getBool("web.change_graph.enabled", false)) {
             environment.jersey().register(ChangeGraphResource.class);
         }
+
+        environment.jersey().register(MVTResource.class);
         environment.jersey().register(NearestResource.class);
         environment.jersey().register(RouteResource.class);
         environment.jersey().register(IsochroneResource.class);
+        environment.jersey().register(SPTResource.class);
         environment.jersey().register(I18NResource.class);
         environment.jersey().register(InfoResource.class);
         environment.healthChecks().register("graphhopper", new GraphHopperHealthCheck(graphHopperManaged.getGraphHopper()));
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
index 03bb4fbb73..267b9d3052 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperManaged.java
@@ -18,6 +18,7 @@
 
 package com.graphhopper.http;
 
+import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.graphhopper.GraphHopper;
 import com.graphhopper.json.geo.JsonFeatureCollection;
@@ -44,10 +45,12 @@
     private final GraphHopper graphHopper;
 
     public GraphHopperManaged(CmdArgs configuration, ObjectMapper objectMapper) {
+        ObjectMapper localObjectMapper = objectMapper.copy();
+        localObjectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
         String splitAreaLocation = configuration.get(Parameters.Landmark.PREPARE + "split_area_location", "");
         JsonFeatureCollection landmarkSplittingFeatureCollection;
         try (Reader reader = splitAreaLocation.isEmpty() ? new InputStreamReader(LandmarkStorage.class.getResource("map.geo.json").openStream(), UTF_CS) : new InputStreamReader(new FileInputStream(splitAreaLocation), UTF_CS)) {
-            landmarkSplittingFeatureCollection = objectMapper.readValue(reader, JsonFeatureCollection.class);
+            landmarkSplittingFeatureCollection = localObjectMapper.readValue(reader, JsonFeatureCollection.class);
         } catch (IOException e1) {
             logger.error("Problem while reading border map GeoJSON. Skipping this.", e1);
             landmarkSplittingFeatureCollection = null;
@@ -57,7 +60,7 @@ public GraphHopperManaged(CmdArgs configuration, ObjectMapper objectMapper) {
         if (!spatialRuleLocation.isEmpty()) {
             final BBox maxBounds = BBox.parseBBoxString(configuration.get("spatial_rules.max_bbox", "-180, 180, -90, 90"));
             try (final InputStreamReader reader = new InputStreamReader(new FileInputStream(spatialRuleLocation), UTF_CS)) {
-                JsonFeatureCollection jsonFeatureCollection = objectMapper.readValue(reader, JsonFeatureCollection.class);
+                JsonFeatureCollection jsonFeatureCollection = localObjectMapper.readValue(reader, JsonFeatureCollection.class);
                 SpatialRuleLookupHelper.buildAndInjectSpatialRuleIntoGH(graphHopper, maxBounds, jsonFeatureCollection);
             } catch (IOException e) {
                 throw new RuntimeException(e);
@@ -71,7 +74,7 @@ public void start() {
         graphHopper.importOrLoad();
         logger.info("loaded graph at:" + graphHopper.getGraphHopperLocation()
                 + ", data_reader_file:" + graphHopper.getDataReaderFile()
-                + ", flag_encoders:" + graphHopper.getEncodingManager()
+                + ", encoded values:" + graphHopper.getEncodingManager().toEncodedValuesAsString()
                 + ", " + graphHopper.getGraphHopperStorage().toDetailsString());
     }
 
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java b/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
index 9f7dbbc725..dcf060a784 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
@@ -1,6 +1,6 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
  *  GraphHopper GmbH licenses this file to you under the Apache License,
@@ -65,7 +65,8 @@ public InfoResource(GraphHopperStorage storage, @Named("hasElevation") Boolean h
     @GET
     public Info getInfo() {
         final Info info = new Info();
-        info.bbox = storage.getBounds();
+        // use bbox always without elevation (for backward compatibility)
+        info.bbox = new BBox(storage.getBounds().minLon, storage.getBounds().maxLon, storage.getBounds().minLat, storage.getBounds().maxLat);
         info.supported_vehicles = storage.getEncodingManager().toString().split(",");
         for (String v : info.supported_vehicles) {
             Info.PerVehicle perVehicleJson = new Info.PerVehicle();
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
index 4281e8fe46..f0aeb8f984 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
@@ -3,8 +3,10 @@
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
 import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.graphhopper.GraphHopper;
+import com.graphhopper.http.WebHelper;
+import com.graphhopper.isochrone.algorithm.DelaunayTriangulationIsolineBuilder;
 import com.graphhopper.isochrone.algorithm.Isochrone;
-import com.graphhopper.isochrone.algorithm.RasterHullBuilder;
+import com.graphhopper.json.geo.JsonFeature;
 import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.Weighting;
@@ -13,6 +15,8 @@
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.GeometryFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -31,17 +35,18 @@
 @Path("isochrone")
 public class IsochroneResource {
 
-    private static final Logger logger = LoggerFactory.getLogger(RouteResource.class);
+    private static final Logger logger = LoggerFactory.getLogger(IsochroneResource.class);
 
     private final GraphHopper graphHopper;
     private final EncodingManager encodingManager;
-    private final RasterHullBuilder rasterHullBuilder;
+    private final DelaunayTriangulationIsolineBuilder delaunayTriangulationIsolineBuilder;
+    private final GeometryFactory geometryFactory = new GeometryFactory();
 
     @Inject
-    public IsochroneResource(GraphHopper graphHopper, EncodingManager encodingManager, RasterHullBuilder rasterHullBuilder) {
+    public IsochroneResource(GraphHopper graphHopper, EncodingManager encodingManager, DelaunayTriangulationIsolineBuilder delaunayTriangulationIsolineBuilder) {
         this.graphHopper = graphHopper;
         this.encodingManager = encodingManager;
-        this.rasterHullBuilder = rasterHullBuilder;
+        this.delaunayTriangulationIsolineBuilder = delaunayTriangulationIsolineBuilder;
     }
 
     @GET
@@ -50,14 +55,15 @@ public Response doGet(
             @Context HttpServletRequest httpReq,
             @Context UriInfo uriInfo,
             @QueryParam("vehicle") @DefaultValue("car") String vehicle,
-            @QueryParam("buckets") @DefaultValue("1") int buckets,
+            @QueryParam("buckets") @DefaultValue("1") int nBuckets,
             @QueryParam("reverse_flow") @DefaultValue("false") boolean reverseFlow,
             @QueryParam("point") GHPoint point,
             @QueryParam("result") @DefaultValue("polygon") String resultStr,
             @QueryParam("time_limit") @DefaultValue("600") long timeLimitInSeconds,
-            @QueryParam("distance_limit") @DefaultValue("-1") double distanceInMeter) {
+            @QueryParam("distance_limit") @DefaultValue("-1") double distanceInMeter,
+            @QueryParam("type") @DefaultValue("json") String respType) {
 
-        if (buckets > 20 || buckets < 1)
+        if (nBuckets > 20 || nBuckets < 1)
             throw new IllegalArgumentException("Number of buckets has to be in the range [1, 20]");
 
         if (point == null)
@@ -65,8 +71,12 @@ public Response doGet(
 
         StopWatch sw = new StopWatch().start();
 
-        if (!encodingManager.supports(vehicle))
+        if (!encodingManager.hasEncoder(vehicle))
             throw new IllegalArgumentException("vehicle not supported:" + vehicle);
+        
+        if (respType != null && !respType.equalsIgnoreCase("json") && !respType.equalsIgnoreCase("geojson")) {
+            throw new IllegalArgumentException("Format not supported:" + respType);
+        }
 
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
         EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
@@ -86,85 +96,58 @@ public Response doGet(
         Isochrone isochrone = new Isochrone(queryGraph, weighting, reverseFlow);
 
         if (distanceInMeter > 0) {
-            double maxMeter = 50 * 1000;
-            if (distanceInMeter > maxMeter)
-                throw new IllegalArgumentException("Specify a limit of less than " + maxMeter / 1000f + "km");
-            if (buckets > (distanceInMeter / 500))
-                throw new IllegalArgumentException("Specify buckets less than the number of explored kilometers");
-
             isochrone.setDistanceLimit(distanceInMeter);
         } else {
-
-            long maxSeconds = 80 * 60;
-            if (timeLimitInSeconds > maxSeconds)
-                throw new IllegalArgumentException("Specify a limit of less than " + maxSeconds + " seconds");
-            if (buckets > (timeLimitInSeconds / 60))
-                throw new IllegalArgumentException("Specify buckets less than the number of explored minutes");
-
             isochrone.setTimeLimit(timeLimitInSeconds);
         }
 
-        List<List<Double[]>> list = isochrone.searchGPS(qr.getClosestNode(), buckets);
-        if (isochrone.getVisitedNodes() > graphHopper.getMaxVisitedNodes() / 5) {
-            throw new IllegalArgumentException("Server side reset: too many junction nodes would have to explored (" + isochrone.getVisitedNodes() + "). Let us know if you need this increased.");
-        }
-
-        int counter = 0;
-        for (List<Double[]> tmp : list) {
-            if (tmp.size() < 2) {
-                throw new IllegalArgumentException("Too few points found for bucket " + counter + ". "
-                        + "Please try a different 'point', a smaller 'buckets' count or a larger 'time_limit'. "
-                        + "And let us know if you think this is a bug!");
+        if ("polygon".equalsIgnoreCase(resultStr)) {
+            List<List<Coordinate>> buckets = isochrone.searchGPS(qr.getClosestNode(), nBuckets);
+            if (isochrone.getVisitedNodes() > graphHopper.getMaxVisitedNodes() / 5) {
+                throw new IllegalArgumentException("Server side reset: too many junction nodes would have to explored (" + isochrone.getVisitedNodes() + "). Let us know if you need this increased.");
             }
-            counter++;
-        }
 
-        Object calcRes;
-        if ("pointlist".equalsIgnoreCase(resultStr)) {
-            calcRes = list;
-
-        } else if ("polygon".equalsIgnoreCase(resultStr)) {
-            list = rasterHullBuilder.calcList(list, list.size() - 1);
-
-            ArrayList polyList = new ArrayList();
-            int index = 0;
-            for (List<Double[]> polygon : list) {
-                HashMap<String, Object> geoJsonMap = new HashMap<>();
-                HashMap<String, Object> propMap = new HashMap<>();
-                HashMap<String, Object> geometryMap = new HashMap<>();
-                polyList.add(geoJsonMap);
-                geoJsonMap.put("type", "Feature");
-                geoJsonMap.put("properties", propMap);
-                geoJsonMap.put("geometry", geometryMap);
-
-                propMap.put("bucket", index);
-                geometryMap.put("type", "Polygon");
-                // we have no holes => embed in yet another list
-                geometryMap.put("coordinates", Collections.singletonList(polygon));
-                index++;
+            int counter = 0;
+            for (List<Coordinate> bucket : buckets) {
+                if (bucket.size() < 2) {
+                    throw new IllegalArgumentException("Too few points found for bucket " + counter + ". "
+                            + "Please try a different 'point', a smaller 'buckets' count or a larger 'time_limit'. "
+                            + "And let us know if you think this is a bug!");
+                }
+                counter++;
             }
-            calcRes = polyList;
+            ArrayList<JsonFeature> features = new ArrayList<>();
+            List<Coordinate[]> polygonShells = delaunayTriangulationIsolineBuilder.calcList(buckets, buckets.size() - 1);
+            for (Coordinate[] polygonShell : polygonShells) {
+                JsonFeature feature = new JsonFeature();
+                HashMap<String, Object> properties = new HashMap<>();
+                properties.put("bucket", features.size());
+                if (respType.equalsIgnoreCase("geojson")) {
+                    properties.put("copyrights", WebHelper.COPYRIGHTS);
+                }
+                feature.setProperties(properties);
+                feature.setGeometry(geometryFactory.createPolygon(polygonShell));
+                features.add(feature);
+            }
+            ObjectNode json = JsonNodeFactory.instance.objectNode();
+            
+            ObjectNode finalJson = null;
+            if (respType.equalsIgnoreCase("geojson")) {
+            	json.put("type", "FeatureCollection");
+                json.putPOJO("features", features);
+                finalJson = json;
+            } else {
+            	json.putPOJO("polygons", features);
+            	finalJson = WebHelper.jsonResponsePutInfo(json, sw.getSeconds());
+            }
+            
+            sw.stop();
+            logger.info("took: " + sw.getSeconds() + ", visited nodes:" + isochrone.getVisitedNodes() + ", " + uriInfo.getQueryParameters());
+            return Response.ok(finalJson).header("X-GH-Took", "" + sw.getSeconds() * 1000).
+                    build();
+
         } else {
             throw new IllegalArgumentException("type not supported:" + resultStr);
         }
-
-        logger.info("took: " + sw.getSeconds() + ", visited nodes:" + isochrone.getVisitedNodes() + ", " + uriInfo.getQueryParameters());
-        return Response.fromResponse(jsonSuccessResponse(calcRes, sw.stop().getSeconds()))
-                .header("X-GH-Took", "" + sw.stop().getSeconds() * 1000)
-                .build();
-    }
-
-    private Response jsonSuccessResponse(Object result, float took) {
-        ObjectNode json = JsonNodeFactory.instance.objectNode();
-        json.putPOJO("polygons", result);
-        // If you replace GraphHopper with your own brand name, this is fine.
-        // Still it would be highly appreciated if you mention us in your about page!
-        final ObjectNode info = json.putObject("info");
-        info.putArray("copyrights")
-                .add("GraphHopper")
-                .add("OpenStreetMap contributors");
-        info.put("took", Math.round(took * 1000));
-
-        return Response.ok(json).build();
     }
-}
+}
\ No newline at end of file
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/MVTResource.java b/web-bundle/src/main/java/com/graphhopper/resources/MVTResource.java
new file mode 100644
index 0000000000..a060ef5b5b
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/resources/MVTResource.java
@@ -0,0 +1,167 @@
+package com.graphhopper.resources;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.LocationIndexTree;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.BBox;
+import com.wdtinc.mapbox_vector_tile.VectorTile;
+import com.wdtinc.mapbox_vector_tile.adapt.jts.IGeometryFilter;
+import com.wdtinc.mapbox_vector_tile.adapt.jts.JtsAdapter;
+import com.wdtinc.mapbox_vector_tile.adapt.jts.TileGeomResult;
+import com.wdtinc.mapbox_vector_tile.adapt.jts.UserDataKeyValueMapConverter;
+import com.wdtinc.mapbox_vector_tile.build.MvtLayerBuild;
+import com.wdtinc.mapbox_vector_tile.build.MvtLayerParams;
+import com.wdtinc.mapbox_vector_tile.build.MvtLayerProps;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.Envelope;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.LineString;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.inject.Inject;
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.*;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.UriInfo;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
+
+@Path("mvt")
+public class MVTResource {
+
+    private static final Logger logger = LoggerFactory.getLogger(MVTResource.class);
+    private static final MediaType PBF = new MediaType("application", "x-protobuf");
+    private final GraphHopper graphHopper;
+    private final EncodingManager encodingManager;
+
+    @Inject
+    public MVTResource(GraphHopper graphHopper, EncodingManager encodingManager) {
+        this.graphHopper = graphHopper;
+        this.encodingManager = encodingManager;
+    }
+
+    @GET
+    @Path("{z}/{x}/{y}.mvt")
+    @Produces("application/x-protobuf")
+    public Response doGetXyz(
+            @Context HttpServletRequest httpReq,
+            @Context UriInfo uriInfo,
+            @PathParam("z") int zInfo,
+            @PathParam("x") int xInfo,
+            @PathParam("y") int yInfo,
+            @QueryParam(Parameters.Details.PATH_DETAILS) List<String> pathDetails) {
+
+        if (zInfo <= 9) {
+            VectorTile.Tile.Builder mvtBuilder = VectorTile.Tile.newBuilder();
+            return Response.fromResponse(Response.ok(mvtBuilder.build().toByteArray(), PBF).build())
+                    .header("X-GH-Took", "0")
+                    .build();
+        }
+
+        StopWatch totalSW = new StopWatch().start();
+        Coordinate nw = num2deg(xInfo, yInfo, zInfo);
+        Coordinate se = num2deg(xInfo + 1, yInfo + 1, zInfo);
+        LocationIndexTree locationIndex = (LocationIndexTree) graphHopper.getLocationIndex();
+        final NodeAccess na = graphHopper.getGraphHopperStorage().getNodeAccess();
+        EdgeExplorer edgeExplorer = graphHopper.getGraphHopperStorage().createEdgeExplorer(DefaultEdgeFilter.ALL_EDGES);
+        BBox bbox = new BBox(nw.x, se.x, se.y, nw.y);
+        if (!bbox.isValid())
+            throw new IllegalStateException("Invalid bbox " + bbox);
+
+        final GeometryFactory geometryFactory = new GeometryFactory();
+        VectorTile.Tile.Builder mvtBuilder = VectorTile.Tile.newBuilder();
+        final IGeometryFilter acceptAllGeomFilter = geometry -> true;
+        final Envelope tileEnvelope = new Envelope(se, nw);
+        final MvtLayerParams layerParams = new MvtLayerParams(256, 4096);
+        final UserDataKeyValueMapConverter converter = new UserDataKeyValueMapConverter();
+        if (!encodingManager.hasEncodedValue(RoadClass.KEY))
+            throw new IllegalStateException("You need to configure GraphHopper to store road_class, e.g. graph.encoded_values: road_class,max_speed,... ");
+
+        final EnumEncodedValue<RoadClass> roadClassEnc = encodingManager.getEnumEncodedValue(RoadClass.KEY, RoadClass.class);
+        final AtomicInteger edgeCounter = new AtomicInteger(0);
+        // in toFeatures addTags of the converter is called and layerProps is filled with keys&values => those need to be stored in the layerBuilder
+        // otherwise the decoding won't be successful and "undefined":"undefined" instead of "speed": 30 is the result
+        final MvtLayerProps layerProps = new MvtLayerProps();
+        final VectorTile.Tile.Layer.Builder layerBuilder = MvtLayerBuild.newLayerBuilder("roads", layerParams);
+
+        locationIndex.query(bbox, new LocationIndexTree.EdgeVisitor(edgeExplorer) {
+            @Override
+            public void onEdge(EdgeIteratorState edge, int nodeA, int nodeB) {
+                LineString lineString;
+                RoadClass rc = edge.get(roadClassEnc);
+                if (zInfo >= 14) {
+                    PointList pl = edge.fetchWayGeometry(3);
+                    lineString = pl.toLineString(false);
+                } else if (rc == RoadClass.MOTORWAY
+                        || zInfo > 10 && (rc == RoadClass.PRIMARY || rc == RoadClass.TRUNK)
+                        || zInfo > 11 && (rc == RoadClass.SECONDARY)
+                        || zInfo > 12) {
+                    double lat = na.getLatitude(nodeA);
+                    double lon = na.getLongitude(nodeA);
+                    double toLat = na.getLatitude(nodeB);
+                    double toLon = na.getLongitude(nodeB);
+                    lineString = geometryFactory.createLineString(new Coordinate[]{new Coordinate(lon, lat), new Coordinate(toLon, toLat)});
+                } else {
+                    // skip edge for certain zoom
+                    return;
+                }
+
+                edgeCounter.incrementAndGet();
+                Map<String, Object> map = new HashMap<>(2);
+                map.put("name", edge.getName());
+                for (String str : pathDetails) {
+                    // how to indicate an erroneous parameter?
+                    if (str.contains(",") || !encodingManager.hasEncodedValue(str))
+                        continue;
+
+                    EncodedValue ev = encodingManager.getEncodedValue(str, EncodedValue.class);
+                    if (ev instanceof EnumEncodedValue)
+                        map.put(ev.getName(), edge.get((EnumEncodedValue) ev).toString());
+                    else if (ev instanceof DecimalEncodedValue)
+                        map.put(ev.getName(), edge.get((DecimalEncodedValue) ev));
+                    else if (ev instanceof BooleanEncodedValue)
+                        map.put(ev.getName(), edge.get((BooleanEncodedValue) ev));
+                    else if (ev instanceof IntEncodedValue)
+                        map.put(ev.getName(), edge.get((IntEncodedValue) ev));
+                }
+
+                lineString.setUserData(map);
+
+                // doing some AffineTransformation
+                TileGeomResult tileGeom = JtsAdapter.createTileGeom(lineString, tileEnvelope, geometryFactory, layerParams, acceptAllGeomFilter);
+                List<VectorTile.Tile.Feature> features = JtsAdapter.toFeatures(tileGeom.mvtGeoms, layerProps, converter);
+                layerBuilder.addAllFeatures(features);
+            }
+
+            @Override
+            public void onTile(BBox bbox, int depth) {
+            }
+        });
+
+        MvtLayerBuild.writeProps(layerBuilder, layerProps);
+        mvtBuilder.addLayers(layerBuilder.build());
+        byte[] bytes = mvtBuilder.build().toByteArray();
+        totalSW.stop();
+        logger.debug("took: " + totalSW.getSeconds() + ", edges:" + edgeCounter.get());
+        return Response.ok(bytes, PBF).header("X-GH-Took", "" + totalSW.getSeconds() * 1000)
+                .build();
+    }
+
+    Coordinate num2deg(int xInfo, int yInfo, int zoom) {
+        double n = Math.pow(2, zoom);
+        double lonDeg = xInfo / n * 360.0 - 180.0;
+        // unfortunately latitude numbers goes from north to south
+        double latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * yInfo / n)));
+        double latDeg = Math.toDegrees(latRad);
+        return new Coordinate(lonDeg, latDeg);
+    }
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
new file mode 100644
index 0000000000..48f6ef20c4
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/resources/PtIsochroneResource.java
@@ -0,0 +1,212 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.resources;
+
+import com.graphhopper.http.WebHelper;
+import com.graphhopper.isochrone.algorithm.ContourBuilder;
+import com.graphhopper.json.geo.JsonFeature;
+import com.graphhopper.reader.gtfs.*;
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.Parameters;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
+import org.locationtech.jts.geom.*;
+import org.locationtech.jts.triangulate.ConformingDelaunayTriangulator;
+import org.locationtech.jts.triangulate.ConstraintVertex;
+import org.locationtech.jts.triangulate.DelaunayTriangulationBuilder;
+import org.locationtech.jts.triangulate.quadedge.QuadEdge;
+import org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision;
+import org.locationtech.jts.triangulate.quadedge.Vertex;
+
+import javax.ws.rs.*;
+import javax.ws.rs.core.MediaType;
+import java.time.Instant;
+import java.util.*;
+import java.util.function.Function;
+
+@Path("isochrone")
+public class PtIsochroneResource {
+
+    private static final double JTS_TOLERANCE = 0.00001;
+
+    private GtfsStorage gtfsStorage;
+    private EncodingManager encodingManager;
+    private GraphHopperStorage graphHopperStorage;
+    private LocationIndex locationIndex;
+
+    private final Function<Label, Double> z = label -> (double) label.currentTime;
+
+    public PtIsochroneResource(GtfsStorage gtfsStorage, EncodingManager encodingManager, GraphHopperStorage graphHopperStorage, LocationIndex locationIndex) {
+        this.gtfsStorage = gtfsStorage;
+        this.encodingManager = encodingManager;
+        this.graphHopperStorage = graphHopperStorage;
+        this.locationIndex = locationIndex;
+    }
+
+    public static class Response {
+        public static class Info {
+            public List<String> copyrights = new ArrayList<>();
+        }
+
+        public List<JsonFeature> polygons = new ArrayList<>();
+        public Info info = new Info();
+    }
+
+    @GET
+    @Produces({MediaType.APPLICATION_JSON})
+    public Response doGet(
+            @QueryParam("point") GHPoint source,
+            @QueryParam("time_limit") @DefaultValue("600") long seconds,
+            @QueryParam("reverse_flow") @DefaultValue("false") boolean reverseFlow,
+            @QueryParam(Parameters.PT.EARLIEST_DEPARTURE_TIME) String departureTimeString,
+            @QueryParam(Parameters.PT.BLOCKED_ROUTE_TYPES) @DefaultValue("0") int blockedRouteTypes,
+            @QueryParam("result") @DefaultValue("multipolygon") String format) {
+        Instant initialTime;
+        try {
+            initialTime = Instant.parse(departureTimeString);
+        } catch (Exception e) {
+            throw new IllegalArgumentException(String.format(Locale.ROOT, "Illegal value for required parameter %s: [%s]", Parameters.PT.EARLIEST_DEPARTURE_TIME, departureTimeString));
+        }
+
+        double targetZ = initialTime.toEpochMilli() + seconds * 1000;
+
+        GeometryFactory geometryFactory = new GeometryFactory();
+        QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
+        final EdgeFilter filter = DefaultEdgeFilter.allEdges(graphHopperStorage.getEncodingManager().getEncoder("foot"));
+        QueryResult queryResult = locationIndex.findClosest(source.lat, source.lon, filter);
+        queryGraph.lookup(Collections.singletonList(queryResult));
+        if (!queryResult.isValid()) {
+            throw new IllegalArgumentException("Cannot find point: " + source);
+        }
+
+        PtFlagEncoder ptFlagEncoder = (PtFlagEncoder) encodingManager.getEncoder("pt");
+        GraphExplorer graphExplorer = new GraphExplorer(queryGraph, new FastestWeighting(encodingManager.getEncoder("foot")), ptFlagEncoder, gtfsStorage, RealtimeFeed.empty(gtfsStorage), reverseFlow, false, 5.0);
+        MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, ptFlagEncoder, reverseFlow, Double.MAX_VALUE, false, false, false, 1000000, Collections.emptyList());
+
+        Map<Coordinate, Double> z1 = new HashMap<>();
+        NodeAccess nodeAccess = queryGraph.getNodeAccess();
+
+        MultiCriteriaLabelSetting.SPTVisitor sptVisitor = nodeLabel -> {
+            Coordinate nodeCoordinate = new Coordinate(nodeAccess.getLongitude(nodeLabel.adjNode), nodeAccess.getLatitude(nodeLabel.adjNode));
+            z1.merge(nodeCoordinate, this.z.apply(nodeLabel), Math::min);
+        };
+
+        if (format.equals("multipoint")) {
+            router.calcLabels(queryResult.getClosestNode(), -1, initialTime, blockedRouteTypes, sptVisitor, label -> label.currentTime <= targetZ);
+            MultiPoint exploredPoints = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
+            return wrap(exploredPoints);
+        } else {
+            router.calcLabelsAndNeighbors(queryResult.getClosestNode(), -1, initialTime, blockedRouteTypes, sptVisitor, label -> label.currentTime <= targetZ);
+            MultiPoint exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
+
+            // Get at least all nodes within our bounding box (I think convex hull would be enough.)
+            // I think then we should have all possible encroaching points. (Proof needed.)
+            locationIndex.query(BBox.fromEnvelope(exploredPointsAndNeighbors.getEnvelopeInternal()), new LocationIndex.Visitor() {
+                @Override
+                public void onNode(int nodeId) {
+                    Coordinate nodeCoordinate = new Coordinate(nodeAccess.getLongitude(nodeId), nodeAccess.getLatitude(nodeId));
+                    z1.merge(nodeCoordinate, Double.MAX_VALUE, Math::min);
+                }
+            });
+            exploredPointsAndNeighbors = geometryFactory.createMultiPointFromCoords(z1.keySet().toArray(new Coordinate[0]));
+
+            CoordinateList siteCoords = DelaunayTriangulationBuilder.extractUniqueCoordinates(exploredPointsAndNeighbors);
+            List<ConstraintVertex> constraintVertices = new ArrayList<>();
+            for (Object siteCoord : siteCoords) {
+                Coordinate coord = (Coordinate) siteCoord;
+                constraintVertices.add(new ConstraintVertex(coord));
+            }
+
+            ConformingDelaunayTriangulator cdt = new ConformingDelaunayTriangulator(constraintVertices, JTS_TOLERANCE);
+            cdt.setConstraints(new ArrayList(), new ArrayList());
+            cdt.formInitialDelaunay();
+
+            QuadEdgeSubdivision tin = cdt.getSubdivision();
+
+            for (Vertex vertex : (Collection<Vertex>) tin.getVertices(true)) {
+                if (tin.isFrameVertex(vertex)) {
+                    vertex.setZ(Double.MAX_VALUE);
+                } else {
+                    Double aDouble = z1.get(vertex.getCoordinate());
+                    if (aDouble != null) {
+                        vertex.setZ(aDouble);
+                    } else {
+                        vertex.setZ(Double.MAX_VALUE);
+                    }
+                }
+            }
+
+            ContourBuilder contourBuilder = new ContourBuilder(tin);
+            MultiPolygon isoline = contourBuilder.computeIsoline(targetZ);
+
+            // debugging tool
+            if (format.equals("triangulation")) {
+                Response response = new Response();
+                for (Vertex vertex : (Collection<Vertex>) tin.getVertices(true)) {
+                    JsonFeature feature = new JsonFeature();
+                    feature.setGeometry(geometryFactory.createPoint(vertex.getCoordinate()));
+                    HashMap<String, Object> properties = new HashMap<>();
+                    properties.put("z", vertex.getZ());
+                    feature.setProperties(properties);
+                    response.polygons.add(feature);
+                }
+                for (QuadEdge edge : (Collection<QuadEdge>) tin.getPrimaryEdges(false)) {
+                    JsonFeature feature = new JsonFeature();
+                    feature.setGeometry(edge.toLineSegment().toGeometry(geometryFactory));
+                    HashMap<String, Object> properties = new HashMap<>();
+                    feature.setProperties(properties);
+                    response.polygons.add(feature);
+                }
+                JsonFeature feature = new JsonFeature();
+                feature.setGeometry(isoline);
+                HashMap<String, Object> properties = new HashMap<>();
+                properties.put("z", targetZ);
+                feature.setProperties(properties);
+                response.polygons.add(feature);
+                response.info.copyrights.addAll(WebHelper.COPYRIGHTS);
+                return response;
+            } else {
+                return wrap(isoline);
+            }
+        }
+
+    }
+
+    private Response wrap(Geometry isoline) {
+        JsonFeature feature = new JsonFeature();
+        feature.setGeometry(isoline);
+        HashMap<String, Object> properties = new HashMap<>();
+        properties.put("bucket", 0);
+        feature.setProperties(properties);
+
+        Response response = new Response();
+        response.polygons.add(feature);
+        response.info.copyrights.addAll(WebHelper.COPYRIGHTS);
+        return response;
+    }
+
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index 517bbb51ee..9ae528bac2 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -22,12 +22,11 @@
 import com.graphhopper.GraphHopperAPI;
 import com.graphhopper.MultiException;
 import com.graphhopper.http.WebHelper;
-import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.Constants;
-import com.graphhopper.util.Helper;
-import com.graphhopper.util.Parameters;
+import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.StopWatch;
+import com.graphhopper.util.gpx.GpxFromInstructions;
 import com.graphhopper.util.shapes.GHPoint;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -43,6 +42,7 @@
 import java.util.List;
 import java.util.Map;
 
+import static com.graphhopper.util.Parameters.Details.PATH_DETAILS;
 import static com.graphhopper.util.Parameters.Routing.*;
 
 /**
@@ -83,8 +83,9 @@ public Response doGet(
             @QueryParam("weighting") @DefaultValue("fastest") String weighting,
             @QueryParam("algorithm") @DefaultValue("") String algoStr,
             @QueryParam("locale") @DefaultValue("en") String localeStr,
-            @QueryParam(Parameters.Routing.POINT_HINT) List<String> pointHints,
-            @QueryParam(Parameters.DETAILS.PATH_DETAILS) List<String> pathDetails,
+            @QueryParam(POINT_HINT) List<String> pointHints,
+            @QueryParam(SNAP_PREVENTION) List<String> snapPreventions,
+            @QueryParam(PATH_DETAILS) List<String> pathDetails,
             @QueryParam("heading") List<Double> favoredHeadings,
             @QueryParam("gpx.route") @DefaultValue("true") boolean withRoute /* default to false for the route part in next API version, see #437 */,
             @QueryParam("gpx.track") @DefaultValue("true") boolean withTrack,
@@ -126,6 +127,7 @@ public Response doGet(
                 setAlgorithm(algoStr).
                 setLocale(localeStr).
                 setPointHints(pointHints).
+                setSnapPreventions(snapPreventions).
                 setPathDetails(pathDetails).
                 getHints().
                 put(CALC_POINTS, calcPoints).
@@ -168,7 +170,8 @@ public Response doGet(
         }
 
         long time = timeString != null ? Long.parseLong(timeString) : System.currentTimeMillis();
-        return Response.ok(ghRsp.getBest().getInstructions().createGPX(trackName, time, enableElevation, withRoute, withTrack, withWayPoints, version), "application/gpx+xml").
+        InstructionList instructions = ghRsp.getBest().getInstructions();
+        return Response.ok(GpxFromInstructions.createGPX(instructions, trackName, time, enableElevation, withRoute, withTrack, withWayPoints, version, instructions.getTr()), "application/gpx+xml").
                 header("Content-Disposition", "attachment;filename=" + "GraphHopper.gpx");
     }
 
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java b/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java
new file mode 100644
index 0000000000..507d8da0fe
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/resources/SPTResource.java
@@ -0,0 +1,207 @@
+package com.graphhopper.resources;
+
+import com.graphhopper.GraphHopper;
+import com.graphhopper.isochrone.algorithm.Isochrone;
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.*;
+import com.graphhopper.util.shapes.GHPoint;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.inject.Inject;
+import javax.servlet.http.HttpServletRequest;
+import javax.ws.rs.*;
+import javax.ws.rs.core.Context;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.StreamingOutput;
+import javax.ws.rs.core.UriInfo;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.util.*;
+
+/**
+ * This resource provides the entire shortest path tree as response. In a simple CSV format discussed at #1577.
+ */
+@Path("spt")
+public class SPTResource {
+
+    private static final Logger logger = LoggerFactory.getLogger(SPTResource.class);
+
+    private final GraphHopper graphHopper;
+    private final EncodingManager encodingManager;
+
+    @Inject
+    public SPTResource(GraphHopper graphHopper, EncodingManager encodingManager) {
+        this.graphHopper = graphHopper;
+        this.encodingManager = encodingManager;
+    }
+
+    @GET
+    @Produces("text/csv")
+    public Response doGet(
+            @Context HttpServletRequest httpReq,
+            @Context UriInfo uriInfo,
+            @QueryParam("vehicle") @DefaultValue("car") String vehicle,
+            @QueryParam("reverse_flow") @DefaultValue("false") boolean reverseFlow,
+            @QueryParam("point") GHPoint point,
+            @QueryParam("columns") String columnsParam,
+            @QueryParam("time_limit") @DefaultValue("600") long timeLimitInSeconds,
+            @QueryParam("distance_limit") @DefaultValue("-1") double distanceInMeter) {
+
+        if (point == null)
+            throw new IllegalArgumentException("point parameter cannot be null");
+
+        StopWatch sw = new StopWatch().start();
+
+        if (!encodingManager.hasEncoder(vehicle))
+            throw new IllegalArgumentException("vehicle not supported:" + vehicle);
+
+        FlagEncoder encoder = encodingManager.getEncoder(vehicle);
+        EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
+        LocationIndex locationIndex = graphHopper.getLocationIndex();
+        QueryResult qr = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
+        if (!qr.isValid())
+            throw new IllegalArgumentException("Point not found:" + point);
+
+        Graph graph = graphHopper.getGraphHopperStorage();
+        QueryGraph queryGraph = new QueryGraph(graph);
+        queryGraph.lookup(Collections.singletonList(qr));
+
+        HintsMap hintsMap = new HintsMap();
+        RouteResource.initHints(hintsMap, uriInfo.getQueryParameters());
+
+        Weighting weighting = graphHopper.createWeighting(hintsMap, encoder, graph);
+        Isochrone isochrone = new Isochrone(queryGraph, weighting, reverseFlow);
+
+        if (distanceInMeter > 0) {
+            isochrone.setDistanceLimit(distanceInMeter);
+        } else {
+            isochrone.setTimeLimit(timeLimitInSeconds);
+        }
+
+        final String COL_SEP = ",", LINE_SEP = "\n";
+        List<String> columns;
+        if (!Helper.isEmpty(columnsParam))
+            columns = Arrays.asList(columnsParam.split(","));
+        else
+            columns = Arrays.asList("longitude", "latitude", "time", "distance");
+
+        if (columns.isEmpty())
+            throw new IllegalArgumentException("Either omit the columns parameter or specify the columns via comma separated values");
+
+        Map<String, EncodedValue> pathDetails = new HashMap<>();
+        for (String col : columns) {
+            if (encodingManager.hasEncodedValue(col))
+                pathDetails.put(col, encodingManager.getEncodedValue(col, EncodedValue.class));
+        }
+
+        StreamingOutput out = output -> {
+            try (Writer writer = new BufferedWriter(new OutputStreamWriter(output, Helper.UTF_CS))) {
+                StringBuilder sb = new StringBuilder();
+                for (String col : columns) {
+                    if (sb.length() > 0)
+                        sb.append(COL_SEP);
+                    sb.append(col);
+                }
+                sb.append(LINE_SEP);
+                writer.write(sb.toString());
+                isochrone.search(qr.getClosestNode(), label -> {
+                    sb.setLength(0);
+                    for (int colIndex = 0; colIndex < columns.size(); colIndex++) {
+                        String col = columns.get(colIndex);
+                        if (colIndex > 0)
+                            sb.append(COL_SEP);
+
+                        switch (col) {
+                            case "node_id":
+                                sb.append(label.nodeId);
+                                continue;
+                            case "prev_node_id":
+                                sb.append(label.prevNodeId);
+                                continue;
+                            case "edge_id":
+                                sb.append(label.edgeId);
+                                continue;
+                            case "prev_edge_id":
+                                sb.append(label.prevEdgeId);
+                                continue;
+                            case "distance":
+                                sb.append(label.distance);
+                                continue;
+                            case "prev_distance":
+                                sb.append(label.prevCoordinate == null ? 0 : label.prevDistance);
+                                continue;
+                            case "time":
+                                sb.append(label.timeInSec);
+                                continue;
+                            case "prev_time":
+                                sb.append(label.prevCoordinate == null ? 0 : label.prevTimeInSec);
+                                continue;
+                            case "longitude":
+                                sb.append(label.coordinate.lon);
+                                continue;
+                            case "prev_longitude":
+                                sb.append(label.prevCoordinate == null ? null : label.prevCoordinate.lon);
+                                continue;
+                            case "latitude":
+                                sb.append(label.coordinate.lat);
+                                continue;
+                            case "prev_latitude":
+                                sb.append(label.prevCoordinate == null ? null : label.prevCoordinate.lat);
+                                continue;
+                        }
+
+                        if (!EdgeIterator.Edge.isValid(label.edgeId))
+                            continue;
+
+                        EdgeIteratorState edge = queryGraph.getEdgeIteratorState(label.edgeId, label.nodeId);
+                        if (edge == null)
+                            continue;
+
+                        if (col.equals(Parameters.Details.STREET_NAME)) {
+                            sb.append(edge.getName().replaceAll(",", ""));
+                            continue;
+                        }
+
+                        EncodedValue ev = pathDetails.get(col);
+                        if (ev instanceof DecimalEncodedValue) {
+                            DecimalEncodedValue dev = (DecimalEncodedValue) ev;
+                            sb.append(reverseFlow ? edge.getReverse(dev) : edge.get(dev));
+                        } else if (ev instanceof EnumEncodedValue) {
+                            EnumEncodedValue eev = (EnumEncodedValue) ev;
+                            sb.append(reverseFlow ? edge.getReverse(eev) : edge.get(eev));
+                        } else if (ev instanceof BooleanEncodedValue) {
+                            BooleanEncodedValue eev = (BooleanEncodedValue) ev;
+                            sb.append(reverseFlow ? edge.getReverse(eev) : edge.get(eev));
+                        } else if (ev instanceof IntEncodedValue) {
+                            IntEncodedValue eev = (IntEncodedValue) ev;
+                            sb.append(reverseFlow ? edge.getReverse(eev) : edge.get(eev));
+                        } else {
+                            throw new IllegalArgumentException("Unknown property " + col);
+                        }
+                    }
+                    sb.append(LINE_SEP);
+                    try {
+                        writer.write(sb.toString());
+                    } catch (IOException ex) {
+                        throw new RuntimeException(ex);
+                    }
+                });
+
+                logger.info("took: " + sw.stop().getSeconds() + ", visited nodes:" + isochrone.getVisitedNodes() + ", " + uriInfo.getQueryParameters());
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        };
+        // took header does not make sense as we stream
+        return Response.ok(out).build();
+    }
+}
diff --git a/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java b/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java
new file mode 100644
index 0000000000..baa2a2de01
--- /dev/null
+++ b/web-bundle/src/test/java/com/graphhopper/util/gpx/GpxFromInstructionsTest.java
@@ -0,0 +1,245 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.util.gpx;
+
+import com.graphhopper.reader.ReaderWay;
+import com.graphhopper.routing.Dijkstra;
+import com.graphhopper.routing.Path;
+import com.graphhopper.routing.profiles.BooleanEncodedValue;
+import com.graphhopper.routing.profiles.Roundabout;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.weighting.ShortestWeighting;
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.GraphBuilder;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.util.*;
+import org.junit.Before;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import javax.xml.XMLConstants;
+import javax.xml.transform.Source;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import javax.xml.validation.Validator;
+import java.io.StringReader;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+
+import static org.junit.Assert.*;
+
+public class GpxFromInstructionsTest {
+
+    private EncodingManager carManager;
+    private FlagEncoder carEncoder;
+    private BooleanEncodedValue roundaboutEnc;
+    private TranslationMap trMap;
+
+    @Before
+    public void setUp() {
+        carEncoder = new CarFlagEncoder();
+        carManager = EncodingManager.create(carEncoder);
+        roundaboutEnc = carManager.getBooleanEncodedValue(Roundabout.KEY);
+        trMap = new TranslationMap().doImport();
+    }
+
+    @Test
+    public void testInstructionsWithTimeAndPlace() {
+        Graph g = new GraphBuilder(carManager).create();
+        //   n-4-5   (n: pillar node)
+        //   |
+        // 7-3-2-6
+        //     |
+        //     1
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(1, 15.0, 10);
+        na.setNode(2, 15.1, 10);
+        na.setNode(3, 15.1, 9.9);
+        na.setNode(4, 15.2, 9.9);
+        na.setNode(5, 15.2, 10);
+        na.setNode(6, 15.1, 10.1);
+        na.setNode(7, 15.1, 9.8);
+
+        g.edge(1, 2, 7000, true).setName("1-2").setFlags(flagsForSpeed(carManager, 70));
+        g.edge(2, 3, 8000, true).setName("2-3").setFlags(flagsForSpeed(carManager, 80));
+        g.edge(2, 6, 10000, true).setName("2-6").setFlags(flagsForSpeed(carManager, 10));
+        g.edge(3, 4, 9000, true).setName("3-4").setFlags(flagsForSpeed(carManager, 90));
+        g.edge(3, 7, 10000, true).setName("3-7").setFlags(flagsForSpeed(carManager, 10));
+        g.edge(4, 5, 10000, true).setName("4-5").setFlags(flagsForSpeed(carManager, 100));
+
+        Path p = new Dijkstra(g, new ShortestWeighting(carEncoder), TraversalMode.NODE_BASED).calcPath(1, 5);
+        InstructionList wayList = p.calcInstructions(roundaboutEnc, trMap.getWithFallBack(Locale.US));
+        PointList points = p.calcPoints();
+        assertEquals(4, wayList.size());
+
+        assertEquals(34000, p.getDistance(), 1e-1);
+        assertEquals(34000, sumDistances(wayList), 1e-1);
+        assertEquals(5, points.size());
+        assertEquals(1604120, p.getTime());
+
+        assertEquals(Instruction.CONTINUE_ON_STREET, wayList.get(0).getSign());
+        assertEquals(15, wayList.get(0).getPoints().getLatitude(0), 1e-3);
+        assertEquals(10, wayList.get(0).getPoints().getLongitude(0), 1e-3);
+
+        assertEquals(Instruction.TURN_LEFT, wayList.get(1).getSign());
+        assertEquals(15.1, wayList.get(1).getPoints().getLatitude(0), 1e-3);
+        assertEquals(10, wayList.get(1).getPoints().getLongitude(0), 1e-3);
+
+        assertEquals(Instruction.TURN_RIGHT, wayList.get(2).getSign());
+        assertEquals(15.1, wayList.get(2).getPoints().getLatitude(0), 1e-3);
+        assertEquals(9.9, wayList.get(2).getPoints().getLongitude(0), 1e-3);
+
+        String gpxStr = GpxFromInstructions.createGPX(wayList, "test", (long) 0, false, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+        verifyGPX(gpxStr);
+//        System.out.println(gpxStr);
+
+        assertTrue(gpxStr, gpxStr.contains("<trkpt lat=\"15.0\" lon=\"10.0\"><time>1970-01-01T00:00:00Z</time>"));
+        assertTrue(gpxStr, gpxStr.contains("<extensions>") && gpxStr.contains("</extensions>"));
+        assertTrue(gpxStr, gpxStr.contains("<rtept lat=\"15.1\" lon=\"10.0\">"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:distance>8000.0</gh:distance>"));
+        assertTrue(gpxStr, gpxStr.contains("<desc>turn left onto 2-3</desc>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:sign>-2</gh:sign>"));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:direction>N</gh:direction>"));
+        assertTrue(gpxStr, gpxStr.contains("<gh:azimuth>0.0</gh:azimuth>"));
+
+        assertFalse(gpxStr, gpxStr.contains("NaN"));
+    }
+
+    @Test
+    public void testCreateGPX() {
+        InstructionAnnotation ea = InstructionAnnotation.EMPTY;
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+        PointList pl = new PointList();
+        pl.add(49.942576, 11.580384);
+        pl.add(49.941858, 11.582422);
+        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
+
+        pl = new PointList();
+        pl.add(49.941575, 11.583501);
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
+
+        pl = new PointList();
+        pl.add(49.941389, 11.584311);
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
+        instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
+
+        List<GPXEntry> result = GpxFromInstructions.createGPXList(instructions);
+        assertEquals(5, result.size());
+
+        assertEquals(0, result.get(0).getTime().longValue());
+        assertNull(result.get(1).getTime());
+        assertEquals(15000, result.get(2).getTime().longValue());
+        assertEquals(19000, result.get(3).getTime().longValue());
+        assertEquals(22000, result.get(4).getTime().longValue());
+
+        verifyGPX(GpxFromInstructions.createGPX(instructions, "GraphHopper", new Date().getTime(), false, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US)));
+    }
+
+    @Test
+    public void testCreateGPXIncludesRoundaboutExitNumber() {
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+
+        PointList pl = new PointList();
+        pl.add(52.555423473315, 13.43890086052345);
+        pl.add(52.555550691982, 13.43946393816465);
+        pl.add(52.555619423589, 13.43886994061328);
+        RoundaboutInstruction instr = new RoundaboutInstruction(Instruction.USE_ROUNDABOUT, "streetname",
+                InstructionAnnotation.EMPTY, pl)
+                .setRadian(2.058006514284998d)
+                .setExitNumber(3)
+                .setExited();
+        instructions.add(instr);
+        instructions.add(new FinishInstruction(52.555619423589, 13.43886994061328, 0));
+
+        String gpxStr = GpxFromInstructions.createGPX(instructions, "test", 0, true, true, false, false, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+
+        assertTrue(gpxStr, gpxStr.contains("<gh:exit_number>3</gh:exit_number>"));
+        verifyGPX(gpxStr);
+    }
+
+    @Test
+    public void testCreateGPXCorrectFormattingSmallNumbers() {
+        InstructionList instructions = new InstructionList(trMap.getWithFallBack(Locale.US));
+
+        PointList pl = new PointList();
+        pl.add(0.000001, 0.000001);
+        pl.add(-0.000123, -0.000125);
+        Instruction instruction = new Instruction(0, "do it", null, pl);
+        instructions.add(instruction);
+        instructions.add(new FinishInstruction(0.000852, 0.000852, 0));
+
+        String gpxStr = GpxFromInstructions.createGPX(instructions, "test", 0, true, true, true, true, Constants.VERSION, trMap.getWithFallBack(Locale.US));
+
+        assertFalse(gpxStr, gpxStr.contains("E-"));
+        assertTrue(gpxStr, gpxStr.contains("0.000001"));
+        assertTrue(gpxStr, gpxStr.contains("-0.000125"));
+        verifyGPX(gpxStr);
+    }
+
+    @Test
+    public void testXMLEscape_issue572() {
+        assertEquals("_", GpxFromInstructions.simpleXMLEscape("<"));
+        assertEquals("_blup_", GpxFromInstructions.simpleXMLEscape("<blup>"));
+        assertEquals("a&amp;b", GpxFromInstructions.simpleXMLEscape("a&b"));
+    }
+
+    private IntsRef flagsForSpeed(EncodingManager encodingManager, int speedKmPerHour) {
+        ReaderWay way = new ReaderWay(1);
+        way.setTag("highway", "motorway");
+        way.setTag("maxspeed", String.format("%d km/h", speedKmPerHour));
+        EncodingManager.AcceptWay map = new EncodingManager.AcceptWay();
+        encodingManager.acceptWay(way, map);
+        return encodingManager.handleWayTags(way, map, 0);
+    }
+
+    private void verifyGPX(String gpx) {
+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+        Schema schema = null;
+        try {
+            Source schemaFile = new StreamSource(getClass().getResourceAsStream("gpx-schema.xsd"));
+            schema = schemaFactory.newSchema(schemaFile);
+
+            // using more schemas: http://stackoverflow.com/q/1094893/194609
+        } catch (SAXException e1) {
+            throw new IllegalStateException("There was a problem with the schema supplied for validation. Message:" + e1.getMessage());
+        }
+        Validator validator = schema.newValidator();
+        try {
+            validator.validate(new StreamSource(new StringReader(gpx)));
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private double sumDistances(InstructionList il) {
+        double val = 0;
+        for (Instruction i : il) {
+            val += i.getDistance();
+        }
+        return val;
+    }
+
+}
diff --git a/core/src/test/resources/com/graphhopper/util/gpx-schema.xsd b/web-bundle/src/test/resources/com/graphhopper/util/gpx/gpx-schema.xsd
similarity index 100%
rename from core/src/test/resources/com/graphhopper/util/gpx-schema.xsd
rename to web-bundle/src/test/resources/com/graphhopper/util/gpx/gpx-schema.xsd
diff --git a/web/package.json b/web/package.json
index 2a28deadda..ac843db171 100644
--- a/web/package.json
+++ b/web/package.json
@@ -24,20 +24,22 @@
     }
   },
   "dependencies": {
+    "leaflet.vectorgrid": "1.3.0",
     "browserify": "16.2.0",
     "browserify-swap": "0.2.2",
-    "d3": "3.5.17",
-    "jquery": "3.3.1",
+    "d3": "5.9.7",
+    "jquery": "3.4.1",
     "leaflet": "1.3.1",
     "leaflet-contextmenu": "1.4.0",
     "leaflet-loading": "0.1.24",
     "moment": "2.22.1",
     "uglifyify": "5.0.0",
-    "flatpickr": "4.4.6"
+    "flatpickr": "4.4.6",
+    "leaflet.heightgraph": "0.1.0"
   },
   "devDependencies": {
     "jasmine": "3.1.0",
-    "jshint": "2.9.5",
-    "watchify": "3.11.0"
+    "jshint": "^2.10.2",
+    "watchify": "^3.11.1"
   }
 }
diff --git a/web/pom.xml b/web/pom.xml
index 0d4d7b1a66..a0eccbb2a5 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -6,14 +6,14 @@
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-web</artifactId>
     <packaging>jar</packaging>
-    <version>0.11-SNAPSHOT</version>
+    <version>0.13-SNAPSHOT</version>
     <name>GraphHopper Web</name>
     <description>Use the GraphHopper routing engine as a web-service</description>
 
     <parent>
         <groupId>com.graphhopper</groupId>
         <artifactId>graphhopper-parent</artifactId>
-        <version>0.11-SNAPSHOT</version>
+        <version>0.13-SNAPSHOT</version>
     </parent>
     <properties>
         <jetty.version>9.4.2.v20170220</jetty.version>
@@ -28,7 +28,7 @@
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-core</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
             <groupId>com.graphhopper</groupId>
@@ -38,12 +38,12 @@
         <dependency>
             <groupId>io.dropwizard-bundles</groupId>
             <artifactId>dropwizard-configurable-assets-bundle</artifactId>
-            <version>1.2.2</version>
+            <version>1.3.5</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-testing</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
             <scope>test</scope>
         </dependency>
 
@@ -57,7 +57,7 @@
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>directions-api-client</artifactId>
-            <version>0.10.1-2</version>
+            <version>${directions-api-client.version}</version>
             <scope>test</scope>
         </dependency>
 
@@ -68,7 +68,6 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-compiler-plugin</artifactId>
-                <version>3.5.1</version>
                 <configuration>
                     <source>1.8</source>
                     <target>1.8</target>
@@ -77,7 +76,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-shade-plugin</artifactId>
-                <version>3.1.1</version>
+                <version>3.2.1</version>
                 <configuration>
                     <createDependencyReducedPom>true</createDependencyReducedPom>
                     <filters>
diff --git a/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java b/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
new file mode 100644
index 0000000000..3cfa30059d
--- /dev/null
+++ b/web/src/main/java/com/graphhopper/http/GHJerseyViolationExceptionMapper.java
@@ -0,0 +1,39 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import com.graphhopper.http.api.JsonErrorEntity;
+import io.dropwizard.jersey.validation.ConstraintMessage;
+import io.dropwizard.jersey.validation.JerseyViolationException;
+
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+import java.util.stream.Collectors;
+
+public class GHJerseyViolationExceptionMapper implements ExceptionMapper<JerseyViolationException> {
+    @Override
+    public Response toResponse(final JerseyViolationException e) {
+        return Response
+                .status(ConstraintMessage.determineStatus(e.getConstraintViolations(), e.getInvocable()))
+                .type(MediaType.APPLICATION_JSON)
+                .entity(new JsonErrorEntity(e.getConstraintViolations().stream().map(v -> new IllegalArgumentException(v.getMessage())).collect(Collectors.toList())))
+                .build();
+    }
+}
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
index 601643b45d..b98b46a7a1 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
@@ -17,12 +17,15 @@
  */
 package com.graphhopper.http;
 
+import com.graphhopper.gtfs.dropwizard.RealtimeBundle;
 import com.graphhopper.http.cli.ImportCommand;
 import com.graphhopper.http.resources.RootResource;
 import io.dropwizard.Application;
 import io.dropwizard.bundles.assets.ConfiguredAssetsBundle;
+import io.dropwizard.client.HttpClientBuilder;
 import io.dropwizard.setup.Bootstrap;
 import io.dropwizard.setup.Environment;
+import org.apache.http.client.HttpClient;
 
 import javax.servlet.DispatcherType;
 import java.util.EnumSet;
@@ -36,12 +39,14 @@ public static void main(String[] args) throws Exception {
     @Override
     public void initialize(Bootstrap<GraphHopperServerConfiguration> bootstrap) {
         bootstrap.addBundle(new GraphHopperBundle());
+        bootstrap.addBundle(new RealtimeBundle());
         bootstrap.addBundle(new ConfiguredAssetsBundle("/assets/", "/maps/", "index.html"));
-        bootstrap.addCommand(new ImportCommand(bootstrap.getObjectMapper()));
+        bootstrap.addCommand(new ImportCommand());
     }
 
     @Override
-    public void run(GraphHopperServerConfiguration configuration, Environment environment) {
+    public void run(GraphHopperServerConfiguration configuration, Environment environment) throws Exception {
+        environment.jersey().register(new GHJerseyViolationExceptionMapper());
         environment.jersey().register(new RootResource());
         environment.servlets().addFilter("cors", CORSFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
         environment.servlets().addFilter("ipfilter", new IPFilter(configuration.getGraphHopperConfiguration().get("jetty.whiteips", ""), configuration.getGraphHopperConfiguration().get("jetty.blackips", ""))).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java b/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
index c786a4d37d..b09ab29897 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperServerConfiguration.java
@@ -19,6 +19,9 @@
 package com.graphhopper.http;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
+import com.graphhopper.gtfs.dropwizard.RealtimeBundleConfiguration;
+import com.graphhopper.gtfs.dropwizard.FeedConfiguration;
+import com.graphhopper.gtfs.dropwizard.RealtimeConfiguration;
 import com.graphhopper.util.CmdArgs;
 import io.dropwizard.Configuration;
 import io.dropwizard.bundles.assets.AssetsBundleConfiguration;
@@ -26,8 +29,10 @@
 
 import javax.validation.Valid;
 import javax.validation.constraints.NotNull;
+import java.util.ArrayList;
+import java.util.List;
 
-public class GraphHopperServerConfiguration extends Configuration implements GraphHopperBundleConfiguration, AssetsBundleConfiguration {
+public class GraphHopperServerConfiguration extends Configuration implements GraphHopperBundleConfiguration, RealtimeBundleConfiguration, AssetsBundleConfiguration {
 
     @NotNull
     @JsonProperty
@@ -37,6 +42,9 @@
     @JsonProperty
     private final AssetsConfiguration assets = AssetsConfiguration.builder().build();
 
+    @JsonProperty
+    private final RealtimeConfiguration gtfsRealtime = new RealtimeConfiguration();
+
     public GraphHopperServerConfiguration() {
     }
 
@@ -49,4 +57,9 @@ public CmdArgs getGraphHopperConfiguration() {
     public AssetsConfiguration getAssetsConfiguration() {
         return assets;
     }
+
+    @Override
+    public RealtimeConfiguration gtfsrealtime() {
+        return gtfsRealtime;
+    }
 }
diff --git a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
index 8ce4b6e8c2..c2ec7c75f2 100644
--- a/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
+++ b/web/src/main/java/com/graphhopper/http/cli/ImportCommand.java
@@ -18,27 +18,47 @@
 
 package com.graphhopper.http.cli;
 
-import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.transit.realtime.GtfsRealtime;
 import com.graphhopper.http.GraphHopperManaged;
 import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.reader.gtfs.GraphHopperGtfs;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.GraphHopperStorage;
 import io.dropwizard.cli.ConfiguredCommand;
 import io.dropwizard.setup.Bootstrap;
 import net.sourceforge.argparse4j.inf.Namespace;
 
-public class ImportCommand extends ConfiguredCommand<GraphHopperServerConfiguration> {
+import java.util.Arrays;
+import java.util.Collections;
 
-    private final ObjectMapper objectMapper;
+public class ImportCommand extends ConfiguredCommand<GraphHopperServerConfiguration> {
 
-    public ImportCommand(ObjectMapper objectMapper) {
+    public ImportCommand() {
         super("import", "creates the graphhopper files used for later (faster) starts");
-        this.objectMapper = objectMapper;
     }
 
     @Override
-    protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespace namespace, GraphHopperServerConfiguration configuration) {
-        final GraphHopperManaged graphHopper = new GraphHopperManaged(configuration.getGraphHopperConfiguration(), objectMapper);
-        graphHopper.start();
-        graphHopper.stop();
+    protected void run(Bootstrap<GraphHopperServerConfiguration> bootstrap, Namespace namespace, GraphHopperServerConfiguration configuration) throws Exception {
+        if (configuration.getGraphHopperConfiguration().has("gtfs.file")) {
+            final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
+            final GHDirectory ghDirectory = GraphHopperGtfs.createGHDirectory(configuration.getGraphHopperConfiguration().get("graph.location", "target/tmp"));
+            final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
+            final EncodingManager encodingManager = EncodingManager.create(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()), 12);
+            final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
+                    configuration.getGraphHopperConfiguration().has("gtfs.file") ? Arrays.asList(configuration.getGraphHopperConfiguration().get("gtfs.file", "").split(",")) : Collections.emptyList(),
+                    configuration.getGraphHopperConfiguration().has("datareader.file") ? Arrays.asList(configuration.getGraphHopperConfiguration().get("datareader.file", "").split(",")) : Collections.emptyList());
+            graphHopperStorage.close();
+        } else {
+            final GraphHopperManaged graphHopper = new GraphHopperManaged(configuration.getGraphHopperConfiguration(), bootstrap.getObjectMapper());
+            graphHopper.start();
+            graphHopper.stop();
+        }
+
     }
 
 }
diff --git a/web/src/main/resources/assets/css/L.Control.Heightgraph.css b/web/src/main/resources/assets/css/L.Control.Heightgraph.css
new file mode 100755
index 0000000000..0221dfb7e3
--- /dev/null
+++ b/web/src/main/resources/assets/css/L.Control.Heightgraph.css
@@ -0,0 +1,146 @@
+.heightgraph-container {
+    background-color: #FFF;
+    border-radius: 10px;
+    display: none;
+    cursor: default;
+    user-select: none;
+}
+
+.heightgraph-toggle {
+    cursor: pointer;
+    box-shadow: 0 1px 7px rgba(0, 0, 0, .4);
+    border-radius: 5px;
+    width: 28px;
+    height: 28px;
+    background: #f8f8f9;
+    display: block;
+}
+
+.heightgraph-toggle-icon {
+    background: url(images/area-chart.svg) no-repeat center center;
+    background-size: 14px 14px;
+    width: 26px;
+    height: 26px;
+    position: absolute;
+}
+
+.heightgraph-close-icon {
+    background: url(images/remove.svg) no-repeat center center;
+    background-size: 14px 14px;
+    width: 26px;
+    height: 26px;
+    position: absolute;
+    right: 0;
+    display: none;
+}
+
+.border-top {
+    stroke-width: 1;
+    stroke: #999;
+    fill: none;
+}
+
+.legend-hover {
+    cursor: pointer;
+}
+
+.legend-text {
+    fill: #000;
+    font-size: 10px;
+    cursor: pointer;
+}
+
+.tick, .tick text {
+    fill: #999;
+    pointer-events: none;
+}
+
+.axis .tick line {
+    visibility: hidden;
+    pointer-events: none;
+}
+
+.axis path {
+    stroke: black;
+    fill: none;
+    stroke-width: 2px;
+    shape-rendering: crispEdges;
+    stroke: lightgrey;
+    pointer-events: none;
+}
+
+.focus {
+    display: none;
+    font-size: 10px;
+    fill: #000;
+    pointer-events: none;
+}
+
+.focus rect {
+    fill: rgba(255, 255, 255, 0.8);
+    stroke-width: 1px;
+    stroke: #888;
+    pointer-events: none;
+}
+
+.focus text {
+    font-size: 12px;
+}
+
+.focusLine line {
+    stroke-width: 1px;
+    stroke: rgb(20, 20, 20);
+    display: none;
+    cursor: default;
+    shape-rendering: crispEdges;
+}
+
+.height-focus.label rect {
+    fill: rgba(255, 255, 255, 0.5);
+    stroke-width: 1px;
+    stroke: #888;
+    pointer-events: none;
+    shape-rendering: crispEdges;
+}
+
+.height-focus.line {
+    stroke: rgb(20, 20, 20);
+    stroke-width: 1px;
+    shape-rendering: crispEdges;
+}
+
+.height-focus.circle {
+    stroke: #FFF;
+    stroke-width: 1px;
+}
+
+.grid .tick {
+    pointer-events: none;
+}
+
+.grid .tick line {
+    stroke: #EEE;
+    stroke-width: 1px;
+    shape-rendering: crispEdges;
+}
+
+.grid path {
+    stroke-width: 0;
+    pointer-events: none;
+}
+
+.tspan {
+    font-weight: bold;
+}
+
+.select-symbol {
+    cursor: pointer;
+}
+
+.select-info {
+    cursor: default;
+}
+
+.lineSelection {
+    cursor: move;
+}
\ No newline at end of file
diff --git a/web/src/main/resources/assets/css/images/area-chart.svg b/web/src/main/resources/assets/css/images/area-chart.svg
new file mode 100755
index 0000000000..cf8b4a36b0
--- /dev/null
+++ b/web/src/main/resources/assets/css/images/area-chart.svg
@@ -0,0 +1 @@
+<svg width="1792" height="1792" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1920 1536v128h-2048v-1536h128v1408h1920zm-384-1024l256 896h-1664v-576l448-576 576 576z"/></svg>
\ No newline at end of file
diff --git a/web/src/main/resources/assets/css/images/remove.svg b/web/src/main/resources/assets/css/images/remove.svg
new file mode 100755
index 0000000000..f063b3df42
--- /dev/null
+++ b/web/src/main/resources/assets/css/images/remove.svg
@@ -0,0 +1 @@
+<svg width="1792" height="1792" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1490 1322q0 40-28 68l-136 136q-28 28-68 28t-68-28l-294-294-294 294q-28 28-68 28t-68-28l-136-136q-28-28-28-68t28-68l294-294-294-294q-28-28-28-68t28-68l136-136q28-28 68-28t68 28l294 294 294-294q28-28 68-28t68 28l136 136q28 28 28 68t-28 68l-294 294 294 294q28 28 28 68z"/></svg>
\ No newline at end of file
diff --git a/web/src/main/resources/assets/css/leaflet.elevation-0.0.4.css b/web/src/main/resources/assets/css/leaflet.elevation-0.0.4.css
deleted file mode 100644
index 49ee5aacbe..0000000000
--- a/web/src/main/resources/assets/css/leaflet.elevation-0.0.4.css
+++ /dev/null
@@ -1,64 +0,0 @@
-.white-theme.leaflet-control.elevation .background
-{
-  background-color: rgba(250,250,250,.6);
-  -webkit-border-radius: 5px;
-  -moz-border-radius: 5px;
-  -ms-border-radius: 5px;
-  -o-border-radius: 5px;
-  border-radius: 5px;
-}
-.white-theme.leaflet-control.elevation .axis line,
-.white-theme.leaflet-control.elevation .axis path
-{
-  fill: none;
-  stroke: #0d1821;
-  stroke-width: 2;
-}
-.white-theme.leaflet-control.elevation .mouse-drag
-{
-  fill: #00cc33;
-  opacity: 0.2;
-}
-.white-theme.leaflet-control.elevation .elevation-toggle
-{
-  cursor: pointer;
-  box-shadow: 0 1px 7px rgba(0,0,0,.4);
-  -webkit-border-radius: 5px;
-  border-radius: 5px;
-  width: 36px;
-  height: 36px;
-  background-color: #f8f8f9;
-}
-.white-theme.leaflet-control.elevation .elevation-toggle-icon
-{
-  background: url(images/elevation.png) no-repeat center center;
-}
-.white-theme.leaflet-control.elevation .area
-{
-  fill: #00cc33;
-  opacity: 0.8;
-}
-.white-theme.leaflet-control.elevation .mouse-focus-line
-{
-  pointer-events: none;
-  stroke-width: 1;
-  stroke: #0d1821;
-}
-.white-theme.leaflet-control.elevation-collapsed .background
-{
-  display: none;
-}
-.white-theme.leaflet-control.elevation-collapsed .elevation-toggle
-{
-  display: block;
-}
-.white-theme.height-focus
-{
-  stroke: #4682b4;
-  fill: #4682b4;
-}
-.white-theme.height-focus.line
-{
-  pointer-events: none;
-  stroke-width: 2;
-}
diff --git a/web/src/main/resources/assets/css/style.css b/web/src/main/resources/assets/css/style.css
index 817b29b81d..07cf28d319 100644
--- a/web/src/main/resources/assets/css/style.css
+++ b/web/src/main/resources/assets/css/style.css
@@ -27,6 +27,12 @@ body {
     padding-right: 5px;
 }
 
+#info ul {
+   margin-left:5px;
+   padding-left:5px;
+   list-style-type: none;
+}
+
 .route_results {
     max-height: 40%;
 }
@@ -205,7 +211,6 @@ body {
     /* color: #666666; */
     font-size: smaller;
     opacity: 0.8;
-    width: 200px;
 }
 
 #footer {
diff --git a/web/src/main/resources/assets/img/header.png b/web/src/main/resources/assets/img/header.png
old mode 100644
new mode 100755
index e89b782da1..6d74c0fe66
Binary files a/web/src/main/resources/assets/img/header.png and b/web/src/main/resources/assets/img/header.png differ
diff --git a/web/src/main/resources/assets/index.html b/web/src/main/resources/assets/index.html
index bb0958fb6d..1e388fd05d 100644
--- a/web/src/main/resources/assets/index.html
+++ b/web/src/main/resources/assets/index.html
@@ -27,13 +27,13 @@
         <title>Driving Directions - GraphHopper Maps</title>
         <meta name="description" content="A fast route planner for biking, hiking and more! Based on OpenStreetMap including elevation data. Try out for free!"/>
         <link rel="stylesheet" href="css/leaflet.css?v=1.3.1" />
-        <link rel="stylesheet" href="css/leaflet.elevation-0.0.4.css" />
         <link rel="stylesheet" href="css/leaflet_numbered_markers.css" />
         <link rel="stylesheet" href="css/leaflet.contextmenu.css?v=1.4.0" />
         <link rel="stylesheet" href="css/leaflet.loading.css?v=0.1.24" />
         <link rel="stylesheet" href="css/ui-lightness/jquery-ui.min.css" />
+        <link rel="stylesheet" href="css/L.Control.Heightgraph.css?v=0.0.1" />
         <link rel="stylesheet" href="css/flatpickr.min.css?v=4.4.6">
-        <script type="text/javascript" src="js/main.js?v=0.10.1"></script>
+        <script type="text/javascript" src="js/main.js?v=0.11.2"></script>
         <link rel="stylesheet" type="text/css" href="css/style.css" />
     </head>
     <body>
@@ -110,28 +110,25 @@
 </div>
 <div id="map">
 </div>
-<!-- Piwik -->
-<script type="text/javascript">
-            PIWIK = false;
-            if (PIWIK) {
-                var _paq = _paq || [];
-                _paq.push(['trackPageView']);
-                _paq.push(['enableLinkTracking']);
-                (function () {
-                    var url = "https://graphhopper.com/piwik/";
-                    _paq.push(['setTrackerUrl', url + 'piwik.php']);
-                    _paq.push(['setSiteId', 1]);
-                    var d = document, g = d.createElement('script'), s = d.getElementsByTagName('script')[0];
-                    g.type = 'text/javascript';
-                    g.defer = true;
-                    g.async = true;
-                    g.src = url + 'piwik.js';
-                    s.parentNode.insertBefore(g, s);
-                })();
-            }
 
+<!-- Matomo -->
+<script type="text/javascript">
+        PIWIK = false;
+        if (PIWIK) {
+          var _paq = window._paq || [];
+          /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
+          _paq.push(['trackPageView']);
+          _paq.push(['enableLinkTracking']);
+          (function() {
+            var u="//matomo.graphhopper.com/";
+            _paq.push(['setTrackerUrl', u+'matomo.php']);
+            _paq.push(['setSiteId', '1']);
+            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
+            g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
+          })();
+        }
 </script>
-<noscript><p><img src="https://graphhopper.com/piwik/piwik.php?idsite=1" style="border:0;" alt=""/></p></noscript>
-<!-- End Piwik Code -->
+<noscript><p><img src="https://matomo.graphhopper.com/matomo.php?idsite=1&amp;rec=1" style="border:0;" alt=""/></p></noscript>
+<!-- End Matomo Code -->
 </body>
 </html>
diff --git a/web/src/main/resources/assets/js/autocomplete.js b/web/src/main/resources/assets/js/autocomplete.js
index b8e3ee00d0..0ecbb3d506 100644
--- a/web/src/main/resources/assets/js/autocomplete.js
+++ b/web/src/main/resources/assets/js/autocomplete.js
@@ -6,13 +6,11 @@ var mapLayer = require('./map.js');
 var dataToHtml = function (data, query) {
     var element = "";
     if (data.name) {
-        element += "<div class='nameseg'>" + formatTools.formatValue(data.name, query) + "</div>";
-    } else if (data.street) {
-        var streetStr = data.street;
+        var name = data.name;
         if (data.housenumber)
-            streetStr = formatTools.insComma(streetStr, data.housenumber);
+            name = formatTools.insComma(name, data.housenumber);
 
-        element += "<div class='nameseg'>" + formatTools.formatValue(streetStr, query) + "</div>";
+        element += "<div class='nameseg'>" + formatTools.formatValue(name, query) + "</div>";
     }
 
     var addStr = "";
@@ -106,7 +104,7 @@ AutoComplete.prototype.showListForIndex = function (ghRequest, routeIfAllResolve
         containerClass: "autocomplete",
         timeout: 1000,
         /* avoid too many requests when typing quickly */
-        deferRequestBy: 5,
+        deferRequestBy: 200,
         minChars: 2,
         maxHeight: 510,
         noCache: true,
@@ -159,15 +157,6 @@ AutoComplete.prototype.showListForIndex = function (ghRequest, routeIfAllResolve
     };
 
     myAutoDiv.autocomplete(options);
-
-    // with the following more stable code we cannot click on suggestions any longer
-//    $("#" + fromOrTo + "Input").focusout(function() {
-//        myAutoDiv.autocomplete().disable();
-//        myAutoDiv.autocomplete().hide();
-//    });
-//    $("#" + fromOrTo + "Input").focusin(function() {
-//        myAutoDiv.autocomplete().enable();
-//    });
 };
 
 AutoComplete.prototype.createStub = function () {
diff --git a/web/src/main/resources/assets/js/config/tileLayers.js b/web/src/main/resources/assets/js/config/tileLayers.js
index 51845c1877..a5691983c4 100644
--- a/web/src/main/resources/assets/js/config/tileLayers.js
+++ b/web/src/main/resources/assets/js/config/tileLayers.js
@@ -16,7 +16,7 @@ var lyrk = L.tileLayer('https://tiles.lyrk.org/' + (retinaTiles ? 'lr' : 'ls') +
     attribution: osmAttr + ', <a href="https://geodienste.lyrk.de/">Lyrk</a>'
 });
 
-var omniscale = L.tileLayer('https://maps.omniscale.net/v2/' +osAPIKey + '/style.default' + (retinaTiles ? '/hq.true' : '') + '/{z}/{x}/{y}.png', {
+var omniscale = L.tileLayer('https://maps.omniscale.net/v2/' +osAPIKey + '/style.default/{z}/{x}/{y}.png' + (retinaTiles ? '?hq=true' : ''), {
     layers: 'osm',
     attribution: osmAttr + ', &copy; <a href="https://maps.omniscale.com/">Omniscale</a>'
 });
@@ -85,6 +85,73 @@ var availableTileLayers = {
     "OpenStreetMap.de": osmde
 };
 
+var overlays;
+if(ghenv.environment === 'development') {
+    var omniscaleGray = L.tileLayer('https://maps.omniscale.net/v2/' +osAPIKey + '/style.grayscale/layers.world,buildings,landusages,labels/{z}/{x}/{y}.png?' + (retinaTiles ? '&hq=true' : ''), {
+        layers: 'osm',
+        attribution: osmAttr + ', &copy; <a href="https://maps.omniscale.com/">Omniscale</a>'
+    });
+    availableTileLayers["Omniscale Dev"] = omniscaleGray;
+
+    require('leaflet.vectorgrid');
+    var vtLayer = L.vectorGrid.protobuf("/mvt/{z}/{x}/{y}.mvt?details=max_speed&details=road_class&details=road_environment", {
+      rendererFactory: L.canvas.tile,
+      maxZoom: 20,
+      minZoom: 10,
+      interactive: true,
+      vectorTileLayerStyles: {
+        'roads': function(properties, zoom) {
+            // weight == line width
+            var color, opacity = 1, weight = 1, rc = properties.road_class;
+            // if(properties.speed < 30) console.log(properties)
+            if(rc == "motorway") {
+                color = '#dd504b'; // red
+                weight = 3;
+            } else if(rc == "primary" || rc == "trunk") {
+                color = '#e2a012'; // orange
+                weight = 2;
+            } else if(rc == "secondary") {
+                weight = 2;
+                color = '#f7c913'; // yellow
+            } else {
+                color = "#aaa5a7"; // grey
+            }
+            if(zoom > 16)
+               weight += 3;
+            else if(zoom > 15)
+               weight += 2;
+            else if(zoom > 13)
+               weight += 1;
+
+            return {
+                weight: weight,
+                color: color,
+                opacity: opacity
+            }
+        },
+      },
+    })
+    .on('click', function(e) {
+    })
+    .on('mouseover', function(e) {
+        console.log(e.layer.properties);
+        // remove route info
+        $("#info").children("div").remove();
+        // remove last vector tile info
+        $("#info").children("ul").remove();
+
+        var list = "";
+        $.each(e.layer.properties, function (key, value) {
+            list += "<li>" + key + ": " + value + "</li>";
+        });
+        $("#info").append("<ul>"+list+"</ul>");
+        $("#info").show();
+    }).on('mouseout', function (e) {
+//        $("#info").html("");
+    });
+    overlays = { "Local MVT": vtLayer };
+}
+
 module.exports.activeLayerName = "Omniscale";
 module.exports.defaultLayer = omniscale;
 
@@ -92,6 +159,10 @@ module.exports.getAvailableTileLayers = function () {
     return availableTileLayers;
 };
 
+module.exports.getOverlays = function () {
+    return overlays;
+};
+
 module.exports.selectLayer = function (layerName) {
     var defaultLayer = availableTileLayers[layerName];
     if (!defaultLayer)
diff --git a/web/src/main/resources/assets/js/lib/leaflet.elevation-0.0.4.min.js b/web/src/main/resources/assets/js/lib/leaflet.elevation-0.0.4.min.js
deleted file mode 100644
index 76fe697f02..0000000000
--- a/web/src/main/resources/assets/js/lib/leaflet.elevation-0.0.4.min.js
+++ /dev/null
@@ -1,2 +0,0 @@
-/*! leaflet.elevation 02-03-2016 */
-L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(a){this._container=null},onAdd:function(a){this._map=a;var b=this.options,c=b.margins;b.xTicks=b.xTicks||Math.round(this._width()/75),b.yTicks=b.yTicks||Math.round(this._height()/30),b.hoverNumber.formatter=b.hoverNumber.formatter||this._formatter;var d=this._x=d3.scale.linear().range([0,this._width()]),e=this._y=d3.scale.linear().range([this._height(),0]),f=(this._area=d3.svg.area().interpolate(b.interpolation).x(function(a){var b=d(a.dist);return a.xDiagCoord=b,b}).y0(this._height()).y1(function(a){return e(a.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(f,b.theme),this._initToggle();var g=d3.select(f);g.attr("width",b.width);var h=g.append("svg");h.attr("width",b.width).attr("class","background").attr("height",b.height).append("g").attr("transform","translate("+c.left+","+c.top+")");var i=d3.svg.line();i=i.x(function(a){return d3.mouse(h.select("g"))[0]}).y(function(a){return this._height()});var j=d3.select(this._container).select("svg").select("g");this._areapath=j.append("path").attr("class","area");var k=this._background=j.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.mobile?(k.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(k.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=j.append("g"),this._yaxisgraphicnode=j.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var l=this._focusG=j.append("g");return this._mousefocus=l.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=l.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),f},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var a=this._dragCurrentCoords=d3.mouse(this._background.node()),b=Math.min(this._dragStartCoords[0],a[0]),c=Math.max(this._dragStartCoords[0],a[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",c-b).attr("x",b);else{var d=d3.select(this._container).select("svg").select("g");this._dragRectangleG=d.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",c-b).attr("height",this._height()).attr("x",b).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var a=this._findItemForX(this._dragStartCoords[0]),b=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(a,b),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(a){var b=d3.bisector(function(a){return a.dist}).left,c=this._x.invert(a);return b(this._data,c)},_findItemForLatLng:function(a){var b=null,c=1/0;return this._data.forEach(function(d){var e=a.distanceTo(d.latlng);c>e&&(c=e,b=d)}),b},_fitSection:function(a,b){var c=Math.min(a,b),d=Math.max(a,b),e=this._calculateFullExtent(this._data.slice(c,d));this._map.fitBounds(e)},_initToggle:function(){var a=this._container;if(a.setAttribute("aria-haspopup",!0),L.Browser.mobile?L.DomEvent.on(a,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(a),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(a,"mouseover",this._expand,this).on(a,"mouseout",this._collapse,this);var b=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,a);b.href="#",b.title=this.options.controlButton.title,L.Browser.mobile?L.DomEvent.on(b,"click",L.DomEvent.stop).on(b,"click",this._expand,this):L.DomEvent.on(b,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var a=this.options;return a.width-a.margins.left-a.margins.right},_height:function(){var a=this.options;return a.height-a.margins.top-a.margins.bottom},_formatter:function(a,b,c){var d;d=0===b?Math.round(a)+"":L.Util.formatNum(a,b)+"";var e=d.split(".");if(e[1]){for(var f=b-e[1].length;f>0;f--)e[1]+="0";d=e.join(c||".")}return d},_appendYaxis:function(a){var b=this.options;b.imperial?a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):a.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(a){var b=this.options;b.imperial?a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):a.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(a,b,c){if(this._data&&0!==this._data.length){var d=d3.mouse(this._background.node()),e=this.options,f=this._data[this._findItemForX(d[0])],g=f.altitude,h=f.dist,i=f.latlng,j=e.hoverNumber.formatter(g,e.hoverNumber.decimalsY);e.hoverNumber.formatter(h,e.hoverNumber.decimalsX);this._showDiagramIndicator(f,d[0]);var k=this._map.latLngToLayerPoint(i);if(e.useHeightIndicator){if(!this._mouseHeightFocus){var l=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=l.append("svg:line").attr("class",e.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0);var m=this._pointG=l.append("g");m.append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",e.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=l.append("svg:text").attr("class",e.theme+" height-focus-label").style("pointer-events","none")}var n=this._height()/this._maxElevation*g,o=k.y-n;this._mouseHeightFocus.attr("x1",k.x).attr("x2",k.x).attr("y1",k.y).attr("y2",o).style("visibility","visible"),this._pointG.attr("transform","translate("+k.x+","+k.y+")").style("visibility","visible"),e.imperial?this._mouseHeightFocusLabel.attr("x",k.x).attr("y",o).text(j+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",k.x).attr("y",o).text(j+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(i):this._marker=new L.Marker(i).addTo(this._map)}},_addGeoJSONData:function(a){var b=this.options;if(a){for(var c=this._data||[],d=this._dist||0,e=this._maxElevation||0,f=0;f<a.length;f++){var g=new L.LatLng(a[f][1],a[f][0]),h=new L.LatLng(a[f?f-1:0][1],a[f?f-1:0][0]),i=b.imperial?g.distanceTo(h)*this.__mileFactor:g.distanceTo(h);d+=Math.round(i/1e3*1e5)/1e5,e=e<a[f][2]?a[f][2]:e,c.push({dist:d,altitude:b.imperial?a[f][2]*this.__footFactor:a[f][2],x:a[f][0],y:a[f][1],latlng:g})}this._dist=d,this._data=c,e=b.imperial?e*this.__footFactor:e,this._maxElevation=e}},_addGPXdata:function(a){var b=this.options;if(a){for(var c=this._data||[],d=this._dist||0,e=this._maxElevation||0,f=0;f<a.length;f++){var g=a[f],h=a[f?f-1:0],i=b.imperial?g.distanceTo(h)*this.__mileFactor:g.distanceTo(h);d+=Math.round(i/1e3*1e5)/1e5,e=e<g.meta.ele?g.meta.ele:e,c.push({dist:d,altitude:b.imperial?g.meta.ele*this.__footFactor:g.meta.ele,x:g.lng,y:g.lat,latlng:g})}this._dist=d,this._data=c,e=b.imperial?e*this.__footFactor:e,this._maxElevation=e}},_addData:function(a){var b,c=a&&a.geometry&&a.geometry;if(c)switch(c.type){case"LineString":this._addGeoJSONData(c.coordinates);break;case"MultiLineString":for(b=0;b<c.coordinates.length;b++)this._addGeoJSONData(c.coordinates[b]);break;default:throw new Error("Invalid GeoJSON object.")}var d=a&&"FeatureCollection"===a.type;if(d)for(b=0;b<a.features.length;b++)this._addData(a.features[b]);a&&a._latlngs&&this._addGPXdata(a._latlngs)},_calculateFullExtent:function(a){if(!a||a.length<1)throw new Error("no data in parameters");var b=new L.latLngBounds(a[0].latlng,a[0].latlng);return a.forEach(function(a){b.extend(a.latlng)}),b},addData:function(a,b){this._addData(a),this._container&&this._applyData(),null===b&&a.on&&(b=a),b&&b.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(a){if(this._data&&0!==this._data.length){var b=a.latlng,c=this._findItemForLatLng(b);if(c){var d=c.xDiagCoord;this._showDiagramIndicator(c,d)}}},_showDiagramIndicator:function(a,b){var c=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",b).attr("y1",0).attr("x2",b).attr("y2",this._height()).classed("hidden",!1);var d=a.altitude,e=a.dist,f=(a.latlng,c.hoverNumber.formatter(d,c.hoverNumber.decimalsY)),g=c.hoverNumber.formatter(e,c.hoverNumber.decimalsX);c.imperial?(this._focuslabelX.attr("x",b).text(f+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",b).text(g+" mi")):(this._focuslabelX.attr("x",b).text(f+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",b).text(g+" km"))},_applyData:function(){var a=d3.extent(this._data,function(a){return a.dist}),b=d3.extent(this._data,function(a){return a.altitude}),c=this.options;void 0!==c.yAxisMin&&(c.yAxisMin<b[0]||c.forceAxisBounds)&&(b[0]=c.yAxisMin),void 0!==c.yAxisMax&&(c.yAxisMax>b[1]||c.forceAxisBounds)&&(b[1]=c.yAxisMax),this._x.domain(a),this._y.domain(b),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(a){return new L.Control.Elevation(a)};
\ No newline at end of file
diff --git a/web/src/main/resources/assets/js/main-template.js b/web/src/main/resources/assets/js/main-template.js
index bc7cd7bae9..47891ead8a 100644
--- a/web/src/main/resources/assets/js/main-template.js
+++ b/web/src/main/resources/assets/js/main-template.js
@@ -5,8 +5,8 @@ require('flatpickr/dist/l10n');
 var L = require('leaflet');
 require('leaflet-contextmenu');
 require('leaflet-loading');
+require('leaflet.heightgraph');
 var moment = require('moment');
-require('./lib/leaflet.elevation-0.0.4.min.js');
 require('./lib/leaflet_numbered_markers.js');
 
 global.jQuery = require('jquery');
@@ -549,7 +549,7 @@ function routeLatLng(request, doQuery) {
             return;
         }
 
-        function createClickHandler(geoJsons, currentLayerIndex, tabHeader, oneTab, hasElevation, useMiles) {
+        function createClickHandler(geoJsons, currentLayerIndex, tabHeader, oneTab, hasElevation, useMiles, details) {
             return function () {
 
                 var currentGeoJson = geoJsons[currentLayerIndex];
@@ -568,7 +568,7 @@ function routeLatLng(request, doQuery) {
 
                 if (hasElevation) {
                     mapLayer.clearElevation();
-                    mapLayer.addElevation(currentGeoJson, useMiles);
+                    mapLayer.addElevation(currentGeoJson, useMiles, details);
                 }
 
                 headerTabs.find("li").removeClass("current");
@@ -633,7 +633,7 @@ function routeLatLng(request, doQuery) {
             mapLayer.addDataToRoutingLayer(geojsonFeature);
             var oneTab = $("<div class='route_result_tab'>");
             routeResultsDiv.append(oneTab);
-            tabHeader.click(createClickHandler(geoJsons, pathIndex, tabHeader, oneTab, request.hasElevation(), request.useMiles));
+            tabHeader.click(createClickHandler(geoJsons, pathIndex, tabHeader, oneTab, request.hasElevation(), request.useMiles, path.details));
 
             var routeInfo = $("<div class='route_description'>");
             if (path.description && path.description.length > 0) {
diff --git a/web/src/main/resources/assets/js/main.js b/web/src/main/resources/assets/js/main.js
deleted file mode 100644
index 1443b38d8f..0000000000
--- a/web/src/main/resources/assets/js/main.js
+++ /dev/null
@@ -1,101 +0,0 @@
-(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
-!function(){var n={version:"3.5.17"},t=[].slice,e=function(n){return t.call(n)},r=this.document;function i(n){return n&&(n.ownerDocument||n.document||n).documentElement}function u(n){return n&&(n.ownerDocument&&n.ownerDocument.defaultView||n.document&&n||n.defaultView)}if(r)try{e(r.documentElement.childNodes)[0].nodeType}catch(n){e=function(n){for(var t=n.length,e=new Array(t);t--;)e[t]=n[t];return e}}if(Date.now||(Date.now=function(){return+new Date}),r)try{r.createElement("DIV").style.setProperty("opacity",0,"")}catch(n){var o=this.Element.prototype,a=o.setAttribute,l=o.setAttributeNS,c=this.CSSStyleDeclaration.prototype,f=c.setProperty;o.setAttribute=function(n,t){a.call(this,n,t+"")},o.setAttributeNS=function(n,t,e){l.call(this,n,t,e+"")},c.setProperty=function(n,t,e){f.call(this,n,t+"",e)}}function s(n,t){return n<t?-1:n>t?1:n>=t?0:NaN}function h(n){return null===n?NaN:+n}function p(n){return!isNaN(n)}function g(n){return{left:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);r<i;){var u=r+i>>>1;n(t[u],e)<0?r=u+1:i=u}return r},right:function(t,e,r,i){for(arguments.length<3&&(r=0),arguments.length<4&&(i=t.length);r<i;){var u=r+i>>>1;n(t[u],e)>0?i=u:r=u+1}return r}}}n.ascending=s,n.descending=function(n,t){return t<n?-1:t>n?1:t>=n?0:NaN},n.min=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&e>r&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&e>r&&(e=r)}return e},n.max=function(n,t){var e,r,i=-1,u=n.length;if(1===arguments.length){for(;++i<u;)if(null!=(r=n[i])&&r>=r){e=r;break}for(;++i<u;)null!=(r=n[i])&&r>e&&(e=r)}else{for(;++i<u;)if(null!=(r=t.call(n,n[i],i))&&r>=r){e=r;break}for(;++i<u;)null!=(r=t.call(n,n[i],i))&&r>e&&(e=r)}return e},n.extent=function(n,t){var e,r,i,u=-1,o=n.length;if(1===arguments.length){for(;++u<o;)if(null!=(r=n[u])&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=n[u])&&(e>r&&(e=r),i<r&&(i=r))}else{for(;++u<o;)if(null!=(r=t.call(n,n[u],u))&&r>=r){e=i=r;break}for(;++u<o;)null!=(r=t.call(n,n[u],u))&&(e>r&&(e=r),i<r&&(i=r))}return[e,i]},n.sum=function(n,t){var e,r=0,i=n.length,u=-1;if(1===arguments.length)for(;++u<i;)p(e=+n[u])&&(r+=e);else for(;++u<i;)p(e=+t.call(n,n[u],u))&&(r+=e);return r},n.mean=function(n,t){var e,r=0,i=n.length,u=-1,o=i;if(1===arguments.length)for(;++u<i;)p(e=h(n[u]))?r+=e:--o;else for(;++u<i;)p(e=h(t.call(n,n[u],u)))?r+=e:--o;if(o)return r/o},n.quantile=function(n,t){var e=(n.length-1)*t+1,r=Math.floor(e),i=+n[r-1],u=e-r;return u?i+u*(n[r]-i):i},n.median=function(t,e){var r,i=[],u=t.length,o=-1;if(1===arguments.length)for(;++o<u;)p(r=h(t[o]))&&i.push(r);else for(;++o<u;)p(r=h(e.call(t,t[o],o)))&&i.push(r);if(i.length)return n.quantile(i.sort(s),.5)},n.variance=function(n,t){var e,r,i=n.length,u=0,o=0,a=-1,l=0;if(1===arguments.length)for(;++a<i;)p(e=h(n[a]))&&(o+=(r=e-u)*(e-(u+=r/++l)));else for(;++a<i;)p(e=h(t.call(n,n[a],a)))&&(o+=(r=e-u)*(e-(u+=r/++l)));if(l>1)return o/(l-1)},n.deviation=function(){var t=n.variance.apply(this,arguments);return t?Math.sqrt(t):t};var v=g(s);function d(n){return n.length}n.bisectLeft=v.left,n.bisect=n.bisectRight=v.right,n.bisector=function(n){return g(1===n.length?function(t,e){return s(n(t),e)}:n)},n.shuffle=function(n,t,e){(u=arguments.length)<3&&(e=n.length,u<2&&(t=0));for(var r,i,u=e-t;u;)i=Math.random()*u--|0,r=n[u+t],n[u+t]=n[i+t],n[i+t]=r;return n},n.permute=function(n,t){for(var e=t.length,r=new Array(e);e--;)r[e]=n[t[e]];return r},n.pairs=function(n){for(var t=0,e=n.length-1,r=n[0],i=new Array(e<0?0:e);t<e;)i[t]=[r,r=n[++t]];return i},n.transpose=function(t){if(!(u=t.length))return[];for(var e=-1,r=n.min(t,d),i=new Array(r);++e<r;)for(var u,o=-1,a=i[e]=new Array(u);++o<u;)a[o]=t[o][e];return i},n.zip=function(){return n.transpose(arguments)},n.keys=function(n){var t=[];for(var e in n)t.push(e);return t},n.values=function(n){var t=[];for(var e in n)t.push(n[e]);return t},n.entries=function(n){var t=[];for(var e in n)t.push({key:e,value:n[e]});return t},n.merge=function(n){for(var t,e,r,i=n.length,u=-1,o=0;++u<i;)o+=n[u].length;for(e=new Array(o);--i>=0;)for(t=(r=n[i]).length;--t>=0;)e[--o]=r[t];return e};var y=Math.abs;function m(n,t){for(var e in t)Object.defineProperty(n.prototype,e,{value:t[e],enumerable:!1})}function M(){this._=Object.create(null)}n.range=function(n,t,e){if(arguments.length<3&&(e=1,arguments.length<2&&(t=n,n=0)),(t-n)/e==1/0)throw new Error("infinite range");var r,i=[],u=function(n){var t=1;for(;n*t%1;)t*=10;return t}(y(e)),o=-1;if(n*=u,t*=u,(e*=u)<0)for(;(r=n+e*++o)>t;)i.push(r/u);else for(;(r=n+e*++o)<t;)i.push(r/u);return i},n.map=function(n,t){var e=new M;if(n instanceof M)n.forEach(function(n,t){e.set(n,t)});else if(Array.isArray(n)){var r,i=-1,u=n.length;if(1===arguments.length)for(;++i<u;)e.set(i,n[i]);else for(;++i<u;)e.set(t.call(n,r=n[i],i),r)}else for(var o in n)e.set(o,n[o]);return e};var x="__proto__",b="\0";function _(n){return(n+="")===x||n[0]===b?b+n:n}function w(n){return(n+="")[0]===b?n.slice(1):n}function S(n){return _(n)in this._}function k(n){return(n=_(n))in this._&&delete this._[n]}function N(){var n=[];for(var t in this._)n.push(w(t));return n}function E(){var n=0;for(var t in this._)++n;return n}function A(){for(var n in this._)return!1;return!0}function C(){this._=Object.create(null)}function z(n){return n}function L(n,t,e){return function(){var r=e.apply(t,arguments);return r===t?n:r}}function q(n,t){if(t in n)return t;t=t.charAt(0).toUpperCase()+t.slice(1);for(var e=0,r=T.length;e<r;++e){var i=T[e]+t;if(i in n)return i}}m(M,{has:S,get:function(n){return this._[_(n)]},set:function(n,t){return this._[_(n)]=t},remove:k,keys:N,values:function(){var n=[];for(var t in this._)n.push(this._[t]);return n},entries:function(){var n=[];for(var t in this._)n.push({key:w(t),value:this._[t]});return n},size:E,empty:A,forEach:function(n){for(var t in this._)n.call(this,w(t),this._[t])}}),n.nest=function(){var t,e,r={},i=[],u=[];function o(n,u,a){if(a>=i.length)return e?e.call(r,u):t?u.sort(t):u;for(var l,c,f,s,h=-1,p=u.length,g=i[a++],v=new M;++h<p;)(s=v.get(l=g(c=u[h])))?s.push(c):v.set(l,[c]);return n?(c=n(),f=function(t,e){c.set(t,o(n,e,a))}):(c={},f=function(t,e){c[t]=o(n,e,a)}),v.forEach(f),c}return r.map=function(n,t){return o(t,n,0)},r.entries=function(t){return function n(t,e){if(e>=i.length)return t;var r=[],o=u[e++];return t.forEach(function(t,i){r.push({key:t,values:n(i,e)})}),o?r.sort(function(n,t){return o(n.key,t.key)}):r}(o(n.map,t,0),0)},r.key=function(n){return i.push(n),r},r.sortKeys=function(n){return u[i.length-1]=n,r},r.sortValues=function(n){return t=n,r},r.rollup=function(n){return e=n,r},r},n.set=function(n){var t=new C;if(n)for(var e=0,r=n.length;e<r;++e)t.add(n[e]);return t},m(C,{has:S,add:function(n){return this._[_(n+="")]=!0,n},remove:k,values:N,size:E,empty:A,forEach:function(n){for(var t in this._)n.call(this,w(t))}}),n.behavior={},n.rebind=function(n,t){for(var e,r=1,i=arguments.length;++r<i;)n[e=arguments[r]]=L(n,t,t[e]);return n};var T=["webkit","ms","moz","Moz","o","O"];function R(){}function D(){}function P(n){var t=[],e=new M;function r(){for(var e,r=t,i=-1,u=r.length;++i<u;)(e=r[i].on)&&e.apply(this,arguments);return n}return r.on=function(r,i){var u,o=e.get(r);return arguments.length<2?o&&o.on:(o&&(o.on=null,t=t.slice(0,u=t.indexOf(o)).concat(t.slice(u+1)),e.remove(r)),i&&t.push(e.set(r,{on:i})),n)},r}function U(){n.event.preventDefault()}function j(){for(var t,e=n.event;t=e.sourceEvent;)e=t;return e}function F(t){for(var e=new D,r=0,i=arguments.length;++r<i;)e[arguments[r]]=P(e);return e.of=function(r,i){return function(u){try{var o=u.sourceEvent=n.event;u.target=t,n.event=u,e[u.type].apply(r,i)}finally{n.event=o}}},e}n.dispatch=function(){for(var n=new D,t=-1,e=arguments.length;++t<e;)n[arguments[t]]=P(n);return n},D.prototype.on=function(n,t){var e=n.indexOf("."),r="";if(e>=0&&(r=n.slice(e+1),n=n.slice(0,e)),n)return arguments.length<2?this[n].on(r):this[n].on(r,t);if(2===arguments.length){if(null==t)for(n in this)this.hasOwnProperty(n)&&this[n].on(r,null);return this}},n.event=null,n.requote=function(n){return n.replace(H,"\\$&")};var H=/[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,O={}.__proto__?function(n,t){n.__proto__=t}:function(n,t){for(var e in t)n[e]=t[e]};function I(n){return O(n,X),n}var Y=function(n,t){return t.querySelector(n)},Z=function(n,t){return t.querySelectorAll(n)},V=function(n,t){var e=n.matches||n[q(n,"matchesSelector")];return(V=function(n,t){return e.call(n,t)})(n,t)};"function"==typeof Sizzle&&(Y=function(n,t){return Sizzle(n,t)[0]||null},Z=Sizzle,V=Sizzle.matchesSelector),n.selection=function(){return n.select(r.documentElement)};var X=n.selection.prototype=[];function $(n){return"function"==typeof n?n:function(){return Y(n,this)}}function B(n){return"function"==typeof n?n:function(){return Z(n,this)}}X.select=function(n){var t,e,r,i,u=[];n=$(n);for(var o=-1,a=this.length;++o<a;){u.push(t=[]),t.parentNode=(r=this[o]).parentNode;for(var l=-1,c=r.length;++l<c;)(i=r[l])?(t.push(e=n.call(i,i.__data__,l,o)),e&&"__data__"in i&&(e.__data__=i.__data__)):t.push(null)}return I(u)},X.selectAll=function(n){var t,r,i=[];n=B(n);for(var u=-1,o=this.length;++u<o;)for(var a=this[u],l=-1,c=a.length;++l<c;)(r=a[l])&&(i.push(t=e(n.call(r,r.__data__,l,u))),t.parentNode=r);return I(i)};var W="http://www.w3.org/1999/xhtml",J={svg:"http://www.w3.org/2000/svg",xhtml:W,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};function G(t,e){return t=n.ns.qualify(t),null==e?t.local?function(){this.removeAttributeNS(t.space,t.local)}:function(){this.removeAttribute(t)}:"function"==typeof e?t.local?function(){var n=e.apply(this,arguments);null==n?this.removeAttributeNS(t.space,t.local):this.setAttributeNS(t.space,t.local,n)}:function(){var n=e.apply(this,arguments);null==n?this.removeAttribute(t):this.setAttribute(t,n)}:t.local?function(){this.setAttributeNS(t.space,t.local,e)}:function(){this.setAttribute(t,e)}}function K(n){return n.trim().replace(/\s+/g," ")}function Q(t){return new RegExp("(?:^|\\s+)"+n.requote(t)+"(?:\\s+|$)","g")}function nn(n){return(n+"").trim().split(/^|\s+/)}function tn(n,t){var e=(n=nn(n).map(en)).length;return"function"==typeof t?function(){for(var r=-1,i=t.apply(this,arguments);++r<e;)n[r](this,i)}:function(){for(var r=-1;++r<e;)n[r](this,t)}}function en(n){var t=Q(n);return function(e,r){if(i=e.classList)return r?i.add(n):i.remove(n);var i=e.getAttribute("class")||"";r?(t.lastIndex=0,t.test(i)||e.setAttribute("class",K(i+" "+n))):e.setAttribute("class",K(i.replace(t," ")))}}function rn(n,t,e){return null==t?function(){this.style.removeProperty(n)}:"function"==typeof t?function(){var r=t.apply(this,arguments);null==r?this.style.removeProperty(n):this.style.setProperty(n,r,e)}:function(){this.style.setProperty(n,t,e)}}function un(n,t){return null==t?function(){delete this[n]}:"function"==typeof t?function(){var e=t.apply(this,arguments);null==e?delete this[n]:this[n]=e}:function(){this[n]=t}}function on(t){return"function"==typeof t?t:(t=n.ns.qualify(t)).local?function(){return this.ownerDocument.createElementNS(t.space,t.local)}:function(){var n=this.ownerDocument,e=this.namespaceURI;return e===W&&n.documentElement.namespaceURI===W?n.createElement(t):n.createElementNS(e,t)}}function an(){var n=this.parentNode;n&&n.removeChild(this)}function ln(n){return{__data__:n}}function cn(n){return function(){return V(this,n)}}function fn(n,t){for(var e=0,r=n.length;e<r;e++)for(var i,u=n[e],o=0,a=u.length;o<a;o++)(i=u[o])&&t(i,o,e);return n}function sn(n){return O(n,hn),n}n.ns={prefix:J,qualify:function(n){var t=n.indexOf(":"),e=n;return t>=0&&"xmlns"!==(e=n.slice(0,t))&&(n=n.slice(t+1)),J.hasOwnProperty(e)?{space:J[e],local:n}:n}},X.attr=function(t,e){if(arguments.length<2){if("string"==typeof t){var r=this.node();return(t=n.ns.qualify(t)).local?r.getAttributeNS(t.space,t.local):r.getAttribute(t)}for(e in t)this.each(G(e,t[e]));return this}return this.each(G(t,e))},X.classed=function(n,t){if(arguments.length<2){if("string"==typeof n){var e=this.node(),r=(n=nn(n)).length,i=-1;if(t=e.classList){for(;++i<r;)if(!t.contains(n[i]))return!1}else for(t=e.getAttribute("class");++i<r;)if(!Q(n[i]).test(t))return!1;return!0}for(t in n)this.each(tn(t,n[t]));return this}return this.each(tn(n,t))},X.style=function(n,t,e){var r=arguments.length;if(r<3){if("string"!=typeof n){for(e in r<2&&(t=""),n)this.each(rn(e,n[e],t));return this}if(r<2){var i=this.node();return u(i).getComputedStyle(i,null).getPropertyValue(n)}e=""}return this.each(rn(n,t,e))},X.property=function(n,t){if(arguments.length<2){if("string"==typeof n)return this.node()[n];for(t in n)this.each(un(t,n[t]));return this}return this.each(un(n,t))},X.text=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.textContent=null==t?"":t}:null==n?function(){this.textContent=""}:function(){this.textContent=n}):this.node().textContent},X.html=function(n){return arguments.length?this.each("function"==typeof n?function(){var t=n.apply(this,arguments);this.innerHTML=null==t?"":t}:null==n?function(){this.innerHTML=""}:function(){this.innerHTML=n}):this.node().innerHTML},X.append=function(n){return n=on(n),this.select(function(){return this.appendChild(n.apply(this,arguments))})},X.insert=function(n,t){return n=on(n),t=$(t),this.select(function(){return this.insertBefore(n.apply(this,arguments),t.apply(this,arguments)||null)})},X.remove=function(){return this.each(an)},X.data=function(n,t){var e,r,i=-1,u=this.length;if(!arguments.length){for(n=new Array(u=(e=this[0]).length);++i<u;)(r=e[i])&&(n[i]=r.__data__);return n}function o(n,e){var r,i,u,o=n.length,f=e.length,s=Math.min(o,f),h=new Array(f),p=new Array(f),g=new Array(o);if(t){var v,d=new M,y=new Array(o);for(r=-1;++r<o;)(i=n[r])&&(d.has(v=t.call(i,i.__data__,r))?g[r]=i:d.set(v,i),y[r]=v);for(r=-1;++r<f;)(i=d.get(v=t.call(e,u=e[r],r)))?!0!==i&&(h[r]=i,i.__data__=u):p[r]=ln(u),d.set(v,!0);for(r=-1;++r<o;)r in y&&!0!==d.get(y[r])&&(g[r]=n[r])}else{for(r=-1;++r<s;)i=n[r],u=e[r],i?(i.__data__=u,h[r]=i):p[r]=ln(u);for(;r<f;++r)p[r]=ln(e[r]);for(;r<o;++r)g[r]=n[r]}p.update=h,p.parentNode=h.parentNode=g.parentNode=n.parentNode,a.push(p),l.push(h),c.push(g)}var a=sn([]),l=I([]),c=I([]);if("function"==typeof n)for(;++i<u;)o(e=this[i],n.call(e,e.parentNode.__data__,i));else for(;++i<u;)o(e=this[i],n);return l.enter=function(){return a},l.exit=function(){return c},l},X.datum=function(n){return arguments.length?this.property("__data__",n):this.property("__data__")},X.filter=function(n){var t,e,r,i=[];"function"!=typeof n&&(n=cn(n));for(var u=0,o=this.length;u<o;u++){i.push(t=[]),t.parentNode=(e=this[u]).parentNode;for(var a=0,l=e.length;a<l;a++)(r=e[a])&&n.call(r,r.__data__,a,u)&&t.push(r)}return I(i)},X.order=function(){for(var n=-1,t=this.length;++n<t;)for(var e,r=this[n],i=r.length-1,u=r[i];--i>=0;)(e=r[i])&&(u&&u!==e.nextSibling&&u.parentNode.insertBefore(e,u),u=e);return this},X.sort=function(n){n=function(n){arguments.length||(n=s);return function(t,e){return t&&e?n(t.__data__,e.__data__):!t-!e}}.apply(this,arguments);for(var t=-1,e=this.length;++t<e;)this[t].sort(n);return this.order()},X.each=function(n){return fn(this,function(t,e,r){n.call(t,t.__data__,e,r)})},X.call=function(n){var t=e(arguments);return n.apply(t[0]=this,t),this},X.empty=function(){return!this.node()},X.node=function(){for(var n=0,t=this.length;n<t;n++)for(var e=this[n],r=0,i=e.length;r<i;r++){var u=e[r];if(u)return u}return null},X.size=function(){var n=0;return fn(this,function(){++n}),n};var hn=[];function pn(t,r,i){var u="__on"+t,o=t.indexOf("."),a=vn;o>0&&(t=t.slice(0,o));var l=gn.get(t);function c(){var n=this[u];n&&(this.removeEventListener(t,n,n.$),delete this[u])}return l&&(t=l,a=dn),o?r?function(){var n=a(r,e(arguments));c.call(this),this.addEventListener(t,this[u]=n,n.$=i),n._=r}:c:r?R:function(){var e,r=new RegExp("^__on([^.]+)"+n.requote(t)+"$");for(var i in this)if(e=i.match(r)){var u=this[i];this.removeEventListener(e[1],u,u.$),delete this[i]}}}n.selection.enter=sn,n.selection.enter.prototype=hn,hn.append=X.append,hn.empty=X.empty,hn.node=X.node,hn.call=X.call,hn.size=X.size,hn.select=function(n){for(var t,e,r,i,u,o=[],a=-1,l=this.length;++a<l;){r=(i=this[a]).update,o.push(t=[]),t.parentNode=i.parentNode;for(var c=-1,f=i.length;++c<f;)(u=i[c])?(t.push(r[c]=e=n.call(i.parentNode,u.__data__,c,a)),e.__data__=u.__data__):t.push(null)}return I(o)},hn.insert=function(n,t){var e,r,i;return arguments.length<2&&(e=this,t=function(n,t,u){var o,a=e[u].update,l=a.length;for(u!=i&&(i=u,r=0),t>=r&&(r=t+1);!(o=a[r])&&++r<l;);return o}),X.insert.call(this,n,t)},n.select=function(n){var t;return"string"==typeof n?(t=[Y(n,r)]).parentNode=r.documentElement:(t=[n]).parentNode=i(n),I([t])},n.selectAll=function(n){var t;return"string"==typeof n?(t=e(Z(n,r))).parentNode=r.documentElement:(t=e(n)).parentNode=null,I([t])},X.on=function(n,t,e){var r=arguments.length;if(r<3){if("string"!=typeof n){for(e in r<2&&(t=!1),n)this.each(pn(e,n[e],t));return this}if(r<2)return(r=this.node()["__on"+n])&&r._;e=!1}return this.each(pn(n,t,e))};var gn=n.map({mouseenter:"mouseover",mouseleave:"mouseout"});function vn(t,e){return function(r){var i=n.event;n.event=r,e[0]=this.__data__;try{t.apply(this,e)}finally{n.event=i}}}function dn(n,t){var e=vn(n,t);return function(n){var t=n.relatedTarget;t&&(t===this||8&t.compareDocumentPosition(this))||e.call(this,n)}}r&&gn.forEach(function(n){"on"+n in r&&gn.remove(n)});var yn,mn=0;function Mn(t){var e=".dragsuppress-"+ ++mn,r="click"+e,o=n.select(u(t)).on("touchmove"+e,U).on("dragstart"+e,U).on("selectstart"+e,U);if(null==yn&&(yn=!("onselectstart"in t)&&q(t.style,"userSelect")),yn){var a=i(t).style,l=a[yn];a[yn]="none"}return function(n){if(o.on(e,null),yn&&(a[yn]=l),n){var t=function(){o.on(r,null)};o.on(r,function(){U(),t()},!0),setTimeout(t,0)}}}n.mouse=function(n){return bn(n,j())};var xn=this.navigator&&/WebKit/.test(this.navigator.userAgent)?-1:0;function bn(t,e){e.changedTouches&&(e=e.changedTouches[0]);var r=t.ownerSVGElement||t;if(r.createSVGPoint){var i=r.createSVGPoint();if(xn<0){var o=u(t);if(o.scrollX||o.scrollY){var a=(r=n.select("body").append("svg").style({position:"absolute",top:0,left:0,margin:0,padding:0,border:"none"},"important"))[0][0].getScreenCTM();xn=!(a.f||a.e),r.remove()}}return xn?(i.x=e.pageX,i.y=e.pageY):(i.x=e.clientX,i.y=e.clientY),[(i=i.matrixTransform(t.getScreenCTM().inverse())).x,i.y]}var l=t.getBoundingClientRect();return[e.clientX-l.left-t.clientLeft,e.clientY-l.top-t.clientTop]}function _n(){return n.event.changedTouches[0].identifier}n.touch=function(n,t,e){if(arguments.length<3&&(e=t,t=j().changedTouches),t)for(var r,i=0,u=t.length;i<u;++i)if((r=t[i]).identifier===e)return bn(n,r)},n.behavior.drag=function(){var t=F(o,"drag","dragstart","dragend"),e=null,r=a(R,n.mouse,u,"mousemove","mouseup"),i=a(_n,n.touch,z,"touchmove","touchend");function o(){this.on("mousedown.drag",r).on("touchstart.drag",i)}function a(r,i,u,o,a){return function(){var l,c=n.event.target.correspondingElement||n.event.target,f=this.parentNode,s=t.of(this,arguments),h=0,p=r(),g=".drag"+(null==p?"":"-"+p),v=n.select(u(c)).on(o+g,function(){var n,t,e=i(f,p);if(!e)return;n=e[0]-y[0],t=e[1]-y[1],h|=n|t,y=e,s({type:"drag",x:e[0]+l[0],y:e[1]+l[1],dx:n,dy:t})}).on(a+g,function(){if(!i(f,p))return;v.on(o+g,null).on(a+g,null),d(h),s({type:"dragend"})}),d=Mn(c),y=i(f,p);l=e?[(l=e.apply(this,arguments)).x-y[0],l.y-y[1]]:[0,0],s({type:"dragstart"})}}return o.origin=function(n){return arguments.length?(e=n,o):e},n.rebind(o,t,"on")},n.touches=function(n,t){return arguments.length<2&&(t=j().touches),t?e(t).map(function(t){var e=bn(n,t);return e.identifier=t.identifier,e}):[]};var wn=1e-6,Sn=wn*wn,kn=Math.PI,Nn=2*kn,En=Nn-wn,An=kn/2,Cn=kn/180,zn=180/kn;function Ln(n){return n>0?1:n<0?-1:0}function qn(n,t,e){return(t[0]-n[0])*(e[1]-n[1])-(t[1]-n[1])*(e[0]-n[0])}function Tn(n){return n>1?0:n<-1?kn:Math.acos(n)}function Rn(n){return n>1?An:n<-1?-An:Math.asin(n)}function Dn(n){return((n=Math.exp(n))+1/n)/2}function Pn(n){return(n=Math.sin(n/2))*n}var Un=Math.SQRT2;n.interpolateZoom=function(n,t){var e,r,i=n[0],u=n[1],o=n[2],a=t[0],l=t[1],c=t[2],f=a-i,s=l-u,h=f*f+s*s;if(h<Sn)r=Math.log(c/o)/Un,e=function(n){return[i+n*f,u+n*s,o*Math.exp(Un*n*r)]};else{var p=Math.sqrt(h),g=(c*c-o*o+4*h)/(2*o*2*p),v=(c*c-o*o-4*h)/(2*c*2*p),d=Math.log(Math.sqrt(g*g+1)-g),y=Math.log(Math.sqrt(v*v+1)-v);r=(y-d)/Un,e=function(n){var t,e=n*r,a=Dn(d),l=o/(2*p)*(a*(t=Un*e+d,((t=Math.exp(2*t))-1)/(t+1))-function(n){return((n=Math.exp(n))-1/n)/2}(d));return[i+l*f,u+l*s,o*a/Dn(Un*e+d)]}}return e.duration=1e3*r,e},n.behavior.zoom=function(){var t,e,i,o,a,l,c,f,s,h={x:0,y:0,k:1},p=[960,500],g=Hn,v=250,d=0,y="mousedown.zoom",m="mousemove.zoom",M="mouseup.zoom",x="touchstart.zoom",b=F(_,"zoomstart","zoom","zoomend");function _(n){n.on(y,L).on(Fn+".zoom",T).on("dblclick.zoom",R).on(x,q)}function w(n){return[(n[0]-h.x)/h.k,(n[1]-h.y)/h.k]}function S(n){h.k=Math.max(g[0],Math.min(g[1],n))}function k(n,t){t=function(n){return[n[0]*h.k+h.x,n[1]*h.k+h.y]}(t),h.x+=n[0]-t[0],h.y+=n[1]-t[1]}function N(t,r,i,u){t.__chart__={x:h.x,y:h.y,k:h.k},S(Math.pow(2,u)),k(e=r,i),t=n.select(t),v>0&&(t=t.transition().duration(v)),t.call(_.event)}function E(){c&&c.domain(l.range().map(function(n){return(n-h.x)/h.k}).map(l.invert)),s&&s.domain(f.range().map(function(n){return(n-h.y)/h.k}).map(f.invert))}function A(n){d++||n({type:"zoomstart"})}function C(n){E(),n({type:"zoom",scale:h.k,translate:[h.x,h.y]})}function z(n){--d||(n({type:"zoomend"}),e=null)}function L(){var t=this,e=b.of(t,arguments),r=0,i=n.select(u(t)).on(m,function(){r=1,k(n.mouse(t),o),C(e)}).on(M,function(){i.on(m,null).on(M,null),a(r),z(e)}),o=w(n.mouse(t)),a=Mn(t);oa.call(t),A(e)}function q(){var t,e=this,r=b.of(e,arguments),i={},u=0,o=".zoom-"+n.event.changedTouches[0].identifier,l="touchmove"+o,c="touchend"+o,f=[],s=n.select(e),p=Mn(e);function g(){var r=n.touches(e);return t=h.k,r.forEach(function(n){n.identifier in i&&(i[n.identifier]=w(n))}),r}function v(){var t=n.event.target;n.select(t).on(l,d).on(c,m),f.push(t);for(var r=n.event.changedTouches,o=0,s=r.length;o<s;++o)i[r[o].identifier]=null;var p=g(),v=Date.now();if(1===p.length){if(v-a<500){var y=p[0];N(e,y,i[y.identifier],Math.floor(Math.log(h.k)/Math.LN2)+1),U()}a=v}else if(p.length>1){y=p[0];var M=p[1],x=y[0]-M[0],b=y[1]-M[1];u=x*x+b*b}}function d(){var o,l,c,f,s=n.touches(e);oa.call(e);for(var h=0,p=s.length;h<p;++h,f=null)if(c=s[h],f=i[c.identifier]){if(l)break;o=c,l=f}if(f){var g=(g=c[0]-o[0])*g+(g=c[1]-o[1])*g,v=u&&Math.sqrt(g/u);o=[(o[0]+c[0])/2,(o[1]+c[1])/2],l=[(l[0]+f[0])/2,(l[1]+f[1])/2],S(v*t)}a=null,k(o,l),C(r)}function m(){if(n.event.touches.length){for(var t=n.event.changedTouches,e=0,u=t.length;e<u;++e)delete i[t[e].identifier];for(var a in i)return void g()}n.selectAll(f).on(o,null),s.on(y,L).on(x,q),p(),z(r)}v(),A(r),s.on(y,null).on(x,v)}function T(){var r=b.of(this,arguments);o?clearTimeout(o):(oa.call(this),t=w(e=i||n.mouse(this)),A(r)),o=setTimeout(function(){o=null,z(r)},50),U(),S(Math.pow(2,.002*jn())*h.k),k(e,t),C(r)}function R(){var t=n.mouse(this),e=Math.log(h.k)/Math.LN2;N(this,t,w(t),n.event.shiftKey?Math.ceil(e)-1:Math.floor(e)+1)}return Fn||(Fn="onwheel"in r?(jn=function(){return-n.event.deltaY*(n.event.deltaMode?120:1)},"wheel"):"onmousewheel"in r?(jn=function(){return n.event.wheelDelta},"mousewheel"):(jn=function(){return-n.event.detail},"MozMousePixelScroll")),_.event=function(t){t.each(function(){var t=b.of(this,arguments),r=h;ca?n.select(this).transition().each("start.zoom",function(){h=this.__chart__||{x:0,y:0,k:1},A(t)}).tween("zoom:zoom",function(){var i=p[0],u=p[1],o=e?e[0]:i/2,a=e?e[1]:u/2,l=n.interpolateZoom([(o-h.x)/h.k,(a-h.y)/h.k,i/h.k],[(o-r.x)/r.k,(a-r.y)/r.k,i/r.k]);return function(n){var e=l(n),r=i/e[2];this.__chart__=h={x:o-e[0]*r,y:a-e[1]*r,k:r},C(t)}}).each("interrupt.zoom",function(){z(t)}).each("end.zoom",function(){z(t)}):(this.__chart__=h,A(t),C(t),z(t))})},_.translate=function(n){return arguments.length?(h={x:+n[0],y:+n[1],k:h.k},E(),_):[h.x,h.y]},_.scale=function(n){return arguments.length?(h={x:h.x,y:h.y,k:null},S(+n),E(),_):h.k},_.scaleExtent=function(n){return arguments.length?(g=null==n?Hn:[+n[0],+n[1]],_):g},_.center=function(n){return arguments.length?(i=n&&[+n[0],+n[1]],_):i},_.size=function(n){return arguments.length?(p=n&&[+n[0],+n[1]],_):p},_.duration=function(n){return arguments.length?(v=+n,_):v},_.x=function(n){return arguments.length?(c=n,l=n.copy(),h={x:0,y:0,k:1},_):c},_.y=function(n){return arguments.length?(s=n,f=n.copy(),h={x:0,y:0,k:1},_):s},n.rebind(_,b,"on")};var jn,Fn,Hn=[0,1/0];function On(){}function In(n,t,e){return this instanceof In?(this.h=+n,this.s=+t,void(this.l=+e)):arguments.length<2?n instanceof In?new In(n.h,n.s,n.l):ft(""+n,st,In):new In(n,t,e)}n.color=On,On.prototype.toString=function(){return this.rgb()+""},n.hsl=In;var Yn=In.prototype=new On;function Zn(n,t,e){var r,i;function u(n){return Math.round(255*function(n){return n>360?n-=360:n<0&&(n+=360),n<60?r+(i-r)*n/60:n<180?i:n<240?r+(i-r)*(240-n)/60:r}(n))}return n=isNaN(n)?0:(n%=360)<0?n+360:n,t=isNaN(t)?0:t<0?0:t>1?1:t,r=2*(e=e<0?0:e>1?1:e)-(i=e<=.5?e*(1+t):e+t-e*t),new ut(u(n+120),u(n),u(n-120))}function Vn(t,e,r){return this instanceof Vn?(this.h=+t,this.c=+e,void(this.l=+r)):arguments.length<2?t instanceof Vn?new Vn(t.h,t.c,t.l):tt(t instanceof Bn?t.l:(t=ht((t=n.rgb(t)).r,t.g,t.b)).l,t.a,t.b):new Vn(t,e,r)}Yn.brighter=function(n){return n=Math.pow(.7,arguments.length?n:1),new In(this.h,this.s,this.l/n)},Yn.darker=function(n){return n=Math.pow(.7,arguments.length?n:1),new In(this.h,this.s,n*this.l)},Yn.rgb=function(){return Zn(this.h,this.s,this.l)},n.hcl=Vn;var Xn=Vn.prototype=new On;function $n(n,t,e){return isNaN(n)&&(n=0),isNaN(t)&&(t=0),new Bn(e,Math.cos(n*=Cn)*t,Math.sin(n)*t)}function Bn(n,t,e){return this instanceof Bn?(this.l=+n,this.a=+t,void(this.b=+e)):arguments.length<2?n instanceof Bn?new Bn(n.l,n.a,n.b):n instanceof Vn?$n(n.h,n.c,n.l):ht((n=ut(n)).r,n.g,n.b):new Bn(n,t,e)}Xn.brighter=function(n){return new Vn(this.h,this.c,Math.min(100,this.l+Wn*(arguments.length?n:1)))},Xn.darker=function(n){return new Vn(this.h,this.c,Math.max(0,this.l-Wn*(arguments.length?n:1)))},Xn.rgb=function(){return $n(this.h,this.c,this.l).rgb()},n.lab=Bn;var Wn=18,Jn=.95047,Gn=1,Kn=1.08883,Qn=Bn.prototype=new On;function nt(n,t,e){var r=(n+16)/116,i=r+t/500,u=r-e/200;return new ut(it(3.2404542*(i=et(i)*Jn)-1.5371385*(r=et(r)*Gn)-.4985314*(u=et(u)*Kn)),it(-.969266*i+1.8760108*r+.041556*u),it(.0556434*i-.2040259*r+1.0572252*u))}function tt(n,t,e){return n>0?new Vn(Math.atan2(e,t)*zn,Math.sqrt(t*t+e*e),n):new Vn(NaN,NaN,n)}function et(n){return n>.206893034?n*n*n:(n-4/29)/7.787037}function rt(n){return n>.008856?Math.pow(n,1/3):7.787037*n+4/29}function it(n){return Math.round(255*(n<=.00304?12.92*n:1.055*Math.pow(n,1/2.4)-.055))}function ut(n,t,e){return this instanceof ut?(this.r=~~n,this.g=~~t,void(this.b=~~e)):arguments.length<2?n instanceof ut?new ut(n.r,n.g,n.b):ft(""+n,ut,Zn):new ut(n,t,e)}function ot(n){return new ut(n>>16,n>>8&255,255&n)}function at(n){return ot(n)+""}Qn.brighter=function(n){return new Bn(Math.min(100,this.l+Wn*(arguments.length?n:1)),this.a,this.b)},Qn.darker=function(n){return new Bn(Math.max(0,this.l-Wn*(arguments.length?n:1)),this.a,this.b)},Qn.rgb=function(){return nt(this.l,this.a,this.b)},n.rgb=ut;var lt=ut.prototype=new On;function ct(n){return n<16?"0"+Math.max(0,n).toString(16):Math.min(255,n).toString(16)}function ft(n,t,e){var r,i,u,o=0,a=0,l=0;if(r=/([a-z]+)\((.*)\)/.exec(n=n.toLowerCase()))switch(i=r[2].split(","),r[1]){case"hsl":return e(parseFloat(i[0]),parseFloat(i[1])/100,parseFloat(i[2])/100);case"rgb":return t(gt(i[0]),gt(i[1]),gt(i[2]))}return(u=vt.get(n))?t(u.r,u.g,u.b):(null==n||"#"!==n.charAt(0)||isNaN(u=parseInt(n.slice(1),16))||(4===n.length?(o=(3840&u)>>4,o|=o>>4,a=240&u,a|=a>>4,l=15&u,l|=l<<4):7===n.length&&(o=(16711680&u)>>16,a=(65280&u)>>8,l=255&u)),t(o,a,l))}function st(n,t,e){var r,i,u=Math.min(n/=255,t/=255,e/=255),o=Math.max(n,t,e),a=o-u,l=(o+u)/2;return a?(i=l<.5?a/(o+u):a/(2-o-u),r=n==o?(t-e)/a+(t<e?6:0):t==o?(e-n)/a+2:(n-t)/a+4,r*=60):(r=NaN,i=l>0&&l<1?0:r),new In(r,i,l)}function ht(n,t,e){var r=rt((.4124564*(n=pt(n))+.3575761*(t=pt(t))+.1804375*(e=pt(e)))/Jn),i=rt((.2126729*n+.7151522*t+.072175*e)/Gn);return Bn(116*i-16,500*(r-i),200*(i-rt((.0193339*n+.119192*t+.9503041*e)/Kn)))}function pt(n){return(n/=255)<=.04045?n/12.92:Math.pow((n+.055)/1.055,2.4)}function gt(n){var t=parseFloat(n);return"%"===n.charAt(n.length-1)?Math.round(2.55*t):t}lt.brighter=function(n){n=Math.pow(.7,arguments.length?n:1);var t=this.r,e=this.g,r=this.b,i=30;return t||e||r?(t&&t<i&&(t=i),e&&e<i&&(e=i),r&&r<i&&(r=i),new ut(Math.min(255,t/n),Math.min(255,e/n),Math.min(255,r/n))):new ut(i,i,i)},lt.darker=function(n){return new ut((n=Math.pow(.7,arguments.length?n:1))*this.r,n*this.g,n*this.b)},lt.hsl=function(){return st(this.r,this.g,this.b)},lt.toString=function(){return"#"+ct(this.r)+ct(this.g)+ct(this.b)};var vt=n.map({aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074});function dt(n){return"function"==typeof n?n:function(){return n}}function yt(n){return function(t,e,r){return 2===arguments.length&&"function"==typeof e&&(r=e,e=null),mt(t,e,n,r)}}function mt(t,r,i,u){var o={},a=n.dispatch("beforesend","progress","load","error"),l={},c=new XMLHttpRequest,f=null;function s(){var n,t=c.status;if(!t&&function(n){var t=n.responseType;return t&&"text"!==t?n.response:n.responseText}(c)||t>=200&&t<300||304===t){try{n=i.call(o,c)}catch(n){return void a.error.call(o,n)}a.load.call(o,n)}else a.error.call(o,c)}return!this.XDomainRequest||"withCredentials"in c||!/^(http(s)?:)?\/\//.test(t)||(c=new XDomainRequest),"onload"in c?c.onload=c.onerror=s:c.onreadystatechange=function(){c.readyState>3&&s()},c.onprogress=function(t){var e=n.event;n.event=t;try{a.progress.call(o,c)}finally{n.event=e}},o.header=function(n,t){return n=(n+"").toLowerCase(),arguments.length<2?l[n]:(null==t?delete l[n]:l[n]=t+"",o)},o.mimeType=function(n){return arguments.length?(r=null==n?null:n+"",o):r},o.responseType=function(n){return arguments.length?(f=n,o):f},o.response=function(n){return i=n,o},["get","post"].forEach(function(n){o[n]=function(){return o.send.apply(o,[n].concat(e(arguments)))}}),o.send=function(n,e,i){if(2===arguments.length&&"function"==typeof e&&(i=e,e=null),c.open(n,t,!0),null==r||"accept"in l||(l.accept=r+",*/*"),c.setRequestHeader)for(var u in l)c.setRequestHeader(u,l[u]);return null!=r&&c.overrideMimeType&&c.overrideMimeType(r),null!=f&&(c.responseType=f),null!=i&&o.on("error",i).on("load",function(n){i(null,n)}),a.beforesend.call(o,c),c.send(null==e?null:e),o},o.abort=function(){return c.abort(),o},n.rebind(o,a,"on"),null==u?o:o.get(function(n){return 1===n.length?function(t,e){n(null==t?e:null)}:n}(u))}vt.forEach(function(n,t){vt.set(n,ot(t))}),n.functor=dt,n.xhr=yt(z),n.dsv=function(n,t){var e=new RegExp('["'+n+"\n]"),r=n.charCodeAt(0);function i(n,e,r){arguments.length<3&&(r=e,e=null);var i=mt(n,t,null==e?u:o(e),r);return i.row=function(n){return arguments.length?i.response(null==(e=n)?u:o(n)):e},i}function u(n){return i.parse(n.responseText)}function o(n){return function(t){return i.parse(t.responseText,n)}}function a(t){return t.map(l).join(n)}function l(n){return e.test(n)?'"'+n.replace(/\"/g,'""')+'"':n}return i.parse=function(n,t){var e;return i.parseRows(n,function(n,r){if(e)return e(n,r-1);var i=new Function("d","return {"+n.map(function(n,t){return JSON.stringify(n)+": d["+t+"]"}).join(",")+"}");e=t?function(n,e){return t(i(n),e)}:i})},i.parseRows=function(n,t){var e,i,u={},o={},a=[],l=n.length,c=0,f=0;function s(){if(c>=l)return o;if(i)return i=!1,u;var t=c;if(34===n.charCodeAt(t)){for(var e=t;e++<l;)if(34===n.charCodeAt(e)){if(34!==n.charCodeAt(e+1))break;++e}return c=e+2,13===(a=n.charCodeAt(e+1))?(i=!0,10===n.charCodeAt(e+2)&&++c):10===a&&(i=!0),n.slice(t+1,e).replace(/""/g,'"')}for(;c<l;){var a,f=1;if(10===(a=n.charCodeAt(c++)))i=!0;else if(13===a)i=!0,10===n.charCodeAt(c)&&(++c,++f);else if(a!==r)continue;return n.slice(t,c-f)}return n.slice(t)}for(;(e=s())!==o;){for(var h=[];e!==u&&e!==o;)h.push(e),e=s();t&&null==(h=t(h,f++))||a.push(h)}return a},i.format=function(t){if(Array.isArray(t[0]))return i.formatRows(t);var e=new C,r=[];return t.forEach(function(n){for(var t in n)e.has(t)||r.push(e.add(t))}),[r.map(l).join(n)].concat(t.map(function(t){return r.map(function(n){return l(t[n])}).join(n)})).join("\n")},i.formatRows=function(n){return n.map(a).join("\n")},i},n.csv=n.dsv(",","text/csv"),n.tsv=n.dsv("\t","text/tab-separated-values");var Mt,xt,bt,_t,wt=this[q(this,"requestAnimationFrame")]||function(n){setTimeout(n,17)};function St(n,t,e){var r=arguments.length;r<2&&(t=0),r<3&&(e=Date.now());var i={c:n,t:e+t,n:null};return xt?xt.n=i:Mt=i,xt=i,bt||(_t=clearTimeout(_t),bt=1,wt(kt)),i}function kt(){var n=Nt(),t=Et()-n;t>24?(isFinite(t)&&(clearTimeout(_t),_t=setTimeout(kt,t)),bt=0):(bt=1,wt(kt))}function Nt(){for(var n=Date.now(),t=Mt;t;)n>=t.t&&t.c(n-t.t)&&(t.c=null),t=t.n;return n}function Et(){for(var n,t=Mt,e=1/0;t;)t.c?(t.t<e&&(e=t.t),t=(n=t).n):t=n?n.n=t.n:Mt=t.n;return xt=n,e}function At(n,t){return t-(n?Math.ceil(Math.log(n)/Math.LN10):1)}n.timer=function(){St.apply(this,arguments)},n.timer.flush=function(){Nt(),Et()},n.round=function(n,t){return t?Math.round(n*(t=Math.pow(10,t)))/t:Math.round(n)};var Ct=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"].map(function(n,t){var e=Math.pow(10,3*y(8-t));return{scale:t>8?function(n){return n/e}:function(n){return n*e},symbol:n}});n.formatPrefix=function(t,e){var r=0;return(t=+t)&&(t<0&&(t*=-1),e&&(t=n.round(t,At(t,e))),r=1+Math.floor(1e-12+Math.log(t)/Math.LN10),r=Math.max(-24,Math.min(24,3*Math.floor((r-1)/3)))),Ct[8+r/3]};var zt=/(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,Lt=n.map({b:function(n){return n.toString(2)},c:function(n){return String.fromCharCode(n)},o:function(n){return n.toString(8)},x:function(n){return n.toString(16)},X:function(n){return n.toString(16).toUpperCase()},g:function(n,t){return n.toPrecision(t)},e:function(n,t){return n.toExponential(t)},f:function(n,t){return n.toFixed(t)},r:function(t,e){return(t=n.round(t,At(t,e))).toFixed(Math.max(0,Math.min(20,At(t*(1+1e-15),e))))}});function qt(n){return n+""}var Tt=n.time={},Rt=Date;function Dt(){this._=new Date(arguments.length>1?Date.UTC.apply(this,arguments):arguments[0])}Dt.prototype={getDate:function(){return this._.getUTCDate()},getDay:function(){return this._.getUTCDay()},getFullYear:function(){return this._.getUTCFullYear()},getHours:function(){return this._.getUTCHours()},getMilliseconds:function(){return this._.getUTCMilliseconds()},getMinutes:function(){return this._.getUTCMinutes()},getMonth:function(){return this._.getUTCMonth()},getSeconds:function(){return this._.getUTCSeconds()},getTime:function(){return this._.getTime()},getTimezoneOffset:function(){return 0},valueOf:function(){return this._.valueOf()},setDate:function(){Pt.setUTCDate.apply(this._,arguments)},setDay:function(){Pt.setUTCDay.apply(this._,arguments)},setFullYear:function(){Pt.setUTCFullYear.apply(this._,arguments)},setHours:function(){Pt.setUTCHours.apply(this._,arguments)},setMilliseconds:function(){Pt.setUTCMilliseconds.apply(this._,arguments)},setMinutes:function(){Pt.setUTCMinutes.apply(this._,arguments)},setMonth:function(){Pt.setUTCMonth.apply(this._,arguments)},setSeconds:function(){Pt.setUTCSeconds.apply(this._,arguments)},setTime:function(){Pt.setTime.apply(this._,arguments)}};var Pt=Date.prototype;function Ut(n,t,e){function r(t){var e=n(t),r=u(e,1);return t-e<r-t?e:r}function i(e){return t(e=n(new Rt(e-1)),1),e}function u(n,e){return t(n=new Rt(+n),e),n}function o(n,r,u){var o=i(n),a=[];if(u>1)for(;o<r;)e(o)%u||a.push(new Date(+o)),t(o,1);else for(;o<r;)a.push(new Date(+o)),t(o,1);return a}n.floor=n,n.round=r,n.ceil=i,n.offset=u,n.range=o;var a=n.utc=jt(n);return a.floor=a,a.round=jt(r),a.ceil=jt(i),a.offset=jt(u),a.range=function(n,t,e){try{Rt=Dt;var r=new Dt;return r._=n,o(r,t,e)}finally{Rt=Date}},n}function jt(n){return function(t,e){try{Rt=Dt;var r=new Dt;return r._=t,n(r,e)._}finally{Rt=Date}}}Tt.year=Ut(function(n){return(n=Tt.day(n)).setMonth(0,1),n},function(n,t){n.setFullYear(n.getFullYear()+t)},function(n){return n.getFullYear()}),Tt.years=Tt.year.range,Tt.years.utc=Tt.year.utc.range,Tt.day=Ut(function(n){var t=new Rt(2e3,0);return t.setFullYear(n.getFullYear(),n.getMonth(),n.getDate()),t},function(n,t){n.setDate(n.getDate()+t)},function(n){return n.getDate()-1}),Tt.days=Tt.day.range,Tt.days.utc=Tt.day.utc.range,Tt.dayOfYear=function(n){var t=Tt.year(n);return Math.floor((n-t-6e4*(n.getTimezoneOffset()-t.getTimezoneOffset()))/864e5)},["sunday","monday","tuesday","wednesday","thursday","friday","saturday"].forEach(function(n,t){t=7-t;var e=Tt[n]=Ut(function(n){return(n=Tt.day(n)).setDate(n.getDate()-(n.getDay()+t)%7),n},function(n,t){n.setDate(n.getDate()+7*Math.floor(t))},function(n){var e=Tt.year(n).getDay();return Math.floor((Tt.dayOfYear(n)+(e+t)%7)/7)-(e!==t)});Tt[n+"s"]=e.range,Tt[n+"s"].utc=e.utc.range,Tt[n+"OfYear"]=function(n){var e=Tt.year(n).getDay();return Math.floor((Tt.dayOfYear(n)+(e+t)%7)/7)}}),Tt.week=Tt.sunday,Tt.weeks=Tt.sunday.range,Tt.weeks.utc=Tt.sunday.utc.range,Tt.weekOfYear=Tt.sundayOfYear;var Ft={"-":"",_:" ",0:"0"},Ht=/^\s*\d+/,Ot=/^%/;function It(n,t,e){var r=n<0?"-":"",i=(r?-n:n)+"",u=i.length;return r+(u<e?new Array(e-u+1).join(t)+i:i)}function Yt(t){return new RegExp("^(?:"+t.map(n.requote).join("|")+")","i")}function Zt(n){for(var t=new M,e=-1,r=n.length;++e<r;)t.set(n[e].toLowerCase(),e);return t}function Vt(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+1));return r?(n.w=+r[0],e+r[0].length):-1}function Xt(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e));return r?(n.U=+r[0],e+r[0].length):-1}function $t(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e));return r?(n.W=+r[0],e+r[0].length):-1}function Bt(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+4));return r?(n.y=+r[0],e+r[0].length):-1}function Wt(n,t,e){Ht.lastIndex=0;var r,i=Ht.exec(t.slice(e,e+2));return i?(n.y=(r=+i[0])+(r>68?1900:2e3),e+i[0].length):-1}function Jt(n,t,e){return/^[+-]\d{4}$/.test(t=t.slice(e,e+5))?(n.Z=-t,e+5):-1}function Gt(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+2));return r?(n.m=r[0]-1,e+r[0].length):-1}function Kt(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+2));return r?(n.d=+r[0],e+r[0].length):-1}function Qt(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+3));return r?(n.j=+r[0],e+r[0].length):-1}function ne(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+2));return r?(n.H=+r[0],e+r[0].length):-1}function te(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+2));return r?(n.M=+r[0],e+r[0].length):-1}function ee(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+2));return r?(n.S=+r[0],e+r[0].length):-1}function re(n,t,e){Ht.lastIndex=0;var r=Ht.exec(t.slice(e,e+3));return r?(n.L=+r[0],e+r[0].length):-1}function ie(n){var t=n.getTimezoneOffset(),e=t>0?"-":"+",r=y(t)/60|0,i=y(t)%60;return e+It(r,"0",2)+It(i,"0",2)}function ue(n,t,e){Ot.lastIndex=0;var r=Ot.exec(t.slice(e,e+1));return r?e+r[0].length:-1}function oe(n){for(var t=n.length,e=-1;++e<t;)n[e][0]=this(n[e][0]);return function(t){for(var e=0,r=n[e];!r[1](t);)r=n[++e];return r[0](t)}}n.locale=function(t){return{numberFormat:function(t){var e=t.decimal,r=t.thousands,i=t.grouping,u=t.currency,o=i&&r?function(n,t){for(var e=n.length,u=[],o=0,a=i[0],l=0;e>0&&a>0&&(l+a+1>t&&(a=Math.max(1,t-l)),u.push(n.substring(e-=a,e+a)),!((l+=a+1)>t));)a=i[o=(o+1)%i.length];return u.reverse().join(r)}:z;return function(t){var r=zt.exec(t),i=r[1]||" ",a=r[2]||">",l=r[3]||"-",c=r[4]||"",f=r[5],s=+r[6],h=r[7],p=r[8],g=r[9],v=1,d="",y="",m=!1,M=!0;switch(p&&(p=+p.substring(1)),(f||"0"===i&&"="===a)&&(f=i="0",a="="),g){case"n":h=!0,g="g";break;case"%":v=100,y="%",g="f";break;case"p":v=100,y="%",g="r";break;case"b":case"o":case"x":case"X":"#"===c&&(d="0"+g.toLowerCase());case"c":M=!1;case"d":m=!0,p=0;break;case"s":v=-1,g="r"}"$"===c&&(d=u[0],y=u[1]),"r"!=g||p||(g="g"),null!=p&&("g"==g?p=Math.max(1,Math.min(21,p)):"e"!=g&&"f"!=g||(p=Math.max(0,Math.min(20,p)))),g=Lt.get(g)||qt;var x=f&&h;return function(t){var r=y;if(m&&t%1)return"";var u=t<0||0===t&&1/t<0?(t=-t,"-"):"-"===l?"":l;if(v<0){var c=n.formatPrefix(t,p);t=c.scale(t),r=c.symbol+y}else t*=v;var b,_,w=(t=g(t,p)).lastIndexOf(".");if(w<0){var S=M?t.lastIndexOf("e"):-1;S<0?(b=t,_=""):(b=t.substring(0,S),_=t.substring(S))}else b=t.substring(0,w),_=e+t.substring(w+1);!f&&h&&(b=o(b,1/0));var k=d.length+b.length+_.length+(x?0:u.length),N=k<s?new Array(k=s-k+1).join(i):"";return x&&(b=o(N+b,N.length?s-_.length:1/0)),u+=d,t=b+_,("<"===a?u+t+N:">"===a?N+u+t:"^"===a?N.substring(0,k>>=1)+u+t+N.substring(k):u+(x?t:N+t))+r}}}(t),timeFormat:function(t){var e=t.dateTime,r=t.date,i=t.time,u=t.periods,o=t.days,a=t.shortDays,l=t.months,c=t.shortMonths;function f(n){var t=n.length;function e(e){for(var r,i,u,o=[],a=-1,l=0;++a<t;)37===n.charCodeAt(a)&&(o.push(n.slice(l,a)),null!=(i=Ft[r=n.charAt(++a)])&&(r=n.charAt(++a)),(u=b[r])&&(r=u(e,null==i?"e"===r?" ":"0":i)),o.push(r),l=a+1);return o.push(n.slice(l,a)),o.join("")}return e.parse=function(t){var e={y:1900,m:0,d:1,H:0,M:0,S:0,L:0,Z:null};if(s(e,n,t,0)!=t.length)return null;"p"in e&&(e.H=e.H%12+12*e.p);var r=null!=e.Z&&Rt!==Dt,i=new(r?Dt:Rt);return"j"in e?i.setFullYear(e.y,0,e.j):"W"in e||"U"in e?("w"in e||(e.w="W"in e?1:0),i.setFullYear(e.y,0,1),i.setFullYear(e.y,0,"W"in e?(e.w+6)%7+7*e.W-(i.getDay()+5)%7:e.w+7*e.U-(i.getDay()+6)%7)):i.setFullYear(e.y,e.m,e.d),i.setHours(e.H+(e.Z/100|0),e.M+e.Z%100,e.S,e.L),r?i._:i},e.toString=function(){return n},e}function s(n,t,e,r){for(var i,u,o,a=0,l=t.length,c=e.length;a<l;){if(r>=c)return-1;if(37===(i=t.charCodeAt(a++))){if(o=t.charAt(a++),!(u=_[o in Ft?t.charAt(a++):o])||(r=u(n,e,r))<0)return-1}else if(i!=e.charCodeAt(r++))return-1}return r}f.utc=function(n){var t=f(n);function e(n){try{var e=new(Rt=Dt);return e._=n,t(e)}finally{Rt=Date}}return e.parse=function(n){try{Rt=Dt;var e=t.parse(n);return e&&e._}finally{Rt=Date}},e.toString=t.toString,e},f.multi=f.utc.multi=oe;var h=n.map(),p=Yt(o),g=Zt(o),v=Yt(a),d=Zt(a),y=Yt(l),m=Zt(l),M=Yt(c),x=Zt(c);u.forEach(function(n,t){h.set(n.toLowerCase(),t)});var b={a:function(n){return a[n.getDay()]},A:function(n){return o[n.getDay()]},b:function(n){return c[n.getMonth()]},B:function(n){return l[n.getMonth()]},c:f(e),d:function(n,t){return It(n.getDate(),t,2)},e:function(n,t){return It(n.getDate(),t,2)},H:function(n,t){return It(n.getHours(),t,2)},I:function(n,t){return It(n.getHours()%12||12,t,2)},j:function(n,t){return It(1+Tt.dayOfYear(n),t,3)},L:function(n,t){return It(n.getMilliseconds(),t,3)},m:function(n,t){return It(n.getMonth()+1,t,2)},M:function(n,t){return It(n.getMinutes(),t,2)},p:function(n){return u[+(n.getHours()>=12)]},S:function(n,t){return It(n.getSeconds(),t,2)},U:function(n,t){return It(Tt.sundayOfYear(n),t,2)},w:function(n){return n.getDay()},W:function(n,t){return It(Tt.mondayOfYear(n),t,2)},x:f(r),X:f(i),y:function(n,t){return It(n.getFullYear()%100,t,2)},Y:function(n,t){return It(n.getFullYear()%1e4,t,4)},Z:ie,"%":function(){return"%"}},_={a:function(n,t,e){v.lastIndex=0;var r=v.exec(t.slice(e));return r?(n.w=d.get(r[0].toLowerCase()),e+r[0].length):-1},A:function(n,t,e){p.lastIndex=0;var r=p.exec(t.slice(e));return r?(n.w=g.get(r[0].toLowerCase()),e+r[0].length):-1},b:function(n,t,e){M.lastIndex=0;var r=M.exec(t.slice(e));return r?(n.m=x.get(r[0].toLowerCase()),e+r[0].length):-1},B:function(n,t,e){y.lastIndex=0;var r=y.exec(t.slice(e));return r?(n.m=m.get(r[0].toLowerCase()),e+r[0].length):-1},c:function(n,t,e){return s(n,b.c.toString(),t,e)},d:Kt,e:Kt,H:ne,I:ne,j:Qt,L:re,m:Gt,M:te,p:function(n,t,e){var r=h.get(t.slice(e,e+=2).toLowerCase());return null==r?-1:(n.p=r,e)},S:ee,U:Xt,w:Vt,W:$t,x:function(n,t,e){return s(n,b.x.toString(),t,e)},X:function(n,t,e){return s(n,b.X.toString(),t,e)},y:Wt,Y:Bt,Z:Jt,"%":ue};return f}(t)}};var ae=n.locale({decimal:".",thousands:",",grouping:[3],currency:["$",""],dateTime:"%a %b %e %X %Y",date:"%m/%d/%Y",time:"%H:%M:%S",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});function le(){}n.format=ae.numberFormat,n.geo={},le.prototype={s:0,t:0,add:function(n){fe(n,this.t,ce),fe(ce.s,this.s,this),this.s?this.t+=ce.t:this.s=ce.t},reset:function(){this.s=this.t=0},valueOf:function(){return this.s}};var ce=new le;function fe(n,t,e){var r=e.s=n+t,i=r-n,u=r-i;e.t=n-u+(t-i)}function se(n,t){n&&pe.hasOwnProperty(n.type)&&pe[n.type](n,t)}n.geo.stream=function(n,t){n&&he.hasOwnProperty(n.type)?he[n.type](n,t):se(n,t)};var he={Feature:function(n,t){se(n.geometry,t)},FeatureCollection:function(n,t){for(var e=n.features,r=-1,i=e.length;++r<i;)se(e[r].geometry,t)}},pe={Sphere:function(n,t){t.sphere()},Point:function(n,t){n=n.coordinates,t.point(n[0],n[1],n[2])},MultiPoint:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)n=e[r],t.point(n[0],n[1],n[2])},LineString:function(n,t){ge(n.coordinates,t,0)},MultiLineString:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)ge(e[r],t,0)},Polygon:function(n,t){ve(n.coordinates,t)},MultiPolygon:function(n,t){for(var e=n.coordinates,r=-1,i=e.length;++r<i;)ve(e[r],t)},GeometryCollection:function(n,t){for(var e=n.geometries,r=-1,i=e.length;++r<i;)se(e[r],t)}};function ge(n,t,e){var r,i=-1,u=n.length-e;for(t.lineStart();++i<u;)r=n[i],t.point(r[0],r[1],r[2]);t.lineEnd()}function ve(n,t){var e=-1,r=n.length;for(t.polygonStart();++e<r;)ge(n[e],t,1);t.polygonEnd()}n.geo.area=function(t){return de=0,n.geo.stream(t,Ce),de};var de,ye,me,Me,xe,be,_e,we,Se,ke,Ne,Ee,Ae=new le,Ce={sphere:function(){de+=4*kn},point:R,lineStart:R,lineEnd:R,polygonStart:function(){Ae.reset(),Ce.lineStart=ze},polygonEnd:function(){var n=2*Ae;de+=n<0?4*kn+n:n,Ce.lineStart=Ce.lineEnd=Ce.point=R}};function ze(){var n,t,e,r,i;function u(n,t){t=t*Cn/2+kn/4;var u=(n*=Cn)-e,o=u>=0?1:-1,a=o*u,l=Math.cos(t),c=Math.sin(t),f=i*c,s=r*l+f*Math.cos(a),h=f*o*Math.sin(a);Ae.add(Math.atan2(h,s)),e=n,r=l,i=c}Ce.point=function(o,a){Ce.point=u,e=(n=o)*Cn,r=Math.cos(a=(t=a)*Cn/2+kn/4),i=Math.sin(a)},Ce.lineEnd=function(){u(n,t)}}function Le(n){var t=n[0],e=n[1],r=Math.cos(e);return[r*Math.cos(t),r*Math.sin(t),Math.sin(e)]}function qe(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]}function Te(n,t){return[n[1]*t[2]-n[2]*t[1],n[2]*t[0]-n[0]*t[2],n[0]*t[1]-n[1]*t[0]]}function Re(n,t){n[0]+=t[0],n[1]+=t[1],n[2]+=t[2]}function De(n,t){return[n[0]*t,n[1]*t,n[2]*t]}function Pe(n){var t=Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);n[0]/=t,n[1]/=t,n[2]/=t}function Ue(n){return[Math.atan2(n[1],n[0]),Rn(n[2])]}function je(n,t){return y(n[0]-t[0])<wn&&y(n[1]-t[1])<wn}n.geo.bounds=function(){var t,e,r,i,u,o,a,l,c,f,s,h={point:p,lineStart:v,lineEnd:d,polygonStart:function(){h.point=m,h.lineStart=M,h.lineEnd=x,c=0,Ce.polygonStart()},polygonEnd:function(){Ce.polygonEnd(),h.point=p,h.lineStart=v,h.lineEnd=d,Ae<0?(t=-(r=180),e=-(i=90)):c>wn?i=90:c<-wn&&(e=-90),s[0]=t,s[1]=r}};function p(n,u){f.push(s=[t=n,r=n]),u<e&&(e=u),u>i&&(i=u)}function g(n,o){var a=Le([n*Cn,o*Cn]);if(l){var c=Te(l,a),f=Te([c[1],-c[0],0],c);Pe(f),f=Ue(f);var s=n-u,h=s>0?1:-1,g=f[0]*zn*h,v=y(s)>180;if(v^(h*u<g&&g<h*n))(d=f[1]*zn)>i&&(i=d);else if(v^(h*u<(g=(g+360)%360-180)&&g<h*n)){var d;(d=-f[1]*zn)<e&&(e=d)}else o<e&&(e=o),o>i&&(i=o);v?n<u?b(t,n)>b(t,r)&&(r=n):b(n,r)>b(t,r)&&(t=n):r>=t?(n<t&&(t=n),n>r&&(r=n)):n>u?b(t,n)>b(t,r)&&(r=n):b(n,r)>b(t,r)&&(t=n)}else p(n,o);l=a,u=n}function v(){h.point=g}function d(){s[0]=t,s[1]=r,h.point=p,l=null}function m(n,t){if(l){var e=n-u;c+=y(e)>180?e+(e>0?360:-360):e}else o=n,a=t;Ce.point(n,t),g(n,t)}function M(){Ce.lineStart()}function x(){m(o,a),Ce.lineEnd(),y(c)>wn&&(t=-(r=180)),s[0]=t,s[1]=r,l=null}function b(n,t){return(t-=n)<0?t+360:t}function _(n,t){return n[0]-t[0]}function w(n,t){return t[0]<=t[1]?t[0]<=n&&n<=t[1]:n<t[0]||t[1]<n}return function(u){if(i=r=-(t=e=1/0),f=[],n.geo.stream(u,h),c=f.length){f.sort(_);for(var o=1,a=[v=f[0]];o<c;++o)w((p=f[o])[0],v)||w(p[1],v)?(b(v[0],p[1])>b(v[0],v[1])&&(v[1]=p[1]),b(p[0],v[1])>b(v[0],v[1])&&(v[0]=p[0])):a.push(v=p);for(var l,c,p,g=-1/0,v=(o=0,a[c=a.length-1]);o<=c;v=p,++o)p=a[o],(l=b(v[1],p[0]))>g&&(g=l,t=p[0],r=v[1])}return f=s=null,t===1/0||e===1/0?[[NaN,NaN],[NaN,NaN]]:[[t,e],[r,i]]}}(),n.geo.centroid=function(t){ye=me=Me=xe=be=_e=we=Se=ke=Ne=Ee=0,n.geo.stream(t,Fe);var e=ke,r=Ne,i=Ee,u=e*e+r*r+i*i;return u<Sn&&(e=_e,r=we,i=Se,me<wn&&(e=Me,r=xe,i=be),(u=e*e+r*r+i*i)<Sn)?[NaN,NaN]:[Math.atan2(r,e)*zn,Rn(i/Math.sqrt(u))*zn]};var Fe={sphere:R,point:He,lineStart:Ie,lineEnd:Ye,polygonStart:function(){Fe.lineStart=Ze},polygonEnd:function(){Fe.lineStart=Ie}};function He(n,t){n*=Cn;var e=Math.cos(t*=Cn);Oe(e*Math.cos(n),e*Math.sin(n),Math.sin(t))}function Oe(n,t,e){Me+=(n-Me)/++ye,xe+=(t-xe)/ye,be+=(e-be)/ye}function Ie(){var n,t,e;function r(r,i){r*=Cn;var u=Math.cos(i*=Cn),o=u*Math.cos(r),a=u*Math.sin(r),l=Math.sin(i),c=Math.atan2(Math.sqrt((c=t*l-e*a)*c+(c=e*o-n*l)*c+(c=n*a-t*o)*c),n*o+t*a+e*l);me+=c,_e+=c*(n+(n=o)),we+=c*(t+(t=a)),Se+=c*(e+(e=l)),Oe(n,t,e)}Fe.point=function(i,u){i*=Cn;var o=Math.cos(u*=Cn);n=o*Math.cos(i),t=o*Math.sin(i),e=Math.sin(u),Fe.point=r,Oe(n,t,e)}}function Ye(){Fe.point=He}function Ze(){var n,t,e,r,i;function u(n,t){n*=Cn;var u=Math.cos(t*=Cn),o=u*Math.cos(n),a=u*Math.sin(n),l=Math.sin(t),c=r*l-i*a,f=i*o-e*l,s=e*a-r*o,h=Math.sqrt(c*c+f*f+s*s),p=e*o+r*a+i*l,g=h&&-Tn(p)/h,v=Math.atan2(h,p);ke+=g*c,Ne+=g*f,Ee+=g*s,me+=v,_e+=v*(e+(e=o)),we+=v*(r+(r=a)),Se+=v*(i+(i=l)),Oe(e,r,i)}Fe.point=function(o,a){n=o,t=a,Fe.point=u,o*=Cn;var l=Math.cos(a*=Cn);e=l*Math.cos(o),r=l*Math.sin(o),i=Math.sin(a),Oe(e,r,i)},Fe.lineEnd=function(){u(n,t),Fe.lineEnd=Ye,Fe.point=He}}function Ve(n,t){function e(e,r){return e=n(e,r),t(e[0],e[1])}return n.invert&&t.invert&&(e.invert=function(e,r){return(e=t.invert(e,r))&&n.invert(e[0],e[1])}),e}function Xe(){return!0}function $e(n,t,e,r,i){var u=[],o=[];if(n.forEach(function(n){if(!((t=n.length-1)<=0)){var t,e=n[0],r=n[t];if(je(e,r)){i.lineStart();for(var a=0;a<t;++a)i.point((e=n[a])[0],e[1]);i.lineEnd()}else{var l=new We(e,n,null,!0),c=new We(e,null,l,!1);l.o=c,u.push(l),o.push(c),c=new We(r,null,l=new We(r,n,null,!1),!0),l.o=c,u.push(l),o.push(c)}}}),o.sort(t),Be(u),Be(o),u.length){for(var a=0,l=e,c=o.length;a<c;++a)o[a].e=l=!l;for(var f,s,h=u[0];;){for(var p=h,g=!0;p.v;)if((p=p.n)===h)return;f=p.z,i.lineStart();do{if(p.v=p.o.v=!0,p.e){if(g)for(a=0,c=f.length;a<c;++a)i.point((s=f[a])[0],s[1]);else r(p.x,p.n.x,1,i);p=p.n}else{if(g)for(a=(f=p.p.z).length-1;a>=0;--a)i.point((s=f[a])[0],s[1]);else r(p.x,p.p.x,-1,i);p=p.p}f=(p=p.o).z,g=!g}while(!p.v);i.lineEnd()}}}function Be(n){if(t=n.length){for(var t,e,r=0,i=n[0];++r<t;)i.n=e=n[r],e.p=i,i=e;i.n=e=n[0],e.p=i}}function We(n,t,e,r){this.x=n,this.z=t,this.o=e,this.e=r,this.v=!1,this.n=this.p=null}function Je(t,e,r,i){return function(u,o){var a,l=e(o),c=u.invert(i[0],i[1]),f={point:s,lineStart:p,lineEnd:g,polygonStart:function(){f.point=x,f.lineStart=b,f.lineEnd=_,a=[],v=[]},polygonEnd:function(){f.point=s,f.lineStart=p,f.lineEnd=g,a=n.merge(a);var t=function(n,t){var e=n[0],r=n[1],i=[Math.sin(e),-Math.cos(e),0],u=0,o=0;Ae.reset();for(var a=0,l=t.length;a<l;++a){var c=t[a],f=c.length;if(f)for(var s=c[0],h=s[0],p=s[1]/2+kn/4,g=Math.sin(p),v=Math.cos(p),d=1;;){d===f&&(d=0);var y=(n=c[d])[0],m=n[1]/2+kn/4,M=Math.sin(m),x=Math.cos(m),b=y-h,_=b>=0?1:-1,w=_*b,S=w>kn,k=g*M;if(Ae.add(Math.atan2(k*_*Math.sin(w),v*x+k*Math.cos(w))),u+=S?b+_*Nn:b,S^h>=e^y>=e){var N=Te(Le(s),Le(n));Pe(N);var E=Te(i,N);Pe(E);var A=(S^b>=0?-1:1)*Rn(E[2]);(r>A||r===A&&(N[0]||N[1]))&&(o+=S^b>=0?1:-1)}if(!d++)break;h=y,g=M,v=x,s=n}}return(u<-wn||u<wn&&Ae<-wn)^1&o}(c,v);a.length?(M||(o.polygonStart(),M=!0),$e(a,Qe,t,r,o)):t&&(M||(o.polygonStart(),M=!0),o.lineStart(),r(null,null,1,o),o.lineEnd()),M&&(o.polygonEnd(),M=!1),a=v=null},sphere:function(){o.polygonStart(),o.lineStart(),r(null,null,1,o),o.lineEnd(),o.polygonEnd()}};function s(n,e){var r=u(n,e);t(n=r[0],e=r[1])&&o.point(n,e)}function h(n,t){var e=u(n,t);l.point(e[0],e[1])}function p(){f.point=h,l.lineStart()}function g(){f.point=s,l.lineEnd()}var v,d,y=Ke(),m=e(y),M=!1;function x(n,t){d.push([n,t]);var e=u(n,t);m.point(e[0],e[1])}function b(){m.lineStart(),d=[]}function _(){x(d[0][0],d[0][1]),m.lineEnd();var n,t=m.clean(),e=y.buffer(),r=e.length;if(d.pop(),v.push(d),d=null,r)if(1&t){var i,u=-1;if((r=(n=e[0]).length-1)>0){for(M||(o.polygonStart(),M=!0),o.lineStart();++u<r;)o.point((i=n[u])[0],i[1]);o.lineEnd()}}else r>1&&2&t&&e.push(e.pop().concat(e.shift())),a.push(e.filter(Ge))}return f}}function Ge(n){return n.length>1}function Ke(){var n,t=[];return{lineStart:function(){t.push(n=[])},point:function(t,e){n.push([t,e])},lineEnd:R,buffer:function(){var e=t;return t=[],n=null,e},rejoin:function(){t.length>1&&t.push(t.pop().concat(t.shift()))}}}function Qe(n,t){return((n=n.x)[0]<0?n[1]-An-wn:An-n[1])-((t=t.x)[0]<0?t[1]-An-wn:An-t[1])}var nr=Je(Xe,function(n){var t,e=NaN,r=NaN,i=NaN;return{lineStart:function(){n.lineStart(),t=1},point:function(u,o){var a=u>0?kn:-kn,l=y(u-e);y(l-kn)<wn?(n.point(e,r=(r+o)/2>0?An:-An),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),n.point(u,r),t=0):i!==a&&l>=kn&&(y(e-i)<wn&&(e-=i*wn),y(u-a)<wn&&(u-=a*wn),r=function(n,t,e,r){var i,u,o=Math.sin(n-e);return y(o)>wn?Math.atan((Math.sin(t)*(u=Math.cos(r))*Math.sin(e)-Math.sin(r)*(i=Math.cos(t))*Math.sin(n))/(i*u*o)):(t+r)/2}(e,r,u,o),n.point(i,r),n.lineEnd(),n.lineStart(),n.point(a,r),t=0),n.point(e=u,r=o),i=a},lineEnd:function(){n.lineEnd(),e=r=NaN},clean:function(){return 2-t}}},function(n,t,e,r){var i;if(null==n)i=e*An,r.point(-kn,i),r.point(0,i),r.point(kn,i),r.point(kn,0),r.point(kn,-i),r.point(0,-i),r.point(-kn,-i),r.point(-kn,0),r.point(-kn,i);else if(y(n[0]-t[0])>wn){var u=n[0]<t[0]?kn:-kn;i=e*u/2,r.point(-u,i),r.point(0,i),r.point(u,i)}else r.point(t[0],t[1])},[-kn,-kn/2]);function tr(n,t,e,r){return function(i){var u,o=i.a,a=i.b,l=o.x,c=o.y,f=0,s=1,h=a.x-l,p=a.y-c;if(u=n-l,h||!(u>0)){if(u/=h,h<0){if(u<f)return;u<s&&(s=u)}else if(h>0){if(u>s)return;u>f&&(f=u)}if(u=e-l,h||!(u<0)){if(u/=h,h<0){if(u>s)return;u>f&&(f=u)}else if(h>0){if(u<f)return;u<s&&(s=u)}if(u=t-c,p||!(u>0)){if(u/=p,p<0){if(u<f)return;u<s&&(s=u)}else if(p>0){if(u>s)return;u>f&&(f=u)}if(u=r-c,p||!(u<0)){if(u/=p,p<0){if(u>s)return;u>f&&(f=u)}else if(p>0){if(u<f)return;u<s&&(s=u)}return f>0&&(i.a={x:l+f*h,y:c+f*p}),s<1&&(i.b={x:l+s*h,y:c+s*p}),i}}}}}}var er=1e9;function rr(t,e,r,i){return function(l){var c,f,s,h,p,g,v,d,y,m,M,x=l,b=Ke(),_=tr(t,e,r,i),w={point:N,lineStart:function(){w.point=E,f&&f.push(s=[]);m=!0,y=!1,v=d=NaN},lineEnd:function(){c&&(E(h,p),g&&y&&b.rejoin(),c.push(b.buffer()));w.point=N,y&&l.lineEnd()},polygonStart:function(){l=b,c=[],f=[],M=!0},polygonEnd:function(){l=x,c=n.merge(c);var e=function(n){for(var t=0,e=f.length,r=n[1],i=0;i<e;++i)for(var u,o=1,a=f[i],l=a.length,c=a[0];o<l;++o)u=a[o],c[1]<=r?u[1]>r&&qn(c,u,n)>0&&++t:u[1]<=r&&qn(c,u,n)<0&&--t,c=u;return 0!==t}([t,i]),r=M&&e,u=c.length;(r||u)&&(l.polygonStart(),r&&(l.lineStart(),S(null,null,1,l),l.lineEnd()),u&&$e(c,o,e,S,l),l.polygonEnd()),c=f=s=null}};function S(n,o,l,c){var f=0,s=0;if(null==n||(f=u(n,l))!==(s=u(o,l))||a(n,o)<0^l>0)do{c.point(0===f||3===f?t:r,f>1?i:e)}while((f=(f+l+4)%4)!==s);else c.point(o[0],o[1])}function k(n,u){return t<=n&&n<=r&&e<=u&&u<=i}function N(n,t){k(n,t)&&l.point(n,t)}function E(n,t){var e=k(n=Math.max(-er,Math.min(er,n)),t=Math.max(-er,Math.min(er,t)));if(f&&s.push([n,t]),m)h=n,p=t,g=e,m=!1,e&&(l.lineStart(),l.point(n,t));else if(e&&y)l.point(n,t);else{var r={a:{x:v,y:d},b:{x:n,y:t}};_(r)?(y||(l.lineStart(),l.point(r.a.x,r.a.y)),l.point(r.b.x,r.b.y),e||l.lineEnd(),M=!1):e&&(l.lineStart(),l.point(n,t),M=!1)}v=n,d=t,y=e}return w};function u(n,i){return y(n[0]-t)<wn?i>0?0:3:y(n[0]-r)<wn?i>0?2:1:y(n[1]-e)<wn?i>0?1:0:i>0?3:2}function o(n,t){return a(n.x,t.x)}function a(n,t){var e=u(n,1),r=u(t,1);return e!==r?e-r:0===e?t[1]-n[1]:1===e?n[0]-t[0]:2===e?n[1]-t[1]:t[0]-n[0]}}function ir(n){var t=0,e=kn/3,r=Nr(n),i=r(t,e);return i.parallels=function(n){return arguments.length?r(t=n[0]*kn/180,e=n[1]*kn/180):[t/kn*180,e/kn*180]},i}function ur(n,t){var e=Math.sin(n),r=(e+Math.sin(t))/2,i=1+e*(2*r-e),u=Math.sqrt(i)/r;function o(n,t){var e=Math.sqrt(i-2*r*Math.sin(t))/r;return[e*Math.sin(n*=r),u-e*Math.cos(n)]}return o.invert=function(n,t){var e=u-t;return[Math.atan2(n,e)/r,Rn((i-(n*n+e*e)*r*r)/(2*r))]},o}n.geo.clipExtent=function(){var n,t,e,r,i,u,o={stream:function(n){return i&&(i.valid=!1),(i=u(n)).valid=!0,i},extent:function(a){return arguments.length?(u=rr(n=+a[0][0],t=+a[0][1],e=+a[1][0],r=+a[1][1]),i&&(i.valid=!1,i=null),o):[[n,t],[e,r]]}};return o.extent([[0,0],[960,500]])},(n.geo.conicEqualArea=function(){return ir(ur)}).raw=ur,n.geo.albers=function(){return n.geo.conicEqualArea().rotate([96,0]).center([-.6,38.7]).parallels([29.5,45.5]).scale(1070)},n.geo.albersUsa=function(){var t,e,r,i,u=n.geo.albers(),o=n.geo.conicEqualArea().rotate([154,0]).center([-2,58.5]).parallels([55,65]),a=n.geo.conicEqualArea().rotate([157,0]).center([-3,19.9]).parallels([8,18]),l={point:function(n,e){t=[n,e]}};function c(n){var u=n[0],o=n[1];return t=null,e(u,o),t||(r(u,o),t)||i(u,o),t}return c.invert=function(n){var t=u.scale(),e=u.translate(),r=(n[0]-e[0])/t,i=(n[1]-e[1])/t;return(i>=.12&&i<.234&&r>=-.425&&r<-.214?o:i>=.166&&i<.234&&r>=-.214&&r<-.115?a:u).invert(n)},c.stream=function(n){var t=u.stream(n),e=o.stream(n),r=a.stream(n);return{point:function(n,i){t.point(n,i),e.point(n,i),r.point(n,i)},sphere:function(){t.sphere(),e.sphere(),r.sphere()},lineStart:function(){t.lineStart(),e.lineStart(),r.lineStart()},lineEnd:function(){t.lineEnd(),e.lineEnd(),r.lineEnd()},polygonStart:function(){t.polygonStart(),e.polygonStart(),r.polygonStart()},polygonEnd:function(){t.polygonEnd(),e.polygonEnd(),r.polygonEnd()}}},c.precision=function(n){return arguments.length?(u.precision(n),o.precision(n),a.precision(n),c):u.precision()},c.scale=function(n){return arguments.length?(u.scale(n),o.scale(.35*n),a.scale(n),c.translate(u.translate())):u.scale()},c.translate=function(n){if(!arguments.length)return u.translate();var t=u.scale(),f=+n[0],s=+n[1];return e=u.translate(n).clipExtent([[f-.455*t,s-.238*t],[f+.455*t,s+.238*t]]).stream(l).point,r=o.translate([f-.307*t,s+.201*t]).clipExtent([[f-.425*t+wn,s+.12*t+wn],[f-.214*t-wn,s+.234*t-wn]]).stream(l).point,i=a.translate([f-.205*t,s+.212*t]).clipExtent([[f-.214*t+wn,s+.166*t+wn],[f-.115*t-wn,s+.234*t-wn]]).stream(l).point,c},c.scale(1070)};var or,ar,lr,cr,fr,sr,hr={point:R,lineStart:R,lineEnd:R,polygonStart:function(){ar=0,hr.lineStart=pr},polygonEnd:function(){hr.lineStart=hr.lineEnd=hr.point=R,or+=y(ar/2)}};function pr(){var n,t,e,r;function i(n,t){ar+=r*n-e*t,e=n,r=t}hr.point=function(u,o){hr.point=i,n=e=u,t=r=o},hr.lineEnd=function(){i(n,t)}}var gr={point:function(n,t){n<lr&&(lr=n);n>fr&&(fr=n);t<cr&&(cr=t);t>sr&&(sr=t)},lineStart:R,lineEnd:R,polygonStart:R,polygonEnd:R};function vr(n){return"m0,"+n+"a"+n+","+n+" 0 1,1 0,"+-2*n+"a"+n+","+n+" 0 1,1 0,"+2*n+"z"}var dr,yr={point:mr,lineStart:Mr,lineEnd:xr,polygonStart:function(){yr.lineStart=br},polygonEnd:function(){yr.point=mr,yr.lineStart=Mr,yr.lineEnd=xr}};function mr(n,t){Me+=n,xe+=t,++be}function Mr(){var n,t;function e(e,r){var i=e-n,u=r-t,o=Math.sqrt(i*i+u*u);_e+=o*(n+e)/2,we+=o*(t+r)/2,Se+=o,mr(n=e,t=r)}yr.point=function(r,i){yr.point=e,mr(n=r,t=i)}}function xr(){yr.point=mr}function br(){var n,t,e,r;function i(n,t){var i=n-e,u=t-r,o=Math.sqrt(i*i+u*u);_e+=o*(e+n)/2,we+=o*(r+t)/2,Se+=o,ke+=(o=r*n-e*t)*(e+n),Ne+=o*(r+t),Ee+=3*o,mr(e=n,r=t)}yr.point=function(u,o){yr.point=i,mr(n=e=u,t=r=o)},yr.lineEnd=function(){i(n,t)}}function _r(n){var t=.5,e=Math.cos(30*Cn),r=16;function i(t){return(r?function(t){var e,i,o,a,l,c,f,s,h,p,g,v,d={point:y,lineStart:m,lineEnd:x,polygonStart:function(){t.polygonStart(),d.lineStart=b},polygonEnd:function(){t.polygonEnd(),d.lineStart=m}};function y(e,r){e=n(e,r),t.point(e[0],e[1])}function m(){s=NaN,d.point=M,t.lineStart()}function M(e,i){var o=Le([e,i]),a=n(e,i);u(s,h,f,p,g,v,s=a[0],h=a[1],f=e,p=o[0],g=o[1],v=o[2],r,t),t.point(s,h)}function x(){d.point=y,t.lineEnd()}function b(){m(),d.point=_,d.lineEnd=w}function _(n,t){M(e=n,t),i=s,o=h,a=p,l=g,c=v,d.point=M}function w(){u(s,h,f,p,g,v,i,o,e,a,l,c,r,t),d.lineEnd=x,x()}return d}:function(t){return Sr(t,function(e,r){e=n(e,r),t.point(e[0],e[1])})})(t)}function u(r,i,o,a,l,c,f,s,h,p,g,v,d,m){var M=f-r,x=s-i,b=M*M+x*x;if(b>4*t&&d--){var _=a+p,w=l+g,S=c+v,k=Math.sqrt(_*_+w*w+S*S),N=Math.asin(S/=k),E=y(y(S)-1)<wn||y(o-h)<wn?(o+h)/2:Math.atan2(w,_),A=n(E,N),C=A[0],z=A[1],L=C-r,q=z-i,T=x*L-M*q;(T*T/b>t||y((M*L+x*q)/b-.5)>.3||a*p+l*g+c*v<e)&&(u(r,i,o,a,l,c,C,z,E,_/=k,w/=k,S,d,m),m.point(C,z),u(C,z,E,_,w,S,f,s,h,p,g,v,d,m))}}return i.precision=function(n){return arguments.length?(r=(t=n*n)>0&&16,i):Math.sqrt(t)},i}function wr(n){this.stream=n}function Sr(n,t){return{point:t,sphere:function(){n.sphere()},lineStart:function(){n.lineStart()},lineEnd:function(){n.lineEnd()},polygonStart:function(){n.polygonStart()},polygonEnd:function(){n.polygonEnd()}}}function kr(n){return Nr(function(){return n})()}function Nr(t){var e,r,i,u,o,a,l=_r(function(n,t){return[(n=e(n,t))[0]*c+u,o-n[1]*c]}),c=150,f=480,s=250,h=0,p=0,g=0,v=0,d=0,m=nr,M=z,x=null,b=null;function _(n){return[(n=i(n[0]*Cn,n[1]*Cn))[0]*c+u,o-n[1]*c]}function w(n){return(n=i.invert((n[0]-u)/c,(o-n[1])/c))&&[n[0]*zn,n[1]*zn]}function S(){i=Ve(r=zr(g,v,d),e);var n=e(h,p);return u=f-n[0]*c,o=s+n[1]*c,k()}function k(){return a&&(a.valid=!1,a=null),_}return _.stream=function(n){return a&&(a.valid=!1),(a=Er(m(r,l(M(n))))).valid=!0,a},_.clipAngle=function(n){return arguments.length?(m=null==n?(x=n,nr):function(n){var t=Math.cos(n),e=t>0,r=y(t)>wn;return Je(i,function(n){var t,a,l,c,f;return{lineStart:function(){c=l=!1,f=1},point:function(s,h){var p,g=[s,h],v=i(s,h),d=e?v?0:o(s,h):v?o(s+(s<0?kn:-kn),h):0;if(!t&&(c=l=v)&&n.lineStart(),v!==l&&(p=u(t,g),(je(t,p)||je(g,p))&&(g[0]+=wn,g[1]+=wn,v=i(g[0],g[1]))),v!==l)f=0,v?(n.lineStart(),p=u(g,t),n.point(p[0],p[1])):(p=u(t,g),n.point(p[0],p[1]),n.lineEnd()),t=p;else if(r&&t&&e^v){var y;d&a||!(y=u(g,t,!0))||(f=0,e?(n.lineStart(),n.point(y[0][0],y[0][1]),n.point(y[1][0],y[1][1]),n.lineEnd()):(n.point(y[1][0],y[1][1]),n.lineEnd(),n.lineStart(),n.point(y[0][0],y[0][1])))}!v||t&&je(t,g)||n.point(g[0],g[1]),t=g,l=v,a=d},lineEnd:function(){l&&n.lineEnd(),t=null},clean:function(){return f|(c&&l)<<1}}},Rr(n,6*Cn),e?[0,-n]:[-kn,n-kn]);function i(n,e){return Math.cos(n)*Math.cos(e)>t}function u(n,e,r){var i=[1,0,0],u=Te(Le(n),Le(e)),o=qe(u,u),a=u[0],l=o-a*a;if(!l)return!r&&n;var c=t*o/l,f=-t*a/l,s=Te(i,u),h=De(i,c);Re(h,De(u,f));var p=s,g=qe(h,p),v=qe(p,p),d=g*g-v*(qe(h,h)-1);if(!(d<0)){var m=Math.sqrt(d),M=De(p,(-g-m)/v);if(Re(M,h),M=Ue(M),!r)return M;var x,b=n[0],_=e[0],w=n[1],S=e[1];_<b&&(x=b,b=_,_=x);var k=_-b,N=y(k-kn)<wn;if(!N&&S<w&&(x=w,w=S,S=x),N||k<wn?N?w+S>0^M[1]<(y(M[0]-b)<wn?w:S):w<=M[1]&&M[1]<=S:k>kn^(b<=M[0]&&M[0]<=_)){var E=De(p,(-g+m)/v);return Re(E,h),[M,Ue(E)]}}}function o(t,r){var i=e?n:kn-n,u=0;return t<-i?u|=1:t>i&&(u|=2),r<-i?u|=4:r>i&&(u|=8),u}}((x=+n)*Cn),k()):x},_.clipExtent=function(n){return arguments.length?(b=n,M=n?rr(n[0][0],n[0][1],n[1][0],n[1][1]):z,k()):b},_.scale=function(n){return arguments.length?(c=+n,S()):c},_.translate=function(n){return arguments.length?(f=+n[0],s=+n[1],S()):[f,s]},_.center=function(n){return arguments.length?(h=n[0]%360*Cn,p=n[1]%360*Cn,S()):[h*zn,p*zn]},_.rotate=function(n){return arguments.length?(g=n[0]%360*Cn,v=n[1]%360*Cn,d=n.length>2?n[2]%360*Cn:0,S()):[g*zn,v*zn,d*zn]},n.rebind(_,l,"precision"),function(){return e=t.apply(this,arguments),_.invert=e.invert&&w,S()}}function Er(n){return Sr(n,function(t,e){n.point(t*Cn,e*Cn)})}function Ar(n,t){return[n,t]}function Cr(n,t){return[n>kn?n-Nn:n<-kn?n+Nn:n,t]}function zr(n,t,e){return n?t||e?Ve(qr(n),Tr(t,e)):qr(n):t||e?Tr(t,e):Cr}function Lr(n){return function(t,e){return[(t+=n)>kn?t-Nn:t<-kn?t+Nn:t,e]}}function qr(n){var t=Lr(n);return t.invert=Lr(-n),t}function Tr(n,t){var e=Math.cos(n),r=Math.sin(n),i=Math.cos(t),u=Math.sin(t);function o(n,t){var o=Math.cos(t),a=Math.cos(n)*o,l=Math.sin(n)*o,c=Math.sin(t),f=c*e+a*r;return[Math.atan2(l*i-f*u,a*e-c*r),Rn(f*i+l*u)]}return o.invert=function(n,t){var o=Math.cos(t),a=Math.cos(n)*o,l=Math.sin(n)*o,c=Math.sin(t),f=c*i-l*u;return[Math.atan2(l*i+c*u,a*e+f*r),Rn(f*e-a*r)]},o}function Rr(n,t){var e=Math.cos(n),r=Math.sin(n);return function(i,u,o,a){var l=o*t;null!=i?(i=Dr(e,i),u=Dr(e,u),(o>0?i<u:i>u)&&(i+=o*Nn)):(i=n+o*Nn,u=n-.5*l);for(var c,f=i;o>0?f>u:f<u;f-=l)a.point((c=Ue([e,-r*Math.cos(f),-r*Math.sin(f)]))[0],c[1])}}function Dr(n,t){var e=Le(t);e[0]-=n,Pe(e);var r=Tn(-e[1]);return((-e[2]<0?-r:r)+2*Math.PI-wn)%(2*Math.PI)}function Pr(t,e,r){var i=n.range(t,e-wn,r).concat(e);return function(n){return i.map(function(t){return[n,t]})}}function Ur(t,e,r){var i=n.range(t,e-wn,r).concat(e);return function(n){return i.map(function(t){return[t,n]})}}function jr(n){return n.source}function Fr(n){return n.target}n.geo.path=function(){var t,e,r,i,u,o=4.5;function a(t){return t&&("function"==typeof o&&i.pointRadius(+o.apply(this,arguments)),u&&u.valid||(u=r(i)),n.geo.stream(t,u)),i.result()}function l(){return u=null,a}return a.area=function(t){return or=0,n.geo.stream(t,r(hr)),or},a.centroid=function(t){return Me=xe=be=_e=we=Se=ke=Ne=Ee=0,n.geo.stream(t,r(yr)),Ee?[ke/Ee,Ne/Ee]:Se?[_e/Se,we/Se]:be?[Me/be,xe/be]:[NaN,NaN]},a.bounds=function(t){return fr=sr=-(lr=cr=1/0),n.geo.stream(t,r(gr)),[[lr,cr],[fr,sr]]},a.projection=function(n){return arguments.length?(r=(t=n)?n.stream||(e=n,i=_r(function(n,t){return e([n*zn,t*zn])}),function(n){return Er(i(n))}):z,l()):t;var e,i},a.context=function(n){return arguments.length?(i=null==(e=n)?new function(){var n=vr(4.5),t=[],e={point:r,lineStart:function(){e.point=i},lineEnd:o,polygonStart:function(){e.lineEnd=a},polygonEnd:function(){e.lineEnd=o,e.point=r},pointRadius:function(t){return n=vr(t),e},result:function(){if(t.length){var n=t.join("");return t=[],n}}};function r(e,r){t.push("M",e,",",r,n)}function i(n,r){t.push("M",n,",",r),e.point=u}function u(n,e){t.push("L",n,",",e)}function o(){e.point=r}function a(){t.push("Z")}return e}:new function(n){var t=4.5,e={point:r,lineStart:function(){e.point=i},lineEnd:o,polygonStart:function(){e.lineEnd=a},polygonEnd:function(){e.lineEnd=o,e.point=r},pointRadius:function(n){return t=n,e},result:R};function r(e,r){n.moveTo(e+t,r),n.arc(e,r,t,0,Nn)}function i(t,r){n.moveTo(t,r),e.point=u}function u(t,e){n.lineTo(t,e)}function o(){e.point=r}function a(){n.closePath()}return e}(n),"function"!=typeof o&&i.pointRadius(o),l()):e},a.pointRadius=function(n){return arguments.length?(o="function"==typeof n?n:(i.pointRadius(+n),+n),a):o},a.projection(n.geo.albersUsa()).context(null)},n.geo.transform=function(n){return{stream:function(t){var e=new wr(t);for(var r in n)e[r]=n[r];return e}}},wr.prototype={point:function(n,t){this.stream.point(n,t)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}},n.geo.projection=kr,n.geo.projectionMutator=Nr,(n.geo.equirectangular=function(){return kr(Ar)}).raw=Ar.invert=Ar,n.geo.rotation=function(n){function t(t){return(t=n(t[0]*Cn,t[1]*Cn))[0]*=zn,t[1]*=zn,t}return n=zr(n[0]%360*Cn,n[1]*Cn,n.length>2?n[2]*Cn:0),t.invert=function(t){return(t=n.invert(t[0]*Cn,t[1]*Cn))[0]*=zn,t[1]*=zn,t},t},Cr.invert=Ar,n.geo.circle=function(){var n,t,e=[0,0],r=6;function i(){var n="function"==typeof e?e.apply(this,arguments):e,r=zr(-n[0]*Cn,-n[1]*Cn,0).invert,i=[];return t(null,null,1,{point:function(n,t){i.push(n=r(n,t)),n[0]*=zn,n[1]*=zn}}),{type:"Polygon",coordinates:[i]}}return i.origin=function(n){return arguments.length?(e=n,i):e},i.angle=function(e){return arguments.length?(t=Rr((n=+e)*Cn,r*Cn),i):n},i.precision=function(e){return arguments.length?(t=Rr(n*Cn,(r=+e)*Cn),i):r},i.angle(90)},n.geo.distance=function(n,t){var e,r=(t[0]-n[0])*Cn,i=n[1]*Cn,u=t[1]*Cn,o=Math.sin(r),a=Math.cos(r),l=Math.sin(i),c=Math.cos(i),f=Math.sin(u),s=Math.cos(u);return Math.atan2(Math.sqrt((e=s*o)*e+(e=c*f-l*s*a)*e),l*f+c*s*a)},n.geo.graticule=function(){var t,e,r,i,u,o,a,l,c,f,s,h,p=10,g=p,v=90,d=360,m=2.5;function M(){return{type:"MultiLineString",coordinates:x()}}function x(){return n.range(Math.ceil(i/v)*v,r,v).map(s).concat(n.range(Math.ceil(l/d)*d,a,d).map(h)).concat(n.range(Math.ceil(e/p)*p,t,p).filter(function(n){return y(n%v)>wn}).map(c)).concat(n.range(Math.ceil(o/g)*g,u,g).filter(function(n){return y(n%d)>wn}).map(f))}return M.lines=function(){return x().map(function(n){return{type:"LineString",coordinates:n}})},M.outline=function(){return{type:"Polygon",coordinates:[s(i).concat(h(a).slice(1),s(r).reverse().slice(1),h(l).reverse().slice(1))]}},M.extent=function(n){return arguments.length?M.majorExtent(n).minorExtent(n):M.minorExtent()},M.majorExtent=function(n){return arguments.length?(i=+n[0][0],r=+n[1][0],l=+n[0][1],a=+n[1][1],i>r&&(n=i,i=r,r=n),l>a&&(n=l,l=a,a=n),M.precision(m)):[[i,l],[r,a]]},M.minorExtent=function(n){return arguments.length?(e=+n[0][0],t=+n[1][0],o=+n[0][1],u=+n[1][1],e>t&&(n=e,e=t,t=n),o>u&&(n=o,o=u,u=n),M.precision(m)):[[e,o],[t,u]]},M.step=function(n){return arguments.length?M.majorStep(n).minorStep(n):M.minorStep()},M.majorStep=function(n){return arguments.length?(v=+n[0],d=+n[1],M):[v,d]},M.minorStep=function(n){return arguments.length?(p=+n[0],g=+n[1],M):[p,g]},M.precision=function(n){return arguments.length?(m=+n,c=Pr(o,u,90),f=Ur(e,t,m),s=Pr(l,a,90),h=Ur(i,r,m),M):m},M.majorExtent([[-180,-90+wn],[180,90-wn]]).minorExtent([[-180,-80-wn],[180,80+wn]])},n.geo.greatArc=function(){var t,e,r=jr,i=Fr;function u(){return{type:"LineString",coordinates:[t||r.apply(this,arguments),e||i.apply(this,arguments)]}}return u.distance=function(){return n.geo.distance(t||r.apply(this,arguments),e||i.apply(this,arguments))},u.source=function(n){return arguments.length?(r=n,t="function"==typeof n?null:n,u):r},u.target=function(n){return arguments.length?(i=n,e="function"==typeof n?null:n,u):i},u.precision=function(){return arguments.length?u:0},u},n.geo.interpolate=function(n,t){return e=n[0]*Cn,r=n[1]*Cn,i=t[0]*Cn,u=t[1]*Cn,o=Math.cos(r),a=Math.sin(r),l=Math.cos(u),c=Math.sin(u),f=o*Math.cos(e),s=o*Math.sin(e),h=l*Math.cos(i),p=l*Math.sin(i),g=2*Math.asin(Math.sqrt(Pn(u-r)+o*l*Pn(i-e))),v=1/Math.sin(g),(d=g?function(n){var t=Math.sin(n*=g)*v,e=Math.sin(g-n)*v,r=e*f+t*h,i=e*s+t*p,u=e*a+t*c;return[Math.atan2(i,r)*zn,Math.atan2(u,Math.sqrt(r*r+i*i))*zn]}:function(){return[e*zn,r*zn]}).distance=g,d;var e,r,i,u,o,a,l,c,f,s,h,p,g,v,d},n.geo.length=function(t){return dr=0,n.geo.stream(t,Hr),dr};var Hr={sphere:R,point:R,lineStart:function(){var n,t,e;function r(r,i){var u=Math.sin(i*=Cn),o=Math.cos(i),a=y((r*=Cn)-n),l=Math.cos(a);dr+=Math.atan2(Math.sqrt((a=o*Math.sin(a))*a+(a=e*u-t*o*l)*a),t*u+e*o*l),n=r,t=u,e=o}Hr.point=function(i,u){n=i*Cn,t=Math.sin(u*=Cn),e=Math.cos(u),Hr.point=r},Hr.lineEnd=function(){Hr.point=Hr.lineEnd=R}},lineEnd:R,polygonStart:R,polygonEnd:R};function Or(n,t){function e(t,e){var r=Math.cos(t),i=Math.cos(e),u=n(r*i);return[u*i*Math.sin(t),u*Math.sin(e)]}return e.invert=function(n,e){var r=Math.sqrt(n*n+e*e),i=t(r),u=Math.sin(i),o=Math.cos(i);return[Math.atan2(n*u,r*o),Math.asin(r&&e*u/r)]},e}var Ir=Or(function(n){return Math.sqrt(2/(1+n))},function(n){return 2*Math.asin(n/2)});(n.geo.azimuthalEqualArea=function(){return kr(Ir)}).raw=Ir;var Yr=Or(function(n){var t=Math.acos(n);return t&&t/Math.sin(t)},z);function Zr(n,t){var e=Math.cos(n),r=function(n){return Math.tan(kn/4+n/2)},i=n===t?Math.sin(n):Math.log(e/Math.cos(t))/Math.log(r(t)/r(n)),u=e*Math.pow(r(n),i)/i;if(!i)return $r;function o(n,t){u>0?t<-An+wn&&(t=-An+wn):t>An-wn&&(t=An-wn);var e=u/Math.pow(r(t),i);return[e*Math.sin(i*n),u-e*Math.cos(i*n)]}return o.invert=function(n,t){var e=u-t,r=Ln(i)*Math.sqrt(n*n+e*e);return[Math.atan2(n,e)/i,2*Math.atan(Math.pow(u/r,1/i))-An]},o}function Vr(n,t){var e=Math.cos(n),r=n===t?Math.sin(n):(e-Math.cos(t))/(t-n),i=e/r+n;if(y(r)<wn)return Ar;function u(n,t){var e=i-t;return[e*Math.sin(r*n),i-e*Math.cos(r*n)]}return u.invert=function(n,t){var e=i-t;return[Math.atan2(n,e)/r,i-Ln(r)*Math.sqrt(n*n+e*e)]},u}(n.geo.azimuthalEquidistant=function(){return kr(Yr)}).raw=Yr,(n.geo.conicConformal=function(){return ir(Zr)}).raw=Zr,(n.geo.conicEquidistant=function(){return ir(Vr)}).raw=Vr;var Xr=Or(function(n){return 1/n},Math.atan);function $r(n,t){return[n,Math.log(Math.tan(kn/4+t/2))]}function Br(n){var t,e=kr(n),r=e.scale,i=e.translate,u=e.clipExtent;return e.scale=function(){var n=r.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.translate=function(){var n=i.apply(e,arguments);return n===e?t?e.clipExtent(null):e:n},e.clipExtent=function(n){var o=u.apply(e,arguments);if(o===e){if(t=null==n){var a=kn*r(),l=i();u([[l[0]-a,l[1]-a],[l[0]+a,l[1]+a]])}}else t&&(o=null);return o},e.clipExtent(null)}(n.geo.gnomonic=function(){return kr(Xr)}).raw=Xr,$r.invert=function(n,t){return[n,2*Math.atan(Math.exp(t))-An]},(n.geo.mercator=function(){return Br($r)}).raw=$r;var Wr=Or(function(){return 1},Math.asin);(n.geo.orthographic=function(){return kr(Wr)}).raw=Wr;var Jr=Or(function(n){return 1/(1+n)},function(n){return 2*Math.atan(n)});function Gr(n,t){return[Math.log(Math.tan(kn/4+t/2)),-n]}function Kr(n){return n[0]}function Qr(n){return n[1]}function ni(n){for(var t=n.length,e=[0,1],r=2,i=2;i<t;i++){for(;r>1&&qn(n[e[r-2]],n[e[r-1]],n[i])<=0;)--r;e[r++]=i}return e.slice(0,r)}function ti(n,t){return n[0]-t[0]||n[1]-t[1]}(n.geo.stereographic=function(){return kr(Jr)}).raw=Jr,Gr.invert=function(n,t){return[-t,2*Math.atan(Math.exp(n))-An]},(n.geo.transverseMercator=function(){var n=Br(Gr),t=n.center,e=n.rotate;return n.center=function(n){return n?t([-n[1],n[0]]):[(n=t())[1],-n[0]]},n.rotate=function(n){return n?e([n[0],n[1],n.length>2?n[2]+90:90]):[(n=e())[0],n[1],n[2]-90]},e([0,0,90])}).raw=Gr,n.geom={},n.geom.hull=function(n){var t=Kr,e=Qr;if(arguments.length)return r(n);function r(n){if(n.length<3)return[];var r,i=dt(t),u=dt(e),o=n.length,a=[],l=[];for(r=0;r<o;r++)a.push([+i.call(this,n[r],r),+u.call(this,n[r],r),r]);for(a.sort(ti),r=0;r<o;r++)l.push([a[r][0],-a[r][1]]);var c=ni(a),f=ni(l),s=f[0]===c[0],h=f[f.length-1]===c[c.length-1],p=[];for(r=c.length-1;r>=0;--r)p.push(n[a[c[r]][2]]);for(r=+s;r<f.length-h;++r)p.push(n[a[f[r]][2]]);return p}return r.x=function(n){return arguments.length?(t=n,r):t},r.y=function(n){return arguments.length?(e=n,r):e},r},n.geom.polygon=function(n){return O(n,ei),n};var ei=n.geom.polygon.prototype=[];function ri(n,t,e){return(e[0]-t[0])*(n[1]-t[1])<(e[1]-t[1])*(n[0]-t[0])}function ii(n,t,e,r){var i=n[0],u=e[0],o=t[0]-i,a=r[0]-u,l=n[1],c=e[1],f=t[1]-l,s=r[1]-c,h=(a*(l-c)-s*(i-u))/(s*o-a*f);return[i+h*o,l+h*f]}function ui(n){var t=n[0],e=n[n.length-1];return!(t[0]-e[0]||t[1]-e[1])}ei.area=function(){for(var n,t=-1,e=this.length,r=this[e-1],i=0;++t<e;)n=r,r=this[t],i+=n[1]*r[0]-n[0]*r[1];return.5*i},ei.centroid=function(n){var t,e,r=-1,i=this.length,u=0,o=0,a=this[i-1];for(arguments.length||(n=-1/(6*this.area()));++r<i;)t=a,a=this[r],e=t[0]*a[1]-a[0]*t[1],u+=(t[0]+a[0])*e,o+=(t[1]+a[1])*e;return[u*n,o*n]},ei.clip=function(n){for(var t,e,r,i,u,o,a=ui(n),l=-1,c=this.length-ui(this),f=this[c-1];++l<c;){for(t=n.slice(),n.length=0,i=this[l],u=t[(r=t.length-a)-1],e=-1;++e<r;)ri(o=t[e],f,i)?(ri(u,f,i)||n.push(ii(u,o,f,i)),n.push(o)):ri(u,f,i)&&n.push(ii(u,o,f,i)),u=o;a&&n.push(n[0]),f=i}return n};var oi,ai,li,ci,fi,si=[],hi=[];function pi(n){var t=si.pop()||new function(){Ci(this),this.edge=this.site=this.circle=null};return t.site=n,t}function gi(n){_i(n),li.remove(n),si.push(n),Ci(n)}function vi(n){var t=n.circle,e=t.x,r=t.cy,i={x:e,y:r},u=n.P,o=n.N,a=[n];gi(n);for(var l=u;l.circle&&y(e-l.circle.x)<wn&&y(r-l.circle.cy)<wn;)u=l.P,a.unshift(l),gi(l),l=u;a.unshift(l),_i(l);for(var c=o;c.circle&&y(e-c.circle.x)<wn&&y(r-c.circle.cy)<wn;)o=c.N,a.push(c),gi(c),c=o;a.push(c),_i(c);var f,s=a.length;for(f=1;f<s;++f)c=a[f],l=a[f-1],Ni(c.edge,l.site,c.site,i);l=a[0],(c=a[s-1]).edge=ki(l.site,c.site,null,i),bi(l),bi(c)}function di(n){for(var t,e,r,i,u=n.x,o=n.y,a=li._;a;)if((r=yi(a,o)-u)>wn)a=a.L;else{if(!((i=u-mi(a,o))>wn)){r>-wn?(t=a.P,e=a):i>-wn?(t=a,e=a.N):t=e=a;break}if(!a.R){t=a;break}a=a.R}var l=pi(n);if(li.insert(t,l),t||e){if(t===e)return _i(t),e=pi(t.site),li.insert(l,e),l.edge=e.edge=ki(t.site,l.site),bi(t),void bi(e);if(e){_i(t),_i(e);var c=t.site,f=c.x,s=c.y,h=n.x-f,p=n.y-s,g=e.site,v=g.x-f,d=g.y-s,y=2*(h*d-p*v),m=h*h+p*p,M=v*v+d*d,x={x:(d*m-p*M)/y+f,y:(h*M-v*m)/y+s};Ni(e.edge,c,g,x),l.edge=ki(c,n,null,x),e.edge=ki(n,g,null,x),bi(t),bi(e)}else l.edge=ki(t.site,l.site)}}function yi(n,t){var e=n.site,r=e.x,i=e.y,u=i-t;if(!u)return r;var o=n.P;if(!o)return-1/0;var a=(e=o.site).x,l=e.y,c=l-t;if(!c)return a;var f=a-r,s=1/u-1/c,h=f/c;return s?(-h+Math.sqrt(h*h-2*s*(f*f/(-2*c)-l+c/2+i-u/2)))/s+r:(r+a)/2}function mi(n,t){var e=n.N;if(e)return yi(e,t);var r=n.site;return r.y===t?r.x:1/0}function Mi(n){this.site=n,this.edges=[]}function xi(n,t){return t.angle-n.angle}function bi(n){var t=n.P,e=n.N;if(t&&e){var r=t.site,i=n.site,u=e.site;if(r!==u){var o=i.x,a=i.y,l=r.x-o,c=r.y-a,f=u.x-o,s=2*(l*(d=u.y-a)-c*f);if(!(s>=-Sn)){var h=l*l+c*c,p=f*f+d*d,g=(d*h-c*p)/s,v=(l*p-f*h)/s,d=v+a,y=hi.pop()||new function(){Ci(this),this.x=this.y=this.arc=this.site=this.cy=null};y.arc=n,y.site=i,y.x=g+o,y.y=d+Math.sqrt(g*g+v*v),y.cy=d,n.circle=y;for(var m=null,M=fi._;M;)if(y.y<M.y||y.y===M.y&&y.x<=M.x){if(!M.L){m=M.P;break}M=M.L}else{if(!M.R){m=M;break}M=M.R}fi.insert(m,y),m||(ci=y)}}}}function _i(n){var t=n.circle;t&&(t.P||(ci=t.N),fi.remove(t),hi.push(t),Ci(t),n.circle=null)}function wi(n,t){var e=n.b;if(e)return!0;var r,i,u=n.a,o=t[0][0],a=t[1][0],l=t[0][1],c=t[1][1],f=n.l,s=n.r,h=f.x,p=f.y,g=s.x,v=s.y,d=(h+g)/2,y=(p+v)/2;if(v===p){if(d<o||d>=a)return;if(h>g){if(u){if(u.y>=c)return}else u={x:d,y:l};e={x:d,y:c}}else{if(u){if(u.y<l)return}else u={x:d,y:c};e={x:d,y:l}}}else if(i=y-(r=(h-g)/(v-p))*d,r<-1||r>1)if(h>g){if(u){if(u.y>=c)return}else u={x:(l-i)/r,y:l};e={x:(c-i)/r,y:c}}else{if(u){if(u.y<l)return}else u={x:(c-i)/r,y:c};e={x:(l-i)/r,y:l}}else if(p<v){if(u){if(u.x>=a)return}else u={x:o,y:r*o+i};e={x:a,y:r*a+i}}else{if(u){if(u.x<o)return}else u={x:a,y:r*a+i};e={x:o,y:r*o+i}}return n.a=u,n.b=e,!0}function Si(n,t){this.l=n,this.r=t,this.a=this.b=null}function ki(n,t,e,r){var i=new Si(n,t);return oi.push(i),e&&Ni(i,n,t,e),r&&Ni(i,t,n,r),ai[n.i].edges.push(new Ei(i,n,t)),ai[t.i].edges.push(new Ei(i,t,n)),i}function Ni(n,t,e,r){n.a||n.b?n.l===e?n.b=r:n.a=r:(n.a=r,n.l=t,n.r=e)}function Ei(n,t,e){var r=n.a,i=n.b;this.edge=n,this.site=t,this.angle=e?Math.atan2(e.y-t.y,e.x-t.x):n.l===t?Math.atan2(i.x-r.x,r.y-i.y):Math.atan2(r.x-i.x,i.y-r.y)}function Ai(){this._=null}function Ci(n){n.U=n.C=n.L=n.R=n.P=n.N=null}function zi(n,t){var e=t,r=t.R,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.R=r.L,e.R&&(e.R.U=e),r.L=e}function Li(n,t){var e=t,r=t.L,i=e.U;i?i.L===e?i.L=r:i.R=r:n._=r,r.U=i,e.U=r,e.L=r.R,e.L&&(e.L.U=e),r.R=e}function qi(n){for(;n.L;)n=n.L;return n}function Ti(n,t){var e,r,i,u=n.sort(Ri).pop();for(oi=[],ai=new Array(n.length),li=new Ai,fi=new Ai;;)if(i=ci,u&&(!i||u.y<i.y||u.y===i.y&&u.x<i.x))u.x===e&&u.y===r||(ai[u.i]=new Mi(u),di(u),e=u.x,r=u.y),u=n.pop();else{if(!i)break;vi(i.arc)}t&&(function(n){for(var t,e=oi,r=tr(n[0][0],n[0][1],n[1][0],n[1][1]),i=e.length;i--;)(!wi(t=e[i],n)||!r(t)||y(t.a.x-t.b.x)<wn&&y(t.a.y-t.b.y)<wn)&&(t.a=t.b=null,e.splice(i,1))}(t),function(n){for(var t,e,r,i,u,o,a,l,c,f,s=n[0][0],h=n[1][0],p=n[0][1],g=n[1][1],v=ai,d=v.length;d--;)if((u=v[d])&&u.prepare())for(l=(a=u.edges).length,o=0;o<l;)r=(f=a[o].end()).x,i=f.y,t=(c=a[++o%l].start()).x,e=c.y,(y(r-t)>wn||y(i-e)>wn)&&(a.splice(o,0,new Ei((m=u.site,M=f,x=y(r-s)<wn&&g-i>wn?{x:s,y:y(t-s)<wn?e:g}:y(i-g)<wn&&h-r>wn?{x:y(e-g)<wn?t:h,y:g}:y(r-h)<wn&&i-p>wn?{x:h,y:y(t-h)<wn?e:p}:y(i-p)<wn&&r-s>wn?{x:y(e-p)<wn?t:s,y:p}:null,b=void 0,b=new Si(m,null),b.a=M,b.b=x,oi.push(b),b),u.site,null)),++l);var m,M,x,b}(t));var o={cells:ai,edges:oi};return li=fi=oi=ai=null,o}function Ri(n,t){return t.y-n.y||t.x-n.x}Mi.prototype.prepare=function(){for(var n,t=this.edges,e=t.length;e--;)(n=t[e].edge).b&&n.a||t.splice(e,1);return t.sort(xi),t.length},Ei.prototype={start:function(){return this.edge.l===this.site?this.edge.a:this.edge.b},end:function(){return this.edge.l===this.site?this.edge.b:this.edge.a}},Ai.prototype={insert:function(n,t){var e,r,i;if(n){if(t.P=n,t.N=n.N,n.N&&(n.N.P=t),n.N=t,n.R){for(n=n.R;n.L;)n=n.L;n.L=t}else n.R=t;e=n}else this._?(n=qi(this._),t.P=null,t.N=n,n.P=n.L=t,e=n):(t.P=t.N=null,this._=t,e=null);for(t.L=t.R=null,t.U=e,t.C=!0,n=t;e&&e.C;)e===(r=e.U).L?(i=r.R)&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.R&&(zi(this,e),e=(n=e).U),e.C=!1,r.C=!0,Li(this,r)):(i=r.L)&&i.C?(e.C=i.C=!1,r.C=!0,n=r):(n===e.L&&(Li(this,e),e=(n=e).U),e.C=!1,r.C=!0,zi(this,r)),e=n.U;this._.C=!1},remove:function(n){n.N&&(n.N.P=n.P),n.P&&(n.P.N=n.N),n.N=n.P=null;var t,e,r,i=n.U,u=n.L,o=n.R;if(e=u?o?qi(o):u:o,i?i.L===n?i.L=e:i.R=e:this._=e,u&&o?(r=e.C,e.C=n.C,e.L=u,u.U=e,e!==o?(i=e.U,e.U=n.U,n=e.R,i.L=n,e.R=o,o.U=e):(e.U=i,i=e,n=e.R)):(r=n.C,n=e),n&&(n.U=i),!r)if(n&&n.C)n.C=!1;else{do{if(n===this._)break;if(n===i.L){if((t=i.R).C&&(t.C=!1,i.C=!0,zi(this,i),t=i.R),t.L&&t.L.C||t.R&&t.R.C){t.R&&t.R.C||(t.L.C=!1,t.C=!0,Li(this,t),t=i.R),t.C=i.C,i.C=t.R.C=!1,zi(this,i),n=this._;break}}else if((t=i.L).C&&(t.C=!1,i.C=!0,Li(this,i),t=i.L),t.L&&t.L.C||t.R&&t.R.C){t.L&&t.L.C||(t.R.C=!1,t.C=!0,zi(this,t),t=i.L),t.C=i.C,i.C=t.L.C=!1,Li(this,i),n=this._;break}t.C=!0,n=i,i=i.U}while(!n.C);n&&(n.C=!1)}}},n.geom.voronoi=function(n){var t=Kr,e=Qr,r=t,i=e,u=Di;if(n)return o(n);function o(n){var t=new Array(n.length),e=u[0][0],r=u[0][1],i=u[1][0],o=u[1][1];return Ti(a(n),u).cells.forEach(function(u,a){var l=u.edges,c=u.site;(t[a]=l.length?l.map(function(n){var t=n.start();return[t.x,t.y]}):c.x>=e&&c.x<=i&&c.y>=r&&c.y<=o?[[e,o],[i,o],[i,r],[e,r]]:[]).point=n[a]}),t}function a(n){return n.map(function(n,t){return{x:Math.round(r(n,t)/wn)*wn,y:Math.round(i(n,t)/wn)*wn,i:t}})}return o.links=function(n){return Ti(a(n)).edges.filter(function(n){return n.l&&n.r}).map(function(t){return{source:n[t.l.i],target:n[t.r.i]}})},o.triangles=function(n){var t=[];return Ti(a(n)).cells.forEach(function(e,r){for(var i,u,o,a,l=e.site,c=e.edges.sort(xi),f=-1,s=c.length,h=c[s-1].edge,p=h.l===l?h.r:h.l;++f<s;)h,i=p,p=(h=c[f].edge).l===l?h.r:h.l,r<i.i&&r<p.i&&(o=i,a=p,((u=l).x-a.x)*(o.y-u.y)-(u.x-o.x)*(a.y-u.y)<0)&&t.push([n[r],n[i.i],n[p.i]])}),t},o.x=function(n){return arguments.length?(r=dt(t=n),o):t},o.y=function(n){return arguments.length?(i=dt(e=n),o):e},o.clipExtent=function(n){return arguments.length?(u=null==n?Di:n,o):u===Di?null:u},o.size=function(n){return arguments.length?o.clipExtent(n&&[[0,0],n]):u===Di?null:u&&u[1]},o};var Di=[[-1e6,-1e6],[1e6,1e6]];function Pi(n){return n.x}function Ui(n){return n.y}function ji(t,e){t=n.rgb(t),e=n.rgb(e);var r=t.r,i=t.g,u=t.b,o=e.r-r,a=e.g-i,l=e.b-u;return function(n){return"#"+ct(Math.round(r+o*n))+ct(Math.round(i+a*n))+ct(Math.round(u+l*n))}}function Fi(n,t){var e,r={},i={};for(e in n)e in t?r[e]=Zi(n[e],t[e]):i[e]=n[e];for(e in t)e in n||(i[e]=t[e]);return function(n){for(e in r)i[e]=r[e](n);return i}}function Hi(n,t){return n=+n,t=+t,function(e){return n*(1-e)+t*e}}function Oi(n,t){var e,r,i,u=Ii.lastIndex=Yi.lastIndex=0,o=-1,a=[],l=[];for(n+="",t+="";(e=Ii.exec(n))&&(r=Yi.exec(t));)(i=r.index)>u&&(i=t.slice(u,i),a[o]?a[o]+=i:a[++o]=i),(e=e[0])===(r=r[0])?a[o]?a[o]+=r:a[++o]=r:(a[++o]=null,l.push({i:o,x:Hi(e,r)})),u=Yi.lastIndex;return u<t.length&&(i=t.slice(u),a[o]?a[o]+=i:a[++o]=i),a.length<2?l[0]?(t=l[0].x,function(n){return t(n)+""}):function(){return t}:(t=l.length,function(n){for(var e,r=0;r<t;++r)a[(e=l[r]).i]=e.x(n);return a.join("")})}n.geom.delaunay=function(t){return n.geom.voronoi().triangles(t)},n.geom.quadtree=function(n,t,e,r,i){var u,o=Kr,a=Qr;if(u=arguments.length)return o=Pi,a=Ui,3===u&&(i=e,r=t,e=t=0),l(n);function l(n){var l,c,f,s,h,p,g,v,d,m=dt(o),M=dt(a);if(null!=t)p=t,g=e,v=r,d=i;else if(v=d=-(p=g=1/0),c=[],f=[],h=n.length,u)for(s=0;s<h;++s)(l=n[s]).x<p&&(p=l.x),l.y<g&&(g=l.y),l.x>v&&(v=l.x),l.y>d&&(d=l.y),c.push(l.x),f.push(l.y);else for(s=0;s<h;++s){var x=+m(l=n[s],s),b=+M(l,s);x<p&&(p=x),b<g&&(g=b),x>v&&(v=x),b>d&&(d=b),c.push(x),f.push(b)}var _=v-p,w=d-g;function S(n,t,e,r,i,u,o,a){if(!isNaN(e)&&!isNaN(r))if(n.leaf){var l=n.x,c=n.y;if(null!=l)if(y(l-e)+y(c-r)<.01)k(n,t,e,r,i,u,o,a);else{var f=n.point;n.x=n.y=n.point=null,k(n,f,l,c,i,u,o,a),k(n,t,e,r,i,u,o,a)}else n.x=e,n.y=r,n.point=t}else k(n,t,e,r,i,u,o,a)}function k(n,t,e,r,i,u,o,a){var l=.5*(i+o),c=.5*(u+a),f=e>=l,s=r>=c,h=s<<1|f;n.leaf=!1,n=n.nodes[h]||(n.nodes[h]={leaf:!0,nodes:[],point:null,x:null,y:null,add:function(n){S(N,n,+m(n,++s),+M(n,s),p,g,v,d)}}),f?i=l:o=l,s?u=c:a=c,S(n,t,e,r,i,u,o,a)}_>w?d=g+_:v=p+w;var N={leaf:!0,nodes:[],point:null,x:null,y:null,add:function(n){S(N,n,+m(n,++s),+M(n,s),p,g,v,d)}};if(N.visit=function(n){!function n(t,e,r,i,u,o){if(!t(e,r,i,u,o)){var a=.5*(r+u),l=.5*(i+o),c=e.nodes;c[0]&&n(t,c[0],r,i,a,l),c[1]&&n(t,c[1],a,i,u,l),c[2]&&n(t,c[2],r,l,a,o),c[3]&&n(t,c[3],a,l,u,o)}}(n,N,p,g,v,d)},N.find=function(n){return function(n,t,e,r,i,u,o){var a,l=1/0;return function n(c,f,s,h,p){if(!(f>u||s>o||h<r||p<i)){if(g=c.point){var g,v=t-c.x,d=e-c.y,y=v*v+d*d;if(y<l){var m=Math.sqrt(l=y);r=t-m,i=e-m,u=t+m,o=e+m,a=g}}for(var M=c.nodes,x=.5*(f+h),b=.5*(s+p),_=(e>=b)<<1|t>=x,w=_+4;_<w;++_)if(c=M[3&_])switch(3&_){case 0:n(c,f,s,x,b);break;case 1:n(c,x,s,h,b);break;case 2:n(c,f,b,x,p);break;case 3:n(c,x,b,h,p)}}}(n,r,i,u,o),a}(N,n[0],n[1],p,g,v,d)},s=-1,null==t){for(;++s<h;)S(N,n[s],c[s],f[s],p,g,v,d);--s}else n.forEach(N.add);return c=f=n=l=null,N}return l.x=function(n){return arguments.length?(o=n,l):o},l.y=function(n){return arguments.length?(a=n,l):a},l.extent=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=+n[0][0],e=+n[0][1],r=+n[1][0],i=+n[1][1]),l):null==t?null:[[t,e],[r,i]]},l.size=function(n){return arguments.length?(null==n?t=e=r=i=null:(t=e=0,r=+n[0],i=+n[1]),l):null==t?null:[r-t,i-e]},l},n.interpolateRgb=ji,n.interpolateObject=Fi,n.interpolateNumber=Hi,n.interpolateString=Oi;var Ii=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Yi=new RegExp(Ii.source,"g");function Zi(t,e){for(var r,i=n.interpolators.length;--i>=0&&!(r=n.interpolators[i](t,e)););return r}function Vi(n,t){var e,r=[],i=[],u=n.length,o=t.length,a=Math.min(n.length,t.length);for(e=0;e<a;++e)r.push(Zi(n[e],t[e]));for(;e<u;++e)i[e]=n[e];for(;e<o;++e)i[e]=t[e];return function(n){for(e=0;e<a;++e)i[e]=r[e](n);return i}}n.interpolate=Zi,n.interpolators=[function(n,t){var e=typeof t;return("string"===e?vt.has(t.toLowerCase())||/^(#|rgb\(|hsl\()/i.test(t)?ji:Oi:t instanceof On?ji:Array.isArray(t)?Vi:"object"===e&&isNaN(t)?Fi:Hi)(n,t)}],n.interpolateArray=Vi;var Xi=function(){return z},$i=n.map({linear:Xi,poly:function(n){return function(t){return Math.pow(t,n)}},quad:function(){return Gi},cubic:function(){return Ki},sin:function(){return nu},exp:function(){return tu},circle:function(){return eu},elastic:function(n,t){var e;arguments.length<2&&(t=.45);arguments.length?e=t/Nn*Math.asin(1/n):(n=1,e=t/4);return function(r){return 1+n*Math.pow(2,-10*r)*Math.sin((r-e)*Nn/t)}},back:function(n){n||(n=1.70158);return function(t){return t*t*((n+1)*t-n)}},bounce:function(){return ru}}),Bi=n.map({in:z,out:Wi,"in-out":Ji,"out-in":function(n){return Ji(Wi(n))}});function Wi(n){return function(t){return 1-n(1-t)}}function Ji(n){return function(t){return.5*(t<.5?n(2*t):2-n(2-2*t))}}function Gi(n){return n*n}function Ki(n){return n*n*n}function Qi(n){if(n<=0)return 0;if(n>=1)return 1;var t=n*n,e=t*n;return 4*(n<.5?e:3*(n-t)+e-.75)}function nu(n){return 1-Math.cos(n*An)}function tu(n){return Math.pow(2,10*(n-1))}function eu(n){return 1-Math.sqrt(1-n*n)}function ru(n){return n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375}function iu(n,t){return t-=n,function(e){return Math.round(n+t*e)}}function uu(n){var t,e,r,i=[n.a,n.b],u=[n.c,n.d],o=au(i),a=ou(i,u),l=au(((t=u)[0]+=(r=-a)*(e=i)[0],t[1]+=r*e[1],t))||0;i[0]*u[1]<u[0]*i[1]&&(i[0]*=-1,i[1]*=-1,o*=-1,a*=-1),this.rotate=(o?Math.atan2(i[1],i[0]):Math.atan2(-u[0],u[1]))*zn,this.translate=[n.e,n.f],this.scale=[o,l],this.skew=l?Math.atan2(a,l)*zn:0}function ou(n,t){return n[0]*t[0]+n[1]*t[1]}function au(n){var t=Math.sqrt(ou(n,n));return t&&(n[0]/=t,n[1]/=t),t}n.ease=function(n){var e,r=n.indexOf("-"),i=r>=0?n.slice(0,r):n,u=r>=0?n.slice(r+1):"in";return i=$i.get(i)||Xi,u=Bi.get(u)||z,e=u(i.apply(null,t.call(arguments,1))),function(n){return n<=0?0:n>=1?1:e(n)}},n.interpolateHcl=function(t,e){t=n.hcl(t),e=n.hcl(e);var r=t.h,i=t.c,u=t.l,o=e.h-r,a=e.c-i,l=e.l-u;isNaN(a)&&(a=0,i=isNaN(i)?e.c:i);isNaN(o)?(o=0,r=isNaN(r)?e.h:r):o>180?o-=360:o<-180&&(o+=360);return function(n){return $n(r+o*n,i+a*n,u+l*n)+""}},n.interpolateHsl=function(t,e){t=n.hsl(t),e=n.hsl(e);var r=t.h,i=t.s,u=t.l,o=e.h-r,a=e.s-i,l=e.l-u;isNaN(a)&&(a=0,i=isNaN(i)?e.s:i);isNaN(o)?(o=0,r=isNaN(r)?e.h:r):o>180?o-=360:o<-180&&(o+=360);return function(n){return Zn(r+o*n,i+a*n,u+l*n)+""}},n.interpolateLab=function(t,e){t=n.lab(t),e=n.lab(e);var r=t.l,i=t.a,u=t.b,o=e.l-r,a=e.a-i,l=e.b-u;return function(n){return nt(r+o*n,i+a*n,u+l*n)+""}},n.interpolateRound=iu,n.transform=function(t){var e=r.createElementNS(n.ns.prefix.svg,"g");return(n.transform=function(n){if(null!=n){e.setAttribute("transform",n);var t=e.transform.baseVal.consolidate()}return new uu(t?t.matrix:lu)})(t)},uu.prototype.toString=function(){return"translate("+this.translate+")rotate("+this.rotate+")skewX("+this.skew+")scale("+this.scale+")"};var lu={a:1,b:0,c:0,d:1,e:0,f:0};function cu(n){return n.length?n.pop()+",":""}function fu(t,e){var r=[],i=[];return t=n.transform(t),e=n.transform(e),function(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push("translate(",null,",",null,")");r.push({i:i-4,x:Hi(n[0],t[0])},{i:i-2,x:Hi(n[1],t[1])})}else(t[0]||t[1])&&e.push("translate("+t+")")}(t.translate,e.translate,r,i),function(n,t,e,r){n!==t?(n-t>180?t+=360:t-n>180&&(n+=360),r.push({i:e.push(cu(e)+"rotate(",null,")")-2,x:Hi(n,t)})):t&&e.push(cu(e)+"rotate("+t+")")}(t.rotate,e.rotate,r,i),function(n,t,e,r){n!==t?r.push({i:e.push(cu(e)+"skewX(",null,")")-2,x:Hi(n,t)}):t&&e.push(cu(e)+"skewX("+t+")")}(t.skew,e.skew,r,i),function(n,t,e,r){if(n[0]!==t[0]||n[1]!==t[1]){var i=e.push(cu(e)+"scale(",null,",",null,")");r.push({i:i-4,x:Hi(n[0],t[0])},{i:i-2,x:Hi(n[1],t[1])})}else 1===t[0]&&1===t[1]||e.push(cu(e)+"scale("+t+")")}(t.scale,e.scale,r,i),t=e=null,function(n){for(var t,e=-1,u=i.length;++e<u;)r[(t=i[e]).i]=t.x(n);return r.join("")}}function su(n,t){return t=(t-=n=+n)||1/t,function(e){return(e-n)/t}}function hu(n,t){return t=(t-=n=+n)||1/t,function(e){return Math.max(0,Math.min(1,(e-n)/t))}}function pu(n){for(var t=n.source,e=n.target,r=function(n,t){if(n===t)return n;var e=gu(n),r=gu(t),i=e.pop(),u=r.pop(),o=null;for(;i===u;)o=i,i=e.pop(),u=r.pop();return o}(t,e),i=[t];t!==r;)t=t.parent,i.push(t);for(var u=i.length;e!==r;)i.splice(u,0,e),e=e.parent;return i}function gu(n){for(var t=[],e=n.parent;null!=e;)t.push(n),n=e,e=e.parent;return t.push(n),t}function vu(n){n.fixed|=2}function du(n){n.fixed&=-7}function yu(n){n.fixed|=4,n.px=n.x,n.py=n.y}function mu(n){n.fixed&=-5}n.interpolateTransform=fu,n.layout={},n.layout.bundle=function(){return function(n){for(var t=[],e=-1,r=n.length;++e<r;)t.push(pu(n[e]));return t}},n.layout.chord=function(){var t,e,r,i,u,o,a,l={},c=0;function f(){var l,f,h,p,g,v={},d=[],y=n.range(i),m=[];for(t=[],e=[],l=0,p=-1;++p<i;){for(f=0,g=-1;++g<i;)f+=r[p][g];d.push(f),m.push(n.range(i)),l+=f}for(u&&y.sort(function(n,t){return u(d[n],d[t])}),o&&m.forEach(function(n,t){n.sort(function(n,e){return o(r[t][n],r[t][e])})}),l=(Nn-c*i)/l,f=0,p=-1;++p<i;){for(h=f,g=-1;++g<i;){var M=y[p],x=m[M][g],b=r[M][x],_=f,w=f+=b*l;v[M+"-"+x]={index:M,subindex:x,startAngle:_,endAngle:w,value:b}}e[M]={index:M,startAngle:h,endAngle:f,value:d[M]},f+=c}for(p=-1;++p<i;)for(g=p-1;++g<i;){var S=v[p+"-"+g],k=v[g+"-"+p];(S.value||k.value)&&t.push(S.value<k.value?{source:k,target:S}:{source:S,target:k})}a&&s()}function s(){t.sort(function(n,t){return a((n.source.value+n.target.value)/2,(t.source.value+t.target.value)/2)})}return l.matrix=function(n){return arguments.length?(i=(r=n)&&r.length,t=e=null,l):r},l.padding=function(n){return arguments.length?(c=n,t=e=null,l):c},l.sortGroups=function(n){return arguments.length?(u=n,t=e=null,l):u},l.sortSubgroups=function(n){return arguments.length?(o=n,t=null,l):o},l.sortChords=function(n){return arguments.length?(a=n,t&&s(),l):a},l.chords=function(){return t||f(),t},l.groups=function(){return e||f(),e},l},n.layout.force=function(){var t,e,r,i,u,o,a={},l=n.dispatch("start","tick","end"),c=[1,1],f=.9,s=Mu,h=xu,p=-30,g=bu,v=.1,d=.64,y=[],m=[];function M(n){return function(t,e,r,i){if(t.point!==n){var u=t.cx-n.x,o=t.cy-n.y,a=i-e,l=u*u+o*o;if(a*a/d<l){if(l<g){var c=t.charge/l;n.px-=u*c,n.py-=o*c}return!0}if(t.point&&l&&l<g){c=t.pointCharge/l;n.px-=u*c,n.py-=o*c}}return!t.charge}}function x(t){t.px=n.event.x,t.py=n.event.y,a.resume()}return a.tick=function(){if((r*=.99)<.005)return t=null,l.end({type:"end",alpha:r=0}),!0;var e,a,s,h,g,d,x,b,_,w=y.length,S=m.length;for(a=0;a<S;++a)h=(s=m[a]).source,(d=(b=(g=s.target).x-h.x)*b+(_=g.y-h.y)*_)&&(b*=d=r*u[a]*((d=Math.sqrt(d))-i[a])/d,_*=d,g.x-=b*(x=h.weight+g.weight?h.weight/(h.weight+g.weight):.5),g.y-=_*x,h.x+=b*(x=1-x),h.y+=_*x);if((x=r*v)&&(b=c[0]/2,_=c[1]/2,a=-1,x))for(;++a<w;)(s=y[a]).x+=(b-s.x)*x,s.y+=(_-s.y)*x;if(p)for(!function n(t,e,r){var i=0,u=0;t.charge=0;if(!t.leaf)for(var o,a=t.nodes,l=a.length,c=-1;++c<l;)null!=(o=a[c])&&(n(o,e,r),t.charge+=o.charge,i+=o.charge*o.cx,u+=o.charge*o.cy);if(t.point){t.leaf||(t.point.x+=Math.random()-.5,t.point.y+=Math.random()-.5);var f=e*r[t.point.index];t.charge+=t.pointCharge=f,i+=f*t.point.x,u+=f*t.point.y}t.cx=i/t.charge;t.cy=u/t.charge}(e=n.geom.quadtree(y),r,o),a=-1;++a<w;)(s=y[a]).fixed||e.visit(M(s));for(a=-1;++a<w;)(s=y[a]).fixed?(s.x=s.px,s.y=s.py):(s.x-=(s.px-(s.px=s.x))*f,s.y-=(s.py-(s.py=s.y))*f);l.tick({type:"tick",alpha:r})},a.nodes=function(n){return arguments.length?(y=n,a):y},a.links=function(n){return arguments.length?(m=n,a):m},a.size=function(n){return arguments.length?(c=n,a):c},a.linkDistance=function(n){return arguments.length?(s="function"==typeof n?n:+n,a):s},a.distance=a.linkDistance,a.linkStrength=function(n){return arguments.length?(h="function"==typeof n?n:+n,a):h},a.friction=function(n){return arguments.length?(f=+n,a):f},a.charge=function(n){return arguments.length?(p="function"==typeof n?n:+n,a):p},a.chargeDistance=function(n){return arguments.length?(g=n*n,a):Math.sqrt(g)},a.gravity=function(n){return arguments.length?(v=+n,a):v},a.theta=function(n){return arguments.length?(d=n*n,a):Math.sqrt(d)},a.alpha=function(n){return arguments.length?(n=+n,r?n>0?r=n:(t.c=null,t.t=NaN,t=null,l.end({type:"end",alpha:r=0})):n>0&&(l.start({type:"start",alpha:r=n}),t=St(a.tick)),a):r},a.start=function(){var n,t,e,r=y.length,l=m.length,f=c[0],g=c[1];for(n=0;n<r;++n)(e=y[n]).index=n,e.weight=0;for(n=0;n<l;++n)"number"==typeof(e=m[n]).source&&(e.source=y[e.source]),"number"==typeof e.target&&(e.target=y[e.target]),++e.source.weight,++e.target.weight;for(n=0;n<r;++n)e=y[n],isNaN(e.x)&&(e.x=v("x",f)),isNaN(e.y)&&(e.y=v("y",g)),isNaN(e.px)&&(e.px=e.x),isNaN(e.py)&&(e.py=e.y);if(i=[],"function"==typeof s)for(n=0;n<l;++n)i[n]=+s.call(this,m[n],n);else for(n=0;n<l;++n)i[n]=s;if(u=[],"function"==typeof h)for(n=0;n<l;++n)u[n]=+h.call(this,m[n],n);else for(n=0;n<l;++n)u[n]=h;if(o=[],"function"==typeof p)for(n=0;n<r;++n)o[n]=+p.call(this,y[n],n);else for(n=0;n<r;++n)o[n]=p;function v(e,i){if(!t){for(t=new Array(r),c=0;c<r;++c)t[c]=[];for(c=0;c<l;++c){var u=m[c];t[u.source.index].push(u.target),t[u.target.index].push(u.source)}}for(var o,a=t[n],c=-1,f=a.length;++c<f;)if(!isNaN(o=a[c][e]))return o;return Math.random()*i}return a.resume()},a.resume=function(){return a.alpha(.1)},a.stop=function(){return a.alpha(0)},a.drag=function(){if(e||(e=n.behavior.drag().origin(z).on("dragstart.force",vu).on("drag.force",x).on("dragend.force",du)),!arguments.length)return e;this.on("mouseover.force",yu).on("mouseout.force",mu).call(e)},n.rebind(a,l,"on")};var Mu=20,xu=1,bu=1/0;function _u(t,e){return n.rebind(t,e,"sort","children","value"),t.nodes=t,t.links=Au,t}function wu(n,t){for(var e=[n];null!=(n=e.pop());)if(t(n),(i=n.children)&&(r=i.length))for(var r,i;--r>=0;)e.push(i[r])}function Su(n,t){for(var e=[n],r=[];null!=(n=e.pop());)if(r.push(n),(u=n.children)&&(i=u.length))for(var i,u,o=-1;++o<i;)e.push(u[o]);for(;null!=(n=r.pop());)t(n)}function ku(n){return n.children}function Nu(n){return n.value}function Eu(n,t){return t.value-n.value}function Au(t){return n.merge(t.map(function(n){return(n.children||[]).map(function(t){return{source:n,target:t}})}))}n.layout.hierarchy=function(){var n=Eu,t=ku,e=Nu;function r(i){var u,o=[i],a=[];for(i.depth=0;null!=(u=o.pop());)if(a.push(u),(c=t.call(r,u,u.depth))&&(l=c.length)){for(var l,c,f;--l>=0;)o.push(f=c[l]),f.parent=u,f.depth=u.depth+1;e&&(u.value=0),u.children=c}else e&&(u.value=+e.call(r,u,u.depth)||0),delete u.children;return Su(i,function(t){var r,i;n&&(r=t.children)&&r.sort(n),e&&(i=t.parent)&&(i.value+=t.value)}),a}return r.sort=function(t){return arguments.length?(n=t,r):n},r.children=function(n){return arguments.length?(t=n,r):t},r.value=function(n){return arguments.length?(e=n,r):e},r.revalue=function(n){return e&&(wu(n,function(n){n.children&&(n.value=0)}),Su(n,function(n){var t;n.children||(n.value=+e.call(r,n,n.depth)||0),(t=n.parent)&&(t.value+=n.value)})),n},r},n.layout.partition=function(){var t=n.layout.hierarchy(),e=[1,1];function r(n,r){var i=t.call(this,n,r);return function n(t,e,r,i){var u=t.children;if(t.x=e,t.y=t.depth*i,t.dx=r,t.dy=i,u&&(o=u.length)){var o,a,l,c=-1;for(r=t.value?r/t.value:0;++c<o;)n(a=u[c],e,l=a.value*r,i),e+=l}}(i[0],0,e[0],e[1]/function n(t){var e=t.children,r=0;if(e&&(i=e.length))for(var i,u=-1;++u<i;)r=Math.max(r,n(e[u]));return 1+r}(i[0])),i}return r.size=function(n){return arguments.length?(e=n,r):e},_u(r,t)},n.layout.pie=function(){var t=Number,e=Cu,r=0,i=Nn,u=0;function o(a){var l,c=a.length,f=a.map(function(n,e){return+t.call(o,n,e)}),s=+("function"==typeof r?r.apply(this,arguments):r),h=("function"==typeof i?i.apply(this,arguments):i)-s,p=Math.min(Math.abs(h)/c,+("function"==typeof u?u.apply(this,arguments):u)),g=p*(h<0?-1:1),v=n.sum(f),d=v?(h-c*g)/v:0,y=n.range(c),m=[];return null!=e&&y.sort(e===Cu?function(n,t){return f[t]-f[n]}:function(n,t){return e(a[n],a[t])}),y.forEach(function(n){m[n]={data:a[n],value:l=f[n],startAngle:s,endAngle:s+=l*d+g,padAngle:p}}),m}return o.value=function(n){return arguments.length?(t=n,o):t},o.sort=function(n){return arguments.length?(e=n,o):e},o.startAngle=function(n){return arguments.length?(r=n,o):r},o.endAngle=function(n){return arguments.length?(i=n,o):i},o.padAngle=function(n){return arguments.length?(u=n,o):u},o};var Cu={};function zu(n){return n.x}function Lu(n){return n.y}function qu(n,t,e){n.y0=t,n.y=e}n.layout.stack=function(){var t=z,e=Du,r=Pu,i=qu,u=zu,o=Lu;function a(l,c){if(!(p=l.length))return l;var f=l.map(function(n,e){return t.call(a,n,e)}),s=f.map(function(n){return n.map(function(n,t){return[u.call(a,n,t),o.call(a,n,t)]})}),h=e.call(a,s,c);f=n.permute(f,h),s=n.permute(s,h);var p,g,v,d,y=r.call(a,s,c),m=f[0].length;for(v=0;v<m;++v)for(i.call(a,f[0][v],d=y[v],s[0][v][1]),g=1;g<p;++g)i.call(a,f[g][v],d+=s[g-1][v][1],s[g][v][1]);return l}return a.values=function(n){return arguments.length?(t=n,a):t},a.order=function(n){return arguments.length?(e="function"==typeof n?n:Tu.get(n)||Du,a):e},a.offset=function(n){return arguments.length?(r="function"==typeof n?n:Ru.get(n)||Pu,a):r},a.x=function(n){return arguments.length?(u=n,a):u},a.y=function(n){return arguments.length?(o=n,a):o},a.out=function(n){return arguments.length?(i=n,a):i},a};var Tu=n.map({"inside-out":function(t){var e,r,i=t.length,u=t.map(Uu),o=t.map(ju),a=n.range(i).sort(function(n,t){return u[n]-u[t]}),l=0,c=0,f=[],s=[];for(e=0;e<i;++e)r=a[e],l<c?(l+=o[r],f.push(r)):(c+=o[r],s.push(r));return s.reverse().concat(f)},reverse:function(t){return n.range(t.length).reverse()},default:Du}),Ru=n.map({silhouette:function(n){var t,e,r,i=n.length,u=n[0].length,o=[],a=0,l=[];for(e=0;e<u;++e){for(t=0,r=0;t<i;t++)r+=n[t][e][1];r>a&&(a=r),o.push(r)}for(e=0;e<u;++e)l[e]=(a-o[e])/2;return l},wiggle:function(n){var t,e,r,i,u,o,a,l,c,f=n.length,s=n[0],h=s.length,p=[];for(p[0]=l=c=0,e=1;e<h;++e){for(t=0,i=0;t<f;++t)i+=n[t][e][1];for(t=0,u=0,a=s[e][0]-s[e-1][0];t<f;++t){for(r=0,o=(n[t][e][1]-n[t][e-1][1])/(2*a);r<t;++r)o+=(n[r][e][1]-n[r][e-1][1])/a;u+=o*n[t][e][1]}p[e]=l-=i?u/i*a:0,l<c&&(c=l)}for(e=0;e<h;++e)p[e]-=c;return p},expand:function(n){var t,e,r,i=n.length,u=n[0].length,o=1/i,a=[];for(e=0;e<u;++e){for(t=0,r=0;t<i;t++)r+=n[t][e][1];if(r)for(t=0;t<i;t++)n[t][e][1]/=r;else for(t=0;t<i;t++)n[t][e][1]=o}for(e=0;e<u;++e)a[e]=0;return a},zero:Pu});function Du(t){return n.range(t.length)}function Pu(n){for(var t=-1,e=n[0].length,r=[];++t<e;)r[t]=0;return r}function Uu(n){for(var t,e=1,r=0,i=n[0][1],u=n.length;e<u;++e)(t=n[e][1])>i&&(r=e,i=t);return r}function ju(n){return n.reduce(Fu,0)}function Fu(n,t){return n+t[1]}function Hu(n,t){return Ou(n,Math.ceil(Math.log(t.length)/Math.LN2+1))}function Ou(n,t){for(var e=-1,r=+n[0],i=(n[1]-r)/t,u=[];++e<=t;)u[e]=i*e+r;return u}function Iu(t){return[n.min(t),n.max(t)]}function Yu(n,t){return n.value-t.value}function Zu(n,t){var e=n._pack_next;n._pack_next=t,t._pack_prev=n,t._pack_next=e,e._pack_prev=t}function Vu(n,t){n._pack_next=t,t._pack_prev=n}function Xu(n,t){var e=t.x-n.x,r=t.y-n.y,i=n.r+t.r;return.999*i*i>e*e+r*r}function $u(n){if((t=n.children)&&(l=t.length)){var t,e,r,i,u,o,a,l,c=1/0,f=-1/0,s=1/0,h=-1/0;if(t.forEach(Bu),(e=t[0]).x=-e.r,e.y=0,M(e),l>1&&((r=t[1]).x=r.r,r.y=0,M(r),l>2))for(Ju(e,r,i=t[2]),M(i),Zu(e,i),e._pack_prev=i,Zu(i,r),r=e._pack_next,u=3;u<l;u++){Ju(e,r,i=t[u]);var p=0,g=1,v=1;for(o=r._pack_next;o!==r;o=o._pack_next,g++)if(Xu(o,i)){p=1;break}if(1==p)for(a=e._pack_prev;a!==o._pack_prev&&!Xu(a,i);a=a._pack_prev,v++);p?(g<v||g==v&&r.r<e.r?Vu(e,r=o):Vu(e=a,r),u--):(Zu(e,i),r=i,M(i))}var d=(c+f)/2,y=(s+h)/2,m=0;for(u=0;u<l;u++)(i=t[u]).x-=d,i.y-=y,m=Math.max(m,i.r+Math.sqrt(i.x*i.x+i.y*i.y));n.r=m,t.forEach(Wu)}function M(n){c=Math.min(n.x-n.r,c),f=Math.max(n.x+n.r,f),s=Math.min(n.y-n.r,s),h=Math.max(n.y+n.r,h)}}function Bu(n){n._pack_next=n._pack_prev=n}function Wu(n){delete n._pack_next,delete n._pack_prev}function Ju(n,t,e){var r=n.r+e.r,i=t.x-n.x,u=t.y-n.y;if(r&&(i||u)){var o=t.r+e.r,a=i*i+u*u,l=.5+((r*=r)-(o*=o))/(2*a),c=Math.sqrt(Math.max(0,2*o*(r+a)-(r-=a)*r-o*o))/(2*a);e.x=n.x+l*i+c*u,e.y=n.y+l*u-c*i}else e.x=n.x+r,e.y=n.y}function Gu(n,t){return n.parent==t.parent?1:2}function Ku(n){var t=n.children;return t.length?t[0]:n.t}function Qu(n){var t,e=n.children;return(t=e.length)?e[t-1]:n.t}function no(n,t,e){var r=e/(t.i-n.i);t.c-=r,t.s+=e,n.c+=r,t.z+=e,t.m+=e}function to(n,t,e){return n.a.parent===t.parent?n.a:e}function eo(n){return{x:n.x,y:n.y,dx:n.dx,dy:n.dy}}function ro(n,t){var e=n.x+t[3],r=n.y+t[0],i=n.dx-t[1]-t[3],u=n.dy-t[0]-t[2];return i<0&&(e+=i/2,i=0),u<0&&(r+=u/2,u=0),{x:e,y:r,dx:i,dy:u}}function io(n){var t=n[0],e=n[n.length-1];return t<e?[t,e]:[e,t]}function uo(n){return n.rangeExtent?n.rangeExtent():io(n.range())}function oo(n,t,e,r){var i=e(n[0],n[1]),u=r(t[0],t[1]);return function(n){return u(i(n))}}function ao(n,t){var e,r=0,i=n.length-1,u=n[r],o=n[i];return o<u&&(e=r,r=i,i=e,e=u,u=o,o=e),n[r]=t.floor(u),n[i]=t.ceil(o),n}function lo(n){return n?{floor:function(t){return Math.floor(t/n)*n},ceil:function(t){return Math.ceil(t/n)*n}}:co}n.layout.histogram=function(){var t=!0,e=Number,r=Iu,i=Hu;function u(u,o){for(var a,l,c=[],f=u.map(e,this),s=r.call(this,f,o),h=i.call(this,s,f,o),p=(o=-1,f.length),g=h.length-1,v=t?1:1/p;++o<g;)(a=c[o]=[]).dx=h[o+1]-(a.x=h[o]),a.y=0;if(g>0)for(o=-1;++o<p;)(l=f[o])>=s[0]&&l<=s[1]&&((a=c[n.bisect(h,l,1,g)-1]).y+=v,a.push(u[o]));return c}return u.value=function(n){return arguments.length?(e=n,u):e},u.range=function(n){return arguments.length?(r=dt(n),u):r},u.bins=function(n){return arguments.length?(i="number"==typeof n?function(t){return Ou(t,n)}:dt(n),u):i},u.frequency=function(n){return arguments.length?(t=!!n,u):t},u},n.layout.pack=function(){var t,e=n.layout.hierarchy().sort(Yu),r=0,i=[1,1];function u(n,u){var o=e.call(this,n,u),a=o[0],l=i[0],c=i[1],f=null==t?Math.sqrt:"function"==typeof t?t:function(){return t};if(a.x=a.y=0,Su(a,function(n){n.r=+f(n.value)}),Su(a,$u),r){var s=r*(t?1:Math.max(2*a.r/l,2*a.r/c))/2;Su(a,function(n){n.r+=s}),Su(a,$u),Su(a,function(n){n.r-=s})}return function n(t,e,r,i){var u=t.children;t.x=e+=i*t.x;t.y=r+=i*t.y;t.r*=i;if(u)for(var o=-1,a=u.length;++o<a;)n(u[o],e,r,i)}(a,l/2,c/2,t?1:1/Math.max(2*a.r/l,2*a.r/c)),o}return u.size=function(n){return arguments.length?(i=n,u):i},u.radius=function(n){return arguments.length?(t=null==n||"function"==typeof n?n:+n,u):t},u.padding=function(n){return arguments.length?(r=+n,u):r},_u(u,e)},n.layout.tree=function(){var t=n.layout.hierarchy().sort(null).value(null),e=Gu,r=[1,1],i=null;function u(n,u){var c=t.call(this,n,u),f=c[0],s=function(n){var t,e={A:null,children:[n]},r=[e];for(;null!=(t=r.pop());)for(var i,u=t.children,o=0,a=u.length;o<a;++o)r.push((u[o]=i={_:u[o],parent:t,children:(i=u[o].children)&&i.slice()||[],A:null,a:null,z:0,m:0,c:0,s:0,t:null,i:o}).a=i);return e.children[0]}(f);if(Su(s,o),s.parent.m=-s.z,wu(s,a),i)wu(f,l);else{var h=f,p=f,g=f;wu(f,function(n){n.x<h.x&&(h=n),n.x>p.x&&(p=n),n.depth>g.depth&&(g=n)});var v=e(h,p)/2-h.x,d=r[0]/(p.x+e(p,h)/2+v),y=r[1]/(g.depth||1);wu(f,function(n){n.x=(n.x+v)*d,n.y=n.depth*y})}return c}function o(n){var t=n.children,r=n.parent.children,i=n.i?r[n.i-1]:null;if(t.length){!function(n){var t,e=0,r=0,i=n.children,u=i.length;for(;--u>=0;)(t=i[u]).z+=e,t.m+=e,e+=t.s+(r+=t.c)}(n);var u=(t[0].z+t[t.length-1].z)/2;i?(n.z=i.z+e(n._,i._),n.m=n.z-u):n.z=u}else i&&(n.z=i.z+e(n._,i._));n.parent.A=function(n,t,r){if(t){for(var i,u=n,o=n,a=t,l=u.parent.children[0],c=u.m,f=o.m,s=a.m,h=l.m;a=Qu(a),u=Ku(u),a&&u;)l=Ku(l),(o=Qu(o)).a=n,(i=a.z+s-u.z-c+e(a._,u._))>0&&(no(to(a,n,r),n,i),c+=i,f+=i),s+=a.m,c+=u.m,h+=l.m,f+=o.m;a&&!Qu(o)&&(o.t=a,o.m+=s-f),u&&!Ku(l)&&(l.t=u,l.m+=c-h,r=n)}return r}(n,i,n.parent.A||r[0])}function a(n){n._.x=n.z+n.parent.m,n.m+=n.parent.m}function l(n){n.x*=r[0],n.y=n.depth*r[1]}return u.separation=function(n){return arguments.length?(e=n,u):e},u.size=function(n){return arguments.length?(i=null==(r=n)?l:null,u):i?null:r},u.nodeSize=function(n){return arguments.length?(i=null==(r=n)?null:l,u):i?r:null},_u(u,t)},n.layout.cluster=function(){var t=n.layout.hierarchy().sort(null).value(null),e=Gu,r=[1,1],i=!1;function u(u,o){var a,l=t.call(this,u,o),c=l[0],f=0;Su(c,function(t){var r=t.children;r&&r.length?(t.x=function(n){return n.reduce(function(n,t){return n+t.x},0)/n.length}(r),t.y=function(t){return 1+n.max(t,function(n){return n.y})}(r)):(t.x=a?f+=e(t,a):0,t.y=0,a=t)});var s=function n(t){var e=t.children;return e&&e.length?n(e[0]):t}(c),h=function n(t){var e,r=t.children;return r&&(e=r.length)?n(r[e-1]):t}(c),p=s.x-e(s,h)/2,g=h.x+e(h,s)/2;return Su(c,i?function(n){n.x=(n.x-c.x)*r[0],n.y=(c.y-n.y)*r[1]}:function(n){n.x=(n.x-p)/(g-p)*r[0],n.y=(1-(c.y?n.y/c.y:1))*r[1]}),l}return u.separation=function(n){return arguments.length?(e=n,u):e},u.size=function(n){return arguments.length?(i=null==(r=n),u):i?null:r},u.nodeSize=function(n){return arguments.length?(i=null!=(r=n),u):i?r:null},_u(u,t)},n.layout.treemap=function(){var t,e=n.layout.hierarchy(),r=Math.round,i=[1,1],u=null,o=eo,a=!1,l="squarify",c=.5*(1+Math.sqrt(5));function f(n,t){for(var e,r,i=-1,u=n.length;++i<u;)r=(e=n[i]).value*(t<0?0:t),e.area=isNaN(r)||r<=0?0:r}function s(n){var t=n.children;if(t&&t.length){var e,r,i,u=o(n),a=[],c=t.slice(),h=1/0,v="slice"===l?u.dx:"dice"===l?u.dy:"slice-dice"===l?1&n.depth?u.dy:u.dx:Math.min(u.dx,u.dy);for(f(c,u.dx*u.dy/n.value),a.area=0;(i=c.length)>0;)a.push(e=c[i-1]),a.area+=e.area,"squarify"!==l||(r=p(a,v))<=h?(c.pop(),h=r):(a.area-=a.pop().area,g(a,v,u,!1),v=Math.min(u.dx,u.dy),a.length=a.area=0,h=1/0);a.length&&(g(a,v,u,!0),a.length=a.area=0),t.forEach(s)}}function h(n){var t=n.children;if(t&&t.length){var e,r=o(n),i=t.slice(),u=[];for(f(i,r.dx*r.dy/n.value),u.area=0;e=i.pop();)u.push(e),u.area+=e.area,null!=e.z&&(g(u,e.z?r.dx:r.dy,r,!i.length),u.length=u.area=0);t.forEach(h)}}function p(n,t){for(var e,r=n.area,i=0,u=1/0,o=-1,a=n.length;++o<a;)(e=n[o].area)&&(e<u&&(u=e),e>i&&(i=e));return t*=t,(r*=r)?Math.max(t*i*c/r,r/(t*u*c)):1/0}function g(n,t,e,i){var u,o=-1,a=n.length,l=e.x,c=e.y,f=t?r(n.area/t):0;if(t==e.dx){for((i||f>e.dy)&&(f=e.dy);++o<a;)(u=n[o]).x=l,u.y=c,u.dy=f,l+=u.dx=Math.min(e.x+e.dx-l,f?r(u.area/f):0);u.z=!0,u.dx+=e.x+e.dx-l,e.y+=f,e.dy-=f}else{for((i||f>e.dx)&&(f=e.dx);++o<a;)(u=n[o]).x=l,u.y=c,u.dx=f,c+=u.dy=Math.min(e.y+e.dy-c,f?r(u.area/f):0);u.z=!1,u.dy+=e.y+e.dy-c,e.x+=f,e.dx-=f}}function v(n){var r=t||e(n),u=r[0];return u.x=u.y=0,u.value?(u.dx=i[0],u.dy=i[1]):u.dx=u.dy=0,t&&e.revalue(u),f([u],u.dx*u.dy/u.value),(t?h:s)(u),a&&(t=r),r}return v.size=function(n){return arguments.length?(i=n,v):i},v.padding=function(n){if(!arguments.length)return u;function t(t){return ro(t,n)}var e;return o=null==(u=n)?eo:"function"==(e=typeof n)?function(t){var e=n.call(v,t,t.depth);return null==e?eo(t):ro(t,"number"==typeof e?[e,e,e,e]:e)}:"number"===e?(n=[n,n,n,n],t):t,v},v.round=function(n){return arguments.length?(r=n?Math.round:Number,v):r!=Number},v.sticky=function(n){return arguments.length?(a=n,t=null,v):a},v.ratio=function(n){return arguments.length?(c=n,v):c},v.mode=function(n){return arguments.length?(l=n+"",v):l},_u(v,e)},n.random={normal:function(n,t){var e=arguments.length;return e<2&&(t=1),e<1&&(n=0),function(){var e,r,i;do{i=(e=2*Math.random()-1)*e+(r=2*Math.random()-1)*r}while(!i||i>1);return n+t*e*Math.sqrt(-2*Math.log(i)/i)}},logNormal:function(){var t=n.random.normal.apply(n,arguments);return function(){return Math.exp(t())}},bates:function(t){var e=n.random.irwinHall(t);return function(){return e()/t}},irwinHall:function(n){return function(){for(var t=0,e=0;e<n;e++)t+=Math.random();return t}}},n.scale={};var co={floor:z,ceil:z};function fo(t,e,r,i){var u=[],o=[],a=0,l=Math.min(t.length,e.length)-1;for(t[l]<t[0]&&(t=t.slice().reverse(),e=e.slice().reverse());++a<=l;)u.push(r(t[a-1],t[a])),o.push(i(e[a-1],e[a]));return function(e){var r=n.bisect(t,e,1,l)-1;return o[r](u[r](e))}}function so(t,e){return n.rebind(t,e,"range","rangeRound","interpolate","clamp")}function ho(n,t){return ao(n,lo(po(n,t)[2])),ao(n,lo(po(n,t)[2])),n}function po(n,t){null==t&&(t=10);var e=io(n),r=e[1]-e[0],i=Math.pow(10,Math.floor(Math.log(r/t)/Math.LN10)),u=t/r*i;return u<=.15?i*=10:u<=.35?i*=5:u<=.75&&(i*=2),e[0]=Math.ceil(e[0]/i)*i,e[1]=Math.floor(e[1]/i)*i+.5*i,e[2]=i,e}function go(t,e){return n.range.apply(n,po(t,e))}function vo(t,e,r){var i=po(t,e);if(r){var u=zt.exec(r);if(u.shift(),"s"===u[8]){var o=n.formatPrefix(Math.max(y(i[0]),y(i[1])));return u[7]||(u[7]="."+mo(o.scale(i[2]))),u[8]="f",r=n.format(u.join("")),function(n){return r(o.scale(n))+o.symbol}}u[7]||(u[7]="."+function(n,t){var e=mo(t[2]);return n in yo?Math.abs(e-mo(Math.max(y(t[0]),y(t[1]))))+ +("e"!==n):e-2*("%"===n)}(u[8],i)),r=u.join("")}else r=",."+mo(i[2])+"f";return n.format(r)}n.scale.linear=function(){return function n(t,e,r,i){var u,o;function a(){var n=Math.min(t.length,e.length)>2?fo:oo,a=i?hu:su;return u=n(t,e,a,r),o=n(e,t,a,Zi),l}function l(n){return u(n)}l.invert=function(n){return o(n)};l.domain=function(n){return arguments.length?(t=n.map(Number),a()):t};l.range=function(n){return arguments.length?(e=n,a()):e};l.rangeRound=function(n){return l.range(n).interpolate(iu)};l.clamp=function(n){return arguments.length?(i=n,a()):i};l.interpolate=function(n){return arguments.length?(r=n,a()):r};l.ticks=function(n){return go(t,n)};l.tickFormat=function(n,e){return vo(t,n,e)};l.nice=function(n){return ho(t,n),a()};l.copy=function(){return n(t,e,r,i)};return a()}([0,1],[0,1],Zi,!1)};var yo={s:1,g:1,p:1,r:1,e:1};function mo(n){return-Math.floor(Math.log(n)/Math.LN10+.01)}n.scale.log=function(){return function t(e,r,i,u){function o(n){return(i?Math.log(n<0?0:n):-Math.log(n>0?0:-n))/Math.log(r)}function a(n){return i?Math.pow(r,n):-Math.pow(r,-n)}function l(n){return e(o(n))}l.invert=function(n){return a(e.invert(n))};l.domain=function(n){return arguments.length?(i=n[0]>=0,e.domain((u=n.map(Number)).map(o)),l):u};l.base=function(n){return arguments.length?(r=+n,e.domain(u.map(o)),l):r};l.nice=function(){var n=ao(u.map(o),i?Math:xo);return e.domain(n),u=n.map(a),l};l.ticks=function(){var n=io(u),t=[],e=n[0],l=n[1],c=Math.floor(o(e)),f=Math.ceil(o(l)),s=r%1?2:r;if(isFinite(f-c)){if(i){for(;c<f;c++)for(var h=1;h<s;h++)t.push(a(c)*h);t.push(a(c))}else for(t.push(a(c));c++<f;)for(var h=s-1;h>0;h--)t.push(a(c)*h);for(c=0;t[c]<e;c++);for(f=t.length;t[f-1]>l;f--);t=t.slice(c,f)}return t};l.tickFormat=function(t,e){if(!arguments.length)return Mo;arguments.length<2?e=Mo:"function"!=typeof e&&(e=n.format(e));var i=Math.max(1,r*t/l.ticks().length);return function(n){var t=n/a(Math.round(o(n)));return t*r<r-.5&&(t*=r),t<=i?e(n):""}};l.copy=function(){return t(e.copy(),r,i,u)};return so(l,e)}(n.scale.linear().domain([0,1]),10,!0,[1,10])};var Mo=n.format(".0e"),xo={floor:function(n){return-Math.ceil(-n)},ceil:function(n){return-Math.floor(-n)}};function bo(n){return function(t){return t<0?-Math.pow(-t,n):Math.pow(t,n)}}n.scale.pow=function(){return function n(t,e,r){var i=bo(e),u=bo(1/e);function o(n){return t(i(n))}o.invert=function(n){return u(t.invert(n))};o.domain=function(n){return arguments.length?(t.domain((r=n.map(Number)).map(i)),o):r};o.ticks=function(n){return go(r,n)};o.tickFormat=function(n,t){return vo(r,n,t)};o.nice=function(n){return o.domain(ho(r,n))};o.exponent=function(n){return arguments.length?(i=bo(e=n),u=bo(1/e),t.domain(r.map(i)),o):e};o.copy=function(){return n(t.copy(),e,r)};return so(o,t)}(n.scale.linear(),1,[0,1])},n.scale.sqrt=function(){return n.scale.pow().exponent(.5)},n.scale.ordinal=function(){return function t(e,r){var i,u,o;function a(n){return u[((i.get(n)||("range"===r.t?i.set(n,e.push(n)):NaN))-1)%u.length]}function l(t,r){return n.range(e.length).map(function(n){return t+r*n})}a.domain=function(n){if(!arguments.length)return e;e=[],i=new M;for(var t,u=-1,o=n.length;++u<o;)i.has(t=n[u])||i.set(t,e.push(t));return a[r.t].apply(a,r.a)};a.range=function(n){return arguments.length?(u=n,o=0,r={t:"range",a:arguments},a):u};a.rangePoints=function(n,t){arguments.length<2&&(t=0);var i=n[0],c=n[1],f=e.length<2?(i=(i+c)/2,0):(c-i)/(e.length-1+t);return u=l(i+f*t/2,f),o=0,r={t:"rangePoints",a:arguments},a};a.rangeRoundPoints=function(n,t){arguments.length<2&&(t=0);var i=n[0],c=n[1],f=e.length<2?(i=c=Math.round((i+c)/2),0):(c-i)/(e.length-1+t)|0;return u=l(i+Math.round(f*t/2+(c-i-(e.length-1+t)*f)/2),f),o=0,r={t:"rangeRoundPoints",a:arguments},a};a.rangeBands=function(n,t,i){arguments.length<2&&(t=0),arguments.length<3&&(i=t);var c=n[1]<n[0],f=n[c-0],s=n[1-c],h=(s-f)/(e.length-t+2*i);return u=l(f+h*i,h),c&&u.reverse(),o=h*(1-t),r={t:"rangeBands",a:arguments},a};a.rangeRoundBands=function(n,t,i){arguments.length<2&&(t=0),arguments.length<3&&(i=t);var c=n[1]<n[0],f=n[c-0],s=n[1-c],h=Math.floor((s-f)/(e.length-t+2*i));return u=l(f+Math.round((s-f-(e.length-t)*h)/2),h),c&&u.reverse(),o=Math.round(h*(1-t)),r={t:"rangeRoundBands",a:arguments},a};a.rangeBand=function(){return o};a.rangeExtent=function(){return io(r.a[0])};a.copy=function(){return t(e,r)};return a.domain(e)}([],{t:"range",a:[[]]})},n.scale.category10=function(){return n.scale.ordinal().range(_o)},n.scale.category20=function(){return n.scale.ordinal().range(wo)},n.scale.category20b=function(){return n.scale.ordinal().range(So)},n.scale.category20c=function(){return n.scale.ordinal().range(ko)};var _o=[2062260,16744206,2924588,14034728,9725885,9197131,14907330,8355711,12369186,1556175].map(at),wo=[2062260,11454440,16744206,16759672,2924588,10018698,14034728,16750742,9725885,12955861,9197131,12885140,14907330,16234194,8355711,13092807,12369186,14408589,1556175,10410725].map(at),So=[3750777,5395619,7040719,10264286,6519097,9216594,11915115,13556636,9202993,12426809,15186514,15190932,8666169,11356490,14049643,15177372,8077683,10834324,13528509,14589654].map(at),ko=[3244733,7057110,10406625,13032431,15095053,16616764,16625259,16634018,3253076,7652470,10607003,13101504,7695281,10394312,12369372,14342891,6513507,9868950,12434877,14277081].map(at);function No(){return 0}n.scale.quantile=function(){return function t(e,r){var i;function u(){var t=0,u=r.length;for(i=[];++t<u;)i[t-1]=n.quantile(e,t/u);return o}function o(t){if(!isNaN(t=+t))return r[n.bisect(i,t)]}o.domain=function(n){return arguments.length?(e=n.map(h).filter(p).sort(s),u()):e};o.range=function(n){return arguments.length?(r=n,u()):r};o.quantiles=function(){return i};o.invertExtent=function(n){return(n=r.indexOf(n))<0?[NaN,NaN]:[n>0?i[n-1]:e[0],n<i.length?i[n]:e[e.length-1]]};o.copy=function(){return t(e,r)};return u()}([],[])},n.scale.quantize=function(){return function n(t,e,r){var i,u;function o(n){return r[Math.max(0,Math.min(u,Math.floor(i*(n-t))))]}function a(){return i=r.length/(e-t),u=r.length-1,o}o.domain=function(n){return arguments.length?(t=+n[0],e=+n[n.length-1],a()):[t,e]};o.range=function(n){return arguments.length?(r=n,a()):r};o.invertExtent=function(n){return[n=(n=r.indexOf(n))<0?NaN:n/i+t,n+1/i]};o.copy=function(){return n(t,e,r)};return a()}(0,1,[0,1])},n.scale.threshold=function(){return function t(e,r){function i(t){if(t<=t)return r[n.bisect(e,t)]}i.domain=function(n){return arguments.length?(e=n,i):e};i.range=function(n){return arguments.length?(r=n,i):r};i.invertExtent=function(n){return n=r.indexOf(n),[e[n-1],e[n]]};i.copy=function(){return t(e,r)};return i}([.5],[0,1])},n.scale.identity=function(){return function n(t){function e(n){return+n}e.invert=e;e.domain=e.range=function(n){return arguments.length?(t=n.map(e),e):t};e.ticks=function(n){return go(t,n)};e.tickFormat=function(n,e){return vo(t,n,e)};e.copy=function(){return n(t)};return e}([0,1])},n.svg={},n.svg.arc=function(){var n=Ao,t=Co,e=No,r=Eo,i=zo,u=Lo,o=qo;function a(){var a=Math.max(0,+n.apply(this,arguments)),c=Math.max(0,+t.apply(this,arguments)),f=i.apply(this,arguments)-An,s=u.apply(this,arguments)-An,h=Math.abs(s-f),p=f>s?0:1;if(c<a&&(g=c,c=a,a=g),h>=En)return l(c,p)+(a?l(a,1-p):"")+"Z";var g,v,d,y,m,M,x,b,_,w,S,k,N=0,E=0,A=[];if((y=(+o.apply(this,arguments)||0)/2)&&(d=r===Eo?Math.sqrt(a*a+c*c):+r.apply(this,arguments),p||(E*=-1),c&&(E=Rn(d/c*Math.sin(y))),a&&(N=Rn(d/a*Math.sin(y)))),c){m=c*Math.cos(f+E),M=c*Math.sin(f+E),x=c*Math.cos(s-E),b=c*Math.sin(s-E);var C=Math.abs(s-f-2*E)<=kn?0:1;if(E&&To(m,M,x,b)===p^C){var z=(f+s)/2;m=c*Math.cos(z),M=c*Math.sin(z),x=b=null}}else m=M=0;if(a){_=a*Math.cos(s-N),w=a*Math.sin(s-N),S=a*Math.cos(f+N),k=a*Math.sin(f+N);var L=Math.abs(f-s+2*N)<=kn?0:1;if(N&&To(_,w,S,k)===1-p^L){var q=(f+s)/2;_=a*Math.cos(q),w=a*Math.sin(q),S=k=null}}else _=w=0;if(h>wn&&(g=Math.min(Math.abs(c-a)/2,+e.apply(this,arguments)))>.001){v=a<c^p?0:1;var T=g,R=g;if(h<kn){var D=null==S?[_,w]:null==x?[m,M]:ii([m,M],[S,k],[x,b],[_,w]),P=m-D[0],U=M-D[1],j=x-D[0],F=b-D[1],H=1/Math.sin(Math.acos((P*j+U*F)/(Math.sqrt(P*P+U*U)*Math.sqrt(j*j+F*F)))/2),O=Math.sqrt(D[0]*D[0]+D[1]*D[1]);R=Math.min(g,(a-O)/(H-1)),T=Math.min(g,(c-O)/(H+1))}if(null!=x){var I=Ro(null==S?[_,w]:[S,k],[m,M],c,T,p),Y=Ro([x,b],[_,w],c,T,p);g===T?A.push("M",I[0],"A",T,",",T," 0 0,",v," ",I[1],"A",c,",",c," 0 ",1-p^To(I[1][0],I[1][1],Y[1][0],Y[1][1]),",",p," ",Y[1],"A",T,",",T," 0 0,",v," ",Y[0]):A.push("M",I[0],"A",T,",",T," 0 1,",v," ",Y[0])}else A.push("M",m,",",M);if(null!=S){var Z=Ro([m,M],[S,k],a,-R,p),V=Ro([_,w],null==x?[m,M]:[x,b],a,-R,p);g===R?A.push("L",V[0],"A",R,",",R," 0 0,",v," ",V[1],"A",a,",",a," 0 ",p^To(V[1][0],V[1][1],Z[1][0],Z[1][1]),",",1-p," ",Z[1],"A",R,",",R," 0 0,",v," ",Z[0]):A.push("L",V[0],"A",R,",",R," 0 0,",v," ",Z[0])}else A.push("L",_,",",w)}else A.push("M",m,",",M),null!=x&&A.push("A",c,",",c," 0 ",C,",",p," ",x,",",b),A.push("L",_,",",w),null!=S&&A.push("A",a,",",a," 0 ",L,",",1-p," ",S,",",k);return A.push("Z"),A.join("")}function l(n,t){return"M0,"+n+"A"+n+","+n+" 0 1,"+t+" 0,"+-n+"A"+n+","+n+" 0 1,"+t+" 0,"+n}return a.innerRadius=function(t){return arguments.length?(n=dt(t),a):n},a.outerRadius=function(n){return arguments.length?(t=dt(n),a):t},a.cornerRadius=function(n){return arguments.length?(e=dt(n),a):e},a.padRadius=function(n){return arguments.length?(r=n==Eo?Eo:dt(n),a):r},a.startAngle=function(n){return arguments.length?(i=dt(n),a):i},a.endAngle=function(n){return arguments.length?(u=dt(n),a):u},a.padAngle=function(n){return arguments.length?(o=dt(n),a):o},a.centroid=function(){var e=(+n.apply(this,arguments)+ +t.apply(this,arguments))/2,r=(+i.apply(this,arguments)+ +u.apply(this,arguments))/2-An;return[Math.cos(r)*e,Math.sin(r)*e]},a};var Eo="auto";function Ao(n){return n.innerRadius}function Co(n){return n.outerRadius}function zo(n){return n.startAngle}function Lo(n){return n.endAngle}function qo(n){return n&&n.padAngle}function To(n,t,e,r){return(n-e)*t-(t-r)*n>0?0:1}function Ro(n,t,e,r,i){var u=n[0]-t[0],o=n[1]-t[1],a=(i?r:-r)/Math.sqrt(u*u+o*o),l=a*o,c=-a*u,f=n[0]+l,s=n[1]+c,h=t[0]+l,p=t[1]+c,g=(f+h)/2,v=(s+p)/2,d=h-f,y=p-s,m=d*d+y*y,M=e-r,x=f*p-h*s,b=(y<0?-1:1)*Math.sqrt(Math.max(0,M*M*m-x*x)),_=(x*y-d*b)/m,w=(-x*d-y*b)/m,S=(x*y+d*b)/m,k=(-x*d+y*b)/m,N=_-g,E=w-v,A=S-g,C=k-v;return N*N+E*E>A*A+C*C&&(_=S,w=k),[[_-l,w-c],[_*e/M,w*e/M]]}function Do(n){var t=Kr,e=Qr,r=Xe,i=Uo,u=i.key,o=.7;function a(u){var a,l=[],c=[],f=-1,s=u.length,h=dt(t),p=dt(e);function g(){l.push("M",i(n(c),o))}for(;++f<s;)r.call(this,a=u[f],f)?c.push([+h.call(this,a,f),+p.call(this,a,f)]):c.length&&(g(),c=[]);return c.length&&g(),l.length?l.join(""):null}return a.x=function(n){return arguments.length?(t=n,a):t},a.y=function(n){return arguments.length?(e=n,a):e},a.defined=function(n){return arguments.length?(r=n,a):r},a.interpolate=function(n){return arguments.length?(u="function"==typeof n?i=n:(i=Po.get(n)||Uo).key,a):u},a.tension=function(n){return arguments.length?(o=n,a):o},a}n.svg.line=function(){return Do(z)};var Po=n.map({linear:Uo,"linear-closed":jo,step:function(n){var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];for(;++t<e;)i.push("H",(r[0]+(r=n[t])[0])/2,"V",r[1]);e>1&&i.push("H",r[0]);return i.join("")},"step-before":Fo,"step-after":Ho,basis:Yo,"basis-open":function(n){if(n.length<4)return Uo(n);var t,e=[],r=-1,i=n.length,u=[0],o=[0];for(;++r<3;)t=n[r],u.push(t[0]),o.push(t[1]);e.push(Zo($o,u)+","+Zo($o,o)),--r;for(;++r<i;)t=n[r],u.shift(),u.push(t[0]),o.shift(),o.push(t[1]),Bo(e,u,o);return e.join("")},"basis-closed":function(n){var t,e,r=-1,i=n.length,u=i+4,o=[],a=[];for(;++r<4;)e=n[r%i],o.push(e[0]),a.push(e[1]);t=[Zo($o,o),",",Zo($o,a)],--r;for(;++r<u;)e=n[r%i],o.shift(),o.push(e[0]),a.shift(),a.push(e[1]),Bo(t,o,a);return t.join("")},bundle:function(n,t){var e=n.length-1;if(e)for(var r,i,u=n[0][0],o=n[0][1],a=n[e][0]-u,l=n[e][1]-o,c=-1;++c<=e;)r=n[c],i=c/e,r[0]=t*r[0]+(1-t)*(u+i*a),r[1]=t*r[1]+(1-t)*(o+i*l);return Yo(n)},cardinal:function(n,t){return n.length<3?Uo(n):n[0]+Oo(n,Io(n,t))},"cardinal-open":function(n,t){return n.length<4?Uo(n):n[1]+Oo(n.slice(1,-1),Io(n,t))},"cardinal-closed":function(n,t){return n.length<3?jo(n):n[0]+Oo((n.push(n[0]),n),Io([n[n.length-2]].concat(n,[n[1]]),t))},monotone:function(n){return n.length<3?Uo(n):n[0]+Oo(n,function(n){var t,e,r,i,u=[],o=function(n){var t=0,e=n.length-1,r=[],i=n[0],u=n[1],o=r[0]=Wo(i,u);for(;++t<e;)r[t]=(o+(o=Wo(i=u,u=n[t+1])))/2;return r[t]=o,r}(n),a=-1,l=n.length-1;for(;++a<l;)t=Wo(n[a],n[a+1]),y(t)<wn?o[a]=o[a+1]=0:(e=o[a]/t,r=o[a+1]/t,(i=e*e+r*r)>9&&(i=3*t/Math.sqrt(i),o[a]=i*e,o[a+1]=i*r));a=-1;for(;++a<=l;)i=(n[Math.min(l,a+1)][0]-n[Math.max(0,a-1)][0])/(6*(1+o[a]*o[a])),u.push([i||0,o[a]*i||0]);return u}(n))}});function Uo(n){return n.length>1?n.join("L"):n+"Z"}function jo(n){return n.join("L")+"Z"}function Fo(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("V",(r=n[t])[1],"H",r[0]);return i.join("")}function Ho(n){for(var t=0,e=n.length,r=n[0],i=[r[0],",",r[1]];++t<e;)i.push("H",(r=n[t])[0],"V",r[1]);return i.join("")}function Oo(n,t){if(t.length<1||n.length!=t.length&&n.length!=t.length+2)return Uo(n);var e=n.length!=t.length,r="",i=n[0],u=n[1],o=t[0],a=o,l=1;if(e&&(r+="Q"+(u[0]-2*o[0]/3)+","+(u[1]-2*o[1]/3)+","+u[0]+","+u[1],i=n[1],l=2),t.length>1){a=t[1],u=n[l],l++,r+="C"+(i[0]+o[0])+","+(i[1]+o[1])+","+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1];for(var c=2;c<t.length;c++,l++)u=n[l],a=t[c],r+="S"+(u[0]-a[0])+","+(u[1]-a[1])+","+u[0]+","+u[1]}if(e){var f=n[l];r+="Q"+(u[0]+2*a[0]/3)+","+(u[1]+2*a[1]/3)+","+f[0]+","+f[1]}return r}function Io(n,t){for(var e,r=[],i=(1-t)/2,u=n[0],o=n[1],a=1,l=n.length;++a<l;)e=u,u=o,o=n[a],r.push([i*(o[0]-e[0]),i*(o[1]-e[1])]);return r}function Yo(n){if(n.length<3)return Uo(n);var t=1,e=n.length,r=n[0],i=r[0],u=r[1],o=[i,i,i,(r=n[1])[0]],a=[u,u,u,r[1]],l=[i,",",u,"L",Zo($o,o),",",Zo($o,a)];for(n.push(n[e-1]);++t<=e;)r=n[t],o.shift(),o.push(r[0]),a.shift(),a.push(r[1]),Bo(l,o,a);return n.pop(),l.push("L",r),l.join("")}function Zo(n,t){return n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]*t[3]}Po.forEach(function(n,t){t.key=n,t.closed=/-closed$/.test(n)});var Vo=[0,2/3,1/3,0],Xo=[0,1/3,2/3,0],$o=[0,1/6,2/3,1/6];function Bo(n,t,e){n.push("C",Zo(Vo,t),",",Zo(Vo,e),",",Zo(Xo,t),",",Zo(Xo,e),",",Zo($o,t),",",Zo($o,e))}function Wo(n,t){return(t[1]-n[1])/(t[0]-n[0])}function Jo(n){for(var t,e,r,i=-1,u=n.length;++i<u;)e=(t=n[i])[0],r=t[1]-An,t[0]=e*Math.cos(r),t[1]=e*Math.sin(r);return n}function Go(n){var t=Kr,e=Kr,r=0,i=Qr,u=Xe,o=Uo,a=o.key,l=o,c="L",f=.7;function s(a){var s,h,p,g=[],v=[],d=[],y=-1,m=a.length,M=dt(t),x=dt(r),b=t===e?function(){return h}:dt(e),_=r===i?function(){return p}:dt(i);function w(){g.push("M",o(n(d),f),c,l(n(v.reverse()),f),"Z")}for(;++y<m;)u.call(this,s=a[y],y)?(v.push([h=+M.call(this,s,y),p=+x.call(this,s,y)]),d.push([+b.call(this,s,y),+_.call(this,s,y)])):v.length&&(w(),v=[],d=[]);return v.length&&w(),g.length?g.join(""):null}return s.x=function(n){return arguments.length?(t=e=n,s):e},s.x0=function(n){return arguments.length?(t=n,s):t},s.x1=function(n){return arguments.length?(e=n,s):e},s.y=function(n){return arguments.length?(r=i=n,s):i},s.y0=function(n){return arguments.length?(r=n,s):r},s.y1=function(n){return arguments.length?(i=n,s):i},s.defined=function(n){return arguments.length?(u=n,s):u},s.interpolate=function(n){return arguments.length?(a="function"==typeof n?o=n:(o=Po.get(n)||Uo).key,l=o.reverse||o,c=o.closed?"M":"L",s):a},s.tension=function(n){return arguments.length?(f=n,s):f},s}function Ko(n){return n.radius}function Qo(n){return[n.x,n.y]}function na(){return 64}function ta(){return"circle"}function ea(n){var t=Math.sqrt(n/kn);return"M0,"+t+"A"+t+","+t+" 0 1,1 0,"+-t+"A"+t+","+t+" 0 1,1 0,"+t+"Z"}n.svg.line.radial=function(){var n=Do(Jo);return n.radius=n.x,delete n.x,n.angle=n.y,delete n.y,n},Fo.reverse=Ho,Ho.reverse=Fo,n.svg.area=function(){return Go(z)},n.svg.area.radial=function(){var n=Go(Jo);return n.radius=n.x,delete n.x,n.innerRadius=n.x0,delete n.x0,n.outerRadius=n.x1,delete n.x1,n.angle=n.y,delete n.y,n.startAngle=n.y0,delete n.y0,n.endAngle=n.y1,delete n.y1,n},n.svg.chord=function(){var n=jr,t=Fr,e=Ko,r=zo,i=Lo;function u(e,r){var i,u,c=o(this,n,e,r),f=o(this,t,e,r);return"M"+c.p0+a(c.r,c.p1,c.a1-c.a0)+(u=f,(i=c).a0==u.a0&&i.a1==u.a1?l(c.r,c.p1,c.r,c.p0):l(c.r,c.p1,f.r,f.p0)+a(f.r,f.p1,f.a1-f.a0)+l(f.r,f.p1,c.r,c.p0))+"Z"}function o(n,t,u,o){var a=t.call(n,u,o),l=e.call(n,a,o),c=r.call(n,a,o)-An,f=i.call(n,a,o)-An;return{r:l,a0:c,a1:f,p0:[l*Math.cos(c),l*Math.sin(c)],p1:[l*Math.cos(f),l*Math.sin(f)]}}function a(n,t,e){return"A"+n+","+n+" 0 "+ +(e>kn)+",1 "+t}function l(n,t,e,r){return"Q 0,0 "+r}return u.radius=function(n){return arguments.length?(e=dt(n),u):e},u.source=function(t){return arguments.length?(n=dt(t),u):n},u.target=function(n){return arguments.length?(t=dt(n),u):t},u.startAngle=function(n){return arguments.length?(r=dt(n),u):r},u.endAngle=function(n){return arguments.length?(i=dt(n),u):i},u},n.svg.diagonal=function(){var n=jr,t=Fr,e=Qo;function r(r,i){var u=n.call(this,r,i),o=t.call(this,r,i),a=(u.y+o.y)/2,l=[u,{x:u.x,y:a},{x:o.x,y:a},o];return"M"+(l=l.map(e))[0]+"C"+l[1]+" "+l[2]+" "+l[3]}return r.source=function(t){return arguments.length?(n=dt(t),r):n},r.target=function(n){return arguments.length?(t=dt(n),r):t},r.projection=function(n){return arguments.length?(e=n,r):e},r},n.svg.diagonal.radial=function(){var t=n.svg.diagonal(),e=Qo,r=t.projection;return t.projection=function(n){return arguments.length?r(function(n){return function(){var t=n.apply(this,arguments),e=t[0],r=t[1]-An;return[e*Math.cos(r),e*Math.sin(r)]}}(e=n)):e},t},n.svg.symbol=function(){var n=ta,t=na;function e(e,r){return(ra.get(n.call(this,e,r))||ea)(t.call(this,e,r))}return e.type=function(t){return arguments.length?(n=dt(t),e):n},e.size=function(n){return arguments.length?(t=dt(n),e):t},e};var ra=n.map({circle:ea,cross:function(n){var t=Math.sqrt(n/5)/2;return"M"+-3*t+","+-t+"H"+-t+"V"+-3*t+"H"+t+"V"+-t+"H"+3*t+"V"+t+"H"+t+"V"+3*t+"H"+-t+"V"+t+"H"+-3*t+"Z"},diamond:function(n){var t=Math.sqrt(n/(2*ua)),e=t*ua;return"M0,"+-t+"L"+e+",0 0,"+t+" "+-e+",0Z"},square:function(n){var t=Math.sqrt(n)/2;return"M"+-t+","+-t+"L"+t+","+-t+" "+t+","+t+" "+-t+","+t+"Z"},"triangle-down":function(n){var t=Math.sqrt(n/ia),e=t*ia/2;return"M0,"+e+"L"+t+","+-e+" "+-t+","+-e+"Z"},"triangle-up":function(n){var t=Math.sqrt(n/ia),e=t*ia/2;return"M0,"+-e+"L"+t+","+e+" "+-t+","+e+"Z"}});n.svg.symbolTypes=ra.keys();var ia=Math.sqrt(3),ua=Math.tan(30*Cn);X.transition=function(n){for(var t,e,r=ca||++ha,i=va(n),u=[],o=fa||{time:Date.now(),ease:Qi,delay:0,duration:250},a=-1,l=this.length;++a<l;){u.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(e=c[f])&&da(e,f,i,r,o),t.push(e)}return la(u,i,r)},X.interrupt=function(n){return this.each(null==n?oa:aa(va(n)))};var oa=aa(va());function aa(n){return function(){var t,e,r;(t=this[n])&&(r=t[e=t.active])&&(r.timer.c=null,r.timer.t=NaN,--t.count?delete t[e]:delete this[n],t.active+=.5,r.event&&r.event.interrupt.call(this,this.__data__,r.index))}}function la(n,t,e){return O(n,sa),n.namespace=t,n.id=e,n}var ca,fa,sa=[],ha=0;function pa(n,t,e,r){var i=n.id,u=n.namespace;return fn(n,"function"==typeof e?function(n,o,a){n[u][i].tween.set(t,r(e.call(n,n.__data__,o,a)))}:(e=r(e),function(n){n[u][i].tween.set(t,e)}))}function ga(n){return null==n&&(n=""),function(){this.textContent=n}}function va(n){return null==n?"__transition__":"__transition_"+n+"__"}function da(n,t,e,r,i){var u,o,a,l,c,f=n[e]||(n[e]={active:0,count:0}),s=f[r];function h(e){var i=f.active,h=f[i];for(var g in h&&(h.timer.c=null,h.timer.t=NaN,--f.count,delete f[i],h.event&&h.event.interrupt.call(n,n.__data__,h.index)),f)if(+g<r){var v=f[g];v.timer.c=null,v.timer.t=NaN,--f.count,delete f[g]}o.c=p,St(function(){return o.c&&p(e||1)&&(o.c=null,o.t=NaN),1},0,u),f.active=r,s.event&&s.event.start.call(n,n.__data__,t),c=[],s.tween.forEach(function(e,r){(r=r.call(n,n.__data__,t))&&c.push(r)}),l=s.ease,a=s.duration}function p(i){for(var u=i/a,o=l(u),h=c.length;h>0;)c[--h].call(n,o);if(u>=1)return s.event&&s.event.end.call(n,n.__data__,t),--f.count?delete f[r]:delete n[e],1}s||(u=i.time,o=St(function(n){var t=s.delay;if(o.t=t+u,t<=n)return h(n-t);o.c=h},0,u),s=f[r]={tween:new M,time:u,timer:o,delay:i.delay,duration:i.duration,ease:i.ease,index:t},i=null,++f.count)}sa.call=X.call,sa.empty=X.empty,sa.node=X.node,sa.size=X.size,n.transition=function(t,e){return t&&t.transition?ca?t.transition(e):t:n.selection().transition(t)},n.transition.prototype=sa,sa.select=function(n){var t,e,r,i=this.id,u=this.namespace,o=[];n=$(n);for(var a=-1,l=this.length;++a<l;){o.push(t=[]);for(var c=this[a],f=-1,s=c.length;++f<s;)(r=c[f])&&(e=n.call(r,r.__data__,f,a))?("__data__"in r&&(e.__data__=r.__data__),da(e,f,u,i,r[u][i]),t.push(e)):t.push(null)}return la(o,u,i)},sa.selectAll=function(n){var t,e,r,i,u,o=this.id,a=this.namespace,l=[];n=B(n);for(var c=-1,f=this.length;++c<f;)for(var s=this[c],h=-1,p=s.length;++h<p;)if(r=s[h]){u=r[a][o],e=n.call(r,r.__data__,h,c),l.push(t=[]);for(var g=-1,v=e.length;++g<v;)(i=e[g])&&da(i,g,a,o,u),t.push(i)}return la(l,a,o)},sa.filter=function(n){var t,e,r=[];"function"!=typeof n&&(n=cn(n));for(var i=0,u=this.length;i<u;i++){r.push(t=[]);for(var o,a=0,l=(o=this[i]).length;a<l;a++)(e=o[a])&&n.call(e,e.__data__,a,i)&&t.push(e)}return la(r,this.namespace,this.id)},sa.tween=function(n,t){var e=this.id,r=this.namespace;return arguments.length<2?this.node()[r][e].tween.get(n):fn(this,null==t?function(t){t[r][e].tween.remove(n)}:function(i){i[r][e].tween.set(n,t)})},sa.attr=function(t,e){if(arguments.length<2){for(e in t)this.attr(e,t[e]);return this}var r="transform"==t?fu:Zi,i=n.ns.qualify(t);function u(){this.removeAttribute(i)}function o(){this.removeAttributeNS(i.space,i.local)}return pa(this,"attr."+t,e,i.local?function(n){return null==n?o:(n+="",function(){var t,e=this.getAttributeNS(i.space,i.local);return e!==n&&(t=r(e,n),function(n){this.setAttributeNS(i.space,i.local,t(n))})})}:function(n){return null==n?u:(n+="",function(){var t,e=this.getAttribute(i);return e!==n&&(t=r(e,n),function(n){this.setAttribute(i,t(n))})})})},sa.attrTween=function(t,e){var r=n.ns.qualify(t);return this.tween("attr."+t,r.local?function(n,t){var i=e.call(this,n,t,this.getAttributeNS(r.space,r.local));return i&&function(n){this.setAttributeNS(r.space,r.local,i(n))}}:function(n,t){var i=e.call(this,n,t,this.getAttribute(r));return i&&function(n){this.setAttribute(r,i(n))}})},sa.style=function(n,t,e){var r=arguments.length;if(r<3){if("string"!=typeof n){for(e in r<2&&(t=""),n)this.style(e,n[e],t);return this}e=""}function i(){this.style.removeProperty(n)}return pa(this,"style."+n,t,function(t){return null==t?i:(t+="",function(){var r,i=u(this).getComputedStyle(this,null).getPropertyValue(n);return i!==t&&(r=Zi(i,t),function(t){this.style.setProperty(n,r(t),e)})})})},sa.styleTween=function(n,t,e){return arguments.length<3&&(e=""),this.tween("style."+n,function(r,i){var o=t.call(this,r,i,u(this).getComputedStyle(this,null).getPropertyValue(n));return o&&function(t){this.style.setProperty(n,o(t),e)}})},sa.text=function(n){return pa(this,"text",n,ga)},sa.remove=function(){var n=this.namespace;return this.each("end.transition",function(){var t;this[n].count<2&&(t=this.parentNode)&&t.removeChild(this)})},sa.ease=function(t){var e=this.id,r=this.namespace;return arguments.length<1?this.node()[r][e].ease:("function"!=typeof t&&(t=n.ease.apply(n,arguments)),fn(this,function(n){n[r][e].ease=t}))},sa.delay=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].delay:fn(this,"function"==typeof n?function(r,i,u){r[e][t].delay=+n.call(r,r.__data__,i,u)}:(n=+n,function(r){r[e][t].delay=n}))},sa.duration=function(n){var t=this.id,e=this.namespace;return arguments.length<1?this.node()[e][t].duration:fn(this,"function"==typeof n?function(r,i,u){r[e][t].duration=Math.max(1,n.call(r,r.__data__,i,u))}:(n=Math.max(1,n),function(r){r[e][t].duration=n}))},sa.each=function(t,e){var r=this.id,i=this.namespace;if(arguments.length<2){var u=fa,o=ca;try{ca=r,fn(this,function(n,e,u){fa=n[i][r],t.call(n,n.__data__,e,u)})}finally{fa=u,ca=o}}else fn(this,function(u){var o=u[i][r];(o.event||(o.event=n.dispatch("start","end","interrupt"))).on(t,e)});return this},sa.transition=function(){for(var n,t,e,r=this.id,i=++ha,u=this.namespace,o=[],a=0,l=this.length;a<l;a++){o.push(n=[]);for(var c,f=0,s=(c=this[a]).length;f<s;f++)(t=c[f])&&da(t,f,u,i,{time:(e=t[u][r]).time,ease:e.ease,delay:e.delay+e.duration,duration:e.duration}),n.push(t)}return la(o,u,i)},n.svg.axis=function(){var t,r=n.scale.linear(),i=ya,u=6,o=6,a=3,l=[10],c=null;function f(e){e.each(function(){var e,f=n.select(this),s=this.__chart__||r,h=this.__chart__=r.copy(),p=null==c?h.ticks?h.ticks.apply(h,l):h.domain():c,g=null==t?h.tickFormat?h.tickFormat.apply(h,l):z:t,v=f.selectAll(".tick").data(p,h),d=v.enter().insert("g",".domain").attr("class","tick").style("opacity",wn),y=n.transition(v.exit()).style("opacity",wn).remove(),m=n.transition(v.order()).style("opacity",1),M=Math.max(u,0)+a,x=uo(h),b=f.selectAll(".domain").data([0]),_=(b.enter().append("path").attr("class","domain"),n.transition(b));d.append("line"),d.append("text");var w,S,k,N,E=d.select("line"),A=m.select("line"),C=v.select("text").text(g),L=d.select("text"),q=m.select("text"),T="top"===i||"left"===i?-1:1;if("bottom"===i||"top"===i?(e=Ma,w="x",k="y",S="x2",N="y2",C.attr("dy",T<0?"0em":".71em").style("text-anchor","middle"),_.attr("d","M"+x[0]+","+T*o+"V0H"+x[1]+"V"+T*o)):(e=xa,w="y",k="x",S="y2",N="x2",C.attr("dy",".32em").style("text-anchor",T<0?"end":"start"),_.attr("d","M"+T*o+","+x[0]+"H0V"+x[1]+"H"+T*o)),E.attr(N,T*u),L.attr(k,T*M),A.attr(S,0).attr(N,T*u),q.attr(w,0).attr(k,T*M),h.rangeBand){var R=h,D=R.rangeBand()/2;s=h=function(n){return R(n)+D}}else s.rangeBand?s=h:y.call(e,h,s);d.call(e,s,h),m.call(e,h,h)})}return f.scale=function(n){return arguments.length?(r=n,f):r},f.orient=function(n){return arguments.length?(i=n in ma?n+"":ya,f):i},f.ticks=function(){return arguments.length?(l=e(arguments),f):l},f.tickValues=function(n){return arguments.length?(c=n,f):c},f.tickFormat=function(n){return arguments.length?(t=n,f):t},f.tickSize=function(n){var t=arguments.length;return t?(u=+n,o=+arguments[t-1],f):u},f.innerTickSize=function(n){return arguments.length?(u=+n,f):u},f.outerTickSize=function(n){return arguments.length?(o=+n,f):o},f.tickPadding=function(n){return arguments.length?(a=+n,f):a},f.tickSubdivide=function(){return arguments.length&&f},f};var ya="bottom",ma={top:1,right:1,bottom:1,left:1};function Ma(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate("+(isFinite(r)?r:e(n))+",0)"})}function xa(n,t,e){n.attr("transform",function(n){var r=t(n);return"translate(0,"+(isFinite(r)?r:e(n))+")"})}n.svg.brush=function(){var t,e,r=F(h,"brushstart","brush","brushend"),i=null,o=null,a=[0,0],l=[0,0],c=!0,f=!0,s=_a[0];function h(t){t.each(function(){var t=n.select(this).style("pointer-events","all").style("-webkit-tap-highlight-color","rgba(0,0,0,0)").on("mousedown.brush",d).on("touchstart.brush",d),e=t.selectAll(".background").data([0]);e.enter().append("rect").attr("class","background").style("visibility","hidden").style("cursor","crosshair"),t.selectAll(".extent").data([0]).enter().append("rect").attr("class","extent").style("cursor","move");var r=t.selectAll(".resize").data(s,z);r.exit().remove(),r.enter().append("g").attr("class",function(n){return"resize "+n}).style("cursor",function(n){return ba[n]}).append("rect").attr("x",function(n){return/[ew]$/.test(n)?-3:null}).attr("y",function(n){return/^[ns]/.test(n)?-3:null}).attr("width",6).attr("height",6).style("visibility","hidden"),r.style("display",h.empty()?"none":null);var u,a=n.transition(t),l=n.transition(e);i&&(u=uo(i),l.attr("x",u[0]).attr("width",u[1]-u[0]),g(a)),o&&(u=uo(o),l.attr("y",u[0]).attr("height",u[1]-u[0]),v(a)),p(a)})}function p(n){n.selectAll(".resize").attr("transform",function(n){return"translate("+a[+/e$/.test(n)]+","+l[+/^s/.test(n)]+")"})}function g(n){n.select(".extent").attr("x",a[0]),n.selectAll(".extent,.n>rect,.s>rect").attr("width",a[1]-a[0])}function v(n){n.select(".extent").attr("y",l[0]),n.selectAll(".extent,.e>rect,.w>rect").attr("height",l[1]-l[0])}function d(){var s,d,y=this,m=n.select(n.event.target),M=r.of(y,arguments),x=n.select(y),b=m.datum(),_=!/^(n|s)$/.test(b)&&i,w=!/^(e|w)$/.test(b)&&o,S=m.classed("extent"),k=Mn(y),N=n.mouse(y),E=n.select(u(y)).on("keydown.brush",function(){32==n.event.keyCode&&(S||(s=null,N[0]-=a[1],N[1]-=l[1],S=2),U())}).on("keyup.brush",function(){32==n.event.keyCode&&2==S&&(N[0]+=a[1],N[1]+=l[1],S=0,U())});if(n.event.changedTouches?E.on("touchmove.brush",z).on("touchend.brush",q):E.on("mousemove.brush",z).on("mouseup.brush",q),x.interrupt().selectAll("*").interrupt(),S)N[0]=a[0]-N[0],N[1]=l[0]-N[1];else if(b){var A=+/w$/.test(b),C=+/^n/.test(b);d=[a[1-A]-N[0],l[1-C]-N[1]],N[0]=a[A],N[1]=l[C]}else n.event.altKey&&(s=N.slice());function z(){var t=n.mouse(y),e=!1;d&&(t[0]+=d[0],t[1]+=d[1]),S||(n.event.altKey?(s||(s=[(a[0]+a[1])/2,(l[0]+l[1])/2]),N[0]=a[+(t[0]<s[0])],N[1]=l[+(t[1]<s[1])]):s=null),_&&L(t,i,0)&&(g(x),e=!0),w&&L(t,o,1)&&(v(x),e=!0),e&&(p(x),M({type:"brush",mode:S?"move":"resize"}))}function L(n,r,i){var u,o,h=uo(r),p=h[0],g=h[1],v=N[i],d=i?l:a,y=d[1]-d[0];if(S&&(p-=v,g-=y+v),u=(i?f:c)?Math.max(p,Math.min(g,n[i])):n[i],S?o=(u+=v)+y:(s&&(v=Math.max(p,Math.min(g,2*s[i]-u))),v<u?(o=u,u=v):o=v),d[0]!=u||d[1]!=o)return i?e=null:t=null,d[0]=u,d[1]=o,!0}function q(){z(),x.style("pointer-events","all").selectAll(".resize").style("display",h.empty()?"none":null),n.select("body").style("cursor",null),E.on("mousemove.brush",null).on("mouseup.brush",null).on("touchmove.brush",null).on("touchend.brush",null).on("keydown.brush",null).on("keyup.brush",null),k(),M({type:"brushend"})}x.style("pointer-events","none").selectAll(".resize").style("display",null),n.select("body").style("cursor",m.style("cursor")),M({type:"brushstart"}),z()}return h.event=function(i){i.each(function(){var i=r.of(this,arguments),u={x:a,y:l,i:t,j:e},o=this.__chart__||u;this.__chart__=u,ca?n.select(this).transition().each("start.brush",function(){t=o.i,e=o.j,a=o.x,l=o.y,i({type:"brushstart"})}).tween("brush:brush",function(){var n=Vi(a,u.x),r=Vi(l,u.y);return t=e=null,function(t){a=u.x=n(t),l=u.y=r(t),i({type:"brush",mode:"resize"})}}).each("end.brush",function(){t=u.i,e=u.j,i({type:"brush",mode:"resize"}),i({type:"brushend"})}):(i({type:"brushstart"}),i({type:"brush",mode:"resize"}),i({type:"brushend"}))})},h.x=function(n){return arguments.length?(s=_a[!(i=n)<<1|!o],h):i},h.y=function(n){return arguments.length?(s=_a[!i<<1|!(o=n)],h):o},h.clamp=function(n){return arguments.length?(i&&o?(c=!!n[0],f=!!n[1]):i?c=!!n:o&&(f=!!n),h):i&&o?[c,f]:i?c:o?f:null},h.extent=function(n){var r,u,c,f,s;return arguments.length?(i&&(r=n[0],u=n[1],o&&(r=r[0],u=u[0]),t=[r,u],i.invert&&(r=i(r),u=i(u)),u<r&&(s=r,r=u,u=s),r==a[0]&&u==a[1]||(a=[r,u])),o&&(c=n[0],f=n[1],i&&(c=c[1],f=f[1]),e=[c,f],o.invert&&(c=o(c),f=o(f)),f<c&&(s=c,c=f,f=s),c==l[0]&&f==l[1]||(l=[c,f])),h):(i&&(t?(r=t[0],u=t[1]):(r=a[0],u=a[1],i.invert&&(r=i.invert(r),u=i.invert(u)),u<r&&(s=r,r=u,u=s))),o&&(e?(c=e[0],f=e[1]):(c=l[0],f=l[1],o.invert&&(c=o.invert(c),f=o.invert(f)),f<c&&(s=c,c=f,f=s))),i&&o?[[r,c],[u,f]]:i?[r,u]:o&&[c,f])},h.clear=function(){return h.empty()||(a=[0,0],l=[0,0],t=e=null),h},h.empty=function(){return!!i&&a[0]==a[1]||!!o&&l[0]==l[1]},n.rebind(h,r,"on")};var ba={n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},_a=[["n","e","s","w","nw","ne","se","sw"],["e","w"],["n","s"],[]],wa=Tt.format=ae.timeFormat,Sa=wa.utc,ka=Sa("%Y-%m-%dT%H:%M:%S.%LZ");function Na(n){return n.toISOString()}function Ea(t,e,r){function i(n){return t(n)}function u(t,r){var i=(t[1]-t[0])/r,u=n.bisect(Ca,i);return u==Ca.length?[e.year,po(t.map(function(n){return n/31536e6}),r)[2]]:u?e[i/Ca[u-1]<Ca[u]/i?u-1:u]:[qa,po(t,r)[2]]}return i.invert=function(n){return Aa(t.invert(n))},i.domain=function(n){return arguments.length?(t.domain(n),i):t.domain().map(Aa)},i.nice=function(n,t){var e=i.domain(),r=io(e),o=null==n?u(r,10):"number"==typeof n&&u(r,n);function a(e){return!isNaN(e)&&!n.range(e,Aa(+e+1),t).length}return o&&(n=o[0],t=o[1]),i.domain(ao(e,t>1?{floor:function(t){for(;a(t=n.floor(t));)t=Aa(t-1);return t},ceil:function(t){for(;a(t=n.ceil(t));)t=Aa(+t+1);return t}}:n))},i.ticks=function(n,t){var e=io(i.domain()),r=null==n?u(e,10):"number"==typeof n?u(e,n):!n.range&&[{range:n},t];return r&&(n=r[0],t=r[1]),n.range(e[0],Aa(+e[1]+1),t<1?1:t)},i.tickFormat=function(){return r},i.copy=function(){return Ea(t.copy(),e,r)},so(i,t)}function Aa(n){return new Date(n)}wa.iso=Date.prototype.toISOString&&+new Date("2000-01-01T00:00:00.000Z")?Na:ka,Na.parse=function(n){var t=new Date(n);return isNaN(t)?null:t},Na.toString=ka.toString,Tt.second=Ut(function(n){return new Rt(1e3*Math.floor(n/1e3))},function(n,t){n.setTime(n.getTime()+1e3*Math.floor(t))},function(n){return n.getSeconds()}),Tt.seconds=Tt.second.range,Tt.seconds.utc=Tt.second.utc.range,Tt.minute=Ut(function(n){return new Rt(6e4*Math.floor(n/6e4))},function(n,t){n.setTime(n.getTime()+6e4*Math.floor(t))},function(n){return n.getMinutes()}),Tt.minutes=Tt.minute.range,Tt.minutes.utc=Tt.minute.utc.range,Tt.hour=Ut(function(n){var t=n.getTimezoneOffset()/60;return new Rt(36e5*(Math.floor(n/36e5-t)+t))},function(n,t){n.setTime(n.getTime()+36e5*Math.floor(t))},function(n){return n.getHours()}),Tt.hours=Tt.hour.range,Tt.hours.utc=Tt.hour.utc.range,Tt.month=Ut(function(n){return(n=Tt.day(n)).setDate(1),n},function(n,t){n.setMonth(n.getMonth()+t)},function(n){return n.getMonth()}),Tt.months=Tt.month.range,Tt.months.utc=Tt.month.utc.range;var Ca=[1e3,5e3,15e3,3e4,6e4,3e5,9e5,18e5,36e5,108e5,216e5,432e5,864e5,1728e5,6048e5,2592e6,7776e6,31536e6],za=[[Tt.second,1],[Tt.second,5],[Tt.second,15],[Tt.second,30],[Tt.minute,1],[Tt.minute,5],[Tt.minute,15],[Tt.minute,30],[Tt.hour,1],[Tt.hour,3],[Tt.hour,6],[Tt.hour,12],[Tt.day,1],[Tt.day,2],[Tt.week,1],[Tt.month,1],[Tt.month,3],[Tt.year,1]],La=wa.multi([[".%L",function(n){return n.getMilliseconds()}],[":%S",function(n){return n.getSeconds()}],["%I:%M",function(n){return n.getMinutes()}],["%I %p",function(n){return n.getHours()}],["%a %d",function(n){return n.getDay()&&1!=n.getDate()}],["%b %d",function(n){return 1!=n.getDate()}],["%B",function(n){return n.getMonth()}],["%Y",Xe]]),qa={range:function(t,e,r){return n.range(Math.ceil(t/r)*r,+e,r).map(Aa)},floor:z,ceil:z};za.year=Tt.year,Tt.scale=function(){return Ea(n.scale.linear(),za,La)};var Ta=za.map(function(n){return[n[0].utc,n[1]]}),Ra=Sa.multi([[".%L",function(n){return n.getUTCMilliseconds()}],[":%S",function(n){return n.getUTCSeconds()}],["%I:%M",function(n){return n.getUTCMinutes()}],["%I %p",function(n){return n.getUTCHours()}],["%a %d",function(n){return n.getUTCDay()&&1!=n.getUTCDate()}],["%b %d",function(n){return 1!=n.getUTCDate()}],["%B",function(n){return n.getUTCMonth()}],["%Y",Xe]]);function Da(n){return JSON.parse(n.responseText)}function Pa(n){var t=r.createRange();return t.selectNode(r.body),t.createContextualFragment(n.responseText)}Ta.year=Tt.year.utc,Tt.scale.utc=function(){return Ea(n.scale.linear(),Ta,Ra)},n.text=yt(function(n){return n.responseText}),n.json=function(n,t){return mt(n,"application/json",Da,t)},n.html=function(n,t){return mt(n,"text/html",Pa,t)},n.xml=yt(function(n){return n.responseXML}),"function"==typeof define&&define.amd?(this.d3=n,define(n)):"object"==typeof module&&module.exports?module.exports=n:this.d3=n}();
-
-},{}],2:[function(require,module,exports){
-!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.flatpickr=t()}(this,function(){"use strict";var e=function(e){return("0"+e).slice(-2)},t=function(e){return!0===e?1:0};function n(e,t,n){var a;return void 0===n&&(n=!1),function(){var i=this,o=arguments;null!==a&&clearTimeout(a),a=window.setTimeout(function(){a=null,n||e.apply(i,o)},t),n&&!a&&e.apply(i,o)}}var a=function(e){return e instanceof Array?e:[e]},i=function(){},o=function(e,t,n){return n.months[t?"shorthand":"longhand"][e]},r={D:i,F:function(e,t,n){e.setMonth(n.months.longhand.indexOf(t))},G:function(e,t){e.setHours(parseFloat(t))},H:function(e,t){e.setHours(parseFloat(t))},J:function(e,t){e.setDate(parseFloat(t))},K:function(e,n,a){e.setHours(e.getHours()%12+12*t(new RegExp(a.amPM[1],"i").test(n)))},M:function(e,t,n){e.setMonth(n.months.shorthand.indexOf(t))},S:function(e,t){e.setSeconds(parseFloat(t))},U:function(e,t){return new Date(1e3*parseFloat(t))},W:function(e,t){var n=parseInt(t);return new Date(e.getFullYear(),0,2+7*(n-1),0,0,0,0)},Y:function(e,t){e.setFullYear(parseFloat(t))},Z:function(e,t){return new Date(t)},d:function(e,t){e.setDate(parseFloat(t))},h:function(e,t){e.setHours(parseFloat(t))},i:function(e,t){e.setMinutes(parseFloat(t))},j:function(e,t){e.setDate(parseFloat(t))},l:i,m:function(e,t){e.setMonth(parseFloat(t)-1)},n:function(e,t){e.setMonth(parseFloat(t)-1)},s:function(e,t){e.setSeconds(parseFloat(t))},w:i,y:function(e,t){e.setFullYear(2e3+parseFloat(t))}},c={D:"(\\w+)",F:"(\\w+)",G:"(\\d\\d|\\d)",H:"(\\d\\d|\\d)",J:"(\\d\\d|\\d)\\w+",K:"",M:"(\\w+)",S:"(\\d\\d|\\d)",U:"(.+)",W:"(\\d\\d|\\d)",Y:"(\\d{4})",Z:"(.+)",d:"(\\d\\d|\\d)",h:"(\\d\\d|\\d)",i:"(\\d\\d|\\d)",j:"(\\d\\d|\\d)",l:"(\\w+)",m:"(\\d\\d|\\d)",n:"(\\d\\d|\\d)",s:"(\\d\\d|\\d)",w:"(\\d\\d|\\d)",y:"(\\d{2})"},l={Z:function(e){return e.toISOString()},D:function(e,t,n){return t.weekdays.shorthand[l.w(e,t,n)]},F:function(e,t,n){return o(l.n(e,t,n)-1,!1,t)},G:function(t,n,a){return e(l.h(t,n,a))},H:function(t){return e(t.getHours())},J:function(e,t){return void 0!==t.ordinal?e.getDate()+t.ordinal(e.getDate()):e.getDate()},K:function(e,n){return n.amPM[t(e.getHours()>11)]},M:function(e,t){return o(e.getMonth(),!0,t)},S:function(t){return e(t.getSeconds())},U:function(e){return e.getTime()/1e3},W:function(e,t,n){return n.getWeek(e)},Y:function(e){return e.getFullYear()},d:function(t){return e(t.getDate())},h:function(e){return e.getHours()%12?e.getHours()%12:12},i:function(t){return e(t.getMinutes())},j:function(e){return e.getDate()},l:function(e,t){return t.weekdays.longhand[e.getDay()]},m:function(t){return e(t.getMonth()+1)},n:function(e){return e.getMonth()+1},s:function(e){return e.getSeconds()},w:function(e){return e.getDay()},y:function(e){return String(e.getFullYear()).substring(2)}},d={weekdays:{shorthand:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],longhand:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},months:{shorthand:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],longhand:["January","February","March","April","May","June","July","August","September","October","November","December"]},daysInMonth:[31,28,31,30,31,30,31,31,30,31,30,31],firstDayOfWeek:0,ordinal:function(e){var t=e%100;if(t>3&&t<21)return"th";switch(t%10){case 1:return"st";case 2:return"nd";case 3:return"rd";default:return"th"}},rangeSeparator:" to ",weekAbbreviation:"Wk",scrollTitle:"Scroll to increment",toggleTitle:"Click to toggle",amPM:["AM","PM"],yearAriaLabel:"Year"},s=function(e){var t=e.config,n=void 0===t?p:t,a=e.l10n,i=void 0===a?d:a;return function(e,t,a){if(void 0!==n.formatDate)return n.formatDate(e,t);var o=a||i;return t.split("").map(function(t,a,i){return l[t]&&"\\"!==i[a-1]?l[t](e,o,n):"\\"!==t?t:""}).join("")}},u=function(e){var t=e.config,n=void 0===t?p:t,a=e.l10n,i=void 0===a?d:a;return function(e,t,a){if(0===e||e){var o,l=e;if(e instanceof Date)o=new Date(e.getTime());else if("string"!=typeof e&&void 0!==e.toFixed)o=new Date(e);else if("string"==typeof e){var d=t||(n||p).dateFormat,s=String(e).trim();if("today"===s)o=new Date,a=!0;else if(/Z$/.test(s)||/GMT$/.test(s))o=new Date(e);else if(n&&n.parseDate)o=n.parseDate(e,d);else{o=n&&n.noCalendar?new Date((new Date).setHours(0,0,0,0)):new Date((new Date).getFullYear(),0,1,0,0,0,0);for(var u,f=[],m=0,g=0,h="";m<d.length;m++){var v=d[m],D="\\"===v,w="\\"===d[m-1]||D;if(c[v]&&!w){h+=c[v];var b=new RegExp(h).exec(e);b&&(u=!0)&&f["Y"!==v?"push":"unshift"]({fn:r[v],val:b[++g]})}else D||(h+=".");f.forEach(function(e){var t=e.fn,n=e.val;return o=t(o,n,i)||o})}o=u?o:void 0}}if(o instanceof Date)return!0===a&&o.setHours(0,0,0,0),o;n.errorHandler(new Error("Invalid date provided: "+l))}}};function f(e,t,n){return void 0===n&&(n=!0),!1!==n?new Date(e.getTime()).setHours(0,0,0,0)-new Date(t.getTime()).setHours(0,0,0,0):e.getTime()-t.getTime()}var m=function(e,t,n){return e>Math.min(t,n)&&e<Math.max(t,n)},g={DAY:864e5},p={_disable:[],_enable:[],allowInput:!1,altFormat:"F j, Y",altInput:!1,altInputClass:"form-control input",animate:"object"==typeof window&&-1===window.navigator.userAgent.indexOf("MSIE"),ariaDateFormat:"F j, Y",clickOpens:!0,closeOnSelect:!0,conjunction:", ",dateFormat:"Y-m-d",defaultHour:12,defaultMinute:0,defaultSeconds:0,disable:[],disableMobile:!1,enable:[],enableSeconds:!1,enableTime:!1,errorHandler:function(e){return"undefined"!=typeof console&&console.warn(e)},getWeek:function(e){var t=new Date(e.getTime());t.setHours(0,0,0,0),t.setDate(t.getDate()+3-(t.getDay()+6)%7);var n=new Date(t.getFullYear(),0,4);return 1+Math.round(((t.getTime()-n.getTime())/864e5-3+(n.getDay()+6)%7)/7)},hourIncrement:1,ignoredFocusElements:[],inline:!1,locale:"default",minuteIncrement:5,mode:"single",nextArrow:"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",noCalendar:!1,now:new Date,onChange:[],onClose:[],onDayCreate:[],onDestroy:[],onKeyDown:[],onMonthChange:[],onOpen:[],onParseConfig:[],onReady:[],onValueUpdate:[],onYearChange:[],onPreCalendarPosition:[],plugins:[],position:"auto",positionElement:void 0,prevArrow:"<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",shorthandCurrentMonth:!1,showMonths:1,static:!1,time_24hr:!1,weekNumbers:!1,wrap:!1};function h(e,t,n){if(!0===n)return e.classList.add(t);e.classList.remove(t)}function v(e,t,n){var a=window.document.createElement(e);return t=t||"",n=n||"",a.className=t,void 0!==n&&(a.textContent=n),a}function D(e){for(;e.firstChild;)e.removeChild(e.firstChild)}function w(e,t){var n=v("div","numInputWrapper"),a=v("input","numInput "+e),i=v("span","arrowUp"),o=v("span","arrowDown");if(a.type="text",a.pattern="\\d*",void 0!==t)for(var r in t)a.setAttribute(r,t[r]);return n.appendChild(a),n.appendChild(i),n.appendChild(o),n}if("function"!=typeof Object.assign&&(Object.assign=function(e){if(!e)throw TypeError("Cannot convert undefined or null to object");for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];for(var i=function(){var t=n[o];t&&Object.keys(t).forEach(function(n){return e[n]=t[n]})},o=0;o<n.length;o++)i();return e}),"function"!=typeof window.requestAnimationFrame){for(var b=["ms","moz","webkit","o"],M=0,y=b.length;M<y&&!window.requestAnimationFrame;++M)window.requestAnimationFrame=window[b[M]+"RequestAnimationFrame"];"function"!=typeof window.requestAnimationFrame&&(window.requestAnimationFrame=function(e){return setTimeout(e,16)})}var C=300;function x(i,r){var l={config:Object.assign({},T.defaultConfig),l10n:d};function p(e){return e.bind(l)}function b(){var e=l.config;!1===e.weekNumbers&&1===e.showMonths||!0!==e.noCalendar&&window.requestAnimationFrame(function(){if(l.calendarContainer.style.visibility="hidden",l.calendarContainer.style.display="block",void 0!==l.daysContainer){var t=(l.days.offsetWidth+1)*e.showMonths;l.daysContainer.style.width=t+"px",l.calendarContainer.style.width=t+(void 0!==l.weekWrapper?l.weekWrapper.offsetWidth:0)+"px",l.calendarContainer.style.removeProperty("visibility"),l.calendarContainer.style.removeProperty("display")}})}function M(n){0!==l.selectedDates.length&&(!function(n){n.preventDefault();var a="keydown"===n.type,i=n.target;void 0!==l.amPM&&n.target===l.amPM&&(l.amPM.textContent=l.l10n.amPM[t(l.amPM.textContent===l.l10n.amPM[0])]);var o=parseFloat(i.getAttribute("data-min")),r=parseFloat(i.getAttribute("data-max")),c=parseFloat(i.getAttribute("data-step")),d=parseInt(i.value,10),s=n.delta||(a?38===n.which?1:-1:0),u=d+c*s;if(void 0!==i.value&&2===i.value.length){var f=i===l.hourElement,m=i===l.minuteElement;u<o?(u=r+u+t(!f)+(t(f)&&t(!l.amPM)),m&&_(void 0,-1,l.hourElement)):u>r&&(u=i===l.hourElement?u-r-t(!l.amPM):o,m&&_(void 0,1,l.hourElement)),l.amPM&&f&&(1===c?u+d===23:Math.abs(u-d)>c)&&(l.amPM.textContent=l.l10n.amPM[t(l.amPM.textContent===l.l10n.amPM[0])]),i.value=e(u)}}(n),"input"!==n.type?(y(),fe()):setTimeout(function(){y(),fe()},C))}function y(){if(void 0!==l.hourElement&&void 0!==l.minuteElement){var e,n,a=(parseInt(l.hourElement.value.slice(-2),10)||0)%24,i=(parseInt(l.minuteElement.value,10)||0)%60,o=void 0!==l.secondElement?(parseInt(l.secondElement.value,10)||0)%60:0;void 0!==l.amPM&&(e=a,n=l.amPM.textContent,a=e%12+12*t(n===l.l10n.amPM[1]));var r=void 0!==l.config.minTime||l.config.minDate&&l.minDateHasTime&&l.latestSelectedDateObj&&0===f(l.latestSelectedDateObj,l.config.minDate,!0);if(void 0!==l.config.maxTime||l.config.maxDate&&l.maxDateHasTime&&l.latestSelectedDateObj&&0===f(l.latestSelectedDateObj,l.config.maxDate,!0)){var c=void 0!==l.config.maxTime?l.config.maxTime:l.config.maxDate;(a=Math.min(a,c.getHours()))===c.getHours()&&(i=Math.min(i,c.getMinutes())),i===c.getMinutes()&&(o=Math.min(o,c.getSeconds()))}if(r){var d=void 0!==l.config.minTime?l.config.minTime:l.config.minDate;(a=Math.max(a,d.getHours()))===d.getHours()&&(i=Math.max(i,d.getMinutes())),i===d.getMinutes()&&(o=Math.max(o,d.getSeconds()))}E(a,i,o)}}function x(e){var t=e||l.latestSelectedDateObj;t&&E(t.getHours(),t.getMinutes(),t.getSeconds())}function E(n,a,i){void 0!==l.latestSelectedDateObj&&l.latestSelectedDateObj.setHours(n%24,a,i||0,0),l.hourElement&&l.minuteElement&&!l.isMobile&&(l.hourElement.value=e(l.config.time_24hr?n:(12+n)%12+12*t(n%12==0)),l.minuteElement.value=e(a),void 0!==l.amPM&&(l.amPM.textContent=l.l10n.amPM[t(n>=12)]),void 0!==l.secondElement&&(l.secondElement.value=e(i)))}function k(e){var t=parseInt(e.target.value)+(e.delta||0);(t/1e3>1||"Enter"===e.key&&!/[^\d]/.test(t.toString()))&&z(t)}function I(e,t,n,a){return t instanceof Array?t.forEach(function(t){return I(e,t,n,a)}):e instanceof Array?e.forEach(function(e){return I(e,t,n,a)}):(e.addEventListener(t,n,a),void l._handlers.push({element:e,event:t,handler:n,options:a}))}function O(e){return function(t){1===t.which&&e(t)}}function S(){le("onChange")}function F(e){var t=void 0!==e?l.parseDate(e):l.latestSelectedDateObj||(l.config.minDate&&l.config.minDate>l.now?l.config.minDate:l.config.maxDate&&l.config.maxDate<l.now?l.config.maxDate:l.now);try{void 0!==t&&(l.currentYear=t.getFullYear(),l.currentMonth=t.getMonth())}catch(e){e.message="Invalid date supplied: "+t,l.config.errorHandler(e)}l.redraw()}function A(e){~e.target.className.indexOf("arrow")&&_(e,e.target.classList.contains("arrowUp")?1:-1)}function _(e,t,n){var a=e&&e.target,i=n||a&&a.parentNode&&a.parentNode.firstChild,o=de("increment");o.delta=t,i&&i.dispatchEvent(o)}function P(e,t,n,a){var i=$(t,!0),o=v("span","flatpickr-day "+e,t.getDate().toString());return o.dateObj=t,o.$i=a,o.setAttribute("aria-label",l.formatDate(t,l.config.ariaDateFormat)),-1===e.indexOf("hidden")&&0===f(t,l.now)&&(l.todayDateElem=o,o.classList.add("today"),o.setAttribute("aria-current","date")),i?(o.tabIndex=-1,se(t)&&(o.classList.add("selected"),l.selectedDateElem=o,"range"===l.config.mode&&(h(o,"startRange",l.selectedDates[0]&&0===f(t,l.selectedDates[0],!0)),h(o,"endRange",l.selectedDates[1]&&0===f(t,l.selectedDates[1],!0)),"nextMonthDay"===e&&o.classList.add("inRange")))):o.classList.add("disabled"),"range"===l.config.mode&&function(e){return!("range"!==l.config.mode||l.selectedDates.length<2)&&f(e,l.selectedDates[0])>=0&&f(e,l.selectedDates[1])<=0}(t)&&!se(t)&&o.classList.add("inRange"),l.weekNumbers&&1===l.config.showMonths&&"prevMonthDay"!==e&&n%7==1&&l.weekNumbers.insertAdjacentHTML("beforeend","<span class='flatpickr-day'>"+l.config.getWeek(t)+"</span>"),le("onDayCreate",o),o}function N(e){e.focus(),"range"===l.config.mode&&Z(e)}function Y(e){for(var t=e>0?0:l.config.showMonths-1,n=e>0?l.config.showMonths:-1,a=t;a!=n;a+=e)for(var i=l.daysContainer.children[a],o=e>0?0:i.children.length-1,r=e>0?i.children.length:-1,c=o;c!=r;c+=e){var d=i.children[c];if(-1===d.className.indexOf("hidden")&&$(d.dateObj))return d}}function j(e,t){var n=G(document.activeElement),a=void 0!==e?e:n?document.activeElement:void 0!==l.selectedDateElem&&G(l.selectedDateElem)?l.selectedDateElem:void 0!==l.todayDateElem&&G(l.todayDateElem)?l.todayDateElem:Y(t>0?1:-1);return void 0===a?l._input.focus():n?void function(e,t){for(var n=-1===e.className.indexOf("Month")?e.dateObj.getMonth():l.currentMonth,a=t>0?l.config.showMonths:-1,i=t>0?1:-1,o=n-l.currentMonth;o!=a;o+=i)for(var r=l.daysContainer.children[o],c=n-l.currentMonth===o?e.$i+t:t<0?r.children.length-1:0,d=r.children.length,s=c;s>=0&&s<d&&s!=(t>0?d:-1);s+=i){var u=r.children[s];if(-1===u.className.indexOf("hidden")&&$(u.dateObj)&&Math.abs(e.$i-s)>=Math.abs(t))return N(u)}l.changeMonth(i),j(Y(i),0)}(a,t):N(a)}function H(e,t){for(var n=(new Date(e,t,1).getDay()-l.l10n.firstDayOfWeek+7)%7,a=l.utils.getDaysInMonth((t-1+12)%12),i=l.utils.getDaysInMonth(t),o=window.document.createDocumentFragment(),r=l.config.showMonths>1,c=r?"prevMonthDay hidden":"prevMonthDay",d=r?"nextMonthDay hidden":"nextMonthDay",s=a+1-n,u=0;s<=a;s++,u++)o.appendChild(P(c,new Date(e,t-1,s),s,u));for(s=1;s<=i;s++,u++)o.appendChild(P("",new Date(e,t,s),s,u));for(var f=i+1;f<=42-n&&(1===l.config.showMonths||u%7!=0);f++,u++)o.appendChild(P(d,new Date(e,t+1,f%i),f,u));var m=v("div","dayContainer");return m.appendChild(o),m}function L(){if(void 0!==l.daysContainer){D(l.daysContainer),l.weekNumbers&&D(l.weekNumbers);for(var e=document.createDocumentFragment(),t=0;t<l.config.showMonths;t++){var n=new Date(l.currentYear,l.currentMonth,1);n.setMonth(l.currentMonth+t),e.appendChild(H(n.getFullYear(),n.getMonth()))}l.daysContainer.appendChild(e),l.days=l.daysContainer.firstChild}}function W(){var e=v("div","flatpickr-month"),t=window.document.createDocumentFragment(),n=v("span","cur-month");n.title=l.l10n.scrollTitle;var a=w("cur-year",{tabindex:"-1"}),i=a.childNodes[0];i.title=l.l10n.scrollTitle,i.setAttribute("aria-label",l.l10n.yearAriaLabel),l.config.minDate&&i.setAttribute("data-min",l.config.minDate.getFullYear().toString()),l.config.maxDate&&(i.setAttribute("data-max",l.config.maxDate.getFullYear().toString()),i.disabled=!!l.config.minDate&&l.config.minDate.getFullYear()===l.config.maxDate.getFullYear());var o=v("div","flatpickr-current-month");return o.appendChild(n),o.appendChild(a),t.appendChild(o),e.appendChild(t),{container:e,yearElement:i,monthElement:n}}function R(){D(l.monthNav),l.monthNav.appendChild(l.prevMonthNav);for(var e=l.config.showMonths;e--;){var t=W();l.yearElements.push(t.yearElement),l.monthElements.push(t.monthElement),l.monthNav.appendChild(t.container)}l.monthNav.appendChild(l.nextMonthNav)}function q(){l.weekdayContainer?D(l.weekdayContainer):l.weekdayContainer=v("div","flatpickr-weekdays");for(var e=l.config.showMonths;e--;){var t=v("div","flatpickr-weekdaycontainer");l.weekdayContainer.appendChild(t)}return J(),l.weekdayContainer}function J(){var e=l.l10n.firstDayOfWeek,t=l.l10n.weekdays.shorthand.concat();e>0&&e<t.length&&(t=t.splice(e,t.length).concat(t.splice(0,e)));for(var n=l.config.showMonths;n--;)l.weekdayContainer.children[n].innerHTML="\n      <span class=flatpickr-weekday>\n        "+t.join("</span><span class=flatpickr-weekday>")+"\n      </span>\n      "}function K(e,t){void 0===t&&(t=!0);var n=t?e:e-l.currentMonth;n<0&&!0===l._hidePrevMonthArrow||n>0&&!0===l._hideNextMonthArrow||(l.currentMonth+=n,(l.currentMonth<0||l.currentMonth>11)&&(l.currentYear+=l.currentMonth>11?1:-1,l.currentMonth=(l.currentMonth+12)%12,le("onYearChange")),L(),le("onMonthChange"),ue())}function B(e){return!(!l.config.appendTo||!l.config.appendTo.contains(e))||l.calendarContainer.contains(e)}function U(e){if(l.isOpen&&!l.config.inline){var t=B(e.target),n=e.target===l.input||e.target===l.altInput||l.element.contains(e.target)||e.path&&e.path.indexOf&&(~e.path.indexOf(l.input)||~e.path.indexOf(l.altInput)),a="blur"===e.type?n&&e.relatedTarget&&!B(e.relatedTarget):!n&&!t,i=!l.config.ignoredFocusElements.some(function(t){return t.contains(e.target)});a&&i&&(l.close(),"range"===l.config.mode&&1===l.selectedDates.length&&(l.clear(!1),l.redraw()))}}function z(e){if(!(!e||l.config.minDate&&e<l.config.minDate.getFullYear()||l.config.maxDate&&e>l.config.maxDate.getFullYear())){var t=e,n=l.currentYear!==t;l.currentYear=t||l.currentYear,l.config.maxDate&&l.currentYear===l.config.maxDate.getFullYear()?l.currentMonth=Math.min(l.config.maxDate.getMonth(),l.currentMonth):l.config.minDate&&l.currentYear===l.config.minDate.getFullYear()&&(l.currentMonth=Math.max(l.config.minDate.getMonth(),l.currentMonth)),n&&(l.redraw(),le("onYearChange"))}}function $(e,t){void 0===t&&(t=!0);var n=l.parseDate(e,void 0,t);if(l.config.minDate&&n&&f(n,l.config.minDate,void 0!==t?t:!l.minDateHasTime)<0||l.config.maxDate&&n&&f(n,l.config.maxDate,void 0!==t?t:!l.maxDateHasTime)>0)return!1;if(0===l.config.enable.length&&0===l.config.disable.length)return!0;if(void 0===n)return!1;for(var a,i=l.config.enable.length>0,o=i?l.config.enable:l.config.disable,r=0;r<o.length;r++){if("function"==typeof(a=o[r])&&a(n))return i;if(a instanceof Date&&void 0!==n&&a.getTime()===n.getTime())return i;if("string"==typeof a&&void 0!==n){var c=l.parseDate(a,void 0,!0);return c&&c.getTime()===n.getTime()?i:!i}if("object"==typeof a&&void 0!==n&&a.from&&a.to&&n.getTime()>=a.from.getTime()&&n.getTime()<=a.to.getTime())return i}return!i}function G(e){return void 0!==l.daysContainer&&(-1===e.className.indexOf("hidden")&&l.daysContainer.contains(e))}function V(e){var t=e.target===l._input,n=B(e.target),a=l.config.allowInput,i=l.isOpen&&(!a||!t),o=l.config.inline&&t&&!a;if(13===e.keyCode&&t){if(a)return l.setDate(l._input.value,!0,e.target===l.altInput?l.config.altFormat:l.config.dateFormat),e.target.blur();l.open()}else if(n||i||o){var r=!!l.timeContainer&&l.timeContainer.contains(e.target);switch(e.keyCode){case 13:r?fe():ie(e);break;case 27:e.preventDefault(),ae();break;case 8:case 46:t&&!l.config.allowInput&&(e.preventDefault(),l.clear());break;case 37:case 39:if(r)l.hourElement&&l.hourElement.focus();else if(e.preventDefault(),void 0!==l.daysContainer&&(!1===a||G(document.activeElement))){var c=39===e.keyCode?1:-1;e.ctrlKey?(K(c),j(Y(1),0)):j(void 0,c)}break;case 38:case 40:e.preventDefault();var d=40===e.keyCode?1:-1;l.daysContainer?e.ctrlKey?(z(l.currentYear-d),j(Y(1),0)):r||j(void 0,7*d):l.config.enableTime&&(!r&&l.hourElement&&l.hourElement.focus(),M(e),l._debouncedChange());break;case 9:if(!r)break;e.target===l.hourElement?(e.preventDefault(),l.minuteElement.select()):e.target===l.minuteElement&&(l.secondElement||l.amPM)?(e.preventDefault(),void 0!==l.secondElement?l.secondElement.focus():void 0!==l.amPM&&(e.preventDefault(),l.amPM.focus())):e.target===l.secondElement&&l.amPM&&(e.preventDefault(),l.amPM.focus())}}if(void 0!==l.amPM&&e.target===l.amPM)switch(e.key){case l.l10n.amPM[0].charAt(0):case l.l10n.amPM[0].charAt(0).toLowerCase():l.amPM.textContent=l.l10n.amPM[0],y(),fe();break;case l.l10n.amPM[1].charAt(0):case l.l10n.amPM[1].charAt(0).toLowerCase():l.amPM.textContent=l.l10n.amPM[1],y(),fe()}le("onKeyDown",e)}function Z(e){if(1===l.selectedDates.length&&e.classList.contains("flatpickr-day")&&!e.classList.contains("disabled")){for(var t=e.dateObj.getTime(),n=l.parseDate(l.selectedDates[0],void 0,!0).getTime(),a=Math.min(t,l.selectedDates[0].getTime()),i=Math.max(t,l.selectedDates[0].getTime()),o=!1,r=0,c=0,d=a;d<i;d+=g.DAY)$(new Date(d),!0)||(o=o||d>a&&d<i,d<n&&(!r||d>r)?r=d:d>n&&(!c||d<c)&&(c=d));for(var s=0;s<l.config.showMonths;s++)for(var u=l.daysContainer.children[s],f=l.daysContainer.children[s-1],p=function(a,i){var d=u.children[a],g=d.dateObj.getTime(),p=r>0&&g<r||c>0&&g>c;return p?(d.classList.add("notAllowed"),["inRange","startRange","endRange"].forEach(function(e){d.classList.remove(e)}),"continue"):o&&!p?"continue":(["startRange","inRange","endRange","notAllowed"].forEach(function(e){d.classList.remove(e)}),e.classList.add(t<l.selectedDates[0].getTime()?"startRange":"endRange"),void(!u.contains(e)&&s>0&&f&&f.lastChild.dateObj.getTime()>=g||(n<t&&g===n?d.classList.add("startRange"):n>t&&g===n&&d.classList.add("endRange"),g>=r&&(0===c||g<=c)&&m(g,n,t)&&d.classList.add("inRange"))))},h=0,v=u.children.length;h<v;h++)p(h)}}function Q(){!l.isOpen||l.config.static||l.config.inline||te()}function X(e){return function(t){var n=l.config["_"+e+"Date"]=l.parseDate(t,l.config.dateFormat),a=l.config["_"+("min"===e?"max":"min")+"Date"];void 0!==n&&(l["min"===e?"minDateHasTime":"maxDateHasTime"]=n.getHours()>0||n.getMinutes()>0||n.getSeconds()>0),l.selectedDates&&(l.selectedDates=l.selectedDates.filter(function(e){return $(e)}),l.selectedDates.length||"min"!==e||x(n),fe()),l.daysContainer&&(ne(),void 0!==n?l.currentYearElement[e]=n.getFullYear().toString():l.currentYearElement.removeAttribute(e),l.currentYearElement.disabled=!!a&&void 0!==n&&a.getFullYear()===n.getFullYear())}}function ee(){"object"!=typeof l.config.locale&&void 0===T.l10ns[l.config.locale]&&l.config.errorHandler(new Error("flatpickr: invalid locale "+l.config.locale)),l.l10n=Object.assign({},T.l10ns.default,"object"==typeof l.config.locale?l.config.locale:"default"!==l.config.locale?T.l10ns[l.config.locale]:void 0),c.K="("+l.l10n.amPM[0]+"|"+l.l10n.amPM[1]+"|"+l.l10n.amPM[0].toLowerCase()+"|"+l.l10n.amPM[1].toLowerCase()+")",l.formatDate=s(l)}function te(e){if(void 0!==l.calendarContainer){le("onPreCalendarPosition");var t=e||l._positionElement,n=Array.prototype.reduce.call(l.calendarContainer.children,function(e,t){return e+t.offsetHeight},0),a=l.calendarContainer.offsetWidth,i=l.config.position.split(" "),o=i[0],r=i.length>1?i[1]:null,c=t.getBoundingClientRect(),d=window.innerHeight-c.bottom,s="above"===o||"below"!==o&&d<n&&c.top>n,u=window.pageYOffset+c.top+(s?-n-2:t.offsetHeight+2);if(h(l.calendarContainer,"arrowTop",!s),h(l.calendarContainer,"arrowBottom",s),!l.config.inline){var f=window.pageXOffset+c.left-(null!=r&&"center"===r?(a-c.width)/2:0),m=window.document.body.offsetWidth-c.right,g=f+a>window.document.body.offsetWidth;h(l.calendarContainer,"rightMost",g),l.config.static||(l.calendarContainer.style.top=u+"px",g?(l.calendarContainer.style.left="auto",l.calendarContainer.style.right=m+"px"):(l.calendarContainer.style.left=f+"px",l.calendarContainer.style.right="auto"))}}}function ne(){l.config.noCalendar||l.isMobile||(ue(),L())}function ae(){l._input.focus(),-1!==window.navigator.userAgent.indexOf("MSIE")||void 0!==navigator.msMaxTouchPoints?setTimeout(l.close,0):l.close()}function ie(e){e.preventDefault(),e.stopPropagation();var t=function e(t,n){return n(t)?t:t.parentNode?e(t.parentNode,n):void 0}(e.target,function(e){return e.classList&&e.classList.contains("flatpickr-day")&&!e.classList.contains("disabled")&&!e.classList.contains("notAllowed")});if(void 0!==t){var n=t,a=l.latestSelectedDateObj=new Date(n.dateObj.getTime()),i=(a.getMonth()<l.currentMonth||a.getMonth()>l.currentMonth+l.config.showMonths-1)&&"range"!==l.config.mode;if(l.selectedDateElem=n,"single"===l.config.mode)l.selectedDates=[a];else if("multiple"===l.config.mode){var o=se(a);o?l.selectedDates.splice(parseInt(o),1):l.selectedDates.push(a)}else"range"===l.config.mode&&(2===l.selectedDates.length&&l.clear(!1),l.selectedDates.push(a),0!==f(a,l.selectedDates[0],!0)&&l.selectedDates.sort(function(e,t){return e.getTime()-t.getTime()}));if(y(),i){var r=l.currentYear!==a.getFullYear();l.currentYear=a.getFullYear(),l.currentMonth=a.getMonth(),r&&le("onYearChange"),le("onMonthChange")}if(ue(),L(),l.config.minDate&&l.minDateHasTime&&l.config.enableTime&&0===f(a,l.config.minDate)&&x(l.config.minDate),fe(),l.config.enableTime&&setTimeout(function(){return l.showTimeInput=!0},50),"range"===l.config.mode&&(1===l.selectedDates.length?Z(n):ue()),i||"range"===l.config.mode||1!==l.config.showMonths?l.selectedDateElem&&l.selectedDateElem.focus():N(n),void 0!==l.hourElement&&setTimeout(function(){return void 0!==l.hourElement&&l.hourElement.select()},451),l.config.closeOnSelect){var c="single"===l.config.mode&&!l.config.enableTime,d="range"===l.config.mode&&2===l.selectedDates.length&&!l.config.enableTime;(c||d)&&ae()}S()}}l.parseDate=u({config:l.config,l10n:l.l10n}),l._handlers=[],l._bind=I,l._setHoursFromDate=x,l.changeMonth=K,l.changeYear=z,l.clear=function(e){void 0===e&&(e=!0);l.input.value="",void 0!==l.altInput&&(l.altInput.value="");void 0!==l.mobileInput&&(l.mobileInput.value="");l.selectedDates=[],l.latestSelectedDateObj=void 0,l.showTimeInput=!1,!0===l.config.enableTime&&(void 0!==l.config.minDate?x(l.config.minDate):E(l.config.defaultHour,l.config.defaultMinute,l.config.defaultSeconds));l.redraw(),e&&le("onChange")},l.close=function(){l.isOpen=!1,l.isMobile||(l.calendarContainer.classList.remove("open"),l._input.classList.remove("active"));le("onClose")},l._createElement=v,l.destroy=function(){void 0!==l.config&&le("onDestroy");for(var e=l._handlers.length;e--;){var t=l._handlers[e];t.element.removeEventListener(t.event,t.handler,t.options)}l._handlers=[],l.mobileInput?(l.mobileInput.parentNode&&l.mobileInput.parentNode.removeChild(l.mobileInput),l.mobileInput=void 0):l.calendarContainer&&l.calendarContainer.parentNode&&l.calendarContainer.parentNode.removeChild(l.calendarContainer);l.altInput&&(l.input.type="text",l.altInput.parentNode&&l.altInput.parentNode.removeChild(l.altInput),delete l.altInput);l.input&&(l.input.type=l.input._type,l.input.classList.remove("flatpickr-input"),l.input.removeAttribute("readonly"),l.input.value="");["_showTimeInput","latestSelectedDateObj","_hideNextMonthArrow","_hidePrevMonthArrow","__hideNextMonthArrow","__hidePrevMonthArrow","isMobile","isOpen","selectedDateElem","minDateHasTime","maxDateHasTime","days","daysContainer","_input","_positionElement","innerContainer","rContainer","monthNav","todayDateElem","calendarContainer","weekdayContainer","prevMonthNav","nextMonthNav","currentMonthElement","currentYearElement","navigationCurrentMonth","selectedDateElem","config"].forEach(function(e){try{delete l[e]}catch(e){}})},l.isEnabled=$,l.jumpToDate=F,l.open=function(e,t){void 0===t&&(t=l._input);if(!0===l.isMobile)return e&&(e.preventDefault(),e.target&&e.target.blur()),setTimeout(function(){void 0!==l.mobileInput&&l.mobileInput.focus()},0),void le("onOpen");if(l._input.disabled||l.config.inline)return;var n=l.isOpen;l.isOpen=!0,n||(l.calendarContainer.classList.add("open"),l._input.classList.add("active"),le("onOpen"),te(t));!0===l.config.enableTime&&!0===l.config.noCalendar&&(0===l.selectedDates.length&&(l.setDate(void 0!==l.config.minDate?new Date(l.config.minDate.getTime()):(new Date).setHours(l.config.defaultHour,l.config.defaultMinute,l.config.defaultSeconds,0),!1),y(),fe()),!1!==l.config.allowInput||void 0!==e&&l.timeContainer.contains(e.relatedTarget)||setTimeout(function(){return l.hourElement.select()},50))},l.redraw=ne,l.set=function(e,t){null!==e&&"object"==typeof e?Object.assign(l.config,e):(l.config[e]=t,void 0!==oe[e]&&oe[e].forEach(function(e){return e()}));l.redraw(),F()},l.setDate=function(e,t,n){void 0===t&&(t=!1);void 0===n&&(n=l.config.dateFormat);if(0!==e&&!e)return l.clear(t);re(e,n),l.showTimeInput=l.selectedDates.length>0,l.latestSelectedDateObj=l.selectedDates[0],l.redraw(),F(),x(),fe(t),t&&le("onChange")},l.toggle=function(e){if(!0===l.isOpen)return l.close();l.open(e)};var oe={locale:[ee,J],showMonths:[R,b,q]};function re(e,t){var n=[];if(e instanceof Array)n=e.map(function(e){return l.parseDate(e,t)});else if(e instanceof Date||"number"==typeof e)n=[l.parseDate(e,t)];else if("string"==typeof e)switch(l.config.mode){case"single":case"time":n=[l.parseDate(e,t)];break;case"multiple":n=e.split(l.config.conjunction).map(function(e){return l.parseDate(e,t)});break;case"range":n=e.split(l.l10n.rangeSeparator).map(function(e){return l.parseDate(e,t)})}else l.config.errorHandler(new Error("Invalid date supplied: "+JSON.stringify(e)));l.selectedDates=n.filter(function(e){return e instanceof Date&&$(e,!1)}),"range"===l.config.mode&&l.selectedDates.sort(function(e,t){return e.getTime()-t.getTime()})}function ce(e){return e.slice().map(function(e){return"string"==typeof e||"number"==typeof e||e instanceof Date?l.parseDate(e,void 0,!0):e&&"object"==typeof e&&e.from&&e.to?{from:l.parseDate(e.from,void 0),to:l.parseDate(e.to,void 0)}:e}).filter(function(e){return e})}function le(e,t){var n=l.config[e];if(void 0!==n&&n.length>0)for(var a=0;n[a]&&a<n.length;a++)n[a](l.selectedDates,l.input.value,l,t);"onChange"===e&&(l.input.dispatchEvent(de("change")),l.input.dispatchEvent(de("input")))}function de(e){var t=document.createEvent("Event");return t.initEvent(e,!0,!0),t}function se(e){for(var t=0;t<l.selectedDates.length;t++)if(0===f(l.selectedDates[t],e))return""+t;return!1}function ue(){l.config.noCalendar||l.isMobile||!l.monthNav||(l.yearElements.forEach(function(e,t){var n=new Date(l.currentYear,l.currentMonth,1);n.setMonth(l.currentMonth+t),l.monthElements[t].textContent=o(n.getMonth(),l.config.shorthandCurrentMonth,l.l10n)+" ",e.value=n.getFullYear().toString()}),l._hidePrevMonthArrow=void 0!==l.config.minDate&&(l.currentYear===l.config.minDate.getFullYear()?l.currentMonth<=l.config.minDate.getMonth():l.currentYear<l.config.minDate.getFullYear()),l._hideNextMonthArrow=void 0!==l.config.maxDate&&(l.currentYear===l.config.maxDate.getFullYear()?l.currentMonth+1>l.config.maxDate.getMonth():l.currentYear>l.config.maxDate.getFullYear()))}function fe(e){if(void 0===e&&(e=!0),0===l.selectedDates.length)return l.clear(e);void 0!==l.mobileInput&&l.mobileFormatStr&&(l.mobileInput.value=void 0!==l.latestSelectedDateObj?l.formatDate(l.latestSelectedDateObj,l.mobileFormatStr):"");var t="range"!==l.config.mode?l.config.conjunction:l.l10n.rangeSeparator;l.input.value=l.selectedDates.map(function(e){return l.formatDate(e,l.config.dateFormat)}).join(t),void 0!==l.altInput&&(l.altInput.value=l.selectedDates.map(function(e){return l.formatDate(e,l.config.altFormat)}).join(t)),!1!==e&&le("onValueUpdate")}function me(e){e.preventDefault();var t=l.prevMonthNav.contains(e.target),n=l.nextMonthNav.contains(e.target);t||n?K(t?-1:1):l.yearElements.indexOf(e.target)>=0?e.target.select():e.target.classList.contains("arrowUp")?l.changeYear(l.currentYear+1):e.target.classList.contains("arrowDown")&&l.changeYear(l.currentYear-1)}return function(){l.element=l.input=i,l.isOpen=!1,function(){var e=["wrap","weekNumbers","allowInput","clickOpens","time_24hr","enableTime","noCalendar","altInput","shorthandCurrentMonth","inline","static","enableSeconds","disableMobile"],t=["onChange","onClose","onDayCreate","onDestroy","onKeyDown","onMonthChange","onOpen","onParseConfig","onReady","onValueUpdate","onYearChange","onPreCalendarPosition"],n=Object.assign({},r,JSON.parse(JSON.stringify(i.dataset||{}))),o={};l.config.parseDate=n.parseDate,l.config.formatDate=n.formatDate,Object.defineProperty(l.config,"enable",{get:function(){return l.config._enable},set:function(e){l.config._enable=ce(e)}}),Object.defineProperty(l.config,"disable",{get:function(){return l.config._disable},set:function(e){l.config._disable=ce(e)}});var c="time"===n.mode;n.dateFormat||!n.enableTime&&!c||(o.dateFormat=n.noCalendar||c?"H:i"+(n.enableSeconds?":S":""):T.defaultConfig.dateFormat+" H:i"+(n.enableSeconds?":S":"")),n.altInput&&(n.enableTime||c)&&!n.altFormat&&(o.altFormat=n.noCalendar||c?"h:i"+(n.enableSeconds?":S K":" K"):T.defaultConfig.altFormat+" h:i"+(n.enableSeconds?":S":"")+" K"),Object.defineProperty(l.config,"minDate",{get:function(){return l.config._minDate},set:X("min")}),Object.defineProperty(l.config,"maxDate",{get:function(){return l.config._maxDate},set:X("max")});var d=function(e){return function(t){l.config["min"===e?"_minTime":"_maxTime"]=l.parseDate(t,"H:i")}};Object.defineProperty(l.config,"minTime",{get:function(){return l.config._minTime},set:d("min")}),Object.defineProperty(l.config,"maxTime",{get:function(){return l.config._maxTime},set:d("max")}),"time"===n.mode&&(l.config.noCalendar=!0,l.config.enableTime=!0),Object.assign(l.config,o,n);for(var s=0;s<e.length;s++)l.config[e[s]]=!0===l.config[e[s]]||"true"===l.config[e[s]];for(var u=t.length;u--;)void 0!==l.config[t[u]]&&(l.config[t[u]]=a(l.config[t[u]]||[]).map(p));l.isMobile=!l.config.disableMobile&&!l.config.inline&&"single"===l.config.mode&&!l.config.disable.length&&!l.config.enable.length&&!l.config.weekNumbers&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);for(var f=0;f<l.config.plugins.length;f++){var m=l.config.plugins[f](l)||{};for(var g in m)~t.indexOf(g)?l.config[g]=a(m[g]).map(p).concat(l.config[g]):void 0===n[g]&&(l.config[g]=m[g])}le("onParseConfig")}(),ee(),l.input=l.config.wrap?i.querySelector("[data-input]"):i,l.input?(l.input._type=l.input.type,l.input.type="text",l.input.classList.add("flatpickr-input"),l._input=l.input,l.config.altInput&&(l.altInput=v(l.input.nodeName,l.input.className+" "+l.config.altInputClass),l._input=l.altInput,l.altInput.placeholder=l.input.placeholder,l.altInput.disabled=l.input.disabled,l.altInput.required=l.input.required,l.altInput.tabIndex=l.input.tabIndex,l.altInput.type="text",l.input.type="hidden",!l.config.static&&l.input.parentNode&&l.input.parentNode.insertBefore(l.altInput,l.input.nextSibling)),l.config.allowInput||l._input.setAttribute("readonly","readonly"),l._positionElement=l.config.positionElement||l._input):l.config.errorHandler(new Error("Invalid input element specified")),function(){l.selectedDates=[],l.now=l.parseDate(l.config.now)||new Date;var e=l.config.defaultDate||l.input.value;e&&re(e,l.config.dateFormat);var t=l.selectedDates.length>0?l.selectedDates[0]:l.config.minDate&&l.config.minDate.getTime()>l.now.getTime()?l.config.minDate:l.config.maxDate&&l.config.maxDate.getTime()<l.now.getTime()?l.config.maxDate:l.now;l.currentYear=t.getFullYear(),l.currentMonth=t.getMonth(),l.selectedDates.length>0&&(l.latestSelectedDateObj=l.selectedDates[0]),void 0!==l.config.minTime&&(l.config.minTime=l.parseDate(l.config.minTime,"H:i")),void 0!==l.config.maxTime&&(l.config.maxTime=l.parseDate(l.config.maxTime,"H:i")),l.minDateHasTime=!!l.config.minDate&&(l.config.minDate.getHours()>0||l.config.minDate.getMinutes()>0||l.config.minDate.getSeconds()>0),l.maxDateHasTime=!!l.config.maxDate&&(l.config.maxDate.getHours()>0||l.config.maxDate.getMinutes()>0||l.config.maxDate.getSeconds()>0),Object.defineProperty(l,"showTimeInput",{get:function(){return l._showTimeInput},set:function(e){l._showTimeInput=e,l.calendarContainer&&h(l.calendarContainer,"showTimeInput",e),l.isOpen&&te()}})}(),l.utils={getDaysInMonth:function(e,t){return void 0===e&&(e=l.currentMonth),void 0===t&&(t=l.currentYear),1===e&&(t%4==0&&t%100!=0||t%400==0)?29:l.l10n.daysInMonth[e]}},l.isMobile||function(){var n=window.document.createDocumentFragment();if(l.calendarContainer=v("div","flatpickr-calendar"),l.calendarContainer.tabIndex=-1,!l.config.noCalendar){if(n.appendChild((l.monthNav=v("div","flatpickr-months"),l.yearElements=[],l.monthElements=[],l.prevMonthNav=v("span","flatpickr-prev-month"),l.prevMonthNav.innerHTML=l.config.prevArrow,l.nextMonthNav=v("span","flatpickr-next-month"),l.nextMonthNav.innerHTML=l.config.nextArrow,R(),Object.defineProperty(l,"_hidePrevMonthArrow",{get:function(){return l.__hidePrevMonthArrow},set:function(e){l.__hidePrevMonthArrow!==e&&(h(l.prevMonthNav,"disabled",e),l.__hidePrevMonthArrow=e)}}),Object.defineProperty(l,"_hideNextMonthArrow",{get:function(){return l.__hideNextMonthArrow},set:function(e){l.__hideNextMonthArrow!==e&&(h(l.nextMonthNav,"disabled",e),l.__hideNextMonthArrow=e)}}),l.currentYearElement=l.yearElements[0],ue(),l.monthNav)),l.innerContainer=v("div","flatpickr-innerContainer"),l.config.weekNumbers){var a=function(){l.calendarContainer.classList.add("hasWeeks");var e=v("div","flatpickr-weekwrapper");e.appendChild(v("span","flatpickr-weekday",l.l10n.weekAbbreviation));var t=v("div","flatpickr-weeks");return e.appendChild(t),{weekWrapper:e,weekNumbers:t}}(),i=a.weekWrapper,o=a.weekNumbers;l.innerContainer.appendChild(i),l.weekNumbers=o,l.weekWrapper=i}l.rContainer=v("div","flatpickr-rContainer"),l.rContainer.appendChild(q()),l.daysContainer||(l.daysContainer=v("div","flatpickr-days"),l.daysContainer.tabIndex=-1),L(),l.rContainer.appendChild(l.daysContainer),l.innerContainer.appendChild(l.rContainer),n.appendChild(l.innerContainer)}l.config.enableTime&&n.appendChild(function(){l.calendarContainer.classList.add("hasTime"),l.config.noCalendar&&l.calendarContainer.classList.add("noCalendar"),l.timeContainer=v("div","flatpickr-time"),l.timeContainer.tabIndex=-1;var n=v("span","flatpickr-time-separator",":"),a=w("flatpickr-hour");l.hourElement=a.childNodes[0];var i=w("flatpickr-minute");if(l.minuteElement=i.childNodes[0],l.hourElement.tabIndex=l.minuteElement.tabIndex=-1,l.hourElement.value=e(l.latestSelectedDateObj?l.latestSelectedDateObj.getHours():l.config.time_24hr?l.config.defaultHour:function(e){switch(e%24){case 0:case 12:return 12;default:return e%12}}(l.config.defaultHour)),l.minuteElement.value=e(l.latestSelectedDateObj?l.latestSelectedDateObj.getMinutes():l.config.defaultMinute),l.hourElement.setAttribute("data-step",l.config.hourIncrement.toString()),l.minuteElement.setAttribute("data-step",l.config.minuteIncrement.toString()),l.hourElement.setAttribute("data-min",l.config.time_24hr?"0":"1"),l.hourElement.setAttribute("data-max",l.config.time_24hr?"23":"12"),l.minuteElement.setAttribute("data-min","0"),l.minuteElement.setAttribute("data-max","59"),l.timeContainer.appendChild(a),l.timeContainer.appendChild(n),l.timeContainer.appendChild(i),l.config.time_24hr&&l.timeContainer.classList.add("time24hr"),l.config.enableSeconds){l.timeContainer.classList.add("hasSeconds");var o=w("flatpickr-second");l.secondElement=o.childNodes[0],l.secondElement.value=e(l.latestSelectedDateObj?l.latestSelectedDateObj.getSeconds():l.config.defaultSeconds),l.secondElement.setAttribute("data-step",l.minuteElement.getAttribute("data-step")),l.secondElement.setAttribute("data-min",l.minuteElement.getAttribute("data-min")),l.secondElement.setAttribute("data-max",l.minuteElement.getAttribute("data-max")),l.timeContainer.appendChild(v("span","flatpickr-time-separator",":")),l.timeContainer.appendChild(o)}return l.config.time_24hr||(l.amPM=v("span","flatpickr-am-pm",l.l10n.amPM[t((l.latestSelectedDateObj?l.hourElement.value:l.config.defaultHour)>11)]),l.amPM.title=l.l10n.toggleTitle,l.amPM.tabIndex=-1,l.timeContainer.appendChild(l.amPM)),l.timeContainer}()),h(l.calendarContainer,"rangeMode","range"===l.config.mode),h(l.calendarContainer,"animate",!0===l.config.animate),h(l.calendarContainer,"multiMonth",l.config.showMonths>1),l.calendarContainer.appendChild(n);var r=void 0!==l.config.appendTo&&void 0!==l.config.appendTo.nodeType;if((l.config.inline||l.config.static)&&(l.calendarContainer.classList.add(l.config.inline?"inline":"static"),l.config.inline&&(!r&&l.element.parentNode?l.element.parentNode.insertBefore(l.calendarContainer,l._input.nextSibling):void 0!==l.config.appendTo&&l.config.appendTo.appendChild(l.calendarContainer)),l.config.static)){var c=v("div","flatpickr-wrapper");l.element.parentNode&&l.element.parentNode.insertBefore(c,l.element),c.appendChild(l.element),l.altInput&&c.appendChild(l.altInput),c.appendChild(l.calendarContainer)}l.config.static||l.config.inline||(void 0!==l.config.appendTo?l.config.appendTo:window.document.body).appendChild(l.calendarContainer)}(),function(){if(l.config.wrap&&["open","close","toggle","clear"].forEach(function(e){Array.prototype.forEach.call(l.element.querySelectorAll("[data-"+e+"]"),function(t){return I(t,"click",l[e])})}),l.isMobile)!function(){var e=l.config.enableTime?l.config.noCalendar?"time":"datetime-local":"date";l.mobileInput=v("input",l.input.className+" flatpickr-mobile"),l.mobileInput.step=l.input.getAttribute("step")||"any",l.mobileInput.tabIndex=1,l.mobileInput.type=e,l.mobileInput.disabled=l.input.disabled,l.mobileInput.required=l.input.required,l.mobileInput.placeholder=l.input.placeholder,l.mobileFormatStr="datetime-local"===e?"Y-m-d\\TH:i:S":"date"===e?"Y-m-d":"H:i:S",l.selectedDates.length>0&&(l.mobileInput.defaultValue=l.mobileInput.value=l.formatDate(l.selectedDates[0],l.mobileFormatStr)),l.config.minDate&&(l.mobileInput.min=l.formatDate(l.config.minDate,"Y-m-d")),l.config.maxDate&&(l.mobileInput.max=l.formatDate(l.config.maxDate,"Y-m-d")),l.input.type="hidden",void 0!==l.altInput&&(l.altInput.type="hidden");try{l.input.parentNode&&l.input.parentNode.insertBefore(l.mobileInput,l.input.nextSibling)}catch(e){}I(l.mobileInput,"change",function(e){l.setDate(e.target.value,!1,l.mobileFormatStr),le("onChange"),le("onClose")})}();else{var e=n(Q,50);l._debouncedChange=n(S,C),l.daysContainer&&!/iPhone|iPad|iPod/i.test(navigator.userAgent)&&I(l.daysContainer,"mouseover",function(e){"range"===l.config.mode&&Z(e.target)}),I(window.document.body,"keydown",V),l.config.static||I(l._input,"keydown",V),l.config.inline||l.config.static||I(window,"resize",e),void 0!==window.ontouchstart?I(window.document,"click",U):I(window.document,"mousedown",O(U)),I(window.document,"focus",U,{capture:!0}),!0===l.config.clickOpens&&(I(l._input,"focus",l.open),I(l._input,"mousedown",O(l.open))),void 0!==l.daysContainer&&(I(l.monthNav,"mousedown",O(me)),I(l.monthNav,["keyup","increment"],k),I(l.daysContainer,"mousedown",O(ie))),void 0!==l.timeContainer&&void 0!==l.minuteElement&&void 0!==l.hourElement&&(I(l.timeContainer,["input","increment"],M),I(l.timeContainer,"mousedown",O(A)),I(l.timeContainer,["input","increment"],l._debouncedChange,{passive:!0}),I([l.hourElement,l.minuteElement],["focus","click"],function(e){return e.target.select()}),void 0!==l.secondElement&&I(l.secondElement,"focus",function(){return l.secondElement&&l.secondElement.select()}),void 0!==l.amPM&&I(l.amPM,"mousedown",O(function(e){M(e),S()})))}}(),(l.selectedDates.length||l.config.noCalendar)&&(l.config.enableTime&&x(l.config.noCalendar?l.latestSelectedDateObj||l.config.minDate:void 0),fe(!1)),b(),l.showTimeInput=l.selectedDates.length>0||l.config.noCalendar;var o=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);!l.isMobile&&o&&te(),le("onReady")}(),l}function E(e,t){for(var n=Array.prototype.slice.call(e),a=[],i=0;i<n.length;i++){var o=n[i];try{if(null!==o.getAttribute("data-fp-omit"))continue;void 0!==o._flatpickr&&(o._flatpickr.destroy(),o._flatpickr=void 0),o._flatpickr=x(o,t||{}),a.push(o._flatpickr)}catch(e){console.error(e)}}return 1===a.length?a[0]:a}"undefined"!=typeof HTMLElement&&(HTMLCollection.prototype.flatpickr=NodeList.prototype.flatpickr=function(e){return E(this,e)},HTMLElement.prototype.flatpickr=function(e){return E([this],e)});var T=function(e,t){return e instanceof NodeList?E(e,t):E("string"==typeof e?window.document.querySelectorAll(e):[e],t)};return T.defaultConfig=p,T.l10ns={en:Object.assign({},d),default:Object.assign({},d)},T.localize=function(e){T.l10ns.default=Object.assign({},T.l10ns.default,e)},T.setDefaults=function(e){T.defaultConfig=Object.assign({},T.defaultConfig,e)},T.parseDate=u({}),T.formatDate=s({}),T.compareDates=f,"undefined"!=typeof jQuery&&(jQuery.fn.flatpickr=function(e){return E(this,e)}),Date.prototype.fp_incr=function(e){return new Date(this.getFullYear(),this.getMonth(),this.getDate()+("string"==typeof e?parseInt(e,10):e))},"undefined"!=typeof window&&(window.flatpickr=T),T});
-
-},{}],3:[function(require,module,exports){
-!function(n,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(n.index={})}(this,function(n){"use strict";var e="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},a={weekdays:{shorthand:["أحد","اثنين","ثلاثاء","أربعاء","خميس","جمعة","سبت"],longhand:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},months:{shorthand:["1","2","3","4","5","6","7","8","9","10","11","12"],longhand:["يناير","فبراير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نوفمبر","ديسمبر"]}};e.l10ns.ar=a,e.l10ns;var r="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},o={weekdays:{shorthand:["So","Mo","Di","Mi","Do","Fr","Sa"],longhand:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"]},months:{shorthand:["Jän","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],longhand:["Jänner","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"]},firstDayOfWeek:1,weekAbbreviation:"KW",rangeSeparator:" bis ",scrollTitle:"Zum Ändern scrollen",toggleTitle:"Zum Umschalten klicken"};r.l10ns.at=o,r.l10ns;var i="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},t={weekdays:{shorthand:["Нд","Пн","Аў","Ср","Чц","Пт","Сб"],longhand:["Нядзеля","Панядзелак","Аўторак","Серада","Чацвер","Пятніца","Субота"]},months:{shorthand:["Сту","Лют","Сак","Кра","Тра","Чэр","Ліп","Жні","Вер","Кас","Ліс","Сне"],longhand:["Студзень","Люты","Сакавік","Красавік","Травень","Чэрвень","Ліпень","Жнівень","Верасень","Кастрычнік","Лістапад","Снежань"]},firstDayOfWeek:1,ordinal:function(){return""},rangeSeparator:" — ",weekAbbreviation:"Тыд.",scrollTitle:"Пракруціце для павелічэння",toggleTitle:"Націсніце для пераключэння",amPM:["ДП","ПП"],yearAriaLabel:"Год"};i.l10ns.be=t,i.l10ns;var d="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},l={weekdays:{shorthand:["Нд","Пн","Вт","Ср","Чт","Пт","Сб"],longhand:["Неделя","Понеделник","Вторник","Сряда","Четвъртък","Петък","Събота"]},months:{shorthand:["Яну","Фев","Март","Апр","Май","Юни","Юли","Авг","Сеп","Окт","Ное","Дек"],longhand:["Януари","Февруари","Март","Април","Май","Юни","Юли","Август","Септември","Октомври","Ноември","Декември"]}};d.l10ns.bg=l,d.l10ns;var s="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},u={weekdays:{shorthand:["রবি","সোম","মঙ্গল","বুধ","বৃহস্পতি","শুক্র","শনি"],longhand:["রবিবার","সোমবার","মঙ্গলবার","বুধবার","বৃহস্পতিবার","শুক্রবার","শনিবার"]},months:{shorthand:["জানু","ফেব্রু","মার্চ","এপ্রিল","মে","জুন","জুলাই","আগ","সেপ্টে","অক্টো","নভে","ডিসে"],longhand:["জানুয়ারী","ফেব্রুয়ারী","মার্চ","এপ্রিল","মে","জুন","জুলাই","আগস্ট","সেপ্টেম্বর","অক্টোবর","নভেম্বর","ডিসেম্বর"]}};s.l10ns.bn=u,s.l10ns;var h="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},w={weekdays:{shorthand:["Dg","Dl","Dt","Dc","Dj","Dv","Ds"],longhand:["Diumenge","Dilluns","Dimarts","Dimecres","Dijous","Divendres","Dissabte"]},months:{shorthand:["Gen","Febr","Març","Abr","Maig","Juny","Jul","Ag","Set","Oct","Nov","Des"],longhand:["Gener","Febrer","Març","Abril","Maig","Juny","Juliol","Agost","Setembre","Octubre","Novembre","Desembre"]},ordinal:function(n){var e=n%100;if(e>3&&e<21)return"è";switch(e%10){case 1:return"r";case 2:return"n";case 3:return"r";case 4:return"t";default:return"è"}},firstDayOfWeek:1};h.l10ns.cat=w,h.l10ns;var f="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},k={weekdays:{shorthand:["Ne","Po","Út","St","Čt","Pá","So"],longhand:["Neděle","Pondělí","Úterý","Středa","Čtvrtek","Pátek","Sobota"]},months:{shorthand:["Led","Ún","Bře","Dub","Kvě","Čer","Čvc","Srp","Zář","Říj","Lis","Pro"],longhand:["Leden","Únor","Březen","Duben","Květen","Červen","Červenec","Srpen","Září","Říjen","Listopad","Prosinec"]},firstDayOfWeek:1,ordinal:function(){return"."},rangeSeparator:" do ",weekAbbreviation:"Týd.",scrollTitle:"Rolujte pro změnu",toggleTitle:"Přepnout dopoledne/odpoledne",amPM:["dop.","odp."],yearAriaLabel:"Rok"};f.l10ns.cs=k,f.l10ns;var p="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},g={weekdays:{shorthand:["Sul","Llun","Maw","Mer","Iau","Gwe","Sad"],longhand:["Dydd Sul","Dydd Llun","Dydd Mawrth","Dydd Mercher","Dydd Iau","Dydd Gwener","Dydd Sadwrn"]},months:{shorthand:["Ion","Chwef","Maw","Ebr","Mai","Meh","Gorff","Awst","Medi","Hyd","Tach","Rhag"],longhand:["Ionawr","Chwefror","Mawrth","Ebrill","Mai","Mehefin","Gorffennaf","Awst","Medi","Hydref","Tachwedd","Rhagfyr"]},firstDayOfWeek:1,ordinal:function(n){return 1===n?"af":2===n?"ail":3===n||4===n?"ydd":5===n||6===n?"ed":n>=7&&n<=10||12==n||15==n||18==n||20==n?"fed":11==n||13==n||14==n||16==n||17==n||19==n?"eg":n>=21&&n<=39?"ain":""}};p.l10ns.cy=g,p.l10ns;var c="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},b={weekdays:{shorthand:["søn","man","tir","ons","tors","fre","lør"],longhand:["søndag","mandag","tirsdag","onsdag","torsdag","fredag","lørdag"]},months:{shorthand:["jan","feb","mar","apr","maj","jun","jul","aug","sep","okt","nov","dec"],longhand:["januar","februar","marts","april","maj","juni","juli","august","september","oktober","november","december"]},ordinal:function(){return"."},firstDayOfWeek:1,rangeSeparator:" til ",weekAbbreviation:"uge"};c.l10ns.da=b,c.l10ns;var v="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},m={weekdays:{shorthand:["So","Mo","Di","Mi","Do","Fr","Sa"],longhand:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"]},months:{shorthand:["Jan","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],longhand:["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"]},firstDayOfWeek:1,weekAbbreviation:"KW",rangeSeparator:" bis ",scrollTitle:"Zum Ändern scrollen",toggleTitle:"Zum Umschalten klicken"};v.l10ns.de=m,v.l10ns;var y={weekdays:{shorthand:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],longhand:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},months:{shorthand:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],longhand:["January","February","March","April","May","June","July","August","September","October","November","December"]},daysInMonth:[31,28,31,30,31,30,31,31,30,31,30,31],firstDayOfWeek:0,ordinal:function(n){var e=n%100;if(e>3&&e<21)return"th";switch(e%10){case 1:return"st";case 2:return"nd";case 3:return"rd";default:return"th"}},rangeSeparator:" to ",weekAbbreviation:"Wk",scrollTitle:"Scroll to increment",toggleTitle:"Click to toggle",amPM:["AM","PM"],yearAriaLabel:"Year"},S="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},M={firstDayOfWeek:1,rangeSeparator:" ĝis ",weekAbbreviation:"Sem",scrollTitle:"Rulumu por pligrandigi la valoron",toggleTitle:"Klaku por ŝalti",weekdays:{shorthand:["Dim","Lun","Mar","Mer","Ĵaŭ","Ven","Sab"],longhand:["dimanĉo","lundo","mardo","merkredo","ĵaŭdo","vendredo","sabato"]},months:{shorthand:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Aŭg","Sep","Okt","Nov","Dec"],longhand:["januaro","februaro","marto","aprilo","majo","junio","julio","aŭgusto","septembro","oktobro","novembro","decembro"]},ordinal:function(){return"-a"}};S.l10ns.eo=M,S.l10ns;var D="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},J={weekdays:{shorthand:["Dom","Lun","Mar","Mié","Jue","Vie","Sáb"],longhand:["Domingo","Lunes","Martes","Miércoles","Jueves","Viernes","Sábado"]},months:{shorthand:["Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic"],longhand:["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"]},ordinal:function(){return"º"},firstDayOfWeek:1,rangeSeparator:" a "};D.l10ns.es=J,D.l10ns;var T="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},A={weekdays:{shorthand:["P","E","T","K","N","R","L"],longhand:["Pühapäev","Esmaspäev","Teisipäev","Kolmapäev","Neljapäev","Reede","Laupäev"]},months:{shorthand:["Jaan","Veebr","Märts","Apr","Mai","Juuni","Juuli","Aug","Sept","Okt","Nov","Dets"],longhand:["Jaanuar","Veebruar","Märts","Aprill","Mai","Juuni","Juuli","August","September","Oktoober","November","Detsember"]},firstDayOfWeek:1,ordinal:function(){return"."},weekAbbreviation:"Näd",rangeSeparator:" kuni ",scrollTitle:"Keri, et suurendada",toggleTitle:"Klõpsa, et vahetada"};T.l10ns.et=A,T.l10ns;var O="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},j={weekdays:{shorthand:["یک","دو","سه","چهار","پنج","جمعه","شنبه"],longhand:["یک‌شنبه","دوشنبه","سه‌شنبه","چهارشنبه","پنچ‌شنبه","جمعه","شنبه"]},months:{shorthand:["ژانویه","فوریه","مارس","آوریل","مه","ژوئن","ژوئیه","اوت","سپتامبر","اکتبر","نوامبر","دسامبر"],longhand:["ژانویه","فوریه","مارس","آوریل","مه","ژوئن","ژوئیه","اوت","سپتامبر","اکتبر","نوامبر","دسامبر"]},firstDayOfWeek:6,ordinal:function(){return""}};O.l10ns.fa=j,O.l10ns;var P="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},N={firstDayOfWeek:1,weekdays:{shorthand:["Su","Ma","Ti","Ke","To","Pe","La"],longhand:["Sunnuntai","Maanantai","Tiistai","Keskiviikko","Torstai","Perjantai","Lauantai"]},months:{shorthand:["Tammi","Helmi","Maalis","Huhti","Touko","Kesä","Heinä","Elo","Syys","Loka","Marras","Joulu"],longhand:["Tammikuu","Helmikuu","Maaliskuu","Huhtikuu","Toukokuu","Kesäkuu","Heinäkuu","Elokuu","Syyskuu","Lokakuu","Marraskuu","Joulukuu"]},ordinal:function(){return"."}};P.l10ns.fi=N,P.l10ns;var z="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},F={firstDayOfWeek:1,weekdays:{shorthand:["Dim","Lun","Mar","Mer","Jeu","Ven","Sam"],longhand:["Dimanche","Lundi","Mardi","Mercredi","Jeudi","Vendredi","Samedi"]},months:{shorthand:["Janv","Févr","Mars","Avr","Mai","Juin","Juil","Août","Sept","Oct","Nov","Déc"],longhand:["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"]},ordinal:function(n){return n>1?"ème":"er"},rangeSeparator:" au ",weekAbbreviation:"Sem",scrollTitle:"Défiler pour augmenter la valeur",toggleTitle:"Cliquer pour basculer"};z.l10ns.fr=F,z.l10ns;var W="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},L={weekdays:{shorthand:["Κυ","Δε","Τρ","Τε","Πέ","Πα","Σά"],longhand:["Κυριακή","Δευτέρα","Τρίτη","Τετάρτη","Πέμπτη","Παρασκευή","Σάββατο"]},months:{shorthand:["Ιαν","Φεβ","Μάρ","Απρ","Μάι","Ιού","Ιού","Αύγ","Σεπ","Οκτ","Νοέ","Δεκ"],longhand:["Ιανουάριος","Φεβρουάριος","Μάρτιος","Απρίλιος","Μάιος","Ιούνιος","Ιούλιος","Αύγουστος","Σεπτέμβριος","Οκτώβριος","Νοέμβριος","Δεκέμβριος"]},firstDayOfWeek:1,ordinal:function(){return""},weekAbbreviation:"Εβδ",rangeSeparator:" έως ",scrollTitle:"Μετακυλήστε για προσαύξηση",toggleTitle:"Κάντε κλικ για αλλαγή",amPM:["ΠΜ","ΜΜ"]};W.l10ns.gr=L,W.l10ns;var K="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},E={weekdays:{shorthand:["א","ב","ג","ד","ה","ו","ז"],longhand:["ראשון","שני","שלישי","רביעי","חמישי","שישי","שבת"]},months:{shorthand:["ינו׳","פבר׳","מרץ","אפר׳","מאי","יוני","יולי","אוג׳","ספט׳","אוק׳","נוב׳","דצמ׳"],longhand:["ינואר","פברואר","מרץ","אפריל","מאי","יוני","יולי","אוגוסט","ספטמבר","אוקטובר","נובמבר","דצמבר"]}};K.l10ns.he=E,K.l10ns;var G="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},C={weekdays:{shorthand:["रवि","सोम","मंगल","बुध","गुरु","शुक्र","शनि"],longhand:["रविवार","सोमवार","मंगलवार","बुधवार","गुरुवार","शुक्रवार","शनिवार"]},months:{shorthand:["जन","फर","मार्च","अप्रेल","मई","जून","जूलाई","अग","सित","अक्ट","नव","दि"],longhand:["जनवरी ","फरवरी","मार्च","अप्रेल","मई","जून","जूलाई","अगस्त ","सितम्बर","अक्टूबर","नवम्बर","दिसम्बर"]}};G.l10ns.hi=C,G.l10ns;var R="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},V={firstDayOfWeek:1,weekdays:{shorthand:["Ned","Pon","Uto","Sri","Čet","Pet","Sub"],longhand:["Nedjelja","Ponedjeljak","Utorak","Srijeda","Četvrtak","Petak","Subota"]},months:{shorthand:["Sij","Velj","Ožu","Tra","Svi","Lip","Srp","Kol","Ruj","Lis","Stu","Pro"],longhand:["Siječanj","Veljača","Ožujak","Travanj","Svibanj","Lipanj","Srpanj","Kolovoz","Rujan","Listopad","Studeni","Prosinac"]}};R.l10ns.hr=V,R.l10ns;var H="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},I={firstDayOfWeek:1,weekdays:{shorthand:["V","H","K","Sz","Cs","P","Szo"],longhand:["Vasárnap","Hétfő","Kedd","Szerda","Csütörtök","Péntek","Szombat"]},months:{shorthand:["Jan","Feb","Már","Ápr","Máj","Jún","Júl","Aug","Szep","Okt","Nov","Dec"],longhand:["Január","Február","Március","Április","Május","Június","Július","Augusztus","Szeptember","Október","November","December"]},ordinal:function(){return"."},weekAbbreviation:"Hét",scrollTitle:"Görgessen",toggleTitle:"Kattintson a váltáshoz"};H.l10ns.hu=I,H.l10ns;var U="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},x={weekdays:{shorthand:["Min","Sen","Sel","Rab","Kam","Jum","Sab"],longhand:["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"]},months:{shorthand:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Agu","Sep","Okt","Nov","Des"],longhand:["Januari","Februari","Maret","April","Mei","Juni","Juli","Agustus","September","Oktober","November","Desember"]},firstDayOfWeek:1,ordinal:function(){return""}};U.l10ns.id=x,U.l10ns;var B="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Q={weekdays:{shorthand:["Dom","Lun","Mar","Mer","Gio","Ven","Sab"],longhand:["Domenica","Lunedì","Martedì","Mercoledì","Giovedì","Venerdì","Sabato"]},months:{shorthand:["Gen","Feb","Mar","Apr","Mag","Giu","Lug","Ago","Set","Ott","Nov","Dic"],longhand:["Gennaio","Febbraio","Marzo","Aprile","Maggio","Giugno","Luglio","Agosto","Settembre","Ottobre","Novembre","Dicembre"]},firstDayOfWeek:1,ordinal:function(){return"°"},rangeSeparator:" al ",weekAbbreviation:"Se",scrollTitle:"Scrolla per aumentare",toggleTitle:"Clicca per cambiare"};B.l10ns.it=Q,B.l10ns;var Z="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},q={weekdays:{shorthand:["日","月","火","水","木","金","土"],longhand:["日曜日","月曜日","火曜日","水曜日","木曜日","金曜日","土曜日"]},months:{shorthand:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],longhand:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"]}};Z.l10ns.ja=q,Z.l10ns;var _="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Y={weekdays:{shorthand:["일","월","화","수","목","금","토"],longhand:["일요일","월요일","화요일","수요일","목요일","금요일","토요일"]},months:{shorthand:["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"],longhand:["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"]},ordinal:function(){return"일"}};_.l10ns.ko=Y,_.l10ns;var X="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},$={weekdays:{shorthand:["S","Pr","A","T","K","Pn","Š"],longhand:["Sekmadienis","Pirmadienis","Antradienis","Trečiadienis","Ketvirtadienis","Penktadienis","Šeštadienis"]},months:{shorthand:["Sau","Vas","Kov","Bal","Geg","Bir","Lie","Rgp","Rgs","Spl","Lap","Grd"],longhand:["Sausis","Vasaris","Kovas","Balandis","Gegužė","Birželis","Liepa","Rugpjūtis","Rugsėjis","Spalis","Lapkritis","Gruodis"]},firstDayOfWeek:1,ordinal:function(){return"-a"},weekAbbreviation:"Sav",scrollTitle:"Keisti laiką pelės rateliu",toggleTitle:"Perjungti laiko formatą"};X.l10ns.lt=$,X.l10ns;var nn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},en={firstDayOfWeek:1,weekdays:{shorthand:["Sv","P","Ot","Tr","Ce","Pk","Se"],longhand:["Svētdiena","Pirmdiena","Otrdiena","Trešdiena","Ceturtdiena","Piektdiena","Sestdiena"]},months:{shorthand:["Jan","Feb","Mar","Mai","Apr","Jūn","Jūl","Aug","Sep","Okt","Nov","Dec"],longhand:["Janvāris","Februāris","Marts","Aprīlis","Maijs","Jūnijs","Jūlijs","Augusts","Septembris","Oktobris","Novembris","Decembris"]},rangeSeparator:" līdz "};nn.l10ns.lv=en,nn.l10ns;var an="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},rn={weekdays:{shorthand:["Не","По","Вт","Ср","Че","Пе","Са"],longhand:["Недела","Понеделник","Вторник","Среда","Четврток","Петок","Сабота"]},months:{shorthand:["Јан","Фев","Мар","Апр","Мај","Јун","Јул","Авг","Сеп","Окт","Ное","Дек"],longhand:["Јануари","Февруари","Март","Април","Мај","Јуни","Јули","Август","Септември","Октомври","Ноември","Декември"]},firstDayOfWeek:1,weekAbbreviation:"Нед.",rangeSeparator:" до "};an.l10ns.mk=rn,an.l10ns;var on="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},tn={firstDayOfWeek:1,weekdays:{shorthand:["Да","Мя","Лх","Пү","Ба","Бя","Ня"],longhand:["Даваа","Мягмар","Лхагва","Пүрэв","Баасан","Бямба","Ням"]},months:{shorthand:["1-р сар","2-р сар","3-р сар","4-р сар","5-р сар","6-р сар","7-р сар","8-р сар","9-р сар","10-р сар","11-р сар","12-р сар"],longhand:["Нэгдүгээр сар","Хоёрдугаар сар","Гуравдугаар сар","Дөрөвдүгээр сар","Тавдугаар сар","Зургаадугаар сар","Долдугаар сар","Наймдугаар сар","Есдүгээр сар","Аравдугаар сар","Арваннэгдүгээр сар","Арванхоёрдугаар сар"]},rangeSeparator:"-с "};on.l10ns.mn=tn,on.l10ns;("undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}}).l10ns;var dn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},ln={weekdays:{shorthand:["နွေ","လာ","ဂါ","ဟူး","ကြာ","သော","နေ"],longhand:["တနင်္ဂနွေ","တနင်္လာ","အင်္ဂါ","ဗုဒ္ဓဟူး","ကြာသပတေး","သောကြာ","စနေ"]},months:{shorthand:["ဇန်","ဖေ","မတ်","ပြီ","မေ","ဇွန်","လိုင်","သြ","စက်","အောက်","နို","ဒီ"],longhand:["ဇန်နဝါရီ","ဖေဖော်ဝါရီ","မတ်","ဧပြီ","မေ","ဇွန်","ဇူလိုင်","သြဂုတ်","စက်တင်ဘာ","အောက်တိုဘာ","နိုဝင်ဘာ","ဒီဇင်ဘာ"]},firstDayOfWeek:1,ordinal:function(){return""}};dn.l10ns.my=ln,dn.l10ns;var sn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},un={weekdays:{shorthand:["zo","ma","di","wo","do","vr","za"],longhand:["zondag","maandag","dinsdag","woensdag","donderdag","vrijdag","zaterdag"]},months:{shorthand:["jan","feb","mrt","apr","mei","jun","jul","aug","sept","okt","nov","dec"],longhand:["januari","februari","maart","april","mei","juni","juli","augustus","september","oktober","november","december"]},firstDayOfWeek:1,weekAbbreviation:"wk",rangeSeparator:" tot ",scrollTitle:"Scroll voor volgende / vorige",toggleTitle:"Klik om te wisselen",ordinal:function(n){return 1===n||8===n||n>=20?"ste":"de"}};sn.l10ns.nl=un,sn.l10ns;var hn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},wn={weekdays:{shorthand:["Søn","Man","Tir","Ons","Tor","Fre","Lør"],longhand:["Søndag","Mandag","Tirsdag","Onsdag","Torsdag","Fredag","Lørdag"]},months:{shorthand:["Jan","Feb","Mar","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Des"],longhand:["Januar","Februar","Mars","April","Mai","Juni","Juli","August","September","Oktober","November","Desember"]},firstDayOfWeek:1,rangeSeparator:" til ",weekAbbreviation:"Uke",scrollTitle:"Scroll for å endre",toggleTitle:"Klikk for å veksle",ordinal:function(){return"."}};hn.l10ns.no=wn,hn.l10ns;var fn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},kn={weekdays:{shorthand:["ਐਤ","ਸੋਮ","ਮੰਗਲ","ਬੁੱਧ","ਵੀਰ","ਸ਼ੁੱਕਰ","ਸ਼ਨਿੱਚਰ"],longhand:["ਐਤਵਾਰ","ਸੋਮਵਾਰ","ਮੰਗਲਵਾਰ","ਬੁੱਧਵਾਰ","ਵੀਰਵਾਰ","ਸ਼ੁੱਕਰਵਾਰ","ਸ਼ਨਿੱਚਰਵਾਰ"]},months:{shorthand:["ਜਨ","ਫ਼ਰ","ਮਾਰ","ਅਪ੍ਰੈ","ਮਈ","ਜੂਨ","ਜੁਲਾ","ਅਗ","ਸਤੰ","ਅਕ","ਨਵੰ","ਦਸੰ"],longhand:["ਜਨਵਰੀ","ਫ਼ਰਵਰੀ","ਮਾਰਚ","ਅਪ੍ਰੈਲ","ਮਈ","ਜੂਨ","ਜੁਲਾਈ","ਅਗਸਤ","ਸਤੰਬਰ","ਅਕਤੂਬਰ","ਨਵੰਬਰ","ਦਸੰਬਰ"]}};fn.l10ns.pa=kn,fn.l10ns;var pn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},gn={weekdays:{shorthand:["Nd","Pn","Wt","Śr","Cz","Pt","So"],longhand:["Niedziela","Poniedziałek","Wtorek","Środa","Czwartek","Piątek","Sobota"]},months:{shorthand:["Sty","Lut","Mar","Kwi","Maj","Cze","Lip","Sie","Wrz","Paź","Lis","Gru"],longhand:["Styczeń","Luty","Marzec","Kwiecień","Maj","Czerwiec","Lipiec","Sierpień","Wrzesień","Październik","Listopad","Grudzień"]},rangeSeparator:" do ",weekAbbreviation:"tydz.",scrollTitle:"Przwiń aby zwiększyć",toggleTitle:"Kliknij aby przełączyć",firstDayOfWeek:1,ordinal:function(){return"."}};pn.l10ns.pl=gn,pn.l10ns;var cn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},bn={weekdays:{shorthand:["Dom","Seg","Ter","Qua","Qui","Sex","Sáb"],longhand:["Domingo","Segunda-feira","Terça-feira","Quarta-feira","Quinta-feira","Sexta-feira","Sábado"]},months:{shorthand:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],longhand:["Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"]},rangeSeparator:" até "};cn.l10ns.pt=bn,cn.l10ns;var vn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},mn={weekdays:{shorthand:["Dum","Lun","Mar","Mie","Joi","Vin","Sam"],longhand:["Duminică","Luni","Marți","Miercuri","Joi","Vineri","Sâmbătă"]},months:{shorthand:["Ian","Feb","Mar","Apr","Mai","Iun","Iul","Aug","Sep","Oct","Noi","Dec"],longhand:["Ianuarie","Februarie","Martie","Aprilie","Mai","Iunie","Iulie","August","Septembrie","Octombrie","Noiembrie","Decembrie"]},firstDayOfWeek:1,ordinal:function(){return""}};vn.l10ns.ro=mn,vn.l10ns;var yn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Sn={weekdays:{shorthand:["Вс","Пн","Вт","Ср","Чт","Пт","Сб"],longhand:["Воскресенье","Понедельник","Вторник","Среда","Четверг","Пятница","Суббота"]},months:{shorthand:["Янв","Фев","Март","Апр","Май","Июнь","Июль","Авг","Сен","Окт","Ноя","Дек"],longhand:["Январь","Февраль","Март","Апрель","Май","Июнь","Июль","Август","Сентябрь","Октябрь","Ноябрь","Декабрь"]},firstDayOfWeek:1,ordinal:function(){return""},rangeSeparator:" — ",weekAbbreviation:"Нед.",scrollTitle:"Прокрутите для увеличения",toggleTitle:"Нажмите для переключения",amPM:["ДП","ПП"],yearAriaLabel:"Год"};yn.l10ns.ru=Sn,yn.l10ns;var Mn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Dn={weekdays:{shorthand:["ඉ","ස","අ","බ","බ්‍ර","සි","සෙ"],longhand:["ඉරිදා","සඳුදා","අඟහරුවාදා","බදාදා","බ්‍රහස්පතින්දා","සිකුරාදා","සෙනසුරාදා"]},months:{shorthand:["ජන","පෙබ","මාර්","අප්‍රේ","මැයි","ජුනි","ජූලි","අගෝ","සැප්","ඔක්","නොවැ","දෙසැ"],longhand:["ජනවාරි","පෙබරවාරි","මාර්තු","අප්‍රේල්","මැයි","ජුනි","ජූලි","අගෝස්තු","සැප්තැම්බර්","ඔක්තෝබර්","නොවැම්බර්","දෙසැම්බර්"]}};Mn.l10ns.si=Dn,Mn.l10ns;var Jn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Tn={weekdays:{shorthand:["Ned","Pon","Ut","Str","Štv","Pia","Sob"],longhand:["Nedeľa","Pondelok","Utorok","Streda","Štvrtok","Piatok","Sobota"]},months:{shorthand:["Jan","Feb","Mar","Apr","Máj","Jún","Júl","Aug","Sep","Okt","Nov","Dec"],longhand:["Január","Február","Marec","Apríl","Máj","Jún","Júl","August","September","Október","November","December"]},firstDayOfWeek:1,rangeSeparator:" do ",ordinal:function(){return"."}};Jn.l10ns.sk=Tn,Jn.l10ns;var An="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},On={weekdays:{shorthand:["Ned","Pon","Tor","Sre","Čet","Pet","Sob"],longhand:["Nedelja","Ponedeljek","Torek","Sreda","Četrtek","Petek","Sobota"]},months:{shorthand:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Avg","Sep","Okt","Nov","Dec"],longhand:["Januar","Februar","Marec","April","Maj","Junij","Julij","Avgust","September","Oktober","November","December"]},firstDayOfWeek:1,rangeSeparator:" do ",ordinal:function(){return"."}};An.l10ns.sl=On,An.l10ns;var jn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Pn={weekdays:{shorthand:["Di","Hë","Ma","Më","En","Pr","Sh"],longhand:["E Diel","E Hënë","E Martë","E Mërkurë","E Enjte","E Premte","E Shtunë"]},months:{shorthand:["Jan","Shk","Mar","Pri","Maj","Qer","Kor","Gus","Sht","Tet","Nën","Dhj"],longhand:["Janar","Shkurt","Mars","Prill","Maj","Qershor","Korrik","Gusht","Shtator","Tetor","Nëntor","Dhjetor"]}};jn.l10ns.sq=Pn,jn.l10ns;var Nn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},zn={weekdays:{shorthand:["Ned","Pon","Uto","Sre","Čet","Pet","Sub"],longhand:["Nedelja","Ponedeljak","Utorak","Sreda","Četvrtak","Petak","Subota"]},months:{shorthand:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Avg","Sep","Okt","Nov","Dec"],longhand:["Januar","Februar","Mart","April","Maj","Jun","Jul","Avgust","Septembar","Oktobar","Novembar","Decembar"]},firstDayOfWeek:1,weekAbbreviation:"Ned.",rangeSeparator:" do "};Nn.l10ns.sr=zn,Nn.l10ns;var Fn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Wn={firstDayOfWeek:1,weekAbbreviation:"v",weekdays:{shorthand:["Sön","Mån","Tis","Ons","Tor","Fre","Lör"],longhand:["Söndag","Måndag","Tisdag","Onsdag","Torsdag","Fredag","Lördag"]},months:{shorthand:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],longhand:["Januari","Februari","Mars","April","Maj","Juni","Juli","Augusti","September","Oktober","November","December"]},ordinal:function(){return"."}};Fn.l10ns.sv=Wn,Fn.l10ns;var Ln="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Kn={weekdays:{shorthand:["อา","จ","อ","พ","พฤ","ศ","ส"],longhand:["อาทิตย์","จันทร์","อังคาร","พุธ","พฤหัสบดี","ศุกร์","เสาร์"]},months:{shorthand:["ม.ค.","ก.พ.","มี.ค.","เม.ย.","พ.ค.","มิ.ย.","ก.ค.","ส.ค.","ก.ย.","ต.ค.","พ.ย.","ธ.ค."],longhand:["มกราคม","กุมภาพันธ์","มีนาคม","เมษายน","พฤษภาคม","มิถุนายน","กรกฎาคม","สิงหาคม","กันยายน","ตุลาคม","พฤศจิกายน","ธันวาคม"]},firstDayOfWeek:1,rangeSeparator:" ถึง ",scrollTitle:"เลื่อนเพื่อเพิ่มหรือลด",toggleTitle:"คลิกเพื่อเปลี่ยน",ordinal:function(){return""}};Ln.l10ns.th=Kn,Ln.l10ns;var En="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Gn={weekdays:{shorthand:["Paz","Pzt","Sal","Çar","Per","Cum","Cmt"],longhand:["Pazar","Pazartesi","Salı","Çarşamba","Perşembe","Cuma","Cumartesi"]},months:{shorthand:["Oca","Şub","Mar","Nis","May","Haz","Tem","Ağu","Eyl","Eki","Kas","Ara"],longhand:["Ocak","Şubat","Mart","Nisan","Mayıs","Haziran","Temmuz","Ağustos","Eylül","Ekim","Kasım","Aralık"]},firstDayOfWeek:1,ordinal:function(){return"."},rangeSeparator:" - ",weekAbbreviation:"Hf",scrollTitle:"Artırmak için kaydırın",toggleTitle:"Aç/Kapa",amPM:["ÖÖ","ÖS"]};En.l10ns.tr=Gn,En.l10ns;var Cn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Rn={firstDayOfWeek:1,weekdays:{shorthand:["Нд","Пн","Вт","Ср","Чт","Пт","Сб"],longhand:["Неділя","Понеділок","Вівторок","Середа","Четвер","П'ятниця","Субота"]},months:{shorthand:["Січ","Лют","Бер","Кві","Тра","Чер","Лип","Сер","Вер","Жов","Лис","Гру"],longhand:["Січень","Лютий","Березень","Квітень","Травень","Червень","Липень","Серпень","Вересень","Жовтень","Листопад","Грудень"]}};Cn.l10ns.uk=Rn,Cn.l10ns;var Vn="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Hn={weekdays:{shorthand:["CN","T2","T3","T4","T5","T6","T7"],longhand:["Chủ nhật","Thứ hai","Thứ ba","Thứ tư","Thứ năm","Thứ sáu","Thứ bảy"]},months:{shorthand:["Th1","Th2","Th3","Th4","Th5","Th6","Th7","Th8","Th9","Th10","Th11","Th12"],longhand:["Tháng một","Tháng hai","Tháng ba","Tháng tư","Tháng năm","Tháng sáu","Tháng bảy","Tháng tám","Tháng chín","Tháng mười","Tháng 11","Tháng 12"]},firstDayOfWeek:1};Vn.l10ns.vn=Hn,Vn.l10ns;var In="undefined"!=typeof window&&void 0!==window.flatpickr?window.flatpickr:{l10ns:{}},Un={weekdays:{shorthand:["周日","周一","周二","周三","周四","周五","周六"],longhand:["星期日","星期一","星期二","星期三","星期四","星期五","星期六"]},months:{shorthand:["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],longhand:["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"]},rangeSeparator:" 至 ",weekAbbreviation:"周",scrollTitle:"滚动切换",toggleTitle:"点击切换 12/24 小时时制"};In.l10ns.zh=Un,In.l10ns;var xn={ar:a,at:o,be:t,bg:l,bn:u,cat:w,cs:k,cy:g,da:b,de:m,default:Object.assign({},y),en:y,eo:M,es:J,et:A,fa:j,fi:N,fr:F,gr:L,he:E,hi:C,hr:V,hu:I,id:x,it:Q,ja:q,ko:Y,lt:$,lv:en,mk:rn,mn:tn,ms:{weekdays:{shorthand:["Min","Isn","Sel","Rab","Kha","Jum","Sab"],longhand:["Minggu","Isnin","Selasa","Rabu","Khamis","Jumaat","Sabtu"]},months:{shorthand:["Jan","Feb","Mac","Apr","Mei","Jun","Jul","Ogo","Sep","Okt","Nov","Dis"],longhand:["Januari","Februari","Mac","April","Mei","Jun","Julai","Ogos","September","Oktober","November","Disember"]},firstDayOfWeek:1,ordinal:function(){return""}},my:ln,nl:un,no:wn,pa:kn,pl:gn,pt:bn,ro:mn,ru:Sn,si:Dn,sk:Tn,sl:On,sq:Pn,sr:zn,sv:Wn,th:Kn,tr:Gn,uk:Rn,vn:Hn,zh:Un};n.default=xn,Object.defineProperty(n,"__esModule",{value:!0})});
-
-},{}],4:[function(require,module,exports){
-!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){"use strict";var n=[],r=e.document,i=Object.getPrototypeOf,o=n.slice,a=n.concat,s=n.push,u=n.indexOf,l={},c=l.toString,f=l.hasOwnProperty,p=f.toString,d=p.call(Object),h={},g=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},v=function(e){return null!=e&&e===e.window},y={type:!0,src:!0,noModule:!0};function m(e,t,n){var i,o=(t=t||r).createElement("script");if(o.text=e,n)for(i in y)n[i]&&(o[i]=n[i]);t.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[c.call(e)]||"object":typeof e}var b=function(e,t){return new b.fn.init(e,t)},w=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function T(e){var t=!!e&&"length"in e&&e.length,n=x(e);return!g(e)&&!v(e)&&("array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e)}b.fn=b.prototype={jquery:"3.3.1",constructor:b,length:0,toArray:function(){return o.call(this)},get:function(e){return null==e?o.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=b.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return b.each(this,e)},map:function(e){return this.pushStack(b.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(o.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(n>=0&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:s,sort:n.sort,splice:n.splice},b.extend=b.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||g(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)n=a[t],a!==(r=e[t])&&(l&&r&&(b.isPlainObject(r)||(i=Array.isArray(r)))?(i?(i=!1,o=n&&Array.isArray(n)?n:[]):o=n&&b.isPlainObject(n)?n:{},a[t]=b.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},b.extend({expando:"jQuery"+("3.3.1"+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==c.call(e))&&(!(t=i(e))||"function"==typeof(n=f.call(t,"constructor")&&t.constructor)&&p.call(n)===d)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e){m(e)},each:function(e,t){var n,r=0;if(T(e))for(n=e.length;r<n&&!1!==t.call(e[r],r,e[r]);r++);else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(w,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(T(Object(e))?b.merge(n,"string"==typeof e?[e]:e):s.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:u.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,s=[];if(T(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&s.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&s.push(i);return a.apply([],s)},guid:1,support:h}),"function"==typeof Symbol&&(b.fn[Symbol.iterator]=n[Symbol.iterator]),b.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});var C=function(e){var t,n,r,i,o,a,s,u,l,c,f,p,d,h,g,v,y,m,x,b="sizzle"+1*new Date,w=e.document,T=0,C=0,E=ae(),k=ae(),S=ae(),D=function(e,t){return e===t&&(f=!0),0},N={}.hasOwnProperty,A=[],j=A.pop,q=A.push,L=A.push,H=A.slice,O=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},P="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",I="\\["+M+"*("+R+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+R+"))|)"+M+"*\\]",W=":("+R+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+I+")*)|.*)\\)|)",$=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),F=new RegExp("^"+M+"*,"+M+"*"),_=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),z=new RegExp("="+M+"*([^\\]'\"]*?)"+M+"*\\]","g"),X=new RegExp(W),U=new RegExp("^"+R+"$"),V={ID:new RegExp("^#("+R+")"),CLASS:new RegExp("^\\.("+R+")"),TAG:new RegExp("^("+R+"|[*])"),ATTR:new RegExp("^"+I),PSEUDO:new RegExp("^"+W),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+P+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},G=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Q=/^[^{]+\{\s*\[native \w/,J=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,K=/[+~]/,Z=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ee=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},te=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ne=function(e,t){return t?"\0"===e?"�":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},re=function(){p()},ie=me(function(e){return!0===e.disabled&&("form"in e||"label"in e)},{dir:"parentNode",next:"legend"});try{L.apply(A=H.call(w.childNodes),w.childNodes),A[w.childNodes.length].nodeType}catch(e){L={apply:A.length?function(e,t){q.apply(e,H.call(t))}:function(e,t){for(var n=e.length,r=0;e[n++]=t[r++];);e.length=n-1}}}function oe(e,t,r,i){var o,s,l,c,f,h,y,m=t&&t.ownerDocument,T=t?t.nodeType:9;if(r=r||[],"string"!=typeof e||!e||1!==T&&9!==T&&11!==T)return r;if(!i&&((t?t.ownerDocument||t:w)!==d&&p(t),t=t||d,g)){if(11!==T&&(f=J.exec(e)))if(o=f[1]){if(9===T){if(!(l=t.getElementById(o)))return r;if(l.id===o)return r.push(l),r}else if(m&&(l=m.getElementById(o))&&x(t,l)&&l.id===o)return r.push(l),r}else{if(f[2])return L.apply(r,t.getElementsByTagName(e)),r;if((o=f[3])&&n.getElementsByClassName&&t.getElementsByClassName)return L.apply(r,t.getElementsByClassName(o)),r}if(n.qsa&&!S[e+" "]&&(!v||!v.test(e))){if(1!==T)m=t,y=e;else if("object"!==t.nodeName.toLowerCase()){for((c=t.getAttribute("id"))?c=c.replace(te,ne):t.setAttribute("id",c=b),s=(h=a(e)).length;s--;)h[s]="#"+c+" "+ye(h[s]);y=h.join(","),m=K.test(e)&&ge(t.parentNode)||t}if(y)try{return L.apply(r,m.querySelectorAll(y)),r}catch(e){}finally{c===b&&t.removeAttribute("id")}}}return u(e.replace(B,"$1"),t,r,i)}function ae(){var e=[];return function t(n,i){return e.push(n+" ")>r.cacheLength&&delete t[e.shift()],t[n+" "]=i}}function se(e){return e[b]=!0,e}function ue(e){var t=d.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function le(e,t){for(var n=e.split("|"),i=n.length;i--;)r.attrHandle[n[i]]=t}function ce(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)for(;n=n.nextSibling;)if(n===t)return-1;return e?1:-1}function fe(e){return function(t){return"input"===t.nodeName.toLowerCase()&&t.type===e}}function pe(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function de(e){return function(t){return"form"in t?t.parentNode&&!1===t.disabled?"label"in t?"label"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&ie(t)===e:t.disabled===e:"label"in t&&t.disabled===e}}function he(e){return se(function(t){return t=+t,se(function(n,r){for(var i,o=e([],n.length,t),a=o.length;a--;)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}function ge(e){return e&&void 0!==e.getElementsByTagName&&e}for(t in n=oe.support={},o=oe.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return!!t&&"HTML"!==t.nodeName},p=oe.setDocument=function(e){var t,i,a=e?e.ownerDocument||e:w;return a!==d&&9===a.nodeType&&a.documentElement?(h=(d=a).documentElement,g=!o(d),w!==d&&(i=d.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener("unload",re,!1):i.attachEvent&&i.attachEvent("onunload",re)),n.attributes=ue(function(e){return e.className="i",!e.getAttribute("className")}),n.getElementsByTagName=ue(function(e){return e.appendChild(d.createComment("")),!e.getElementsByTagName("*").length}),n.getElementsByClassName=Q.test(d.getElementsByClassName),n.getById=ue(function(e){return h.appendChild(e).id=b,!d.getElementsByName||!d.getElementsByName(b).length}),n.getById?(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){return e.getAttribute("id")===t}},r.find.ID=function(e,t){if(void 0!==t.getElementById&&g){var n=t.getElementById(e);return n?[n]:[]}}):(r.filter.ID=function(e){var t=e.replace(Z,ee);return function(e){var n=void 0!==e.getAttributeNode&&e.getAttributeNode("id");return n&&n.value===t}},r.find.ID=function(e,t){if(void 0!==t.getElementById&&g){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];for(i=t.getElementsByName(e),r=0;o=i[r++];)if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),r.find.TAG=n.getElementsByTagName?function(e,t){return void 0!==t.getElementsByTagName?t.getElementsByTagName(e):n.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i++];)1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=n.getElementsByClassName&&function(e,t){if(void 0!==t.getElementsByClassName&&g)return t.getElementsByClassName(e)},y=[],v=[],(n.qsa=Q.test(d.querySelectorAll))&&(ue(function(e){h.appendChild(e).innerHTML="<a id='"+b+"'></a><select id='"+b+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+P+")"),e.querySelectorAll("[id~="+b+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+b+"+*").length||v.push(".#.+[+~]")}),ue(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=d.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),h.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(n.matchesSelector=Q.test(m=h.matches||h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&ue(function(e){n.disconnectedMatch=m.call(e,"*"),m.call(e,"[s!='']:x"),y.push("!=",W)}),v=v.length&&new RegExp(v.join("|")),y=y.length&&new RegExp(y.join("|")),t=Q.test(h.compareDocumentPosition),x=t||Q.test(h.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return f=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r||(1&(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!n.sortDetached&&t.compareDocumentPosition(e)===r?e===d||e.ownerDocument===w&&x(w,e)?-1:t===d||t.ownerDocument===w&&x(w,t)?1:c?O(c,e)-O(c,t):0:4&r?-1:1)}:function(e,t){if(e===t)return f=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===d?-1:t===d?1:i?-1:o?1:c?O(c,e)-O(c,t):0;if(i===o)return ce(e,t);for(n=e;n=n.parentNode;)a.unshift(n);for(n=t;n=n.parentNode;)s.unshift(n);for(;a[r]===s[r];)r++;return r?ce(a[r],s[r]):a[r]===w?-1:s[r]===w?1:0},d):d},oe.matches=function(e,t){return oe(e,null,null,t)},oe.matchesSelector=function(e,t){if((e.ownerDocument||e)!==d&&p(e),t=t.replace(z,"='$1']"),n.matchesSelector&&g&&!S[t+" "]&&(!y||!y.test(t))&&(!v||!v.test(t)))try{var r=m.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){}return oe(t,d,null,[e]).length>0},oe.contains=function(e,t){return(e.ownerDocument||e)!==d&&p(e),x(e,t)},oe.attr=function(e,t){(e.ownerDocument||e)!==d&&p(e);var i=r.attrHandle[t.toLowerCase()],o=i&&N.call(r.attrHandle,t.toLowerCase())?i(e,t,!g):void 0;return void 0!==o?o:n.attributes||!g?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null},oe.escape=function(e){return(e+"").replace(te,ne)},oe.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},oe.uniqueSort=function(e){var t,r=[],i=0,o=0;if(f=!n.detectDuplicates,c=!n.sortStable&&e.slice(0),e.sort(D),f){for(;t=e[o++];)t===e[o]&&(i=r.push(o));for(;i--;)e.splice(r[i],1)}return c=null,e},i=oe.getText=function(e){var t,n="",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e)}else if(3===o||4===o)return e.nodeValue}else for(;t=e[r++];)n+=i(t);return n},(r=oe.selectors={cacheLength:50,createPseudo:se,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(Z,ee),e[3]=(e[3]||e[4]||e[5]||"").replace(Z,ee),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||oe.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&oe.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return V.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=a(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(Z,ee).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=E[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&E(e,function(e){return t.test("string"==typeof e.className&&e.className||void 0!==e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=oe.attr(r,e);return null==i?"!="===t:!t||(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i.replace($," ")+" ").indexOf(n)>-1:"|="===t&&(i===n||i.slice(0,n.length+1)===n+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==a?"nextSibling":"previousSibling",v=t.parentNode,y=s&&t.nodeName.toLowerCase(),m=!u&&!s,x=!1;if(v){if(o){for(;g;){for(p=t;p=p[g];)if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?v.firstChild:v.lastChild],a&&m){for(x=(d=(l=(c=(f=(p=v)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1])&&l[2],p=d&&v.childNodes[d];p=++d&&p&&p[g]||(x=d=0)||h.pop();)if(1===p.nodeType&&++x&&p===t){c[e]=[T,d,x];break}}else if(m&&(x=d=(l=(c=(f=(p=t)[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]||[])[0]===T&&l[1]),!1===x)for(;(p=++d&&p&&p[g]||(x=d=0)||h.pop())&&((s?p.nodeName.toLowerCase()!==y:1!==p.nodeType)||!++x||(m&&((c=(f=p[b]||(p[b]={}))[p.uniqueID]||(f[p.uniqueID]={}))[e]=[T,x]),p!==t)););return(x-=i)===r||x%r==0&&x/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||oe.error("unsupported pseudo: "+e);return i[b]?i(t):i.length>1?(n=[e,e,"",t],r.setFilters.hasOwnProperty(e.toLowerCase())?se(function(e,n){for(var r,o=i(e,t),a=o.length;a--;)e[r=O(e,o[a])]=!(n[r]=o[a])}):function(e){return i(e,0,n)}):i}},pseudos:{not:se(function(e){var t=[],n=[],r=s(e.replace(B,"$1"));return r[b]?se(function(e,t,n,i){for(var o,a=r(e,null,i,[]),s=e.length;s--;)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:se(function(e){return function(t){return oe(e,t).length>0}}),contains:se(function(e){return e=e.replace(Z,ee),function(t){return(t.textContent||t.innerText||i(t)).indexOf(e)>-1}}),lang:se(function(e){return U.test(e||"")||oe.error("unsupported lang: "+e),e=e.replace(Z,ee).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return(n=n.toLowerCase())===e||0===n.indexOf(e+"-")}while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===d.activeElement&&(!d.hasFocus||d.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:de(!1),disabled:de(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!r.pseudos.empty(e)},header:function(e){return Y.test(e.nodeName)},input:function(e){return G.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:he(function(){return[0]}),last:he(function(e,t){return[t-1]}),eq:he(function(e,t,n){return[n<0?n+t:n]}),even:he(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:he(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:he(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:he(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=r.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[t]=fe(t);for(t in{submit:!0,reset:!0})r.pseudos[t]=pe(t);function ve(){}function ye(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function me(e,t,n){var r=t.dir,i=t.next,o=i||r,a=n&&"parentNode"===o,s=C++;return t.first?function(t,n,i){for(;t=t[r];)if(1===t.nodeType||a)return e(t,n,i);return!1}:function(t,n,u){var l,c,f,p=[T,s];if(u){for(;t=t[r];)if((1===t.nodeType||a)&&e(t,n,u))return!0}else for(;t=t[r];)if(1===t.nodeType||a)if(c=(f=t[b]||(t[b]={}))[t.uniqueID]||(f[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else{if((l=c[o])&&l[0]===T&&l[1]===s)return p[2]=l[2];if(c[o]=p,p[2]=e(t,n,u))return!0}return!1}}function xe(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function be(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function we(e,t,n,r,i,o){return r&&!r[b]&&(r=we(r)),i&&!i[b]&&(i=we(i,o)),se(function(o,a,s,u){var l,c,f,p=[],d=[],h=a.length,g=o||function(e,t,n){for(var r=0,i=t.length;r<i;r++)oe(e,t[r],n);return n}(t||"*",s.nodeType?[s]:s,[]),v=!e||!o&&t?g:be(g,p,e,s,u),y=n?i||(o?e:h||r)?[]:a:v;if(n&&n(v,y,s,u),r)for(l=be(y,d),r(l,[],s,u),c=l.length;c--;)(f=l[c])&&(y[d[c]]=!(v[d[c]]=f));if(o){if(i||e){if(i){for(l=[],c=y.length;c--;)(f=y[c])&&l.push(v[c]=f);i(null,y=[],l,u)}for(c=y.length;c--;)(f=y[c])&&(l=i?O(o,f):p[c])>-1&&(o[l]=!(a[l]=f))}}else y=be(y===a?y.splice(h,y.length):y),i?i(null,a,y,u):L.apply(a,y)})}function Te(e){for(var t,n,i,o=e.length,a=r.relative[e[0].type],s=a||r.relative[" "],u=a?1:0,c=me(function(e){return e===t},s,!0),f=me(function(e){return O(t,e)>-1},s,!0),p=[function(e,n,r){var i=!a&&(r||n!==l)||((t=n).nodeType?c(e,n,r):f(e,n,r));return t=null,i}];u<o;u++)if(n=r.relative[e[u].type])p=[me(xe(p),n)];else{if((n=r.filter[e[u].type].apply(null,e[u].matches))[b]){for(i=++u;i<o&&!r.relative[e[i].type];i++);return we(u>1&&xe(p),u>1&&ye(e.slice(0,u-1).concat({value:" "===e[u-2].type?"*":""})).replace(B,"$1"),n,u<i&&Te(e.slice(u,i)),i<o&&Te(e=e.slice(i)),i<o&&ye(e))}p.push(n)}return xe(p)}return ve.prototype=r.filters=r.pseudos,r.setFilters=new ve,a=oe.tokenize=function(e,t){var n,i,o,a,s,u,l,c=k[e+" "];if(c)return t?0:c.slice(0);for(s=e,u=[],l=r.preFilter;s;){for(a in n&&!(i=F.exec(s))||(i&&(s=s.slice(i[0].length)||s),u.push(o=[])),n=!1,(i=_.exec(s))&&(n=i.shift(),o.push({value:n,type:i[0].replace(B," ")}),s=s.slice(n.length)),r.filter)!(i=V[a].exec(s))||l[a]&&!(i=l[a](i))||(n=i.shift(),o.push({value:n,type:a,matches:i}),s=s.slice(n.length));if(!n)break}return t?s.length:s?oe.error(e):k(e,u).slice(0)},s=oe.compile=function(e,t){var n,i=[],o=[],s=S[e+" "];if(!s){for(t||(t=a(e)),n=t.length;n--;)(s=Te(t[n]))[b]?i.push(s):o.push(s);(s=S(e,function(e,t){var n=t.length>0,i=e.length>0,o=function(o,a,s,u,c){var f,h,v,y=0,m="0",x=o&&[],b=[],w=l,C=o||i&&r.find.TAG("*",c),E=T+=null==w?1:Math.random()||.1,k=C.length;for(c&&(l=a===d||a||c);m!==k&&null!=(f=C[m]);m++){if(i&&f){for(h=0,a||f.ownerDocument===d||(p(f),s=!g);v=e[h++];)if(v(f,a||d,s)){u.push(f);break}c&&(T=E)}n&&((f=!v&&f)&&y--,o&&x.push(f))}if(y+=m,n&&m!==y){for(h=0;v=t[h++];)v(x,b,a,s);if(o){if(y>0)for(;m--;)x[m]||b[m]||(b[m]=j.call(u));b=be(b)}L.apply(u,b),c&&!o&&b.length>0&&y+t.length>1&&oe.uniqueSort(u)}return c&&(T=E,l=w),x};return n?se(o):o}(o,i))).selector=e}return s},u=oe.select=function(e,t,n,i){var o,u,l,c,f,p="function"==typeof e&&e,d=!i&&a(e=p.selector||e);if(n=n||[],1===d.length){if((u=d[0]=d[0].slice(0)).length>2&&"ID"===(l=u[0]).type&&9===t.nodeType&&g&&r.relative[u[1].type]){if(!(t=(r.find.ID(l.matches[0].replace(Z,ee),t)||[])[0]))return n;p&&(t=t.parentNode),e=e.slice(u.shift().value.length)}for(o=V.needsContext.test(e)?0:u.length;o--&&(l=u[o],!r.relative[c=l.type]);)if((f=r.find[c])&&(i=f(l.matches[0].replace(Z,ee),K.test(u[0].type)&&ge(t.parentNode)||t))){if(u.splice(o,1),!(e=i.length&&ye(u)))return L.apply(n,i),n;break}}return(p||s(e,d))(i,t,!g,n,!t||K.test(e)&&ge(t.parentNode)||t),n},n.sortStable=b.split("").sort(D).join("")===b,n.detectDuplicates=!!f,p(),n.sortDetached=ue(function(e){return 1&e.compareDocumentPosition(d.createElement("fieldset"))}),ue(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||le("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),n.attributes&&ue(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||le("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ue(function(e){return null==e.getAttribute("disabled")})||le(P,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),oe}(e);b.find=C,b.expr=C.selectors,b.expr[":"]=b.expr.pseudos,b.uniqueSort=b.unique=C.uniqueSort,b.text=C.getText,b.isXMLDoc=C.isXML,b.contains=C.contains,b.escapeSelector=C.escape;var E=function(e,t,n){for(var r=[],i=void 0!==n;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&b(e).is(n))break;r.push(e)}return r},k=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},S=b.expr.match.needsContext;function D(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var N=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function A(e,t,n){return g(t)?b.grep(e,function(e,r){return!!t.call(e,r,e)!==n}):t.nodeType?b.grep(e,function(e){return e===t!==n}):"string"!=typeof t?b.grep(e,function(e){return u.call(t,e)>-1!==n}):b.filter(t,e,n)}b.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?b.find.matchesSelector(r,e)?[r]:[]:b.find.matches(e,b.grep(t,function(e){return 1===e.nodeType}))},b.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(b(e).filter(function(){for(t=0;t<r;t++)if(b.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)b.find(e,i[t],n);return r>1?b.uniqueSort(n):n},filter:function(e){return this.pushStack(A(this,e||[],!1))},not:function(e){return this.pushStack(A(this,e||[],!0))},is:function(e){return!!A(this,"string"==typeof e&&S.test(e)?b(e):e||[],!1).length}});var j,q=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(b.fn.init=function(e,t,n){var i,o;if(!e)return this;if(n=n||j,"string"==typeof e){if(!(i="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:q.exec(e))||!i[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(i[1]){if(t=t instanceof b?t[0]:t,b.merge(this,b.parseHTML(i[1],t&&t.nodeType?t.ownerDocument||t:r,!0)),N.test(i[1])&&b.isPlainObject(t))for(i in t)g(this[i])?this[i](t[i]):this.attr(i,t[i]);return this}return(o=r.getElementById(i[2]))&&(this[0]=o,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):g(e)?void 0!==n.ready?n.ready(e):e(b):b.makeArray(e,this)}).prototype=b.fn,j=b(r);var L=/^(?:parents|prev(?:Until|All))/,H={children:!0,contents:!0,next:!0,prev:!0};function O(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}b.fn.extend({has:function(e){var t=b(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(b.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&b(e);if(!S.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?a.index(n)>-1:1===n.nodeType&&b.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?b.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?u.call(b(e),this[0]):u.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(b.uniqueSort(b.merge(this.get(),b(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),b.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return E(e,"parentNode")},parentsUntil:function(e,t,n){return E(e,"parentNode",n)},next:function(e){return O(e,"nextSibling")},prev:function(e){return O(e,"previousSibling")},nextAll:function(e){return E(e,"nextSibling")},prevAll:function(e){return E(e,"previousSibling")},nextUntil:function(e,t,n){return E(e,"nextSibling",n)},prevUntil:function(e,t,n){return E(e,"previousSibling",n)},siblings:function(e){return k((e.parentNode||{}).firstChild,e)},children:function(e){return k(e.firstChild)},contents:function(e){return D(e,"iframe")?e.contentDocument:(D(e,"template")&&(e=e.content||e),b.merge([],e.childNodes))}},function(e,t){b.fn[e]=function(n,r){var i=b.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=b.filter(r,i)),this.length>1&&(H[e]||b.uniqueSort(i),L.test(e)&&i.reverse()),this.pushStack(i)}});var P=/[^\x20\t\r\n\f]+/g;function M(e){return e}function R(e){throw e}function I(e,t,n,r){var i;try{e&&g(i=e.promise)?i.call(e).done(t).fail(n):e&&g(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}b.Callbacks=function(e){e="string"==typeof e?function(e){var t={};return b.each(e.match(P)||[],function(e,n){t[n]=!0}),t}(e):b.extend({},e);var t,n,r,i,o=[],a=[],s=-1,u=function(){for(i=i||e.once,r=t=!0;a.length;s=-1)for(n=a.shift();++s<o.length;)!1===o[s].apply(n[0],n[1])&&e.stopOnFalse&&(s=o.length,n=!1);e.memory||(n=!1),t=!1,i&&(o=n?[]:"")},l={add:function(){return o&&(n&&!t&&(s=o.length-1,a.push(n)),function t(n){b.each(n,function(n,r){g(r)?e.unique&&l.has(r)||o.push(r):r&&r.length&&"string"!==x(r)&&t(r)})}(arguments),n&&!t&&u()),this},remove:function(){return b.each(arguments,function(e,t){for(var n;(n=b.inArray(t,o,n))>-1;)o.splice(n,1),n<=s&&s--}),this},has:function(e){return e?b.inArray(e,o)>-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return i=a=[],o=n="",this},disabled:function(){return!o},lock:function(){return i=a=[],n||t||(o=n=""),this},locked:function(){return!!i},fireWith:function(e,n){return i||(n=[e,(n=n||[]).slice?n.slice():n],a.push(n),t||u()),this},fire:function(){return l.fireWith(this,arguments),this},fired:function(){return!!r}};return l},b.extend({Deferred:function(t){var n=[["notify","progress",b.Callbacks("memory"),b.Callbacks("memory"),2],["resolve","done",b.Callbacks("once memory"),b.Callbacks("once memory"),0,"resolved"],["reject","fail",b.Callbacks("once memory"),b.Callbacks("once memory"),1,"rejected"]],r="pending",i={state:function(){return r},always:function(){return o.done(arguments).fail(arguments),this},catch:function(e){return i.then(null,e)},pipe:function(){var e=arguments;return b.Deferred(function(t){b.each(n,function(n,r){var i=g(e[r[4]])&&e[r[4]];o[r[1]](function(){var e=i&&i.apply(this,arguments);e&&g(e.promise)?e.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[r[0]+"With"](this,i?[e]:arguments)})}),e=null}).promise()},then:function(t,r,i){var o=0;function a(t,n,r,i){return function(){var s=this,u=arguments,l=function(){var e,l;if(!(t<o)){if((e=r.apply(s,u))===n.promise())throw new TypeError("Thenable self-resolution");l=e&&("object"==typeof e||"function"==typeof e)&&e.then,g(l)?i?l.call(e,a(o,n,M,i),a(o,n,R,i)):(o++,l.call(e,a(o,n,M,i),a(o,n,R,i),a(o,n,M,n.notifyWith))):(r!==M&&(s=void 0,u=[e]),(i||n.resolveWith)(s,u))}},c=i?l:function(){try{l()}catch(e){b.Deferred.exceptionHook&&b.Deferred.exceptionHook(e,c.stackTrace),t+1>=o&&(r!==R&&(s=void 0,u=[e]),n.rejectWith(s,u))}};t?c():(b.Deferred.getStackHook&&(c.stackTrace=b.Deferred.getStackHook()),e.setTimeout(c))}}return b.Deferred(function(e){n[0][3].add(a(0,e,g(i)?i:M,e.notifyWith)),n[1][3].add(a(0,e,g(t)?t:M)),n[2][3].add(a(0,e,g(r)?r:R))}).promise()},promise:function(e){return null!=e?b.extend(e,i):i}},o={};return b.each(n,function(e,t){var a=t[2],s=t[5];i[t[1]]=a.add,s&&a.add(function(){r=s},n[3-e][2].disable,n[3-e][3].disable,n[0][2].lock,n[0][3].lock),a.add(t[3].fire),o[t[0]]=function(){return o[t[0]+"With"](this===o?void 0:this,arguments),this},o[t[0]+"With"]=a.fireWith}),i.promise(o),t&&t.call(o,o),o},when:function(e){var t=arguments.length,n=t,r=Array(n),i=o.call(arguments),a=b.Deferred(),s=function(e){return function(n){r[e]=this,i[e]=arguments.length>1?o.call(arguments):n,--t||a.resolveWith(r,i)}};if(t<=1&&(I(e,a.done(s(n)).resolve,a.reject,!t),"pending"===a.state()||g(i[n]&&i[n].then)))return a.then();for(;n--;)I(i[n],s(n),a.reject);return a.promise()}});var W=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;b.Deferred.exceptionHook=function(t,n){e.console&&e.console.warn&&t&&W.test(t.name)&&e.console.warn("jQuery.Deferred exception: "+t.message,t.stack,n)},b.readyException=function(t){e.setTimeout(function(){throw t})};var $=b.Deferred();function B(){r.removeEventListener("DOMContentLoaded",B),e.removeEventListener("load",B),b.ready()}b.fn.ready=function(e){return $.then(e).catch(function(e){b.readyException(e)}),this},b.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--b.readyWait:b.isReady)||(b.isReady=!0,!0!==e&&--b.readyWait>0||$.resolveWith(r,[b]))}}),b.ready.then=$.then,"complete"===r.readyState||"loading"!==r.readyState&&!r.documentElement.doScroll?e.setTimeout(b.ready):(r.addEventListener("DOMContentLoaded",B),e.addEventListener("load",B));var F=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===x(n))for(s in i=!0,n)F(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,g(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(b(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},_=/^-ms-/,z=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function U(e){return e.replace(_,"ms-").replace(z,X)}var V=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function G(){this.expando=b.expando+G.uid++}G.uid=1,G.prototype={cache:function(e){var t=e[this.expando];return t||(t={},V(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[U(t)]=n;else for(r in t)i[U(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][U(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(U):(t=U(t))in r?[t]:t.match(P)||[]).length;for(;n--;)delete r[t[n]]}(void 0===t||b.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!b.isEmptyObject(t)}};var Y=new G,Q=new G,J=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,K=/[A-Z]/g;function Z(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(K,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n=function(e){return"true"===e||"false"!==e&&("null"===e?null:e===+e+""?+e:J.test(e)?JSON.parse(e):e)}(n)}catch(e){}Q.set(e,t,n)}else n=void 0;return n}b.extend({hasData:function(e){return Q.hasData(e)||Y.hasData(e)},data:function(e,t,n){return Q.access(e,t,n)},removeData:function(e,t){Q.remove(e,t)},_data:function(e,t,n){return Y.access(e,t,n)},_removeData:function(e,t){Y.remove(e,t)}}),b.fn.extend({data:function(e,t){var n,r,i,o=this[0],a=o&&o.attributes;if(void 0===e){if(this.length&&(i=Q.get(o),1===o.nodeType&&!Y.get(o,"hasDataAttrs"))){for(n=a.length;n--;)a[n]&&0===(r=a[n].name).indexOf("data-")&&(r=U(r.slice(5)),Z(o,r,i[r]));Y.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){Q.set(this,e)}):F(this,function(t){var n;if(o&&void 0===t)return void 0!==(n=Q.get(o,e))?n:void 0!==(n=Z(o,e))?n:void 0;this.each(function(){Q.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){Q.remove(this,e)})}}),b.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Y.get(e,t),n&&(!r||Array.isArray(n)?r=Y.access(e,t,b.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=b.queue(e,t),r=n.length,i=n.shift(),o=b._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){b.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Y.get(e,n)||Y.access(e,n,{empty:b.Callbacks("once memory").add(function(){Y.remove(e,[t+"queue",n])})})}}),b.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?b.queue(this[0],e):void 0===t?this:this.each(function(){var n=b.queue(this,e,t);b._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&b.dequeue(this,e)})},dequeue:function(e){return this.each(function(){b.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=b.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";a--;)(n=Y.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var ee=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,te=new RegExp("^(?:([+-])=|)("+ee+")([a-z%]*)$","i"),ne=["Top","Right","Bottom","Left"],re=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&b.contains(e.ownerDocument,e)&&"none"===b.css(e,"display")},ie=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function oe(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return b.css(e,t,"")},u=s(),l=n&&n[3]||(b.cssNumber[t]?"":"px"),c=(b.cssNumber[t]||"px"!==l&&+u)&&te.exec(b.css(e,t));if(c&&c[3]!==l){for(u/=2,l=l||c[3],c=+u||1;a--;)b.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,b.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ae={};function se(e){var t,n=e.ownerDocument,r=e.nodeName,i=ae[r];return i||(t=n.body.appendChild(n.createElement(r)),i=b.css(t,"display"),t.parentNode.removeChild(t),"none"===i&&(i="block"),ae[r]=i,i)}function ue(e,t){for(var n,r,i=[],o=0,a=e.length;o<a;o++)(r=e[o]).style&&(n=r.style.display,t?("none"===n&&(i[o]=Y.get(r,"display")||null,i[o]||(r.style.display="")),""===r.style.display&&re(r)&&(i[o]=se(r))):"none"!==n&&(i[o]="none",Y.set(r,"display",n)));for(o=0;o<a;o++)null!=i[o]&&(e[o].style.display=i[o]);return e}b.fn.extend({show:function(){return ue(this,!0)},hide:function(){return ue(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){re(this)?b(this).show():b(this).hide()})}});var le=/^(?:checkbox|radio)$/i,ce=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,fe=/^$|^module$|\/(?:java|ecma)script/i,pe={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function de(e,t){var n;return n=void 0!==e.getElementsByTagName?e.getElementsByTagName(t||"*"):void 0!==e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&D(e,t)?b.merge([e],n):n}function he(e,t){for(var n=0,r=e.length;n<r;n++)Y.set(e[n],"globalEval",!t||Y.get(t[n],"globalEval"))}pe.optgroup=pe.option,pe.tbody=pe.tfoot=pe.colgroup=pe.caption=pe.thead,pe.th=pe.td;var ge,ve,ye=/<|&#?\w+;/;function me(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===x(o))b.merge(p,o.nodeType?[o]:o);else if(ye.test(o)){for(a=a||f.appendChild(t.createElement("div")),s=(ce.exec(o)||["",""])[1].toLowerCase(),u=pe[s]||pe._default,a.innerHTML=u[1]+b.htmlPrefilter(o)+u[2],c=u[0];c--;)a=a.lastChild;b.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));for(f.textContent="",d=0;o=p[d++];)if(r&&b.inArray(o,r)>-1)i&&i.push(o);else if(l=b.contains(o.ownerDocument,o),a=de(f.appendChild(o),"script"),l&&he(a),n)for(c=0;o=a[c++];)fe.test(o.type||"")&&n.push(o);return f}ge=r.createDocumentFragment().appendChild(r.createElement("div")),(ve=r.createElement("input")).setAttribute("type","radio"),ve.setAttribute("checked","checked"),ve.setAttribute("name","t"),ge.appendChild(ve),h.checkClone=ge.cloneNode(!0).cloneNode(!0).lastChild.checked,ge.innerHTML="<textarea>x</textarea>",h.noCloneChecked=!!ge.cloneNode(!0).lastChild.defaultValue;var xe=r.documentElement,be=/^key/,we=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Te=/^([^.]*)(?:\.(.+)|)/;function Ce(){return!0}function Ee(){return!1}function ke(){try{return r.activeElement}catch(e){}}function Se(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Se(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Ee;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return b().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=b.guid++)),e.each(function(){b.event.add(this,t,i,r,n)})}b.event={global:{},add:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.get(e);if(v)for(n.handler&&(n=(o=n).handler,i=o.selector),i&&b.find.matchesSelector(xe,i),n.guid||(n.guid=b.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(t){return void 0!==b&&b.event.triggered!==t.type?b.event.dispatch.apply(e,arguments):void 0}),l=(t=(t||"").match(P)||[""]).length;l--;)d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=b.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=b.event.special[d]||{},c=b.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&b.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(e,r,h,a)||e.addEventListener&&e.addEventListener(d,a)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),b.event.global[d]=!0)},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Y.hasData(e)&&Y.get(e);if(v&&(u=v.events)){for(l=(t=(t||"").match(P)||[""]).length;l--;)if(d=g=(s=Te.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){for(f=b.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;o--;)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||b.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)b.event.remove(e,d+t[l],n,r,!0);b.isEmptyObject(u)&&Y.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=b.event.fix(e),u=new Array(arguments.length),l=(Y.get(this,"events")||{})[s.type]||[],c=b.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){for(a=b.event.handlers.call(this,s,l),t=0;(i=a[t++])&&!s.isPropagationStopped();)for(s.currentTarget=i.elem,n=0;(o=i.handlers[n++])&&!s.isImmediatePropagationStopped();)s.rnamespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((b.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()));return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&e.button>=1))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?b(i,this).index(l)>-1:b.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(e,t){Object.defineProperty(b.Event.prototype,e,{enumerable:!0,configurable:!0,get:g(t)?function(){if(this.originalEvent)return t(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[e]},set:function(t){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:t})}})},fix:function(e){return e[b.expando]?e:new b.Event(e)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ke()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===ke()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&D(this,"input"))return this.click(),!1},_default:function(e){return D(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},b.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},b.Event=function(e,t){if(!(this instanceof b.Event))return new b.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?Ce:Ee,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&b.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[b.expando]=!0},b.Event.prototype={constructor:b.Event,isDefaultPrevented:Ee,isPropagationStopped:Ee,isImmediatePropagationStopped:Ee,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=Ce,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=Ce,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=Ce,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},b.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,char:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&be.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&we.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},b.event.addProp),b.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,t){b.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=e.relatedTarget,i=e.handleObj;return r&&(r===this||b.contains(this,r))||(e.type=i.origType,n=i.handler.apply(this,arguments),e.type=t),n}}}),b.fn.extend({on:function(e,t,n,r){return Se(this,e,t,n,r)},one:function(e,t,n,r){return Se(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,b(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Ee),this.each(function(){b.event.remove(this,e,n,t)})}});var De=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Ne=/<script|<style|<link/i,Ae=/checked\s*(?:[^=]|=\s*.checked.)/i,je=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function qe(e,t){return D(e,"table")&&D(11!==t.nodeType?t:t.firstChild,"tr")&&b(e).children("tbody")[0]||e}function Le(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function He(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Oe(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Y.hasData(e)&&(o=Y.access(e),a=Y.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)b.event.add(t,i,l[i][n]);Q.hasData(e)&&(s=Q.access(e),u=b.extend({},s),Q.set(t,u))}}function Pe(e,t,n,r){t=a.apply([],t);var i,o,s,u,l,c,f=0,p=e.length,d=p-1,v=t[0],y=g(v);if(y||p>1&&"string"==typeof v&&!h.checkClone&&Ae.test(v))return e.each(function(i){var o=e.eq(i);y&&(t[0]=v.call(this,i,o.html())),Pe(o,t,n,r)});if(p&&(o=(i=me(t,e[0].ownerDocument,!1,e,r)).firstChild,1===i.childNodes.length&&(i=o),o||r)){for(u=(s=b.map(de(i,"script"),Le)).length;f<p;f++)l=i,f!==d&&(l=b.clone(l,!0,!0),u&&b.merge(s,de(l,"script"))),n.call(e[f],l,f);if(u)for(c=s[s.length-1].ownerDocument,b.map(s,He),f=0;f<u;f++)l=s[f],fe.test(l.type||"")&&!Y.access(l,"globalEval")&&b.contains(c,l)&&(l.src&&"module"!==(l.type||"").toLowerCase()?b._evalUrl&&b._evalUrl(l.src):m(l.textContent.replace(je,""),c,l))}return e}function Me(e,t,n){for(var r,i=t?b.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||b.cleanData(de(r)),r.parentNode&&(n&&b.contains(r.ownerDocument,r)&&he(de(r,"script")),r.parentNode.removeChild(r));return e}b.extend({htmlPrefilter:function(e){return e.replace(De,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=b.contains(e.ownerDocument,e);if(!(h.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||b.isXMLDoc(e)))for(a=de(c),r=0,i=(o=de(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&le.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||de(e),a=a||de(c),r=0,i=o.length;r<i;r++)Oe(o[r],a[r]);else Oe(e,c);return(a=de(c,"script")).length>0&&he(a,!f&&de(e,"script")),c},cleanData:function(e){for(var t,n,r,i=b.event.special,o=0;void 0!==(n=e[o]);o++)if(V(n)){if(t=n[Y.expando]){if(t.events)for(r in t.events)i[r]?b.event.remove(n,r):b.removeEvent(n,r,t.handle);n[Y.expando]=void 0}n[Q.expando]&&(n[Q.expando]=void 0)}}}),b.fn.extend({detach:function(e){return Me(this,e,!0)},remove:function(e){return Me(this,e)},text:function(e){return F(this,function(e){return void 0===e?b.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Pe(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||qe(this,e).appendChild(e)})},prepend:function(){return Pe(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=qe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Pe(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(b.cleanData(de(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return b.clone(this,e,t)})},html:function(e){return F(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ne.test(e)&&!pe[(ce.exec(e)||["",""])[1].toLowerCase()]){e=b.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(b.cleanData(de(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=[];return Pe(this,arguments,function(t){var n=this.parentNode;b.inArray(this,e)<0&&(b.cleanData(de(this)),n&&n.replaceChild(t,this))},e)}}),b.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){b.fn[e]=function(e){for(var n,r=[],i=b(e),o=i.length-1,a=0;a<=o;a++)n=a===o?this:this.clone(!0),b(i[a])[t](n),s.apply(r,n.get());return this.pushStack(r)}});var Re=new RegExp("^("+ee+")(?!px)[a-z%]+$","i"),Ie=function(t){var n=t.ownerDocument.defaultView;return n&&n.opener||(n=e),n.getComputedStyle(t)},We=new RegExp(ne.join("|"),"i");function $e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Ie(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||b.contains(e.ownerDocument,e)||(a=b.style(e,t)),!h.pixelBoxStyles()&&Re.test(a)&&We.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function Be(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function t(){if(c){l.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",c.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",xe.appendChild(l).appendChild(c);var t=e.getComputedStyle(c);i="1%"!==t.top,u=12===n(t.marginLeft),c.style.right="60%",s=36===n(t.right),o=36===n(t.width),c.style.position="absolute",a=36===c.offsetWidth||"absolute",xe.removeChild(l),c=null}}function n(e){return Math.round(parseFloat(e))}var i,o,a,s,u,l=r.createElement("div"),c=r.createElement("div");c.style&&(c.style.backgroundClip="content-box",c.cloneNode(!0).style.backgroundClip="",h.clearCloneStyle="content-box"===c.style.backgroundClip,b.extend(h,{boxSizingReliable:function(){return t(),o},pixelBoxStyles:function(){return t(),s},pixelPosition:function(){return t(),i},reliableMarginLeft:function(){return t(),u},scrollboxSize:function(){return t(),a}}))}();var Fe=/^(none|table(?!-c[ea]).+)/,_e=/^--/,ze={position:"absolute",visibility:"hidden",display:"block"},Xe={letterSpacing:"0",fontWeight:"400"},Ue=["Webkit","Moz","ms"],Ve=r.createElement("div").style;function Ge(e){var t=b.cssProps[e];return t||(t=b.cssProps[e]=function(e){if(e in Ve)return e;for(var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;n--;)if((e=Ue[n]+t)in Ve)return e}(e)||e),t}function Ye(e,t,n){var r=te.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function Qe(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=b.css(e,n+ne[a],!0,i)),r?("content"===n&&(u-=b.css(e,"padding"+ne[a],!0,i)),"margin"!==n&&(u-=b.css(e,"border"+ne[a]+"Width",!0,i))):(u+=b.css(e,"padding"+ne[a],!0,i),"padding"!==n?u+=b.css(e,"border"+ne[a]+"Width",!0,i):s+=b.css(e,"border"+ne[a]+"Width",!0,i));return!r&&o>=0&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))),u}function Je(e,t,n){var r=Ie(e),i=$e(e,t,r),o="border-box"===b.css(e,"boxSizing",!1,r),a=o;if(Re.test(i)){if(!n)return i;i="auto"}return a=a&&(h.boxSizingReliable()||i===e.style[t]),("auto"===i||!parseFloat(i)&&"inline"===b.css(e,"display",!1,r))&&(i=e["offset"+t[0].toUpperCase()+t.slice(1)],a=!0),(i=parseFloat(i)||0)+Qe(e,t,n||(o?"border":"content"),a,r,i)+"px"}function Ke(e,t,n,r,i){return new Ke.prototype.init(e,t,n,r,i)}b.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=$e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=U(t),u=_e.test(t),l=e.style;if(u||(t=Ge(s)),a=b.cssHooks[t]||b.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=te.exec(n))&&i[1]&&(n=oe(e,t,i),o="number"),null!=n&&n==n&&("number"===o&&(n+=i&&i[3]||(b.cssNumber[s]?"":"px")),h.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=U(t);return _e.test(t)||(t=Ge(s)),(a=b.cssHooks[t]||b.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=$e(e,t,r)),"normal"===i&&t in Xe&&(i=Xe[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),b.each(["height","width"],function(e,t){b.cssHooks[t]={get:function(e,n,r){if(n)return!Fe.test(b.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?Je(e,t,r):ie(e,ze,function(){return Je(e,t,r)})},set:function(e,n,r){var i,o=Ie(e),a="border-box"===b.css(e,"boxSizing",!1,o),s=r&&Qe(e,t,r,a,o);return a&&h.scrollboxSize()===o.position&&(s-=Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-parseFloat(o[t])-Qe(e,t,"border",!1,o)-.5)),s&&(i=te.exec(n))&&"px"!==(i[3]||"px")&&(e.style[t]=n,n=b.css(e,t)),Ye(0,n,s)}}}),b.cssHooks.marginLeft=Be(h.reliableMarginLeft,function(e,t){if(t)return(parseFloat($e(e,"marginLeft"))||e.getBoundingClientRect().left-ie(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),b.each({margin:"",padding:"",border:"Width"},function(e,t){b.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];r<4;r++)i[e+ne[r]+t]=o[r]||o[r-2]||o[0];return i}},"margin"!==e&&(b.cssHooks[e+t].set=Ye)}),b.fn.extend({css:function(e,t){return F(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Ie(e),i=t.length;a<i;a++)o[t[a]]=b.css(e,t[a],!1,r);return o}return void 0!==n?b.style(e,t,n):b.css(e,t)},e,t,arguments.length>1)}}),b.Tween=Ke,Ke.prototype={constructor:Ke,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||b.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(b.cssNumber[n]?"":"px")},cur:function(){var e=Ke.propHooks[this.prop];return e&&e.get?e.get(this):Ke.propHooks._default.get(this)},run:function(e){var t,n=Ke.propHooks[this.prop];return this.options.duration?this.pos=t=b.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Ke.propHooks._default.set(this),this}},Ke.prototype.init.prototype=Ke.prototype,Ke.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=b.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){b.fx.step[e.prop]?b.fx.step[e.prop](e):1!==e.elem.nodeType||null==e.elem.style[b.cssProps[e.prop]]&&!b.cssHooks[e.prop]?e.elem[e.prop]=e.now:b.style(e.elem,e.prop,e.now+e.unit)}}},Ke.propHooks.scrollTop=Ke.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},b.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},b.fx=Ke.prototype.init,b.fx.step={};var Ze,et,tt=/^(?:toggle|show|hide)$/,nt=/queueHooks$/;function rt(){et&&(!1===r.hidden&&e.requestAnimationFrame?e.requestAnimationFrame(rt):e.setTimeout(rt,b.fx.interval),b.fx.tick())}function it(){return e.setTimeout(function(){Ze=void 0}),Ze=Date.now()}function ot(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=ne[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function at(e,t,n){for(var r,i=(st.tweeners[t]||[]).concat(st.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function st(e,t,n){var r,i,o=0,a=st.prefilters.length,s=b.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=Ze||it(),n=Math.max(0,l.startTime+l.duration-t),r=1-(n/l.duration||0),o=0,a=l.tweens.length;o<a;o++)l.tweens[o].run(r);return s.notifyWith(e,[l,r,n]),r<1&&a?n:(a||s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:b.extend({},t),opts:b.extend(!0,{specialEasing:{},easing:b.easing._default},n),originalProperties:t,originalOptions:n,startTime:Ze||it(),duration:n.duration,tweens:[],createTween:function(t,n){var r=b.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;n<r;n++)l.tweens[n].run(1);return t?(s.notifyWith(e,[l,1,0]),s.resolveWith(e,[l,t])):s.rejectWith(e,[l,t]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=U(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=b.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);o<a;o++)if(r=st.prefilters[o].call(l,e,c,l.opts))return g(r.stop)&&(b._queueHooks(l.elem,l.opts.queue).stop=r.stop.bind(r)),r;return b.map(c,at,l),g(l.opts.start)&&l.opts.start.call(e,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),b.fx.timer(b.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l}b.Animation=b.extend(st,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return oe(n.elem,e,te.exec(t),n),n}]},tweener:function(e,t){g(e)?(t=e,e=["*"]):e=e.match(P);for(var n,r=0,i=e.length;r<i;r++)n=e[r],st.tweeners[n]=st.tweeners[n]||[],st.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&re(e),v=Y.get(e,"fxshow");for(r in n.queue||(null==(a=b._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,b.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],tt.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||b.style(e,r)}if((u=!b.isEmptyObject(t))||!b.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Y.get(e,"display")),"none"===(c=b.css(e,"display"))&&(l?c=l:(ue([e],!0),l=e.style.display||l,c=b.css(e,"display"),ue([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===b.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Y.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&ue([e],!0),p.done(function(){for(r in g||ue([e]),Y.remove(e,"fxshow"),d)b.style(e,r,d[r])})),u=at(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?st.prefilters.unshift(e):st.prefilters.push(e)}}),b.speed=function(e,t,n){var r=e&&"object"==typeof e?b.extend({},e):{complete:n||!n&&t||g(e)&&e,duration:e,easing:n&&t||t&&!g(t)&&t};return b.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in b.fx.speeds?r.duration=b.fx.speeds[r.duration]:r.duration=b.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){g(r.old)&&r.old.call(this),r.queue&&b.dequeue(this,r.queue)},r},b.fn.extend({fadeTo:function(e,t,n,r){return this.filter(re).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=b.isEmptyObject(e),o=b.speed(t,n,r),a=function(){var t=st(this,b.extend({},e),o);(i||Y.get(this,"finish"))&&t.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&!1!==e&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=b.timers,a=Y.get(this);if(i)a[i]&&a[i].stop&&r(a[i]);else for(i in a)a[i]&&a[i].stop&&nt.test(i)&&r(a[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));!t&&n||b.dequeue(this,e)})},finish:function(e){return!1!==e&&(e=e||"fx"),this.each(function(){var t,n=Y.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=b.timers,a=r?r.length:0;for(n.finish=!0,b.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;t<a;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),b.each(["toggle","show","hide"],function(e,t){var n=b.fn[t];b.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ot(t,!0),e,r,i)}}),b.each({slideDown:ot("show"),slideUp:ot("hide"),slideToggle:ot("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){b.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),b.timers=[],b.fx.tick=function(){var e,t=0,n=b.timers;for(Ze=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||b.fx.stop(),Ze=void 0},b.fx.timer=function(e){b.timers.push(e),b.fx.start()},b.fx.interval=13,b.fx.start=function(){et||(et=!0,rt())},b.fx.stop=function(){et=null},b.fx.speeds={slow:600,fast:200,_default:400},b.fn.delay=function(t,n){return t=b.fx&&b.fx.speeds[t]||t,n=n||"fx",this.queue(n,function(n,r){var i=e.setTimeout(n,t);r.stop=function(){e.clearTimeout(i)}})},function(){var e=r.createElement("input"),t=r.createElement("select").appendChild(r.createElement("option"));e.type="checkbox",h.checkOn=""!==e.value,h.optSelected=t.selected,(e=r.createElement("input")).value="t",e.type="radio",h.radioValue="t"===e.value}();var ut,lt=b.expr.attrHandle;b.fn.extend({attr:function(e,t){return F(this,b.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){b.removeAttr(this,e)})}}),b.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return void 0===e.getAttribute?b.prop(e,t,n):(1===o&&b.isXMLDoc(e)||(i=b.attrHooks[t.toLowerCase()]||(b.expr.match.bool.test(t)?ut:void 0)),void 0!==n?null===n?void b.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=b.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!h.radioValue&&"radio"===t&&D(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(P);if(i&&1===e.nodeType)for(;n=i[r++];)e.removeAttribute(n)}}),ut={set:function(e,t,n){return!1===t?b.removeAttr(e,n):e.setAttribute(n,n),n}},b.each(b.expr.match.bool.source.match(/\w+/g),function(e,t){var n=lt[t]||b.find.attr;lt[t]=function(e,t,r){var i,o,a=t.toLowerCase();return r||(o=lt[a],lt[a]=i,i=null!=n(e,t,r)?a:null,lt[a]=o),i}});var ct=/^(?:input|select|textarea|button)$/i,ft=/^(?:a|area)$/i;function pt(e){return(e.match(P)||[]).join(" ")}function dt(e){return e.getAttribute&&e.getAttribute("class")||""}function ht(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(P)||[]}b.fn.extend({prop:function(e,t){return F(this,b.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[b.propFix[e]||e]})}}),b.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&b.isXMLDoc(e)||(t=b.propFix[t]||t,i=b.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=b.find.attr(e,"tabindex");return t?parseInt(t,10):ct.test(e.nodeName)||ft.test(e.nodeName)&&e.href?0:-1}}},propFix:{for:"htmlFor",class:"className"}}),h.optSelected||(b.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),b.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){b.propFix[this.toLowerCase()]=this}),b.fn.extend({addClass:function(e){var t,n,r,i,o,a,s,u=0;if(g(e))return this.each(function(t){b(this).addClass(e.call(this,t,dt(this)))});if((t=ht(e)).length)for(;n=this[u++];)if(i=dt(n),r=1===n.nodeType&&" "+pt(i)+" "){for(a=0;o=t[a++];)r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=pt(r))&&n.setAttribute("class",s)}return this},removeClass:function(e){var t,n,r,i,o,a,s,u=0;if(g(e))return this.each(function(t){b(this).removeClass(e.call(this,t,dt(this)))});if(!arguments.length)return this.attr("class","");if((t=ht(e)).length)for(;n=this[u++];)if(i=dt(n),r=1===n.nodeType&&" "+pt(i)+" "){for(a=0;o=t[a++];)for(;r.indexOf(" "+o+" ")>-1;)r=r.replace(" "+o+" "," ");i!==(s=pt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(e,t){var n=typeof e,r="string"===n||Array.isArray(e);return"boolean"==typeof t&&r?t?this.addClass(e):this.removeClass(e):g(e)?this.each(function(n){b(this).toggleClass(e.call(this,n,dt(this),t),t)}):this.each(function(){var t,i,o,a;if(r)for(i=0,o=b(this),a=ht(e);t=a[i++];)o.hasClass(t)?o.removeClass(t):o.addClass(t);else void 0!==e&&"boolean"!==n||((t=dt(this))&&Y.set(this,"__className__",t),this.setAttribute&&this.setAttribute("class",t||!1===e?"":Y.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;for(t=" "+e+" ";n=this[r++];)if(1===n.nodeType&&(" "+pt(dt(n))+" ").indexOf(t)>-1)return!0;return!1}});var gt=/\r/g;b.fn.extend({val:function(e){var t,n,r,i=this[0];return arguments.length?(r=g(e),this.each(function(n){var i;1===this.nodeType&&(null==(i=r?e.call(this,n,b(this).val()):e)?i="":"number"==typeof i?i+="":Array.isArray(i)&&(i=b.map(i,function(e){return null==e?"":e+""})),(t=b.valHooks[this.type]||b.valHooks[this.nodeName.toLowerCase()])&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))})):i?(t=b.valHooks[i.type]||b.valHooks[i.nodeName.toLowerCase()])&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:"string"==typeof(n=i.value)?n.replace(gt,""):null==n?"":n:void 0}}),b.extend({valHooks:{option:{get:function(e){var t=b.find.attr(e,"value");return null!=t?t:pt(b.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!D(n.parentNode,"optgroup"))){if(t=b(n).val(),a)return t;s.push(t)}return s},set:function(e,t){for(var n,r,i=e.options,o=b.makeArray(t),a=i.length;a--;)((r=i[a]).selected=b.inArray(b.valHooks.option.get(r),o)>-1)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),b.each(["radio","checkbox"],function(){b.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=b.inArray(b(e).val(),t)>-1}},h.checkOn||(b.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),h.focusin="onfocusin"in e;var vt=/^(?:focusinfocus|focusoutblur)$/,yt=function(e){e.stopPropagation()};b.extend(b.event,{trigger:function(t,n,i,o){var a,s,u,l,c,p,d,h,y=[i||r],m=f.call(t,"type")?t.type:t,x=f.call(t,"namespace")?t.namespace.split("."):[];if(s=h=u=i=i||r,3!==i.nodeType&&8!==i.nodeType&&!vt.test(m+b.event.triggered)&&(m.indexOf(".")>-1&&(m=(x=m.split(".")).shift(),x.sort()),c=m.indexOf(":")<0&&"on"+m,(t=t[b.expando]?t:new b.Event(m,"object"==typeof t&&t)).isTrigger=o?2:3,t.namespace=x.join("."),t.rnamespace=t.namespace?new RegExp("(^|\\.)"+x.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=i),n=null==n?[t]:b.makeArray(n,[t]),d=b.event.special[m]||{},o||!d.trigger||!1!==d.trigger.apply(i,n))){if(!o&&!d.noBubble&&!v(i)){for(l=d.delegateType||m,vt.test(l+m)||(s=s.parentNode);s;s=s.parentNode)y.push(s),u=s;u===(i.ownerDocument||r)&&y.push(u.defaultView||u.parentWindow||e)}for(a=0;(s=y[a++])&&!t.isPropagationStopped();)h=s,t.type=a>1?l:d.bindType||m,(p=(Y.get(s,"events")||{})[t.type]&&Y.get(s,"handle"))&&p.apply(s,n),(p=c&&s[c])&&p.apply&&V(s)&&(t.result=p.apply(s,n),!1===t.result&&t.preventDefault());return t.type=m,o||t.isDefaultPrevented()||d._default&&!1!==d._default.apply(y.pop(),n)||!V(i)||c&&g(i[m])&&!v(i)&&((u=i[c])&&(i[c]=null),b.event.triggered=m,t.isPropagationStopped()&&h.addEventListener(m,yt),i[m](),t.isPropagationStopped()&&h.removeEventListener(m,yt),b.event.triggered=void 0,u&&(i[c]=u)),t.result}},simulate:function(e,t,n){var r=b.extend(new b.Event,n,{type:e,isSimulated:!0});b.event.trigger(r,null,t)}}),b.fn.extend({trigger:function(e,t){return this.each(function(){b.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return b.event.trigger(e,t,n,!0)}}),h.focusin||b.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){b.event.simulate(t,e.target,b.event.fix(e))};b.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=Y.access(r,t);i||r.addEventListener(e,n,!0),Y.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=Y.access(r,t)-1;i?Y.access(r,t,i):(r.removeEventListener(e,n,!0),Y.remove(r,t))}}});var mt=e.location,xt=Date.now(),bt=/\?/;b.parseXML=function(t){var n;if(!t||"string"!=typeof t)return null;try{n=(new e.DOMParser).parseFromString(t,"text/xml")}catch(e){n=void 0}return n&&!n.getElementsByTagName("parsererror").length||b.error("Invalid XML: "+t),n};var wt=/\[\]$/,Tt=/\r?\n/g,Ct=/^(?:submit|button|image|reset|file)$/i,Et=/^(?:input|select|textarea|keygen)/i;function kt(e,t,n,r){var i;if(Array.isArray(t))b.each(t,function(t,i){n||wt.test(e)?r(e,i):kt(e+"["+("object"==typeof i&&null!=i?t:"")+"]",i,n,r)});else if(n||"object"!==x(t))r(e,t);else for(i in t)kt(e+"["+i+"]",t[i],n,r)}b.param=function(e,t){var n,r=[],i=function(e,t){var n=g(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(Array.isArray(e)||e.jquery&&!b.isPlainObject(e))b.each(e,function(){i(this.name,this.value)});else for(n in e)kt(n,e[n],t,i);return r.join("&")},b.fn.extend({serialize:function(){return b.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=b.prop(this,"elements");return e?b.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!b(this).is(":disabled")&&Et.test(this.nodeName)&&!Ct.test(e)&&(this.checked||!le.test(e))}).map(function(e,t){var n=b(this).val();return null==n?null:Array.isArray(n)?b.map(n,function(e){return{name:t.name,value:e.replace(Tt,"\r\n")}}):{name:t.name,value:n.replace(Tt,"\r\n")}}).get()}});var St=/%20/g,Dt=/#.*$/,Nt=/([?&])_=[^&]*/,At=/^(.*?):[ \t]*([^\r\n]*)$/gm,jt=/^(?:GET|HEAD)$/,qt=/^\/\//,Lt={},Ht={},Ot="*/".concat("*"),Pt=r.createElement("a");function Mt(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(P)||[];if(g(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function Rt(e,t,n,r){var i={},o=e===Ht;function a(s){var u;return i[s]=!0,b.each(e[s]||[],function(e,s){var l=s(t,n,r);return"string"!=typeof l||o||i[l]?o?!(u=l):void 0:(t.dataTypes.unshift(l),a(l),!1)}),u}return a(t.dataTypes[0])||!i["*"]&&a("*")}function It(e,t){var n,r,i=b.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&b.extend(!0,e,r),e}Pt.href=mt.href,b.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:mt.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(mt.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Ot,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":b.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?It(It(e,b.ajaxSettings),t):It(b.ajaxSettings,e)},ajaxPrefilter:Mt(Lt),ajaxTransport:Mt(Ht),ajax:function(t,n){"object"==typeof t&&(n=t,t=void 0),n=n||{};var i,o,a,s,u,l,c,f,p,d,h=b.ajaxSetup({},n),g=h.context||h,v=h.context&&(g.nodeType||g.jquery)?b(g):b.event,y=b.Deferred(),m=b.Callbacks("once memory"),x=h.statusCode||{},w={},T={},C="canceled",E={readyState:0,getResponseHeader:function(e){var t;if(c){if(!s)for(s={};t=At.exec(a);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return c?a:null},setRequestHeader:function(e,t){return null==c&&(e=T[e.toLowerCase()]=T[e.toLowerCase()]||e,w[e]=t),this},overrideMimeType:function(e){return null==c&&(h.mimeType=e),this},statusCode:function(e){var t;if(e)if(c)E.always(e[E.status]);else for(t in e)x[t]=[x[t],e[t]];return this},abort:function(e){var t=e||C;return i&&i.abort(t),k(0,t),this}};if(y.promise(E),h.url=((t||h.url||mt.href)+"").replace(qt,mt.protocol+"//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||"*").toLowerCase().match(P)||[""],null==h.crossDomain){l=r.createElement("a");try{l.href=h.url,l.href=l.href,h.crossDomain=Pt.protocol+"//"+Pt.host!=l.protocol+"//"+l.host}catch(e){h.crossDomain=!0}}if(h.data&&h.processData&&"string"!=typeof h.data&&(h.data=b.param(h.data,h.traditional)),Rt(Lt,h,n,E),c)return E;for(p in(f=b.event&&h.global)&&0==b.active++&&b.event.trigger("ajaxStart"),h.type=h.type.toUpperCase(),h.hasContent=!jt.test(h.type),o=h.url.replace(Dt,""),h.hasContent?h.data&&h.processData&&0===(h.contentType||"").indexOf("application/x-www-form-urlencoded")&&(h.data=h.data.replace(St,"+")):(d=h.url.slice(o.length),h.data&&(h.processData||"string"==typeof h.data)&&(o+=(bt.test(o)?"&":"?")+h.data,delete h.data),!1===h.cache&&(o=o.replace(Nt,"$1"),d=(bt.test(o)?"&":"?")+"_="+xt+++d),h.url=o+d),h.ifModified&&(b.lastModified[o]&&E.setRequestHeader("If-Modified-Since",b.lastModified[o]),b.etag[o]&&E.setRequestHeader("If-None-Match",b.etag[o])),(h.data&&h.hasContent&&!1!==h.contentType||n.contentType)&&E.setRequestHeader("Content-Type",h.contentType),E.setRequestHeader("Accept",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+("*"!==h.dataTypes[0]?", "+Ot+"; q=0.01":""):h.accepts["*"]),h.headers)E.setRequestHeader(p,h.headers[p]);if(h.beforeSend&&(!1===h.beforeSend.call(g,E,h)||c))return E.abort();if(C="abort",m.add(h.complete),E.done(h.success),E.fail(h.error),i=Rt(Ht,h,n,E)){if(E.readyState=1,f&&v.trigger("ajaxSend",[E,h]),c)return E;h.async&&h.timeout>0&&(u=e.setTimeout(function(){E.abort("timeout")},h.timeout));try{c=!1,i.send(w,k)}catch(e){if(c)throw e;k(-1,e)}}else k(-1,"No Transport");function k(t,n,r,s){var l,p,d,w,T,C=n;c||(c=!0,u&&e.clearTimeout(u),i=void 0,a=s||"",E.readyState=t>0?4:0,l=t>=200&&t<300||304===t,r&&(w=function(e,t,n){for(var r,i,o,a,s=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(h,E,r)),w=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];for(o=c.shift();o;)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e.throws)t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(h,w,E,l),l?(h.ifModified&&((T=E.getResponseHeader("Last-Modified"))&&(b.lastModified[o]=T),(T=E.getResponseHeader("etag"))&&(b.etag[o]=T)),204===t||"HEAD"===h.type?C="nocontent":304===t?C="notmodified":(C=w.state,p=w.data,l=!(d=w.error))):(d=C,!t&&C||(C="error",t<0&&(t=0))),E.status=t,E.statusText=(n||C)+"",l?y.resolveWith(g,[p,C,E]):y.rejectWith(g,[E,C,d]),E.statusCode(x),x=void 0,f&&v.trigger(l?"ajaxSuccess":"ajaxError",[E,h,l?p:d]),m.fireWith(g,[E,C]),f&&(v.trigger("ajaxComplete",[E,h]),--b.active||b.event.trigger("ajaxStop")))}return E},getJSON:function(e,t,n){return b.get(e,t,n,"json")},getScript:function(e,t){return b.get(e,void 0,t,"script")}}),b.each(["get","post"],function(e,t){b[t]=function(e,n,r,i){return g(n)&&(i=i||r,r=n,n=void 0),b.ajax(b.extend({url:e,type:t,dataType:i,data:n,success:r},b.isPlainObject(e)&&e))}}),b._evalUrl=function(e){return b.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,throws:!0})},b.fn.extend({wrapAll:function(e){var t;return this[0]&&(g(e)&&(e=e.call(this[0])),t=b(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(e){return g(e)?this.each(function(t){b(this).wrapInner(e.call(this,t))}):this.each(function(){var t=b(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=g(e);return this.each(function(n){b(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(e){return this.parent(e).not("body").each(function(){b(this).replaceWith(this.childNodes)}),this}}),b.expr.pseudos.hidden=function(e){return!b.expr.pseudos.visible(e)},b.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},b.ajaxSettings.xhr=function(){try{return new e.XMLHttpRequest}catch(e){}};var Wt={0:200,1223:204},$t=b.ajaxSettings.xhr();h.cors=!!$t&&"withCredentials"in $t,h.ajax=$t=!!$t,b.ajaxTransport(function(t){var n,r;if(h.cors||$t&&!t.crossDomain)return{send:function(i,o){var a,s=t.xhr();if(s.open(t.type,t.url,t.async,t.username,t.password),t.xhrFields)for(a in t.xhrFields)s[a]=t.xhrFields[a];for(a in t.mimeType&&s.overrideMimeType&&s.overrideMimeType(t.mimeType),t.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest"),i)s.setRequestHeader(a,i[a]);n=function(e){return function(){n&&(n=r=s.onload=s.onerror=s.onabort=s.ontimeout=s.onreadystatechange=null,"abort"===e?s.abort():"error"===e?"number"!=typeof s.status?o(0,"error"):o(s.status,s.statusText):o(Wt[s.status]||s.status,s.statusText,"text"!==(s.responseType||"text")||"string"!=typeof s.responseText?{binary:s.response}:{text:s.responseText},s.getAllResponseHeaders()))}},s.onload=n(),r=s.onerror=s.ontimeout=n("error"),void 0!==s.onabort?s.onabort=r:s.onreadystatechange=function(){4===s.readyState&&e.setTimeout(function(){n&&r()})},n=n("abort");try{s.send(t.hasContent&&t.data||null)}catch(e){if(n)throw e}},abort:function(){n&&n()}}}),b.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),b.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return b.globalEval(e),e}}}),b.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),b.ajaxTransport("script",function(e){var t,n;if(e.crossDomain)return{send:function(i,o){t=b("<script>").prop({charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&o("error"===e.type?404:200,e.type)}),r.head.appendChild(t[0])},abort:function(){n&&n()}}});var Bt,Ft=[],_t=/(=)\?(?=&|$)|\?\?/;b.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Ft.pop()||b.expando+"_"+xt++;return this[e]=!0,e}}),b.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,a,s=!1!==t.jsonp&&(_t.test(t.url)?"url":"string"==typeof t.data&&0===(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&_t.test(t.data)&&"data");if(s||"jsonp"===t.dataTypes[0])return i=t.jsonpCallback=g(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,s?t[s]=t[s].replace(_t,"$1"+i):!1!==t.jsonp&&(t.url+=(bt.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return a||b.error(i+" was not called"),a[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){a=arguments},r.always(function(){void 0===o?b(e).removeProp(i):e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,Ft.push(i)),a&&g(o)&&o(a[0]),a=o=void 0}),"script"}),h.createHTMLDocument=((Bt=r.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Bt.childNodes.length),b.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(h.createHTMLDocument?((i=(t=r.implementation.createHTMLDocument("")).createElement("base")).href=r.location.href,t.head.appendChild(i)):t=r),o=N.exec(e),a=!n&&[],o?[t.createElement(o[1])]:(o=me([e],t,a),a&&a.length&&b(a).remove(),b.merge([],o.childNodes)));var i,o,a},b.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return s>-1&&(r=pt(e.slice(s)),e=e.slice(0,s)),g(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),a.length>0&&b.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?b("<div>").append(b.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},b.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){b.fn[t]=function(e){return this.on(t,e)}}),b.expr.pseudos.animated=function(e){return b.grep(b.timers,function(t){return e===t.elem}).length},b.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=b.css(e,"position"),c=b(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=b.css(e,"top"),u=b.css(e,"left"),("absolute"===l||"fixed"===l)&&(o+u).indexOf("auto")>-1?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),g(t)&&(t=t.call(e,n,b.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},b.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){b.offset.setOffset(this,e,t)});var t,n,r=this[0];return r?r.getClientRects().length?(t=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:t.top+n.pageYOffset,left:t.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===b.css(r,"position"))t=r.getBoundingClientRect();else{for(t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;e&&(e===n.body||e===n.documentElement)&&"static"===b.css(e,"position");)e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=b(e).offset()).top+=b.css(e,"borderTopWidth",!0),i.left+=b.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-b.css(r,"marginTop",!0),left:t.left-i.left-b.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent;e&&"static"===b.css(e,"position");)e=e.offsetParent;return e||xe})}}),b.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,t){var n="pageYOffset"===t;b.fn[e]=function(r){return F(this,function(e,r,i){var o;if(v(e)?o=e:9===e.nodeType&&(o=e.defaultView),void 0===i)return o?o[t]:e[r];o?o.scrollTo(n?o.pageXOffset:i,n?i:o.pageYOffset):e[r]=i},e,r,arguments.length)}}),b.each(["top","left"],function(e,t){b.cssHooks[t]=Be(h.pixelPosition,function(e,n){if(n)return n=$e(e,t),Re.test(n)?b(e).position()[t]+"px":n})}),b.each({Height:"height",Width:"width"},function(e,t){b.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){b.fn[r]=function(i,o){var a=arguments.length&&(n||"boolean"!=typeof i),s=n||(!0===i||!0===o?"margin":"border");return F(this,function(t,n,i){var o;return v(t)?0===r.indexOf("outer")?t["inner"+e]:t.document.documentElement["client"+e]:9===t.nodeType?(o=t.documentElement,Math.max(t.body["scroll"+e],o["scroll"+e],t.body["offset"+e],o["offset"+e],o["client"+e])):void 0===i?b.css(t,n,s):b.style(t,n,i,s)},t,a?i:void 0,a)}})}),b.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,t){b.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),b.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),b.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),b.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),g(e))return r=o.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(o.call(arguments)))}).guid=e.guid=e.guid||b.guid++,i},b.holdReady=function(e){e?b.readyWait++:b.ready(!0)},b.isArray=Array.isArray,b.parseJSON=JSON.parse,b.nodeName=D,b.isFunction=g,b.isWindow=v,b.camelCase=U,b.type=x,b.now=Date.now,b.isNumeric=function(e){var t=b.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return b});var zt=e.jQuery,Xt=e.$;return b.noConflict=function(t){return e.$===b&&(e.$=Xt),t&&e.jQuery===b&&(e.jQuery=zt),b},t||(e.jQuery=e.$=b),b});
-
-},{}],5:[function(require,module,exports){
-!function(t){var e;if("function"==typeof define&&define.amd)define(["leaflet"],t);else if("object"==typeof module&&"object"==typeof module.exports)e=require("leaflet"),module.exports=t(e);else{if(void 0===window.L)throw new Error("Leaflet must be loaded first");t(window.L)}}(function(t){t.Map.mergeOptions({contextmenuItems:[]}),t.Map.ContextMenu=t.Handler.extend({_touchstart:t.Browser.msPointer?"MSPointerDown":t.Browser.pointer?"pointerdown":"touchstart",statics:{BASE_CLS:"leaflet-contextmenu"},initialize:function(e){t.Handler.prototype.initialize.call(this,e),this._items=[],this._visible=!1;var n=this._container=t.DomUtil.create("div",t.Map.ContextMenu.BASE_CLS,e._container);n.style.zIndex=1e4,n.style.position="absolute",e.options.contextmenuWidth&&(n.style.width=e.options.contextmenuWidth+"px"),this._createItems(),t.DomEvent.on(n,"click",t.DomEvent.stop).on(n,"mousedown",t.DomEvent.stop).on(n,"dblclick",t.DomEvent.stop).on(n,"contextmenu",t.DomEvent.stop)},addHooks:function(){var e=this._map.getContainer();t.DomEvent.on(e,"mouseleave",this._hide,this).on(document,"keydown",this._onKeyDown,this),t.Browser.touch&&t.DomEvent.on(document,this._touchstart,this._hide,this),this._map.on({contextmenu:this._show,mousedown:this._hide,movestart:this._hide,zoomstart:this._hide},this)},removeHooks:function(){var e=this._map.getContainer();t.DomEvent.off(e,"mouseleave",this._hide,this).off(document,"keydown",this._onKeyDown,this),t.Browser.touch&&t.DomEvent.off(document,this._touchstart,this._hide,this),this._map.off({contextmenu:this._show,mousedown:this._hide,movestart:this._hide,zoomstart:this._hide},this)},showAt:function(e,n){e instanceof t.LatLng&&(e=this._map.latLngToContainerPoint(e)),this._showAtPoint(e,n)},hide:function(){this._hide()},addItem:function(t){return this.insertItem(t)},insertItem:function(t,e){e=void 0!==e?e:this._items.length;var n=this._createItem(this._container,t,e);return this._items.push(n),this._sizeChanged=!0,this._map.fire("contextmenu.additem",{contextmenu:this,el:n.el,index:e}),n.el},removeItem:function(e){var n=this._container;return isNaN(e)||(e=n.children[e]),e?(this._removeItem(t.Util.stamp(e)),this._sizeChanged=!0,this._map.fire("contextmenu.removeitem",{contextmenu:this,el:e}),e):null},removeAllItems:function(){for(var e,n=this._container.children;n.length;)e=n[0],this._removeItem(t.Util.stamp(e));return n},hideAllItems:function(){var t,e;for(t=0,e=this._items.length;t<e;t++)this._items[t].el.style.display="none"},showAllItems:function(){var t,e;for(t=0,e=this._items.length;t<e;t++)this._items[t].el.style.display=""},setDisabled:function(e,n){var i=this._container,o=t.Map.ContextMenu.BASE_CLS+"-item";isNaN(e)||(e=i.children[e]),e&&t.DomUtil.hasClass(e,o)&&(n?(t.DomUtil.addClass(e,o+"-disabled"),this._map.fire("contextmenu.disableitem",{contextmenu:this,el:e})):(t.DomUtil.removeClass(e,o+"-disabled"),this._map.fire("contextmenu.enableitem",{contextmenu:this,el:e})))},isVisible:function(){return this._visible},_createItems:function(){var t,e,n=this._map.options.contextmenuItems;for(t=0,e=n.length;t<e;t++)this._items.push(this._createItem(this._container,n[t]))},_createItem:function(e,n,i){if(n.separator||"-"===n)return this._createSeparator(e,i);var o=t.Map.ContextMenu.BASE_CLS+"-item",s=n.disabled?o+" "+o+"-disabled":o,h=this._insertElementAt("a",s,e,i),a=this._createEventHandler(h,n.callback,n.context,n.hideOnSelect),r=this._getIcon(n),m=this._getIconCls(n),u="";return r?u='<img class="'+t.Map.ContextMenu.BASE_CLS+'-icon" src="'+r+'"/>':m&&(u='<span class="'+t.Map.ContextMenu.BASE_CLS+"-icon "+m+'"></span>'),h.innerHTML=u+n.text,h.href="#",t.DomEvent.on(h,"mouseover",this._onItemMouseOver,this).on(h,"mouseout",this._onItemMouseOut,this).on(h,"mousedown",t.DomEvent.stopPropagation).on(h,"click",a),t.Browser.touch&&t.DomEvent.on(h,this._touchstart,t.DomEvent.stopPropagation),t.Browser.pointer||t.DomEvent.on(h,"click",this._onItemMouseOut,this),{id:t.Util.stamp(h),el:h,callback:a}},_removeItem:function(e){var n,i,o,s,h;for(o=0,s=this._items.length;o<s;o++)if((n=this._items[o]).id===e)return i=n.el,(h=n.callback)&&(t.DomEvent.off(i,"mouseover",this._onItemMouseOver,this).off(i,"mouseover",this._onItemMouseOut,this).off(i,"mousedown",t.DomEvent.stopPropagation).off(i,"click",h),t.Browser.touch&&t.DomEvent.off(i,this._touchstart,t.DomEvent.stopPropagation),t.Browser.pointer||t.DomEvent.on(i,"click",this._onItemMouseOut,this)),this._container.removeChild(i),this._items.splice(o,1),n;return null},_createSeparator:function(e,n){var i=this._insertElementAt("div",t.Map.ContextMenu.BASE_CLS+"-separator",e,n);return{id:t.Util.stamp(i),el:i}},_createEventHandler:function(e,n,i,o){var s=this,h=this._map,a=t.Map.ContextMenu.BASE_CLS+"-item-disabled";o=void 0===o||o;return function(r){t.DomUtil.hasClass(e,a)||(o&&s._hide(),n&&n.call(i||h,s._showLocation),s._map.fire("contextmenu.select",{contextmenu:s,el:e}))}},_insertElementAt:function(t,e,n,i){var o,s=document.createElement(t);return s.className=e,void 0!==i&&(o=n.children[i]),o?n.insertBefore(s,o):n.appendChild(s),s},_show:function(t){this._showAtPoint(t.containerPoint,t)},_showAtPoint:function(e,n){if(this._items.length){var i=this._map,o=i.containerPointToLayerPoint(e),s=i.layerPointToLatLng(o),h=t.extend(n||{},{contextmenu:this});this._showLocation={latlng:s,layerPoint:o,containerPoint:e},n&&n.relatedTarget&&(this._showLocation.relatedTarget=n.relatedTarget),this._setPosition(e),this._visible||(this._container.style.display="block",this._visible=!0),this._map.fire("contextmenu.show",h)}},_hide:function(){this._visible&&(this._visible=!1,this._container.style.display="none",this._map.fire("contextmenu.hide",{contextmenu:this}))},_getIcon:function(e){return t.Browser.retina&&e.retinaIcon||e.icon},_getIconCls:function(e){return t.Browser.retina&&e.retinaIconCls||e.iconCls},_setPosition:function(e){var n,i=this._map.getSize(),o=this._container,s=this._getElementSize(o);this._map.options.contextmenuAnchor&&(n=t.point(this._map.options.contextmenuAnchor),e=e.add(n)),o._leaflet_pos=e,e.x+s.x>i.x?(o.style.left="auto",o.style.right=Math.min(Math.max(i.x-e.x,0),i.x-s.x-1)+"px"):(o.style.left=Math.max(e.x,0)+"px",o.style.right="auto"),e.y+s.y>i.y?(o.style.top="auto",o.style.bottom=Math.min(Math.max(i.y-e.y,0),i.y-s.y-1)+"px"):(o.style.top=Math.max(e.y,0)+"px",o.style.bottom="auto")},_getElementSize:function(t){var e=this._size,n=t.style.display;return e&&!this._sizeChanged||(e={},t.style.left="-999999px",t.style.right="auto",t.style.display="block",e.x=t.offsetWidth,e.y=t.offsetHeight,t.style.left="auto",t.style.display=n,this._sizeChanged=!1),e},_onKeyDown:function(t){27===t.keyCode&&this._hide()},_onItemMouseOver:function(e){t.DomUtil.addClass(e.target||e.srcElement,"over")},_onItemMouseOut:function(e){t.DomUtil.removeClass(e.target||e.srcElement,"over")}}),t.Map.addInitHook("addHandler","contextmenu",t.Map.ContextMenu),t.Mixin.ContextMenu={bindContextMenu:function(e){return t.setOptions(this,e),this._initContextMenu(),this},unbindContextMenu:function(){return this.off("contextmenu",this._showContextMenu,this),this},addContextMenuItem:function(t){this.options.contextmenuItems.push(t)},removeContextMenuItemWithIndex:function(t){for(var e=[],n=0;n<this.options.contextmenuItems.length;n++)this.options.contextmenuItems[n].index==t&&e.push(n);for(var i=e.pop();void 0!==i;)this.options.contextmenuItems.splice(i,1),i=e.pop()},replaceContextMenuItem:function(t){this.removeContextMenuItemWithIndex(t.index),this.addContextMenuItem(t)},_initContextMenu:function(){this._items=[],this.on("contextmenu",this._showContextMenu,this)},_showContextMenu:function(e){var n,i,o,s,h;if(this._map.contextmenu){for(i=t.extend({relatedTarget:this},e),o=this._map.mouseEventToContainerPoint(e.originalEvent),this.options.contextmenuInheritItems||this._map.contextmenu.hideAllItems(),s=0,h=this.options.contextmenuItems.length;s<h;s++)n=this.options.contextmenuItems[s],this._items.push(this._map.contextmenu.insertItem(n,n.index));this._map.once("contextmenu.hide",this._hideContextMenu,this),this._map.contextmenu.showAt(o,i)}},_hideContextMenu:function(){var t,e;for(t=0,e=this._items.length;t<e;t++)this._map.contextmenu.removeItem(this._items[t]);this._items.length=0,this.options.contextmenuInheritItems||this._map.contextmenu.showAllItems()}};var e,n,i,o=[t.Marker,t.Path],s={contextmenu:!1,contextmenuItems:[],contextmenuInheritItems:!0};for(n=0,i=o.length;n<i;n++)(e=o[n]).prototype.options?e.mergeOptions(s):e.prototype.options=s,e.addInitHook(function(){this.options.contextmenu&&this._initContextMenu()}),e.include(t.Mixin.ContextMenu);return t.Map.ContextMenu});
-
-},{"leaflet":7}],6:[function(require,module,exports){
-!function(){var o=window.console||{error:function(){},warn:function(){}};function t(t){t.Control.Loading=t.Control.extend({options:{delayIndicator:null,position:"topleft",separate:!1,zoomControl:null,spinjs:!1,spin:{lines:7,length:3,width:3,radius:5,rotate:13,top:"83%"}},initialize:function(o){t.setOptions(this,o),this._dataLoaders={},null!==this.options.zoomControl&&(this.zoomControl=this.options.zoomControl)},onAdd:function(n){if(this.options.spinjs&&"function"!=typeof Spinner)return o.error("Leaflet.loading cannot load because you didn't load spin.js (http://fgnass.github.io/spin.js/), even though you set it in options.");this._addLayerListeners(n),this._addMapListeners(n),this.options.separate||this.zoomControl||(n.zoomControl?this.zoomControl=n.zoomControl:n.zoomsliderControl&&(this.zoomControl=n.zoomsliderControl));var i,a="leaflet-control-loading";return this.zoomControl&&!this.options.separate?(i=this.zoomControl._container,a+=" leaflet-bar-part-bottom leaflet-bar-part last",t.DomUtil.addClass(this._getLastControlButton(),"leaflet-bar-part-bottom")):i=t.DomUtil.create("div","leaflet-control-zoom leaflet-control-layer-container leaflet-bar"),this._indicatorContainer=i,this._indicator=t.DomUtil.create("a",a,i),this.options.spinjs&&(this._spinner=new Spinner(this.options.spin).spin(),this._indicator.appendChild(this._spinner.el)),i},onRemove:function(o){this._removeLayerListeners(o),this._removeMapListeners(o)},removeFrom:function(o){return this.zoomControl&&!this.options.separate?(this._container.removeChild(this._indicator),this._map=null,this.onRemove(o),this):t.Control.prototype.removeFrom.call(this,o)},addLoader:function(o){if(this._dataLoaders[o]=!0,this.options.delayIndicator&&!this.delayIndicatorTimeout){var t=this;this.delayIndicatorTimeout=setTimeout(function(){t.updateIndicator(),t.delayIndicatorTimeout=null},this.options.delayIndicator)}else this.updateIndicator()},removeLoader:function(o){delete this._dataLoaders[o],this.updateIndicator(),this.options.delayIndicator&&this.delayIndicatorTimeout&&!this.isLoading()&&(clearTimeout(this.delayIndicatorTimeout),this.delayIndicatorTimeout=null)},updateIndicator:function(){this.isLoading()?this._showIndicator():this._hideIndicator()},isLoading:function(){return this._countLoaders()>0},_countLoaders:function(){var o,t=0;for(o in this._dataLoaders)this._dataLoaders.hasOwnProperty(o)&&t++;return t},_showIndicator:function(){t.DomUtil.addClass(this._indicator,"is-loading"),t.DomUtil.addClass(this._indicatorContainer,"is-loading"),this.options.separate||(this.zoomControl instanceof t.Control.Zoom?t.DomUtil.removeClass(this._getLastControlButton(),"leaflet-bar-part-bottom"):"function"==typeof t.Control.Zoomslider&&this.zoomControl instanceof t.Control.Zoomslider&&t.DomUtil.removeClass(this.zoomControl._ui.zoomOut,"leaflet-bar-part-bottom"))},_hideIndicator:function(){t.DomUtil.removeClass(this._indicator,"is-loading"),t.DomUtil.removeClass(this._indicatorContainer,"is-loading"),this.options.separate||(this.zoomControl instanceof t.Control.Zoom?t.DomUtil.addClass(this._getLastControlButton(),"leaflet-bar-part-bottom"):"function"==typeof t.Control.Zoomslider&&this.zoomControl instanceof t.Control.Zoomslider&&t.DomUtil.addClass(this.zoomControl._ui.zoomOut,"leaflet-bar-part-bottom"))},_getLastControlButton:function(){for(var o=this.zoomControl._container,t=o.children.length-1;t>0;){var n=o.children[t];if(this._indicator!==n&&0!==n.offsetWidth&&0!==n.offsetHeight)break;t--}return o.children[t]},_handleLoading:function(o){this.addLoader(this.getEventId(o))},_handleBaseLayerChange:function(o){var n=this;o.layer&&o.layer.eachLayer&&"function"==typeof o.layer.eachLayer?o.layer.eachLayer(function(o){n._handleBaseLayerChange({layer:o})}):t.TileLayer.Canvas&&o.layer instanceof t.TileLayer.Canvas||n._handleLoading(o)},_handleLoad:function(o){this.removeLoader(this.getEventId(o))},getEventId:function(o){return o.id?o.id:o.layer?o.layer._leaflet_id:o.target._leaflet_id},_layerAdd:function(t){if(t.layer&&t.layer.on)try{t.layer.on({loading:this._handleLoading,load:this._handleLoad},this)}catch(n){o.warn("L.Control.Loading: Tried and failed to add  event handlers to layer",t.layer),o.warn("L.Control.Loading: Full details",n)}},_layerRemove:function(t){if(t.layer&&t.layer.off)try{t.layer.off({loading:this._handleLoading,load:this._handleLoad},this)}catch(n){o.warn("L.Control.Loading: Tried and failed to remove event handlers from layer",t.layer),o.warn("L.Control.Loading: Full details",n)}},_addLayerListeners:function(o){o.eachLayer(function(o){o.on&&o.on({loading:this._handleLoading,load:this._handleLoad},this)},this),o.on("layeradd",this._layerAdd,this),o.on("layerremove",this._layerRemove,this)},_removeLayerListeners:function(o){o.eachLayer(function(o){o.off&&o.off({loading:this._handleLoading,load:this._handleLoad},this)},this),o.off("layeradd",this._layerAdd,this),o.off("layerremove",this._layerRemove,this)},_addMapListeners:function(o){o.on({baselayerchange:this._handleBaseLayerChange,dataloading:this._handleLoading,dataload:this._handleLoad,layerremove:this._handleLoad},this)},_removeMapListeners:function(o){o.off({baselayerchange:this._handleBaseLayerChange,dataloading:this._handleLoading,dataload:this._handleLoad,layerremove:this._handleLoad},this)}}),t.Map.addInitHook(function(){this.options.loadingControl&&(this.loadingControl=new t.Control.Loading,this.addControl(this.loadingControl))}),t.Control.loading=function(o){return new t.Control.Loading(o)}}"function"==typeof define&&define.amd?define(["leaflet"],function(o){t(o)}):t(L)}();
-
-},{}],7:[function(require,module,exports){
-!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports):"function"==typeof define&&define.amd?define(["exports"],i):i(t.L={})}(this,function(t){"use strict";var i=Object.freeze;function e(t){var i,e,n,o;for(e=1,n=arguments.length;e<n;e++)for(i in o=arguments[e])t[i]=o[i];return t}Object.freeze=function(t){return t};var n=Object.create||function(){function t(){}return function(i){return t.prototype=i,new t}}();function o(t,i){var e=Array.prototype.slice;if(t.bind)return t.bind.apply(t,e.call(arguments,1));var n=e.call(arguments,2);return function(){return t.apply(i,n.length?n.concat(e.call(arguments)):arguments)}}var s=0;function r(t){return t._leaflet_id=t._leaflet_id||++s,t._leaflet_id}function a(t,i,e){var n,o,s,r;return r=function(){n=!1,o&&(s.apply(e,o),o=!1)},s=function(){n?o=arguments:(t.apply(e,arguments),setTimeout(r,i),n=!0)}}function h(t,i,e){var n=i[1],o=i[0],s=n-o;return t===n&&e?t:((t-o)%s+s)%s+o}function u(){return!1}function l(t,i){var e=Math.pow(10,void 0===i?6:i);return Math.round(t*e)/e}function c(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}function _(t){return c(t).split(/\s+/)}function d(t,i){for(var e in t.hasOwnProperty("options")||(t.options=t.options?n(t.options):{}),i)t.options[e]=i[e];return t.options}function p(t,i,e){var n=[];for(var o in t)n.push(encodeURIComponent(e?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(i&&-1!==i.indexOf("?")?"&":"?")+n.join("&")}var m=/\{ *([\w_-]+) *\}/g;function f(t,i){return t.replace(m,function(t,e){var n=i[e];if(void 0===n)throw new Error("No value provided for variable "+t);return"function"==typeof n&&(n=n(i)),n})}var g=Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)};function v(t,i){for(var e=0;e<t.length;e++)if(t[e]===i)return e;return-1}var y="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";function x(t){return window["webkit"+t]||window["moz"+t]||window["ms"+t]}var w=0;function P(t){var i=+new Date,e=Math.max(0,16-(i-w));return w=i+e,window.setTimeout(t,e)}var b=window.requestAnimationFrame||x("RequestAnimationFrame")||P,T=window.cancelAnimationFrame||x("CancelAnimationFrame")||x("CancelRequestAnimationFrame")||function(t){window.clearTimeout(t)};function z(t,i,e){if(!e||b!==P)return b.call(window,o(t,i));t.call(i)}function M(t){t&&T.call(window,t)}var C=(Object.freeze||Object)({freeze:i,extend:e,create:n,bind:o,lastId:s,stamp:r,throttle:a,wrapNum:h,falseFn:u,formatNum:l,trim:c,splitWords:_,setOptions:d,getParamString:p,template:f,isArray:g,indexOf:v,emptyImageUrl:y,requestFn:b,cancelFn:T,requestAnimFrame:z,cancelAnimFrame:M});function Z(){}Z.extend=function(t){var i=function(){this.initialize&&this.initialize.apply(this,arguments),this.callInitHooks()},o=i.__super__=this.prototype,s=n(o);for(var r in s.constructor=i,i.prototype=s,this)this.hasOwnProperty(r)&&"prototype"!==r&&"__super__"!==r&&(i[r]=this[r]);return t.statics&&(e(i,t.statics),delete t.statics),t.includes&&(!function(t){if("undefined"==typeof L||!L||!L.Mixin)return;t=g(t)?t:[t];for(var i=0;i<t.length;i++)t[i]===L.Mixin.Events&&console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.",(new Error).stack)}(t.includes),e.apply(null,[s].concat(t.includes)),delete t.includes),s.options&&(t.options=e(n(s.options),t.options)),e(s,t),s._initHooks=[],s.callInitHooks=function(){if(!this._initHooksCalled){o.callInitHooks&&o.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,i=s._initHooks.length;t<i;t++)s._initHooks[t].call(this)}},i},Z.include=function(t){return e(this.prototype,t),this},Z.mergeOptions=function(t){return e(this.prototype.options,t),this},Z.addInitHook=function(t){var i=Array.prototype.slice.call(arguments,1),e="function"==typeof t?t:function(){this[t].apply(this,i)};return this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(e),this};var S={on:function(t,i,e){if("object"==typeof t)for(var n in t)this._on(n,t[n],i);else for(var o=0,s=(t=_(t)).length;o<s;o++)this._on(t[o],i,e);return this},off:function(t,i,e){if(t)if("object"==typeof t)for(var n in t)this._off(n,t[n],i);else for(var o=0,s=(t=_(t)).length;o<s;o++)this._off(t[o],i,e);else delete this._events;return this},_on:function(t,i,e){this._events=this._events||{};var n=this._events[t];n||(n=[],this._events[t]=n),e===this&&(e=void 0);for(var o={fn:i,ctx:e},s=n,r=0,a=s.length;r<a;r++)if(s[r].fn===i&&s[r].ctx===e)return;s.push(o)},_off:function(t,i,e){var n,o,s;if(this._events&&(n=this._events[t]))if(i){if(e===this&&(e=void 0),n)for(o=0,s=n.length;o<s;o++){var r=n[o];if(r.ctx===e&&r.fn===i)return r.fn=u,this._firingCount&&(this._events[t]=n=n.slice()),void n.splice(o,1)}}else{for(o=0,s=n.length;o<s;o++)n[o].fn=u;delete this._events[t]}},fire:function(t,i,n){if(!this.listens(t,n))return this;var o=e({},i,{type:t,target:this,sourceTarget:i&&i.sourceTarget||this});if(this._events){var s=this._events[t];if(s){this._firingCount=this._firingCount+1||1;for(var r=0,a=s.length;r<a;r++){var h=s[r];h.fn.call(h.ctx||this,o)}this._firingCount--}}return n&&this._propagateEvent(o),this},listens:function(t,i){var e=this._events&&this._events[t];if(e&&e.length)return!0;if(i)for(var n in this._eventParents)if(this._eventParents[n].listens(t,i))return!0;return!1},once:function(t,i,e){if("object"==typeof t){for(var n in t)this.once(n,t[n],i);return this}var s=o(function(){this.off(t,i,e).off(t,s,e)},this);return this.on(t,i,e).on(t,s,e)},addEventParent:function(t){return this._eventParents=this._eventParents||{},this._eventParents[r(t)]=t,this},removeEventParent:function(t){return this._eventParents&&delete this._eventParents[r(t)],this},_propagateEvent:function(t){for(var i in this._eventParents)this._eventParents[i].fire(t.type,e({layer:t.target,propagatedFrom:t.target},t),!0)}};S.addEventListener=S.on,S.removeEventListener=S.clearAllEventListeners=S.off,S.addOneTimeEventListener=S.once,S.fireEvent=S.fire,S.hasEventListeners=S.listens;var E=Z.extend(S);function k(t,i,e){this.x=e?Math.round(t):t,this.y=e?Math.round(i):i}var I=Math.trunc||function(t){return t>0?Math.floor(t):Math.ceil(t)};function A(t,i,e){return t instanceof k?t:g(t)?new k(t[0],t[1]):void 0===t||null===t?t:"object"==typeof t&&"x"in t&&"y"in t?new k(t.x,t.y):new k(t,i,e)}function B(t,i){if(t)for(var e=i?[t,i]:t,n=0,o=e.length;n<o;n++)this.extend(e[n])}function O(t,i){return!t||t instanceof B?t:new B(t,i)}function R(t,i){if(t)for(var e=i?[t,i]:t,n=0,o=e.length;n<o;n++)this.extend(e[n])}function D(t,i){return t instanceof R?t:new R(t,i)}function N(t,i,e){if(isNaN(t)||isNaN(i))throw new Error("Invalid LatLng object: ("+t+", "+i+")");this.lat=+t,this.lng=+i,void 0!==e&&(this.alt=+e)}function j(t,i,e){return t instanceof N?t:g(t)&&"object"!=typeof t[0]?3===t.length?new N(t[0],t[1],t[2]):2===t.length?new N(t[0],t[1]):null:void 0===t||null===t?t:"object"==typeof t&&"lat"in t?new N(t.lat,"lng"in t?t.lng:t.lon,t.alt):void 0===i?null:new N(t,i,e)}k.prototype={clone:function(){return new k(this.x,this.y)},add:function(t){return this.clone()._add(A(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(A(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},scaleBy:function(t){return new k(this.x*t.x,this.y*t.y)},unscaleBy:function(t){return new k(this.x/t.x,this.y/t.y)},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.clone()._ceil()},_ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},trunc:function(){return this.clone()._trunc()},_trunc:function(){return this.x=I(this.x),this.y=I(this.y),this},distanceTo:function(t){var i=(t=A(t)).x-this.x,e=t.y-this.y;return Math.sqrt(i*i+e*e)},equals:function(t){return(t=A(t)).x===this.x&&t.y===this.y},contains:function(t){return t=A(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+l(this.x)+", "+l(this.y)+")"}},B.prototype={extend:function(t){return t=A(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new k((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new k(this.min.x,this.max.y)},getTopRight:function(){return new k(this.max.x,this.min.y)},getTopLeft:function(){return this.min},getBottomRight:function(){return this.max},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var i,e;return(t="number"==typeof t[0]||t instanceof k?A(t):O(t))instanceof B?(i=t.min,e=t.max):i=e=t,i.x>=this.min.x&&e.x<=this.max.x&&i.y>=this.min.y&&e.y<=this.max.y},intersects:function(t){t=O(t);var i=this.min,e=this.max,n=t.min,o=t.max,s=o.x>=i.x&&n.x<=e.x,r=o.y>=i.y&&n.y<=e.y;return s&&r},overlaps:function(t){t=O(t);var i=this.min,e=this.max,n=t.min,o=t.max,s=o.x>i.x&&n.x<e.x,r=o.y>i.y&&n.y<e.y;return s&&r},isValid:function(){return!(!this.min||!this.max)}},R.prototype={extend:function(t){var i,e,n=this._southWest,o=this._northEast;if(t instanceof N)i=t,e=t;else{if(!(t instanceof R))return t?this.extend(j(t)||D(t)):this;if(i=t._southWest,e=t._northEast,!i||!e)return this}return n||o?(n.lat=Math.min(i.lat,n.lat),n.lng=Math.min(i.lng,n.lng),o.lat=Math.max(e.lat,o.lat),o.lng=Math.max(e.lng,o.lng)):(this._southWest=new N(i.lat,i.lng),this._northEast=new N(e.lat,e.lng)),this},pad:function(t){var i=this._southWest,e=this._northEast,n=Math.abs(i.lat-e.lat)*t,o=Math.abs(i.lng-e.lng)*t;return new R(new N(i.lat-n,i.lng-o),new N(e.lat+n,e.lng+o))},getCenter:function(){return new N((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new N(this.getNorth(),this.getWest())},getSouthEast:function(){return new N(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof N||"lat"in t?j(t):D(t);var i,e,n=this._southWest,o=this._northEast;return t instanceof R?(i=t.getSouthWest(),e=t.getNorthEast()):i=e=t,i.lat>=n.lat&&e.lat<=o.lat&&i.lng>=n.lng&&e.lng<=o.lng},intersects:function(t){t=D(t);var i=this._southWest,e=this._northEast,n=t.getSouthWest(),o=t.getNorthEast(),s=o.lat>=i.lat&&n.lat<=e.lat,r=o.lng>=i.lng&&n.lng<=e.lng;return s&&r},overlaps:function(t){t=D(t);var i=this._southWest,e=this._northEast,n=t.getSouthWest(),o=t.getNorthEast(),s=o.lat>i.lat&&n.lat<e.lat,r=o.lng>i.lng&&n.lng<e.lng;return s&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t,i){return!!t&&(t=D(t),this._southWest.equals(t.getSouthWest(),i)&&this._northEast.equals(t.getNorthEast(),i))},isValid:function(){return!(!this._southWest||!this._northEast)}},N.prototype={equals:function(t,i){return!!t&&(t=j(t),Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng))<=(void 0===i?1e-9:i))},toString:function(t){return"LatLng("+l(this.lat,t)+", "+l(this.lng,t)+")"},distanceTo:function(t){return F.distance(this,j(t))},wrap:function(){return F.wrapLatLng(this)},toBounds:function(t){var i=180*t/40075017,e=i/Math.cos(Math.PI/180*this.lat);return D([this.lat-i,this.lng-e],[this.lat+i,this.lng+e])},clone:function(){return new N(this.lat,this.lng,this.alt)}};var W,H={latLngToPoint:function(t,i){var e=this.projection.project(t),n=this.scale(i);return this.transformation._transform(e,n)},pointToLatLng:function(t,i){var e=this.scale(i),n=this.transformation.untransform(t,e);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},unproject:function(t){return this.projection.unproject(t)},scale:function(t){return 256*Math.pow(2,t)},zoom:function(t){return Math.log(t/256)/Math.LN2},getProjectedBounds:function(t){if(this.infinite)return null;var i=this.projection.bounds,e=this.scale(t);return new B(this.transformation.transform(i.min,e),this.transformation.transform(i.max,e))},infinite:!1,wrapLatLng:function(t){var i=this.wrapLng?h(t.lng,this.wrapLng,!0):t.lng;return new N(this.wrapLat?h(t.lat,this.wrapLat,!0):t.lat,i,t.alt)},wrapLatLngBounds:function(t){var i=t.getCenter(),e=this.wrapLatLng(i),n=i.lat-e.lat,o=i.lng-e.lng;if(0===n&&0===o)return t;var s=t.getSouthWest(),r=t.getNorthEast();return new R(new N(s.lat-n,s.lng-o),new N(r.lat-n,r.lng-o))}},F=e({},H,{wrapLng:[-180,180],R:6371e3,distance:function(t,i){var e=Math.PI/180,n=t.lat*e,o=i.lat*e,s=Math.sin((i.lat-t.lat)*e/2),r=Math.sin((i.lng-t.lng)*e/2),a=s*s+Math.cos(n)*Math.cos(o)*r*r,h=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));return this.R*h}}),U={R:6378137,MAX_LATITUDE:85.0511287798,project:function(t){var i=Math.PI/180,e=this.MAX_LATITUDE,n=Math.max(Math.min(e,t.lat),-e),o=Math.sin(n*i);return new k(this.R*t.lng*i,this.R*Math.log((1+o)/(1-o))/2)},unproject:function(t){var i=180/Math.PI;return new N((2*Math.atan(Math.exp(t.y/this.R))-Math.PI/2)*i,t.x*i/this.R)},bounds:(W=6378137*Math.PI,new B([-W,-W],[W,W]))};function V(t,i,e,n){if(g(t))return this._a=t[0],this._b=t[1],this._c=t[2],void(this._d=t[3]);this._a=t,this._b=i,this._c=e,this._d=n}function q(t,i,e,n){return new V(t,i,e,n)}V.prototype={transform:function(t,i){return this._transform(t.clone(),i)},_transform:function(t,i){return i=i||1,t.x=i*(this._a*t.x+this._b),t.y=i*(this._c*t.y+this._d),t},untransform:function(t,i){return i=i||1,new k((t.x/i-this._b)/this._a,(t.y/i-this._d)/this._c)}};var G=e({},F,{code:"EPSG:3857",projection:U,transformation:function(){var t=.5/(Math.PI*U.R);return q(t,.5,-t,.5)}()}),K=e({},G,{code:"EPSG:900913"});function Y(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}function X(t,i){var e,n,o,s,r,a,h="";for(e=0,o=t.length;e<o;e++){for(n=0,s=(r=t[e]).length;n<s;n++)a=r[n],h+=(n?"L":"M")+a.x+" "+a.y;h+=i?Mt?"z":"x":""}return h||"M0 0"}var J=document.documentElement.style,$="ActiveXObject"in window,Q=$&&!document.addEventListener,tt="msLaunchUri"in navigator&&!("documentMode"in document),it=Zt("webkit"),et=Zt("android"),nt=Zt("android 2")||Zt("android 3"),ot=parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1],10),st=et&&Zt("Google")&&ot<537&&!("AudioNode"in window),rt=!!window.opera,at=Zt("chrome"),ht=Zt("gecko")&&!it&&!rt&&!$,ut=!at&&Zt("safari"),lt=Zt("phantom"),ct="OTransition"in J,_t=0===navigator.platform.indexOf("Win"),dt=$&&"transition"in J,pt="WebKitCSSMatrix"in window&&"m11"in new window.WebKitCSSMatrix&&!nt,mt="MozPerspective"in J,ft=!window.L_DISABLE_3D&&(dt||pt||mt)&&!ct&&!lt,gt="undefined"!=typeof orientation||Zt("mobile"),vt=gt&&it,yt=gt&&pt,xt=!window.PointerEvent&&window.MSPointerEvent,wt=!(!window.PointerEvent&&!xt),Lt=!window.L_NO_TOUCH&&(wt||"ontouchstart"in window||window.DocumentTouch&&document instanceof window.DocumentTouch),Pt=gt&&rt,bt=gt&&ht,Tt=(window.devicePixelRatio||window.screen.deviceXDPI/window.screen.logicalXDPI)>1,zt=!!document.createElement("canvas").getContext,Mt=!(!document.createElementNS||!Y("svg").createSVGRect),Ct=!Mt&&function(){try{var t=document.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(t){return!1}}();function Zt(t){return navigator.userAgent.toLowerCase().indexOf(t)>=0}var St=(Object.freeze||Object)({ie:$,ielt9:Q,edge:tt,webkit:it,android:et,android23:nt,androidStock:st,opera:rt,chrome:at,gecko:ht,safari:ut,phantom:lt,opera12:ct,win:_t,ie3d:dt,webkit3d:pt,gecko3d:mt,any3d:ft,mobile:gt,mobileWebkit:vt,mobileWebkit3d:yt,msPointer:xt,pointer:wt,touch:Lt,mobileOpera:Pt,mobileGecko:bt,retina:Tt,canvas:zt,svg:Mt,vml:Ct}),Et=xt?"MSPointerDown":"pointerdown",kt=xt?"MSPointerMove":"pointermove",It=xt?"MSPointerUp":"pointerup",At=xt?"MSPointerCancel":"pointercancel",Bt=["INPUT","SELECT","OPTION"],Ot={},Rt=!1,Dt=0;function Nt(t,i,e,n){return"touchstart"===i?function(t,i,e){var n=o(function(t){if("mouse"!==t.pointerType&&t.MSPOINTER_TYPE_MOUSE&&t.pointerType!==t.MSPOINTER_TYPE_MOUSE){if(!(Bt.indexOf(t.target.tagName)<0))return;ni(t)}Ft(t,i)});t["_leaflet_touchstart"+e]=n,t.addEventListener(Et,n,!1),Rt||(document.documentElement.addEventListener(Et,jt,!0),document.documentElement.addEventListener(kt,Wt,!0),document.documentElement.addEventListener(It,Ht,!0),document.documentElement.addEventListener(At,Ht,!0),Rt=!0)}(t,e,n):"touchmove"===i?function(t,i,e){var n=function(t){(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons)&&Ft(t,i)};t["_leaflet_touchmove"+e]=n,t.addEventListener(kt,n,!1)}(t,e,n):"touchend"===i&&function(t,i,e){var n=function(t){Ft(t,i)};t["_leaflet_touchend"+e]=n,t.addEventListener(It,n,!1),t.addEventListener(At,n,!1)}(t,e,n),this}function jt(t){Ot[t.pointerId]=t,Dt++}function Wt(t){Ot[t.pointerId]&&(Ot[t.pointerId]=t)}function Ht(t){delete Ot[t.pointerId],Dt--}function Ft(t,i){for(var e in t.touches=[],Ot)t.touches.push(Ot[e]);t.changedTouches=[t],i(t)}var Ut=xt?"MSPointerDown":wt?"pointerdown":"touchstart",Vt=xt?"MSPointerUp":wt?"pointerup":"touchend",qt="_leaflet_";function Gt(t,i,e){var n,o,s=!1,r=250;function a(t){var i;if(wt){if(!tt||"mouse"===t.pointerType)return;i=Dt}else i=t.touches.length;if(!(i>1)){var e=Date.now(),a=e-(n||e);o=t.touches?t.touches[0]:t,s=a>0&&a<=r,n=e}}function h(t){if(s&&!o.cancelBubble){if(wt){if(!tt||"mouse"===t.pointerType)return;var e,r,a={};for(r in o)e=o[r],a[r]=e&&e.bind?e.bind(o):e;o=a}o.type="dblclick",i(o),n=null}}return t[qt+Ut+e]=a,t[qt+Vt+e]=h,t[qt+"dblclick"+e]=i,t.addEventListener(Ut,a,!1),t.addEventListener(Vt,h,!1),t.addEventListener("dblclick",i,!1),this}function Kt(t,i){var e=t[qt+Ut+i],n=t[qt+Vt+i],o=t[qt+"dblclick"+i];return t.removeEventListener(Ut,e,!1),t.removeEventListener(Vt,n,!1),tt||t.removeEventListener("dblclick",o,!1),this}function Yt(t,i,e,n){if("object"==typeof i)for(var o in i)$t(t,o,i[o],e);else for(var s=0,r=(i=_(i)).length;s<r;s++)$t(t,i[s],e,n);return this}var Xt="_leaflet_events";function Jt(t,i,e,n){if("object"==typeof i)for(var o in i)Qt(t,o,i[o],e);else if(i)for(var s=0,r=(i=_(i)).length;s<r;s++)Qt(t,i[s],e,n);else{for(var a in t[Xt])Qt(t,a,t[Xt][a]);delete t[Xt]}return this}function $t(t,i,e,n){var o=i+r(e)+(n?"_"+r(n):"");if(t[Xt]&&t[Xt][o])return this;var s=function(i){return e.call(n||t,i||window.event)},a=s;wt&&0===i.indexOf("touch")?Nt(t,i,s,o):!Lt||"dblclick"!==i||!Gt||wt&&at?"addEventListener"in t?"mousewheel"===i?t.addEventListener("onwheel"in t?"wheel":"mousewheel",s,!1):"mouseenter"===i||"mouseleave"===i?(s=function(i){i=i||window.event,_i(t,i)&&a(i)},t.addEventListener("mouseenter"===i?"mouseover":"mouseout",s,!1)):("click"===i&&et&&(s=function(t){!function(t,i){var e=t.timeStamp||t.originalEvent&&t.originalEvent.timeStamp,n=hi&&e-hi;if(n&&n>100&&n<500||t.target._simulatedClick&&!t._simulated)return void oi(t);hi=e,i(t)}(t,a)}),t.addEventListener(i,s,!1)):"attachEvent"in t&&t.attachEvent("on"+i,s):Gt(t,s,o),t[Xt]=t[Xt]||{},t[Xt][o]=s}function Qt(t,i,e,n){var o=i+r(e)+(n?"_"+r(n):""),s=t[Xt]&&t[Xt][o];if(!s)return this;wt&&0===i.indexOf("touch")?function(t,i,e){var n=t["_leaflet_"+i+e];"touchstart"===i?t.removeEventListener(Et,n,!1):"touchmove"===i?t.removeEventListener(kt,n,!1):"touchend"===i&&(t.removeEventListener(It,n,!1),t.removeEventListener(At,n,!1))}(t,i,o):!Lt||"dblclick"!==i||!Kt||wt&&at?"removeEventListener"in t?"mousewheel"===i?t.removeEventListener("onwheel"in t?"wheel":"mousewheel",s,!1):t.removeEventListener("mouseenter"===i?"mouseover":"mouseleave"===i?"mouseout":i,s,!1):"detachEvent"in t&&t.detachEvent("on"+i,s):Kt(t,o),t[Xt][o]=null}function ti(t){return t.stopPropagation?t.stopPropagation():t.originalEvent?t.originalEvent._stopped=!0:t.cancelBubble=!0,ci(t),this}function ii(t){return $t(t,"mousewheel",ti),this}function ei(t){return Yt(t,"mousedown touchstart dblclick",ti),$t(t,"click",li),this}function ni(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this}function oi(t){return ni(t),ti(t),this}function si(t,i){if(!i)return new k(t.clientX,t.clientY);var e=i.getBoundingClientRect(),n=e.width/i.offsetWidth||1,o=e.height/i.offsetHeight||1;return new k(t.clientX/n-e.left-i.clientLeft,t.clientY/o-e.top-i.clientTop)}var ri=_t&&at?2*window.devicePixelRatio:ht?window.devicePixelRatio:1;function ai(t){return tt?t.wheelDeltaY/2:t.deltaY&&0===t.deltaMode?-t.deltaY/ri:t.deltaY&&1===t.deltaMode?20*-t.deltaY:t.deltaY&&2===t.deltaMode?60*-t.deltaY:t.deltaX||t.deltaZ?0:t.wheelDelta?(t.wheelDeltaY||t.wheelDelta)/2:t.detail&&Math.abs(t.detail)<32765?20*-t.detail:t.detail?t.detail/-32765*60:0}var hi,ui={};function li(t){ui[t.type]=!0}function ci(t){var i=ui[t.type];return ui[t.type]=!1,i}function _i(t,i){var e=i.relatedTarget;if(!e)return!0;try{for(;e&&e!==t;)e=e.parentNode}catch(t){return!1}return e!==t}var di,pi,mi,fi,gi,vi=(Object.freeze||Object)({on:Yt,off:Jt,stopPropagation:ti,disableScrollPropagation:ii,disableClickPropagation:ei,preventDefault:ni,stop:oi,getMousePosition:si,getWheelDelta:ai,fakeStop:li,skipped:ci,isExternalTarget:_i,addListener:Yt,removeListener:Jt}),yi=Bi(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),xi=Bi(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),wi="webkitTransition"===xi||"OTransition"===xi?xi+"End":"transitionend";function Li(t){return"string"==typeof t?document.getElementById(t):t}function Pi(t,i){var e=t.style[i]||t.currentStyle&&t.currentStyle[i];if((!e||"auto"===e)&&document.defaultView){var n=document.defaultView.getComputedStyle(t,null);e=n?n[i]:null}return"auto"===e?null:e}function bi(t,i,e){var n=document.createElement(t);return n.className=i||"",e&&e.appendChild(n),n}function Ti(t){var i=t.parentNode;i&&i.removeChild(t)}function zi(t){for(;t.firstChild;)t.removeChild(t.firstChild)}function Mi(t){var i=t.parentNode;i.lastChild!==t&&i.appendChild(t)}function Ci(t){var i=t.parentNode;i.firstChild!==t&&i.insertBefore(t,i.firstChild)}function Zi(t,i){if(void 0!==t.classList)return t.classList.contains(i);var e=Ii(t);return e.length>0&&new RegExp("(^|\\s)"+i+"(\\s|$)").test(e)}function Si(t,i){if(void 0!==t.classList)for(var e=_(i),n=0,o=e.length;n<o;n++)t.classList.add(e[n]);else if(!Zi(t,i)){var s=Ii(t);ki(t,(s?s+" ":"")+i)}}function Ei(t,i){void 0!==t.classList?t.classList.remove(i):ki(t,c((" "+Ii(t)+" ").replace(" "+i+" "," ")))}function ki(t,i){void 0===t.className.baseVal?t.className=i:t.className.baseVal=i}function Ii(t){return void 0===t.className.baseVal?t.className:t.className.baseVal}function Ai(t,i){"opacity"in t.style?t.style.opacity=i:"filter"in t.style&&function(t,i){var e=!1,n="DXImageTransform.Microsoft.Alpha";try{e=t.filters.item(n)}catch(t){if(1===i)return}i=Math.round(100*i),e?(e.Enabled=100!==i,e.Opacity=i):t.style.filter+=" progid:"+n+"(opacity="+i+")"}(t,i)}function Bi(t){for(var i=document.documentElement.style,e=0;e<t.length;e++)if(t[e]in i)return t[e];return!1}function Oi(t,i,e){var n=i||new k(0,0);t.style[yi]=(dt?"translate("+n.x+"px,"+n.y+"px)":"translate3d("+n.x+"px,"+n.y+"px,0)")+(e?" scale("+e+")":"")}function Ri(t,i){t._leaflet_pos=i,ft?Oi(t,i):(t.style.left=i.x+"px",t.style.top=i.y+"px")}function Di(t){return t._leaflet_pos||new k(0,0)}if("onselectstart"in document)di=function(){Yt(window,"selectstart",ni)},pi=function(){Jt(window,"selectstart",ni)};else{var Ni=Bi(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);di=function(){if(Ni){var t=document.documentElement.style;mi=t[Ni],t[Ni]="none"}},pi=function(){Ni&&(document.documentElement.style[Ni]=mi,mi=void 0)}}function ji(){Yt(window,"dragstart",ni)}function Wi(){Jt(window,"dragstart",ni)}function Hi(t){for(;-1===t.tabIndex;)t=t.parentNode;t.style&&(Fi(),fi=t,gi=t.style.outline,t.style.outline="none",Yt(window,"keydown",Fi))}function Fi(){fi&&(fi.style.outline=gi,fi=void 0,gi=void 0,Jt(window,"keydown",Fi))}var Ui=(Object.freeze||Object)({TRANSFORM:yi,TRANSITION:xi,TRANSITION_END:wi,get:Li,getStyle:Pi,create:bi,remove:Ti,empty:zi,toFront:Mi,toBack:Ci,hasClass:Zi,addClass:Si,removeClass:Ei,setClass:ki,getClass:Ii,setOpacity:Ai,testProp:Bi,setTransform:Oi,setPosition:Ri,getPosition:Di,disableTextSelection:di,enableTextSelection:pi,disableImageDrag:ji,enableImageDrag:Wi,preventOutline:Hi,restoreOutline:Fi}),Vi=E.extend({run:function(t,i,e,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=e||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=Di(t),this._offset=i.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(!0),this._complete())},_animate:function(){this._animId=z(this._animate,this),this._step()},_step:function(t){var i=+new Date-this._startTime,e=1e3*this._duration;i<e?this._runFrame(this._easeOut(i/e),t):(this._runFrame(1),this._complete())},_runFrame:function(t,i){var e=this._startPos.add(this._offset.multiplyBy(t));i&&e._round(),Ri(this._el,e),this.fire("step")},_complete:function(){M(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),qi=E.extend({options:{crs:G,center:void 0,zoom:void 0,minZoom:void 0,maxZoom:void 0,layers:[],maxBounds:void 0,renderer:void 0,zoomAnimation:!0,zoomAnimationThreshold:4,fadeAnimation:!0,markerZoomAnimation:!0,transform3DLimit:8388608,zoomSnap:1,zoomDelta:1,trackResize:!0},initialize:function(t,i){i=d(this,i),this._initContainer(t),this._initLayout(),this._onResize=o(this._onResize,this),this._initEvents(),i.maxBounds&&this.setMaxBounds(i.maxBounds),void 0!==i.zoom&&(this._zoom=this._limitZoom(i.zoom)),i.center&&void 0!==i.zoom&&this.setView(j(i.center),i.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._sizeChanged=!0,this.callInitHooks(),this._zoomAnimated=xi&&ft&&!Pt&&this.options.zoomAnimation,this._zoomAnimated&&(this._createAnimProxy(),Yt(this._proxy,wi,this._catchTransitionEnd,this)),this._addLayers(this.options.layers)},setView:function(t,i,n){if((i=void 0===i?this._zoom:this._limitZoom(i),t=this._limitCenter(j(t),i,this.options.maxBounds),n=n||{},this._stop(),this._loaded&&!n.reset&&!0!==n)&&(void 0!==n.animate&&(n.zoom=e({animate:n.animate},n.zoom),n.pan=e({animate:n.animate,duration:n.duration},n.pan)),this._zoom!==i?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,i,n.zoom):this._tryAnimatedPan(t,n.pan)))return clearTimeout(this._sizeTimer),this;return this._resetView(t,i),this},setZoom:function(t,i){return this._loaded?this.setView(this.getCenter(),t,{zoom:i}):(this._zoom=t,this)},zoomIn:function(t,i){return t=t||(ft?this.options.zoomDelta:1),this.setZoom(this._zoom+t,i)},zoomOut:function(t,i){return t=t||(ft?this.options.zoomDelta:1),this.setZoom(this._zoom-t,i)},setZoomAround:function(t,i,e){var n=this.getZoomScale(i),o=this.getSize().divideBy(2),s=(t instanceof k?t:this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1-1/n),r=this.containerPointToLatLng(o.add(s));return this.setView(r,i,{zoom:e})},_getBoundsCenterZoom:function(t,i){i=i||{},t=t.getBounds?t.getBounds():D(t);var e=A(i.paddingTopLeft||i.padding||[0,0]),n=A(i.paddingBottomRight||i.padding||[0,0]),o=this.getBoundsZoom(t,!1,e.add(n));if((o="number"==typeof i.maxZoom?Math.min(i.maxZoom,o):o)===1/0)return{center:t.getCenter(),zoom:o};var s=n.subtract(e).divideBy(2),r=this.project(t.getSouthWest(),o),a=this.project(t.getNorthEast(),o);return{center:this.unproject(r.add(a).divideBy(2).add(s),o),zoom:o}},fitBounds:function(t,i){if(!(t=D(t)).isValid())throw new Error("Bounds are not valid.");var e=this._getBoundsCenterZoom(t,i);return this.setView(e.center,e.zoom,i)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,i){return this.setView(t,this._zoom,{pan:i})},panBy:function(t,i){if(t=A(t).round(),i=i||{},!t.x&&!t.y)return this.fire("moveend");if(!0!==i.animate&&!this.getSize().contains(t))return this._resetView(this.unproject(this.project(this.getCenter()).add(t)),this.getZoom()),this;if(this._panAnim||(this._panAnim=new Vi,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),i.noMoveStart||this.fire("movestart"),!1!==i.animate){Si(this._mapPane,"leaflet-pan-anim");var e=this._getMapPanePos().subtract(t).round();this._panAnim.run(this._mapPane,e,i.duration||.25,i.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},flyTo:function(t,i,e){if(!1===(e=e||{}).animate||!ft)return this.setView(t,i,e);this._stop();var n=this.project(this.getCenter()),o=this.project(t),s=this.getSize(),r=this._zoom;t=j(t),i=void 0===i?r:i;var a=Math.max(s.x,s.y),h=a*this.getZoomScale(r,i),u=o.distanceTo(n)||1,l=1.42,c=l*l;function _(t){var i=(h*h-a*a+(t?-1:1)*c*c*u*u)/(2*(t?h:a)*c*u),e=Math.sqrt(i*i+1)-i;return e<1e-9?-18:Math.log(e)}function d(t){return(Math.exp(t)-Math.exp(-t))/2}function p(t){return(Math.exp(t)+Math.exp(-t))/2}var m=_(0);function f(t){return a*(p(m)*(d(i=m+l*t)/p(i))-d(m))/c;var i}var g=Date.now(),v=(_(1)-m)/l,y=e.duration?1e3*e.duration:1e3*v*.8;return this._moveStart(!0,e.noMoveStart),function e(){var s=(Date.now()-g)/y,h=function(t){return 1-Math.pow(1-t,1.5)}(s)*v;s<=1?(this._flyToFrame=z(e,this),this._move(this.unproject(n.add(o.subtract(n).multiplyBy(f(h)/u)),r),this.getScaleZoom(a/function(t){return a*(p(m)/p(m+l*t))}(h),r),{flyTo:!0})):this._move(t,i)._moveEnd(!0)}.call(this),this},flyToBounds:function(t,i){var e=this._getBoundsCenterZoom(t,i);return this.flyTo(e.center,e.zoom,i)},setMaxBounds:function(t){return(t=D(t)).isValid()?(this.options.maxBounds&&this.off("moveend",this._panInsideMaxBounds),this.options.maxBounds=t,this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds)):(this.options.maxBounds=null,this.off("moveend",this._panInsideMaxBounds))},setMinZoom:function(t){var i=this.options.minZoom;return this.options.minZoom=t,this._loaded&&i!==t&&(this.fire("zoomlevelschange"),this.getZoom()<this.options.minZoom)?this.setZoom(t):this},setMaxZoom:function(t){var i=this.options.maxZoom;return this.options.maxZoom=t,this._loaded&&i!==t&&(this.fire("zoomlevelschange"),this.getZoom()>this.options.maxZoom)?this.setZoom(t):this},panInsideBounds:function(t,i){this._enforcingBounds=!0;var e=this.getCenter(),n=this._limitCenter(e,this._zoom,D(t));return e.equals(n)||this.panTo(n,i),this._enforcingBounds=!1,this},invalidateSize:function(t){if(!this._loaded)return this;t=e({animate:!1,pan:!0},!0===t?{animate:!0}:t);var i=this.getSize();this._sizeChanged=!0,this._lastCenter=null;var n=this.getSize(),s=i.divideBy(2).round(),r=n.divideBy(2).round(),a=s.subtract(r);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:i,newSize:n})):this},stop:function(){return this.setZoom(this._limitZoom(this._zoom)),this.options.zoomSnap||this.fire("viewreset"),this._stop()},locate:function(t){if(t=this._locateOptions=e({timeout:1e4,watch:!1},t),!("geolocation"in navigator))return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var i=o(this._handleGeolocationResponse,this),n=o(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(i,n,t):navigator.geolocation.getCurrentPosition(i,n,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var i=t.code,e=t.message||(1===i?"permission denied":2===i?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:i,message:"Geolocation error: "+e+"."})},_handleGeolocationResponse:function(t){var i=new N(t.coords.latitude,t.coords.longitude),e=i.toBounds(t.coords.accuracy),n=this._locateOptions;if(n.setView){var o=this.getBoundsZoom(e);this.setView(i,n.maxZoom?Math.min(o,n.maxZoom):o)}var s={latlng:i,bounds:e,timestamp:t.timestamp};for(var r in t.coords)"number"==typeof t.coords[r]&&(s[r]=t.coords[r]);this.fire("locationfound",s)},addHandler:function(t,i){if(!i)return this;var e=this[t]=new i(this);return this._handlers.push(e),this.options[t]&&e.enable(),this},remove:function(){if(this._initEvents(!0),this._containerId!==this._container._leaflet_id)throw new Error("Map container is being reused by another instance");try{delete this._container._leaflet_id,delete this._containerId}catch(t){this._container._leaflet_id=void 0,this._containerId=void 0}var t;for(t in void 0!==this._locationWatchId&&this.stopLocate(),this._stop(),Ti(this._mapPane),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this._loaded&&this.fire("unload"),this._layers)this._layers[t].remove();for(t in this._panes)Ti(this._panes[t]);return this._layers=[],this._panes=[],delete this._mapPane,delete this._renderer,this},createPane:function(t,i){var e=bi("div","leaflet-pane"+(t?" leaflet-"+t.replace("Pane","")+"-pane":""),i||this._mapPane);return t&&(this._panes[t]=e),e},getCenter:function(){return this._checkIfLoaded(),this._lastCenter&&!this._moved()?this._lastCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds();return new R(this.unproject(t.getBottomLeft()),this.unproject(t.getTopRight()))},getMinZoom:function(){return void 0===this.options.minZoom?this._layersMinZoom||0:this.options.minZoom},getMaxZoom:function(){return void 0===this.options.maxZoom?void 0===this._layersMaxZoom?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,i,e){t=D(t),e=A(e||[0,0]);var n=this.getZoom()||0,o=this.getMinZoom(),s=this.getMaxZoom(),r=t.getNorthWest(),a=t.getSouthEast(),h=this.getSize().subtract(e),u=O(this.project(a,n),this.project(r,n)).getSize(),l=ft?this.options.zoomSnap:1,c=h.x/u.x,_=h.y/u.y,d=i?Math.max(c,_):Math.min(c,_);return n=this.getScaleZoom(d,n),l&&(n=Math.round(n/(l/100))*(l/100),n=i?Math.ceil(n/l)*l:Math.floor(n/l)*l),Math.max(o,Math.min(s,n))},getSize:function(){return this._size&&!this._sizeChanged||(this._size=new k(this._container.clientWidth||0,this._container.clientHeight||0),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(t,i){var e=this._getTopLeftPoint(t,i);return new B(e,e.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._pixelOrigin},getPixelWorldBounds:function(t){return this.options.crs.getProjectedBounds(void 0===t?this.getZoom():t)},getPane:function(t){return"string"==typeof t?this._panes[t]:t},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t,i){var e=this.options.crs;return i=void 0===i?this._zoom:i,e.scale(t)/e.scale(i)},getScaleZoom:function(t,i){var e=this.options.crs;i=void 0===i?this._zoom:i;var n=e.zoom(t*e.scale(i));return isNaN(n)?1/0:n},project:function(t,i){return i=void 0===i?this._zoom:i,this.options.crs.latLngToPoint(j(t),i)},unproject:function(t,i){return i=void 0===i?this._zoom:i,this.options.crs.pointToLatLng(A(t),i)},layerPointToLatLng:function(t){var i=A(t).add(this.getPixelOrigin());return this.unproject(i)},latLngToLayerPoint:function(t){return this.project(j(t))._round()._subtract(this.getPixelOrigin())},wrapLatLng:function(t){return this.options.crs.wrapLatLng(j(t))},wrapLatLngBounds:function(t){return this.options.crs.wrapLatLngBounds(D(t))},distance:function(t,i){return this.options.crs.distance(j(t),j(i))},containerPointToLayerPoint:function(t){return A(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return A(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var i=this.containerPointToLayerPoint(A(t));return this.layerPointToLatLng(i)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(j(t)))},mouseEventToContainerPoint:function(t){return si(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var i=this._container=Li(t);if(!i)throw new Error("Map container not found.");if(i._leaflet_id)throw new Error("Map container is already initialized.");Yt(i,"scroll",this._onScroll,this),this._containerId=r(i)},_initLayout:function(){var t=this._container;this._fadeAnimated=this.options.fadeAnimation&&ft,Si(t,"leaflet-container"+(Lt?" leaflet-touch":"")+(Tt?" leaflet-retina":"")+(Q?" leaflet-oldie":"")+(ut?" leaflet-safari":"")+(this._fadeAnimated?" leaflet-fade-anim":""));var i=Pi(t,"position");"absolute"!==i&&"relative"!==i&&"fixed"!==i&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._paneRenderers={},this._mapPane=this.createPane("mapPane",this._container),Ri(this._mapPane,new k(0,0)),this.createPane("tilePane"),this.createPane("shadowPane"),this.createPane("overlayPane"),this.createPane("markerPane"),this.createPane("tooltipPane"),this.createPane("popupPane"),this.options.markerZoomAnimation||(Si(t.markerPane,"leaflet-zoom-hide"),Si(t.shadowPane,"leaflet-zoom-hide"))},_resetView:function(t,i){Ri(this._mapPane,new k(0,0));var e=!this._loaded;this._loaded=!0,i=this._limitZoom(i),this.fire("viewprereset");var n=this._zoom!==i;this._moveStart(n,!1)._move(t,i)._moveEnd(n),this.fire("viewreset"),e&&this.fire("load")},_moveStart:function(t,i){return t&&this.fire("zoomstart"),i||this.fire("movestart"),this},_move:function(t,i,e){void 0===i&&(i=this._zoom);var n=this._zoom!==i;return this._zoom=i,this._lastCenter=t,this._pixelOrigin=this._getNewPixelOrigin(t),(n||e&&e.pinch)&&this.fire("zoom",e),this.fire("move",e)},_moveEnd:function(t){return t&&this.fire("zoomend"),this.fire("moveend")},_stop:function(){return M(this._flyToFrame),this._panAnim&&this._panAnim.stop(),this},_rawPanBy:function(t){Ri(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_panInsideMaxBounds:function(){this._enforcingBounds||this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(t){this._targets={},this._targets[r(this._container)]=this;var i=t?Jt:Yt;i(this._container,"click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress",this._handleDOMEvent,this),this.options.trackResize&&i(window,"resize",this._onResize,this),ft&&this.options.transform3DLimit&&(t?this.off:this.on).call(this,"moveend",this._onMoveEnd)},_onResize:function(){M(this._resizeRequest),this._resizeRequest=z(function(){this.invalidateSize({debounceMoveend:!0})},this)},_onScroll:function(){this._container.scrollTop=0,this._container.scrollLeft=0},_onMoveEnd:function(){var t=this._getMapPanePos();Math.max(Math.abs(t.x),Math.abs(t.y))>=this.options.transform3DLimit&&this._resetView(this.getCenter(),this.getZoom())},_findEventTargets:function(t,i){for(var e,n=[],o="mouseout"===i||"mouseover"===i,s=t.target||t.srcElement,a=!1;s;){if((e=this._targets[r(s)])&&("click"===i||"preclick"===i)&&!t._simulated&&this._draggableMoved(e)){a=!0;break}if(e&&e.listens(i,!0)){if(o&&!_i(s,t))break;if(n.push(e),o)break}if(s===this._container)break;s=s.parentNode}return n.length||a||o||!_i(s,t)||(n=[this]),n},_handleDOMEvent:function(t){if(this._loaded&&!ci(t)){var i=t.type;"mousedown"!==i&&"keypress"!==i||Hi(t.target||t.srcElement),this._fireDOMEvent(t,i)}},_mouseEvents:["click","dblclick","mouseover","mouseout","contextmenu"],_fireDOMEvent:function(t,i,n){if("click"===t.type){var o=e({},t);o.type="preclick",this._fireDOMEvent(o,o.type,n)}if(!t._stopped&&(n=(n||[]).concat(this._findEventTargets(t,i))).length){var s=n[0];"contextmenu"===i&&s.listens(i,!0)&&ni(t);var r={originalEvent:t};if("keypress"!==t.type){var a=s.getLatLng&&(!s._radius||s._radius<=10);r.containerPoint=a?this.latLngToContainerPoint(s.getLatLng()):this.mouseEventToContainerPoint(t),r.layerPoint=this.containerPointToLayerPoint(r.containerPoint),r.latlng=a?s.getLatLng():this.layerPointToLatLng(r.layerPoint)}for(var h=0;h<n.length;h++)if(n[h].fire(i,r,!0),r.originalEvent._stopped||!1===n[h].options.bubblingMouseEvents&&-1!==v(this._mouseEvents,i))return}},_draggableMoved:function(t){return(t=t.dragging&&t.dragging.enabled()?t:this).dragging&&t.dragging.moved()||this.boxZoom&&this.boxZoom.moved()},_clearHandlers:function(){for(var t=0,i=this._handlers.length;t<i;t++)this._handlers[t].disable()},whenReady:function(t,i){return this._loaded?t.call(i||this,{target:this}):this.on("load",t,i),this},_getMapPanePos:function(){return Di(this._mapPane)||new k(0,0)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(t,i){return(t&&void 0!==i?this._getNewPixelOrigin(t,i):this.getPixelOrigin()).subtract(this._getMapPanePos())},_getNewPixelOrigin:function(t,i){var e=this.getSize()._divideBy(2);return this.project(t,i)._subtract(e)._add(this._getMapPanePos())._round()},_latLngToNewLayerPoint:function(t,i,e){var n=this._getNewPixelOrigin(e,i);return this.project(t,i)._subtract(n)},_latLngBoundsToNewLayerBounds:function(t,i,e){var n=this._getNewPixelOrigin(e,i);return O([this.project(t.getSouthWest(),i)._subtract(n),this.project(t.getNorthWest(),i)._subtract(n),this.project(t.getSouthEast(),i)._subtract(n),this.project(t.getNorthEast(),i)._subtract(n)])},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,i,e){if(!e)return t;var n=this.project(t,i),o=this.getSize().divideBy(2),s=new B(n.subtract(o),n.add(o)),r=this._getBoundsOffset(s,e,i);return r.round().equals([0,0])?t:this.unproject(n.add(r),i)},_limitOffset:function(t,i){if(!i)return t;var e=this.getPixelBounds(),n=new B(e.min.add(t),e.max.add(t));return t.add(this._getBoundsOffset(n,i))},_getBoundsOffset:function(t,i,e){var n=O(this.project(i.getNorthEast(),e),this.project(i.getSouthWest(),e)),o=n.min.subtract(t.min),s=n.max.subtract(t.max);return new k(this._rebound(o.x,-s.x),this._rebound(o.y,-s.y))},_rebound:function(t,i){return t+i>0?Math.round(t-i)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(i))},_limitZoom:function(t){var i=this.getMinZoom(),e=this.getMaxZoom(),n=ft?this.options.zoomSnap:1;return n&&(t=Math.round(t/n)*n),Math.max(i,Math.min(e,t))},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){Ei(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,i){var e=this._getCenterOffset(t)._trunc();return!(!0!==(i&&i.animate)&&!this.getSize().contains(e))&&(this.panBy(e,i),!0)},_createAnimProxy:function(){var t=this._proxy=bi("div","leaflet-proxy leaflet-zoom-animated");this._panes.mapPane.appendChild(t),this.on("zoomanim",function(t){var i=yi,e=this._proxy.style[i];Oi(this._proxy,this.project(t.center,t.zoom),this.getZoomScale(t.zoom,1)),e===this._proxy.style[i]&&this._animatingZoom&&this._onZoomTransitionEnd()},this),this.on("load moveend",function(){var t=this.getCenter(),i=this.getZoom();Oi(this._proxy,this.project(t,i),this.getZoomScale(i,1))},this),this._on("unload",this._destroyAnimProxy,this)},_destroyAnimProxy:function(){Ti(this._proxy),delete this._proxy},_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,i,e){if(this._animatingZoom)return!0;if(e=e||{},!this._zoomAnimated||!1===e.animate||this._nothingToAnimate()||Math.abs(i-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(i),o=this._getCenterOffset(t)._divideBy(1-1/n);return!(!0!==e.animate&&!this.getSize().contains(o))&&(z(function(){this._moveStart(!0,!1)._animateZoom(t,i,!0)},this),!0)},_animateZoom:function(t,i,e,n){this._mapPane&&(e&&(this._animatingZoom=!0,this._animateToCenter=t,this._animateToZoom=i,Si(this._mapPane,"leaflet-zoom-anim")),this.fire("zoomanim",{center:t,zoom:i,noUpdate:n}),setTimeout(o(this._onZoomTransitionEnd,this),250))},_onZoomTransitionEnd:function(){this._animatingZoom&&(this._mapPane&&Ei(this._mapPane,"leaflet-zoom-anim"),this._animatingZoom=!1,this._move(this._animateToCenter,this._animateToZoom),z(function(){this._moveEnd(!0)},this))}});var Gi=Z.extend({options:{position:"topright"},initialize:function(t){d(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var i=this._map;return i&&i.removeControl(this),this.options.position=t,i&&i.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this.remove(),this._map=t;var i=this._container=this.onAdd(t),e=this.getPosition(),n=t._controlCorners[e];return Si(i,"leaflet-control"),-1!==e.indexOf("bottom")?n.insertBefore(i,n.firstChild):n.appendChild(i),this},remove:function(){return this._map?(Ti(this._container),this.onRemove&&this.onRemove(this._map),this._map=null,this):this},_refocusOnMap:function(t){this._map&&t&&t.screenX>0&&t.screenY>0&&this._map.getContainer().focus()}}),Ki=function(t){return new Gi(t)};qi.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.remove(),this},_initControlPos:function(){var t=this._controlCorners={},i="leaflet-",e=this._controlContainer=bi("div",i+"control-container",this._container);function n(n,o){var s=i+n+" "+i+o;t[n+o]=bi("div",s,e)}n("top","left"),n("top","right"),n("bottom","left"),n("bottom","right")},_clearControlPos:function(){for(var t in this._controlCorners)Ti(this._controlCorners[t]);Ti(this._controlContainer),delete this._controlCorners,delete this._controlContainer}});var Yi=Gi.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0,hideSingleBase:!1,sortLayers:!1,sortFunction:function(t,i,e,n){return e<n?-1:n<e?1:0}},initialize:function(t,i,e){for(var n in d(this,e),this._layerControlInputs=[],this._layers=[],this._lastZIndex=0,this._handlingClick=!1,t)this._addLayer(t[n],n);for(n in i)this._addLayer(i[n],n,!0)},onAdd:function(t){this._initLayout(),this._update(),this._map=t,t.on("zoomend",this._checkDisabledLayers,this);for(var i=0;i<this._layers.length;i++)this._layers[i].layer.on("add remove",this._onLayerChange,this);return this._container},addTo:function(t){return Gi.prototype.addTo.call(this,t),this._expandIfNotCollapsed()},onRemove:function(){this._map.off("zoomend",this._checkDisabledLayers,this);for(var t=0;t<this._layers.length;t++)this._layers[t].layer.off("add remove",this._onLayerChange,this)},addBaseLayer:function(t,i){return this._addLayer(t,i),this._map?this._update():this},addOverlay:function(t,i){return this._addLayer(t,i,!0),this._map?this._update():this},removeLayer:function(t){t.off("add remove",this._onLayerChange,this);var i=this._getLayer(r(t));return i&&this._layers.splice(this._layers.indexOf(i),1),this._map?this._update():this},expand:function(){Si(this._container,"leaflet-control-layers-expanded"),this._form.style.height=null;var t=this._map.getSize().y-(this._container.offsetTop+50);return t<this._form.clientHeight?(Si(this._form,"leaflet-control-layers-scrollbar"),this._form.style.height=t+"px"):Ei(this._form,"leaflet-control-layers-scrollbar"),this._checkDisabledLayers(),this},collapse:function(){return Ei(this._container,"leaflet-control-layers-expanded"),this},_initLayout:function(){var t="leaflet-control-layers",i=this._container=bi("div",t),e=this.options.collapsed;i.setAttribute("aria-haspopup",!0),ei(i),ii(i);var n=this._form=bi("form",t+"-list");e&&(this._map.on("click",this.collapse,this),et||Yt(i,{mouseenter:this.expand,mouseleave:this.collapse},this));var o=this._layersLink=bi("a",t+"-toggle",i);o.href="#",o.title="Layers",Lt?(Yt(o,"click",oi),Yt(o,"click",this.expand,this)):Yt(o,"focus",this.expand,this),e||this.expand(),this._baseLayersList=bi("div",t+"-base",n),this._separator=bi("div",t+"-separator",n),this._overlaysList=bi("div",t+"-overlays",n),i.appendChild(n)},_getLayer:function(t){for(var i=0;i<this._layers.length;i++)if(this._layers[i]&&r(this._layers[i].layer)===t)return this._layers[i]},_addLayer:function(t,i,e){this._map&&t.on("add remove",this._onLayerChange,this),this._layers.push({layer:t,name:i,overlay:e}),this.options.sortLayers&&this._layers.sort(o(function(t,i){return this.options.sortFunction(t.layer,i.layer,t.name,i.name)},this)),this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex)),this._expandIfNotCollapsed()},_update:function(){if(!this._container)return this;zi(this._baseLayersList),zi(this._overlaysList),this._layerControlInputs=[];var t,i,e,n,o=0;for(e=0;e<this._layers.length;e++)n=this._layers[e],this._addItem(n),i=i||n.overlay,t=t||!n.overlay,o+=n.overlay?0:1;return this.options.hideSingleBase&&(t=t&&o>1,this._baseLayersList.style.display=t?"":"none"),this._separator.style.display=i&&t?"":"none",this},_onLayerChange:function(t){this._handlingClick||this._update();var i=this._getLayer(r(t.target)),e=i.overlay?"add"===t.type?"overlayadd":"overlayremove":"add"===t.type?"baselayerchange":null;e&&this._map.fire(e,i)},_createRadioElement:function(t,i){var e='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"'+(i?' checked="checked"':"")+"/>",n=document.createElement("div");return n.innerHTML=e,n.firstChild},_addItem:function(t){var i,e=document.createElement("label"),n=this._map.hasLayer(t.layer);t.overlay?((i=document.createElement("input")).type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=n):i=this._createRadioElement("leaflet-base-layers",n),this._layerControlInputs.push(i),i.layerId=r(t.layer),Yt(i,"click",this._onInputClick,this);var o=document.createElement("span");o.innerHTML=" "+t.name;var s=document.createElement("div");return e.appendChild(s),s.appendChild(i),s.appendChild(o),(t.overlay?this._overlaysList:this._baseLayersList).appendChild(e),this._checkDisabledLayers(),e},_onInputClick:function(){var t,i,e=this._layerControlInputs,n=[],o=[];this._handlingClick=!0;for(var s=e.length-1;s>=0;s--)t=e[s],i=this._getLayer(t.layerId).layer,t.checked?n.push(i):t.checked||o.push(i);for(s=0;s<o.length;s++)this._map.hasLayer(o[s])&&this._map.removeLayer(o[s]);for(s=0;s<n.length;s++)this._map.hasLayer(n[s])||this._map.addLayer(n[s]);this._handlingClick=!1,this._refocusOnMap()},_checkDisabledLayers:function(){for(var t,i,e=this._layerControlInputs,n=this._map.getZoom(),o=e.length-1;o>=0;o--)t=e[o],i=this._getLayer(t.layerId).layer,t.disabled=void 0!==i.options.minZoom&&n<i.options.minZoom||void 0!==i.options.maxZoom&&n>i.options.maxZoom},_expandIfNotCollapsed:function(){return this._map&&!this.options.collapsed&&this.expand(),this},_expand:function(){return this.expand()},_collapse:function(){return this.collapse()}}),Xi=Gi.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"&#x2212;",zoomOutTitle:"Zoom out"},onAdd:function(t){var i="leaflet-control-zoom",e=bi("div",i+" leaflet-bar"),n=this.options;return this._zoomInButton=this._createButton(n.zoomInText,n.zoomInTitle,i+"-in",e,this._zoomIn),this._zoomOutButton=this._createButton(n.zoomOutText,n.zoomOutTitle,i+"-out",e,this._zoomOut),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),e},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},disable:function(){return this._disabled=!0,this._updateDisabled(),this},enable:function(){return this._disabled=!1,this._updateDisabled(),this},_zoomIn:function(t){!this._disabled&&this._map._zoom<this._map.getMaxZoom()&&this._map.zoomIn(this._map.options.zoomDelta*(t.shiftKey?3:1))},_zoomOut:function(t){!this._disabled&&this._map._zoom>this._map.getMinZoom()&&this._map.zoomOut(this._map.options.zoomDelta*(t.shiftKey?3:1))},_createButton:function(t,i,e,n,o){var s=bi("a",e,n);return s.innerHTML=t,s.href="#",s.title=i,s.setAttribute("role","button"),s.setAttribute("aria-label",i),ei(s),Yt(s,"click",oi),Yt(s,"click",o,this),Yt(s,"click",this._refocusOnMap,this),s},_updateDisabled:function(){var t=this._map,i="leaflet-disabled";Ei(this._zoomInButton,i),Ei(this._zoomOutButton,i),(this._disabled||t._zoom===t.getMinZoom())&&Si(this._zoomOutButton,i),(this._disabled||t._zoom===t.getMaxZoom())&&Si(this._zoomInButton,i)}});qi.mergeOptions({zoomControl:!0}),qi.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new Xi,this.addControl(this.zoomControl))});var Ji=Gi.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0},onAdd:function(t){var i=bi("div","leaflet-control-scale"),e=this.options;return this._addScales(e,"leaflet-control-scale-line",i),t.on(e.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,i,e){t.metric&&(this._mScale=bi("div",i,e)),t.imperial&&(this._iScale=bi("div",i,e))},_update:function(){var t=this._map,i=t.getSize().y/2,e=t.distance(t.containerPointToLatLng([0,i]),t.containerPointToLatLng([this.options.maxWidth,i]));this._updateScales(e)},_updateScales:function(t){this.options.metric&&t&&this._updateMetric(t),this.options.imperial&&t&&this._updateImperial(t)},_updateMetric:function(t){var i=this._getRoundNum(t),e=i<1e3?i+" m":i/1e3+" km";this._updateScale(this._mScale,e,i/t)},_updateImperial:function(t){var i,e,n,o=3.2808399*t;o>5280?(i=o/5280,e=this._getRoundNum(i),this._updateScale(this._iScale,e+" mi",e/i)):(n=this._getRoundNum(o),this._updateScale(this._iScale,n+" ft",n/o))},_updateScale:function(t,i,e){t.style.width=Math.round(this.options.maxWidth*e)+"px",t.innerHTML=i},_getRoundNum:function(t){var i=Math.pow(10,(Math.floor(t)+"").length-1),e=t/i;return i*(e=e>=10?10:e>=5?5:e>=3?3:e>=2?2:1)}}),$i=Gi.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){d(this,t),this._attributions={}},onAdd:function(t){for(var i in t.attributionControl=this,this._container=bi("div","leaflet-control-attribution"),ei(this._container),t._layers)t._layers[i].getAttribution&&this.addAttribution(t._layers[i].getAttribution());return this._update(),this._container},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):this},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):this},_update:function(){if(this._map){var t=[];for(var i in this._attributions)this._attributions[i]&&t.push(i);var e=[];this.options.prefix&&e.push(this.options.prefix),t.length&&e.push(t.join(", ")),this._container.innerHTML=e.join(" | ")}}});qi.mergeOptions({attributionControl:!0}),qi.addInitHook(function(){this.options.attributionControl&&(new $i).addTo(this)});Gi.Layers=Yi,Gi.Zoom=Xi,Gi.Scale=Ji,Gi.Attribution=$i,Ki.layers=function(t,i,e){return new Yi(t,i,e)},Ki.zoom=function(t){return new Xi(t)},Ki.scale=function(t){return new Ji(t)},Ki.attribution=function(t){return new $i(t)};var Qi=Z.extend({initialize:function(t){this._map=t},enable:function(){return this._enabled?this:(this._enabled=!0,this.addHooks(),this)},disable:function(){return this._enabled?(this._enabled=!1,this.removeHooks(),this):this},enabled:function(){return!!this._enabled}});Qi.addTo=function(t,i){return t.addHandler(i,this),this};var te,ie={Events:S},ee=Lt?"touchstart mousedown":"mousedown",ne={mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},oe={mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"},se=E.extend({options:{clickTolerance:3},initialize:function(t,i,e,n){d(this,n),this._element=t,this._dragStartTarget=i||t,this._preventOutline=e},enable:function(){this._enabled||(Yt(this._dragStartTarget,ee,this._onDown,this),this._enabled=!0)},disable:function(){this._enabled&&(se._dragging===this&&this.finishDrag(),Jt(this._dragStartTarget,ee,this._onDown,this),this._enabled=!1,this._moved=!1)},_onDown:function(t){if(!t._simulated&&this._enabled&&(this._moved=!1,!Zi(this._element,"leaflet-zoom-anim")&&!(se._dragging||t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||(se._dragging=this,this._preventOutline&&Hi(this._element),ji(),di(),this._moving)))){this.fire("down");var i=t.touches?t.touches[0]:t;this._startPoint=new k(i.clientX,i.clientY),Yt(document,oe[t.type],this._onMove,this),Yt(document,ne[t.type],this._onUp,this)}},_onMove:function(t){if(!t._simulated&&this._enabled)if(t.touches&&t.touches.length>1)this._moved=!0;else{var i=t.touches&&1===t.touches.length?t.touches[0]:t,e=new k(i.clientX,i.clientY).subtract(this._startPoint);(e.x||e.y)&&(Math.abs(e.x)+Math.abs(e.y)<this.options.clickTolerance||(ni(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=Di(this._element).subtract(e),Si(document.body,"leaflet-dragging"),this._lastTarget=t.target||t.srcElement,window.SVGElementInstance&&this._lastTarget instanceof SVGElementInstance&&(this._lastTarget=this._lastTarget.correspondingUseElement),Si(this._lastTarget,"leaflet-drag-target")),this._newPos=this._startPos.add(e),this._moving=!0,M(this._animRequest),this._lastEvent=t,this._animRequest=z(this._updatePosition,this,!0)))}},_updatePosition:function(){var t={originalEvent:this._lastEvent};this.fire("predrag",t),Ri(this._element,this._newPos),this.fire("drag",t)},_onUp:function(t){!t._simulated&&this._enabled&&this.finishDrag()},finishDrag:function(){for(var t in Ei(document.body,"leaflet-dragging"),this._lastTarget&&(Ei(this._lastTarget,"leaflet-drag-target"),this._lastTarget=null),oe)Jt(document,oe[t],this._onMove,this),Jt(document,ne[t],this._onUp,this);Wi(),pi(),this._moved&&this._moving&&(M(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1,se._dragging=!1}});function re(t,i){if(!i||!t.length)return t.slice();var e=i*i;return t=function(t,i){var e=t.length,n=new(typeof Uint8Array!=void 0+""?Uint8Array:Array)(e);n[0]=n[e-1]=1,function t(i,e,n,o,s){var r,a,h,u=0;for(a=o+1;a<=s-1;a++)(h=ce(i[a],i[o],i[s],!0))>u&&(r=a,u=h);u>n&&(e[r]=1,t(i,e,n,o,r),t(i,e,n,r,s))}(t,n,i,0,e-1);var o,s=[];for(o=0;o<e;o++)n[o]&&s.push(t[o]);return s}(t=function(t,i){for(var e=[t[0]],n=1,o=0,s=t.length;n<s;n++)r=t[n],a=t[o],void 0,void 0,h=a.x-r.x,u=a.y-r.y,h*h+u*u>i&&(e.push(t[n]),o=n);var r,a,h,u;o<s-1&&e.push(t[s-1]);return e}(t,e),e)}function ae(t,i,e){return Math.sqrt(ce(t,i,e,!0))}function he(t,i,e,n,o){var s,r,a,h=n?te:le(t,e),u=le(i,e);for(te=u;;){if(!(h|u))return[t,i];if(h&u)return!1;a=le(r=ue(t,i,s=h||u,e,o),e),s===h?(t=r,h=a):(i=r,u=a)}}function ue(t,i,e,n,o){var s,r,a=i.x-t.x,h=i.y-t.y,u=n.min,l=n.max;return 8&e?(s=t.x+a*(l.y-t.y)/h,r=l.y):4&e?(s=t.x+a*(u.y-t.y)/h,r=u.y):2&e?(s=l.x,r=t.y+h*(l.x-t.x)/a):1&e&&(s=u.x,r=t.y+h*(u.x-t.x)/a),new k(s,r,o)}function le(t,i){var e=0;return t.x<i.min.x?e|=1:t.x>i.max.x&&(e|=2),t.y<i.min.y?e|=4:t.y>i.max.y&&(e|=8),e}function ce(t,i,e,n){var o,s=i.x,r=i.y,a=e.x-s,h=e.y-r,u=a*a+h*h;return u>0&&((o=((t.x-s)*a+(t.y-r)*h)/u)>1?(s=e.x,r=e.y):o>0&&(s+=a*o,r+=h*o)),a=t.x-s,h=t.y-r,n?a*a+h*h:new k(s,r)}function _e(t){return!g(t[0])||"object"!=typeof t[0][0]&&void 0!==t[0][0]}function de(t){return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."),_e(t)}var pe=(Object.freeze||Object)({simplify:re,pointToSegmentDistance:ae,closestPointOnSegment:function(t,i,e){return ce(t,i,e)},clipSegment:he,_getEdgeIntersection:ue,_getBitCode:le,_sqClosestPointOnSegment:ce,isFlat:_e,_flat:de});function me(t,i,e){var n,o,s,r,a,h,u,l,c,_=[1,4,2,8];for(o=0,u=t.length;o<u;o++)t[o]._code=le(t[o],i);for(r=0;r<4;r++){for(l=_[r],n=[],o=0,s=(u=t.length)-1;o<u;s=o++)a=t[o],h=t[s],a._code&l?h._code&l||((c=ue(h,a,l,i,e))._code=le(c,i),n.push(c)):(h._code&l&&((c=ue(h,a,l,i,e))._code=le(c,i),n.push(c)),n.push(a));t=n}return t}var fe=(Object.freeze||Object)({clipPolygon:me}),ge={project:function(t){return new k(t.lng,t.lat)},unproject:function(t){return new N(t.y,t.x)},bounds:new B([-180,-90],[180,90])},ve={R:6378137,R_MINOR:6356752.314245179,bounds:new B([-20037508.34279,-15496570.73972],[20037508.34279,18764656.23138]),project:function(t){var i=Math.PI/180,e=this.R,n=t.lat*i,o=this.R_MINOR/e,s=Math.sqrt(1-o*o),r=s*Math.sin(n),a=Math.tan(Math.PI/4-n/2)/Math.pow((1-r)/(1+r),s/2);return n=-e*Math.log(Math.max(a,1e-10)),new k(t.lng*i*e,n)},unproject:function(t){for(var i,e=180/Math.PI,n=this.R,o=this.R_MINOR/n,s=Math.sqrt(1-o*o),r=Math.exp(-t.y/n),a=Math.PI/2-2*Math.atan(r),h=0,u=.1;h<15&&Math.abs(u)>1e-7;h++)i=s*Math.sin(a),i=Math.pow((1-i)/(1+i),s/2),a+=u=Math.PI/2-2*Math.atan(r*i)-a;return new N(a*e,t.x*e/n)}},ye=(Object.freeze||Object)({LonLat:ge,Mercator:ve,SphericalMercator:U}),xe=e({},F,{code:"EPSG:3395",projection:ve,transformation:function(){var t=.5/(Math.PI*ve.R);return q(t,.5,-t,.5)}()}),we=e({},F,{code:"EPSG:4326",projection:ge,transformation:q(1/180,1,-1/180,.5)}),Le=e({},H,{projection:ge,transformation:q(1,0,-1,0),scale:function(t){return Math.pow(2,t)},zoom:function(t){return Math.log(t)/Math.LN2},distance:function(t,i){var e=i.lng-t.lng,n=i.lat-t.lat;return Math.sqrt(e*e+n*n)},infinite:!0});H.Earth=F,H.EPSG3395=xe,H.EPSG3857=G,H.EPSG900913=K,H.EPSG4326=we,H.Simple=Le;var Pe=E.extend({options:{pane:"overlayPane",attribution:null,bubblingMouseEvents:!0},addTo:function(t){return t.addLayer(this),this},remove:function(){return this.removeFrom(this._map||this._mapToAdd)},removeFrom:function(t){return t&&t.removeLayer(this),this},getPane:function(t){return this._map.getPane(t?this.options[t]||t:this.options.pane)},addInteractiveTarget:function(t){return this._map._targets[r(t)]=this,this},removeInteractiveTarget:function(t){return delete this._map._targets[r(t)],this},getAttribution:function(){return this.options.attribution},_layerAdd:function(t){var i=t.target;if(i.hasLayer(this)){if(this._map=i,this._zoomAnimated=i._zoomAnimated,this.getEvents){var e=this.getEvents();i.on(e,this),this.once("remove",function(){i.off(e,this)},this)}this.onAdd(i),this.getAttribution&&i.attributionControl&&i.attributionControl.addAttribution(this.getAttribution()),this.fire("add"),i.fire("layeradd",{layer:this})}}});qi.include({addLayer:function(t){if(!t._layerAdd)throw new Error("The provided object is not a Layer.");var i=r(t);return this._layers[i]?this:(this._layers[i]=t,t._mapToAdd=this,t.beforeAdd&&t.beforeAdd(this),this.whenReady(t._layerAdd,t),this)},removeLayer:function(t){var i=r(t);return this._layers[i]?(this._loaded&&t.onRemove(this),t.getAttribution&&this.attributionControl&&this.attributionControl.removeAttribution(t.getAttribution()),delete this._layers[i],this._loaded&&(this.fire("layerremove",{layer:t}),t.fire("remove")),t._map=t._mapToAdd=null,this):this},hasLayer:function(t){return!!t&&r(t)in this._layers},eachLayer:function(t,i){for(var e in this._layers)t.call(i,this._layers[e]);return this},_addLayers:function(t){for(var i=0,e=(t=t?g(t)?t:[t]:[]).length;i<e;i++)this.addLayer(t[i])},_addZoomLimit:function(t){!isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[r(t)]=t,this._updateZoomLevels())},_removeZoomLimit:function(t){var i=r(t);this._zoomBoundLayers[i]&&(delete this._zoomBoundLayers[i],this._updateZoomLevels())},_updateZoomLevels:function(){var t=1/0,i=-1/0,e=this._getZoomSpan();for(var n in this._zoomBoundLayers){var o=this._zoomBoundLayers[n].options;t=void 0===o.minZoom?t:Math.min(t,o.minZoom),i=void 0===o.maxZoom?i:Math.max(i,o.maxZoom)}this._layersMaxZoom=i===-1/0?void 0:i,this._layersMinZoom=t===1/0?void 0:t,e!==this._getZoomSpan()&&this.fire("zoomlevelschange"),void 0===this.options.maxZoom&&this._layersMaxZoom&&this.getZoom()>this._layersMaxZoom&&this.setZoom(this._layersMaxZoom),void 0===this.options.minZoom&&this._layersMinZoom&&this.getZoom()<this._layersMinZoom&&this.setZoom(this._layersMinZoom)}});var be=Pe.extend({initialize:function(t,i){var e,n;if(d(this,i),this._layers={},t)for(e=0,n=t.length;e<n;e++)this.addLayer(t[e])},addLayer:function(t){var i=this.getLayerId(t);return this._layers[i]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var i=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[i]&&this._map.removeLayer(this._layers[i]),delete this._layers[i],this},hasLayer:function(t){return!!t&&(t in this._layers||this.getLayerId(t)in this._layers)},clearLayers:function(){return this.eachLayer(this.removeLayer,this)},invoke:function(t){var i,e,n=Array.prototype.slice.call(arguments,1);for(i in this._layers)(e=this._layers[i])[t]&&e[t].apply(e,n);return this},onAdd:function(t){this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t)},eachLayer:function(t,i){for(var e in this._layers)t.call(i,this._layers[e]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];return this.eachLayer(t.push,t),t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return r(t)}}),Te=be.extend({addLayer:function(t){return this.hasLayer(t)?this:(t.addEventParent(this),be.prototype.addLayer.call(this,t),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),t.removeEventParent(this),be.prototype.removeLayer.call(this,t),this.fire("layerremove",{layer:t})):this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new R;for(var i in this._layers){var e=this._layers[i];t.extend(e.getBounds?e.getBounds():e.getLatLng())}return t}}),ze=Z.extend({options:{popupAnchor:[0,0],tooltipAnchor:[0,0]},initialize:function(t){d(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,i){var e=this._getIconUrl(t);if(!e){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n=this._createImg(e,i&&"IMG"===i.tagName?i:null);return this._setIconStyles(n,t),n},_setIconStyles:function(t,i){var e=this.options,n=e[i+"Size"];"number"==typeof n&&(n=[n,n]);var o=A(n),s=A("shadow"===i&&e.shadowAnchor||e.iconAnchor||o&&o.divideBy(2,!0));t.className="leaflet-marker-"+i+" "+(e.className||""),s&&(t.style.marginLeft=-s.x+"px",t.style.marginTop=-s.y+"px"),o&&(t.style.width=o.x+"px",t.style.height=o.y+"px")},_createImg:function(t,i){return(i=i||document.createElement("img")).src=t,i},_getIconUrl:function(t){return Tt&&this.options[t+"RetinaUrl"]||this.options[t+"Url"]}});var Me=ze.extend({options:{iconUrl:"marker-icon.png",iconRetinaUrl:"marker-icon-2x.png",shadowUrl:"marker-shadow.png",iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],tooltipAnchor:[16,-28],shadowSize:[41,41]},_getIconUrl:function(t){return Me.imagePath||(Me.imagePath=this._detectIconPath()),(this.options.imagePath||Me.imagePath)+ze.prototype._getIconUrl.call(this,t)},_detectIconPath:function(){var t=bi("div","leaflet-default-icon-path",document.body),i=Pi(t,"background-image")||Pi(t,"backgroundImage");return document.body.removeChild(t),i=null===i||0!==i.indexOf("url")?"":i.replace(/^url\(["']?/,"").replace(/marker-icon\.png["']?\)$/,"")}}),Ce=Qi.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new se(t,t,!0)),this._draggable.on({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).enable(),Si(t,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off({dragstart:this._onDragStart,predrag:this._onPreDrag,drag:this._onDrag,dragend:this._onDragEnd},this).disable(),this._marker._icon&&Ei(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_adjustPan:function(t){var i=this._marker,e=i._map,n=this._marker.options.autoPanSpeed,o=this._marker.options.autoPanPadding,s=L.DomUtil.getPosition(i._icon),r=e.getPixelBounds(),a=e.getPixelOrigin(),h=O(r.min._subtract(a).add(o),r.max._subtract(a).subtract(o));if(!h.contains(s)){var u=A((Math.max(h.max.x,s.x)-h.max.x)/(r.max.x-h.max.x)-(Math.min(h.min.x,s.x)-h.min.x)/(r.min.x-h.min.x),(Math.max(h.max.y,s.y)-h.max.y)/(r.max.y-h.max.y)-(Math.min(h.min.y,s.y)-h.min.y)/(r.min.y-h.min.y)).multiplyBy(n);e.panBy(u,{animate:!1}),this._draggable._newPos._add(u),this._draggable._startPos._add(u),L.DomUtil.setPosition(i._icon,this._draggable._newPos),this._onDrag(t),this._panRequest=z(this._adjustPan.bind(this,t))}},_onDragStart:function(){this._oldLatLng=this._marker.getLatLng(),this._marker.closePopup().fire("movestart").fire("dragstart")},_onPreDrag:function(t){this._marker.options.autoPan&&(M(this._panRequest),this._panRequest=z(this._adjustPan.bind(this,t)))},_onDrag:function(t){var i=this._marker,e=i._shadow,n=Di(i._icon),o=i._map.layerPointToLatLng(n);e&&Ri(e,n),i._latlng=o,t.latlng=o,t.oldLatLng=this._oldLatLng,i.fire("move",t).fire("drag",t)},_onDragEnd:function(t){M(this._panRequest),delete this._oldLatLng,this._marker.fire("moveend").fire("dragend",t)}}),Ze=Pe.extend({options:{icon:new Me,interactive:!0,draggable:!1,autoPan:!1,autoPanPadding:[50,50],autoPanSpeed:10,keyboard:!0,title:"",alt:"",zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250,pane:"markerPane",bubblingMouseEvents:!1},initialize:function(t,i){d(this,i),this._latlng=j(t)},onAdd:function(t){this._zoomAnimated=this._zoomAnimated&&t.options.markerZoomAnimation,this._zoomAnimated&&t.on("zoomanim",this._animateZoom,this),this._initIcon(),this.update()},onRemove:function(t){this.dragging&&this.dragging.enabled()&&(this.options.draggable=!0,this.dragging.removeHooks()),delete this.dragging,this._zoomAnimated&&t.off("zoomanim",this._animateZoom,this),this._removeIcon(),this._removeShadow()},getEvents:function(){return{zoom:this.update,viewreset:this.update}},getLatLng:function(){return this._latlng},setLatLng:function(t){var i=this._latlng;return this._latlng=j(t),this.update(),this.fire("move",{oldLatLng:i,latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update()},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup,this._popup.options),this},getElement:function(){return this._icon},update:function(){if(this._icon&&this._map){var t=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(t)}return this},_initIcon:function(){var t=this.options,i="leaflet-zoom-"+(this._zoomAnimated?"animated":"hide"),e=t.icon.createIcon(this._icon),n=!1;e!==this._icon&&(this._icon&&this._removeIcon(),n=!0,t.title&&(e.title=t.title),"IMG"===e.tagName&&(e.alt=t.alt||"")),Si(e,i),t.keyboard&&(e.tabIndex="0"),this._icon=e,t.riseOnHover&&this.on({mouseover:this._bringToFront,mouseout:this._resetZIndex});var o=t.icon.createShadow(this._shadow),s=!1;o!==this._shadow&&(this._removeShadow(),s=!0),o&&(Si(o,i),o.alt=""),this._shadow=o,t.opacity<1&&this._updateOpacity(),n&&this.getPane().appendChild(this._icon),this._initInteraction(),o&&s&&this.getPane("shadowPane").appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&this.off({mouseover:this._bringToFront,mouseout:this._resetZIndex}),Ti(this._icon),this.removeInteractiveTarget(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&Ti(this._shadow),this._shadow=null},_setPos:function(t){Ri(this._icon,t),this._shadow&&Ri(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var i=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(i)},_initInteraction:function(){if(this.options.interactive&&(Si(this._icon,"leaflet-interactive"),this.addInteractiveTarget(this._icon),Ce)){var t=this.options.draggable;this.dragging&&(t=this.dragging.enabled(),this.dragging.disable()),this.dragging=new Ce(this),t&&this.dragging.enable()}},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){var t=this.options.opacity;Ai(this._icon,t),this._shadow&&Ai(this._shadow,t)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)},_getPopupAnchor:function(){return this.options.icon.options.popupAnchor},_getTooltipAnchor:function(){return this.options.icon.options.tooltipAnchor}});var Se=Pe.extend({options:{stroke:!0,color:"#3388ff",weight:3,opacity:1,lineCap:"round",lineJoin:"round",dashArray:null,dashOffset:null,fill:!1,fillColor:null,fillOpacity:.2,fillRule:"evenodd",interactive:!0,bubblingMouseEvents:!0},beforeAdd:function(t){this._renderer=t.getRenderer(this)},onAdd:function(){this._renderer._initPath(this),this._reset(),this._renderer._addPath(this)},onRemove:function(){this._renderer._removePath(this)},redraw:function(){return this._map&&this._renderer._updatePath(this),this},setStyle:function(t){return d(this,t),this._renderer&&this._renderer._updateStyle(this),this},bringToFront:function(){return this._renderer&&this._renderer._bringToFront(this),this},bringToBack:function(){return this._renderer&&this._renderer._bringToBack(this),this},getElement:function(){return this._path},_reset:function(){this._project(),this._update()},_clickTolerance:function(){return(this.options.stroke?this.options.weight/2:0)+this._renderer.options.tolerance}}),Ee=Se.extend({options:{fill:!0,radius:10},initialize:function(t,i){d(this,i),this._latlng=j(t),this._radius=this.options.radius},setLatLng:function(t){return this._latlng=j(t),this.redraw(),this.fire("move",{latlng:this._latlng})},getLatLng:function(){return this._latlng},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius},setStyle:function(t){var i=t&&t.radius||this._radius;return Se.prototype.setStyle.call(this,t),this.setRadius(i),this},_project:function(){this._point=this._map.latLngToLayerPoint(this._latlng),this._updateBounds()},_updateBounds:function(){var t=this._radius,i=this._radiusY||t,e=this._clickTolerance(),n=[t+e,i+e];this._pxBounds=new B(this._point.subtract(n),this._point.add(n))},_update:function(){this._map&&this._updatePath()},_updatePath:function(){this._renderer._updateCircle(this)},_empty:function(){return this._radius&&!this._renderer._bounds.intersects(this._pxBounds)},_containsPoint:function(t){return t.distanceTo(this._point)<=this._radius+this._clickTolerance()}});var ke=Ee.extend({initialize:function(t,i,n){if("number"==typeof i&&(i=e({},n,{radius:i})),d(this,i),this._latlng=j(t),isNaN(this.options.radius))throw new Error("Circle radius cannot be NaN");this._mRadius=this.options.radius},setRadius:function(t){return this._mRadius=t,this.redraw()},getRadius:function(){return this._mRadius},getBounds:function(){var t=[this._radius,this._radiusY||this._radius];return new R(this._map.layerPointToLatLng(this._point.subtract(t)),this._map.layerPointToLatLng(this._point.add(t)))},setStyle:Se.prototype.setStyle,_project:function(){var t=this._latlng.lng,i=this._latlng.lat,e=this._map,n=e.options.crs;if(n.distance===F.distance){var o=Math.PI/180,s=this._mRadius/F.R/o,r=e.project([i+s,t]),a=e.project([i-s,t]),h=r.add(a).divideBy(2),u=e.unproject(h).lat,l=Math.acos((Math.cos(s*o)-Math.sin(i*o)*Math.sin(u*o))/(Math.cos(i*o)*Math.cos(u*o)))/o;(isNaN(l)||0===l)&&(l=s/Math.cos(Math.PI/180*i)),this._point=h.subtract(e.getPixelOrigin()),this._radius=isNaN(l)?0:h.x-e.project([u,t-l]).x,this._radiusY=h.y-r.y}else{var c=n.unproject(n.project(this._latlng).subtract([this._mRadius,0]));this._point=e.latLngToLayerPoint(this._latlng),this._radius=this._point.x-e.latLngToLayerPoint(c).x}this._updateBounds()}});var Ie=Se.extend({options:{smoothFactor:1,noClip:!1},initialize:function(t,i){d(this,i),this._setLatLngs(t)},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._setLatLngs(t),this.redraw()},isEmpty:function(){return!this._latlngs.length},closestLayerPoint:function(t){for(var i,e,n=1/0,o=null,s=ce,r=0,a=this._parts.length;r<a;r++)for(var h=this._parts[r],u=1,l=h.length;u<l;u++){var c=s(t,i=h[u-1],e=h[u],!0);c<n&&(n=c,o=s(t,i,e))}return o&&(o.distance=Math.sqrt(n)),o},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");var t,i,e,n,o,s,r,a=this._rings[0],h=a.length;if(!h)return null;for(t=0,i=0;t<h-1;t++)i+=a[t].distanceTo(a[t+1])/2;if(0===i)return this._map.layerPointToLatLng(a[0]);for(t=0,n=0;t<h-1;t++)if(o=a[t],s=a[t+1],(n+=e=o.distanceTo(s))>i)return r=(n-i)/e,this._map.layerPointToLatLng([s.x-r*(s.x-o.x),s.y-r*(s.y-o.y)])},getBounds:function(){return this._bounds},addLatLng:function(t,i){return i=i||this._defaultShape(),t=j(t),i.push(t),this._bounds.extend(t),this.redraw()},_setLatLngs:function(t){this._bounds=new R,this._latlngs=this._convertLatLngs(t)},_defaultShape:function(){return _e(this._latlngs)?this._latlngs:this._latlngs[0]},_convertLatLngs:function(t){for(var i=[],e=_e(t),n=0,o=t.length;n<o;n++)e?(i[n]=j(t[n]),this._bounds.extend(i[n])):i[n]=this._convertLatLngs(t[n]);return i},_project:function(){var t=new B;this._rings=[],this._projectLatlngs(this._latlngs,this._rings,t);var i=this._clickTolerance(),e=new k(i,i);this._bounds.isValid()&&t.isValid()&&(t.min._subtract(e),t.max._add(e),this._pxBounds=t)},_projectLatlngs:function(t,i,e){var n,o,s=t[0]instanceof N,r=t.length;if(s){for(o=[],n=0;n<r;n++)o[n]=this._map.latLngToLayerPoint(t[n]),e.extend(o[n]);i.push(o)}else for(n=0;n<r;n++)this._projectLatlngs(t[n],i,e)},_clipPoints:function(){var t=this._renderer._bounds;if(this._parts=[],this._pxBounds&&this._pxBounds.intersects(t))if(this.options.noClip)this._parts=this._rings;else{var i,e,n,o,s,r,a,h=this._parts;for(i=0,n=0,o=this._rings.length;i<o;i++)for(e=0,s=(a=this._rings[i]).length;e<s-1;e++)(r=he(a[e],a[e+1],t,e,!0))&&(h[n]=h[n]||[],h[n].push(r[0]),r[1]===a[e+1]&&e!==s-2||(h[n].push(r[1]),n++))}},_simplifyPoints:function(){for(var t=this._parts,i=this.options.smoothFactor,e=0,n=t.length;e<n;e++)t[e]=re(t[e],i)},_update:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),this._updatePath())},_updatePath:function(){this._renderer._updatePoly(this)},_containsPoint:function(t,i){var e,n,o,s,r,a,h=this._clickTolerance();if(!this._pxBounds||!this._pxBounds.contains(t))return!1;for(e=0,s=this._parts.length;e<s;e++)for(n=0,o=(r=(a=this._parts[e]).length)-1;n<r;o=n++)if((i||0!==n)&&ae(t,a[o],a[n])<=h)return!0;return!1}});Ie._flat=de;var Ae=Ie.extend({options:{fill:!0},isEmpty:function(){return!this._latlngs.length||!this._latlngs[0].length},getCenter:function(){if(!this._map)throw new Error("Must add layer to map before using getCenter()");var t,i,e,n,o,s,r,a,h,u=this._rings[0],l=u.length;if(!l)return null;for(s=r=a=0,t=0,i=l-1;t<l;i=t++)e=u[t],n=u[i],o=e.y*n.x-n.y*e.x,r+=(e.x+n.x)*o,a+=(e.y+n.y)*o,s+=3*o;return h=0===s?u[0]:[r/s,a/s],this._map.layerPointToLatLng(h)},_convertLatLngs:function(t){var i=Ie.prototype._convertLatLngs.call(this,t),e=i.length;return e>=2&&i[0]instanceof N&&i[0].equals(i[e-1])&&i.pop(),i},_setLatLngs:function(t){Ie.prototype._setLatLngs.call(this,t),_e(this._latlngs)&&(this._latlngs=[this._latlngs])},_defaultShape:function(){return _e(this._latlngs[0])?this._latlngs[0]:this._latlngs[0][0]},_clipPoints:function(){var t=this._renderer._bounds,i=this.options.weight,e=new k(i,i);if(t=new B(t.min.subtract(e),t.max.add(e)),this._parts=[],this._pxBounds&&this._pxBounds.intersects(t))if(this.options.noClip)this._parts=this._rings;else for(var n,o=0,s=this._rings.length;o<s;o++)(n=me(this._rings[o],t,!0)).length&&this._parts.push(n)},_updatePath:function(){this._renderer._updatePoly(this,!0)},_containsPoint:function(t){var i,e,n,o,s,r,a,h,u=!1;if(!this._pxBounds.contains(t))return!1;for(o=0,a=this._parts.length;o<a;o++)for(s=0,r=(h=(i=this._parts[o]).length)-1;s<h;r=s++)e=i[s],n=i[r],e.y>t.y!=n.y>t.y&&t.x<(n.x-e.x)*(t.y-e.y)/(n.y-e.y)+e.x&&(u=!u);return u||Ie.prototype._containsPoint.call(this,t,!0)}});var Be=Te.extend({initialize:function(t,i){d(this,i),this._layers={},t&&this.addData(t)},addData:function(t){var i,e,n,o=g(t)?t:t.features;if(o){for(i=0,e=o.length;i<e;i++)((n=o[i]).geometries||n.geometry||n.features||n.coordinates)&&this.addData(n);return this}var s=this.options;if(s.filter&&!s.filter(t))return this;var r=Oe(t,s);return r?(r.feature=He(t),r.defaultOptions=r.options,this.resetStyle(r),s.onEachFeature&&s.onEachFeature(t,r),this.addLayer(r)):this},resetStyle:function(t){return t.options=e({},t.defaultOptions),this._setLayerStyle(t,this.options.style),this},setStyle:function(t){return this.eachLayer(function(i){this._setLayerStyle(i,t)},this)},_setLayerStyle:function(t,i){"function"==typeof i&&(i=i(t.feature)),t.setStyle&&t.setStyle(i)}});function Oe(t,i){var e,n,o,s,r="Feature"===t.type?t.geometry:t,a=r?r.coordinates:null,h=[],u=i&&i.pointToLayer,l=i&&i.coordsToLatLng||Re;if(!a&&!r)return null;switch(r.type){case"Point":return e=l(a),u?u(t,e):new Ze(e);case"MultiPoint":for(o=0,s=a.length;o<s;o++)e=l(a[o]),h.push(u?u(t,e):new Ze(e));return new Te(h);case"LineString":case"MultiLineString":return n=De(a,"LineString"===r.type?0:1,l),new Ie(n,i);case"Polygon":case"MultiPolygon":return n=De(a,"Polygon"===r.type?1:2,l),new Ae(n,i);case"GeometryCollection":for(o=0,s=r.geometries.length;o<s;o++){var c=Oe({geometry:r.geometries[o],type:"Feature",properties:t.properties},i);c&&h.push(c)}return new Te(h);default:throw new Error("Invalid GeoJSON object.")}}function Re(t){return new N(t[1],t[0],t[2])}function De(t,i,e){for(var n,o=[],s=0,r=t.length;s<r;s++)n=i?De(t[s],i-1,e):(e||Re)(t[s]),o.push(n);return o}function Ne(t,i){return i="number"==typeof i?i:6,void 0!==t.alt?[l(t.lng,i),l(t.lat,i),l(t.alt,i)]:[l(t.lng,i),l(t.lat,i)]}function je(t,i,e,n){for(var o=[],s=0,r=t.length;s<r;s++)o.push(i?je(t[s],i-1,e,n):Ne(t[s],n));return!i&&e&&o.push(o[0]),o}function We(t,i){return t.feature?e({},t.feature,{geometry:i}):He(i)}function He(t){return"Feature"===t.type||"FeatureCollection"===t.type?t:{type:"Feature",properties:{},geometry:t}}var Fe={toGeoJSON:function(t){return We(this,{type:"Point",coordinates:Ne(this.getLatLng(),t)})}};function Ue(t,i){return new Be(t,i)}Ze.include(Fe),ke.include(Fe),Ee.include(Fe),Ie.include({toGeoJSON:function(t){var i=!_e(this._latlngs),e=je(this._latlngs,i?1:0,!1,t);return We(this,{type:(i?"Multi":"")+"LineString",coordinates:e})}}),Ae.include({toGeoJSON:function(t){var i=!_e(this._latlngs),e=i&&!_e(this._latlngs[0]),n=je(this._latlngs,e?2:i?1:0,!0,t);return i||(n=[n]),We(this,{type:(e?"Multi":"")+"Polygon",coordinates:n})}}),be.include({toMultiPoint:function(t){var i=[];return this.eachLayer(function(e){i.push(e.toGeoJSON(t).geometry.coordinates)}),We(this,{type:"MultiPoint",coordinates:i})},toGeoJSON:function(t){var i=this.feature&&this.feature.geometry&&this.feature.geometry.type;if("MultiPoint"===i)return this.toMultiPoint(t);var e="GeometryCollection"===i,n=[];return this.eachLayer(function(i){if(i.toGeoJSON){var o=i.toGeoJSON(t);if(e)n.push(o.geometry);else{var s=He(o);"FeatureCollection"===s.type?n.push.apply(n,s.features):n.push(s)}}}),e?We(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}});var Ve=Ue,qe=Pe.extend({options:{opacity:1,alt:"",interactive:!1,crossOrigin:!1,errorOverlayUrl:"",zIndex:1,className:""},initialize:function(t,i,e){this._url=t,this._bounds=D(i),d(this,e)},onAdd:function(){this._image||(this._initImage(),this.options.opacity<1&&this._updateOpacity()),this.options.interactive&&(Si(this._image,"leaflet-interactive"),this.addInteractiveTarget(this._image)),this.getPane().appendChild(this._image),this._reset()},onRemove:function(){Ti(this._image),this.options.interactive&&this.removeInteractiveTarget(this._image)},setOpacity:function(t){return this.options.opacity=t,this._image&&this._updateOpacity(),this},setStyle:function(t){return t.opacity&&this.setOpacity(t.opacity),this},bringToFront:function(){return this._map&&Mi(this._image),this},bringToBack:function(){return this._map&&Ci(this._image),this},setUrl:function(t){return this._url=t,this._image&&(this._image.src=t),this},setBounds:function(t){return this._bounds=D(t),this._map&&this._reset(),this},getEvents:function(){var t={zoom:this._reset,viewreset:this._reset};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},getBounds:function(){return this._bounds},getElement:function(){return this._image},_initImage:function(){var t="IMG"===this._url.tagName,i=this._image=t?this._url:bi("img");Si(i,"leaflet-image-layer"),this._zoomAnimated&&Si(i,"leaflet-zoom-animated"),this.options.className&&Si(i,this.options.className),i.onselectstart=u,i.onmousemove=u,i.onload=o(this.fire,this,"load"),i.onerror=o(this._overlayOnError,this,"error"),this.options.crossOrigin&&(i.crossOrigin=""),this.options.zIndex&&this._updateZIndex(),t?this._url=i.src:(i.src=this._url,i.alt=this.options.alt)},_animateZoom:function(t){var i=this._map.getZoomScale(t.zoom),e=this._map._latLngBoundsToNewLayerBounds(this._bounds,t.zoom,t.center).min;Oi(this._image,e,i)},_reset:function(){var t=this._image,i=new B(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast())),e=i.getSize();Ri(t,i.min),t.style.width=e.x+"px",t.style.height=e.y+"px"},_updateOpacity:function(){Ai(this._image,this.options.opacity)},_updateZIndex:function(){this._image&&void 0!==this.options.zIndex&&null!==this.options.zIndex&&(this._image.style.zIndex=this.options.zIndex)},_overlayOnError:function(){this.fire("error");var t=this.options.errorOverlayUrl;t&&this._url!==t&&(this._url=t,this._image.src=t)}}),Ge=qe.extend({options:{autoplay:!0,loop:!0},_initImage:function(){var t="VIDEO"===this._url.tagName,i=this._image=t?this._url:bi("video");if(Si(i,"leaflet-image-layer"),this._zoomAnimated&&Si(i,"leaflet-zoom-animated"),i.onselectstart=u,i.onmousemove=u,i.onloadeddata=o(this.fire,this,"load"),t){for(var e=i.getElementsByTagName("source"),n=[],s=0;s<e.length;s++)n.push(e[s].src);this._url=e.length>0?n:[i.src]}else{g(this._url)||(this._url=[this._url]),i.autoplay=!!this.options.autoplay,i.loop=!!this.options.loop;for(var r=0;r<this._url.length;r++){var a=bi("source");a.src=this._url[r],i.appendChild(a)}}}});var Ke=Pe.extend({options:{offset:[0,7],className:"",pane:"popupPane"},initialize:function(t,i){d(this,t),this._source=i},onAdd:function(t){this._zoomAnimated=t._zoomAnimated,this._container||this._initLayout(),t._fadeAnimated&&Ai(this._container,0),clearTimeout(this._removeTimeout),this.getPane().appendChild(this._container),this.update(),t._fadeAnimated&&Ai(this._container,1),this.bringToFront()},onRemove:function(t){t._fadeAnimated?(Ai(this._container,0),this._removeTimeout=setTimeout(o(Ti,void 0,this._container),200)):Ti(this._container)},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=j(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},getElement:function(){return this._container},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},getEvents:function(){var t={zoom:this._updatePosition,viewreset:this._updatePosition};return this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},isOpen:function(){return!!this._map&&this._map.hasLayer(this)},bringToFront:function(){return this._map&&Mi(this._container),this},bringToBack:function(){return this._map&&Ci(this._container),this},_updateContent:function(){if(this._content){var t=this._contentNode,i="function"==typeof this._content?this._content(this._source||this):this._content;if("string"==typeof i)t.innerHTML=i;else{for(;t.hasChildNodes();)t.removeChild(t.firstChild);t.appendChild(i)}this.fire("contentupdate")}},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),i=A(this.options.offset),e=this._getAnchor();this._zoomAnimated?Ri(this._container,t.add(e)):i=i.add(t).add(e);var n=this._containerBottom=-i.y,o=this._containerLeft=-Math.round(this._containerWidth/2)+i.x;this._container.style.bottom=n+"px",this._container.style.left=o+"px"}},_getAnchor:function(){return[0,0]}}),Ye=Ke.extend({options:{maxWidth:300,minWidth:50,maxHeight:null,autoPan:!0,autoPanPaddingTopLeft:null,autoPanPaddingBottomRight:null,autoPanPadding:[5,5],keepInView:!1,closeButton:!0,autoClose:!0,closeOnEscapeKey:!0,className:""},openOn:function(t){return t.openPopup(this),this},onAdd:function(t){Ke.prototype.onAdd.call(this,t),t.fire("popupopen",{popup:this}),this._source&&(this._source.fire("popupopen",{popup:this},!0),this._source instanceof Se||this._source.on("preclick",ti))},onRemove:function(t){Ke.prototype.onRemove.call(this,t),t.fire("popupclose",{popup:this}),this._source&&(this._source.fire("popupclose",{popup:this},!0),this._source instanceof Se||this._source.off("preclick",ti))},getEvents:function(){var t=Ke.prototype.getEvents.call(this);return(void 0!==this.options.closeOnClick?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t="leaflet-popup",i=this._container=bi("div",t+" "+(this.options.className||"")+" leaflet-zoom-animated"),e=this._wrapper=bi("div",t+"-content-wrapper",i);if(this._contentNode=bi("div",t+"-content",e),ei(e),ii(this._contentNode),Yt(e,"contextmenu",ti),this._tipContainer=bi("div",t+"-tip-container",i),this._tip=bi("div",t+"-tip",this._tipContainer),this.options.closeButton){var n=this._closeButton=bi("a",t+"-close-button",i);n.href="#close",n.innerHTML="&#215;",Yt(n,"click",this._onCloseButtonClick,this)}},_updateLayout:function(){var t=this._contentNode,i=t.style;i.width="",i.whiteSpace="nowrap";var e=t.offsetWidth;e=Math.min(e,this.options.maxWidth),e=Math.max(e,this.options.minWidth),i.width=e+1+"px",i.whiteSpace="",i.height="";var n=t.offsetHeight,o=this.options.maxHeight;o&&n>o?(i.height=o+"px",Si(t,"leaflet-popup-scrolled")):Ei(t,"leaflet-popup-scrolled"),this._containerWidth=this._container.offsetWidth},_animateZoom:function(t){var i=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center),e=this._getAnchor();Ri(this._container,i.add(e))},_adjustPan:function(){if(!(!this.options.autoPan||this._map._panAnim&&this._map._panAnim._inProgress)){var t=this._map,i=parseInt(Pi(this._container,"marginBottom"),10)||0,e=this._container.offsetHeight+i,n=this._containerWidth,o=new k(this._containerLeft,-e-this._containerBottom);o._add(Di(this._container));var s=t.layerPointToContainerPoint(o),r=A(this.options.autoPanPadding),a=A(this.options.autoPanPaddingTopLeft||r),h=A(this.options.autoPanPaddingBottomRight||r),u=t.getSize(),l=0,c=0;s.x+n+h.x>u.x&&(l=s.x+n-u.x+h.x),s.x-l-a.x<0&&(l=s.x-a.x),s.y+e+h.y>u.y&&(c=s.y+e-u.y+h.y),s.y-c-a.y<0&&(c=s.y-a.y),(l||c)&&t.fire("autopanstart").panBy([l,c])}},_onCloseButtonClick:function(t){this._close(),oi(t)},_getAnchor:function(){return A(this._source&&this._source._getPopupAnchor?this._source._getPopupAnchor():[0,0])}});qi.mergeOptions({closePopupOnClick:!0}),qi.include({openPopup:function(t,i,e){return t instanceof Ye||(t=new Ye(e).setContent(t)),i&&t.setLatLng(i),this.hasLayer(t)?this:(this._popup&&this._popup.options.autoClose&&this.closePopup(),this._popup=t,this.addLayer(t))},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&this.removeLayer(t),this}}),Pe.include({bindPopup:function(t,i){return t instanceof Ye?(d(t,i),this._popup=t,t._source=this):(this._popup&&!i||(this._popup=new Ye(i,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this.off({click:this._openPopup,keypress:this._onKeyPress,remove:this.closePopup,move:this._movePopup}),this._popupHandlersAdded=!1,this._popup=null),this},openPopup:function(t,i){if(t instanceof Pe||(i=t,t=this),t instanceof Te)for(var e in this._layers){t=this._layers[e];break}return i||(i=t.getCenter?t.getCenter():t.getLatLng()),this._popup&&this._map&&(this._popup._source=t,this._popup.update(),this._map.openPopup(this._popup,i)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(t){return this._popup&&(this._popup._map?this.closePopup():this.openPopup(t)),this},isPopupOpen:function(){return!!this._popup&&this._popup.isOpen()},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},getPopup:function(){return this._popup},_openPopup:function(t){var i=t.layer||t.target;this._popup&&this._map&&(oi(t),i instanceof Se?this.openPopup(t.layer||t.target,t.latlng):this._map.hasLayer(this._popup)&&this._popup._source===i?this.closePopup():this.openPopup(i,t.latlng))},_movePopup:function(t){this._popup.setLatLng(t.latlng)},_onKeyPress:function(t){13===t.originalEvent.keyCode&&this._openPopup(t)}});var Xe=Ke.extend({options:{pane:"tooltipPane",offset:[0,0],direction:"auto",permanent:!1,sticky:!1,interactive:!1,opacity:.9},onAdd:function(t){Ke.prototype.onAdd.call(this,t),this.setOpacity(this.options.opacity),t.fire("tooltipopen",{tooltip:this}),this._source&&this._source.fire("tooltipopen",{tooltip:this},!0)},onRemove:function(t){Ke.prototype.onRemove.call(this,t),t.fire("tooltipclose",{tooltip:this}),this._source&&this._source.fire("tooltipclose",{tooltip:this},!0)},getEvents:function(){var t=Ke.prototype.getEvents.call(this);return Lt&&!this.options.permanent&&(t.preclick=this._close),t},_close:function(){this._map&&this._map.closeTooltip(this)},_initLayout:function(){var t="leaflet-tooltip "+(this.options.className||"")+" leaflet-zoom-"+(this._zoomAnimated?"animated":"hide");this._contentNode=this._container=bi("div",t)},_updateLayout:function(){},_adjustPan:function(){},_setPosition:function(t){var i=this._map,e=this._container,n=i.latLngToContainerPoint(i.getCenter()),o=i.layerPointToContainerPoint(t),s=this.options.direction,r=e.offsetWidth,a=e.offsetHeight,h=A(this.options.offset),u=this._getAnchor();"top"===s?t=t.add(A(-r/2+h.x,-a+h.y+u.y,!0)):"bottom"===s?t=t.subtract(A(r/2-h.x,-h.y,!0)):"center"===s?t=t.subtract(A(r/2+h.x,a/2-u.y+h.y,!0)):"right"===s||"auto"===s&&o.x<n.x?(s="right",t=t.add(A(h.x+u.x,u.y-a/2+h.y,!0))):(s="left",t=t.subtract(A(r+u.x-h.x,a/2-u.y-h.y,!0))),Ei(e,"leaflet-tooltip-right"),Ei(e,"leaflet-tooltip-left"),Ei(e,"leaflet-tooltip-top"),Ei(e,"leaflet-tooltip-bottom"),Si(e,"leaflet-tooltip-"+s),Ri(e,t)},_updatePosition:function(){var t=this._map.latLngToLayerPoint(this._latlng);this._setPosition(t)},setOpacity:function(t){this.options.opacity=t,this._container&&Ai(this._container,t)},_animateZoom:function(t){var i=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);this._setPosition(i)},_getAnchor:function(){return A(this._source&&this._source._getTooltipAnchor&&!this.options.sticky?this._source._getTooltipAnchor():[0,0])}});qi.include({openTooltip:function(t,i,e){return t instanceof Xe||(t=new Xe(e).setContent(t)),i&&t.setLatLng(i),this.hasLayer(t)?this:this.addLayer(t)},closeTooltip:function(t){return t&&this.removeLayer(t),this}}),Pe.include({bindTooltip:function(t,i){return t instanceof Xe?(d(t,i),this._tooltip=t,t._source=this):(this._tooltip&&!i||(this._tooltip=new Xe(i,this)),this._tooltip.setContent(t)),this._initTooltipInteractions(),this._tooltip.options.permanent&&this._map&&this._map.hasLayer(this)&&this.openTooltip(),this},unbindTooltip:function(){return this._tooltip&&(this._initTooltipInteractions(!0),this.closeTooltip(),this._tooltip=null),this},_initTooltipInteractions:function(t){if(t||!this._tooltipHandlersAdded){var i=t?"off":"on",e={remove:this.closeTooltip,move:this._moveTooltip};this._tooltip.options.permanent?e.add=this._openTooltip:(e.mouseover=this._openTooltip,e.mouseout=this.closeTooltip,this._tooltip.options.sticky&&(e.mousemove=this._moveTooltip),Lt&&(e.click=this._openTooltip)),this[i](e),this._tooltipHandlersAdded=!t}},openTooltip:function(t,i){if(t instanceof Pe||(i=t,t=this),t instanceof Te)for(var e in this._layers){t=this._layers[e];break}return i||(i=t.getCenter?t.getCenter():t.getLatLng()),this._tooltip&&this._map&&(this._tooltip._source=t,this._tooltip.update(),this._map.openTooltip(this._tooltip,i),this._tooltip.options.interactive&&this._tooltip._container&&(Si(this._tooltip._container,"leaflet-clickable"),this.addInteractiveTarget(this._tooltip._container))),this},closeTooltip:function(){return this._tooltip&&(this._tooltip._close(),this._tooltip.options.interactive&&this._tooltip._container&&(Ei(this._tooltip._container,"leaflet-clickable"),this.removeInteractiveTarget(this._tooltip._container))),this},toggleTooltip:function(t){return this._tooltip&&(this._tooltip._map?this.closeTooltip():this.openTooltip(t)),this},isTooltipOpen:function(){return this._tooltip.isOpen()},setTooltipContent:function(t){return this._tooltip&&this._tooltip.setContent(t),this},getTooltip:function(){return this._tooltip},_openTooltip:function(t){var i=t.layer||t.target;this._tooltip&&this._map&&this.openTooltip(i,this._tooltip.options.sticky?t.latlng:void 0)},_moveTooltip:function(t){var i,e,n=t.latlng;this._tooltip.options.sticky&&t.originalEvent&&(i=this._map.mouseEventToContainerPoint(t.originalEvent),e=this._map.containerPointToLayerPoint(i),n=this._map.layerPointToLatLng(e)),this._tooltip.setLatLng(n)}});var Je=ze.extend({options:{iconSize:[12,12],html:!1,bgPos:null,className:"leaflet-div-icon"},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:document.createElement("div"),e=this.options;if(i.innerHTML=!1!==e.html?e.html:"",e.bgPos){var n=A(e.bgPos);i.style.backgroundPosition=-n.x+"px "+-n.y+"px"}return this._setIconStyles(i,"icon"),i},createShadow:function(){return null}});ze.Default=Me;var $e=Pe.extend({options:{tileSize:256,opacity:1,updateWhenIdle:gt,updateWhenZooming:!0,updateInterval:200,zIndex:1,bounds:null,minZoom:0,maxZoom:void 0,maxNativeZoom:void 0,minNativeZoom:void 0,noWrap:!1,pane:"tilePane",className:"",keepBuffer:2},initialize:function(t){d(this,t)},onAdd:function(){this._initContainer(),this._levels={},this._tiles={},this._resetView(),this._update()},beforeAdd:function(t){t._addZoomLimit(this)},onRemove:function(t){this._removeAllTiles(),Ti(this._container),t._removeZoomLimit(this),this._container=null,this._tileZoom=void 0},bringToFront:function(){return this._map&&(Mi(this._container),this._setAutoZIndex(Math.max)),this},bringToBack:function(){return this._map&&(Ci(this._container),this._setAutoZIndex(Math.min)),this},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},isLoading:function(){return this._loading},redraw:function(){return this._map&&(this._removeAllTiles(),this._update()),this},getEvents:function(){var t={viewprereset:this._invalidateAll,viewreset:this._resetView,zoom:this._resetView,moveend:this._onMoveEnd};return this.options.updateWhenIdle||(this._onMove||(this._onMove=a(this._onMoveEnd,this.options.updateInterval,this)),t.move=this._onMove),this._zoomAnimated&&(t.zoomanim=this._animateZoom),t},createTile:function(){return document.createElement("div")},getTileSize:function(){var t=this.options.tileSize;return t instanceof k?t:new k(t,t)},_updateZIndex:function(){this._container&&void 0!==this.options.zIndex&&null!==this.options.zIndex&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t){for(var i,e=this.getPane().children,n=-t(-1/0,1/0),o=0,s=e.length;o<s;o++)i=e[o].style.zIndex,e[o]!==this._container&&i&&(n=t(n,+i));isFinite(n)&&(this.options.zIndex=n+t(-1,1),this._updateZIndex())},_updateOpacity:function(){if(this._map&&!Q){Ai(this._container,this.options.opacity);var t=+new Date,i=!1,e=!1;for(var n in this._tiles){var o=this._tiles[n];if(o.current&&o.loaded){var s=Math.min(1,(t-o.loaded)/200);Ai(o.el,s),s<1?i=!0:(o.active?e=!0:this._onOpaqueTile(o),o.active=!0)}}e&&!this._noPrune&&this._pruneTiles(),i&&(M(this._fadeFrame),this._fadeFrame=z(this._updateOpacity,this))}},_onOpaqueTile:u,_initContainer:function(){this._container||(this._container=bi("div","leaflet-layer "+(this.options.className||"")),this._updateZIndex(),this.options.opacity<1&&this._updateOpacity(),this.getPane().appendChild(this._container))},_updateLevels:function(){var t=this._tileZoom,i=this.options.maxZoom;if(void 0!==t){for(var e in this._levels)this._levels[e].el.children.length||e===t?(this._levels[e].el.style.zIndex=i-Math.abs(t-e),this._onUpdateLevel(e)):(Ti(this._levels[e].el),this._removeTilesAtZoom(e),this._onRemoveLevel(e),delete this._levels[e]);var n=this._levels[t],o=this._map;return n||((n=this._levels[t]={}).el=bi("div","leaflet-tile-container leaflet-zoom-animated",this._container),n.el.style.zIndex=i,n.origin=o.project(o.unproject(o.getPixelOrigin()),t).round(),n.zoom=t,this._setZoomTransform(n,o.getCenter(),o.getZoom()),n.el.offsetWidth,this._onCreateLevel(n)),this._level=n,n}},_onUpdateLevel:u,_onRemoveLevel:u,_onCreateLevel:u,_pruneTiles:function(){if(this._map){var t,i,e=this._map.getZoom();if(e>this.options.maxZoom||e<this.options.minZoom)this._removeAllTiles();else{for(t in this._tiles)(i=this._tiles[t]).retain=i.current;for(t in this._tiles)if((i=this._tiles[t]).current&&!i.active){var n=i.coords;this._retainParent(n.x,n.y,n.z,n.z-5)||this._retainChildren(n.x,n.y,n.z,n.z+2)}for(t in this._tiles)this._tiles[t].retain||this._removeTile(t)}}},_removeTilesAtZoom:function(t){for(var i in this._tiles)this._tiles[i].coords.z===t&&this._removeTile(i)},_removeAllTiles:function(){for(var t in this._tiles)this._removeTile(t)},_invalidateAll:function(){for(var t in this._levels)Ti(this._levels[t].el),this._onRemoveLevel(t),delete this._levels[t];this._removeAllTiles(),this._tileZoom=void 0},_retainParent:function(t,i,e,n){var o=Math.floor(t/2),s=Math.floor(i/2),r=e-1,a=new k(+o,+s);a.z=+r;var h=this._tileCoordsToKey(a),u=this._tiles[h];return u&&u.active?(u.retain=!0,!0):(u&&u.loaded&&(u.retain=!0),r>n&&this._retainParent(o,s,r,n))},_retainChildren:function(t,i,e,n){for(var o=2*t;o<2*t+2;o++)for(var s=2*i;s<2*i+2;s++){var r=new k(o,s);r.z=e+1;var a=this._tileCoordsToKey(r),h=this._tiles[a];h&&h.active?h.retain=!0:(h&&h.loaded&&(h.retain=!0),e+1<n&&this._retainChildren(o,s,e+1,n))}},_resetView:function(t){var i=t&&(t.pinch||t.flyTo);this._setView(this._map.getCenter(),this._map.getZoom(),i,i)},_animateZoom:function(t){this._setView(t.center,t.zoom,!0,t.noUpdate)},_clampZoom:function(t){var i=this.options;return void 0!==i.minNativeZoom&&t<i.minNativeZoom?i.minNativeZoom:void 0!==i.maxNativeZoom&&i.maxNativeZoom<t?i.maxNativeZoom:t},_setView:function(t,i,e,n){var o=this._clampZoom(Math.round(i));(void 0!==this.options.maxZoom&&o>this.options.maxZoom||void 0!==this.options.minZoom&&o<this.options.minZoom)&&(o=void 0);var s=this.options.updateWhenZooming&&o!==this._tileZoom;n&&!s||(this._tileZoom=o,this._abortLoading&&this._abortLoading(),this._updateLevels(),this._resetGrid(),void 0!==o&&this._update(t),e||this._pruneTiles(),this._noPrune=!!e),this._setZoomTransforms(t,i)},_setZoomTransforms:function(t,i){for(var e in this._levels)this._setZoomTransform(this._levels[e],t,i)},_setZoomTransform:function(t,i,e){var n=this._map.getZoomScale(e,t.zoom),o=t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(i,e)).round();ft?Oi(t.el,o,n):Ri(t.el,o)},_resetGrid:function(){var t=this._map,i=t.options.crs,e=this._tileSize=this.getTileSize(),n=this._tileZoom,o=this._map.getPixelWorldBounds(this._tileZoom);o&&(this._globalTileRange=this._pxBoundsToTileRange(o)),this._wrapX=i.wrapLng&&!this.options.noWrap&&[Math.floor(t.project([0,i.wrapLng[0]],n).x/e.x),Math.ceil(t.project([0,i.wrapLng[1]],n).x/e.y)],this._wrapY=i.wrapLat&&!this.options.noWrap&&[Math.floor(t.project([i.wrapLat[0],0],n).y/e.x),Math.ceil(t.project([i.wrapLat[1],0],n).y/e.y)]},_onMoveEnd:function(){this._map&&!this._map._animatingZoom&&this._update()},_getTiledPixelBounds:function(t){var i=this._map,e=i._animatingZoom?Math.max(i._animateToZoom,i.getZoom()):i.getZoom(),n=i.getZoomScale(e,this._tileZoom),o=i.project(t,this._tileZoom).floor(),s=i.getSize().divideBy(2*n);return new B(o.subtract(s),o.add(s))},_update:function(t){var i=this._map;if(i){var e=this._clampZoom(i.getZoom());if(void 0===t&&(t=i.getCenter()),void 0!==this._tileZoom){var n=this._getTiledPixelBounds(t),o=this._pxBoundsToTileRange(n),s=o.getCenter(),r=[],a=this.options.keepBuffer,h=new B(o.getBottomLeft().subtract([a,-a]),o.getTopRight().add([a,-a]));if(!(isFinite(o.min.x)&&isFinite(o.min.y)&&isFinite(o.max.x)&&isFinite(o.max.y)))throw new Error("Attempted to load an infinite number of tiles");for(var u in this._tiles){var l=this._tiles[u].coords;l.z===this._tileZoom&&h.contains(new k(l.x,l.y))||(this._tiles[u].current=!1)}if(Math.abs(e-this._tileZoom)>1)this._setView(t,e);else{for(var c=o.min.y;c<=o.max.y;c++)for(var _=o.min.x;_<=o.max.x;_++){var d=new k(_,c);if(d.z=this._tileZoom,this._isValidTile(d)){var p=this._tiles[this._tileCoordsToKey(d)];p?p.current=!0:r.push(d)}}if(r.sort(function(t,i){return t.distanceTo(s)-i.distanceTo(s)}),0!==r.length){this._loading||(this._loading=!0,this.fire("loading"));var m=document.createDocumentFragment();for(_=0;_<r.length;_++)this._addTile(r[_],m);this._level.el.appendChild(m)}}}}},_isValidTile:function(t){var i=this._map.options.crs;if(!i.infinite){var e=this._globalTileRange;if(!i.wrapLng&&(t.x<e.min.x||t.x>e.max.x)||!i.wrapLat&&(t.y<e.min.y||t.y>e.max.y))return!1}if(!this.options.bounds)return!0;var n=this._tileCoordsToBounds(t);return D(this.options.bounds).overlaps(n)},_keyToBounds:function(t){return this._tileCoordsToBounds(this._keyToTileCoords(t))},_tileCoordsToNwSe:function(t){var i=this._map,e=this.getTileSize(),n=t.scaleBy(e),o=n.add(e);return[i.unproject(n,t.z),i.unproject(o,t.z)]},_tileCoordsToBounds:function(t){var i=this._tileCoordsToNwSe(t),e=new R(i[0],i[1]);return this.options.noWrap||(e=this._map.wrapLatLngBounds(e)),e},_tileCoordsToKey:function(t){return t.x+":"+t.y+":"+t.z},_keyToTileCoords:function(t){var i=t.split(":"),e=new k(+i[0],+i[1]);return e.z=+i[2],e},_removeTile:function(t){var i=this._tiles[t];i&&(st||i.el.setAttribute("src",y),Ti(i.el),delete this._tiles[t],this.fire("tileunload",{tile:i.el,coords:this._keyToTileCoords(t)}))},_initTile:function(t){Si(t,"leaflet-tile");var i=this.getTileSize();t.style.width=i.x+"px",t.style.height=i.y+"px",t.onselectstart=u,t.onmousemove=u,Q&&this.options.opacity<1&&Ai(t,this.options.opacity),et&&!nt&&(t.style.WebkitBackfaceVisibility="hidden")},_addTile:function(t,i){var e=this._getTilePos(t),n=this._tileCoordsToKey(t),s=this.createTile(this._wrapCoords(t),o(this._tileReady,this,t));this._initTile(s),this.createTile.length<2&&z(o(this._tileReady,this,t,null,s)),Ri(s,e),this._tiles[n]={el:s,coords:t,current:!0},i.appendChild(s),this.fire("tileloadstart",{tile:s,coords:t})},_tileReady:function(t,i,e){if(this._map){i&&this.fire("tileerror",{error:i,tile:e,coords:t});var n=this._tileCoordsToKey(t);(e=this._tiles[n])&&(e.loaded=+new Date,this._map._fadeAnimated?(Ai(e.el,0),M(this._fadeFrame),this._fadeFrame=z(this._updateOpacity,this)):(e.active=!0,this._pruneTiles()),i||(Si(e.el,"leaflet-tile-loaded"),this.fire("tileload",{tile:e.el,coords:t})),this._noTilesToLoad()&&(this._loading=!1,this.fire("load"),Q||!this._map._fadeAnimated?z(this._pruneTiles,this):setTimeout(o(this._pruneTiles,this),250)))}},_getTilePos:function(t){return t.scaleBy(this.getTileSize()).subtract(this._level.origin)},_wrapCoords:function(t){var i=new k(this._wrapX?h(t.x,this._wrapX):t.x,this._wrapY?h(t.y,this._wrapY):t.y);return i.z=t.z,i},_pxBoundsToTileRange:function(t){var i=this.getTileSize();return new B(t.min.unscaleBy(i).floor(),t.max.unscaleBy(i).ceil().subtract([1,1]))},_noTilesToLoad:function(){for(var t in this._tiles)if(!this._tiles[t].loaded)return!1;return!0}});var Qe=$e.extend({options:{minZoom:0,maxZoom:18,subdomains:"abc",errorTileUrl:"",zoomOffset:0,tms:!1,zoomReverse:!1,detectRetina:!1,crossOrigin:!1},initialize:function(t,i){this._url=t,(i=d(this,i)).detectRetina&&Tt&&i.maxZoom>0&&(i.tileSize=Math.floor(i.tileSize/2),i.zoomReverse?(i.zoomOffset--,i.minZoom++):(i.zoomOffset++,i.maxZoom--),i.minZoom=Math.max(0,i.minZoom)),"string"==typeof i.subdomains&&(i.subdomains=i.subdomains.split("")),et||this.on("tileunload",this._onTileRemove)},setUrl:function(t,i){return this._url=t,i||this.redraw(),this},createTile:function(t,i){var e=document.createElement("img");return Yt(e,"load",o(this._tileOnLoad,this,i,e)),Yt(e,"error",o(this._tileOnError,this,i,e)),this.options.crossOrigin&&(e.crossOrigin=""),e.alt="",e.setAttribute("role","presentation"),e.src=this.getTileUrl(t),e},getTileUrl:function(t){var i={r:Tt?"@2x":"",s:this._getSubdomain(t),x:t.x,y:t.y,z:this._getZoomForUrl()};if(this._map&&!this._map.options.crs.infinite){var n=this._globalTileRange.max.y-t.y;this.options.tms&&(i.y=n),i["-y"]=n}return f(this._url,e(i,this.options))},_tileOnLoad:function(t,i){Q?setTimeout(o(t,this,null,i),0):t(null,i)},_tileOnError:function(t,i,e){var n=this.options.errorTileUrl;n&&i.getAttribute("src")!==n&&(i.src=n),t(e,i)},_onTileRemove:function(t){t.tile.onload=null},_getZoomForUrl:function(){var t=this._tileZoom,i=this.options.maxZoom,e=this.options.zoomReverse,n=this.options.zoomOffset;return e&&(t=i-t),t+n},_getSubdomain:function(t){var i=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[i]},_abortLoading:function(){var t,i;for(t in this._tiles)this._tiles[t].coords.z!==this._tileZoom&&((i=this._tiles[t].el).onload=u,i.onerror=u,i.complete||(i.src=y,Ti(i),delete this._tiles[t]))}});function tn(t,i){return new Qe(t,i)}var en=Qe.extend({defaultWmsParams:{service:"WMS",request:"GetMap",layers:"",styles:"",format:"image/jpeg",transparent:!1,version:"1.1.1"},options:{crs:null,uppercase:!1},initialize:function(t,i){this._url=t;var n=e({},this.defaultWmsParams);for(var o in i)o in this.options||(n[o]=i[o]);var s=(i=d(this,i)).detectRetina&&Tt?2:1,r=this.getTileSize();n.width=r.x*s,n.height=r.y*s,this.wmsParams=n},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var i=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[i]=this._crs.code,Qe.prototype.onAdd.call(this,t)},getTileUrl:function(t){var i=this._tileCoordsToNwSe(t),e=this._crs,n=O(e.project(i[0]),e.project(i[1])),o=n.min,s=n.max,r=(this._wmsVersion>=1.3&&this._crs===we?[o.y,o.x,s.y,s.x]:[o.x,o.y,s.x,s.y]).join(","),a=L.TileLayer.prototype.getTileUrl.call(this,t);return a+p(this.wmsParams,a,this.options.uppercase)+(this.options.uppercase?"&BBOX=":"&bbox=")+r},setParams:function(t,i){return e(this.wmsParams,t),i||this.redraw(),this}});Qe.WMS=en,tn.wms=function(t,i){return new en(t,i)};var nn=Pe.extend({options:{padding:.1,tolerance:0},initialize:function(t){d(this,t),r(this),this._layers=this._layers||{}},onAdd:function(){this._container||(this._initContainer(),this._zoomAnimated&&Si(this._container,"leaflet-zoom-animated")),this.getPane().appendChild(this._container),this._update(),this.on("update",this._updatePaths,this)},onRemove:function(){this.off("update",this._updatePaths,this),this._destroyContainer()},getEvents:function(){var t={viewreset:this._reset,zoom:this._onZoom,moveend:this._update,zoomend:this._onZoomEnd};return this._zoomAnimated&&(t.zoomanim=this._onAnimZoom),t},_onAnimZoom:function(t){this._updateTransform(t.center,t.zoom)},_onZoom:function(){this._updateTransform(this._map.getCenter(),this._map.getZoom())},_updateTransform:function(t,i){var e=this._map.getZoomScale(i,this._zoom),n=Di(this._container),o=this._map.getSize().multiplyBy(.5+this.options.padding),s=this._map.project(this._center,i),r=this._map.project(t,i).subtract(s),a=o.multiplyBy(-e).add(n).add(o).subtract(r);ft?Oi(this._container,a,e):Ri(this._container,a)},_reset:function(){for(var t in this._update(),this._updateTransform(this._center,this._zoom),this._layers)this._layers[t]._reset()},_onZoomEnd:function(){for(var t in this._layers)this._layers[t]._project()},_updatePaths:function(){for(var t in this._layers)this._layers[t]._update()},_update:function(){var t=this.options.padding,i=this._map.getSize(),e=this._map.containerPointToLayerPoint(i.multiplyBy(-t)).round();this._bounds=new B(e,e.add(i.multiplyBy(1+2*t)).round()),this._center=this._map.getCenter(),this._zoom=this._map.getZoom()}}),on=nn.extend({getEvents:function(){var t=nn.prototype.getEvents.call(this);return t.viewprereset=this._onViewPreReset,t},_onViewPreReset:function(){this._postponeUpdatePaths=!0},onAdd:function(){nn.prototype.onAdd.call(this),this._draw()},_initContainer:function(){var t=this._container=document.createElement("canvas");Yt(t,"mousemove",a(this._onMouseMove,32,this),this),Yt(t,"click dblclick mousedown mouseup contextmenu",this._onClick,this),Yt(t,"mouseout",this._handleMouseOut,this),this._ctx=t.getContext("2d")},_destroyContainer:function(){delete this._ctx,Ti(this._container),Jt(this._container),delete this._container},_updatePaths:function(){if(!this._postponeUpdatePaths){for(var t in this._redrawBounds=null,this._layers)this._layers[t]._update();this._redraw()}},_update:function(){if(!this._map._animatingZoom||!this._bounds){this._drawnLayers={},nn.prototype._update.call(this);var t=this._bounds,i=this._container,e=t.getSize(),n=Tt?2:1;Ri(i,t.min),i.width=n*e.x,i.height=n*e.y,i.style.width=e.x+"px",i.style.height=e.y+"px",Tt&&this._ctx.scale(2,2),this._ctx.translate(-t.min.x,-t.min.y),this.fire("update")}},_reset:function(){nn.prototype._reset.call(this),this._postponeUpdatePaths&&(this._postponeUpdatePaths=!1,this._updatePaths())},_initPath:function(t){this._updateDashArray(t),this._layers[r(t)]=t;var i=t._order={layer:t,prev:this._drawLast,next:null};this._drawLast&&(this._drawLast.next=i),this._drawLast=i,this._drawFirst=this._drawFirst||this._drawLast},_addPath:function(t){this._requestRedraw(t)},_removePath:function(t){var i=t._order,e=i.next,n=i.prev;e?e.prev=n:this._drawLast=n,n?n.next=e:this._drawFirst=e,delete t._order,delete this._layers[L.stamp(t)],this._requestRedraw(t)},_updatePath:function(t){this._extendRedrawBounds(t),t._project(),t._update(),this._requestRedraw(t)},_updateStyle:function(t){this._updateDashArray(t),this._requestRedraw(t)},_updateDashArray:function(t){if(t.options.dashArray){var i,e=t.options.dashArray.split(","),n=[];for(i=0;i<e.length;i++)n.push(Number(e[i]));t.options._dashArray=n}},_requestRedraw:function(t){this._map&&(this._extendRedrawBounds(t),this._redrawRequest=this._redrawRequest||z(this._redraw,this))},_extendRedrawBounds:function(t){if(t._pxBounds){var i=(t.options.weight||0)+1;this._redrawBounds=this._redrawBounds||new B,this._redrawBounds.extend(t._pxBounds.min.subtract([i,i])),this._redrawBounds.extend(t._pxBounds.max.add([i,i]))}},_redraw:function(){this._redrawRequest=null,this._redrawBounds&&(this._redrawBounds.min._floor(),this._redrawBounds.max._ceil()),this._clear(),this._draw(),this._redrawBounds=null},_clear:function(){var t=this._redrawBounds;if(t){var i=t.getSize();this._ctx.clearRect(t.min.x,t.min.y,i.x,i.y)}else this._ctx.clearRect(0,0,this._container.width,this._container.height)},_draw:function(){var t,i=this._redrawBounds;if(this._ctx.save(),i){var e=i.getSize();this._ctx.beginPath(),this._ctx.rect(i.min.x,i.min.y,e.x,e.y),this._ctx.clip()}this._drawing=!0;for(var n=this._drawFirst;n;n=n.next)t=n.layer,(!i||t._pxBounds&&t._pxBounds.intersects(i))&&t._updatePath();this._drawing=!1,this._ctx.restore()},_updatePoly:function(t,i){if(this._drawing){var e,n,o,s,r=t._parts,a=r.length,h=this._ctx;if(a){for(this._drawnLayers[t._leaflet_id]=t,h.beginPath(),e=0;e<a;e++){for(n=0,o=r[e].length;n<o;n++)s=r[e][n],h[n?"lineTo":"moveTo"](s.x,s.y);i&&h.closePath()}this._fillStroke(h,t)}}},_updateCircle:function(t){if(this._drawing&&!t._empty()){var i=t._point,e=this._ctx,n=Math.max(Math.round(t._radius),1),o=(Math.max(Math.round(t._radiusY),1)||n)/n;this._drawnLayers[t._leaflet_id]=t,1!==o&&(e.save(),e.scale(1,o)),e.beginPath(),e.arc(i.x,i.y/o,n,0,2*Math.PI,!1),1!==o&&e.restore(),this._fillStroke(e,t)}},_fillStroke:function(t,i){var e=i.options;e.fill&&(t.globalAlpha=e.fillOpacity,t.fillStyle=e.fillColor||e.color,t.fill(e.fillRule||"evenodd")),e.stroke&&0!==e.weight&&(t.setLineDash&&t.setLineDash(i.options&&i.options._dashArray||[]),t.globalAlpha=e.opacity,t.lineWidth=e.weight,t.strokeStyle=e.color,t.lineCap=e.lineCap,t.lineJoin=e.lineJoin,t.stroke())},_onClick:function(t){for(var i,e,n=this._map.mouseEventToLayerPoint(t),o=this._drawFirst;o;o=o.next)(i=o.layer).options.interactive&&i._containsPoint(n)&&!this._map._draggableMoved(i)&&(e=i);e&&(li(t),this._fireEvent([e],t))},_onMouseMove:function(t){if(this._map&&!this._map.dragging.moving()&&!this._map._animatingZoom){var i=this._map.mouseEventToLayerPoint(t);this._handleMouseHover(t,i)}},_handleMouseOut:function(t){var i=this._hoveredLayer;i&&(Ei(this._container,"leaflet-interactive"),this._fireEvent([i],t,"mouseout"),this._hoveredLayer=null)},_handleMouseHover:function(t,i){for(var e,n,o=this._drawFirst;o;o=o.next)(e=o.layer).options.interactive&&e._containsPoint(i)&&(n=e);n!==this._hoveredLayer&&(this._handleMouseOut(t),n&&(Si(this._container,"leaflet-interactive"),this._fireEvent([n],t,"mouseover"),this._hoveredLayer=n)),this._hoveredLayer&&this._fireEvent([this._hoveredLayer],t)},_fireEvent:function(t,i,e){this._map._fireDOMEvent(i,e||i.type,t)},_bringToFront:function(t){var i=t._order,e=i.next,n=i.prev;e&&(e.prev=n,n?n.next=e:e&&(this._drawFirst=e),i.prev=this._drawLast,this._drawLast.next=i,i.next=null,this._drawLast=i,this._requestRedraw(t))},_bringToBack:function(t){var i=t._order,e=i.next,n=i.prev;n&&(n.next=e,e?e.prev=n:n&&(this._drawLast=n),i.prev=null,i.next=this._drawFirst,this._drawFirst.prev=i,this._drawFirst=i,this._requestRedraw(t))}});function sn(t){return zt?new on(t):null}var rn=function(){try{return document.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return document.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return document.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),an={_initContainer:function(){this._container=bi("div","leaflet-vml-container")},_update:function(){this._map._animatingZoom||(nn.prototype._update.call(this),this.fire("update"))},_initPath:function(t){var i=t._container=rn("shape");Si(i,"leaflet-vml-shape "+(this.options.className||"")),i.coordsize="1 1",t._path=rn("path"),i.appendChild(t._path),this._updateStyle(t),this._layers[r(t)]=t},_addPath:function(t){var i=t._container;this._container.appendChild(i),t.options.interactive&&t.addInteractiveTarget(i)},_removePath:function(t){var i=t._container;Ti(i),t.removeInteractiveTarget(i),delete this._layers[r(t)]},_updateStyle:function(t){var i=t._stroke,e=t._fill,n=t.options,o=t._container;o.stroked=!!n.stroke,o.filled=!!n.fill,n.stroke?(i||(i=t._stroke=rn("stroke")),o.appendChild(i),i.weight=n.weight+"px",i.color=n.color,i.opacity=n.opacity,n.dashArray?i.dashStyle=g(n.dashArray)?n.dashArray.join(" "):n.dashArray.replace(/( *, *)/g," "):i.dashStyle="",i.endcap=n.lineCap.replace("butt","flat"),i.joinstyle=n.lineJoin):i&&(o.removeChild(i),t._stroke=null),n.fill?(e||(e=t._fill=rn("fill")),o.appendChild(e),e.color=n.fillColor||n.color,e.opacity=n.fillOpacity):e&&(o.removeChild(e),t._fill=null)},_updateCircle:function(t){var i=t._point.round(),e=Math.round(t._radius),n=Math.round(t._radiusY||e);this._setPath(t,t._empty()?"M0 0":"AL "+i.x+","+i.y+" "+e+","+n+" 0,23592600")},_setPath:function(t,i){t._path.v=i},_bringToFront:function(t){Mi(t._container)},_bringToBack:function(t){Ci(t._container)}},hn=Ct?rn:Y,un=nn.extend({getEvents:function(){var t=nn.prototype.getEvents.call(this);return t.zoomstart=this._onZoomStart,t},_initContainer:function(){this._container=hn("svg"),this._container.setAttribute("pointer-events","none"),this._rootGroup=hn("g"),this._container.appendChild(this._rootGroup)},_destroyContainer:function(){Ti(this._container),Jt(this._container),delete this._container,delete this._rootGroup,delete this._svgSize},_onZoomStart:function(){this._update()},_update:function(){if(!this._map._animatingZoom||!this._bounds){nn.prototype._update.call(this);var t=this._bounds,i=t.getSize(),e=this._container;this._svgSize&&this._svgSize.equals(i)||(this._svgSize=i,e.setAttribute("width",i.x),e.setAttribute("height",i.y)),Ri(e,t.min),e.setAttribute("viewBox",[t.min.x,t.min.y,i.x,i.y].join(" ")),this.fire("update")}},_initPath:function(t){var i=t._path=hn("path");t.options.className&&Si(i,t.options.className),t.options.interactive&&Si(i,"leaflet-interactive"),this._updateStyle(t),this._layers[r(t)]=t},_addPath:function(t){this._rootGroup||this._initContainer(),this._rootGroup.appendChild(t._path),t.addInteractiveTarget(t._path)},_removePath:function(t){Ti(t._path),t.removeInteractiveTarget(t._path),delete this._layers[r(t)]},_updatePath:function(t){t._project(),t._update()},_updateStyle:function(t){var i=t._path,e=t.options;i&&(e.stroke?(i.setAttribute("stroke",e.color),i.setAttribute("stroke-opacity",e.opacity),i.setAttribute("stroke-width",e.weight),i.setAttribute("stroke-linecap",e.lineCap),i.setAttribute("stroke-linejoin",e.lineJoin),e.dashArray?i.setAttribute("stroke-dasharray",e.dashArray):i.removeAttribute("stroke-dasharray"),e.dashOffset?i.setAttribute("stroke-dashoffset",e.dashOffset):i.removeAttribute("stroke-dashoffset")):i.setAttribute("stroke","none"),e.fill?(i.setAttribute("fill",e.fillColor||e.color),i.setAttribute("fill-opacity",e.fillOpacity),i.setAttribute("fill-rule",e.fillRule||"evenodd")):i.setAttribute("fill","none"))},_updatePoly:function(t,i){this._setPath(t,X(t._parts,i))},_updateCircle:function(t){var i=t._point,e=Math.max(Math.round(t._radius),1),n="a"+e+","+(Math.max(Math.round(t._radiusY),1)||e)+" 0 1,0 ",o=t._empty()?"M0 0":"M"+(i.x-e)+","+i.y+n+2*e+",0 "+n+2*-e+",0 ";this._setPath(t,o)},_setPath:function(t,i){t._path.setAttribute("d",i)},_bringToFront:function(t){Mi(t._path)},_bringToBack:function(t){Ci(t._path)}});function ln(t){return Mt||Ct?new un(t):null}Ct&&un.include(an),qi.include({getRenderer:function(t){var i=t.options.renderer||this._getPaneRenderer(t.options.pane)||this.options.renderer||this._renderer;return i||(i=this._renderer=this.options.preferCanvas&&sn()||ln()),this.hasLayer(i)||this.addLayer(i),i},_getPaneRenderer:function(t){if("overlayPane"===t||void 0===t)return!1;var i=this._paneRenderers[t];return void 0===i&&(i=un&&ln({pane:t})||on&&sn({pane:t}),this._paneRenderers[t]=i),i}});var cn=Ae.extend({initialize:function(t,i){Ae.prototype.initialize.call(this,this._boundsToLatLngs(t),i)},setBounds:function(t){return this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return[(t=D(t)).getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}});un.create=hn,un.pointsToPath=X,Be.geometryToLayer=Oe,Be.coordsToLatLng=Re,Be.coordsToLatLngs=De,Be.latLngToCoords=Ne,Be.latLngsToCoords=je,Be.getFeature=We,Be.asFeature=He,qi.mergeOptions({boxZoom:!0});var _n=Qi.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._resetStateTimeout=0,t.on("unload",this._destroy,this)},addHooks:function(){Yt(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){Jt(this._container,"mousedown",this._onMouseDown,this)},moved:function(){return this._moved},_destroy:function(){Ti(this._pane),delete this._pane},_resetState:function(){this._resetStateTimeout=0,this._moved=!1},_clearDeferredResetState:function(){0!==this._resetStateTimeout&&(clearTimeout(this._resetStateTimeout),this._resetStateTimeout=0)},_onMouseDown:function(t){if(!t.shiftKey||1!==t.which&&1!==t.button)return!1;this._clearDeferredResetState(),this._resetState(),di(),ji(),this._startPoint=this._map.mouseEventToContainerPoint(t),Yt(document,{contextmenu:oi,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseMove:function(t){this._moved||(this._moved=!0,this._box=bi("div","leaflet-zoom-box",this._container),Si(this._container,"leaflet-crosshair"),this._map.fire("boxzoomstart")),this._point=this._map.mouseEventToContainerPoint(t);var i=new B(this._point,this._startPoint),e=i.getSize();Ri(this._box,i.min),this._box.style.width=e.x+"px",this._box.style.height=e.y+"px"},_finish:function(){this._moved&&(Ti(this._box),Ei(this._container,"leaflet-crosshair")),pi(),Wi(),Jt(document,{contextmenu:oi,mousemove:this._onMouseMove,mouseup:this._onMouseUp,keydown:this._onKeyDown},this)},_onMouseUp:function(t){if((1===t.which||1===t.button)&&(this._finish(),this._moved)){this._clearDeferredResetState(),this._resetStateTimeout=setTimeout(o(this._resetState,this),0);var i=new R(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point));this._map.fitBounds(i).fire("boxzoomend",{boxZoomBounds:i})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}});qi.addInitHook("addHandler","boxZoom",_n),qi.mergeOptions({doubleClickZoom:!0});var dn=Qi.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var i=this._map,e=i.getZoom(),n=i.options.zoomDelta,o=t.originalEvent.shiftKey?e-n:e+n;"center"===i.options.doubleClickZoom?i.setZoom(o):i.setZoomAround(t.containerPoint,o)}});qi.addInitHook("addHandler","doubleClickZoom",dn),qi.mergeOptions({dragging:!0,inertia:!nt,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,easeLinearity:.2,worldCopyJump:!1,maxBoundsViscosity:0});var pn=Qi.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new se(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),this._draggable.on("predrag",this._onPreDragLimit,this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDragWrap,this),t.on("zoomend",this._onZoomEnd,this),t.whenReady(this._onZoomEnd,this))}Si(this._map._container,"leaflet-grab leaflet-touch-drag"),this._draggable.enable(),this._positions=[],this._times=[]},removeHooks:function(){Ei(this._map._container,"leaflet-grab"),Ei(this._map._container,"leaflet-touch-drag"),this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},moving:function(){return this._draggable&&this._draggable._moving},_onDragStart:function(){var t=this._map;if(t._stop(),this._map.options.maxBounds&&this._map.options.maxBoundsViscosity){var i=D(this._map.options.maxBounds);this._offsetLimit=O(this._map.latLngToContainerPoint(i.getNorthWest()).multiplyBy(-1),this._map.latLngToContainerPoint(i.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),this._viscosity=Math.min(1,Math.max(0,this._map.options.maxBoundsViscosity))}else this._offsetLimit=null;t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(t){if(this._map.options.inertia){var i=this._lastTime=+new Date,e=this._lastPos=this._draggable._absPos||this._draggable._newPos;this._positions.push(e),this._times.push(i),this._prunePositions(i)}this._map.fire("move",t).fire("drag",t)},_prunePositions:function(t){for(;this._positions.length>1&&t-this._times[0]>50;)this._positions.shift(),this._times.shift()},_onZoomEnd:function(){var t=this._map.getSize().divideBy(2),i=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=i.subtract(t).x,this._worldWidth=this._map.getPixelWorldBounds().getSize().x},_viscousLimit:function(t,i){return t-(t-i)*this._viscosity},_onPreDragLimit:function(){if(this._viscosity&&this._offsetLimit){var t=this._draggable._newPos.subtract(this._draggable._startPos),i=this._offsetLimit;t.x<i.min.x&&(t.x=this._viscousLimit(t.x,i.min.x)),t.y<i.min.y&&(t.y=this._viscousLimit(t.y,i.min.y)),t.x>i.max.x&&(t.x=this._viscousLimit(t.x,i.max.x)),t.y>i.max.y&&(t.y=this._viscousLimit(t.y,i.max.y)),this._draggable._newPos=this._draggable._startPos.add(t)}},_onPreDragWrap:function(){var t=this._worldWidth,i=Math.round(t/2),e=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-i+e)%t+i-e,s=(n+i+e)%t-i-e,r=Math.abs(o+e)<Math.abs(s+e)?o:s;this._draggable._absPos=this._draggable._newPos.clone(),this._draggable._newPos.x=r},_onDragEnd:function(t){var i=this._map,e=i.options,n=!e.inertia||this._times.length<2;if(i.fire("dragend",t),n)i.fire("moveend");else{this._prunePositions(+new Date);var o=this._lastPos.subtract(this._positions[0]),s=(this._lastTime-this._times[0])/1e3,r=e.easeLinearity,a=o.multiplyBy(r/s),h=a.distanceTo([0,0]),u=Math.min(e.inertiaMaxSpeed,h),l=a.multiplyBy(u/h),c=u/(e.inertiaDeceleration*r),_=l.multiplyBy(-c/2).round();_.x||_.y?(_=i._limitOffset(_,i.options.maxBounds),z(function(){i.panBy(_,{duration:c,easeLinearity:r,noMoveStart:!0,animate:!0})})):i.fire("moveend")}}});qi.addInitHook("addHandler","dragging",pn),qi.mergeOptions({keyboard:!0,keyboardPanDelta:80});var mn=Qi.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,54,173]},initialize:function(t){this._map=t,this._setPanDelta(t.options.keyboardPanDelta),this._setZoomDelta(t.options.zoomDelta)},addHooks:function(){var t=this._map._container;t.tabIndex<=0&&(t.tabIndex="0"),Yt(t,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.on({focus:this._addHooks,blur:this._removeHooks},this)},removeHooks:function(){this._removeHooks(),Jt(this._map._container,{focus:this._onFocus,blur:this._onBlur,mousedown:this._onMouseDown},this),this._map.off({focus:this._addHooks,blur:this._removeHooks},this)},_onMouseDown:function(){if(!this._focused){var t=document.body,i=document.documentElement,e=t.scrollTop||i.scrollTop,n=t.scrollLeft||i.scrollLeft;this._map._container.focus(),window.scrollTo(n,e)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanDelta:function(t){var i,e,n=this._panKeys={},o=this.keyCodes;for(i=0,e=o.left.length;i<e;i++)n[o.left[i]]=[-1*t,0];for(i=0,e=o.right.length;i<e;i++)n[o.right[i]]=[t,0];for(i=0,e=o.down.length;i<e;i++)n[o.down[i]]=[0,t];for(i=0,e=o.up.length;i<e;i++)n[o.up[i]]=[0,-1*t]},_setZoomDelta:function(t){var i,e,n=this._zoomKeys={},o=this.keyCodes;for(i=0,e=o.zoomIn.length;i<e;i++)n[o.zoomIn[i]]=t;for(i=0,e=o.zoomOut.length;i<e;i++)n[o.zoomOut[i]]=-t},_addHooks:function(){Yt(document,"keydown",this._onKeyDown,this)},_removeHooks:function(){Jt(document,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){if(!(t.altKey||t.ctrlKey||t.metaKey)){var i,e=t.keyCode,n=this._map;if(e in this._panKeys){if(n._panAnim&&n._panAnim._inProgress)return;i=this._panKeys[e],t.shiftKey&&(i=A(i).multiplyBy(3)),n.panBy(i),n.options.maxBounds&&n.panInsideBounds(n.options.maxBounds)}else if(e in this._zoomKeys)n.setZoom(n.getZoom()+(t.shiftKey?3:1)*this._zoomKeys[e]);else{if(27!==e||!n._popup||!n._popup.options.closeOnEscapeKey)return;n.closePopup()}oi(t)}}});qi.addInitHook("addHandler","keyboard",mn),qi.mergeOptions({scrollWheelZoom:!0,wheelDebounceTime:40,wheelPxPerZoomLevel:60});var fn=Qi.extend({addHooks:function(){Yt(this._map._container,"mousewheel",this._onWheelScroll,this),this._delta=0},removeHooks:function(){Jt(this._map._container,"mousewheel",this._onWheelScroll,this)},_onWheelScroll:function(t){var i=ai(t),e=this._map.options.wheelDebounceTime;this._delta+=i,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var n=Math.max(e-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o(this._performZoom,this),n),oi(t)},_performZoom:function(){var t=this._map,i=t.getZoom(),e=this._map.options.zoomSnap||0;t._stop();var n=this._delta/(4*this._map.options.wheelPxPerZoomLevel),o=4*Math.log(2/(1+Math.exp(-Math.abs(n))))/Math.LN2,s=e?Math.ceil(o/e)*e:o,r=t._limitZoom(i+(this._delta>0?s:-s))-i;this._delta=0,this._startTime=null,r&&("center"===t.options.scrollWheelZoom?t.setZoom(i+r):t.setZoomAround(this._lastMousePos,i+r))}});qi.addInitHook("addHandler","scrollWheelZoom",fn),qi.mergeOptions({tap:!0,tapTolerance:15});var gn=Qi.extend({addHooks:function(){Yt(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){Jt(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(ni(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],e=i.target;this._startPos=this._newPos=new k(i.clientX,i.clientY),e.tagName&&"a"===e.tagName.toLowerCase()&&Si(e,"leaflet-active"),this._holdTimeout=setTimeout(o(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),this._simulateEvent("mousedown",i),Yt(document,{touchmove:this._onMove,touchend:this._onUp},this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),Jt(document,{touchmove:this._onMove,touchend:this._onUp},this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],e=i.target;e&&e.tagName&&"a"===e.tagName.toLowerCase()&&Ei(e,"leaflet-active"),this._simulateEvent("mouseup",i),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var i=t.touches[0];this._newPos=new k(i.clientX,i.clientY),this._simulateEvent("mousemove",i)},_simulateEvent:function(t,i){var e=document.createEvent("MouseEvents");e._simulated=!0,i.target._simulatedClick=!0,e.initMouseEvent(t,!0,!0,window,1,i.screenX,i.screenY,i.clientX,i.clientY,!1,!1,!1,!1,0,null),i.target.dispatchEvent(e)}});Lt&&!wt&&qi.addInitHook("addHandler","tap",gn),qi.mergeOptions({touchZoom:Lt&&!nt,bounceAtZoomLimits:!0});var vn=Qi.extend({addHooks:function(){Si(this._map._container,"leaflet-touch-zoom"),Yt(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){Ei(this._map._container,"leaflet-touch-zoom"),Jt(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var e=i.mouseEventToContainerPoint(t.touches[0]),n=i.mouseEventToContainerPoint(t.touches[1]);this._centerPoint=i.getSize()._divideBy(2),this._startLatLng=i.containerPointToLatLng(this._centerPoint),"center"!==i.options.touchZoom&&(this._pinchStartLatLng=i.containerPointToLatLng(e.add(n)._divideBy(2))),this._startDist=e.distanceTo(n),this._startZoom=i.getZoom(),this._moved=!1,this._zooming=!0,i._stop(),Yt(document,"touchmove",this._onTouchMove,this),Yt(document,"touchend",this._onTouchEnd,this),ni(t)}},_onTouchMove:function(t){if(t.touches&&2===t.touches.length&&this._zooming){var i=this._map,e=i.mouseEventToContainerPoint(t.touches[0]),n=i.mouseEventToContainerPoint(t.touches[1]),s=e.distanceTo(n)/this._startDist;if(this._zoom=i.getScaleZoom(s,this._startZoom),!i.options.bounceAtZoomLimits&&(this._zoom<i.getMinZoom()&&s<1||this._zoom>i.getMaxZoom()&&s>1)&&(this._zoom=i._limitZoom(this._zoom)),"center"===i.options.touchZoom){if(this._center=this._startLatLng,1===s)return}else{var r=e._add(n)._divideBy(2)._subtract(this._centerPoint);if(1===s&&0===r.x&&0===r.y)return;this._center=i.unproject(i.project(this._pinchStartLatLng,this._zoom).subtract(r),this._zoom)}this._moved||(i._moveStart(!0,!1),this._moved=!0),M(this._animRequest);var a=o(i._move,i,this._center,this._zoom,{pinch:!0,round:!1});this._animRequest=z(a,this,!0),ni(t)}},_onTouchEnd:function(){this._moved&&this._zooming?(this._zooming=!1,M(this._animRequest),Jt(document,"touchmove",this._onTouchMove),Jt(document,"touchend",this._onTouchEnd),this._map.options.zoomAnimation?this._map._animateZoom(this._center,this._map._limitZoom(this._zoom),!0,this._map.options.zoomSnap):this._map._resetView(this._center,this._map._limitZoom(this._zoom))):this._zooming=!1}});qi.addInitHook("addHandler","touchZoom",vn),qi.BoxZoom=_n,qi.DoubleClickZoom=dn,qi.Drag=pn,qi.Keyboard=mn,qi.ScrollWheelZoom=fn,qi.Tap=gn,qi.TouchZoom=vn;var yn=window.L;window.L=t,Object.freeze=i,t.version="1.3.1",t.noConflict=function(){return window.L=yn,this},t.Control=Gi,t.control=Ki,t.Browser=St,t.Evented=E,t.Mixin=ie,t.Util=C,t.Class=Z,t.Handler=Qi,t.extend=e,t.bind=o,t.stamp=r,t.setOptions=d,t.DomEvent=vi,t.DomUtil=Ui,t.PosAnimation=Vi,t.Draggable=se,t.LineUtil=pe,t.PolyUtil=fe,t.Point=k,t.point=A,t.Bounds=B,t.bounds=O,t.Transformation=V,t.transformation=q,t.Projection=ye,t.LatLng=N,t.latLng=j,t.LatLngBounds=R,t.latLngBounds=D,t.CRS=H,t.GeoJSON=Be,t.geoJSON=Ue,t.geoJson=Ve,t.Layer=Pe,t.LayerGroup=be,t.layerGroup=function(t,i){return new be(t,i)},t.FeatureGroup=Te,t.featureGroup=function(t){return new Te(t)},t.ImageOverlay=qe,t.imageOverlay=function(t,i,e){return new qe(t,i,e)},t.VideoOverlay=Ge,t.videoOverlay=function(t,i,e){return new Ge(t,i,e)},t.DivOverlay=Ke,t.Popup=Ye,t.popup=function(t,i){return new Ye(t,i)},t.Tooltip=Xe,t.tooltip=function(t,i){return new Xe(t,i)},t.Icon=ze,t.icon=function(t){return new ze(t)},t.DivIcon=Je,t.divIcon=function(t){return new Je(t)},t.Marker=Ze,t.marker=function(t,i){return new Ze(t,i)},t.TileLayer=Qe,t.tileLayer=tn,t.GridLayer=$e,t.gridLayer=function(t){return new $e(t)},t.SVG=un,t.svg=ln,t.Renderer=nn,t.Canvas=on,t.canvas=sn,t.Path=Se,t.CircleMarker=Ee,t.circleMarker=function(t,i){return new Ee(t,i)},t.Circle=ke,t.circle=function(t,i,e){return new ke(t,i,e)},t.Polyline=Ie,t.polyline=function(t,i){return new Ie(t,i)},t.Polygon=Ae,t.polygon=function(t,i){return new Ae(t,i)},t.Rectangle=cn,t.rectangle=function(t,i){return new cn(t,i)},t.Map=qi,t.map=function(t,i){return new qi(t,i)}});
-
-},{}],8:[function(require,module,exports){
-!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.moment=t()}(this,function(){"use strict";var e,t;function n(){return e.apply(null,arguments)}function s(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function i(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function r(e){return void 0===e}function a(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function o(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function u(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function l(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function d(e,t){for(var n in t)l(t,n)&&(e[n]=t[n]);return l(t,"toString")&&(e.toString=t.toString),l(t,"valueOf")&&(e.valueOf=t.valueOf),e}function h(e,t,n,s){return Tt(e,t,n,s,!0).utc()}function c(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function f(e){if(null==e._isValid){var n=c(e),s=t.call(n.parsedDateParts,function(e){return null!=e}),i=!isNaN(e._d.getTime())&&n.overflow<0&&!n.empty&&!n.invalidMonth&&!n.invalidWeekday&&!n.weekdayMismatch&&!n.nullInput&&!n.invalidFormat&&!n.userInvalidated&&(!n.meridiem||n.meridiem&&s);if(e._strict&&(i=i&&0===n.charsLeftOver&&0===n.unusedTokens.length&&void 0===n.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return i;e._isValid=i}return e._isValid}function m(e){var t=h(NaN);return null!=e?d(c(t),e):c(t).userInvalidated=!0,t}t=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var _=n.momentProperties=[];function y(e,t){var n,s,i;if(r(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),r(t._i)||(e._i=t._i),r(t._f)||(e._f=t._f),r(t._l)||(e._l=t._l),r(t._strict)||(e._strict=t._strict),r(t._tzm)||(e._tzm=t._tzm),r(t._isUTC)||(e._isUTC=t._isUTC),r(t._offset)||(e._offset=t._offset),r(t._pf)||(e._pf=c(t)),r(t._locale)||(e._locale=t._locale),_.length>0)for(n=0;n<_.length;n++)r(i=t[s=_[n]])||(e[s]=i);return e}var g=!1;function p(e){y(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===g&&(g=!0,n.updateOffset(this),g=!1)}function v(e){return e instanceof p||null!=e&&null!=e._isAMomentObject}function w(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function M(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=w(t)),n}function S(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&M(e[s])!==M(t[s]))&&a++;return a+r}function D(e){!1===n.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function k(e,t){var s=!0;return d(function(){if(null!=n.deprecationHandler&&n.deprecationHandler(null,e),s){for(var i,r=[],a=0;a<arguments.length;a++){if(i="","object"==typeof arguments[a]){for(var o in i+="\n["+a+"] ",arguments[0])i+=o+": "+arguments[0][o]+", ";i=i.slice(0,-2)}else i=arguments[a];r.push(i)}D(e+"\nArguments: "+Array.prototype.slice.call(r).join("")+"\n"+(new Error).stack),s=!1}return t.apply(this,arguments)},t)}var Y,O={};function T(e,t){null!=n.deprecationHandler&&n.deprecationHandler(e,t),O[e]||(D(t),O[e]=!0)}function x(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function b(e,t){var n,s=d({},e);for(n in t)l(t,n)&&(i(e[n])&&i(t[n])?(s[n]={},d(s[n],e[n]),d(s[n],t[n])):null!=t[n]?s[n]=t[n]:delete s[n]);for(n in e)l(e,n)&&!l(t,n)&&i(e[n])&&(s[n]=d({},s[n]));return s}function P(e){null!=e&&this.set(e)}n.suppressDeprecationWarnings=!1,n.deprecationHandler=null,Y=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)l(e,t)&&n.push(t);return n};var W={};function H(e,t){var n=e.toLowerCase();W[n]=W[n+"s"]=W[t]=e}function R(e){return"string"==typeof e?W[e]||W[e.toLowerCase()]:void 0}function C(e){var t,n,s={};for(n in e)l(e,n)&&(t=R(n))&&(s[t]=e[n]);return s}var F={};function L(e,t){F[e]=t}function U(e,t,n){var s=""+Math.abs(e),i=t-s.length;return(e>=0?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}var N=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,G=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,V={},E={};function I(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(E[e]=i),t&&(E[t[0]]=function(){return U(i.apply(this,arguments),t[1],t[2])}),n&&(E[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function A(e,t){return e.isValid()?(t=j(t,e.localeData()),V[t]=V[t]||function(e){var t,n,s,i=e.match(N);for(t=0,n=i.length;t<n;t++)E[i[t]]?i[t]=E[i[t]]:i[t]=(s=i[t]).match(/\[[\s\S]/)?s.replace(/^\[|\]$/g,""):s.replace(/\\/g,"");return function(t){var s,r="";for(s=0;s<n;s++)r+=x(i[s])?i[s].call(t,e):i[s];return r}}(t),V[t](e)):e.localeData().invalidDate()}function j(e,t){var n=5;function s(e){return t.longDateFormat(e)||e}for(G.lastIndex=0;n>=0&&G.test(e);)e=e.replace(G,s),G.lastIndex=0,n-=1;return e}var Z=/\d/,z=/\d\d/,$=/\d{3}/,q=/\d{4}/,J=/[+-]?\d{6}/,B=/\d\d?/,Q=/\d\d\d\d?/,X=/\d\d\d\d\d\d?/,K=/\d{1,3}/,ee=/\d{1,4}/,te=/[+-]?\d{1,6}/,ne=/\d+/,se=/[+-]?\d+/,ie=/Z|[+-]\d\d:?\d\d/gi,re=/Z|[+-]\d\d(?::?\d\d)?/gi,ae=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,oe={};function ue(e,t,n){oe[e]=x(t)?t:function(e,s){return e&&n?n:t}}function le(e,t){return l(oe,e)?oe[e](t._strict,t._locale):new RegExp(de(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i})))}function de(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var he={};function ce(e,t){var n,s=t;for("string"==typeof e&&(e=[e]),a(t)&&(s=function(e,n){n[t]=M(e)}),n=0;n<e.length;n++)he[e[n]]=s}function fe(e,t){ce(e,function(e,n,s,i){s._w=s._w||{},t(e,s._w,s,i)})}function me(e,t,n){null!=t&&l(he,e)&&he[e](t,n._a,n,e)}var _e=0,ye=1,ge=2,pe=3,ve=4,we=5,Me=6,Se=7,De=8;function ke(e){return Ye(e)?366:365}function Ye(e){return e%4==0&&e%100!=0||e%400==0}I("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),I(0,["YY",2],0,function(){return this.year()%100}),I(0,["YYYY",4],0,"year"),I(0,["YYYYY",5],0,"year"),I(0,["YYYYYY",6,!0],0,"year"),H("year","y"),L("year",1),ue("Y",se),ue("YY",B,z),ue("YYYY",ee,q),ue("YYYYY",te,J),ue("YYYYYY",te,J),ce(["YYYYY","YYYYYY"],_e),ce("YYYY",function(e,t){t[_e]=2===e.length?n.parseTwoDigitYear(e):M(e)}),ce("YY",function(e,t){t[_e]=n.parseTwoDigitYear(e)}),ce("Y",function(e,t){t[_e]=parseInt(e,10)}),n.parseTwoDigitYear=function(e){return M(e)+(M(e)>68?1900:2e3)};var Oe,Te=xe("FullYear",!0);function xe(e,t){return function(s){return null!=s?(Pe(this,e,s),n.updateOffset(this,t),this):be(this,e)}}function be(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function Pe(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&Ye(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),We(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n))}function We(e,t){if(isNaN(e)||isNaN(t))return NaN;var n,s=(t%(n=12)+n)%n;return e+=(t-s)/12,1===s?Ye(e)?29:28:31-s%7%2}Oe=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1},I("M",["MM",2],"Mo",function(){return this.month()+1}),I("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),I("MMMM",0,0,function(e){return this.localeData().months(this,e)}),H("month","M"),L("month",8),ue("M",B),ue("MM",B,z),ue("MMM",function(e,t){return t.monthsShortRegex(e)}),ue("MMMM",function(e,t){return t.monthsRegex(e)}),ce(["M","MM"],function(e,t){t[ye]=M(e)-1}),ce(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[ye]=i:c(n).invalidMonth=e});var He=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Re="January_February_March_April_May_June_July_August_September_October_November_December".split("_");var Ce="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Fe(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=M(t);else if(!a(t=e.localeData().monthsParse(t)))return e;return n=Math.min(e.date(),We(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function Le(e){return null!=e?(Fe(this,e),n.updateOffset(this,!0),this):be(this,"Month")}var Ue=ae;var Ne=ae;function Ge(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=h([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=de(s[t]),i[t]=de(i[t]);for(t=0;t<24;t++)r[t]=de(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function Ve(e){var t=new Date(Date.UTC.apply(null,arguments));return e<100&&e>=0&&isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e),t}function Ee(e,t,n){var s=7+t-n;return-((7+Ve(e,0,s).getUTCDay()-t)%7)+s-1}function Ie(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+Ee(e,s,i);return o<=0?a=ke(r=e-1)+o:o>ke(e)?(r=e+1,a=o-ke(e)):(r=e,a=o),{year:r,dayOfYear:a}}function Ae(e,t,n){var s,i,r=Ee(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+je(i=e.year()-1,t,n):a>je(e.year(),t,n)?(s=a-je(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function je(e,t,n){var s=Ee(e,t,n),i=Ee(e+1,t,n);return(ke(e)-s+i)/7}I("w",["ww",2],"wo","week"),I("W",["WW",2],"Wo","isoWeek"),H("week","w"),H("isoWeek","W"),L("week",5),L("isoWeek",5),ue("w",B),ue("ww",B,z),ue("W",B),ue("WW",B,z),fe(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=M(e)});I("d",0,"do","day"),I("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),I("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),I("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),I("e",0,0,"weekday"),I("E",0,0,"isoWeekday"),H("day","d"),H("weekday","e"),H("isoWeekday","E"),L("day",11),L("weekday",11),L("isoWeekday",11),ue("d",B),ue("e",B),ue("E",B),ue("dd",function(e,t){return t.weekdaysMinRegex(e)}),ue("ddd",function(e,t){return t.weekdaysShortRegex(e)}),ue("dddd",function(e,t){return t.weekdaysRegex(e)}),fe(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:c(n).invalidWeekday=e}),fe(["d","e","E"],function(e,t,n,s){t[s]=M(e)});var Ze="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");var ze="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");var $e="Su_Mo_Tu_We_Th_Fr_Sa".split("_");var qe=ae;var Je=ae;var Be=ae;function Qe(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],l=[];for(t=0;t<7;t++)n=h([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),l.push(s),l.push(i),l.push(r);for(a.sort(e),o.sort(e),u.sort(e),l.sort(e),t=0;t<7;t++)o[t]=de(o[t]),u[t]=de(u[t]),l[t]=de(l[t]);this._weekdaysRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Xe(){return this.hours()%12||12}function Ke(e,t){I(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function et(e,t){return t._meridiemParse}I("H",["HH",2],0,"hour"),I("h",["hh",2],0,Xe),I("k",["kk",2],0,function(){return this.hours()||24}),I("hmm",0,0,function(){return""+Xe.apply(this)+U(this.minutes(),2)}),I("hmmss",0,0,function(){return""+Xe.apply(this)+U(this.minutes(),2)+U(this.seconds(),2)}),I("Hmm",0,0,function(){return""+this.hours()+U(this.minutes(),2)}),I("Hmmss",0,0,function(){return""+this.hours()+U(this.minutes(),2)+U(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),H("hour","h"),L("hour",13),ue("a",et),ue("A",et),ue("H",B),ue("h",B),ue("k",B),ue("HH",B,z),ue("hh",B,z),ue("kk",B,z),ue("hmm",Q),ue("hmmss",X),ue("Hmm",Q),ue("Hmmss",X),ce(["H","HH"],pe),ce(["k","kk"],function(e,t,n){var s=M(e);t[pe]=24===s?0:s}),ce(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),ce(["h","hh"],function(e,t,n){t[pe]=M(e),c(n).bigHour=!0}),ce("hmm",function(e,t,n){var s=e.length-2;t[pe]=M(e.substr(0,s)),t[ve]=M(e.substr(s)),c(n).bigHour=!0}),ce("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[pe]=M(e.substr(0,s)),t[ve]=M(e.substr(s,2)),t[we]=M(e.substr(i)),c(n).bigHour=!0}),ce("Hmm",function(e,t,n){var s=e.length-2;t[pe]=M(e.substr(0,s)),t[ve]=M(e.substr(s))}),ce("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[pe]=M(e.substr(0,s)),t[ve]=M(e.substr(s,2)),t[we]=M(e.substr(i))});var tt,nt=xe("Hours",!0),st={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Re,monthsShort:Ce,week:{dow:0,doy:6},weekdays:Ze,weekdaysMin:$e,weekdaysShort:ze,meridiemParse:/[ap]\.?m?\.?/i},it={},rt={};function at(e){return e?e.toLowerCase().replace("_","-"):e}function ot(e){var t=null;if(!it[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=tt._abbr,require("./locale/"+e),ut(t)}catch(e){}return it[e]}function ut(e,t){var n;return e&&((n=r(t)?dt(e):lt(e,t))?tt=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),tt._abbr}function lt(e,t){if(null!==t){var n,s=st;if(t.abbr=e,null!=it[e])T("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),s=it[e]._config;else if(null!=t.parentLocale)if(null!=it[t.parentLocale])s=it[t.parentLocale]._config;else{if(null==(n=ot(t.parentLocale)))return rt[t.parentLocale]||(rt[t.parentLocale]=[]),rt[t.parentLocale].push({name:e,config:t}),null;s=n._config}return it[e]=new P(b(s,t)),rt[e]&&rt[e].forEach(function(e){lt(e.name,e.config)}),ut(e),it[e]}return delete it[e],null}function dt(e){var t;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return tt;if(!s(e)){if(t=ot(e))return t;e=[e]}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=at(e[r]).split("-")).length,n=(n=at(e[r+1]))?n.split("-"):null;t>0;){if(s=ot(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&S(i,n,!0)>=t-1)break;t--}r++}return tt}(e)}function ht(e){var t,n=e._a;return n&&-2===c(e).overflow&&(t=n[ye]<0||n[ye]>11?ye:n[ge]<1||n[ge]>We(n[_e],n[ye])?ge:n[pe]<0||n[pe]>24||24===n[pe]&&(0!==n[ve]||0!==n[we]||0!==n[Me])?pe:n[ve]<0||n[ve]>59?ve:n[we]<0||n[we]>59?we:n[Me]<0||n[Me]>999?Me:-1,c(e)._overflowDayOfYear&&(t<_e||t>ge)&&(t=ge),c(e)._overflowWeeks&&-1===t&&(t=Se),c(e)._overflowWeekday&&-1===t&&(t=De),c(e).overflow=t),e}function ct(e,t,n){return null!=e?e:null!=t?t:n}function ft(e){var t,s,i,r,a,o=[];if(!e._d){for(i=function(e){var t=new Date(n.now());return e._useUTC?[t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate()]:[t.getFullYear(),t.getMonth(),t.getDate()]}(e),e._w&&null==e._a[ge]&&null==e._a[ye]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=ct(t.GG,e._a[_e],Ae(xt(),1,4).year),s=ct(t.W,1),((i=ct(t.E,1))<1||i>7)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=Ae(xt(),r,a);n=ct(t.gg,e._a[_e],l.year),s=ct(t.w,l.week),null!=t.d?((i=t.d)<0||i>6)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||t.e>6)&&(u=!0)):i=r}s<1||s>je(n,r,a)?c(e)._overflowWeeks=!0:null!=u?c(e)._overflowWeekday=!0:(o=Ie(n,s,i,r,a),e._a[_e]=o.year,e._dayOfYear=o.dayOfYear)}(e),null!=e._dayOfYear&&(a=ct(e._a[_e],i[_e]),(e._dayOfYear>ke(a)||0===e._dayOfYear)&&(c(e)._overflowDayOfYear=!0),s=Ve(a,0,e._dayOfYear),e._a[ye]=s.getUTCMonth(),e._a[ge]=s.getUTCDate()),t=0;t<3&&null==e._a[t];++t)e._a[t]=o[t]=i[t];for(;t<7;t++)e._a[t]=o[t]=null==e._a[t]?2===t?1:0:e._a[t];24===e._a[pe]&&0===e._a[ve]&&0===e._a[we]&&0===e._a[Me]&&(e._nextDay=!0,e._a[pe]=0),e._d=(e._useUTC?Ve:function(e,t,n,s,i,r,a){var o=new Date(e,t,n,s,i,r,a);return e<100&&e>=0&&isFinite(o.getFullYear())&&o.setFullYear(e),o}).apply(null,o),r=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[pe]=24),e._w&&void 0!==e._w.d&&e._w.d!==r&&(c(e).weekdayMismatch=!0)}}var mt=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,_t=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,yt=/Z|[+-]\d\d(?::?\d\d)?/,gt=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],pt=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],vt=/^\/?Date\((\-?\d+)/i;function wt(e){var t,n,s,i,r,a,o=e._i,u=mt.exec(o)||_t.exec(o);if(u){for(c(e).iso=!0,t=0,n=gt.length;t<n;t++)if(gt[t][1].exec(u[1])){i=gt[t][0],s=!1!==gt[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=pt.length;t<n;t++)if(pt[t][1].exec(u[3])){r=(u[2]||" ")+pt[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!yt.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),Yt(e)}else e._isValid=!1}var Mt=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;function St(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);if(t<=49)return 2e3+t;if(t<=999)return 1900+t;return t}(e),Ce.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}var Dt={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function kt(e){var t=Mt.exec(e._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim());if(t){var n=St(t[4],t[3],t[2],t[5],t[6],t[7]);if(!function(e,t,n){return!e||ze.indexOf(e)===new Date(t[0],t[1],t[2]).getDay()||(c(n).weekdayMismatch=!0,n._isValid=!1,!1)}(t[1],n,e))return;e._a=n,e._tzm=function(e,t,n){if(e)return Dt[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return(s-i)/100*60+i}(t[8],t[9],t[10]),e._d=Ve.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),c(e).rfc2822=!0}else e._isValid=!1}function Yt(e){if(e._f!==n.ISO_8601)if(e._f!==n.RFC_2822){e._a=[],c(e).empty=!0;var t,s,i,r,a,o=""+e._i,u=o.length,l=0;for(i=j(e._f,e._locale).match(N)||[],t=0;t<i.length;t++)r=i[t],(s=(o.match(le(r,e))||[])[0])&&((a=o.substr(0,o.indexOf(s))).length>0&&c(e).unusedInput.push(a),o=o.slice(o.indexOf(s)+s.length),l+=s.length),E[r]?(s?c(e).empty=!1:c(e).unusedTokens.push(r),me(r,s,e)):e._strict&&!s&&c(e).unusedTokens.push(r);c(e).charsLeftOver=u-l,o.length>0&&c(e).unusedInput.push(o),e._a[pe]<=12&&!0===c(e).bigHour&&e._a[pe]>0&&(c(e).bigHour=void 0),c(e).parsedDateParts=e._a.slice(0),c(e).meridiem=e._meridiem,e._a[pe]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):null!=e.isPM?((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0),t):t}(e._locale,e._a[pe],e._meridiem),ft(e),ht(e)}else kt(e);else wt(e)}function Ot(e){var t=e._i,l=e._f;return e._locale=e._locale||dt(e._l),null===t||void 0===l&&""===t?m({nullInput:!0}):("string"==typeof t&&(e._i=t=e._locale.preparse(t)),v(t)?new p(ht(t)):(o(t)?e._d=t:s(l)?function(e){var t,n,s,i,r;if(0===e._f.length)return c(e).invalidFormat=!0,void(e._d=new Date(NaN));for(i=0;i<e._f.length;i++)r=0,t=y({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],Yt(t),f(t)&&(r+=c(t).charsLeftOver,r+=10*c(t).unusedTokens.length,c(t).score=r,(null==s||r<s)&&(s=r,n=t));d(e,n||t)}(e):l?Yt(e):function(e){var t=e._i;r(t)?e._d=new Date(n.now()):o(t)?e._d=new Date(t.valueOf()):"string"==typeof t?function(e){var t=vt.exec(e._i);null===t?(wt(e),!1===e._isValid&&(delete e._isValid,kt(e),!1===e._isValid&&(delete e._isValid,n.createFromInputFallback(e)))):e._d=new Date(+t[1])}(e):s(t)?(e._a=u(t.slice(0),function(e){return parseInt(e,10)}),ft(e)):i(t)?function(e){if(!e._d){var t=C(e._i);e._a=u([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),ft(e)}}(e):a(t)?e._d=new Date(t):n.createFromInputFallback(e)}(e),f(e)||(e._d=null),e))}function Tt(e,t,n,r,a){var o,u={};return!0!==n&&!1!==n||(r=n,n=void 0),(i(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0}(e)||s(e)&&0===e.length)&&(e=void 0),u._isAMomentObject=!0,u._useUTC=u._isUTC=a,u._l=n,u._i=e,u._f=t,u._strict=r,(o=new p(ht(Ot(u))))._nextDay&&(o.add(1,"d"),o._nextDay=void 0),o}function xt(e,t,n,s){return Tt(e,t,n,s,!1)}n.createFromInputFallback=k("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),n.ISO_8601=function(){},n.RFC_2822=function(){};var bt=k("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=xt.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:m()}),Pt=k("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=xt.apply(null,arguments);return this.isValid()&&e.isValid()?e>this?this:e:m()});function Wt(e,t){var n,i;if(1===t.length&&s(t[0])&&(t=t[0]),!t.length)return xt();for(n=t[0],i=1;i<t.length;++i)t[i].isValid()&&!t[i][e](n)||(n=t[i]);return n}var Ht=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Rt(e){var t=C(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,d=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Oe.call(Ht,t)||null!=e[t]&&isNaN(e[t]))return!1;for(var n=!1,s=0;s<Ht.length;++s)if(e[Ht[s]]){if(n)return!1;parseFloat(e[Ht[s]])!==M(e[Ht[s]])&&(n=!0)}return!0}(t),this._milliseconds=+d+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=dt(),this._bubble()}function Ct(e){return e instanceof Rt}function Ft(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function Lt(e,t){I(e,0,0,function(){var e=this.utcOffset(),n="+";return e<0&&(e=-e,n="-"),n+U(~~(e/60),2)+t+U(~~e%60,2)})}Lt("Z",":"),Lt("ZZ",""),ue("Z",re),ue("ZZ",re),ce(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=Nt(re,e)});var Ut=/([\+\-]|\d\d)/gi;function Nt(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(Ut)||["-",0,0],i=60*s[1]+M(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Gt(e,t){var s,i;return t._isUTC?(s=t.clone(),i=(v(e)||o(e)?e.valueOf():xt(e).valueOf())-s.valueOf(),s._d.setTime(s._d.valueOf()+i),n.updateOffset(s,!1),s):xt(e).local()}function Vt(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Et(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}n.updateOffset=function(){};var It=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,At=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function jt(e,t){var n,s,i,r=e,o=null;return Ct(e)?r={ms:e._milliseconds,d:e._days,M:e._months}:a(e)?(r={},t?r[t]=e:r.milliseconds=e):(o=It.exec(e))?(n="-"===o[1]?-1:1,r={y:0,d:M(o[ge])*n,h:M(o[pe])*n,m:M(o[ve])*n,s:M(o[we])*n,ms:M(Ft(1e3*o[Me]))*n}):(o=At.exec(e))?(n="-"===o[1]?-1:(o[1],1),r={y:Zt(o[2],n),M:Zt(o[3],n),w:Zt(o[4],n),d:Zt(o[5],n),h:Zt(o[6],n),m:Zt(o[7],n),s:Zt(o[8],n)}):null==r?r={}:"object"==typeof r&&("from"in r||"to"in r)&&(i=function(e,t){var n;if(!e.isValid()||!t.isValid())return{milliseconds:0,months:0};t=Gt(t,e),e.isBefore(t)?n=zt(e,t):((n=zt(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(xt(r.from),xt(r.to)),(r={}).ms=i.milliseconds,r.M=i.months),s=new Rt(r),Ct(e)&&l(e,"_locale")&&(s._locale=e._locale),s}function Zt(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function zt(e,t){var n={milliseconds:0,months:0};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function $t(e,t){return function(n,s){var i;return null===s||isNaN(+s)||(T(t,"moment()."+t+"(period, number) is deprecated. Please use moment()."+t+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),i=n,n=s,s=i),qt(this,jt(n="string"==typeof n?+n:n,s),e),this}}function qt(e,t,s,i){var r=t._milliseconds,a=Ft(t._days),o=Ft(t._months);e.isValid()&&(i=null==i||i,o&&Fe(e,be(e,"Month")+o*s),a&&Pe(e,"Date",be(e,"Date")+a*s),r&&e._d.setTime(e._d.valueOf()+r*s),i&&n.updateOffset(e,a||o))}jt.fn=Rt.prototype,jt.invalid=function(){return jt(NaN)};var Jt=$t(1,"add"),Bt=$t(-1,"subtract");function Qt(e,t){var n=12*(t.year()-e.year())+(t.month()-e.month()),s=e.clone().add(n,"months");return-(n+(t-s<0?(t-s)/(s-e.clone().add(n-1,"months")):(t-s)/(e.clone().add(n+1,"months")-s)))||0}function Xt(e){var t;return void 0===e?this._locale._abbr:(null!=(t=dt(e))&&(this._locale=t),this)}n.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",n.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Kt=k("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});function en(){return this._locale}function tn(e,t){I(0,[e,e.length],0,t)}function nn(e,t,n,s,i){var r;return null==e?Ae(this,s,i).year:(t>(r=je(e,s,i))&&(t=r),function(e,t,n,s,i){var r=Ie(e,t,n,s,i),a=Ve(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}I(0,["gg",2],0,function(){return this.weekYear()%100}),I(0,["GG",2],0,function(){return this.isoWeekYear()%100}),tn("gggg","weekYear"),tn("ggggg","weekYear"),tn("GGGG","isoWeekYear"),tn("GGGGG","isoWeekYear"),H("weekYear","gg"),H("isoWeekYear","GG"),L("weekYear",1),L("isoWeekYear",1),ue("G",se),ue("g",se),ue("GG",B,z),ue("gg",B,z),ue("GGGG",ee,q),ue("gggg",ee,q),ue("GGGGG",te,J),ue("ggggg",te,J),fe(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=M(e)}),fe(["gg","GG"],function(e,t,s,i){t[i]=n.parseTwoDigitYear(e)}),I("Q",0,"Qo","quarter"),H("quarter","Q"),L("quarter",7),ue("Q",Z),ce("Q",function(e,t){t[ye]=3*(M(e)-1)}),I("D",["DD",2],"Do","date"),H("date","D"),L("date",9),ue("D",B),ue("DD",B,z),ue("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),ce(["D","DD"],ge),ce("Do",function(e,t){t[ge]=M(e.match(B)[0])});var sn=xe("Date",!0);I("DDD",["DDDD",3],"DDDo","dayOfYear"),H("dayOfYear","DDD"),L("dayOfYear",4),ue("DDD",K),ue("DDDD",$),ce(["DDD","DDDD"],function(e,t,n){n._dayOfYear=M(e)}),I("m",["mm",2],0,"minute"),H("minute","m"),L("minute",14),ue("m",B),ue("mm",B,z),ce(["m","mm"],ve);var rn=xe("Minutes",!1);I("s",["ss",2],0,"second"),H("second","s"),L("second",15),ue("s",B),ue("ss",B,z),ce(["s","ss"],we);var an,on=xe("Seconds",!1);for(I("S",0,0,function(){return~~(this.millisecond()/100)}),I(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),I(0,["SSS",3],0,"millisecond"),I(0,["SSSS",4],0,function(){return 10*this.millisecond()}),I(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),I(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),I(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),I(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),I(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),H("millisecond","ms"),L("millisecond",16),ue("S",K,Z),ue("SS",K,z),ue("SSS",K,$),an="SSSS";an.length<=9;an+="S")ue(an,ne);function un(e,t){t[Me]=M(1e3*("0."+e))}for(an="S";an.length<=9;an+="S")ce(an,un);var ln=xe("Milliseconds",!1);I("z",0,0,"zoneAbbr"),I("zz",0,0,"zoneName");var dn=p.prototype;function hn(e){return e}dn.add=Jt,dn.calendar=function(e,t){var s=e||xt(),i=Gt(s,this).startOf("day"),r=n.calendarFormat(this,i)||"sameElse",a=t&&(x(t[r])?t[r].call(this,s):t[r]);return this.format(a||this.localeData().calendar(r,this,xt(s)))},dn.clone=function(){return new p(this)},dn.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Gt(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=R(t)){case"year":r=Qt(this,s)/12;break;case"month":r=Qt(this,s);break;case"quarter":r=Qt(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s}return n?r:w(r)},dn.endOf=function(e){return void 0===(e=R(e))||"millisecond"===e?this:("date"===e&&(e="day"),this.startOf(e).add(1,"isoWeek"===e?"week":e).subtract(1,"ms"))},dn.format=function(e){e||(e=this.isUtc()?n.defaultFormatUtc:n.defaultFormat);var t=A(this,e);return this.localeData().postformat(t)},dn.from=function(e,t){return this.isValid()&&(v(e)&&e.isValid()||xt(e).isValid())?jt({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},dn.fromNow=function(e){return this.from(xt(),e)},dn.to=function(e,t){return this.isValid()&&(v(e)&&e.isValid()||xt(e).isValid())?jt({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},dn.toNow=function(e){return this.to(xt(),e)},dn.get=function(e){return x(this[e=R(e)])?this[e]():this},dn.invalidAt=function(){return c(this).overflow},dn.isAfter=function(e,t){var n=v(e)?e:xt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=R(r(t)?"millisecond":t))?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},dn.isBefore=function(e,t){var n=v(e)?e:xt(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=R(r(t)?"millisecond":t))?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},dn.isBetween=function(e,t,n,s){return("("===(s=s||"()")[0]?this.isAfter(e,n):!this.isBefore(e,n))&&(")"===s[1]?this.isBefore(t,n):!this.isAfter(t,n))},dn.isSame=function(e,t){var n,s=v(e)?e:xt(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(t=R(t||"millisecond"))?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},dn.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},dn.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},dn.isValid=function(){return f(this)},dn.lang=Kt,dn.locale=Xt,dn.localeData=en,dn.max=Pt,dn.min=bt,dn.parsingFlags=function(){return d({},c(this))},dn.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:F[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=C(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(x(this[e=R(e)]))return this[e](t);return this},dn.startOf=function(e){switch(e=R(e)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===e&&this.weekday(0),"isoWeek"===e&&this.isoWeekday(1),"quarter"===e&&this.month(3*Math.floor(this.month()/3)),this},dn.subtract=Bt,dn.toArray=function(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]},dn.toObject=function(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}},dn.toDate=function(){return new Date(this.valueOf())},dn.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||n.year()>9999?A(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):x(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",A(n,"Z")):A(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},dn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},dn.toJSON=function(){return this.isValid()?this.toISOString():null},dn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},dn.unix=function(){return Math.floor(this.valueOf()/1e3)},dn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},dn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},dn.year=Te,dn.isLeapYear=function(){return Ye(this.year())},dn.weekYear=function(e){return nn.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},dn.isoWeekYear=function(e){return nn.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},dn.quarter=dn.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},dn.month=Le,dn.daysInMonth=function(){return We(this.year(),this.month())},dn.week=dn.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},dn.isoWeek=dn.isoWeeks=function(e){var t=Ae(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},dn.weeksInYear=function(){var e=this.localeData()._week;return je(this.year(),e.dow,e.doy)},dn.isoWeeksInYear=function(){return je(this.year(),1,4)},dn.date=sn,dn.day=dn.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(e=function(e,t){return"string"!=typeof e?e:isNaN(e)?"number"==typeof(e=t.weekdaysParse(e))?e:null:parseInt(e,10)}(e,this.localeData()),this.add(e-t,"d")):t},dn.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},dn.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null!=e){var t=function(e,t){return"string"==typeof e?t.weekdaysParse(e)%7||7:isNaN(e)?null:e}(e,this.localeData());return this.day(this.day()%7?t:t-7)}return this.day()||7},dn.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},dn.hour=dn.hours=nt,dn.minute=dn.minutes=rn,dn.second=dn.seconds=on,dn.millisecond=dn.milliseconds=ln,dn.utcOffset=function(e,t,s){var i,r=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null!=e){if("string"==typeof e){if(null===(e=Nt(re,e)))return this}else Math.abs(e)<16&&!s&&(e*=60);return!this._isUTC&&t&&(i=Vt(this)),this._offset=e,this._isUTC=!0,null!=i&&this.add(i,"m"),r!==e&&(!t||this._changeInProgress?qt(this,jt(e-r,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,n.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?r:Vt(this)},dn.utc=function(e){return this.utcOffset(0,e)},dn.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Vt(this),"m")),this},dn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Nt(ie,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},dn.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?xt(e).utcOffset():0,(this.utcOffset()-e)%60==0)},dn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},dn.isLocal=function(){return!!this.isValid()&&!this._isUTC},dn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},dn.isUtc=Et,dn.isUTC=Et,dn.zoneAbbr=function(){return this._isUTC?"UTC":""},dn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},dn.dates=k("dates accessor is deprecated. Use date instead.",sn),dn.months=k("months accessor is deprecated. Use month instead",Le),dn.years=k("years accessor is deprecated. Use year instead",Te),dn.zone=k("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),dn.isDSTShifted=k("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!r(this._isDSTShifted))return this._isDSTShifted;var e={};if(y(e,this),(e=Ot(e))._a){var t=e._isUTC?h(e._a):xt(e._a);this._isDSTShifted=this.isValid()&&S(e._a,t.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted});var cn=P.prototype;function fn(e,t,n,s){var i=dt(),r=h().set(s,t);return i[n](r,e)}function mn(e,t,n){if(a(e)&&(t=e,e=void 0),e=e||"",null!=t)return fn(e,t,n,"month");var s,i=[];for(s=0;s<12;s++)i[s]=fn(e,s,n,"month");return i}function _n(e,t,n,s){"boolean"==typeof e?(a(t)&&(n=t,t=void 0),t=t||""):(n=t=e,e=!1,a(t)&&(n=t,t=void 0),t=t||"");var i,r=dt(),o=e?r._week.dow:0;if(null!=n)return fn(t,(n+o)%7,s,"day");var u=[];for(i=0;i<7;i++)u[i]=fn(t,(i+o)%7,s,"day");return u}cn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return x(s)?s.call(t,n):s},cn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},cn.invalidDate=function(){return this._invalidDate},cn.ordinal=function(e){return this._ordinal.replace("%d",e)},cn.preparse=hn,cn.postformat=hn,cn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return x(i)?i(e,t,n,s):i.replace(/%d/i,e)},cn.pastFuture=function(e,t){var n=this._relativeTime[e>0?"future":"past"];return x(n)?n(t):n.replace(/%s/i,t)},cn.set=function(e){var t,n;for(n in e)x(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},cn.months=function(e,t){return e?s(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||He).test(t)?"format":"standalone"][e.month()]:s(this._months)?this._months:this._months.standalone},cn.monthsShort=function(e,t){return e?s(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[He.test(t)?"format":"standalone"][e.month()]:s(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},cn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=h([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Oe.call(this._shortMonthsParse,a))?i:null:-1!==(i=Oe.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Oe.call(this._shortMonthsParse,a))?i:-1!==(i=Oe.call(this._longMonthsParse,a))?i:null:-1!==(i=Oe.call(this._longMonthsParse,a))?i:-1!==(i=Oe.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=h([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},cn.monthsRegex=function(e){return this._monthsParseExact?(l(this,"_monthsRegex")||Ge.call(this),e?this._monthsStrictRegex:this._monthsRegex):(l(this,"_monthsRegex")||(this._monthsRegex=Ne),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},cn.monthsShortRegex=function(e){return this._monthsParseExact?(l(this,"_monthsRegex")||Ge.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(l(this,"_monthsShortRegex")||(this._monthsShortRegex=Ue),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},cn.week=function(e){return Ae(e,this._week.dow,this._week.doy).week},cn.firstDayOfYear=function(){return this._week.doy},cn.firstDayOfWeek=function(){return this._week.dow},cn.weekdays=function(e,t){return e?s(this._weekdays)?this._weekdays[e.day()]:this._weekdays[this._weekdays.isFormat.test(t)?"format":"standalone"][e.day()]:s(this._weekdays)?this._weekdays:this._weekdays.standalone},cn.weekdaysMin=function(e){return e?this._weekdaysMin[e.day()]:this._weekdaysMin},cn.weekdaysShort=function(e){return e?this._weekdaysShort[e.day()]:this._weekdaysShort},cn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=h([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Oe.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Oe.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Oe.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Oe.call(this._weekdaysParse,a))?i:-1!==(i=Oe.call(this._shortWeekdaysParse,a))?i:-1!==(i=Oe.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Oe.call(this._shortWeekdaysParse,a))?i:-1!==(i=Oe.call(this._weekdaysParse,a))?i:-1!==(i=Oe.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Oe.call(this._minWeekdaysParse,a))?i:-1!==(i=Oe.call(this._weekdaysParse,a))?i:-1!==(i=Oe.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=h([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".",".?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".",".?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".",".?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},cn.weekdaysRegex=function(e){return this._weekdaysParseExact?(l(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(l(this,"_weekdaysRegex")||(this._weekdaysRegex=qe),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},cn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(l(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(l(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Je),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},cn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(l(this,"_weekdaysRegex")||Qe.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(l(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Be),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},cn.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},cn.meridiem=function(e,t,n){return e>11?n?"pm":"PM":n?"am":"AM"},ut("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===M(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),n.lang=k("moment.lang is deprecated. Use moment.locale instead.",ut),n.langData=k("moment.langData is deprecated. Use moment.localeData instead.",dt);var yn=Math.abs;function gn(e,t,n,s){var i=jt(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function pn(e){return e<0?Math.floor(e):Math.ceil(e)}function vn(e){return 4800*e/146097}function wn(e){return 146097*e/4800}function Mn(e){return function(){return this.as(e)}}var Sn=Mn("ms"),Dn=Mn("s"),kn=Mn("m"),Yn=Mn("h"),On=Mn("d"),Tn=Mn("w"),xn=Mn("M"),bn=Mn("y");function Pn(e){return function(){return this.isValid()?this._data[e]:NaN}}var Wn=Pn("milliseconds"),Hn=Pn("seconds"),Rn=Pn("minutes"),Cn=Pn("hours"),Fn=Pn("days"),Ln=Pn("months"),Un=Pn("years");var Nn=Math.round,Gn={ss:44,s:45,m:45,h:22,d:26,M:11};var Vn=Math.abs;function En(e){return(e>0)-(e<0)||+e}function In(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=Vn(this._milliseconds)/1e3,s=Vn(this._days),i=Vn(this._months);t=w((e=w(n/60))/60),n%=60,e%=60;var r=w(i/12),a=i%=12,o=s,u=t,l=e,d=n?n.toFixed(3).replace(/\.?0+$/,""):"",h=this.asSeconds();if(!h)return"P0D";var c=h<0?"-":"",f=En(this._months)!==En(h)?"-":"",m=En(this._days)!==En(h)?"-":"",_=En(this._milliseconds)!==En(h)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||d?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(d?_+d+"S":"")}var An=Rt.prototype;return An.isValid=function(){return this._isValid},An.abs=function(){var e=this._data;return this._milliseconds=yn(this._milliseconds),this._days=yn(this._days),this._months=yn(this._months),e.milliseconds=yn(e.milliseconds),e.seconds=yn(e.seconds),e.minutes=yn(e.minutes),e.hours=yn(e.hours),e.months=yn(e.months),e.years=yn(e.years),this},An.add=function(e,t){return gn(this,e,t,1)},An.subtract=function(e,t){return gn(this,e,t,-1)},An.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=R(e))||"year"===e)return t=this._days+s/864e5,n=this._months+vn(t),"month"===e?n:n/12;switch(t=this._days+Math.round(wn(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},An.asMilliseconds=Sn,An.asSeconds=Dn,An.asMinutes=kn,An.asHours=Yn,An.asDays=On,An.asWeeks=Tn,An.asMonths=xn,An.asYears=bn,An.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*M(this._months/12):NaN},An._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return r>=0&&a>=0&&o>=0||r<=0&&a<=0&&o<=0||(r+=864e5*pn(wn(o)+a),a=0,o=0),u.milliseconds=r%1e3,e=w(r/1e3),u.seconds=e%60,t=w(e/60),u.minutes=t%60,n=w(t/60),u.hours=n%24,o+=i=w(vn(a+=w(n/24))),a-=pn(wn(i)),s=w(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},An.clone=function(){return jt(this)},An.get=function(e){return e=R(e),this.isValid()?this[e+"s"]():NaN},An.milliseconds=Wn,An.seconds=Hn,An.minutes=Rn,An.hours=Cn,An.days=Fn,An.weeks=function(){return w(this.days()/7)},An.months=Ln,An.years=Un,An.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t=this.localeData(),n=function(e,t,n){var s=jt(e).abs(),i=Nn(s.as("s")),r=Nn(s.as("m")),a=Nn(s.as("h")),o=Nn(s.as("d")),u=Nn(s.as("M")),l=Nn(s.as("y")),d=i<=Gn.ss&&["s",i]||i<Gn.s&&["ss",i]||r<=1&&["m"]||r<Gn.m&&["mm",r]||a<=1&&["h"]||a<Gn.h&&["hh",a]||o<=1&&["d"]||o<Gn.d&&["dd",o]||u<=1&&["M"]||u<Gn.M&&["MM",u]||l<=1&&["y"]||["yy",l];return d[2]=t,d[3]=+e>0,d[4]=n,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,d)}(this,!e,t);return e&&(n=t.pastFuture(+this,n)),t.postformat(n)},An.toISOString=In,An.toString=In,An.toJSON=In,An.locale=Xt,An.localeData=en,An.toIsoString=k("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",In),An.lang=Kt,I("X",0,0,"unix"),I("x",0,0,"valueOf"),ue("x",se),ue("X",/[+-]?\d+(\.\d{1,3})?/),ce("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),ce("x",function(e,t,n){n._d=new Date(M(e))}),n.version="2.22.1",e=xt,n.fn=dn,n.min=function(){return Wt("isBefore",[].slice.call(arguments,0))},n.max=function(){return Wt("isAfter",[].slice.call(arguments,0))},n.now=function(){return Date.now?Date.now():+new Date},n.utc=h,n.unix=function(e){return xt(1e3*e)},n.months=function(e,t){return mn(e,t,"months")},n.isDate=o,n.locale=ut,n.invalid=m,n.duration=jt,n.isMoment=v,n.weekdays=function(e,t,n){return _n(e,t,n,"weekdays")},n.parseZone=function(){return xt.apply(null,arguments).parseZone()},n.localeData=dt,n.isDuration=Ct,n.monthsShort=function(e,t){return mn(e,t,"monthsShort")},n.weekdaysMin=function(e,t,n){return _n(e,t,n,"weekdaysMin")},n.defineLocale=lt,n.updateLocale=function(e,t){if(null!=t){var n,s,i=st;null!=(s=ot(e))&&(i=s._config),(n=new P(t=b(i,t))).parentLocale=it[e],it[e]=n,ut(e)}else null!=it[e]&&(null!=it[e].parentLocale?it[e]=it[e].parentLocale:null!=it[e]&&delete it[e]);return it[e]},n.locales=function(){return Y(it)},n.weekdaysShort=function(e,t,n){return _n(e,t,n,"weekdaysShort")},n.normalizeUnits=R,n.relativeTimeRounding=function(e){return void 0===e?Nn:"function"==typeof e&&(Nn=e,!0)},n.relativeTimeThreshold=function(e,t){return void 0!==Gn[e]&&(void 0===t?Gn[e]:(Gn[e]=t,"s"===e&&(Gn.ss=t-1),!0))},n.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},n.prototype=dn,n.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"YYYY-[W]WW",MONTH:"YYYY-MM"},n});
-
-},{}],9:[function(require,module,exports){
-var formatTools=require("./tools/format.js"),GHInput=require("./graphhopper/GHInput.js"),GHRoute=require("./graphhopper/GHRoute.js"),mapLayer=require("./map.js"),dataToHtml=function(e,t){var o="";if(e.name)o+="<div class='nameseg'>"+formatTools.formatValue(e.name,t)+"</div>";else if(e.street){var a=e.street;e.housenumber&&(a=formatTools.insComma(a,e.housenumber)),o+="<div class='nameseg'>"+formatTools.formatValue(a,t)+"</div>"}var n="";return e.postcode&&(n=e.postcode),e.city&&(n=formatTools.insComma(n,e.city)),e.country&&(n=formatTools.insComma(n,e.country)),n&&(o+="<div class='cityseg'>"+formatTools.formatValue(n,t)+"</div>"),e.osm_key,"place"===e.osm_key?o+="<span class='moreseg'>"+e.osm_value+"</span>":o+="<span class='moreseg'>"+e.osm_key+"</span>",o},dataToText=function(e){var t="";return e.name?t=e.name:e.street&&(t=e.street,e.housenumber&&(t=formatTools.insComma(t,e.housenumber))),e.postcode&&(t=formatTools.insComma(t,e.postcode)),e.city&&t.indexOf(e.city)<0&&(t=formatTools.insComma(t,e.city)),e.country&&t.indexOf(e.country)<0&&(t=formatTools.insComma(t,e.country)),t},AutoComplete=function(e,t){this.host=e,this.key=t,this.dataType="json",this.api_params={locale:"en"}};AutoComplete.prototype.createPath=function(e){for(var t in this.api_params){var o=this.api_params[t];if(GHRoute.isArray(o))for(var a in o)e+="&"+encodeURIComponent(t)+"="+encodeURIComponent(o[a]);else e+="&"+encodeURIComponent(t)+"="+encodeURIComponent(o)}return e},AutoComplete.prototype.createGeocodeURL=function(e,t){var o=this.createPath(this.host+"/geocode?limit=6&type="+this.dataType+"&key="+this.key);if(t>=0&&t<e.route.size()){var a=e.route.getIndex(t);a.isResolved()&&(o+="&point="+a.lat+","+a.lng)}return o},AutoComplete.prototype.getAutoCompleteDiv=function(e){return $("#locationpoints > div.pointDiv").eq(e).find(".pointInput")},AutoComplete.prototype.hide=function(){$(':input[id$="_Input"]').autocomplete().hide()},AutoComplete.prototype.showListForIndex=function(e,t,o){var a=this.getAutoCompleteDiv(o),n=this.createGeocodeURL(e,o-1),r={containerClass:"autocomplete",timeout:1e3,deferRequestBy:5,minChars:2,maxHeight:510,noCache:!0,triggerSelectOnValidInput:!1,autoSelectFirst:!1,paramName:"q",dataType:e.dataType,onSearchStart:function(e){return void 0===new GHInput(e.q).lat},serviceUrl:function(){return n},transformResult:function(e,t){if(e.suggestions=[],e.hits)for(var o=0;o<e.hits.length;o++){var a=e.hits[o];e.suggestions.push({value:dataToText(a),data:a})}return e},onSearchError:function(e,t,o,a,n){},formatResult:function(e,t){return dataToHtml(e.data,t)},onSelect:function(e){r.onPreSelect(e)},onPreSelect:function(n){var r=e.route.getIndex(o);a.autocomplete().disable();var s=n.data.point;r.setCoord(s.lat,s.lng),r.input=n.value,t(!0)||mapLayer.focus(r,15,o),a.autocomplete().enable()}};a.autocomplete(r)},AutoComplete.prototype.createStub=function(){return complete=new AutoComplete,complete.showListForIndex=function(){},complete.hide=function(){},complete},AutoComplete.prototype.setLocale=function(e){e&&(this.api_params.locale=e)},module.exports=AutoComplete;
-
-},{"./graphhopper/GHInput.js":13,"./graphhopper/GHRoute.js":15,"./map.js":24,"./tools/format.js":28}],10:[function(require,module,exports){
-exports.options={environment:"development",routing:{host:"",api_key:""},geocoding:{host:"",api_key:""},thunderforest:{api_key:""},omniscale:{api_key:""}};
-
-},{}],11:[function(require,module,exports){
-var ghenv=require("./options.js").options,tfAddition="";ghenv.thunderforest.api_key&&(tfAddition="?apikey="+ghenv.thunderforest.api_key);var osAPIKey="mapsgraph-bf48cc0b";ghenv.omniscale.api_key&&(osAPIKey=ghenv.omniscale.api_key);var osmAttr='&copy; <a href="http://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors',retinaTiles=L.Browser.retina,lyrk=L.tileLayer("https://tiles.lyrk.org/"+(retinaTiles?"lr":"ls")+"/{z}/{x}/{y}?apikey=6e8cfef737a140e2a58c8122aaa26077",{attribution:osmAttr+', <a href="https://geodienste.lyrk.de/">Lyrk</a>'}),omniscale=L.tileLayer("https://maps.omniscale.net/v2/"+osAPIKey+"/style.default"+(retinaTiles?"/hq.true":"")+"/{z}/{x}/{y}.png",{layers:"osm",attribution:osmAttr+', &copy; <a href="https://maps.omniscale.com/">Omniscale</a>'}),openMapSurfer=L.tileLayer("http://korona.geog.uni-heidelberg.de/tiles/roads/x={x}&y={y}&z={z}",{attribution:osmAttr+', <a href="http://korona.geog.uni-heidelberg.de/contact.html">GIScience Heidelberg</a>'}),sorbianLang=L.tileLayer("http://a.tile.openstreetmap.de/tiles/osmhrb/{z}/{x}/{y}.png",{attribution:osmAttr+', <a href="http://www.alberding.eu/">&copy; Alberding GmbH, CC-BY-SA</a>'}),thunderTransport=L.tileLayer("https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/transport/" target="_blank">Thunderforest Transport</a>'}),thunderCycle=L.tileLayer("https://{s}.tile.thunderforest.com/cycle/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/opencyclemap/" target="_blank">Thunderforest Cycle</a>'}),thunderOutdoors=L.tileLayer("https://{s}.tile.thunderforest.com/outdoors/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://www.thunderforest.com/maps/outdoors/" target="_blank">Thunderforest Outdoors</a>'}),thunderNeighbourhood=L.tileLayer("https://{s}.tile.thunderforest.com/neighbourhood/{z}/{x}/{y}.png"+tfAddition,{attribution:osmAttr+', <a href="https://thunderforest.com/maps/neighbourhood/" target="_blank">Thunderforest Neighbourhood</a>'}),wrk=L.tileLayer("http://{s}.wanderreitkarte.de/topo/{z}/{x}/{y}.png",{attribution:osmAttr+', <a href="http://wanderreitkarte.de" target="_blank">WanderReitKarte</a>',subdomains:["topo4","topo","topo2","topo3"]}),osm=L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",{attribution:osmAttr}),osmde=L.tileLayer("http://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png",{attribution:osmAttr}),mapLink='<a href="http://www.esri.com/">Esri</a>',wholink="i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",esriAerial=L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",{attribution:"&copy; "+mapLink+", "+wholink,maxZoom:18}),availableTileLayers={Omniscale:omniscale,OpenStreetMap:osm,"Esri Aerial":esriAerial,"TF Transport":thunderTransport,"TF Cycle":thunderCycle,"TF Outdoors":thunderOutdoors,"TF Neighbourhood":thunderNeighbourhood,Lyrk:lyrk,WanderReitKarte:wrk,OpenMapSurfer:openMapSurfer,"Sorbian Language":sorbianLang,"OpenStreetMap.de":osmde};module.exports.activeLayerName="Omniscale",module.exports.defaultLayer=omniscale,module.exports.getAvailableTileLayers=function(){return availableTileLayers},module.exports.selectLayer=function(e){var t=availableTileLayers[e];return t||(t=module.exports.defaultLayer),t};
-
-},{"./options.js":10}],12:[function(require,module,exports){
-var ensureOneCheckboxSelected=function(){$("#gpx_route").change(function(){$(this).is(":checked")?($("#gpx_track").prop("disabled",!1),$("#gpx_waypoints").prop("disabled",!1)):$("#gpx_track").is(":checked")?$("#gpx_waypoints").is(":checked")||$("#gpx_track").prop("disabled",!0):$("#gpx_waypoints").prop("disabled",!0)}),$("#gpx_track").change(function(){$(this).is(":checked")?($("#gpx_route").prop("disabled",!1),$("#gpx_waypoints").prop("disabled",!1)):$("#gpx_route").is(":checked")?$("#gpx_waypoints").is(":checked")||$("#gpx_route").prop("disabled",!0):$("#gpx_waypoints").prop("disabled",!0)}),$("#gpx_waypoints").change(function(){$(this).is(":checked")?($("#gpx_route").prop("disabled",!1),$("#gpx_track").prop("disabled",!1)):$("#gpx_route").is(":checked")?$("#gpx_track").is(":checked")||$("#gpx_route").prop("disabled",!0):$("#gpx_track").prop("disabled",!0)})};module.exports.addGpxExport=function(e){var p;function o(){var o,i,t;return o=$("#gpx_route").is(":checked"),i=$("#gpx_track").is(":checked"),t=$("#gpx_waypoints").is(":checked"),e.route.isResolved()&&window.open(e.createGPXURL(o,i,t)),p.dialog("close"),!1}$(function(){p=$("#gpx_dialog").dialog({width:420,height:260,autoOpen:!1,resizable:!1,draggable:!1,buttons:{"Export GPX":o,Cancel:function(){$(this).dialog("close")}}}),ensureOneCheckboxSelected()}),$("#gpxExportButton a").click(function(e){e.preventDefault(),$("#gpx_dialog").dialog("open")})};
-
-},{}],13:[function(require,module,exports){
-function round(t,n){return void 0===n&&(n=1e6),Math.round(t*n)/n}var GHInput=function(t){this.set(t)};GHInput.isObject=function(t){return"[object object]"===Object.prototype.toString.call(t).toLowerCase()},GHInput.isString=function(t){return"[object string]"===Object.prototype.toString.call(t).toLowerCase()},GHInput.prototype.isResolved=function(){return!isNaN(this.lat)&&!isNaN(this.lng)},GHInput.prototype.setCoord=function(t,n){this.lat=round(t),this.lng=round(n),this.input=this.toString()},GHInput.prototype.setUnresolved=function(){this.lat=void 0,this.lng=void 0},GHInput.prototype.set=function(t){if(this.input=t,GHInput.isObject(t))this.setCoord(t.lat,t.lng);else if(GHInput.isString(t)){var n=t.indexOf(",");n>=0?(this.lat=round(parseFloat(t.substr(0,n))),this.lng=round(parseFloat(t.substr(n+1))),this.isResolved()?this.input=this.toString():this.setUnresolved()):this.setUnresolved()}},GHInput.prototype.toString=function(){if(void 0!==this.lat&&void 0!==this.lng)return this.lat+","+this.lng},module.exports=GHInput;
-
-},{}],14:[function(require,module,exports){
-var GHRoute=require("./GHRoute.js"),GHInput=require("./GHInput.js"),graphhopperTools=require("./tools.js");Function.prototype.bind||(Function.prototype.bind=function(t){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var e=Array.prototype.slice.call(arguments,1),i=this,o=function(){},s=function(){return i.apply(this instanceof o&&t?this:t,e.concat(Array.prototype.slice.call(arguments)))};return o.prototype=this.prototype,s.prototype=new o,s});var GHRequest=function(t,e){this.host=t,this.route=new GHRoute(new GHInput,new GHInput),this.from=this.route.first(),this.to=this.route.last(),this.features={},this.do_zoom=!0,this.useMiles=!1,this.dataType="json",this.api_params={locale:"en",vehicle:"car",weighting:"fastest",elevation:!1,key:e,pt:{}},this.route.addListener("route.add",function(t){this.to=this.route.last()}.bind(this)),this.route.addListener("route.remove",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.move",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this)),this.route.addListener("route.reverse",function(t){this.from=this.route.first(),this.to=this.route.last()}.bind(this))};GHRequest.prototype.init=function(t){for(var e in t)if("point"!==e&&"mathRandom"!==e&&"do_zoom"!==e&&"layer"!==e&&"use_miles"!==e){var i=t[e];"false"===i?i=!1:"true"===i&&(i=!0),this.api_params[e]=i}"do_zoom"in t&&(this.do_zoom=t.do_zoom),"use_miles"in t&&(this.useMiles=t.use_miles),this.api_params.elevation=!1;var o=this.features[this.api_params.vehicle];if(o&&o.elevation&&(this.api_params.elevation=!("elevation"in t)||t.elevation),t.q){var s=t.q;t.point||(t.point=[]);var r=s.indexOf("from:"),a=s.indexOf("to:");if(r>=0&&a>=0)r<a?(t.point.push(s.substring(r+5,a).trim()),t.point.push(s.substring(a+3).trim())):(t.point.push(s.substring(a+3,r).trim()),t.point.push(s.substring(r+5).trim()));else for(var n=s.split("p:"),p=0;p<n.length;p++){var u=n[p].trim();0!==u.length&&t.point.push(u)}}},GHRequest.prototype.setEarliestDepartureTime=function(t){this.api_params.pt.earliest_departure_time=t},GHRequest.prototype.getEarliestDepartureTime=function(){if(this.api_params.pt.earliest_departure_time)return this.api_params.pt.earliest_departure_time},GHRequest.prototype.initVehicle=function(t){this.api_params.vehicle=t;var e=this.features[t];e&&e.elevation?this.api_params.elevation=!0:this.api_params.elevation=!1},GHRequest.prototype.hasElevation=function(){return this.api_params.elevation},GHRequest.prototype.getVehicle=function(){return this.api_params.vehicle},GHRequest.prototype.isPublicTransit=function(){return"pt"===this.getVehicle()},GHRequest.prototype.createGeocodeURL=function(t,e){var i=this.host;t&&(i=t);var o=this.createPath(i+"/geocode?limit=6&type="+this.dataType);if(e>=0&&e<this.route.size()){var s=this.route.getIndex(e);s.isResolved()&&(o+="&point="+s.lat+","+s.lng)}return o},GHRequest.prototype.createURL=function(){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type="+this.dataType)},GHRequest.prototype.createGPXURL=function(t,e,i){return this.createPath(this.host+"/route?"+this.createPointParams(!1)+"&type=gpx&gpx.route="+t+"&gpx.track="+e+"&gpx.waypoints="+i)},GHRequest.prototype.createHistoryURL=function(){return this.createPath("?"+this.createPointParams(!0),{key:!0})+"&use_miles="+!!this.useMiles},GHRequest.prototype.createPointParams=function(t){var e,i,o,s="";for(i=0,o=this.route.size();i<o;i++)e=this.route.getIndex(i),i>0&&(s+="&"),void 0===e.input?s+="point=":s+=t?"point="+encodeURIComponent(e.input):"point="+encodeURIComponent(e.toString());return s},GHRequest.prototype.createPath=function(t,e){for(var i in this.api_params)if(!e||!e[i]){var o=this.api_params[i];t+=this.flatParameter(i,o)}return t},GHRequest.prototype.flatParameter=function(t,e){var i,o,s="";if(GHRoute.isObject(e)){for(o in i=Object.keys(e)){var r=i[o];s+=this.flatParameter(t+"."+r,e[r])}return s}if(GHRoute.isArray(e)){for(o in i=e)s+=this.flatParameter(t,i[o]);return s}return"&"+encodeURIComponent(t)+"="+encodeURIComponent(e)},GHRequest.prototype.doRequest=function(t,e){var i=this;$.ajax({timeout:3e4,url:t,success:function(t){if(t.paths)for(var o=0;o<t.paths.length;o++){var s=t.paths[o];if(s.points_encoded){var r=graphhopperTools.decodePath(s.points,i.hasElevation());s.points={type:"LineString",coordinates:r};var a=graphhopperTools.decodePath(s.snapped_waypoints,i.hasElevation());s.snapped_waypoints={type:"MultiPoint",coordinates:a}}}e(t)},error:function(i){var o,s="API did not respond! ";if(i&&i.responseText&&i.responseText.indexOf("{")>=0)o=JSON.parse(i.responseText);else if(i&&i.statusText&&"OK"!==i.statusText){o={message:s+=i.statusText,hints:[{message:s,details:"Error for "+t}]}}console.log(s+" "+JSON.stringify(i)),e(o)},type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.getInfo=function(){var t=this.host+"/info?type="+this.dataType+"&key="+this.getKey();return $.ajax({url:t,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},GHRequest.prototype.setLocale=function(t){t&&(this.api_params.locale=t)},GHRequest.prototype.getKey=function(){return this.api_params.key},GHRequest.prototype.fetchTranslationMap=function(t){t||(t="");var e=this.host+"/i18n/"+t+"?type="+this.dataType+"&key="+this.getKey();return $.ajax({url:e,timeout:3e3,type:"GET",dataType:this.dataType,crossDomain:!0})},module.exports=GHRequest;
-
-},{"./GHInput.js":13,"./GHRoute.js":15,"./tools.js":16}],15:[function(require,module,exports){
-var GHInput=require("./GHInput.js"),GHroute=function(){var t=Object.create(Array.prototype);return t=Array.apply(t,arguments)||t,GHroute.injectClassMethods(t),t._listeners={},t};GHroute.injectClassMethods=function(t){for(var e in GHroute.prototype)GHroute.prototype.hasOwnProperty(e)&&(t[e]=GHroute.prototype[e]);return t},GHroute.fromArray=function(t){return GHroute.apply(null,t)},GHroute.isArray=function(t){return"[object array]"===Object.prototype.toString.call(t).toLowerCase()},GHroute.isObject=function(t){return"[object object]"===Object.prototype.toString.call(t).toLowerCase()},GHroute.prototype={first:function(){return this.getIndex(0)},last:function(){return this.getIndex(this.length-1)},getIndex:function(t){return this[t=isNaN(t)?0:t]instanceof GHInput&&this[t]},getIndexByCoord:function(t){var e,r,i=!1,n=new GHInput(t);for(e=0,r=this.length;e<r;e++)if(this[e].toString()===n.toString()){i=e;break}return i},getIndexFromCoord:function(t){return this.getIndex(this.getIndexByCoord(t))},size:function(){return this.length},add:function(t,e){if(GHroute.isArray(t)){for(var r=0;r<t.length;r++)Array.prototype.push.call(this,t[r]instanceof GHInput?t[r]:new GHInput(t[r])),void 0!==e?(this.move(-1,e,!0),e++):e=this.lenght-1,this.fire("route.add",{point:this[e],to:e});return this}return Array.prototype.push.call(this,t instanceof GHInput?t:new GHInput(t)),void 0!==e?this.move(-1,e,!0):e=this.lenght-1,this.fire("route.add",{point:this[e],to:e}),this[e]},removeSingle:function(t){var e=!1;return isNaN(t)||t>=this.length||void 0===this[t]?(t instanceof GHInput&&(t=t.toString()),e=this.getIndexByCoord(t)):e=t,!1!==e&&this.remove(e),this},remove:function(t,e){var r=e||1;return Array.prototype.splice.call(this,t,r),1===this.length&&Array.prototype.push.call(this,new GHInput),this.fire("route.remove",{from:t,to:r}),this},addAll:function(){for(var t=0;t<arguments.length;t++)this.add(arguments[t]);return this},set:function(t,e,r){if(t instanceof GHInput)this[e]=t;else{if(!(this[e]instanceof GHInput))return!!r&&this.add(t,e);this[e].set(t)}return this.fire("route.set",{point:this[e],to:e}),this[e]},move:function(t,e,r){for(;t<0;)t+=this.length;for(;e<0;)e+=this.length;if(e>=this.length)for(var i=e-this.length;1+i--;)Array.prototype.push.call(this,void 0);return Array.prototype.splice.call(this,e,0,Array.prototype.splice.call(this,t,1)[0]),r||this.fire("route.move",{old_index:t,new_index:e}),this},reverse:function(){return Array.prototype.reverse.call(this),this.fire("route.reverse",{}),this},isResolved:function(){for(var t=0,e=this.length;t<e;t++){if(!this[t].isResolved())return!1}return!0},addListener:function(t,e){return void 0===this._listeners[t]&&(this._listeners[t]=[]),this._listeners[t].push(e),this},fire:function(t,e){if("string"==typeof t&&(t={type:t}),"object"==typeof e)for(var r in e)t[r]=e[r];if(t.route||(t.route=this),!t.type)throw new Error("Event object missing 'type' property.");if(this._listeners[t.type]instanceof Array)for(var i=this._listeners[t.type],n=0,o=i.length;n<o;n++)i[n].call(this,t)},removeListener:function(t,e){if(this._listeners[t]instanceof Array)for(var r=this._listeners[t],i=0,n=r.length;i<n;i++)if(r[i]===e){r.splice(i,1);break}}},module.exports=GHroute;
-
-},{"./GHInput.js":13}],16:[function(require,module,exports){
-var decodePath=function(e,d){for(var o=e.length,h=0,r=[],t=0,a=0,c=0;h<o;){var l,i=0,u=0;do{u|=(31&(l=e.charCodeAt(h++)-63))<<i,i+=5}while(l>=32);t+=1&u?~(u>>1):u>>1,i=0,u=0;do{u|=(31&(l=e.charCodeAt(h++)-63))<<i,i+=5}while(l>=32);if(a+=1&u?~(u>>1):u>>1,d){i=0,u=0;do{u|=(31&(l=e.charCodeAt(h++)-63))<<i,i+=5}while(l>=32);c+=1&u?~(u>>1):u>>1,r.push([1e-5*a,1e-5*t,c/100])}else r.push([1e-5*a,1e-5*t])}return r};module.exports.decodePath=decodePath;
-
-},{}],17:[function(require,module,exports){
-var translate=require("./translate.js"),messages=require("./messages.js"),routeSegmentPopup=null;function addInstruction(t,e,n,a,r,o,i){var s=n.sign;s=0===a?"marker-icon-green":messages.getSignName(s);var p=n.text;n.annotation_text&&(p=p?p+", "+n.annotation_text:n.annotation_text);var c=window.location.pathname,d=c.substring(0,c.lastIndexOf("/")),l=$("<tr class='instruction'/>");if("continue"!==s){var g="<img class='pic' style='vertical-align: middle' src='"+d+"/img/"+s+".png'/>";l.append("<td class='instr_pic'>"+g+"</td>")}else l.append("<td class='instr_pic'/>");var u=$("<td class='instr_title'>");u.text(p),l.append(u);var m=n.distance;m>0&&l.append("<td class='instr_distance'><span>"+translate.createDistanceString(m,o)+"<br/>"+translate.createTimeString(n.time)+"</span></td>"),r&&(l.click(function(){routeSegmentPopup&&t.removeLayerFromMap(routeSegmentPopup),routeSegmentPopup=L.popup().setLatLng([r[1],r[0]]).setContent(p).openOn(t.getMap())}),i&&L.marker([r[1],r[0]],{icon:L.icon({iconUrl:"./img/marker-small-red.png",iconSize:[16,16]}),draggable:!0,autoPan:!0}).addTo(t.getRoutingLayer()).bindPopup(p)),e.append(l)}module.exports.create=function(t,e,n,a){for(var r=$("<table class='instructions'>"),o=a.api_params.debug,i=e.instructions.length>100,s=Math.min(e.instructions.length,100),p=0;p<s;p++){var c=e.instructions[p],d=e.points.coordinates[c.interval[0]];addInstruction(t,r,c,p,d,a.useMiles,o)}var l=$("<div class='instructions_info'>");if(l.append(r),i){var g=$("<button id='moreButton'>"+translate.tr("more_button")+"…</button>");g.click(function(){g.remove();for(var n=s;n<e.instructions.length;n++){var o=e.instructions[n],i=e.points.coordinates[o.interval[0]];addInstruction(t,r,o,n,i,a.useMiles)}}),r.append(g)}var u=$("<div id='routeDetails'/>");u.hide();var m=$("<button class='expandDetails'>+</button>");m.click(function(){u.toggle()}),l.append(m);var f="points: "+e.points.coordinates.length;u.append("<span>"+f+"</span>"),$("#export-link a").attr("href",n);var v=$("<br/><a>view on OSM</a>"),h=a.getVehicle();"bicycle"===h?h="bike":h.indexOf("truck")>=0&&(h="car"),v.attr("href","http://www.openstreetmap.org/directions?engine=graphhopper_"+h+"&route="+encodeURIComponent(a.from.lat+","+a.from.lng+";"+a.to.lat+","+a.to.lng)),u.append(v);var b=$("<a>OSRM</a>");b.attr("href","http://map.project-osrm.org/?z=13&loc="+a.from+"&loc="+a.to),u.append("<br/><span>Compare with: </span>"),u.append(b);var x=$("<a>Google</a> "),w="",_="";"FOOT"===a.getVehicle().toUpperCase()?(w="&dirflg=w",_="&mode=W"):(a.getVehicle().toUpperCase().indexOf("BIKE")>=0||"MTB"===a.getVehicle().toUpperCase())&&(w="&dirflg=b"),x.attr("href","https://maps.google.com/?saddr="+a.from+"&daddr="+a.to+w),u.append(x);var S=$("<a>Bing</a> ");return S.attr("href","https://www.bing.com/maps/default.aspx?rtp=adr."+a.from+"~adr."+a.to+_),u.append(S),metaVersionInfo&&u.append(metaVersionInfo),l.append(u),l};
-
-},{"./messages.js":25,"./translate.js":32}],18:[function(require,module,exports){
-!function(t){"function"==typeof define&&define.amd?define(["jquery"],t):t(jQuery)}(function(t){t.ui=t.ui||{},t.ui.version="1.12.0";var e=0,i=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,o,n;for(n=0;null!=(o=i[n]);n++)try{(s=t._data(o,"events"))&&s.remove&&t(o).triggerHandler("remove")}catch(t){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var o,n,r,h={},a=e.split(".")[0],l=a+"-"+(e=e.split(".")[1]);return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[a]=t[a]||{},o=t[a][e],n=t[a][e]=function(t,e){return this._createWidget?void(arguments.length&&this._createWidget(t,e)):new n(t,e)},t.extend(n,o,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),(r=new i).options=t.widget.extend({},r.options),t.each(s,function(e,s){return t.isFunction(s)?void(h[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,n=this._superApply;return this._super=t,this._superApply=o,e=s.apply(this,arguments),this._super=i,this._superApply=n,e}}()):void(h[e]=s)}),n.prototype=t.widget.extend(r,{widgetEventPrefix:o&&r.widgetEventPrefix||e},h,{constructor:n,namespace:a,widgetName:e,widgetFullName:l}),o?(t.each(o._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,n,i._proto)}),delete o._childConstructors):i._childConstructors.push(n),t.widget.bridge(e,n),n},t.widget.extend=function(e){for(var s,o,n=i.call(arguments,1),r=0,h=n.length;h>r;r++)for(s in n[r])o=n[r][s],n[r].hasOwnProperty(s)&&void 0!==o&&(e[s]=t.isPlainObject(o)?t.isPlainObject(e[s])?t.widget.extend({},e[s],o):t.widget.extend({},o):o);return e},t.widget.bridge=function(e,s){var o=s.prototype.widgetFullName||e;t.fn[e]=function(n){var r="string"==typeof n,h=i.call(arguments,1),a=this;return r?this.each(function(){var i,s=t.data(this,o);return"instance"===n?(a=s,!1):s?t.isFunction(s[n])&&"_"!==n.charAt(0)?(i=s[n].apply(s,h))!==s&&void 0!==i?(a=i&&i.jquery?a.pushStack(i.get()):i,!1):void 0:t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; attempted to call method '"+n+"'")}):(h.length&&(n=t.widget.extend.apply(null,[n].concat(h))),this.each(function(){var e=t.data(this,o);e?(e.option(n||{}),e._init&&e._init()):t.data(this,o,new s(n,this))})),a}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(i,s){s=t(s||this.defaultElement||this)[0],this.element=t(s),this.uuid=e++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},s!==this&&(t.data(s,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===s&&this.destroy()}}),this.document=t(s.style?s.ownerDocument:s.document||s),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),i),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,o,n,r=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(r={},e=(s=e.split(".")).shift(),s.length){for(o=r[e]=t.widget.extend({},this.options[e]),n=0;s.length-1>n;n++)o[s[n]]=o[s[n]]||{},o=o[s[n]];if(e=s.pop(),1===arguments.length)return void 0===o[e]?null:o[e];o[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];r[e]=i}return this._setOptions(r),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,o;for(i in e)o=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&o&&o.length&&(s=t(o.get()),this._removeClass(o,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,n){var r,h;for(h=0;i.length>h;h++)r=o.classesElementLookup[i[h]]||t(),r=e.add?t(t.unique(r.get().concat(e.element.get()))):t(r.not(e.element).get()),o.classesElementLookup[i[h]]=r,s.push(i[h]),n&&e.classes[i[h]]&&s.push(e.classes[i[h]])}var s=[],o=this;return(e=t.extend({element:this.element,classes:this.options.classes||{}},e)).keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var o="string"==typeof t||null===t,n={extra:o?e:i,keys:o?t:e,element:o?this.element:t,add:s};return n.element.toggleClass(this._classes(n),s),this},_on:function(e,i,s){var o,n=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=o=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,o=this.widget()),t.each(s,function(s,r){function h(){return e||!0!==n.options.disabled&&!t(this).hasClass("ui-state-disabled")?("string"==typeof r?n[r]:r).apply(n,arguments):void 0}"string"!=typeof r&&(h.guid=r.guid=r.guid||h.guid||t.guid++);var a=s.match(/^([\w:-]*)\s*(.*)$/),l=a[1]+n.eventNamespace,c=a[2];c?o.on(l,c,h):i.on(l,h)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){var i=this;return setTimeout(function(){return("string"==typeof t?i[t]:t).apply(i,arguments)},e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var o,n,r=this.options[e];if(s=s||{},(i=t.Event(i)).type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],n=i.originalEvent)for(o in n)o in i||(i[o]=n[o]);return this.element.trigger(i,s),!(t.isFunction(r)&&!1===r.apply(this.element[0],[i].concat(s))||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,o,n){"string"==typeof o&&(o={effect:o});var r,h=o?!0===o||"number"==typeof o?i:o.effect||i:e;"number"==typeof(o=o||{})&&(o={duration:o}),r=!t.isEmptyObject(o),o.complete=n,o.delay&&s.delay(o.delay),r&&t.effects&&t.effects.effect[h]?s[e](o):h!==e&&s[h]?s[h](o.duration,o.easing,n):s.queue(function(i){t(this)[e](),n&&n.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}var s,o,n=Math.max,r=Math.abs,h=Math.round,a=/left|center|right/,l=/top|center|bottom/,c=/[\+\-]\d+(\.[\d]+)?%?/,p=/^\w+/,u=/%$/,d=t.fn.position;o=function(){var e=t("<div>").css("position","absolute").appendTo("body").offset({top:1.5,left:1.5}),i=1.5===e.offset().top;return e.remove(),o=function(){return i},i},t.position={scrollbarWidth:function(){if(void 0!==s)return s;var e,i,o=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),n=o.children()[0];return t("body").append(o),e=n.offsetWidth,o.css("overflow","scroll"),e===(i=n.offsetWidth)&&(i=o[0].clientWidth),o.remove(),s=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),o="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth;return{width:"scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight?t.position.scrollbarWidth():0,height:o?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),o=!!i[0]&&9===i[0].nodeType;return{element:i,isWindow:s,isDocument:o,offset:!s&&!o?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(s){if(!s||!s.of)return d.apply(this,arguments);s=t.extend({},s);var u,f,g,m,_,v,b=t(s.of),w=t.position.getWithinInfo(s.within),y=t.position.getScrollInfo(w),P=(s.collision||"flip").split(" "),x={};return v=function(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}(b),b[0].preventDefault&&(s.at="left top"),f=v.width,g=v.height,m=v.offset,_=t.extend({},m),t.each(["my","at"],function(){var t,e,i=(s[this]||"").split(" ");1===i.length&&(i=a.test(i[0])?i.concat(["center"]):l.test(i[0])?["center"].concat(i):["center","center"]),i[0]=a.test(i[0])?i[0]:"center",i[1]=l.test(i[1])?i[1]:"center",t=c.exec(i[0]),e=c.exec(i[1]),x[this]=[t?t[0]:0,e?e[0]:0],s[this]=[p.exec(i[0])[0],p.exec(i[1])[0]]}),1===P.length&&(P[1]=P[0]),"right"===s.at[0]?_.left+=f:"center"===s.at[0]&&(_.left+=f/2),"bottom"===s.at[1]?_.top+=g:"center"===s.at[1]&&(_.top+=g/2),u=e(x.at,f,g),_.left+=u[0],_.top+=u[1],this.each(function(){var a,l,c=t(this),p=c.outerWidth(),d=c.outerHeight(),v=i(this,"marginLeft"),z=i(this,"marginTop"),C=p+v+i(this,"marginRight")+y.width,H=d+z+i(this,"marginBottom")+y.height,T=t.extend({},_),k=e(x.my,c.outerWidth(),c.outerHeight());"right"===s.my[0]?T.left-=p:"center"===s.my[0]&&(T.left-=p/2),"bottom"===s.my[1]?T.top-=d:"center"===s.my[1]&&(T.top-=d/2),T.left+=k[0],T.top+=k[1],o()||(T.left=h(T.left),T.top=h(T.top)),a={marginLeft:v,marginTop:z},t.each(["left","top"],function(e,i){t.ui.position[P[e]]&&t.ui.position[P[e]][i](T,{targetWidth:f,targetHeight:g,elemWidth:p,elemHeight:d,collisionPosition:a,collisionWidth:C,collisionHeight:H,offset:[u[0]+k[0],u[1]+k[1]],my:s.my,at:s.at,within:w,elem:c})}),s.using&&(l=function(t){var e=m.left-T.left,i=e+f-p,o=m.top-T.top,h=o+g-d,a={target:{element:b,left:m.left,top:m.top,width:f,height:g},element:{element:c,left:T.left,top:T.top,width:p,height:d},horizontal:0>i?"left":e>0?"right":"center",vertical:0>h?"top":o>0?"bottom":"middle"};p>f&&f>r(e+i)&&(a.horizontal="center"),d>g&&g>r(o+h)&&(a.vertical="middle"),a.important=n(r(e),r(i))>n(r(o),r(h))?"horizontal":"vertical",s.using.call(this,t,a)}),c.offset(t.extend(T,{using:l}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,o=s.isWindow?s.scrollLeft:s.offset.left,r=s.width,h=t.left-e.collisionPosition.marginLeft,a=o-h,l=h+e.collisionWidth-r-o;e.collisionWidth>r?a>0&&0>=l?(i=t.left+a+e.collisionWidth-r-o,t.left+=a-i):t.left=l>0&&0>=a?o:a>l?o+r-e.collisionWidth:o:a>0?t.left+=a:l>0?t.left-=l:t.left=n(t.left-h,t.left)},top:function(t,e){var i,s=e.within,o=s.isWindow?s.scrollTop:s.offset.top,r=e.within.height,h=t.top-e.collisionPosition.marginTop,a=o-h,l=h+e.collisionHeight-r-o;e.collisionHeight>r?a>0&&0>=l?(i=t.top+a+e.collisionHeight-r-o,t.top+=a-i):t.top=l>0&&0>=a?o:a>l?o+r-e.collisionHeight:o:a>0?t.top+=a:l>0?t.top-=l:t.top=n(t.top-h,t.top)}},flip:{left:function(t,e){var i,s,o=e.within,n=o.offset.left+o.scrollLeft,h=o.width,a=o.isWindow?o.scrollLeft:o.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-a,p=l+e.collisionWidth-h-a,u="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,d="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(0>(i=t.left+u+d+f+e.collisionWidth-h-n)||r(c)>i)&&(t.left+=u+d+f):p>0&&(((s=t.left-e.collisionPosition.marginLeft+u+d+f-a)>0||p>r(s))&&(t.left+=u+d+f))},top:function(t,e){var i,s,o=e.within,n=o.offset.top+o.scrollTop,h=o.height,a=o.isWindow?o.scrollTop:o.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-a,p=l+e.collisionHeight-h-a,u="top"===e.my[1]?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,d="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,f=-2*e.offset[1];0>c?(0>(s=t.top+u+d+f+e.collisionHeight-h-n)||r(c)>s)&&(t.top+=u+d+f):p>0&&(((i=t.top-e.collisionPosition.marginTop+u+d+f-a)>0||p>r(i))&&(t.top+=u+d+f))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}}),t.ui.focusable=function(e,i){var s,o,n,r,h,a=e.nodeName.toLowerCase();return"area"===a?(o=(s=e.parentNode).name,!(!e.href||!o||"map"!==s.nodeName.toLowerCase())&&((n=t("img[usemap='#"+o+"']")).length>0&&n.is(":visible"))):(/^(input|select|textarea|button|object)$/.test(a)?(r=!e.disabled)&&((h=t(e).closest("fieldset")[0])&&(r=!h.disabled)):r="a"===a&&e.href||i,r&&t(e).is(":visible")&&function(t){for(var e=t.css("visibility");"inherit"===e;)e=(t=t.parent()).css("visibility");return"hidden"!==e}(t(e)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,n){return t.each(o,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),n&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var o="Width"===i?["Left","Right"]:["Top","Bottom"],n=i.toLowerCase(),r={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?r["inner"+i].call(this):this.each(function(){t(this).css(n,s(this,e)+"px")})},t.fn["outer"+i]=function(e,o){return"number"!=typeof e?r["outer"+i].call(this,e):this.each(function(){t(this).css(n,s(this,e,!0,o)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,o,n;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(o=this.eq(0).parents("label"),(s=this.attr("id"))&&(n=(e=this.eq(0).parents().last()).add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",o=o.add(n.find(i).addBack(i))),this.pushStack(o))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,o=e?/(auto|scroll|hidden)/:/(auto|scroll)/,n=this.parents().filter(function(){var e=t(this);return(!s||"static"!==e.css("position"))&&o.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&n.length?n:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var s=!1;t(document).on("mouseup",function(){s=!1}),t.widget("ui.mouse",{version:"1.12.0",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!s){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,o=1===e.which,n=!("string"!=typeof this.options.cancel||!e.target.nodeName)&&t(e.target).closest(this.options.cancel).length;return!(o&&!n&&this._mouseCapture(e))||(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=!1!==this._mouseStart(e),!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),s=!0,!0))}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=!1!==this._mouseStart(this._mouseDownEvent,e),this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,s=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var o,n=t.ui[e].prototype;for(o in s)n.plugins[o]=n.plugins[o]||[],n.plugins[o].push([i,s[o]])},call:function(t,e,i,s){var o,n=t.plugins[e];if(n&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(o=0;n.length>o;o++)t.options[n[o][0]]&&n[o][1].apply(t.element,i)}},t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?void(this.destroyOnClear=!0):(this._removeHandleClassName(),void this._mouseDestroy())},_mouseCapture:function(e){var i=this.options;return this._blurActiveElement(e),!(this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0)&&(this.handle=this._getHandle(e),!!this.handle&&(this._blockFrames(!0===i.iframeFix?"iframe":i.iframeFix),!0))},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);this._getHandle(e)&&s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),!1===this._trigger("start",e)?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(!1===this._trigger("drag",e,s))return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||!0===this.options.revert||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){!1!==i._trigger("stop",e)&&i._clear()}):!1!==this._trigger("stop",e)&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return!this.options.handle||!!t(e.target).closest(this.element.find(this.options.handle)).length},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),o=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return o.parents("body").length||o.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&o[0]===this.element[0]&&this._setPositionRelative(),o[0]===this.element[0]||/(fixed|absolute)/.test(o.css("position"))||o.css("position","absolute"),o},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,o=this.options,n=this.document[0];return this.relativeContainer=null,o.containment?"window"===o.containment?void(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]):"document"===o.containment?void(this.containment=[0,0,t(n).width()-this.helperProportions.width-this.margins.left,(t(n).height()||n.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]):o.containment.constructor===Array?void(this.containment=o.containment):("parent"===o.containment&&(o.containment=this.helper[0].parentNode),void((s=(i=t(o.containment))[0])&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i))):void(this.containment=null)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,o,n,r=this.options,h=this._isRootNode(this.scrollParent[0]),a=t.pageX,l=t.pageY;return h&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(a=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(a=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),r.grid&&(o=r.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/r.grid[1])*r.grid[1]:this.originalPageY,l=i?o-this.offset.click.top>=i[1]||o-this.offset.click.top>i[3]?o:o-this.offset.click.top>=i[1]?o-r.grid[1]:o+r.grid[1]:o,n=r.grid[0]?this.originalPageX+Math.round((a-this.originalPageX)/r.grid[0])*r.grid[0]:this.originalPageX,a=i?n-this.offset.click.left>=i[0]||n-this.offset.click.left>i[2]?n:n-this.offset.click.left>=i[0]?n-r.grid[0]:n+r.grid[0]:n),"y"===r.axis&&(a=this.originalPageX),"x"===r.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:h?0:this.offset.scroll.top),left:a-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:h?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var o=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,o))})},stop:function(e,i,s){var o=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,o))})},drag:function(e,i,s){t.each(s.sortables,function(){var o=!1,n=this;n.positionAbs=s.positionAbs,n.helperProportions=s.helperProportions,n.offset.click=s.offset.click,n._intersectsWith(n.containerCache)&&(o=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==n&&this._intersectsWith(this.containerCache)&&t.contains(n.element[0],this.element[0])&&(o=!1),o})),o?(n.isOver||(n.isOver=1,s._parent=i.helper.parent(),n.currentItem=i.helper.appendTo(n.element).data("ui-sortable-item",!0),n.options._helper=n.options.helper,n.options.helper=function(){return i.helper[0]},e.target=n.currentItem[0],n._mouseCapture(e,!0),n._mouseStart(e,!0,!0),n.offset.click.top=s.offset.click.top,n.offset.click.left=s.offset.click.left,n.offset.parent.left-=s.offset.parent.left-n.offset.parent.left,n.offset.parent.top-=s.offset.parent.top-n.offset.parent.top,s._trigger("toSortable",e),s.dropped=n.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,n.fromOutside=s),n.currentItem&&(n._mouseDrag(e),i.position=n.position)):n.isOver&&(n.isOver=0,n.cancelHelperRemoval=!0,n.options._revert=n.options.revert,n.options.revert=!1,n._trigger("out",e,n._uiHash(n)),n._mouseStop(e,!0),n.options.revert=n.options._revert,n.options.helper=n.options._helper,n.placeholder&&n.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var o=t("body"),n=s.options;o.css("cursor")&&(n._cursor=o.css("cursor")),o.css("cursor",n.cursor)},stop:function(e,i,s){var o=s.options;o._cursor&&t("body").css("cursor",o._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var o=t(i.helper),n=s.options;o.css("opacity")&&(n._opacity=o.css("opacity")),o.css("opacity",n.opacity)},stop:function(e,i,s){var o=s.options;o._opacity&&t(i.helper).css("opacity",o._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var o=s.options,n=!1,r=s.scrollParentNotHidden[0],h=s.document[0];r!==h&&"HTML"!==r.tagName?(o.axis&&"x"===o.axis||(s.overflowOffset.top+r.offsetHeight-e.pageY<o.scrollSensitivity?r.scrollTop=n=r.scrollTop+o.scrollSpeed:e.pageY-s.overflowOffset.top<o.scrollSensitivity&&(r.scrollTop=n=r.scrollTop-o.scrollSpeed)),o.axis&&"y"===o.axis||(s.overflowOffset.left+r.offsetWidth-e.pageX<o.scrollSensitivity?r.scrollLeft=n=r.scrollLeft+o.scrollSpeed:e.pageX-s.overflowOffset.left<o.scrollSensitivity&&(r.scrollLeft=n=r.scrollLeft-o.scrollSpeed))):(o.axis&&"x"===o.axis||(e.pageY-t(h).scrollTop()<o.scrollSensitivity?n=t(h).scrollTop(t(h).scrollTop()-o.scrollSpeed):t(window).height()-(e.pageY-t(h).scrollTop())<o.scrollSensitivity&&(n=t(h).scrollTop(t(h).scrollTop()+o.scrollSpeed))),o.axis&&"y"===o.axis||(e.pageX-t(h).scrollLeft()<o.scrollSensitivity?n=t(h).scrollLeft(t(h).scrollLeft()-o.scrollSpeed):t(window).width()-(e.pageX-t(h).scrollLeft())<o.scrollSensitivity&&(n=t(h).scrollLeft(t(h).scrollLeft()+o.scrollSpeed)))),!1!==n&&t.ui.ddmanager&&!o.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var o=s.options;s.snapElements=[],t(o.snap.constructor!==String?o.snap.items||":data(ui-draggable)":o.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var o,n,r,h,a,l,c,p,u,d,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(u=s.snapElements.length-1;u>=0;u--)l=(a=s.snapElements[u].left-s.margins.left)+s.snapElements[u].width,p=(c=s.snapElements[u].top-s.margins.top)+s.snapElements[u].height,a-g>_||m>l+g||c-g>b||v>p+g||!t.contains(s.snapElements[u].item.ownerDocument,s.snapElements[u].item)?(s.snapElements[u].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[u].item})),s.snapElements[u].snapping=!1):("inner"!==f.snapMode&&(o=g>=Math.abs(c-b),n=g>=Math.abs(p-v),r=g>=Math.abs(a-_),h=g>=Math.abs(l-m),o&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),n&&(i.position.top=s._convertPositionTo("relative",{top:p,left:0}).top),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:a-s.helperProportions.width}).left),h&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),d=o||n||r||h,"outer"!==f.snapMode&&(o=g>=Math.abs(c-v),n=g>=Math.abs(p-b),r=g>=Math.abs(a-m),h=g>=Math.abs(l-_),o&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),n&&(i.position.top=s._convertPositionTo("relative",{top:p-s.helperProportions.height,left:0}).top),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:a}).left),h&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[u].snapping&&(o||n||r||h||d)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[u].item})),s.snapElements[u].snapping=o||n||r||h||d)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var o,n=s.options,r=t.makeArray(t(n.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});r.length&&(o=parseInt(t(r[0]).css("zIndex"),10)||0,t(r).each(function(e){t(this).css("zIndex",o+e)}),this.css("zIndex",o+r.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var o=t(i.helper),n=s.options;o.css("zIndex")&&(n._zIndex=o.css("zIndex")),o.css("zIndex",n.zIndex)},stop:function(e,i,s){var o=s.options;o._zIndex&&t(i.helper).css("zIndex",o._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",o=!1;return e[s]>0||(e[s]=1,o=e[s]>0,e[s]=0,o)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles()}},_setupHandles:function(){var e,i,s,o,n,r=this.options,h=this;if(this.handles=r.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)o="ui-resizable-"+(e=t.trim(s[i])),n=t("<div>"),this._addClass(n,"ui-resizable-handle "+o),n.css({zIndex:r.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(n);this._renderAxis=function(e){var i,s,o,n;for(i in e=e||this.element,this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:h._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),n=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),o=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(o,n),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){h.resizing||(this.className&&(n=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),h.axis=n&&n[1]?n[1]:"se")}),r.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,o=!1;for(i in this.handles)((s=t(this.handles[i])[0])===e.target||t.contains(s,e.target))&&(o=!0);return!this.options.disabled&&o},_mouseStart:function(e){var i,s,o,n=this.options,r=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),n.containment&&(i+=t(n.containment).scrollLeft()||0,s+=t(n.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:r.width(),height:r.height()},this.originalSize=this._helper?{width:r.outerWidth(),height:r.outerHeight()}:{width:r.width(),height:r.height()},this.sizeDiff={width:r.outerWidth()-r.width(),height:r.outerHeight()-r.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof n.aspectRatio?n.aspectRatio:this.originalSize.width/this.originalSize.height||1,o=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===o?this.axis+"-resize":o),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,o=this.originalMousePosition,n=this.axis,r=e.pageX-o.left||0,h=e.pageY-o.top||0,a=this._change[n];return this._updatePrevProperties(),!!a&&(i=a.apply(this,[e,r,h]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1)},_mouseStop:function(e){this.resizing=!1;var i,s,o,n,r,h,a,l=this.options,c=this;return this._helper&&(o=(s=(i=this._proportionallyResizeElements).length&&/textarea/i.test(i[0].nodeName))&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,n=s?0:c.sizeDiff.width,r={width:c.helper.width()-n,height:c.helper.height()-o},h=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,a=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(r,{top:a,left:h})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,o,n,r=this.options;n={minWidth:this._isNumber(r.minWidth)?r.minWidth:0,maxWidth:this._isNumber(r.maxWidth)?r.maxWidth:1/0,minHeight:this._isNumber(r.minHeight)?r.minHeight:0,maxHeight:this._isNumber(r.maxHeight)?r.maxHeight:1/0},(this._aspectRatio||t)&&(e=n.minHeight*this.aspectRatio,s=n.minWidth/this.aspectRatio,i=n.maxHeight*this.aspectRatio,o=n.maxWidth/this.aspectRatio,e>n.minWidth&&(n.minWidth=e),s>n.minHeight&&(n.minHeight=s),n.maxWidth>i&&(n.maxWidth=i),n.maxHeight>o&&(n.maxHeight=o)),this._vBoundaries=n},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,o=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,n=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,r=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,h=this.originalPosition.left+this.originalSize.width,a=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return n&&(t.width=e.minWidth),r&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),o&&(t.height=e.maxHeight),n&&l&&(t.left=h-e.minWidth),s&&l&&(t.left=h-e.maxWidth),r&&c&&(t.top=a-e.minHeight),o&&c&&(t.top=a-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],o=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(o[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize;return{left:this.originalPosition.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize;return{top:this.originalPosition.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,o=i._proportionallyResizeElements,n=o.length&&/textarea/i.test(o[0].nodeName),r=n&&i._hasScroll(o[0],"left")?0:i.sizeDiff.height,h=n?0:i.sizeDiff.width,a={width:i.size.width-h,height:i.size.height-r},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(a,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};o&&o.length&&t(o[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,o,n,r,h,a=t(this).resizable("instance"),l=a.options,c=a.element,p=l.containment,u=p instanceof t?p.get(0):/parent/.test(p)?c.parent().get(0):p;u&&(a.containerElement=t(u),/document/.test(p)||p===document?(a.containerOffset={left:0,top:0},a.containerPosition={left:0,top:0},a.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(u),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=a._num(e.css("padding"+s))}),a.containerOffset=e.offset(),a.containerPosition=e.position(),a.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=a.containerOffset,o=a.containerSize.height,n=a.containerSize.width,r=a._hasScroll(u,"left")?u.scrollWidth:n,h=a._hasScroll(u)?u.scrollHeight:o,a.parentData={element:u,left:s.left,top:s.top,width:r,height:h}))},resize:function(e){var i,s,o,n,r=t(this).resizable("instance"),h=r.options,a=r.containerOffset,l=r.position,c=r._aspectRatio||e.shiftKey,p={top:0,left:0},u=r.containerElement,d=!0;u[0]!==document&&/static/.test(u.css("position"))&&(p=a),l.left<(r._helper?a.left:0)&&(r.size.width=r.size.width+(r._helper?r.position.left-a.left:r.position.left-p.left),c&&(r.size.height=r.size.width/r.aspectRatio,d=!1),r.position.left=h.helper?a.left:0),l.top<(r._helper?a.top:0)&&(r.size.height=r.size.height+(r._helper?r.position.top-a.top:r.position.top),c&&(r.size.width=r.size.height*r.aspectRatio,d=!1),r.position.top=r._helper?a.top:0),o=r.containerElement.get(0)===r.element.parent().get(0),n=/relative|absolute/.test(r.containerElement.css("position")),o&&n?(r.offset.left=r.parentData.left+r.position.left,r.offset.top=r.parentData.top+r.position.top):(r.offset.left=r.element.offset().left,r.offset.top=r.element.offset().top),i=Math.abs(r.sizeDiff.width+(r._helper?r.offset.left-p.left:r.offset.left-a.left)),s=Math.abs(r.sizeDiff.height+(r._helper?r.offset.top-p.top:r.offset.top-a.top)),i+r.size.width>=r.parentData.width&&(r.size.width=r.parentData.width-i,c&&(r.size.height=r.size.width/r.aspectRatio,d=!1)),s+r.size.height>=r.parentData.height&&(r.size.height=r.parentData.height-s,c&&(r.size.width=r.size.height*r.aspectRatio,d=!1)),d||(r.position.left=r.prevPosition.left,r.position.top=r.prevPosition.top,r.size.width=r.prevSize.width,r.size.height=r.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,o=e.containerPosition,n=e.containerElement,r=t(e.helper),h=r.offset(),a=r.outerWidth()-e.sizeDiff.width,l=r.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(n.css("position"))&&t(this).css({left:h.left-o.left-s.left,width:a,height:l}),e._helper&&!i.animate&&/static/.test(n.css("position"))&&t(this).css({left:h.left-o.left-s.left,width:a,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance").options;t(e.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),o=s.options,n=s.originalSize,r=s.originalPosition,h={height:s.size.height-n.height||0,width:s.size.width-n.width||0,top:s.position.top-r.top||0,left:s.position.left-r.left||0};t(o.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),o={},n=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(n,function(t,e){var i=(s[e]||0)+(h[e]||0);i&&i>=0&&(o[e]=i||null)}),e.css(o)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),!1!==t.uiBackCompat&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,o=i.size,n=i.originalSize,r=i.originalPosition,h=i.axis,a="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=a[0]||1,c=a[1]||1,p=Math.round((o.width-n.width)/l)*l,u=Math.round((o.height-n.height)/c)*c,d=n.width+p,f=n.height+u,g=s.maxWidth&&d>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>d,v=s.minHeight&&s.minHeight>f;s.grid=a,_&&(d+=l),v&&(f+=c),g&&(d-=l),m&&(f-=c),/^(se|s|e)$/.test(h)?(i.size.width=d,i.size.height=f):/^(ne)$/.test(h)?(i.size.width=d,i.size.height=f,i.position.top=r.top-u):/^(sw)$/.test(h)?(i.size.width=d,i.size.height=f,i.position.left=r.left-p):((0>=f-c||0>=d-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=r.top-u):(f=c-e.height,i.size.height=f,i.position.top=r.top+n.height-f),d-l>0?(i.size.width=d,i.position.left=r.left-p):(d=l-e.width,i.size.width=d,i.position.left=r.left+n.width-d))}}),t.ui.resizable,t.widget("ui.sortable",t.ui.mouse,{version:"1.12.0",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,o=!1,n=this;return!this.reverting&&(!this.options.disabled&&"static"!==this.options.type&&(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,n.widgetName+"-item")===n?(s=t(this),!1):void 0}),t.data(e.target,n.widgetName+"-item")===n&&(s=t(e.target)),!!s&&(!(this.options.handle&&!i&&(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(o=!0)}),!o))&&(this.currentItem=s,this._removeCurrentsFromItems(),!0))))},_mouseStart:function(e,i,s){var o,n,r=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,r.cursorAt&&this._adjustOffsetFromHelper(r.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),r.containment&&this._setContainment(),r.cursor&&"auto"!==r.cursor&&(n=this.document.find("body"),this.storedCursor=n.css("cursor"),n.css("cursor",r.cursor),this.storedStylesheet=t("<style>*{ cursor: "+r.cursor+" !important; }</style>").appendTo(n)),r.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",r.opacity)),r.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",r.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(o=this.containers.length-1;o>=0;o--)this.containers[o]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!r.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,o,n,r=this.options,h=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<r.scrollSensitivity?this.scrollParent[0].scrollTop=h=this.scrollParent[0].scrollTop+r.scrollSpeed:e.pageY-this.overflowOffset.top<r.scrollSensitivity&&(this.scrollParent[0].scrollTop=h=this.scrollParent[0].scrollTop-r.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<r.scrollSensitivity?this.scrollParent[0].scrollLeft=h=this.scrollParent[0].scrollLeft+r.scrollSpeed:e.pageX-this.overflowOffset.left<r.scrollSensitivity&&(this.scrollParent[0].scrollLeft=h=this.scrollParent[0].scrollLeft-r.scrollSpeed)):(e.pageY-this.document.scrollTop()<r.scrollSensitivity?h=this.document.scrollTop(this.document.scrollTop()-r.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<r.scrollSensitivity&&(h=this.document.scrollTop(this.document.scrollTop()+r.scrollSpeed)),e.pageX-this.document.scrollLeft()<r.scrollSensitivity?h=this.document.scrollLeft(this.document.scrollLeft()-r.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<r.scrollSensitivity&&(h=this.document.scrollLeft(this.document.scrollLeft()+r.scrollSpeed))),!1!==h&&t.ui.ddmanager&&!r.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(o=(s=this.items[i]).item[0],(n=this._intersectsWithPointer(s))&&s.instance===this.currentContainer&&o!==this.currentItem[0]&&this.placeholder[1===n?"next":"prev"]()[0]!==o&&!t.contains(this.placeholder[0],o)&&("semi-dynamic"!==this.options.type||!t.contains(this.element[0],o))){if(this.direction=1===n?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,o=this.placeholder.offset(),n=this.options.axis,r={};n&&"x"!==n||(r.left=o.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),n&&"y"!==n||(r.top=o.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(r,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp({target:null}),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,o=s+this.helperProportions.height,n=t.left,r=n+t.width,h=t.top,a=h+t.height,l=this.offset.click.top,c=this.offset.click.left,p="x"===this.options.axis||s+l>h&&a>s+l,u="y"===this.options.axis||e+c>n&&r>e+c,d=p&&u;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?d:e+this.helperProportions.width/2>n&&r>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>h&&a>o-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),o="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width);return!!(s&&o)&&(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1))},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),o=this._getDragHorizontalDirection();return this.floating&&o?"right"===o&&i||"left"===o&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){h.push(this)}var s,o,n,r,h=[],a=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(o=(n=t(l[s],this.document[0])).length-1;o>=0;o--)(r=t.data(n[o],this.widgetFullName))&&r!==this&&!r.options.disabled&&a.push([t.isFunction(r.options.items)?r.options.items.call(r.element):t(r.options.items,r.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),r]);for(a.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=a.length-1;s>=0;s--)a[s][0].each(i);return t(h)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,o,n,r,h,a,l,c=this.items,p=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],u=this._connectWith();if(u&&this.ready)for(i=u.length-1;i>=0;i--)for(s=(o=t(u[i],this.document[0])).length-1;s>=0;s--)(n=t.data(o[s],this.widgetFullName))&&n!==this&&!n.options.disabled&&(p.push([t.isFunction(n.options.items)?n.options.items.call(n.element[0],e,{item:this.currentItem}):t(n.options.items,n.element),n]),this.containers.push(n));for(i=p.length-1;i>=0;i--)for(r=p[i][1],s=0,l=(h=p[i][0]).length;l>s;s++)(a=t(h[s])).data(this.widgetName+"-item",r),c.push({item:a,instance:r,width:0,height:0,left:0,top:0})},refreshPositions:function(e){var i,s,o,n;for(this.floating=!!this.items.length&&("x"===this.options.axis||this._isFloating(this.items[0].item)),this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset()),i=this.items.length-1;i>=0;i--)(s=this.items[i]).instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(o=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=o.outerWidth(),s.height=o.outerHeight()),n=o.offset(),s.left=n.left,s.top=n.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)n=this.containers[i].element.offset(),this.containers[i].containerCache.left=n.left,this.containers[i].containerCache.top=n.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){var i,s=(e=e||this).options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),o=t("<"+s+">",e.document[0]);return e._addClass(o,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(o,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(o)):"tr"===s?e._createTrPlaceholder(e.currentItem,o):"img"===s&&o.attr("src",e.currentItem.attr("src")),i||o.css("visibility","hidden"),o},update:function(t,o){(!i||s.forcePlaceholderSize)&&(o.height()||o.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),o.width()||o.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,o,n,r,h,a,l,c,p,u=null,d=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(u&&t.contains(this.containers[i].element[0],u.element[0]))continue;u=this.containers[i],d=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(u)if(1===this.containers.length)this.containers[d].containerCache.over||(this.containers[d]._trigger("over",e,this._uiHash(this)),this.containers[d].containerCache.over=1);else{for(o=1e4,n=null,r=(c=u.floating||this._isFloating(this.currentItem))?"left":"top",h=c?"width":"height",p=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[d].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(a=this.items[s].item.offset()[r],l=!1,e[p]-a>this.items[s][h]/2&&(l=!0),o>Math.abs(e[p]-a)&&(o=Math.abs(e[p]-a),n=this.items[s],this.direction=l?"up":"down"));if(!n&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[d])return void(this.currentContainer.containerCache.over||(this.containers[d]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1));n?this._rearrange(e,n,null,!0):this._rearrange(e,null,this.containers[d].element,!0),this._trigger("change",e,this._uiHash()),this.containers[d]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[d],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[d]._trigger("over",e,this._uiHash(this)),this.containers[d].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,o=this.options;"parent"===o.containment&&(o.containment=this.helper[0].parentNode),("document"===o.containment||"window"===o.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===o.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===o.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(o.containment)||(e=t(o.containment)[0],i=t(o.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,o="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,n=/(html|body)/i.test(o[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():n?0:o.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():n?0:o.scrollLeft())*s}},_generatePosition:function(e){var i,s,o=this.options,n=e.pageX,r=e.pageY,h="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,a=/(html|body)/i.test(h[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(n=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(r=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(n=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(r=this.containment[3]+this.offset.click.top)),o.grid&&(i=this.originalPageY+Math.round((r-this.originalPageY)/o.grid[1])*o.grid[1],r=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-o.grid[1]:i+o.grid[1]:i,s=this.originalPageX+Math.round((n-this.originalPageX)/o.grid[0])*o.grid[0],n=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-o.grid[0]:s+o.grid[0]:s)),{top:r-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():a?0:h.scrollTop()),left:n-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():a?0:h.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var o=this.counter;this._delay(function(){o===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,o=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&o.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||o.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(o.push(function(t){this._trigger("remove",t,this._uiHash())}),o.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),o.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||o.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(o.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;o.length>s;s++)o[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){!1===t.Widget.prototype._trigger.apply(this,arguments)&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}});var o=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.0",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,o){var n,r={};return o?"controlgroupLabel"===s?((n=e.element.find(o)).each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(n,null,"ui-widget ui-widget-content ui-state-default"),void(i=i.concat(n.get()))):void(t.fn[s]&&(e["_"+s+"Options"]&&(r=e["_"+s+"Options"]("middle")),e.element.find(o).each(function(){var o=t(this),n=o[s]("instance"),h=t.widget.extend({},r);if("button"!==s||!o.parent(".ui-spinner").length){n||(n=o[s]()[s]("instance")),n&&(h.classes=e._resolveClassesValues(h.classes,n)),o[s](h);var a=o[s]("widget");t.data(a[0],"ui-controlgroup-data",n||o[s]("instance")),i.push(a[0])}}))):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this).data("ui-controlgroup-data");i&&i[e]&&i[e]()})},_updateCornerClass:function(t,e){var i=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,"ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all"),this._addClass(t,null,i)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:!!e&&"auto",classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(t){var n=i.options.classes[t]||"";n=n.replace(o,"").trim(),s[t]=(n+" "+e[t]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?void this._callChildMethod(e?"disable":"enable"):void this.refresh()},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var o=e[s]().data("ui-controlgroup-data");if(o&&i["_"+o.widgetName+"Options"]){var n=i["_"+o.widgetName+"Options"](1===e.length?"only":s);n.classes=i._resolveClassesValues(n.classes,o),o.element[o.widgetName](n)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.0",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,o=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(o.label=this.originalLabel),null!=(e=this.element[0].disabled)&&(o.disabled=e),o},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e=this.element[0].name,i="input[name='"+t.ui.escapeSelector(e)+"']";return e?(this.form.length?t(this.form[0].elements).filter(i):t(i).filter(function(){return 0===t(this).form().length})).not(this.element):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),void(this.element[0].disabled=e)):void this.refresh()):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){this.label.contents().not(this.element.add(this.icon).add(this.iconSpace)).remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.0",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),null!=(t=this.element[0].disabled)&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,o=s?this.options.iconPosition:i,n="top"===o||"bottom"===o;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(o),n?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(o))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),!1!==t.uiBackCompat&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?void this._super("showLabel",e):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),void this._superApply(arguments))}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.widget("ui.dialog",{version:"1.12.0",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),(t=e.parent.children().eq(e.index)).length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&!1!==this._trigger("beforeClose",e)&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,o=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),n=Math.max.apply(null,o);return n>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",n+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?void(this._moveToTop()&&this._focusTabbable()):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),void this._trigger("open"))},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]);this.uiDialog[0]===e||t.contains(this.uiDialog[0],e)||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),void this.close(e);if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),o=i.filter(":last");e.target!==o[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){o.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?void this._removeClass(this.uiDialog,"ui-dialog-buttons"):(t.each(i,function(i,s){var o,n;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),o=s.click,n={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,t("<button></button>",s).button(n).appendTo(e.uiButtonSet).on("click",function(){o.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),void this.uiDialogButtonPane.appendTo(this.uiDialog))},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,o){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(o))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(o,n){var r=n.offset.left-i.document.scrollLeft(),h=n.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",o,e(n))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,o=s.resizable,n=this.uiDialog.css("position"),r="string"==typeof o?o:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:r,start:function(s,o){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(o))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(o,n){var r=i.uiDialog.offset(),h=r.left-i.document.scrollLeft(),a=r.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(h>=0?"+":"")+h+" top"+(a>=0?"+":"")+a,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",o,e(n))}}).css("position",n)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,o={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(o[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",o)},_setOption:function(e,i){var s,o,n=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&((s=n.is(":data(ui-draggable)"))&&!i&&n.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&((o=n.is(":data(ui-resizable)"))&&!i&&n.resizable("destroy"),o&&"string"==typeof i&&n.resizable("option","handles",i),o||!1===i||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return!!t(e.target).closest(".ui-dialog").length||!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),!1!==t.uiBackCompat&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog});
-
-},{}],19:[function(require,module,exports){
-!function(e){"use strict";"function"==typeof define&&define.amd?define(["jquery"],e):e(jQuery)}(function(e){"use strict";var t={escapeRegExChars:function(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},createNode:function(e){var t=document.createElement("div");return t.className=e,t.style.position="absolute",t.style.display="none",t.style.cursor="pointer",t}},s=27,i=9,n=13,o=38,l=39,a=40;function u(t,s){var i=function(){},n={autoSelectFirst:!1,appendTo:"body",serviceUrl:null,lookup:null,onSelect:null,width:"auto",minChars:1,maxHeight:300,deferRequestBy:0,params:{},formatResult:u.formatResult,onPreSelect:i,delimiter:null,zIndex:9999,type:"GET",noCache:!1,onSearchStart:i,onSearchComplete:i,onSearchError:i,containerClass:"autocomplete-suggestions",tabDisabled:!1,dataType:"text",currentRequest:null,triggerSelectOnValidInput:!0,lookupFilter:function(e,t,s){return-1!==e.value.toLowerCase().indexOf(s)},paramName:"query",transformResult:function(t){return"string"==typeof t?e.parseJSON(t):t}};this.element=t,this.el=e(t),this.suggestions=[],this.badQueries=[],this.selectedIndex=-1,this.currentValue=this.element.value,this.intervalId=0,this.cachedResponse={},this.onChangeInterval=null,this.onChange=null,this.isLocal=!1,this.suggestionsContainer=null,this.options=e.extend({},n,s),this.classes={selected:"autocomplete-selected",suggestion:"autocomplete-suggestion"},this.hint=null,this.hintValue="",this.selection=null,this.initialize(),this.setOptions(s)}u.utils=t,e.Autocomplete=u,u.formatResult=function(e,s){var i="("+t.escapeRegExChars(s)+")";return e.value.replace(new RegExp(i,"gi"),"<strong>$1</strong>")},u.prototype={killerFn:null,initialize:function(){var t,s=this,i="."+s.classes.suggestion,n=(s.classes.selected,s.options);s.element.setAttribute("autocomplete","off"),s.killerFn=function(t){0===e(t.target).closest("."+s.options.containerClass).length&&(s.killSuggestions(),s.disableKillerFn())},s.suggestionsContainer=u.utils.createNode(n.containerClass),(t=e(s.suggestionsContainer)).appendTo(n.appendTo),"auto"!==n.width&&t.width(n.width),t.on("click.autocomplete",i,function(){s.select(e(this).data("index"))}),s.fixPosition(),s.fixPositionCapture=function(){s.visible&&s.fixPosition()},e(window).on("resize.autocomplete",s.fixPositionCapture),s.el.on("keydown.autocomplete",function(e){s.onKeyPress(e)}),s.el.on("keyup.autocomplete",function(e){s.onKeyUp(e)}),s.el.on("blur.autocomplete",function(){s.onBlur()}),s.el.on("focus.autocomplete",function(){s.onFocus()}),s.el.on("change.autocomplete",function(e){s.onKeyUp(e)})},onFocus:function(){this.fixPosition(),this.options.minChars,this.el.val().length},onBlur:function(){this.enableKillerFn()},setOptions:function(t){var s=this.options;e.extend(s,t),this.isLocal=e.isArray(s.lookup),this.isLocal&&(s.lookup=this.verifySuggestionsFormat(s.lookup)),e(this.suggestionsContainer).css({"max-height":s.maxHeight+"px",width:s.width+"px","z-index":s.zIndex})},clearCache:function(){this.cachedResponse={},this.badQueries=[]},clear:function(){this.clearCache(),this.currentValue="",this.suggestions=[]},disable:function(){this.disabled=!0,this.currentRequest&&this.currentRequest.abort()},enable:function(){this.disabled=!1},fixPosition:function(){var t,s;"body"===this.options.appendTo&&(s={top:(t=this.el.offset()).top+this.el.outerHeight()+"px",left:t.left+"px"},"auto"===this.options.width&&(s.width=this.el.outerWidth()-2+"px"),e(this.suggestionsContainer).css(s))},enableKillerFn:function(){e(document).on("click.autocomplete",this.killerFn)},disableKillerFn:function(){e(document).off("click.autocomplete",this.killerFn)},killSuggestions:function(){var e=this;e.stopKillSuggestions(),e.intervalId=window.setInterval(function(){e.hide(),e.stopKillSuggestions()},50)},stopKillSuggestions:function(){window.clearInterval(this.intervalId)},isCursorAtEnd:function(){var e,t=this.el.val().length,s=this.element.selectionStart;return"number"==typeof s?s===t:!document.selection||((e=document.selection.createRange()).moveStart("character",-t),t===e.text.length)},onKeyPress:function(e){if(this.disabled||this.visible||e.which!==a||!this.currentValue){if(!this.disabled&&this.visible){switch(e.which){case s:this.el.val(this.currentValue),this.hide();break;case l:if(this.hint&&this.options.onHint&&this.isCursorAtEnd()){this.selectHint();break}return;case i:if(this.hint&&this.options.onHint)return void this.selectHint();case n:if(-1===this.selectedIndex)return void this.hide();if(this.select(this.selectedIndex),e.which===i&&!1===this.options.tabDisabled)return;break;case o:this.moveUp();break;case a:this.moveDown();break;default:return}e.stopImmediatePropagation(),e.preventDefault()}}else this.suggest()},onKeyUp:function(e){var t=this;if(!t.disabled){switch(e.which){case o:case a:return}clearInterval(t.onChangeInterval),t.currentValue!==t.el.val()&&(t.findBestHint(),t.options.deferRequestBy>0?t.onChangeInterval=setInterval(function(){t.onValueChange()},t.options.deferRequestBy):t.onValueChange())}},onValueChange:function(){var t,s=this.options,i=this.el.val(),n=this.getQuery(i);this.selection&&(this.selection=null,(s.onInvalidateSelection||e.noop).call(this.element)),clearInterval(this.onChangeInterval),this.currentValue=i,this.selectedIndex=-1,s.triggerSelectOnValidInput&&-1!==(t=this.findSuggestionIndex(n))?this.select(t):n.length<s.minChars?this.hide():this.getSuggestions(n)},findSuggestionIndex:function(t){var s=-1,i=t.toLowerCase();return e.each(this.suggestions,function(e,t){if(t.value.toLowerCase()===i)return s=e,!1}),s},getQuery:function(t){var s,i=this.options.delimiter;return i?(s=t.split(i),e.trim(s[s.length-1])):t},getSuggestionsLocal:function(t){var s,i=this.options,n=t.toLowerCase(),o=i.lookupFilter,l=parseInt(i.lookupLimit,10);return s={suggestions:e.grep(i.lookup,function(e){return o(e,t,n)})},l&&s.suggestions.length>l&&(s.suggestions=s.suggestions.slice(0,l)),s},getSuggestions:function(t){var s,i,n,o=this,l=o.options,a=l.serviceUrl;if(l.params[l.paramName]=t,i=l.ignoreParams?null:l.params,o.isLocal?s=o.getSuggestionsLocal(t):(e.isFunction(a)&&(a=a.call(o.element,t)),n=a+"?"+e.param(i||{}),s=o.cachedResponse[n]),s&&e.isArray(s.suggestions))o.suggestions=s.suggestions,o.suggest();else if(!o.isBadQuery(t)){if(!1===l.onSearchStart.call(o.element,l.params))return;o.currentRequest&&o.currentRequest.abort(),o.currentRequest=e.ajax({url:a,data:i,type:l.type,dataType:l.dataType}).done(function(e){o.currentRequest=null,o.processResponse(e,t,n),l.onSearchComplete.call(o.element,t)}).fail(function(e,s,i){l.onSearchError.call(o.element,t,e,s,i)})}},isBadQuery:function(e){for(var t=this.badQueries,s=t.length;s--;)if(0===e.indexOf(t[s]))return!0;return!1},hide:function(){this.visible=!1,this.selectedIndex=-1,e(this.suggestionsContainer).hide(),this.signalHint(null)},suggest:function(){if(0!==this.suggestions.length){var t,s,i=this.options,n=i.formatResult,o=this.getQuery(this.currentValue),l=this.classes.suggestion,a=this.classes.selected,u=e(this.suggestionsContainer),r=i.beforeRender,h="";i.triggerSelectOnValidInput&&-1!==(t=this.findSuggestionIndex(o))?this.select(t):(e.each(this.suggestions,function(e,t){h+='<div class="'+l+'" data-index="'+e+'">'+n(t,o)+"</div>"}),"auto"===i.width&&(s=this.el.outerWidth()-2,u.width(s>0?s:300)),u.html(h),i.autoSelectFirst&&(this.selectedIndex=0,u.children().first().addClass(a)),e.isFunction(r)&&r.call(this.element,u),u.show(),this.visible=!0,this.findBestHint())}else this.hide()},findBestHint:function(){var t=this.el.val().toLowerCase(),s=null;t&&(e.each(this.suggestions,function(e,i){var n=0===i.value.toLowerCase().indexOf(t);return n&&(s=i),!n}),this.signalHint(s))},signalHint:function(t){var s="";t&&(s=this.currentValue+t.value.substr(this.currentValue.length)),this.hintValue!==s&&(this.hintValue=s,this.hint=t,(this.options.onHint||e.noop)(s))},verifySuggestionsFormat:function(t){return t.length&&"string"==typeof t[0]?e.map(t,function(e){return{value:e,data:null}}):t},processResponse:function(e,t,s){var i=this.options,n=i.transformResult(e,t);n.suggestions=this.verifySuggestionsFormat(n.suggestions),i.noCache||(this.cachedResponse[s]=n,0===n.suggestions.length&&this.badQueries.push(s)),t===this.getQuery(this.currentValue)&&(this.suggestions=n.suggestions,this.suggest())},activate:function(t){var s,i=this.classes.selected,n=e(this.suggestionsContainer),o=n.children();return this.selectedIndex===t?null:(n.children("."+i).removeClass(i),this.selectedIndex=t,-1!==this.selectedIndex&&o.length>this.selectedIndex?(s=o.get(this.selectedIndex),e(s).addClass(i),this.options.onPreSelect(this.suggestions[t],s),s):null)},selectHint:function(){var t=e.inArray(this.hint,this.suggestions);this.select(t)},select:function(e){this.hide(),this.onSelect(e)},moveUp:function(){if(-1!==this.selectedIndex)return 0===this.selectedIndex?(e(this.suggestionsContainer).children().first().removeClass(this.classes.selected),this.selectedIndex=-1,this.el.val(this.currentValue),void this.findBestHint()):void this.adjustScroll(this.selectedIndex-1)},moveDown:function(){this.selectedIndex!==this.suggestions.length-1&&this.adjustScroll(this.selectedIndex+1)},adjustScroll:function(t){var s,i,n,o=this.activate(t);o&&(s=o.offsetTop,n=(i=e(this.suggestionsContainer).scrollTop())+this.options.maxHeight-25,s<i?e(this.suggestionsContainer).scrollTop(s):s>n&&e(this.suggestionsContainer).scrollTop(s-this.options.maxHeight+25),this.el.val(this.getValue(this.suggestions[t].value)),this.signalHint(null))},onSelect:function(t){var s=this.options.onSelect,i=this.suggestions[t];this.currentValue=this.getValue(i.value),this.el.val(this.currentValue),this.signalHint(null),this.suggestions=[],this.selection=i,e.isFunction(s)&&s.call(this.element,i)},getValue:function(e){var t,s,i=this.options.delimiter;return i?1===(s=(t=this.currentValue).split(i)).length?e:t.substr(0,t.length-s[s.length-1].length)+e:e},dispose:function(){this.el.off(".autocomplete").removeData("autocomplete"),this.disableKillerFn(),e(window).off("resize.autocomplete",this.fixPositionCapture),e(this.suggestionsContainer).remove()}},e.fn.autocomplete=function(t,s){return 0===arguments.length?this.first().data("autocomplete"):this.each(function(){var i=e(this),n=i.data("autocomplete");"string"==typeof t?n&&"function"==typeof n[t]&&n[t](s):(n&&n.dispose&&n.dispose(),n=new u(this,t),i.data("autocomplete",n))})}});
-
-},{}],20:[function(require,module,exports){
-(function(e,t){"use strict";var r=e.History=e.History||{},a=e.jQuery;if(void 0!==r.Adapter)throw new Error("History.js Adapter has already been loaded...");r.Adapter={bind:function(e,t,r){a(e).bind(t,r)},trigger:function(e,t,r){a(e).trigger(t,r)},extractEventData:function(e,t,r){return t&&t.originalEvent&&t.originalEvent[e]||r&&r[e]||void 0},onDomLoad:function(e){a(e)}},void 0!==r.init&&r.init()})(window),function(e,t){"use strict";var r=e.console||t,a=e.document,o=e.navigator,n=e.sessionStorage||!1,i=e.setTimeout,s=e.clearTimeout,l=e.setInterval,u=e.clearInterval,c=e.JSON,d=e.alert,p=e.History=e.History||{},g=e.history;try{n.setItem("TEST","1"),n.removeItem("TEST")}catch(e){n=!1}if(c.stringify=c.stringify||c.encode,c.parse=c.parse||c.decode,void 0!==p.init)throw new Error("History.js Core has already been loaded...");p.init=function(e){return void 0!==p.Adapter&&(void 0!==p.initCore&&p.initCore(),void 0!==p.initHtml4&&p.initHtml4(),!0)},p.initCore=function(h){if(void 0!==p.initCore.initialized)return!1;if(p.initCore.initialized=!0,p.options=p.options||{},p.options.hashChangeInterval=p.options.hashChangeInterval||100,p.options.safariPollInterval=p.options.safariPollInterval||500,p.options.doubleCheckInterval=p.options.doubleCheckInterval||500,p.options.disableSuid=p.options.disableSuid||!1,p.options.storeInterval=p.options.storeInterval||1e3,p.options.busyDelay=p.options.busyDelay||250,p.options.debug=p.options.debug||!1,p.options.initialTitle=p.options.initialTitle||a.title,p.options.html4Mode=p.options.html4Mode||!1,p.options.delayInit=p.options.delayInit||!1,p.intervalList=[],p.clearAllIntervals=function(){var e,t=p.intervalList;if(void 0!==t&&null!==t){for(e=0;e<t.length;e++)u(t[e]);p.intervalList=null}},p.debug=function(){p.options.debug&&p.log.apply(p,arguments)},p.log=function(){var e,t,o,n,i,s=void 0!==r&&void 0!==r.log&&void 0!==r.log.apply,l=a.getElementById("log");for(s?(e=(n=Array.prototype.slice.call(arguments)).shift(),void 0!==r.debug?r.debug.apply(r,[e,n]):r.log.apply(r,[e,n])):e="\n"+arguments[0]+"\n",t=1,o=arguments.length;t<o;++t){if("object"==typeof(i=arguments[t])&&void 0!==c)try{i=c.stringify(i)}catch(e){}e+="\n"+i+"\n"}return l?(l.value+=e+"\n-----\n",l.scrollTop=l.scrollHeight-l.clientHeight):s||d(e),!0},p.getInternetExplorerMajorVersion=function(){return p.getInternetExplorerMajorVersion.cached=void 0!==p.getInternetExplorerMajorVersion.cached?p.getInternetExplorerMajorVersion.cached:function(){for(var e=3,t=a.createElement("div"),r=t.getElementsByTagName("i");(t.innerHTML="\x3c!--[if gt IE "+ ++e+"]><i></i><![endif]--\x3e")&&r[0];);return e>4&&e}()},p.isInternetExplorer=function(){return p.isInternetExplorer.cached=void 0!==p.isInternetExplorer.cached?p.isInternetExplorer.cached:Boolean(p.getInternetExplorerMajorVersion())},p.options.html4Mode?p.emulated={pushState:!0,hashChange:!0}:p.emulated={pushState:!Boolean(e.history&&e.history.pushState&&e.history.replaceState&&!/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i.test(o.userAgent)&&!/AppleWebKit\/5([0-2]|3[0-2])/i.test(o.userAgent)),hashChange:Boolean(!("onhashchange"in e||"onhashchange"in a)||p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<8)},p.enabled=!p.emulated.pushState,p.bugs={setHash:Boolean(!p.emulated.pushState&&"Apple Computer, Inc."===o.vendor&&/AppleWebKit\/5([0-2]|3[0-3])/.test(o.userAgent)),safariPoll:Boolean(!p.emulated.pushState&&"Apple Computer, Inc."===o.vendor&&/AppleWebKit\/5([0-2]|3[0-3])/.test(o.userAgent)),ieDoubleCheck:Boolean(p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<8),hashEscape:Boolean(p.isInternetExplorer()&&p.getInternetExplorerMajorVersion()<7)},p.isEmptyObject=function(e){for(var t in e)if(e.hasOwnProperty(t))return!1;return!0},p.cloneObject=function(e){var t,r;return e?(t=c.stringify(e),r=c.parse(t)):r={},r},p.getRootUrl=function(){var e=a.location.protocol+"//"+(a.location.hostname||a.location.host);return a.location.port&&(e+=":"+a.location.port),e+="/"},p.getBaseHref=function(){var e=a.getElementsByTagName("base"),t="";return 1===e.length&&(t=e[0].href.replace(/[^\/]+$/,"")),(t=t.replace(/\/+$/,""))&&(t+="/"),t},p.getBaseUrl=function(){return p.getBaseHref()||p.getBasePageUrl()||p.getRootUrl()},p.getPageUrl=function(){return((p.getState(!1,!1)||{}).url||p.getLocationHref()).replace(/\/+$/,"").replace(/[^\/]+$/,function(e,t,r){return/\./.test(e)?e:e+"/"})},p.getBasePageUrl=function(){return p.getLocationHref().replace(/[#\?].*/,"").replace(/[^\/]+$/,function(e,t,r){return/[^\/]$/.test(e)?"":e}).replace(/\/+$/,"")+"/"},p.getFullUrl=function(e,t){var r=e,a=e.substring(0,1);return t=void 0===t||t,/[a-z]+\:\/\//.test(e)||(r="/"===a?p.getRootUrl()+e.replace(/^\/+/,""):"#"===a?p.getPageUrl().replace(/#.*/,"")+e:"?"===a?p.getPageUrl().replace(/[\?#].*/,"")+e:t?p.getBaseUrl()+e.replace(/^(\.\/)+/,""):p.getBasePageUrl()+e.replace(/^(\.\/)+/,"")),r.replace(/\#$/,"")},p.getShortUrl=function(e){var t=e,r=p.getBaseUrl(),a=p.getRootUrl();return p.emulated.pushState&&(t=t.replace(r,"")),t=t.replace(a,"/"),p.isTraditionalAnchor(t)&&(t="./"+t),t=t.replace(/^(\.\/)+/g,"./").replace(/\#$/,"")},p.getLocationHref=function(e){return(e=e||a).URL===e.location.href?e.location.href:e.location.href===decodeURIComponent(e.URL)?e.URL:e.location.hash&&decodeURIComponent(e.location.href.replace(/^[^#]+/,""))===e.location.hash?e.location.href:-1==e.URL.indexOf("#")&&-1!=e.location.href.indexOf("#")?e.location.href:e.URL||e.location.href},p.store={},p.idToState=p.idToState||{},p.stateToId=p.stateToId||{},p.urlToId=p.urlToId||{},p.storedStates=p.storedStates||[],p.savedStates=p.savedStates||[],p.normalizeStore=function(){p.store.idToState=p.store.idToState||{},p.store.urlToId=p.store.urlToId||{},p.store.stateToId=p.store.stateToId||{}},p.getState=function(e,t){void 0===e&&(e=!0),void 0===t&&(t=!0);var r=p.getLastSavedState();return!r&&t&&(r=p.createStateObject()),e&&((r=p.cloneObject(r)).url=r.cleanUrl||r.url),r},p.getIdByState=function(e){var t,r=p.extractId(e.url);if(!r)if(t=p.getStateString(e),void 0!==p.stateToId[t])r=p.stateToId[t];else if(void 0!==p.store.stateToId[t])r=p.store.stateToId[t];else{for(;r=(new Date).getTime()+String(Math.random()).replace(/\D/g,""),void 0!==p.idToState[r]||void 0!==p.store.idToState[r];);p.stateToId[t]=r,p.idToState[r]=e}return r},p.normalizeState=function(e){var t,r;return e&&"object"==typeof e||(e={}),void 0!==e.normalized?e:(e.data&&"object"==typeof e.data||(e.data={}),(t={}).normalized=!0,t.title=e.title||"",t.url=p.getFullUrl(e.url?e.url:p.getLocationHref()),t.hash=p.getShortUrl(t.url),t.data=p.cloneObject(e.data),t.id=p.getIdByState(t),t.cleanUrl=t.url.replace(/\??\&_suid.*/,""),t.url=t.cleanUrl,r=!p.isEmptyObject(t.data),(t.title||r)&&!0!==p.options.disableSuid&&(t.hash=p.getShortUrl(t.url).replace(/\??\&_suid.*/,""),/\?/.test(t.hash)||(t.hash+="?"),t.hash+="&_suid="+t.id),t.hashedUrl=p.getFullUrl(t.hash),(p.emulated.pushState||p.bugs.safariPoll)&&p.hasUrlDuplicate(t)&&(t.url=t.hashedUrl),t)},p.createStateObject=function(e,t,r){var a={data:e,title:t,url:r};return a=p.normalizeState(a)},p.getStateById=function(e){return e=String(e),p.idToState[e]||p.store.idToState[e]||t},p.getStateString=function(e){var t;return t={data:p.normalizeState(e).data,title:e.title,url:e.url},c.stringify(t)},p.getStateId=function(e){return p.normalizeState(e).id},p.getHashByState=function(e){return p.normalizeState(e).hash},p.extractId=function(e){var t,r;return r=-1!=e.indexOf("#")?e.split("#")[0]:e,(t=/(.*)\&_suid=([0-9]+)$/.exec(r))&&t[1]||e,(t?String(t[2]||""):"")||!1},p.isTraditionalAnchor=function(e){return!/[\/\?\.]/.test(e)},p.extractState=function(e,t){var r,a,o=null;return t=t||!1,(r=p.extractId(e))&&(o=p.getStateById(r)),o||(a=p.getFullUrl(e),(r=p.getIdByUrl(a)||!1)&&(o=p.getStateById(r)),!o&&t&&!p.isTraditionalAnchor(e)&&(o=p.createStateObject(null,null,a))),o},p.getIdByUrl=function(e){return p.urlToId[e]||p.store.urlToId[e]||t},p.getLastSavedState=function(){return p.savedStates[p.savedStates.length-1]||t},p.getLastStoredState=function(){return p.storedStates[p.storedStates.length-1]||t},p.hasUrlDuplicate=function(e){var t;return(t=p.extractState(e.url))&&t.id!==e.id},p.storeState=function(e){return p.urlToId[e.url]=e.id,p.storedStates.push(p.cloneObject(e)),e},p.isLastSavedState=function(e){var t=!1;return p.savedStates.length&&(t=e.id===p.getLastSavedState().id),t},p.saveState=function(e){return!p.isLastSavedState(e)&&(p.savedStates.push(p.cloneObject(e)),!0)},p.getStateByIndex=function(e){return void 0===e?p.savedStates[p.savedStates.length-1]:e<0?p.savedStates[p.savedStates.length+e]:p.savedStates[e]},p.getCurrentIndex=function(){return p.savedStates.length<1?0:p.savedStates.length-1},p.getHash=function(e){var t=p.getLocationHref(e);return p.getHashByUrl(t)},p.unescapeHash=function(e){var t=p.normalizeHash(e);return t=decodeURIComponent(t)},p.normalizeHash=function(e){return e.replace(/[^#]*#/,"").replace(/#.*/,"")},p.setHash=function(e,t){var r,o;return!1!==t&&p.busy()?(p.pushQueue({scope:p,callback:p.setHash,args:arguments,queue:t}),!1):(p.busy(!0),(r=p.extractState(e,!0))&&!p.emulated.pushState?p.pushState(r.data,r.title,r.url,!1):p.getHash()!==e&&(p.bugs.setHash?(o=p.getPageUrl(),p.pushState(null,null,o+"#"+e,!1)):a.location.hash=e),p)},p.escapeHash=function(t){var r=p.normalizeHash(t);return r=e.encodeURIComponent(r),p.bugs.hashEscape||(r=r.replace(/\%21/g,"!").replace(/\%26/g,"&").replace(/\%3D/g,"=").replace(/\%3F/g,"?")),r},p.getHashByUrl=function(e){var t=String(e).replace(/([^#]*)#?([^#]*)#?(.*)/,"$2");return t=p.unescapeHash(t)},p.setTitle=function(e){var t,r=e.title;r||(t=p.getStateByIndex(0))&&t.url===e.url&&(r=t.title||p.options.initialTitle);try{a.getElementsByTagName("title")[0].innerHTML=r.replace("<","&lt;").replace(">","&gt;").replace(" & "," &amp; ")}catch(e){}return a.title=r,p},p.queues=[],p.busy=function(e){if(void 0!==e?p.busy.flag=e:void 0===p.busy.flag&&(p.busy.flag=!1),!p.busy.flag){s(p.busy.timeout);var t=function(){var e,r,a;if(!p.busy.flag)for(e=p.queues.length-1;e>=0;--e)0!==(r=p.queues[e]).length&&(a=r.shift(),p.fireQueueItem(a),p.busy.timeout=i(t,p.options.busyDelay))};p.busy.timeout=i(t,p.options.busyDelay)}return p.busy.flag},p.busy.flag=!1,p.fireQueueItem=function(e){return e.callback.apply(e.scope||p,e.args||[])},p.pushQueue=function(e){return p.queues[e.queue||0]=p.queues[e.queue||0]||[],p.queues[e.queue||0].push(e),p},p.queue=function(e,t){return"function"==typeof e&&(e={callback:e}),void 0!==t&&(e.queue=t),p.busy()?p.pushQueue(e):p.fireQueueItem(e),p},p.clearQueue=function(){return p.busy.flag=!1,p.queues=[],p},p.stateChanged=!1,p.doubleChecker=!1,p.doubleCheckComplete=function(){return p.stateChanged=!0,p.doubleCheckClear(),p},p.doubleCheckClear=function(){return p.doubleChecker&&(s(p.doubleChecker),p.doubleChecker=!1),p},p.doubleCheck=function(e){return p.stateChanged=!1,p.doubleCheckClear(),p.bugs.ieDoubleCheck&&(p.doubleChecker=i(function(){return p.doubleCheckClear(),p.stateChanged||e(),!0},p.options.doubleCheckInterval)),p},p.safariStatePoll=function(){var t=p.extractState(p.getLocationHref());if(!p.isLastSavedState(t))return t||p.createStateObject(),p.Adapter.trigger(e,"popstate"),p},p.back=function(e){return!1!==e&&p.busy()?(p.pushQueue({scope:p,callback:p.back,args:arguments,queue:e}),!1):(p.busy(!0),p.doubleCheck(function(){p.back(!1)}),g.go(-1),!0)},p.forward=function(e){return!1!==e&&p.busy()?(p.pushQueue({scope:p,callback:p.forward,args:arguments,queue:e}),!1):(p.busy(!0),p.doubleCheck(function(){p.forward(!1)}),g.go(1),!0)},p.go=function(e,t){var r;if(e>0)for(r=1;r<=e;++r)p.forward(t);else{if(!(e<0))throw new Error("History.go: History.go requires a positive or negative integer passed.");for(r=-1;r>=e;--r)p.back(t)}return p},p.emulated.pushState){var f=function(){};p.pushState=p.pushState||f,p.replaceState=p.replaceState||f}else p.onPopState=function(t,r){var a,o,n=!1,i=!1;return p.doubleCheckComplete(),(a=p.getHash())?((o=p.extractState(a||p.getLocationHref(),!0))?p.replaceState(o.data,o.title,o.url,!1):(p.Adapter.trigger(e,"anchorchange"),p.busy(!1)),p.expectedStateId=!1,!1):((i=(n=p.Adapter.extractEventData("state",t,r)||!1)?p.getStateById(n):p.expectedStateId?p.getStateById(p.expectedStateId):p.extractState(p.getLocationHref()))||(i=p.createStateObject(null,null,p.getLocationHref())),p.expectedStateId=!1,p.isLastSavedState(i)?(p.busy(!1),!1):(p.storeState(i),p.saveState(i),p.setTitle(i),p.Adapter.trigger(e,"statechange"),p.busy(!1),!0))},p.Adapter.bind(e,"popstate",p.onPopState),p.pushState=function(t,r,a,o){if(p.getHashByUrl(a)&&p.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(!1!==o&&p.busy())return p.pushQueue({scope:p,callback:p.pushState,args:arguments,queue:o}),!1;p.busy(!0);var n=p.createStateObject(t,r,a);return p.isLastSavedState(n)?p.busy(!1):(p.storeState(n),p.expectedStateId=n.id,g.pushState(n.id,n.title,n.url),p.Adapter.trigger(e,"popstate")),!0},p.replaceState=function(t,r,a,o){if(p.getHashByUrl(a)&&p.emulated.pushState)throw new Error("History.js does not support states with fragement-identifiers (hashes/anchors).");if(!1!==o&&p.busy())return p.pushQueue({scope:p,callback:p.replaceState,args:arguments,queue:o}),!1;p.busy(!0);var n=p.createStateObject(t,r,a);return p.isLastSavedState(n)?p.busy(!1):(p.storeState(n),p.expectedStateId=n.id,g.replaceState(n.id,n.title,n.url),p.Adapter.trigger(e,"popstate")),!0};if(n){try{p.store=c.parse(n.getItem("History.store"))||{}}catch(e){p.store={}}p.normalizeStore()}else p.store={},p.normalizeStore();p.Adapter.bind(e,"unload",p.clearAllIntervals),p.saveState(p.storeState(p.extractState(p.getLocationHref(),!0))),n&&(p.onUnload=function(){var e,t,r;try{e=c.parse(n.getItem("History.store"))||{}}catch(t){e={}}for(t in e.idToState=e.idToState||{},e.urlToId=e.urlToId||{},e.stateToId=e.stateToId||{},p.idToState)p.idToState.hasOwnProperty(t)&&(e.idToState[t]=p.idToState[t]);for(t in p.urlToId)p.urlToId.hasOwnProperty(t)&&(e.urlToId[t]=p.urlToId[t]);for(t in p.stateToId)p.stateToId.hasOwnProperty(t)&&(e.stateToId[t]=p.stateToId[t]);p.store=e,p.normalizeStore(),r=c.stringify(e);try{n.setItem("History.store",r)}catch(e){if(e.code!==DOMException.QUOTA_EXCEEDED_ERR)throw e;n.length&&(n.removeItem("History.store"),n.setItem("History.store",r))}},p.intervalList.push(l(p.onUnload,p.options.storeInterval)),p.Adapter.bind(e,"beforeunload",p.onUnload),p.Adapter.bind(e,"unload",p.onUnload)),p.emulated.pushState||(p.bugs.safariPoll&&p.intervalList.push(l(p.safariStatePoll,p.options.safariPollInterval)),"Apple Computer, Inc."!==o.vendor&&"Mozilla"!==(o.appCodeName||"")||(p.Adapter.bind(e,"hashchange",function(){p.Adapter.trigger(e,"popstate")}),p.getHash()&&p.Adapter.onDomLoad(function(){p.Adapter.trigger(e,"hashchange")})))},(!p.options||!p.options.delayInit)&&p.init()}(window);
-
-},{}],21:[function(require,module,exports){
-L.Control.Elevation=L.Control.extend({options:{position:"topright",theme:"lime-theme",width:600,height:175,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:3,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1,yAxisMin:void 0,yAxisMax:void 0,forceAxisBounds:!1,controlButton:{iconCssClass:"elevation-toggle-icon",title:"Elevation"},imperial:!1},__mileFactor:.621371,__footFactor:3.28084,onRemove:function(t){this._container=null},onAdd:function(t){this._map=t;var i=this.options,e=i.margins;i.xTicks=i.xTicks||Math.round(this._width()/75),i.yTicks=i.yTicks||Math.round(this._height()/30),i.hoverNumber.formatter=i.hoverNumber.formatter||this._formatter;var a=this._x=d3.scale.linear().range([0,this._width()]),s=this._y=d3.scale.linear().range([this._height(),0]),o=(this._area=d3.svg.area().interpolate(i.interpolation).x(function(t){var i=a(t.dist);return t.xDiagCoord=i,i}).y0(this._height()).y1(function(t){return s(t.altitude)}),this._container=L.DomUtil.create("div","elevation"));L.DomUtil.addClass(o,i.theme),this._initToggle();var n=d3.select(o);n.attr("width",i.width);var r=n.append("svg");r.attr("width",i.width).attr("class","background").attr("height",i.height).append("g").attr("transform","translate("+e.left+","+e.top+")");var h=d3.svg.line();h=h.x(function(t){return d3.mouse(r.select("g"))[0]}).y(function(t){return this._height()});var l=d3.select(this._container).select("svg").select("g");this._areapath=l.append("path").attr("class","area");var d=this._background=l.append("rect").attr("width",this._width()).attr("height",this._height()).style("fill","none").style("stroke","none").style("pointer-events","all");L.Browser.mobile?(d.on("touchmove.drag",this._dragHandler.bind(this)).on("touchstart.drag",this._dragStartHandler.bind(this)).on("touchstart.focus",this._mousemoveHandler.bind(this)),L.DomEvent.on(this._container,"touchend",this._dragEndHandler,this)):(d.on("mousemove.focus",this._mousemoveHandler.bind(this)).on("mouseout.focus",this._mouseoutHandler.bind(this)).on("mousedown.drag",this._dragStartHandler.bind(this)).on("mousemove.drag",this._dragHandler.bind(this)),L.DomEvent.on(this._container,"mouseup",this._dragEndHandler,this)),this._xaxisgraphicnode=l.append("g"),this._yaxisgraphicnode=l.append("g"),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode);var c=this._focusG=l.append("g");return this._mousefocus=c.append("svg:line").attr("class","mouse-focus-line").attr("x2","0").attr("y2","0").attr("x1","0").attr("y1","0"),this._focuslabelX=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-x"),this._focuslabelY=c.append("svg:text").style("pointer-events","none").attr("class","mouse-focus-label-y"),this._data&&this._applyData(),o},_dragHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!0,this._drawDragRectangle()},_drawDragRectangle:function(){if(this._dragStartCoords){var t=this._dragCurrentCoords=d3.mouse(this._background.node()),i=Math.min(this._dragStartCoords[0],t[0]),e=Math.max(this._dragStartCoords[0],t[0]);if(this._dragRectangle||this._dragRectangleG)this._dragRectangle.attr("width",e-i).attr("x",i);else{var a=d3.select(this._container).select("svg").select("g");this._dragRectangleG=a.append("g"),this._dragRectangle=this._dragRectangleG.append("rect").attr("width",e-i).attr("height",this._height()).attr("x",i).attr("class","mouse-drag").style("pointer-events","none")}}},_resetDrag:function(){this._dragRectangleG&&(this._dragRectangleG.remove(),this._dragRectangleG=null,this._dragRectangle=null,this._hidePositionMarker(),this._map.fitBounds(this._fullExtent))},_dragEndHandler:function(){if(!this._dragStartCoords||!this._gotDragged)return this._dragStartCoords=null,this._gotDragged=!1,void this._resetDrag();this._hidePositionMarker();var t=this._findItemForX(this._dragStartCoords[0]),i=this._findItemForX(this._dragCurrentCoords[0]);this._fitSection(t,i),this._dragStartCoords=null,this._gotDragged=!1},_dragStartHandler:function(){d3.event.preventDefault(),d3.event.stopPropagation(),this._gotDragged=!1,this._dragStartCoords=d3.mouse(this._background.node())},_findItemForX:function(t){var i=d3.bisector(function(t){return t.dist}).left,e=this._x.invert(t);return i(this._data,e)},_findItemForLatLng:function(t){var i=null,e=1/0;return this._data.forEach(function(a){var s=t.distanceTo(a.latlng);e>s&&(e=s,i=a)}),i},_fitSection:function(t,i){var e=Math.min(t,i),a=Math.max(t,i),s=this._calculateFullExtent(this._data.slice(e,a));this._map.fitBounds(s)},_initToggle:function(){var t=this._container;if(t.setAttribute("aria-haspopup",!0),L.Browser.mobile?L.DomEvent.on(t,"click",L.DomEvent.stopPropagation):L.DomEvent.disableClickPropagation(t),this.options.collapsed){this._collapse(),L.Browser.android||L.DomEvent.on(t,"mouseover",this._expand,this).on(t,"mouseout",this._collapse,this);var i=this._button=L.DomUtil.create("a","elevation-toggle "+this.options.controlButton.iconCssClass,t);i.href="#",i.title=this.options.controlButton.title,L.Browser.mobile?L.DomEvent.on(i,"click",L.DomEvent.stop).on(i,"click",this._expand,this):L.DomEvent.on(i,"focus",this._expand,this),this._map.on("click",this._collapse,this)}},_expand:function(){this._container.className=this._container.className.replace(" elevation-collapsed","")},_collapse:function(){L.DomUtil.addClass(this._container,"elevation-collapsed")},_width:function(){var t=this.options;return t.width-t.margins.left-t.margins.right},_height:function(){var t=this.options;return t.height-t.margins.top-t.margins.bottom},_formatter:function(t,i,e){var a,s=(a=0===i?Math.round(t)+"":L.Util.formatNum(t,i)+"").split(".");if(s[1]){for(var o=i-s[1].length;o>0;o--)s[1]+="0";a=s.join(e||".")}return a},_appendYaxis:function(t){this.options.imperial?t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-37).attr("y",3).style("text-anchor","end").text("ft"):t.attr("class","y axis").call(d3.svg.axis().scale(this._y).ticks(this.options.yTicks).orient("left")).append("text").attr("x",-45).attr("y",3).style("text-anchor","end").text("m")},_appendXaxis:function(t){this.options.imperial?t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+10).attr("y",15).style("text-anchor","end").text("mi"):t.attr("class","x axis").attr("transform","translate(0,"+this._height()+")").call(d3.svg.axis().scale(this._x).ticks(this.options.xTicks).orient("bottom")).append("text").attr("x",this._width()+20).attr("y",15).style("text-anchor","end").text("km")},_updateAxis:function(){this._xaxisgraphicnode.selectAll("g").remove(),this._xaxisgraphicnode.selectAll("path").remove(),this._xaxisgraphicnode.selectAll("text").remove(),this._yaxisgraphicnode.selectAll("g").remove(),this._yaxisgraphicnode.selectAll("path").remove(),this._yaxisgraphicnode.selectAll("text").remove(),this._appendXaxis(this._xaxisgraphicnode),this._appendYaxis(this._yaxisgraphicnode)},_mouseoutHandler:function(){this._hidePositionMarker()},_hidePositionMarker:function(){this._marker&&(this._map.removeLayer(this._marker),this._marker=null),this._mouseHeightFocus&&(this._mouseHeightFocus.style("visibility","hidden"),this._mouseHeightFocusLabel.style("visibility","hidden")),this._pointG&&this._pointG.style("visibility","hidden"),this._focusG.style("visibility","hidden")},_mousemoveHandler:function(t,i,e){if(this._data&&0!==this._data.length){var a=d3.mouse(this._background.node()),s=this.options,o=this._data[this._findItemForX(a[0])],n=o.altitude,r=o.dist,h=o.latlng,l=s.hoverNumber.formatter(n,s.hoverNumber.decimalsY);s.hoverNumber.formatter(r,s.hoverNumber.decimalsX),this._showDiagramIndicator(o,a[0]);var d=this._map.latLngToLayerPoint(h);if(s.useHeightIndicator){if(!this._mouseHeightFocus){var c=d3.select(".leaflet-overlay-pane svg").append("g");this._mouseHeightFocus=c.append("svg:line").attr("class",s.theme+" height-focus line").attr("x2",0).attr("y2",0).attr("x1",0).attr("y1",0),(this._pointG=c.append("g")).append("svg:circle").attr("r",6).attr("cx",0).attr("cy",0).attr("class",s.theme+" height-focus circle-lower"),this._mouseHeightFocusLabel=c.append("svg:text").attr("class",s.theme+" height-focus-label").style("pointer-events","none")}var _=this._height()/this._maxElevation*n,u=d.y-_;this._mouseHeightFocus.attr("x1",d.x).attr("x2",d.x).attr("y1",d.y).attr("y2",u).style("visibility","visible"),this._pointG.attr("transform","translate("+d.x+","+d.y+")").style("visibility","visible"),s.imperial?this._mouseHeightFocusLabel.attr("x",d.x).attr("y",u).text(l+" ft").style("visibility","visible"):this._mouseHeightFocusLabel.attr("x",d.x).attr("y",u).text(l+" m").style("visibility","visible")}else this._marker?this._marker.setLatLng(h):this._marker=new L.Marker(h).addTo(this._map)}},_addGeoJSONData:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var n=new L.LatLng(t[o][1],t[o][0]),r=new L.LatLng(t[o?o-1:0][1],t[o?o-1:0][0]),h=i.imperial?n.distanceTo(r)*this.__mileFactor:n.distanceTo(r);a+=Math.round(h/1e3*1e5)/1e5,s=s<t[o][2]?t[o][2]:s,e.push({dist:a,altitude:i.imperial?t[o][2]*this.__footFactor:t[o][2],x:t[o][0],y:t[o][1],latlng:n})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addGPXdata:function(t){var i=this.options;if(t){for(var e=this._data||[],a=this._dist||0,s=this._maxElevation||0,o=0;o<t.length;o++){var n=t[o],r=t[o?o-1:0],h=i.imperial?n.distanceTo(r)*this.__mileFactor:n.distanceTo(r);a+=Math.round(h/1e3*1e5)/1e5,s=s<n.meta.ele?n.meta.ele:s,e.push({dist:a,altitude:i.imperial?n.meta.ele*this.__footFactor:n.meta.ele,x:n.lng,y:n.lat,latlng:n})}this._dist=a,this._data=e,s=i.imperial?s*this.__footFactor:s,this._maxElevation=s}},_addData:function(t){var i,e=t&&t.geometry&&t.geometry;if(e)switch(e.type){case"LineString":this._addGeoJSONData(e.coordinates);break;case"MultiLineString":for(i=0;i<e.coordinates.length;i++)this._addGeoJSONData(e.coordinates[i]);break;default:throw new Error("Invalid GeoJSON object.")}if(t&&"FeatureCollection"===t.type)for(i=0;i<t.features.length;i++)this._addData(t.features[i]);t&&t._latlngs&&this._addGPXdata(t._latlngs)},_calculateFullExtent:function(t){if(!t||t.length<1)throw new Error("no data in parameters");var i=new L.latLngBounds(t[0].latlng,t[0].latlng);return t.forEach(function(t){i.extend(t.latlng)}),i},addData:function(t,i){this._addData(t),this._container&&this._applyData(),null===i&&t.on&&(i=t),i&&i.on("mousemove",this._handleLayerMouseOver.bind(this))},_handleLayerMouseOver:function(t){if(this._data&&0!==this._data.length){var i=t.latlng,e=this._findItemForLatLng(i);if(e){var a=e.xDiagCoord;this._showDiagramIndicator(e,a)}}},_showDiagramIndicator:function(t,i){var e=this.options;this._focusG.style("visibility","visible"),this._mousefocus.attr("x1",i).attr("y1",0).attr("x2",i).attr("y2",this._height()).classed("hidden",!1);var a=t.altitude,s=t.dist,o=(t.latlng,e.hoverNumber.formatter(a,e.hoverNumber.decimalsY)),n=e.hoverNumber.formatter(s,e.hoverNumber.decimalsX);e.imperial?(this._focuslabelX.attr("x",i).text(o+" ft"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(n+" mi")):(this._focuslabelX.attr("x",i).text(o+" m"),this._focuslabelY.attr("y",this._height()-5).attr("x",i).text(n+" km"))},_applyData:function(){var t=d3.extent(this._data,function(t){return t.dist}),i=d3.extent(this._data,function(t){return t.altitude}),e=this.options;void 0!==e.yAxisMin&&(e.yAxisMin<i[0]||e.forceAxisBounds)&&(i[0]=e.yAxisMin),void 0!==e.yAxisMax&&(e.yAxisMax>i[1]||e.forceAxisBounds)&&(i[1]=e.yAxisMax),this._x.domain(t),this._y.domain(i),this._areapath.datum(this._data).attr("d",this._area),this._updateAxis(),this._fullExtent=this._calculateFullExtent(this._data)},_clearData:function(){this._data=null,this._dist=null,this._maxElevation=null},clear:function(){this._clearData(),this._areapath&&(this._areapath.attr("d","M0 0"),this._x.domain([0,1]),this._y.domain([0,1]),this._updateAxis())},hide:function(){this._container.style.display="none"},show:function(){this._container.style.display="block"}}),L.control.elevation=function(t){return new L.Control.Elevation(t)};
-
-},{}],22:[function(require,module,exports){
-L.NumberedDivIcon=L.Icon.extend({options:{iconUrl:"./img/marker_hole.png",number:"",shadowUrl:null,iconSize:new L.Point(25,41),iconAnchor:new L.Point(12,40),popupAnchor:new L.Point(0,-33),shadowSize:new L.Point(50,-64),shadowAnchor:new L.Point(4,-62),className:"leaflet-div-icon"},createIcon:function(){var n=document.createElement("div"),e=this._createImg(this.options.iconUrl),o=document.createElement("div");return o.setAttribute("class","number"),o.innerHTML=this.options.number||"",n.appendChild(e),n.appendChild(o),this._setIconStyles(n,"icon"),n},createShadow:function(){return null}});
-
-},{}],23:[function(require,module,exports){
-(function (global){
-global.d3=require("d3");var Flatpickr=require("flatpickr");require("flatpickr/dist/l10n");var L=require("leaflet");require("leaflet-contextmenu"),require("leaflet-loading");var moment=require("moment");require("./lib/leaflet.elevation-0.0.4.min.js"),require("./lib/leaflet_numbered_markers.js"),global.jQuery=require("jquery"),global.$=global.jQuery,require("./lib/jquery-ui-custom-1.12.0.min.js"),require("./lib/jquery.history.js"),require("./lib/jquery.autocomplete.js");var ghenv=require("./config/options.js").options;console.log(ghenv.environment);var GHInput=require("./graphhopper/GHInput.js"),GHRequest=require("./graphhopper/GHRequest.js"),host=ghenv.routing.host;host||(host=""===location.port?location.protocol+"//"+location.hostname:location.protocol+"//"+location.hostname+":"+location.port);var AutoComplete=require("./autocomplete.js");if("development"===ghenv.environment)var autocomplete=AutoComplete.prototype.createStub();else autocomplete=new AutoComplete(ghenv.geocoding.host,ghenv.geocoding.api_key);var metaVersionInfo,mapLayer=require("./map.js"),nominatim=require("./nominatim.js"),routeManipulation=require("./routeManipulation.js"),gpxExport=require("./gpxexport.js"),messages=require("./messages.js"),translate=require("./translate.js"),format=require("./tools/format.js"),urlTools=require("./tools/url.js"),vehicleTools=require("./tools/vehicle.js"),tileLayers=require("./config/tileLayers.js"),debug=!1,ghRequest=new GHRequest(host,ghenv.routing.api_key),bounds={};function initFromParams(e,t){ghRequest.init(e);var r=new Flatpickr(document.getElementById("input_date_0"),{defaultDate:new Date,allowInput:!0,minuteIncrement:15,time_24hr:!0,enableTime:!0});ghRequest.getEarliestDepartureTime()&&r.setDate(ghRequest.getEarliestDepartureTime());var o,a=0;if(e.point)for(var n=0;n<e.point.length;n++)""!==e.point[n]&&(a++,o=n);e.point&&a>=2?resolveCoords(e.point,t):e.point&&1===a&&(ghRequest.route.set(e.point[o],o,!0),resolveIndex(o).done(function(){mapLayer.focus(ghRequest.route.getIndex(o),15,o)}))}function resolveCoords(e,t){for(var r=0,o=e.length;r<o;r++){var a=e[r],n=ghRequest.route.getIndex(r);n&&a===n.input&&n.isResolved()||ghRequest.route.set(a,r,!0)}checkInput(),ghRequest.route.isResolved()?(resolveAll(),routeLatLng(ghRequest,t)):$.when.apply($,resolveAll()).done(function(){routeLatLng(ghRequest,t)})}global.window&&(window.log=function(){log.history=log.history||[],log.history.push(arguments),this.console&&debug&&console.log(Array.prototype.slice.call(arguments))}),$(document).ready(function(e){jQuery.support.cors=!0,gpxExport.addGpxExport(ghRequest),isProduction()&&$("#hosting").show();var t=window.History;t.enabled&&t.Adapter.bind(window,"statechange",function(){var e=t.getState();console.log(e),initFromParams(e.data,!0)}),$("#locationform").submit(function(e){e.preventDefault(),mySubmit()});var r=urlTools.parseUrlWithHisto();$.when(ghRequest.fetchTranslationMap(r.locale),ghRequest.getInfo()).then(function(e,t){var o=e[0];autocomplete.setLocale(o.locale),ghRequest.setLocale(o.locale),translate.init(o);var a=t[0],n=a.bbox;bounds.initialized=!0,bounds.minLon=n[0],bounds.minLat=n[1],bounds.maxLon=n[2],bounds.maxLat=n[3],nominatim.setBounds(bounds);var s=$("#vehicles");function i(e,t){var r=$("<button class='vehicle-btn' title='"+translate.tr(e)+"'/>");return t&&r.hide(),r.attr("id",e),r.html("<img src='img/"+e+".png' alt='"+translate.tr(e)+"'></img>"),r.click(function(){ghRequest.initVehicle(e),resolveAll(),routeLatLng(ghRequest)}),r}if(a.features){ghRequest.features=a.features;var l={car:1,foot:2,bike:3,motorcycle:1e4},u=r.vehicle&&(!l[r.vehicle]||l[r.vehicle]>3),p=vehicleTools.getSortedVehicleKeys(a.features,l);p.length>0&&ghRequest.initVehicle(p[0]),ghRequest.isPublicTransit()&&$(".time_input").show();var d=[];for(var c in p){var g=i(p[c].toLowerCase(),!u&&c>2);s.append(g),c>2&&d.push(g)}if(!u&&p.length>3){var h=$("<a id='more-vehicle-btn'> ...</a>").click(function(){for(var e in h.hide(),d)d[e].show()});s.append($("<a class='vehicle-info-link' href='https://graphhopper.com/api/1/docs/supported-vehicle-profiles/'>?</a>")),s.append(h)}}metaVersionInfo=messages.extractMetaVersionInfo(a),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,r.layer,r.use_miles),initFromParams(r,!0),checkInput()},function(e){console.log(e),$("#error").html('GraphHopper API offline? <a href="http://graphhopper.com/maps">Refresh</a><br/>Status: '+e.statusText+"<br/>"+host),bounds={minLon:-180,minLat:-90,maxLon:180,maxLat:90},nominatim.setBounds(bounds),mapLayer.initMap(bounds,setStartCoord,setIntermediateCoord,setEndCoord,r.layer,r.use_miles)});var o=r.locale&&r.locale.split("-",1)[0];if("en"!=o){var a;switch(o){case"ca":a="cat";break;case"el":a="gr";break;default:a=o}Flatpickr.l10ns.hasOwnProperty(a)&&Flatpickr.localize(Flatpickr.l10ns[a])}$(window).resize(function(){mapLayer.adjustMapSize()}),$("#locationpoints").sortable({items:".pointDiv",cursor:"n-resize",containment:"parent",handle:".pointFlag",update:function(e,t){var r=$(t.item[0]).data("index");sortable_items=$("#locationpoints > div.pointDiv"),$(sortable_items).each(function(e){var t=$(this).data("index");if(r===t)return ghRequest.route.move(t,e),routeIfAllResolved()||checkInput(),!1})}}),$("#locationpoints > div.pointAdd").click(function(){ghRequest.route.add(new GHInput),checkInput()}),checkInput()});var FROM="from",TO="to";function getToFrom(e){return 0===e?FROM:e===ghRequest.route.size()-1?TO:-1}function checkInput(){var e=$("#pointTemplate").html(),t=ghRequest.route.size();$("#locationpoints > div.pointDiv").length>t&&$("#locationpoints > div.pointDiv:gt("+(t-1)+")").remove(),$("#locationpoints .pointDelete").off();for(var r=function(){var e=$(this).parent().data("index");ghRequest.route.removeSingle(e),mapLayer.clearLayers(),checkInput(),routeLatLng(ghRequest,!1)},o=0;o<t;o++){var a=$("#locationpoints > div.pointDiv").eq(o);0===a.length&&($("#locationpoints > div.pointAdd").before(translate.nanoTemplate(e,{id:o})),a=$("#locationpoints > div.pointDiv").eq(o));var n=getToFrom(o);if(a.data("index",o),a.find(".pointFlag").attr("src",n===FROM?"img/marker-small-green.png":n===TO?"img/marker-small-red.png":"img/marker-small-blue.png"),t>2?a.find(".pointDelete").click(r).prop("disabled",!1).removeClass("ui-state-disabled"):a.find(".pointDelete").prop("disabled",!0).addClass("ui-state-disabled"),autocomplete.showListForIndex(ghRequest,routeIfAllResolved,o),translate.isI18nIsInitialized()){var s=a.find(".pointInput");0===o?$(s).attr("placeholder",translate.tr("from_hint")):o===t-1?$(s).attr("placeholder",translate.tr("to_hint")):$(s).attr("placeholder",translate.tr("via_hint"))}}}function setToStart(e){var t=e.relatedTarget.getLatLng(),r=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(r,0),routeIfAllResolved()}function setToEnd(e){var t=e.relatedTarget.getLatLng(),r=ghRequest.route.getIndexByCoord(t);ghRequest.route.move(r,-1),routeIfAllResolved()}function setStartCoord(e){ghRequest.route.set(e.latlng.wrap(),0),resolveFrom(),routeIfAllResolved()}function setIntermediateCoord(e){var t=mapLayer.getSubLayers("route").map(function(e){return{coordinates:e.getLatLngs(),wayPoints:e.feature.properties.snapped_waypoints.coordinates.map(function(e){return L.latLng(e[1],e[0])})}}),r=routeManipulation.getIntermediatePointIndex(t,e.latlng);ghRequest.route.add(e.latlng.wrap(),r),resolveIndex(r),routeIfAllResolved()}function deleteCoord(e){var t=e.relatedTarget.getLatLng();ghRequest.route.removeSingle(t),mapLayer.clearLayers(),routeLatLng(ghRequest,!1)}function setEndCoord(e){var t=ghRequest.route.size()-1;ghRequest.route.set(e.latlng.wrap(),t),resolveTo(),routeIfAllResolved()}function routeIfAllResolved(e){return!!ghRequest.route.isResolved()&&(routeLatLng(ghRequest,e),!0)}function setFlag(e,t){if(e.lat){var r=getToFrom(t),o=mapLayer.createMarker(t,e,setToEnd,setToStart,deleteCoord,ghRequest);o._openPopup=o.openPopup,o.openPopup=function(){var e,t=this.getLatLng(),r=ghRequest.route.getIndexFromCoord(t);if(r.resolvedList&&r.resolvedList[0]&&r.resolvedList[0].locationDetails){var o=r.resolvedList[0].locationDetails;e=format.formatAddress(o),this._popup.setContent(e).update()}this._openPopup()};var a={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:setToStart,index:1};-1===r&&o.options.contextmenuItems.push(a),o.on("dragend",function(e){mapLayer.clearLayers();var r=e.target.getLatLng();autocomplete.hide(),ghRequest.route.getIndex(t).setCoord(r.lat,r.lng),resolveIndex(t),ghRequest.do_zoom=!1,routeLatLng(ghRequest,!1)})}}function resolveFrom(){return resolveIndex(0)}function resolveTo(){return resolveIndex(ghRequest.route.size()-1)}function resolveIndex(e){return setFlag(ghRequest.route.getIndex(e),e),0===e?ghRequest.to.isResolved()?mapLayer.setDisabledForMapsContextMenu("start",!1):mapLayer.setDisabledForMapsContextMenu("start",!0):e===ghRequest.route.size()-1&&(ghRequest.from.isResolved()?mapLayer.setDisabledForMapsContextMenu("end",!1):mapLayer.setDisabledForMapsContextMenu("end",!0)),nominatim.resolve(e,ghRequest.route.getIndex(e))}function resolveAll(){for(var e=[],t=0,r=ghRequest.route.size();t<r;t++)e[t]=resolveIndex(t);return ghRequest.isPublicTransit()&&ghRequest.setEarliestDepartureTime(moment($("#input_date_0").val(),"YYYY-MM-DD HH:mm").toISOString()),e}function flagAll(){for(var e=0,t=ghRequest.route.size();e<t;e++)setFlag(ghRequest.route.getIndex(e),e)}function routeLatLng(e,t){var r,o=e.do_zoom;e.do_zoom=!0;var a=e.createHistoryURL()+"&layer="+tileLayers.activeLayerName;if(!t&&History.enabled){var n=urlTools.parseUrl(a);return console.log(n),n.do_zoom=o,n.mathRandom=Math.random(),void History.pushState(n,messages.browserTitle,a)}var s=$("#info");s.empty(),s.show();var i=$("<div class='route_results'/>");s.append(i),mapLayer.clearElevation(),mapLayer.clearLayers(),flagAll(),mapLayer.setDisabledForMapsContextMenu("intermediate",!1),$("#vehicles button").removeClass("selectvehicle"),$("button#"+e.getVehicle().toLowerCase()).addClass("selectvehicle");var l=e.createURL();i.html('<img src="img/indicator.gif"/> Search Route ...'),e.doRequest(l,function(t){if(i.html(""),t.message){var n=t.message;if(console.log(n),t.hints)for(var s=0;s<t.hints.length;s++)i.append("<div class='error'>"+t.hints[s].message+"</div>");else i.append("<div class='error'>"+n+"</div>")}else{var l=$("<ul id='route_result_tabs'/>");t.paths.length>1&&(i.append(l),i.append("<div class='clear'/>"));var u,p={color:"#00cc33",weight:5,opacity:.6},d={color:"#00cc33",weight:6,opacity:.8},c={color:"darkgray",weight:6,opacity:.8},g=[],h=function(e){return function(){mapLayer.updateScale(e),ghRequest.useMiles=e,resolveAll(),routeLatLng(ghRequest)}};if(t.paths.length>0&&t.paths[0].points_order){mapLayer.clearLayers();var m=t.paths[0].points_order;for(r=0;r<m.length;r++)setFlag(ghRequest.route.getIndex(m[r]),r)}for(var v=0;v<t.paths.length;v++){var f=$("<li>").append(v+1+"<img class='alt_route_img' src='img/alt_route.png'/>");0===v&&(u=f),l.append(f);var q=t.paths[v],b=0===v?p:c,y={type:"Feature",geometry:q.points,properties:{style:b,name:"route",snapped_waypoints:q.snapped_waypoints}};g.push(y),mapLayer.addDataToRoutingLayer(y);var R=$("<div class='route_result_tab'>");i.append(R),f.click(Y(g,v,f,R,e.hasElevation(),e.useMiles));var x=$("<div class='route_description'>");q.description&&q.description.length>0&&(x.text(q.description),x.append("<br/>"));var I,_=translate.createDistanceString(q.distance,e.useMiles);if(e.isPublicTransit()){var w=moment(ghRequest.getEarliestDepartureTime()).add(q.time,"milliseconds").format("LT");I=q.transfers>=0?translate.tr("pt_route_info",[w,q.transfers,_]):translate.tr("pt_route_info_walking",[w,_])}else{var k=translate.createTimeString(q.time);I=translate.tr("route_info",[_,k])}x.append(I);var T=$("<button class='plain_text_button "+(e.useMiles?"gray":"")+"'>");T.text(translate.tr2("km_abbr")),T.click(h(!1));var C=$("<button class='plain_text_button "+(e.useMiles?"":"gray")+"'>");C.text(translate.tr2("mi_abbr")),C.click(h(!0));var F=$("<span style='float: right;'>");if(F.append(T),F.append("|"),F.append(C),x.append(F),e.hasElevation()&&x.append(translate.createEleInfoString(q.ascend,q.descend,e.useMiles)),x.append($("<div style='clear:both'/>")),R.append(x),q.instructions){var M=require("./instructions.js");R.append(M.create(mapLayer,q,a,e))}var j=q.details;if(j&&e.api_params.debug)for(var D in j){var S=j[D];for(r=0;r<S.length;r++){var A=S[r],z=A[0],E=A[2],P=q.points.coordinates[z];L.marker([P[1],P[0]],{icon:L.icon({iconUrl:"./img/marker-small-blue.png",iconSize:[15,15]}),draggable:!0,autoPan:!0}).addTo(mapLayer.getRoutingLayer()).bindPopup(D+":"+E)}}}u.click(),mapLayer.adjustMapSize();var H=t.paths[0];if(H.bbox&&o){var B=H.bbox[0],O=H.bbox[1],G=H.bbox[2],V=H.bbox[3],U=new L.LatLngBounds(new L.LatLng(O,B),new L.LatLng(V,G));mapLayer.fitMapToBounds(U)}$(".defaulting").each(function(e,t){$(t).css("color","black")})}function Y(e,t,r,o,a,n){return function(){var s=e[t];mapLayer.eachLayer(function(e){if(e.setStyle){var t=e.feature===s;e.setStyle(t?d:c),t&&(L.Browser.ie||L.Browser.opera||e.bringToFront())}}),a&&(mapLayer.clearElevation(),mapLayer.addElevation(s,n)),l.find("li").removeClass("current"),i.find("div").removeClass("current"),r.addClass("current"),o.addClass("current")}}})}function mySubmit(){var e,t,r,o=[],a=!0,n=$("#locationpoints > div.pointDiv > input.pointInput"),s=n.size;if($.each(n,function(n){0===n?(e=$(this).val())!==translate.tr("from_hint")&&""!==e?o.push(e):a=!1:n===s-1?(t=$(this).val())!==translate.tr("to_hint")&&""!==t?o.push(t):a=!1:(r=$(this).val())!==translate.tr("via_hint")&&""!==r?o.push(r):a=!1}),a&&e!==translate.tr("from_hint"))return t===translate.tr("to_hint")?(ghRequest.from.setStr(e),void $.when(resolveFrom()).done(function(){mapLayer.focus(ghRequest.from,null,0)})):void(a&&resolveCoords(o))}function isProduction(){return host.indexOf("graphhopper.com")>0}module.exports.setFlag=setFlag;
-
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./autocomplete.js":9,"./config/options.js":10,"./config/tileLayers.js":11,"./gpxexport.js":12,"./graphhopper/GHInput.js":13,"./graphhopper/GHRequest.js":14,"./instructions.js":17,"./lib/jquery-ui-custom-1.12.0.min.js":18,"./lib/jquery.autocomplete.js":19,"./lib/jquery.history.js":20,"./lib/leaflet.elevation-0.0.4.min.js":21,"./lib/leaflet_numbered_markers.js":22,"./map.js":24,"./messages.js":25,"./nominatim.js":26,"./routeManipulation.js":27,"./tools/format.js":28,"./tools/url.js":30,"./tools/vehicle.js":31,"./translate.js":32,"d3":1,"flatpickr":2,"flatpickr/dist/l10n":3,"jquery":4,"leaflet":7,"leaflet-contextmenu":5,"leaflet-loading":6,"moment":8}],24:[function(require,module,exports){
-var routingLayer,map,menuStart,menuIntermediate,menuEnd,defaultContextmenuItems,mainTemplate=require("./main-template.js"),tileLayers=require("./config/tileLayers.js"),translate=require("./translate.js"),elevationControl=null,fullscreenControl=null;function adjustMapSize(){var e=$("#map");if(e.width(100),fullscreenControl&&(fullscreenControl.updateClass(),fullscreenControl.isFullscreen()))return e.height($(window).height()).width($(window).width()),$("#input").hide(),void map.invalidateSize();var t=$(window).height();t=t<100?100:t,$("#input").show();var n=t-60-$("#input_header").height()-$("#footer").height(),a=$("#route_result_tabs li").height();n-=isNaN(a)?0:a;var o=$(".route_description").height();n-=isNaN(o)?0:o,$(".instructions_info").css("max-height",n);var r=$(window).width()-$("#input").width()-10;e.width(r).height(t)}function initMap(e,t,n,a,o,r){adjustMapSize();var i=tileLayers.selectLayer(o);defaultContextmenuItems=[{separator:!0,index:10},{text:translate.tr("show_coords"),callback:function(e){alert(e.latlng.lat+","+e.latlng.lng)},index:11},{text:translate.tr("center_map"),callback:function(e){map.panTo(e.latlng)},index:12}],map=L.map("map",{layers:[i],minZoom:2,contextmenu:!0,contextmenuItems:defaultContextmenuItems,zoomControl:!1,loadingControl:!1});var l={text:translate.tr("set_start"),icon:"./img/marker-small-green.png",callback:t,index:0},s={text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:n,disabled:!0,index:1},m={text:translate.tr("set_end"),icon:"./img/marker-small-red.png",callback:a,index:2};menuStart=map.contextmenu.insertItem(l,l.index),menuIntermediate=map.contextmenu.insertItem(s,s.index),menuEnd=map.contextmenu.insertItem(m,m.index);new L.Control.Zoom({position:"topleft",zoomInTitle:translate.tr("zoom_in"),zoomOutTitle:translate.tr("zoom_out")}).addTo(map);var u=!1;L.Control.Fullscreen=L.Control.extend({isFullscreen:function(){return u},updateClass:function(){var e=this.getContainer();L.DomUtil.setClass(e,u?"fullscreen-reverse-btn":"fullscreen-btn"),L.DomUtil.addClass(e,"leaflet-control")},onAdd:function(e){var t=L.DomUtil.create("div","fullscreen-btn");return t.title="Fullscreen Mode",t.onmousedown=function(e){u=!u,adjustMapSize()},t}}),fullscreenControl=new L.Control.Fullscreen({position:"topleft"}).addTo(map),(new L.Control.loading).addTo(map),L.control.layers(tileLayers.getAvailableTileLayers()).addTo(map),map.on("baselayerchange",function(e){e.name&&(tileLayers.activeLayerName=e.name,$("#export-link a").attr("href",function(e,t){return t.replace(/(layer=)([\w\s]+)/,"$1"+tileLayers.activeLayerName)}))}),scaleControl=L.control.scale(r?{metric:!1}:{imperial:!1}).addTo(map),map.fitBounds(new L.LatLngBounds(new L.LatLng(e.minLat,e.minLon),new L.LatLng(e.maxLat,e.maxLon))),map.attributionControl.setPrefix(!1);var d={type:"Feature",geometry:{type:"LineString",coordinates:[[e.minLon,e.minLat],[e.maxLon,e.minLat],[e.maxLon,e.maxLat],[e.minLon,e.maxLat],[e.minLon,e.minLat]]}};e.initialized&&L.geoJson(d,{style:{color:"black",weight:2,opacity:.3}}).addTo(map),(routingLayer=L.geoJson().addTo(map)).options={style:function(e){return e.properties&&e.properties.style},contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("route"),disabled:!0,index:0},{text:translate.tr("set_intermediate"),icon:"./img/marker-small-blue.png",callback:n,index:1}]),contextmenuInheritItems:!1}}function focus(e,t,n){e.lat&&e.lng&&(t||(t=11),routingLayer.clearLayers(),map.setView(new L.LatLng(e.lat,e.lng),t),mainTemplate.setFlag(e,n))}module.exports.clearLayers=function(){routingLayer.clearLayers()},module.exports.getRoutingLayer=function(){return routingLayer},module.exports.getSubLayers=function(e){return routingLayer.getLayers().filter(function(t){return t.feature&&t.feature.properties&&t.feature.properties.name===e})},module.exports.addDataToRoutingLayer=function(e){routingLayer.addData(e)},module.exports.eachLayer=function(e){routingLayer.eachLayer(e)},module.exports.setDisabledForMapsContextMenu=function(e,t){"start"===e&&map.contextmenu.setDisabled(menuStart,t),"end"===e&&map.contextmenu.setDisabled(menuEnd,t),"intermediate"===e&&map.contextmenu.setDisabled(menuIntermediate,t)},module.exports.fitMapToBounds=function(e){map.fitBounds(e,{padding:[42,42]})},module.exports.removeLayerFromMap=function(e){map.removeLayer(e)},module.exports.focus=focus,module.exports.initMap=initMap,module.exports.adjustMapSize=adjustMapSize,module.exports.addElevation=function(e,t){null===elevationControl&&(elevationControl=L.control.elevation({position:"bottomright",theme:"white-theme",width:450,height:125,margins:{top:10,right:20,bottom:30,left:60},useHeightIndicator:!0,interpolation:"linear",hoverNumber:{decimalsX:2,decimalsY:0,formatter:void 0},xTicks:void 0,yTicks:void 0,collapsed:!1})).addTo(map),elevationControl.options.imperial=t,elevationControl.addData(e)},module.exports.clearElevation=function(){elevationControl&&elevationControl.clear()},module.exports.getMap=function(){return map},module.exports.updateScale=function(e){if(null!==scaleControl){scaleControl.remove();var t=e?{metric:!1}:{imperial:!1};scaleControl=L.control.scale(t).addTo(map)}};var FROM="from",TO="to";function getToFrom(e,t){return 0===e?FROM:e===t.route.size()-1?TO:-1}var iconFrom=L.icon({iconUrl:"./img/marker-icon-green.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]}),iconTo=L.icon({iconUrl:"./img/marker-icon-red.png",shadowSize:[50,64],shadowAnchor:[4,62],iconAnchor:[12,40]});module.exports.createMarker=function(e,t,n,a,o,r){var i=getToFrom(e,r);return L.marker([t.lat,t.lng],{icon:i===FROM?iconFrom:i===TO?iconTo:new L.NumberedDivIcon({number:e}),draggable:!0,autoPan:!0,contextmenu:!0,contextmenuItems:defaultContextmenuItems.concat([{text:translate.tr("marker")+" "+(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e),disabled:!0,index:0},{text:translate.tr(i!==TO?"set_end":"set_start"),icon:i!==TO?"./img/marker-small-red.png":"./img/marker-small-green.png",callback:i!==TO?n:a,index:2},{text:translate.tr("delete_from_route"),callback:o,disabled:-1!==i&&2===r.route.size(),index:3}]),contextmenuInheritItems:!1}).addTo(routingLayer).bindPopup(i===FROM?translate.tr("start_label"):i===TO?translate.tr("end_label"):translate.tr("intermediate_label")+" "+e)};
-
-},{"./config/tileLayers.js":11,"./main-template.js":23,"./translate.js":32}],25:[function(require,module,exports){
-module.exports.extractMetaVersionInfo=function(e){return metaVersionInfo="",e.data_date&&(metaVersionInfo+="<br/>Data date: "+e.data_date),e.import_date&&(metaVersionInfo+="<br/>Import date: "+e.import_date),e.prepare_date&&(metaVersionInfo+="<br/>Prepare date: "+e.prepare_date),e.version&&(metaVersionInfo+="<br/>GH version: "+e.version),e.build_date&&(metaVersionInfo+="<br/>Jar date: "+e.build_date),metaVersionInfo},module.exports.getSignName=function(e){return-98===e?"u_turn":-8===e?"u_turn_left":-7===e?"keep_left":-3===e?"sharp_left":-2===e?"left":-1===e?"slight_left":0===e?"continue":1===e?"slight_right":2===e?"right":3===e?"sharp_right":4===e?"marker-icon-red":5===e?"marker-icon-blue":6===e?"roundabout":7===e?"keep_right":8===e?"u_turn_right":101===e?"pt_start_trip":102===e?"pt_transfer_to":103===e?"pt_end_trip":"unknown"},module.exports.browserTitle="GraphHopper Maps - Driving Directions";
-
-},{}],26:[function(require,module,exports){
-var bounds,nominatimURL="https://nominatim.openstreetmap.org/search",nominatimReverseURL="https://nominatim.openstreetmap.org/reverse",mathTools=require("./tools/math.js"),format=require("./tools/format.js");function createAmbiguityList(o){o.error="",o.resolvedList=[];if(o.isResolved()){var n=$.Deferred();return n.resolve([o]),n}if(o.lat&&o.lng){var r=nominatimReverseURL+"?lat="+o.lat+"&lon="+o.lng+"&format=json&zoom=16";return $.ajax({url:r,type:"GET",dataType:"json",timeout:3e3}).then(function(n){if(!n)return o.error="No description found for coordinate",[o];var r=n.address,e={};return e.lat=o.lat,e.lng=o.lng,e.bbox=n.boundingbox,e.positionType=n.type,e.locationDetails=format.formatLocationEntry(r),o.resolvedList.push(e),[o]},function(n){return console.log("[nominatim_reverse] Error while looking up coordinate lat="+o.lat+"&lon="+o.lng),o.error="Problem while looking up location.",[o]})}return doGeoCoding(o.input,10,3e3).then(function(n){if(!n||0===n.length)return o.error="No area description found",[o];var r,e=n[0].importance;for(var t in n){var i=n[t];if(e-i.importance>.4)break;if(!r||JSON.stringify(r)!==JSON.stringify(i.address)){r=i.address,e=i.importance;var a={};a.lat=mathTools.round(i.lat),a.lng=mathTools.round(i.lon),a.locationDetails=format.formatLocationEntry(r),a.bbox=i.boundingbox,a.positionType=i.type,o.resolvedList.push(a)}}if(0===o.resolvedList.length)return o.error="No area description found",[o];var s=o.resolvedList;return o.lat=s[0].lat,o.lng=s[0].lng,[o]},function(){return o.error="Problem while looking up address",[o]})}function doGeoCoding(o,n,r){n||(n=10);var e=nominatimURL+"?format=json&addressdetails=1&q="+encodeURIComponent(o)+"&limit="+n;return bounds.initialized&&(e+="&bounded=1&viewbox="+bounds.minLon+","+bounds.maxLat+","+bounds.maxLon+","+bounds.minLat),$.ajax({url:e,type:"GET",dataType:"json",timeout:r}).fail(createCallback("[nominatim] Problem while looking up location "+o))}function createCallback(o){return function(n){console.log(o+" "+JSON.stringify(n))}}function resolve(o,n){var r=$("#locationpoints > div.pointDiv").eq(o);return $(r).find(".pointFlag").hide(),$(r).find(".pointIndicator").show(),$(r).find(".pointInput").val(n.input),createAmbiguityList(n).always(function(){var o=$(r).find(".pointResolveError");return o.empty(),n.error&&(o.show(),o.text(n.error).fadeOut(5e3),n.error=""),$(r).find(".pointIndicator").hide(),$(r).find(".pointFlag").show(),n})}module.exports.resolve=resolve,module.exports.setBounds=function(o){bounds=o};
-
-},{"./tools/format.js":28,"./tools/math.js":29}],27:[function(require,module,exports){
-var L=require("leaflet");module.exports.getIntermediatePointIndex=function(e,n){for(var t=0,r=e[0].wayPoints,a=[],i=0;i<e.length;++i)for(var o=e[i].coordinates,d=0;d<o.length;++d)o[d].equals(r[t],1e-5)&&t++,a.push({distance:o[d].distanceTo(n),nextWayPointIndex:t===r.length?t-1:t});var s=a.reduce(function(e,n){return n.distance-e.distance<1e-6?n:e}).nextWayPointIndex;return s=s>0&&s<r.length?s:1};
-
-},{"leaflet":7}],28:[function(require,module,exports){
-function insComma(o,t){return o.length>0?o+", "+t:t}function formatLocationEntry(o){var t={},n="";return o?(o.road&&(n=o.road,o.house_number&&(n.length>0&&(n+=" "),n+=o.house_number),t.road=n),o.postcode&&(t.postcode=o.postcode),t.country=o.country,(o.city||o.suburb||o.town||o.village||o.hamlet||o.locality)&&(n="",o.locality&&(n=insComma(n,o.locality)),o.hamlet&&(n=insComma(n,o.hamlet)),o.village&&(n=insComma(n,o.village)),o.suburb&&(n=insComma(n,o.suburb)),o.city&&(n=insComma(n,o.city)),o.town&&(n=insComma(n,o.town)),t.city=n),n="",o.state&&(n+=o.state),o.continent&&(n=insComma(n,o.continent)),t.more=n,t):t}module.exports.formatLocationEntry=formatLocationEntry,module.exports.formatAddress=function(o){return(o.road?o.road+", ":"")+(o.postcode?o.postcode+", ":"")+(o.city?o.city+", ":"")+(o.country?o.country:"")},module.exports.insComma=insComma,module.exports.formatValue=function(o,t){var n="("+$.Autocomplete.utils.escapeRegExChars(t)+")";return o.replace(/[<>]/g,"_").replace(new RegExp(n,"gi"),"<strong>$1</strong>")};
-
-},{}],29:[function(require,module,exports){
-module.exports.getCenter=function(n){var o={lat:0,lng:0};return n.initialized&&(o.lat=(n.minLat+n.maxLat)/2,o.lng=(n.minLon+n.maxLon)/2),o},module.exports.floor=function(n,o){return o||(o=1e6),Math.floor(n*o)/o},module.exports.round=function(n,o){return void 0===o&&(o=1e6),Math.round(n*o)/o};
-
-},{}],30:[function(require,module,exports){
-var isArray=function(r){return"[object array]"===Object.prototype.toString.call(r).toLowerCase()};function parseUrlWithHisto(){return window.location.hash?parseUrl(window.location.hash):parseUrl(window.location.search)}function parseUrl(r){var e=r.indexOf("?");e>=0&&(r=r.substring(e+1));for(var t={},a=r.split("&"),o=0;o<a.length;o++){var n=a[o].indexOf("=");if(!(n<0)){var i=a[o].substring(0,n),s=a[o].substring(n+1);mergeParamIntoObject(t,i,s=decodeURIComponent(s.replace(/\+/g," ")))}}return t}function mergeParamIntoObject(r,e,t){var a,o=e.indexOf(".");if(o<0)return void 0===r[e]&&"heading"!==e&&"point"!==e&&"details"!==e?("true"===t?t=!0:"false"===t&&(t=!1),r[e]=t):(a=r[e],isArray(a)?a.push(t):r[e]=a?[a,t]:[t]),r;var n=e.substring(0,o),i=e.substring(o+1);return(a=r[n])||(a={}),r[n]=mergeParamIntoObject(a,i,t),r}module.exports.parseUrl=parseUrl,module.exports.mergeParamIntoObject=mergeParamIntoObject,module.exports.parseUrlWithHisto=parseUrlWithHisto;
-
-},{}],31:[function(require,module,exports){
-module.exports.getSortedVehicleKeys=function(e,r){var t=Object.keys(e);return t.sort(function(e,t){var o=r[e],n=r[t];return o||n?(o||(o=4),n||(n=4),o-n):e.localeCompare(t)}),t};
-
-},{}],32:[function(require,module,exports){
-(function (global){
-var i18nIsInitialized,defaultTranslationMap=null,enTranslationMap=null,mathTools=require("./tools/math.js");function tr2(t,r){if(null===t)return console.log("ERROR: key was null?"),"";if(null===defaultTranslationMap)return console.log("ERROR: defaultTranslationMap was not initialized?"),t;t=t.toLowerCase();var o=defaultTranslationMap[t];return!o&&enTranslationMap&&(o=enTranslationMap[t]),o?stringFormat(o,r):t}function tr(t,r){return t!==t.toLowerCase()&&console.log("key "+t+" has to be lower case"),tr2("web."+t,r)}function stringFormat(t,r){if("string"==typeof r&&(r=[r]),t.indexOf("%1$s")>=0)return t.replace(/\%(\d+)\$s/g,function(t,o){return void 0!==r[--o]?r[o]:t});var o=0;return t.replace(/\%s/g,function(t){var n=void 0!==r[o]?r[o]:t;return o++,n})}function initI18N(){if(global.$){$("#searchButton").attr("value",tr("search_button"));var t=$("#locationpoints > div.pointDiv > input.pointInput"),r=t.size;$(t).each(function(t){0===t?$(this).attr("placeholder",tr("from_hint")):t===r-1?$(this).attr("placeholder",tr("to_hint")):$(this).attr("placeholder",tr("via_hint"))}),$(".pointFlag").each(function(){$(this).attr("title",tr("drag_to_reorder"))}),$(".pointDelete").each(function(){$(this).attr("title",tr("delete_from_route"))}),$("#export-link").attr("title",tr("staticlink")),$("#gpxExportButton").attr("title",tr("gpx_export_button"))}}function mToKm(t){return t/1e3}function mToFt(t){return t/.3048}function mToMi(t){return t/1609.344}module.exports.createDistanceString=function(t,r){return r?t<152?mathTools.round(mToFt(t),1)+tr2("ft_abbr"):((t=mathTools.round(mToMi(t),100))>100&&(t=mathTools.round(t,1)),t+tr2("mi_abbr")):t<900?mathTools.round(t,1)+tr2("m_abbr"):((t=mathTools.round(mToKm(t),100))>100&&(t=mathTools.round(t,1)),t+tr2("km_abbr"))},module.exports.createEleInfoString=function(t,r,o){var n="";return(t>0||r>0)&&(n="<br/> ",t>0&&(n+=o?"&#8599;"+mathTools.round(mToFt(t),1)+tr2("ft_abbr"):"&#8599;"+mathTools.round(t,1)+tr2("m_abbr")),r>0&&(n+=o?" &#8600;"+mathTools.round(mToFt(r),1)+tr2("ft_abbr"):" &#8600;"+mathTools.round(r,1)+tr2("m_abbr"))),n},module.exports.createTimeString=function(t){var r,o=mathTools.round(t/60/1e3,1e3);return o>60?o/60>24?(r=mathTools.floor(o/60/24,1)+tr2("day_abbr"),(o=mathTools.floor(o/60%24,1))>0&&(r+=" "+o+tr2("hour_abbr"))):(r=mathTools.floor(o/60,1)+tr2("hour_abbr"),(o=mathTools.floor(o%60,1))>0&&(r+=" "+o+tr2("min_abbr"))):r=mathTools.round(o%60,1)+tr2("min_abbr"),r},module.exports.tr=tr,module.exports.tr2=tr2,module.exports.nanoTemplate=function(t,r){return t.replace(/\{([\w\.]*)\}/g,function(t,o){var n=o.split("."),a=r[n.shift()];for(i=0,l=n.length;i<l;_i++)a=a[this];return void 0!==a&&null!==a?a:""})},module.exports.init=function(t){defaultTranslationMap=t.default,enTranslationMap=t.en,defaultTranslationMap||(defaultTranslationMap=enTranslationMap),i18nIsInitialized=!0,initI18N()},module.exports.isI18nIsInitialized=function(){return i18nIsInitialized};
-
-}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
-},{"./tools/math.js":29}]},{},[23]);
diff --git a/web/src/main/resources/assets/js/map.js b/web/src/main/resources/assets/js/map.js
index 64544b1ae8..04d2ec9346 100644
--- a/web/src/main/resources/assets/js/map.js
+++ b/web/src/main/resources/assets/js/map.js
@@ -135,7 +135,10 @@ function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selec
 
     new L.Control.loading().addTo(map);
 
-    L.control.layers(tileLayers.getAvailableTileLayers()/*, overlays*/).addTo(map);
+    if(tileLayers.getOverlays())
+        L.control.layers(tileLayers.getAvailableTileLayers(), tileLayers.getOverlays()).addTo(map);
+    else
+        L.control.layers(tileLayers.getAvailableTileLayers()).addTo(map);
 
     map.on('baselayerchange', function (a) {
         if (a.name) {
@@ -204,6 +207,7 @@ function initMap(bounds, setStartCoord, setIntermediateCoord, setEndCoord, selec
             }]),
         contextmenuInheritItems: false
     };
+
 }
 
 function focus(coord, zoom, index) {
@@ -262,39 +266,104 @@ module.exports.focus = focus;
 module.exports.initMap = initMap;
 module.exports.adjustMapSize = adjustMapSize;
 
-module.exports.addElevation = function (geoJsonFeature, useMiles) {
+module.exports.addElevation = function (geoJsonFeature, useMiles, details) {
+
+    // Don't show the elevation graph on small displays
+    if(window.innerWidth < 900 || window.innerHeight < 400){
+        return;
+    }
+
+    // TODO no option to switch to miles yet
+    var options = {
+       width: 600,
+       height: 280,
+       margins: {
+           top: 10,
+           right: 30,
+           bottom: 55,
+           left: 50
+       },
+       position: "bottomright"
+    }
+
+    var GHFeatureCollection = [];
+
+    for (var detailKey in details) {
+        GHFeatureCollection.push(sliceFeatureCollection(details[detailKey], detailKey, geoJsonFeature))
+    }
+
+    if(GHFeatureCollection.length === 0) {
+        // No Path Details => Show only elevation
+        geoJsonFeature.properties.attributeType = "elevation";
+        var elevationCollection = {
+            "type": "FeatureCollection",
+            "features": [geoJsonFeature],
+            "properties": {
+                "Creator": "GraphHopper",
+                "records": 1,
+                "summary": "Elevation"
+            }
+        };
+        GHFeatureCollection.push(elevationCollection);
+        // Use a fixed color for elevation
+        options.mappings = { Elevation: {'elevation': {text: 'Elevation [m]', color: '#27ce49'}}};
+    }
+
     if (elevationControl === null) {
-        elevationControl = L.control.elevation({
-            position: "bottomright",
-            theme: "white-theme", //default: lime-theme
-            width: 450,
-            height: 125,
-            margins: {
-                top: 10,
-                right: 20,
-                bottom: 30,
-                left: 60
-            },
-            useHeightIndicator: true, //if false a marker is drawn at map position
-            interpolation: "linear", //see https://github.com/mbostock/d3/wiki/SVG-Shapes#wiki-area_interpolate
-            hoverNumber: {
-                decimalsX: 2, //decimals on distance (in km or mi)
-                decimalsY: 0, //decimals on height (in m or ft)
-                formatter: undefined //custom formatter function may be injected
-            },
-            xTicks: undefined, //number of ticks in x axis, calculated by default according to width
-            yTicks: undefined, //number of ticks on y axis, calculated by default according to height
-            collapsed: false    //collapsed mode, show chart on click or mouseover
-        });
+        elevationControl = L.control.heightgraph(options);
         elevationControl.addTo(map);
     }
-    elevationControl.options.imperial = useMiles;
-    elevationControl.addData(geoJsonFeature);
+
+    elevationControl.addData(GHFeatureCollection);
 };
 
+function sliceFeatureCollection(detail, detailKey, geoJsonFeature){
+
+    var feature = {
+      "type": "FeatureCollection",
+      "features": [],
+      "properties": {
+          "Creator": "GraphHopper",
+          "summary": detailKey,
+          "records": detail.length
+      }
+    };
+
+    var points = geoJsonFeature.geometry.coordinates;
+    for (var i = 0; i < detail.length; i++) {
+        var detailObj = detail[i];
+        var from = detailObj[0];
+        // It's important to +1
+        // Array.slice is exclusive the to element and the feature needs to include the to coordinate
+        var to = detailObj[1] + 1;
+        var value = detailObj[2] || "Undefined";
+
+        var tmpPoints = points.slice(from,to)
+
+        feature.features.push({
+          "type": "Feature",
+          "geometry": {
+              "type": "LineString",
+              "coordinates": tmpPoints
+          },
+          "properties": {
+              "attributeType": value
+          }
+        });
+    }
+
+    return feature;
+}
+
 module.exports.clearElevation = function () {
-    if (elevationControl)
-        elevationControl.clear();
+    if (elevationControl){
+        if(elevationControl._markedSegments){
+            map.removeLayer(elevationControl._markedSegments);
+        }
+        // TODO this part is not really nice to remove and readd it to the map everytime
+        elevationControl.remove();
+        elevationControl = null;
+    }
 };
 
 module.exports.getMap = function () {
diff --git a/web/src/main/resources/assets/js/tools/format.js b/web/src/main/resources/assets/js/tools/format.js
index 0193e48f8b..214bb69881 100644
--- a/web/src/main/resources/assets/js/tools/format.js
+++ b/web/src/main/resources/assets/js/tools/format.js
@@ -4,6 +4,7 @@ function insComma(textA, textB) {
     return textB;
 }
 
+// TODO unused: currently just dataToHtml is used
 function formatLocationEntry(address) {
     var locationDetails = {};
     var text = "";
@@ -53,6 +54,7 @@ function formatLocationEntry(address) {
 
 module.exports.formatLocationEntry = formatLocationEntry;
 
+// TODO unused
 module.exports.formatAddress = function (address) {
     return ((address.road) ? address.road + ', ' : '') +
         ((address.postcode) ? address.postcode + ', ' : '') +
diff --git a/web/src/main/resources/assets/js/translate.js b/web/src/main/resources/assets/js/translate.js
index 1d382cbe5e..5df696ac55 100644
--- a/web/src/main/resources/assets/js/translate.js
+++ b/web/src/main/resources/assets/js/translate.js
@@ -57,12 +57,14 @@ function initI18N() {
         var location_points = $("#locationpoints > div.pointDiv > input.pointInput");
         var l = location_points.size;
         $(location_points).each(function (index) {
-            if (index === 0)
+            if (index === 0) {
                 $(this).attr("placeholder", tr("from_hint"));
-            else if (index === (l - 1))
+                $(this).focus();
+            } else if (index === (l - 1)) {
                 $(this).attr("placeholder", tr("to_hint"));
-            else
+            } else {
                 $(this).attr("placeholder", tr("via_hint"));
+            }
         });
         $('.pointFlag').each(function () {
             $(this).attr('title', tr('drag_to_reorder'));
diff --git a/web/src/main/resources/assets/opensearch.xml b/web/src/main/resources/assets/opensearch.xml
index f306ef97c2..36c0b13811 100644
--- a/web/src/main/resources/assets/opensearch.xml
+++ b/web/src/main/resources/assets/opensearch.xml
@@ -6,7 +6,7 @@
     <Contact>info@graphhopper.com</Contact>    
     <Image height="16" width="16" type="image/x-icon">http://graphhopper.com/favicon.ico</Image>
     <Image height="16" width="16" type="image/x-icon">http://graphhopper.com/img/icon.png</Image>
-    <Url type="text/html" template="http://graphhopper.com/maps?q={searchTerms}"/>    
+    <Url type="text/html" template="https://graphhopper.com/maps/?point={searchTerms}"/>    
     <OutputEncoding>UTF-8</OutputEncoding>
     <InputEncoding>UTF-8</InputEncoding>
-</OpenSearchDescription>
\ No newline at end of file
+</OpenSearchDescription>
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
similarity index 83%
rename from web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java
rename to web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
index 8838374ac1..5af59cf50b 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
@@ -31,18 +31,21 @@
 import static org.junit.Assert.*;
 
 /**
- * Tests the DataFlagencoder with the SpatialRuleLookup enabled
+ * Tests the DataFlagEncoder with the SpatialRuleLookup enabled
  *
  * @author Robin Boldt
  */
-public class GraphHopperDataflagEncoderSpatialRulesIT {
+public class GraphHopperDataFlagEncoderSpatialRulesTest {
     private static final String DIR = "./target/north-bayreuth-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
 
     static {
+        // The EncodedValue "country" requires the setting "spatial_rules.location" as "country" does not load via DefaultTagParserFactory
+        // TODO should we automatically detect this somehow and include a default country file?
         config.getGraphHopperConfiguration().merge(new CmdArgs().
                 put("graph.flag_encoders", "generic").
+                put("graph.encoded_values", "country,road_environment,road_class,road_access,max_speed").
                 put("prepare.ch.weightings", "no").
                 put("spatial_rules.location", "../core/files/spatialrules/countries.geo.json").
                 put("spatial_rules.max_bbox", "11.4,11.7,49.9,50.1").
@@ -51,17 +54,16 @@
     }
 
     @ClassRule
-    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule(
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule<>(
             GraphHopperApplication.class, config);
 
-
     @AfterClass
     public static void cleanUp() {
         Helper.removeDir(new File(DIR));
     }
 
     @Test
-    public void testDetourToComplyWithSpatialRule() throws Exception {
+    public void testDetourToComplyWithSpatialRule() {
         final Response response = app.client().target("http://localhost:8080/route?" + "point=49.995933,11.54809&point=50.004871,11.517191&vehicle=generic").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
rename to web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
index 427ee6e923..a98ab0a243 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
@@ -36,7 +36,7 @@
  *
  * @author Robin Boldt
  */
-public class GraphHopperLandmarksIT {
+public class GraphHopperLandmarksTest {
     private static final String DIR = "./target/landmark-test-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java b/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
similarity index 60%
rename from web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java
rename to web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
index c5afb9c87c..119c8dc0d1 100644
--- a/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
@@ -9,19 +9,24 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.shapes.Polygon;
 import io.dropwizard.testing.junit.DropwizardAppRule;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.JsonNode;
 import org.junit.AfterClass;
 import org.junit.ClassRule;
 import org.junit.Test;
 
 import javax.ws.rs.core.Response;
 import java.io.File;
+import java.io.IOException;
 import java.util.List;
+import java.util.Map;
 
 import static junit.framework.TestCase.assertFalse;
 import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
 
-public class IsochroneResourceIT {
+public class IsochroneResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
@@ -39,7 +44,7 @@
     }
 
     @ClassRule
-    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule(
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule<>(
             GraphHopperApplication.class, config);
 
     @AfterClass
@@ -97,7 +102,8 @@ public void requestBadRequest() {
         Response response = app.client().target("http://localhost:8080/route?point=-1.816719,51.557148").request().buildGet().invoke();
         assertEquals(400, response.getStatus());
     }
-  
+
+    @Test
     public void requestWithShortest() throws Exception {
         IsochroneResponse rsp = client.isochroneGet("42.509644,1.540554", "no_key_necessary", 130,
                 -1, "car", 1, false, "shortest");
@@ -114,7 +120,86 @@ public void requestWithShortest() throws Exception {
         polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
         assertTrue(polygon0.size() >= 190);
     }
+    
+    @Test
+    public void requestJsonBadType() throws IOException {
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130&type=xml");
+
+        JsonNode json = parseRequestResponse(response);
+        String message = json.path("message").asText();
 
+        assertEquals(message, "Format not supported:xml");
+    }
+    
+    
+    @Test
+    public void requestJsonWithType() throws IOException {
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130&type=json");
+        JsonNode json = parseRequestResponse(response);
+        assertTrue(json.has("polygons"));
+        assertTrue(json.has("info"));
+    }
+    
+    @Test
+    public void requestJsonNoType() throws IOException {
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130");
+        JsonNode json = parseRequestResponse(response);
+        assertTrue(json.has("polygons"));
+        assertTrue(json.has("info"));
+    }
+    
+    @Test
+    public void requestGeoJsonPolygons() throws IOException {        
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130&type=geojson");
+        JsonNode json = parseRequestResponse(response);
+        
+        assertFalse(json.has("polygons"));
+        assertFalse(json.has("info"));
+        
+        assertTrue(json.has("type"));
+        assertEquals(json.path("type").asText(), "FeatureCollection");
+        
+        assertTrue(json.has("features"));
+        
+        JsonNode firstFeature = json.path("features").path(0);
+        assertTrue(firstFeature.isObject());
+        
+        assertTrue(firstFeature.path("properties").has("bucket"));
+        assertTrue(firstFeature.path("properties").has("copyrights"));
+        
+        assertEquals(firstFeature.path("type").asText(), "Feature");
+        assertEquals(firstFeature.path("geometry").path("type").asText(), "Polygon");
+    }
+    
+    @Test
+    public void requestGeoJsonPolygonsBuckets() throws IOException {        
+        Response response = requestIsochrone("/isochrone?point=42.531073,1.573792&time_limit=130&type=geojson&buckets=3");
+        JsonNode json = parseRequestResponse(response);
+        
+        JsonNode features = json.path("features");
+        int length = features.size();
+        JsonNode firstFeature = features.path(0);
+        JsonNode lastFeature = features.path(length - 1);
+        
+        assertEquals(firstFeature.path("properties").path("bucket").asInt(), 0);
+        assertEquals(firstFeature.path("geometry").path("type").asText(), "Polygon");
+        
+        assertEquals(lastFeature.path("properties").path("bucket").asInt(), 2);
+        assertEquals(lastFeature.path("geometry").path("type").asText(), "Polygon");
+    }    
+    
+    private Response requestIsochrone(String path) {
+    	String url = "http://localhost:8080" + path;
+        return app.client().target(url).request().buildGet().invoke();
+    }
+    
+    private JsonNode parseRequestResponse (Response response) throws IOException {
+        String body = response.readEntity(String.class);
+        
+        ObjectMapper objectMapper = new ObjectMapper();
+        return objectMapper.readTree(body);
+    }
+    
     private boolean contains(List polygon, double lat, double lon) {
         int index = 0;
         double lats[] = new double[polygon.size()];
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java b/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java
new file mode 100644
index 0000000000..b6e740421a
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/isochrone/PtIsochroneResourceTest.java
@@ -0,0 +1,117 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http.isochrone;
+
+import com.graphhopper.http.GHPointConverterProvider;
+import com.graphhopper.jackson.Jackson;
+import com.graphhopper.reader.gtfs.GraphHopperGtfs;
+import com.graphhopper.reader.gtfs.GtfsStorage;
+import com.graphhopper.reader.gtfs.PtFlagEncoder;
+import com.graphhopper.resources.PtIsochroneResource;
+import com.graphhopper.routing.util.CarFlagEncoder;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.storage.GHDirectory;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.util.Helper;
+import io.dropwizard.testing.junit.ResourceTestRule;
+import org.junit.AfterClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.locationtech.jts.geom.Coordinate;
+import org.locationtech.jts.geom.Geometry;
+import org.locationtech.jts.geom.GeometryFactory;
+
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import java.io.File;
+import java.time.LocalDateTime;
+import java.time.ZoneId;
+import java.util.Collections;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public class PtIsochroneResourceTest {
+
+    private static final String GRAPH_LOC = "target/PtIsochroneResourceTest";
+    private static final ZoneId zoneId = ZoneId.of("America/Los_Angeles");
+    private static GraphHopperStorage graphHopperStorage;
+    private static LocationIndex locationIndex;
+    private static PtIsochroneResource isochroneResource;
+    private GeometryFactory geometryFactory = new GeometryFactory();
+
+    static {
+        Helper.removeDir(new File(GRAPH_LOC));
+        final PtFlagEncoder ptFlagEncoder = new PtFlagEncoder();
+        final CarFlagEncoder carFlagEncoder = new CarFlagEncoder();
+        final FootFlagEncoder footFlagEncoder = new FootFlagEncoder();
+
+        EncodingManager encodingManager = new EncodingManager.Builder(12).add(carFlagEncoder).add(footFlagEncoder).add(ptFlagEncoder).build();
+        GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
+        GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("../reader-gtfs/files/sample-feed.zip"), Collections.emptyList());
+        locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
+        isochroneResource = new PtIsochroneResource(gtfsStorage, graphHopperStorage.getEncodingManager(), graphHopperStorage, locationIndex);
+    }
+
+    @ClassRule
+    public static final ResourceTestRule resources = ResourceTestRule.builder()
+            .addProvider(new GHPointConverterProvider())
+            .setMapper(Jackson.newObjectMapper())
+            .addResource(isochroneResource)
+            .build();
+
+
+    @Test
+    public void testIsoline() {
+        WebTarget webTarget = resources
+                .target("/isochrone")
+                .queryParam("point", "36.914893,-116.76821") // NADAV
+                .queryParam("pt.earliest_departure_time", LocalDateTime.of(2007, 1, 1, 0, 0, 0).atZone(zoneId).toInstant())
+                .queryParam("time_limit", 6 * 60 * 60 + 49 * 60); // exactly the time I should arrive at NANAA
+        Invocation.Builder request = webTarget.request();
+        PtIsochroneResource.Response isochroneResponse = request.get(PtIsochroneResource.Response.class);
+        Geometry isoline = isochroneResponse.polygons.get(0).getGeometry();
+        // NADAV is in
+        assertTrue(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.76821, 36.914893)))));
+        // NANAA is in
+        assertTrue(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.761472, 36.914944)))));
+        // DADAN is in
+        assertTrue(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.768242, 36.909489)))));
+        // EMSI is in
+        assertTrue(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.76218, 36.905697)))));
+        // STAGECOACH is out
+        assertFalse(isoline.covers(geometryFactory.createPoint(makePrecise(new Coordinate(-116.751677, 36.915682)))));
+    }
+
+    // Snap coordinate to GraphHopper's implicit grid of allowable points.
+    // Otherwise, we can't reliably use coordinates from input data in tests.
+    private Coordinate makePrecise(Coordinate coordinate) {
+        return new Coordinate(Helper.intToDegree(Helper.degreeToInt(coordinate.x)), Helper.intToDegree(Helper.degreeToInt(coordinate.y)));
+    }
+
+    @AfterClass
+    public static void close() {
+        graphHopperStorage.close();
+        locationIndex.close();
+    }
+
+}
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/SPTResourceTest.java b/web/src/test/java/com/graphhopper/http/isochrone/SPTResourceTest.java
new file mode 100644
index 0000000000..b892858527
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/isochrone/SPTResourceTest.java
@@ -0,0 +1,93 @@
+package com.graphhopper.http.isochrone;
+
+import com.graphhopper.directions.api.client.ApiClient;
+import com.graphhopper.directions.api.client.api.IsochroneApi;
+import com.graphhopper.http.GraphHopperApplication;
+import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import io.dropwizard.testing.junit.DropwizardAppRule;
+import org.junit.AfterClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+import java.util.Arrays;
+import java.util.List;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+
+public class SPTResourceTest {
+    private static final String DIR = "./target/spt-gh/";
+
+    private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
+
+    private static IsochroneApi client;
+
+    static {
+        config.getGraphHopperConfiguration().merge(new CmdArgs().
+                put("prepare.ch.weightings", "no").
+                put("graph.flag_encoders", "car").
+                put("graph.encoded_values", "max_speed,road_class").
+                put("datareader.file", "../core/files/andorra.osm.pbf").
+                put("graph.location", DIR));
+        client = new IsochroneApi();
+        client.setApiClient(new ApiClient().setBasePath("http://localhost:8080"));
+    }
+
+    @ClassRule
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule<>(
+            GraphHopperApplication.class, config);
+
+    @AfterClass
+    public static void cleanUp() {
+        Helper.removeDir(new File(DIR));
+    }
+
+    @Test
+    public void requestSPT() {
+        Response rsp = app.client().target("http://localhost:8080/spt?point=42.531073,1.573792&time_limit=300").request().buildGet().invoke();
+        String rspCsvString = rsp.readEntity(String.class);
+        String[] lines = rspCsvString.split("\n");
+        assertTrue(lines.length > 500);
+        List<String> headers = Arrays.asList(lines[0].split(","));
+        assertEquals("[longitude, latitude, time, distance]", headers.toString());
+        String[] row = lines[1].split(",");
+        assertEquals(1.5552, Double.parseDouble(row[0]), 0.0001);
+        assertEquals(42.5179, Double.parseDouble(row[1]), 0.0001);
+        assertEquals(118, Integer.parseInt(row[2]) / 1000, 1);
+        assertEquals(2263, Integer.parseInt(row[3]), 1);
+
+        rsp = app.client().target("http://localhost:8080/spt?point=42.531073,1.573792&columns=prev_time").request().buildGet().invoke();
+        rspCsvString = rsp.readEntity(String.class);
+        lines = rspCsvString.split("\n");
+        assertTrue(lines.length > 500);
+        headers = Arrays.asList(lines[0].split(","));
+        int prevTimeIndex = headers.indexOf("prev_time");
+        assertNotEquals(-1, prevTimeIndex);
+
+        row = lines[1].split(",");
+        assertEquals(115, Integer.parseInt(row[prevTimeIndex]) / 1000);
+    }
+
+    @Test
+    public void requestDetails() {
+        Response rsp = app.client().target("http://localhost:8080/spt?point=42.531073,1.573792&time_limit=300&columns=street_name,road_class,max_speed").request().buildGet().invoke();
+        String rspCsvString = rsp.readEntity(String.class);
+        String[] lines = rspCsvString.split("\n");
+        assertTrue(lines.length > 500);
+
+        String[] row = lines[16].split(",");
+        assertEquals("", row[0]);
+        assertEquals("service", row[1]);
+        assertEquals(20, Double.parseDouble(row[2]), .1);
+
+        row = lines[9].split(",");
+        assertEquals("Carretera d'Engolasters CS-200", row[0]);
+        assertEquals("secondary", row[1]);
+        assertTrue(Double.isInfinite(Double.parseDouble(row[2])));
+    }
+}
\ No newline at end of file
diff --git a/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
index 8a0674a3d9..e156867450 100644
--- a/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
@@ -37,7 +37,7 @@
 /**
  * @author Peter Karich
  */
-public class ChangeGraphResourceIT {
+public class ChangeGraphResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java b/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java
new file mode 100644
index 0000000000..8a05ff25b3
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/resources/GpxTravelTimeConsistencyTest.java
@@ -0,0 +1,78 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http.resources;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GraphHopper;
+import com.graphhopper.PathWrapper;
+import com.graphhopper.reader.osm.GraphHopperOSM;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.util.gpx.GPXEntry;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.gpx.GpxFromInstructions;
+import com.graphhopper.util.shapes.GHPoint;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public class GpxTravelTimeConsistencyTest {
+
+    public static final String DIR = "../core/files";
+    private static final String graphFileFoot = "target/gpxtraveltimeconsistency-it";
+    private static final String osmFile = DIR + "/monaco.osm.gz";
+    private static final String importVehicles = "foot";
+    private static GraphHopper hopper;
+
+    @BeforeClass
+    public static void beforeClass() {
+        Helper.removeDir(new File(graphFileFoot));
+        hopper = new GraphHopperOSM().
+                setOSMFile(osmFile).
+                setStoreOnFlush(true).
+                setCHEnabled(false).
+                setGraphHopperLocation(graphFileFoot).
+                setEncodingManager(EncodingManager.create(importVehicles)).
+                importOrLoad();
+    }
+
+    @Test
+    public void testGPXListTravelTimeConsistency() {
+        GHPoint routeStart = new GHPoint(43.727687, 7.418737);
+        GHPoint routeEnd = new GHPoint(43.74958, 7.436566);
+        GHRequest request = new GHRequest(routeStart, routeEnd);
+        request.setWeighting("fastest");
+        request.setVehicle("foot");
+        PathWrapper path = hopper.route(request).getBest();
+        List<GPXEntry> gpxList = GpxFromInstructions.createGPXList(path.getInstructions());
+        for(GPXEntry entry : gpxList) {
+            if (entry.getTime() != null ) {
+                GHRequest requestForWaypoint = new GHRequest(routeStart, entry.getPoint());
+                requestForWaypoint.setWeighting("fastest");
+                requestForWaypoint.setVehicle("foot");
+                PathWrapper partialPath = hopper.route(requestForWaypoint).getBest();
+                assertEquals("GPXListEntry timeStamp is expected to be the same as route duration.", partialPath.getTime(), entry.getTime().longValue());
+            }
+        }
+    }
+
+}
diff --git a/web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java
similarity index 98%
rename from web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java
index c1182e26bb..60387208a4 100644
--- a/web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java
@@ -15,7 +15,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-public class I18nResourceIT {
+public class I18nResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/MvtResourceTest.java b/web/src/test/java/com/graphhopper/http/resources/MvtResourceTest.java
new file mode 100644
index 0000000000..eeda7b4183
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/resources/MvtResourceTest.java
@@ -0,0 +1,116 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http.resources;
+
+import com.graphhopper.http.GraphHopperApplication;
+import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import com.wdtinc.mapbox_vector_tile.adapt.jts.MvtReader;
+import com.wdtinc.mapbox_vector_tile.adapt.jts.TagKeyValueMapConverter;
+import com.wdtinc.mapbox_vector_tile.adapt.jts.model.JtsLayer;
+import com.wdtinc.mapbox_vector_tile.adapt.jts.model.JtsMvt;
+import io.dropwizard.testing.junit.DropwizardAppRule;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.locationtech.jts.geom.Geometry;
+import org.locationtech.jts.geom.GeometryFactory;
+import org.locationtech.jts.geom.MultiLineString;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertEquals;
+
+/**
+ * @author Peter Karich
+ */
+public class MvtResourceTest {
+    private static final String DIR = "./target/andorra-gh/";
+
+    private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
+
+    static {
+        config.getGraphHopperConfiguration().merge(new CmdArgs().
+                put("graph.flag_encoders", "car").
+                put("graph.encoded_values", "road_class,road_environment,max_speed,surface").
+                put("prepare.ch.weightings", "no").
+                put("prepare.min_network_size", "0").
+                put("prepare.min_one_way_network_size", "0").
+                put("datareader.file", "../core/files/andorra.osm.pbf").
+                put("graph.location", DIR));
+    }
+
+    @ClassRule
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule<>(GraphHopperApplication.class, config);
+
+    @BeforeClass
+    @AfterClass
+    public static void cleanUp() {
+        Helper.removeDir(new File(DIR));
+    }
+
+    @Test
+    public void testBasicMvtQuery() throws IOException {
+        final Response response = app.client().target("http://localhost:8080/mvt/15/16528/12099.mvt").request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        InputStream is = response.readEntity(InputStream.class);
+        JtsMvt result = MvtReader.loadMvt(is, new GeometryFactory(), new TagKeyValueMapConverter());
+        final Map<String, JtsLayer> layerValues = result.getLayersByName();
+        assertEquals(1, layerValues.size());
+        assertTrue(layerValues.containsKey("roads"));
+        JtsLayer layer = layerValues.values().iterator().next();
+        MultiLineString multiLineString = (MultiLineString) layer.getGeometries().iterator().next();
+        assertEquals(42, multiLineString.getCoordinates().length);
+        Map map = (Map) multiLineString.getUserData();
+        assertEquals("Camì de les Pardines", map.get("name"));
+    }
+
+    @Test
+    public void testWithDetailsInResponse() throws IOException {
+        final Response response = app.client().target("http://localhost:8080/mvt/15/16522/12102.mvt?details=max_speed&details=road_class&details=road_environment").request().buildGet().invoke();
+        assertEquals(200, response.getStatus());
+        InputStream is = response.readEntity(InputStream.class);
+        JtsMvt result = MvtReader.loadMvt(is, new GeometryFactory(), new TagKeyValueMapConverter());
+        final Map<String, JtsLayer> layerValues = result.getLayersByName();
+        JtsLayer layer = layerValues.values().iterator().next();
+        List layerGeoList = (List) layer.getGeometries();
+        Geometry geometry = (Geometry) layerGeoList.get(0);
+        assertEquals(19, geometry.getCoordinates().length);
+        assertEquals(21, layerGeoList.size());
+
+        Map map = (Map) ((Geometry) layerGeoList.get(0)).getUserData();
+        assertTrue(Double.isInfinite((Double) map.get("max_speed")));
+        assertEquals("residential", map.get("road_class"));
+
+        map = (Map) ((Geometry) layerGeoList.get(1)).getUserData();
+        assertEquals(50, (Double) map.get("max_speed"), .1);
+        assertEquals("secondary", map.get("road_class"));
+        assertEquals("road", map.get("road_environment"));
+
+        map = (Map) ((Geometry) layerGeoList.get(12)).getUserData();
+        assertEquals("bridge", map.get("road_environment"));
+    }
+}
diff --git a/web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
similarity index 98%
rename from web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
index eb6aa7c260..f27ecb63c3 100644
--- a/web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
@@ -36,7 +36,7 @@
 /**
  * @author svantulden
  */
-public class NearestResourceIT {
+public class NearestResourceTest {
     private static final String dir = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java b/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java
rename to web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
index 42d45ea2d8..eb016196a2 100644
--- a/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
@@ -37,7 +37,7 @@
 /**
  * @author svantulden
  */
-public class NearestResourceWithEleIT {
+public class NearestResourceWithEleTest {
     private static final String dir = "./target/monaco-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceIssue1574Test.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceIssue1574Test.java
new file mode 100644
index 0000000000..828733d97f
--- /dev/null
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceIssue1574Test.java
@@ -0,0 +1,74 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.http.resources;
+
+import com.fasterxml.jackson.databind.JsonNode;
+import com.graphhopper.http.GraphHopperApplication;
+import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.util.CmdArgs;
+import com.graphhopper.util.Helper;
+import io.dropwizard.testing.junit.DropwizardAppRule;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+import javax.ws.rs.core.Response;
+import java.io.File;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+/**
+ * @author Peter Karich
+ */
+public class RouteResourceIssue1574Test {
+    private static final String DIR = "./target/andorra-1574-gh/";
+
+    private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
+
+    static {
+        // this is the reason we put this test into an extra file: we can only reproduce the bug of issue 1574 by increasing the one-way-network size
+        config.getGraphHopperConfiguration().merge(new CmdArgs().
+                put("graph.flag_encoders", "car").
+                put("prepare.ch.weightings", "fastest").
+                put("prepare.min_network_size", "0").
+                put("prepare.min_one_way_network_size", "12").
+                put("datareader.file", "../core/files/andorra.osm.pbf").
+                put("graph.location", DIR));
+    }
+
+    @ClassRule
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule<>(GraphHopperApplication.class, config);
+
+    @BeforeClass
+    @AfterClass
+    public static void cleanUp() {
+        Helper.removeDir(new File(DIR));
+    }
+
+    @Test
+    public void testStallOnDemandBug_issue1574() {
+        final Response response = app.client().target("http://localhost:8080/route?point=42.486984,1.493152&point=42.481863,1.491297&point=42.49697,1.501265&&vehicle=car&weighting=fastest&stall_on_demand=true").request().buildGet().invoke();
+        JsonNode json = response.readEntity(JsonNode.class);
+        assertFalse("there should be no error, but: " + json.get("message"), json.has("message"));
+        System.out.println(json);
+        assertEquals(200, response.getStatus());
+    }
+
+}
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
similarity index 80%
rename from web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
index a4c96bf258..f87f415386 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
@@ -25,13 +25,18 @@
 import com.graphhopper.api.GraphHopperWeb;
 import com.graphhopper.http.GraphHopperApplication;
 import com.graphhopper.http.GraphHopperServerConfiguration;
+import com.graphhopper.routing.profiles.RoadClass;
+import com.graphhopper.routing.profiles.RoadEnvironment;
+import com.graphhopper.routing.profiles.Surface;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
+import com.graphhopper.util.InstructionList;
 import com.graphhopper.util.details.PathDetail;
 import com.graphhopper.util.exceptions.PointOutOfBoundsException;
 import com.graphhopper.util.shapes.GHPoint;
 import io.dropwizard.testing.junit.DropwizardAppRule;
 import org.junit.AfterClass;
+import org.junit.BeforeClass;
 import org.junit.ClassRule;
 import org.junit.Test;
 
@@ -46,7 +51,7 @@
 /**
  * @author Peter Karich
  */
-public class RouteResourceIT {
+public class RouteResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
@@ -55,16 +60,18 @@
         config.getGraphHopperConfiguration().merge(new CmdArgs().
                 put("graph.flag_encoders", "car").
                 put("prepare.ch.weightings", "fastest").
+                put("routing.ch.disabling_allowed", "true").
                 put("prepare.min_network_size", "0").
                 put("prepare.min_one_way_network_size", "0").
                 put("datareader.file", "../core/files/andorra.osm.pbf").
+                put("graph.encoded_values", "road_class,surface,road_environment,max_speed").
                 put("graph.location", DIR));
     }
 
     @ClassRule
-    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule(
-            GraphHopperApplication.class, config);
+    public static final DropwizardAppRule<GraphHopperServerConfiguration> app = new DropwizardAppRule<>(GraphHopperApplication.class, config);
 
+    @BeforeClass
     @AfterClass
     public static void cleanUp() {
         Helper.removeDir(new File(DIR));
@@ -92,7 +99,7 @@ public void testWrongPointFormat() {
     }
 
     @Test
-    public void testQueryWithDirections() throws Exception {
+    public void testQueryWithDirections() {
         // Note, in general specifying directions does not work with CH, but this is an example where it works
         final Response response = app.client().target("http://localhost:8080/route?" + "point=42.496696,1.499323&point=42.497257,1.501501&heading=240&heading=240&ch.force_heading=true").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
@@ -106,7 +113,7 @@ public void testQueryWithDirections() throws Exception {
     }
 
     @Test
-    public void testQueryWithStraightVia() throws Exception {
+    public void testQueryWithStraightVia() {
         // Note, in general specifying pass_through does not work with CH, but this is an example where it works
         final Response response = app.client().target("http://localhost:8080/route?point=42.534133,1.581473&point=42.534781,1.582149&point=42.535042,1.582514&pass_through=true").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
@@ -120,7 +127,7 @@ public void testQueryWithStraightVia() throws Exception {
     }
 
     @Test
-    public void testJsonRounding() throws Exception {
+    public void testJsonRounding() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
@@ -129,7 +136,7 @@ public void testJsonRounding() throws Exception {
     }
 
     @Test
-    public void testFailIfElevationRequestedButNotIncluded() throws Exception {
+    public void testFailIfElevationRequestedButNotIncluded() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851234,1.536198&point=42.510071,1.548128&points_encoded=false&elevation=true").request().buildGet().invoke();
         assertEquals(400, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
@@ -138,7 +145,7 @@ public void testFailIfElevationRequestedButNotIncluded() throws Exception {
     }
 
     @Test
-    public void testGraphHopperWeb() throws Exception {
+    public void testGraphHopperWeb() {
         GraphHopperWeb hopper = new GraphHopperWeb();
         assertTrue(hopper.load("http://localhost:8080/route"));
         GHResponse rsp = hopper.route(new GHRequest(42.554851, 1.536198, 42.510071, 1.548128));
@@ -158,16 +165,33 @@ public void testGraphHopperWeb() throws Exception {
         assertTrue("distance wasn't correct:" + arsp.getDistance(), arsp.getDistance() > 20000);
         assertTrue("distance wasn't correct:" + arsp.getDistance(), arsp.getDistance() < 21000);
 
-        List<Map<String, Object>> instructions = arsp.getInstructions().createJson();
+        InstructionList instructions = arsp.getInstructions();
         assertEquals(26, instructions.size());
-        assertEquals("Continue onto la Callisa", instructions.get(0).get("text"));
-        assertEquals("At roundabout, take exit 2", instructions.get(4).get("text"));
-        assertEquals(true, instructions.get(4).get("exited"));
-        assertEquals(false, instructions.get(24).get("exited"));
+        assertEquals("Continue onto la Callisa", instructions.get(0).getTurnDescription(null));
+        assertEquals("At roundabout, take exit 2", instructions.get(4).getTurnDescription(null));
+        assertEquals(true, instructions.get(4).getExtraInfoJSON().get("exited"));
+        assertEquals(false, instructions.get(24).getExtraInfoJSON().get("exited"));
     }
 
     @Test
-    public void testPathDetails() throws Exception {
+    public void testPathDetailsRoadClass() {
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
+        assertTrue(hopper.load("http://localhost:8080/route"));
+        GHRequest request = new GHRequest(42.546757, 1.528645, 42.520573, 1.557999);
+        request.setPathDetails(Arrays.asList(RoadClass.KEY, Surface.KEY, RoadEnvironment.KEY, "average_speed"));
+        GHResponse rsp = hopper.route(request);
+        assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
+        assertEquals(4, rsp.getBest().getPathDetails().get(RoadClass.KEY).size());
+        assertEquals(RoadClass.PRIMARY.toString(), rsp.getBest().getPathDetails().get(RoadClass.KEY).get(3).getValue());
+
+        List<PathDetail> roadEnvList = rsp.getBest().getPathDetails().get(RoadEnvironment.KEY);
+        assertEquals(10, roadEnvList.size());
+        assertEquals(RoadEnvironment.ROAD.toString(), roadEnvList.get(0).getValue());
+        assertEquals(RoadEnvironment.TUNNEL.toString(), roadEnvList.get(6).getValue());
+    }
+
+    @Test
+    public void testPathDetails() {
         GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load("http://localhost:8080/route"));
         GHRequest request = new GHRequest(42.554851, 1.536198, 42.510071, 1.548128);
@@ -205,7 +229,7 @@ public void testPathDetails() throws Exception {
     }
 
     @Test
-    public void testPathDetailsSamePoint() throws Exception {
+    public void testPathDetailsSamePoint() {
         GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load("http://localhost:8080/route"));
         GHRequest request = new GHRequest(42.554851, 1.536198, 42.554851, 1.536198);
@@ -216,7 +240,7 @@ public void testPathDetailsSamePoint() throws Exception {
     }
 
     @Test
-    public void testPathDetailsNoConnection() throws Exception {
+    public void testPathDetailsNoConnection() {
         GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
         assertTrue(hopper.load("http://localhost:8080/route"));
         GHRequest request = new GHRequest(42.542078, 1.45586, 42.537841, 1.439981);
@@ -226,8 +250,8 @@ public void testPathDetailsNoConnection() throws Exception {
     }
 
     @Test
-    public void testPathDetailsWithoutGraphHopperWeb() throws Exception {
-        final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128&details=average_speed&details=edge_id").request().buildGet().invoke();
+    public void testPathDetailsWithoutGraphHopperWeb() {
+        final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128&details=average_speed&details=edge_id&details=max_speed").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
         JsonNode infoJson = json.get("info");
@@ -246,7 +270,11 @@ public void testPathDetailsWithoutGraphHopperWeb() throws Exception {
         int firstLink = edgeIds.get(0).get(2).asInt();
         int lastLink = edgeIds.get(edgeIds.size() - 1).get(2).asInt();
         assertEquals(880, firstLink);
-        assertEquals(1419, lastLink);
+        assertEquals(1421, lastLink);
+
+        JsonNode maxSpeed = details.get("max_speed");
+        assertEquals(-1, maxSpeed.get(0).get(2).asDouble(-1), .01);
+        assertEquals(50, maxSpeed.get(1).get(2).asDouble(-1), .01);
     }
 
     @Test
@@ -262,6 +290,37 @@ public void testInitInstructionsWithTurnDescription() {
         assertEquals("Carrer Antoni Fiter i Rossell", rsp.getBest().getInstructions().get(3).getName());
     }
 
+    @Test
+    public void testSnapPreventions() {
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
+        assertTrue(hopper.load("http://localhost:8080/route"));
+        GHRequest request = new GHRequest(42.511139, 1.53285, 42.508165, 1.532271);
+        GHResponse rsp = hopper.route(request);
+        assertFalse(rsp.getErrors().toString(), rsp.hasErrors());
+        assertEquals(490, rsp.getBest().getDistance(), 2);
+
+        request.setSnapPreventions(Arrays.asList("tunnel"));
+        rsp = hopper.route(request);
+        assertEquals(1081, rsp.getBest().getDistance(), 2);
+    }
+
+    @Test
+    public void testSnapPreventionsAndPointHints() {
+        GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
+        assertTrue(hopper.load("http://localhost:8080/route"));
+        GHRequest request = new GHRequest(42.511139, 1.53285, 42.508165, 1.532271);
+        request.setSnapPreventions(Arrays.asList("tunnel"));
+        request.setPointHints(Arrays.asList("Avinguda Fiter i Rossell", ""));
+        GHResponse rsp = hopper.route(request);
+        assertEquals(1590, rsp.getBest().getDistance(), 2);
+
+        // contradicting hints should still allow routing
+        request.setSnapPreventions(Arrays.asList("tunnel"));
+        request.setPointHints(Arrays.asList("Tunèl del Pont Pla", ""));
+        rsp = hopper.route(request);
+        assertEquals(490, rsp.getBest().getDistance(), 2);
+    }
+
     @Test
     public void testGraphHopperWebRealExceptions() {
         GraphHopperAPI hopper = new com.graphhopper.api.GraphHopperWeb();
@@ -311,7 +370,7 @@ public void testGPX() {
     }
 
     @Test
-    public void testGPXWithExcludedRouteSelection() throws Exception {
+    public void testGPXWithExcludedRouteSelection() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128&type=gpx&gpx.route=false&gpx.waypoints=false").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         String str = response.readEntity(String.class);
@@ -321,7 +380,7 @@ public void testGPXWithExcludedRouteSelection() throws Exception {
     }
 
     @Test
-    public void testGPXWithTrackAndWaypointsSelection() throws Exception {
+    public void testGPXWithTrackAndWaypointsSelection() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128&type=gpx&gpx.track=true&gpx.route=false&gpx.waypoints=true").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         String str = response.readEntity(String.class);
@@ -342,7 +401,7 @@ public void testGPXWithError() {
     }
 
     @Test
-    public void testWithError() throws Exception {
+    public void testWithError() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198").request().buildGet().invoke();
         assertEquals(400, response.getStatus());
     }
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java
rename to web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
index 4c3165e774..cb13a5c894 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
@@ -36,7 +36,7 @@
 /**
  * @author Peter Karich
  */
-public class RouteResourceWithEleIT {
+public class RouteResourceWithEleTest {
     private static final String dir = "./target/monaco-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
