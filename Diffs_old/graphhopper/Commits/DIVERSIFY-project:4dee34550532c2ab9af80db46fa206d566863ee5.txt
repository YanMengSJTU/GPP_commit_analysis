diff --git a/Tasks_Amal.txt b/Tasks_Amal.txt
index 52ef608680..f43ba9c761 100644
--- a/Tasks_Amal.txt
+++ b/Tasks_Amal.txt
@@ -7,51 +7,103 @@ Graphhopper web
 3. On the client side, the URL query is amended to include weighting (its value is taken from the value selected by the user), and vehicle, which is read from config.properties.
 4. On the client side, If the user entered the query directly from the URL, e.g. (http://localhost:9000/?point=Tallaght&point=Blackrock&vehicle=car&weighting=shortest&locale=en-US), the params values from the query are propagated to corresponding DOM elements!
 5. Routing is done if the user selects 'shortest' by calling relevant encoder (only fastest was implemented)
+6. write a program in java that populates all Dublin Edges with random noise values (from 0-80) for testing purposes (Done! please refer to point
+    8 for imp. required changes in the Python code)
 
-
-TODO:
-----
-1. Graphhopper: Building noise encoder that accesses noise readings from redis and returns the path with min total noise.
+7. Graphhopper: Building noise encoder that accesses noise readings from redis and returns the path with min total noise.
    -> Actually NoiseWeighting, not encoder. Encoder is per Vechile, e.g. CarFlagEncoder, BikeFlagEnclder...etc, and is only used when
       calculating the 'fastest' route (weighting is set to 'fastest') because the minimization of time will depond on the speed of every
       vechile. For shortest and LeastNoisy, only distance matters!
-   -> Check Chweighting which is called by other algorithms to see of NoiseWeightig needs to be incorporated by anyway
+   -> NoiseWeighting has been implemented that implements 'Weighting' and is linked to 'least-noisy' weighting (passed from the web page) 
+
+8. IMPORTANT NOTES: Graphhopper generates a graph from the OSM map (a set of bytecode files;e.g. edges, nodes, names...etc.). During the generation process, it makes many 
+   simplification (merging/removing edges nodes), and more importantly, changing the ids of the edges. They dont keep any link belween the concrete edgeID 
+   (OSM edgeID) and internal graph edgeID (as far as I have looked). The only meaningful information we can get from the graph is the 'name' of the graph edge.
+   Please note that Graph edgeID maps to many OSM edgeIDs, however this relationship is not maintained. Therfore, there is no way to retrieve noise readings
+   from Redis by OSM edgeID. What I have done in '6' is that I got the 'edgeName' from graphhopper, which is a concatenation between 'name' tag and 'ref' tag
+   in every way; e.g.'Butt Bridge, R802', 'Cardiffsbridge Road, R103', 'Cardiffsbridge Road, R108'. You can notice here that the 'name' is not unique, however,
+   the combination of 'name' and 'ref' is unique on the graph level, but not on the OSM level
+  
+   Therefore, to be able to retrieve noise readings, keys should be formatted as follows: city_readingType_edgeName[_ref]. 
+   The reason why we need 'city' and 'readingType' is described below. 'name' and 'ref' are not unique for GH (however they are unique to the internal graph
+   representation by eliminating street number -if exists-), when parsing the OSM map to get the values of 'name' and 'ref' of a specific 'edgeID', and if
+   this key combination exists in Redis, an average of the stored reading and the new noise reading maybe calculated (that's how I implmeneted it in 6). In 6
+   I first used Osmosis to filter Dublin map to show only Ways, then I started parsing the xml file (to improve the performance). In the OSM map, each way
+   should have a 'name', but may not have a 'ref'. so, 'ref' is optional, and a key without a ref should be like: city_readingType_edgeName 
+   
+   city_readingType is required in Redis keys because Redis doesn't have a way to rename DBs, and by default everything is stored/retrieved from db0, so
+   there should be a way to distinguish which city each key belongs to, and which noise readings it store. for example, we might have 
+   'dublin_noise_Abbey Street', 'dublin_air_Abbey Street', 'paris_noise_Abbey Street' (street names are not unique from city to another), so there should be
+   a way to ditinguish between them. Having said that, Python code needs to be changed as described in point '1' in TODO list below.     
+    
 
-2. Required changes in Python code: There is no way in Redis to change the database name, so that it can carry the city name and the type
-  of readings to be able to connect to the appropriate database during routing to capture relevant sensor readings. Here we assume that 
-  every city+sensor reading type is stored in a separate database. Another solution is to store everything in the same database, 
-  but the keys of the hashes should carry the type of the reading; i.e. city_type_edge (from the config file).
 
-3. write a program in java that populates all Dublin Edges with random noise values (from 0-80) for testing purposes
 
+TODO:
+----
+
+1. Required changes in Python code: 
+   There is no way in Redis to change the database name, so that it can carry the city name and the type
+  of readings to be able to connect to the appropriate database during routing to capture relevant sensor readings. Here we assume that 
+  every city+sensor reading type is stored in a separate database. Another solution is to store everything in the same database, 
+  but the keys of the hashes should carry the type of the reading; i.e. city_readingType_edgeName_[ref] (check point 8 above). city is coming from the name 
+  of the map (first token; e.g. dublin-m50.osm), readingType is coming from the city config file (type field). We should standardize the name of the readings
+  for all cities; e.g. noise, air...etc., which is important during routing. These are the steps I followed when I implemented 6: 
+
+  a. Filter the relevant map to generate another dump map with only 'Ways'; e.g. 'dublin-ways.osm'
+  b. Do the Python magic (Vivek's magic:)) to retrieve affected edges given a propagation value...etc.
+  c. for each edgeId from 'b', retrieve corresponsing 'name' and 'ref' (if exists) from 'dublin-ways.osm', and build the Redis key as 
+     city_readingType_edgeName[_ref] ([_ref] is optional). When parsing a new sensor file, all old readings in redis should be overwritten. But the point 
+     here is that in the same sensor file, there might be the case that two or more different OSM edgeIds, having the same edgeName[_ref].   
+     So, we need to decide whether to overwrite or get their average. In 6, I calculated their average. 
+  d. The name of the fields inside each hash should be 'type' and 'timestap'. for example, 'noise' and 'timestamp'. This is important in routing. 
+  e. We might still need to keep track of OSM edgeIds (dont know why, but we would need it:)), so, in addition to 'noise' and 'timestamp', we might have a set,
+     for example named as 'edgeIds' storing the edges of this key.
+
+  f. PROBLEM WITH REDIS: During routing, the routing algorithm calls the relevant Weighting (e.g. LeastNoisyWeighting) for each edge it's examining to minimize the desired weighting.
+     for example, if 'Weighting = fastest', the algorithm minimizes the time, if if 'Weighting = fastest', the algorithm minimizes the distance. Now, if
+     'Weighting = least-noisy', the algorithm minimizes the the noise-readings. The algorithim calls for noise readings hunderads of time, after sometime, 
+      Redis rejects the connection and raises 'JedisConnectionException: java.net.SocketException: Connection reset'. It's important for this problem to
+      be solved in order to get real results! For now, I am returing an average value of 30 if the noise-reading doesnt exist for this street, 
+      or the connection with Reids is rejected!
+  g. ANOTHER PROBLEM we can live it for now, 'least-noisy' calculation is slower than 'fastest' and 'shortest', because we rely on Redis. An alternative,
+     to the Redis solution is that We might consider *again* amending the OSM map with new tags and retrieving them from the graph 
+     (have no idea how they manipulate bytecode!).
+
+ 
+2. If Bike or Foot is specificed in 'acceptWay' in config file, the user to be provided the option to specify 'Elevation' Yes or NO
+   -> elevation is equals false by default
 
-4. instructions should also include noise readings on different segments when least-noise weighting is selected
+3. Instruction list should also include noise readings on different segments when least-noise weighting is selected, which are displayed with the reading
+   timestamp.
 
 
-5. When routing based on the noise readings, shall we take distance into consideration, the algorithm might return a very long route
+4. When routing based on the noise readings, shall we take distance into consideration, the algorithm might return a very long route
    just because it's the least noisy. A solution could be to have two weighting: 'least_noisy' that takes distance into account, and
-   abolute-least-noisy' that just cares about noise.
+   abolute-least-noisy' that just cares about noise--To BE DISCUSSED
 
-6. Investigate with heatmap on the visualization of noise readings on the map! would be cool
+5. If more than one vechile is specified in "osmreader.acceptway" in config.properties, the aplication raises an exception when it runs; i.e "Multiple encoders are active, can't return one". currently, only one vechile type is accepted; car,foot,bike,mtb,racingbike.
+   -> This exception is actually coming from EncodingManger when encodingManager.getSingle() is called inside route() inside graphhopper
+   -> Also check getVehicleCount() inside encodingManager()
+   -> Maybe this could be solved by defining another method similar to getSingle() that returns multiple FlagEncoder corresponding to
+      the values specified in osmreader.acceptWay
 
-7. If Bike or Foot is specificed in 'acceptWay' in config file, the user to be provided the option to specify 'Elevation' Yes or NO
-   -> elevation is equals false by default
+------------------------------------------------------------------------------------------------------------------------------
+Miscellaneous
+-------------
 
 
-8. Generate an Andriod app out of the Netbeans project
+6. Investigate with heatmap on the visualization of noise readings on the map! would be cool:)
 
 
-9. in LeastNoisyWeighting, check what calls getMinWeight() method, and what it's needed for 
+7. Generate an Andriod app out of the Netbeans project
 
 
-10. If more than one vechile is specified in "osmreader.acceptway" in config.properties, the aplication raises an exception when it runs; i.e "Multiple encoders are active, can't return one". currently, only one vechile type is accepted; car,foot,bike,mtb,racingbike.
-   -> This exception is actually coming from EncodingManger when encodingManager.getSingle() is called inside route() inside graphhopper
-   -> Also check getVehicleCount() inside encodingManager()
-   -> Maybe this could be solved by defining another method similar to getSingle() that returns multiple FlagEncoder corresponding to
-      the values specified in osmreader.acceptWay
+8. in LeastNoisyWeighting, check what calls getMinWeight() method, and what it's needed for 
 
 
-11. check wehen running from netbeans, what is the root dir? cant find file, and cant read sensor data!
+9. Graphhopper noise routing: Check Chweighting which is called by other algorithms to see if NoiseWeightig needs to be incorporated by anyway, probably
+   this is also related to 8.
 
 
 
diff --git a/core/src/main/java/com/graphhopper/routing/util/LeastNoisyWeighting.java b/core/src/main/java/com/graphhopper/routing/util/LeastNoisyWeighting.java
index 62579deb82..86ca6cfc8e 100644
--- a/core/src/main/java/com/graphhopper/routing/util/LeastNoisyWeighting.java
+++ b/core/src/main/java/com/graphhopper/routing/util/LeastNoisyWeighting.java
@@ -18,14 +18,6 @@
 import com.graphhopper.util.EdgeIteratorState;
 import java.util.Random;
 
-import java.io.IOException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.List;
-import java.util.*;
-
 import redis.clients.jedis.BinaryJedis;
 import redis.clients.jedis.Jedis;
 import redis.clients.jedis.Protocol;
@@ -46,7 +38,6 @@
     public LeastNoisyWeighting()
     {
         System.out.println("LeastNoiseWeighting instantiated!");
-
     }
 
     @Override
@@ -60,44 +51,64 @@ public double getMinWeight( double noiseValue )
     public double calcWeight( EdgeIteratorState edge, boolean reverse )
     {
         //Experimenting with returning a random radom between 0-80...Worked!
-        Random nw = new Random();
-        double returnedRandom = nw.nextInt(100);
+        /*Random nw = new Random();
+         double returnedRandom = nw.nextInt(100);
 
-        System.out.println("edge.getEdge() = " + edge.getEdge());
-        System.out.println("edge.getFlags() = " + edge.getFlags());
-        System.out.println("edge.getName() = " + edge.getName());
+         System.out.println("edge.getEdge() = " + edge.getEdge());
+         System.out.println("edge.getFlags() = " + edge.getFlags());
+         System.out.println("edge.getName() = " + edge.getName());
 
-        return returnedRandom;
+         return returnedRandom;*/
 
-        //double noiseValue = getNoiseFromRedis(edge);
-        //return noiseValue;
+        double noiseValue = getNoiseFromRedis(edge);
+        return noiseValue;
     }
 
     double getNoiseFromRedis( EdgeIteratorState edge ) throws JedisConnectionException, JedisDataException
     {
-        double noiseValue = 0;
+        double noiseValue = 30;
+        String ntime;
+        //TODO, get the city name from the graph
         String city = getCurrentCity();
-        //TODO: connect to redis
-        //The Python code to be extended to include the type of the readings with the key for each has
-        //i.e.edge_type (type is the reading type from the relevant config file)
-        //check if we can increment the time of the noise reading to instructions in the response??
 
+        //Matching keys is very very slow
         try
         {
 
             Jedis jedis = new Jedis("localhost");
-            String hashname = "dublin_ways_set";
-        //Map<String, String> decibles = jedis.hgetAll(hashname);
-            //System.out.println("Noise Entries = " + decibles);
-            Set<String> affectedEdges = jedis.smembers(hashname);
-        //System.out.println("dublin_ways_set = " + affectedEdges);
-
-            /*for(Map.Entry<String, String> value: decibles.entrySet())
+            String edgeName = edge.getName();
+            //Set<String> matchedEdges = new HashSet();
+
+            if (edgeName.length() > 0)
+            {
+
+                if (edgeName.contains(","))
+                    edgeName = edgeName.replace(", ", "_");
+
+                edgeName = "dublin_noise_" + edgeName;
+                
+                System.out.println("edgeName = " + edgeName);
+                
+                if (jedis.exists(edgeName))
+                {
+                    noiseValue = Double.parseDouble(jedis.hget(edgeName, "noise"));
+                    System.out.println("noiseValue = " + noiseValue);
+                    ntime = jedis.hget(edgeName, "timestamp");
+                }
+            }
+
+            /*if (edgeName.length() >0)
              {
-             String date = value.getKey();
-             String noise = value.getValue();
-             System.out.println("on " + date + ", noise was: " + noise);
+             matchedEdges = jedis.keys("dublin_noise_"+edgeName+"*");
              }*/
+            //could loop on all returned edges, and get the average of returned noise readings, however, it would make
+            //the process slower
+            //if(matchedEdges.size()>0)
+            //{
+            //Iterator iter = matchedEdges.iterator();
+            //String firstKey = (String)iter.next();
+            //}
+            //check what to do with time and how to amend the instruction list with noise readings and timestamp 
         } catch (JedisConnectionException e)
         {
             System.out.println("JedisConnectionException: " + e.getMessage());
diff --git a/core/src/main/java/com/graphhopper/routing/util/PopulateRedisRandomNoise.java b/core/src/main/java/com/graphhopper/routing/util/PopulateRedisRandomNoise.java
index 699c0ffbb2..4e12e211bd 100644
--- a/core/src/main/java/com/graphhopper/routing/util/PopulateRedisRandomNoise.java
+++ b/core/src/main/java/com/graphhopper/routing/util/PopulateRedisRandomNoise.java
@@ -17,8 +17,6 @@
 
 import java.util.Random;
 import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
 
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
@@ -45,7 +43,6 @@ public static void main( String[] strs ) throws Exception, JedisConnectionExcept
         SAXHandler handler = new SAXHandler();
         parser.parse("output.xml", handler);
         System.out.println("Number of ways = " + handler.waysIDs.size());
-        System.out.println("1st way = " + handler.waysIDs.get(0));
         try
         {
             Jedis jedis = new Jedis("localhost");
@@ -54,8 +51,8 @@ public static void main( String[] strs ) throws Exception, JedisConnectionExcept
             for (int i = 0; i < handler.waysIDs.size(); i++)
             {
                 String hashkey = handler.waysIDs.get(i);
-                System.out.println("hashkey = "+hashkey);
-                hashkey = "dublin-noise-" + hashkey;
+                //System.out.println("hashkey = "+hashkey);
+                hashkey = "dublin_noise_" + hashkey;
 
                 Random noiseValue = new Random();
                 double returnedNoise = noiseValue.nextInt(80);
@@ -63,8 +60,21 @@ public static void main( String[] strs ) throws Exception, JedisConnectionExcept
                 Random noiseTime = new Random();
                 double returnedTime = noiseTime.nextInt(23);
                 String ntime = String.valueOf(returnedTime) + "time";
-                jedis.hset(hashkey, "Noisetube_value", noise);
-                jedis.hset(hashkey, "Noisetube_timestamp", ntime);
+
+                if (!jedis.exists(hashkey))
+                {
+                    jedis.hset(hashkey, "noise", noise);
+
+                } else
+                {
+                    String currentNoise = jedis.hget(hashkey, "noise");
+                    returnedNoise = (returnedNoise + Double.parseDouble(currentNoise)) / 2;
+                    noise = String.valueOf(returnedNoise);
+                    jedis.hset(hashkey, "noise", noise);
+                }
+
+                jedis.hset(hashkey, "timestamp", ntime);
+
             }
 
         } catch (JedisConnectionException e)
@@ -86,7 +96,10 @@ public static void main( String[] strs ) throws Exception, JedisConnectionExcept
 class SAXHandler extends DefaultHandler
 {
     ArrayList<String> waysIDs = new ArrayList<String>();
-    String wayId, wayName, wayRef;
+    String wayId ="";
+    String wayName="";
+    String wayRef="";
+    int refFlag = 0;
 
     public SAXHandler()
     {
@@ -100,38 +113,47 @@ public void startElement( String uri, String localName, String qName, Attributes
         if (qName.equalsIgnoreCase("way"))
         {
             wayId = attributes.getValue("id");
-            System.out.println("WayID = " + wayId);
-        }
-        else if (qName.equalsIgnoreCase("tag"))
+        } else if (qName.equalsIgnoreCase("tag"))
         {
             if (attributes.getValue("k").equalsIgnoreCase("name"))
             {
                 wayName = attributes.getValue("v");
-                System.out.println("wayName = " + wayName);
-            }
-            else if(attributes.getValue("k").equalsIgnoreCase("ref"))
+                
+            } else if (attributes.getValue("k").equalsIgnoreCase("ref"))
             {
                 wayRef = attributes.getValue("v");
-                System.out.println("wayRef = " + wayRef);
+                refFlag = 1;
             }
         }
-       
+
     }
-    
+
     @Override
-    public void endElement(String uri, String localName, String qName) throws SAXException 
+    public void endElement( String uri, String localName, String qName ) throws SAXException
     {
+        //exclude wayid and could be added (TODO) it as a set inside the hash; e.g. key: dublin_noise_Parnell_R111, fields:(noise, timestamp, wayIDs:Set)
+
         if (qName.equalsIgnoreCase("way"))
         {
-           if(wayId!=null && wayName!=null && wayRef!=null)
-           {
-               waysIDs.add(wayName+"-"+wayRef+"-"+wayId);
-           }
+            if (wayName.length()>0)
+            {
+                String firstToken = wayName.split(" ")[0];
+
+                if (firstToken.matches(".*\\d.*"))
+                {
+                    if (wayName.length() > firstToken.length())
+                        wayName = wayName.substring(firstToken.length() + 1);
+                }
+
+                if (refFlag == 1)
+                    waysIDs.add(wayName + "_" + wayRef);
+                else
+                    waysIDs.add(wayName);
+            }
+            refFlag = 0;
             
         }
-        
+
     }
 
 }
-
-
diff --git a/core/src/main/java/com/graphhopper/routing/util/SmallTests.java b/core/src/main/java/com/graphhopper/routing/util/SmallTests.java
new file mode 100644
index 0000000000..0e31bde91b
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/util/SmallTests.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2014 elgammaa.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.graphhopper.routing.util;
+
+import java.util.*;
+
+/**
+ *
+ * @author elgammaa
+ */
+public class SmallTests
+{
+    public static void main( String[] strs ) throws Exception
+    {
+        String str = "Dublin Blackrock Scout Group";
+        System.out.println("str equals: " + str);
+
+        String firstToken = str.split(" ")[0];
+
+        if (firstToken.matches(".*\\d.*"))
+        {
+            System.out.println(firstToken + " :has a number");
+            str = str.substring(firstToken.length() + 1);
+
+            System.out.println("*str now equals:*" + str);
+
+        } else
+            System.out.println(str + " :DOESNT a number");
+
+    }
+
+}
