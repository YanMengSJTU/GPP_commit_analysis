diff --git a/core/src/main/java/com/graphhopper/Trip.java b/core/src/main/java/com/graphhopper/Trip.java
index bc891342aa..25611620ac 100644
--- a/core/src/main/java/com/graphhopper/Trip.java
+++ b/core/src/main/java/com/graphhopper/Trip.java
@@ -38,14 +38,23 @@ public double getDistance() {
         public final Point geometry;
 
         public final Date arrivalTime;
+        public final Date plannedArrivalTime;
+        public final Date predictedArrivalTime;
+
         public final Date departureTime;
+        public final Date plannedDepartureTime;
+        public final Date predictedDepartureTime;
 
-        public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date departureTime) {
+        public Stop(String stop_id, String name, Point geometry, Date arrivalTime, Date plannedArrivalTime, Date predictedArrivalTime, Date departureTime, Date plannedDepartureTime, Date predictedDepartureTime) {
             this.stop_id = stop_id;
             this.stop_name = name;
             this.geometry = geometry;
             this.arrivalTime = arrivalTime;
+            this.plannedArrivalTime = plannedArrivalTime;
+            this.predictedArrivalTime = predictedArrivalTime;
             this.departureTime = departureTime;
+            this.plannedDepartureTime = plannedDepartureTime;
+            this.predictedDepartureTime = predictedDepartureTime;
         }
 
         @Override
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index a68cd1d6ac..85b331fca5 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -89,6 +89,10 @@ public static RealtimeFeed fromProtobuf(Graph graph, GtfsStorage staticGtfs, PtF
             .forEach(tripUpdate -> {
                 final int[] boardEdges = staticGtfs.getBoardEdgesForTrip().get(tripUpdate.getTrip());
                 final int[] leaveEdges = staticGtfs.getAlightEdgesForTrip().get(tripUpdate.getTrip());
+                if (boardEdges == null || leaveEdges == null) {
+                    logger.warn("Trip not found: {}", tripUpdate.getTrip());
+                    return;
+                }
                 tripUpdate.getStopTimeUpdateList().stream()
                         .filter(stopTimeUpdate -> stopTimeUpdate.getScheduleRelationship() == SKIPPED)
                         .mapToInt(stu -> stu.getStopSequence()-1) // stop sequence number is 1-based, not 0-based
@@ -336,6 +340,7 @@ boolean isBlocked(int edgeId) {
                 logger.trace("stop_sequence {} scheduled departure {} updated departure {}", i, previousOriginalStopTime.departure_time, updatedPreviousStopTime.departure_time);
                 time = updatedPreviousStopTime.departure_time;
                 stopTimes.add(updatedPreviousStopTime);
+                logger.trace("Number of stop times: {}", stopTimes.size());
             }
 
             final StopTime originalStopTime = feed.stop_times.get(new Fun.Tuple2(tripUpdate.getTrip().getTripId(), stopTimeUpdate.getStopSequence()));
@@ -357,6 +362,7 @@ boolean isBlocked(int edgeId) {
                 logger.trace("stop_sequence {} scheduled departure {} updated departure {}", stopTimeUpdate.getStopSequence(), originalStopTime.departure_time, updatedStopTime.departure_time);
                 time = updatedStopTime.departure_time;
                 stopTimes.add(updatedStopTime);
+                logger.trace("Number of stop times: {}", stopTimes.size());
             } else if (stopTimeUpdate.getScheduleRelationship() == NO_DATA) {
             } else if (tripUpdate.getTrip().getScheduleRelationship() == GtfsRealtime.TripDescriptor.ScheduleRelationship.ADDED) {
                 final StopTime stopTime = new StopTime();
@@ -367,12 +373,13 @@ boolean isBlocked(int edgeId) {
                 stopTime.arrival_time = (int) Duration.between(arrival_time.truncatedTo(ChronoUnit.DAYS), arrival_time).getSeconds();
                 final ZonedDateTime departure_time = Instant.ofEpochSecond(stopTimeUpdate.getArrival().getTime()).atZone(ZoneId.of(agency.agency_timezone));
                 stopTime.departure_time = (int) Duration.between(departure_time.truncatedTo(ChronoUnit.DAYS), departure_time).getSeconds();
-                System.out.println(delay);
                 stopTimes.add(stopTime);
+                logger.trace("Number of stop times: {}", stopTimes.size());
             } else {
                 throw new RuntimeException();
             }
         }
+        logger.trace("Number of stop times: {}", stopTimes.size());
         BitSet validOnDay = new BitSet(); // Not valid on any day. Just a template.
         return new GtfsReader.TripWithStopTimes(trip, stopTimes, validOnDay);
     }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index 9afc2f8030..baa450d90c 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -42,6 +42,7 @@
 import java.util.*;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
 
 import static com.graphhopper.reader.gtfs.Label.reverseEdges;
 import static java.time.temporal.ChronoUnit.SECONDS;
@@ -195,7 +196,7 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
         private final List<Trip.Stop> stops = new ArrayList<>();
         private final GTFSFeed gtfsFeed;
         private Instant arrivalTimeFromHopEdge;
-        private Instant updatedArrival;
+        private Optional<Instant> updatedArrival;
         private StopTime stopTime = null;
         private final GtfsReader.TripWithStopTimes tripUpdate;
 
@@ -203,6 +204,9 @@ private InstructionList getInstructions(Translation tr, List<Trip.Leg> legs) {
             this.tripDescriptor = tripDescriptor;
             this.gtfsFeed = gtfsStorage.getGtfsFeeds().get(feedId);
             this.tripUpdate = realtimeFeed.getTripUpdate(tripDescriptor).orElse(null);
+            if (this.tripUpdate != null) {
+                validateTripUpdate(this.tripUpdate);
+            }
         }
 
         void next(Label.Transition t) {
@@ -211,23 +215,23 @@ void next(Label.Transition t) {
                     int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
                     stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
                     Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
-                    Instant updatedDeparture = plannedDeparture.plus(getDepartureDelay(stopSequence), SECONDS);
+                    Optional<Instant> updatedDeparture = getDepartureDelay(stopSequence).map(delay -> plannedDeparture.plus(delay, SECONDS));
                     Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, Date.from(updatedDeparture)));
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), null, null, null, updatedDeparture.map(Date::from).orElse(Date.from(plannedDeparture)), Date.from(plannedDeparture), updatedDeparture.map(Date::from).orElse(null)));
                     break;
                 }
                 case HOP: {
                     int stopSequence = gtfsStorage.getStopSequences().get(t.edge.edgeIteratorState.getEdge());
                     stopTime = gtfsFeed.stop_times.get(new Fun.Tuple2<>(tripDescriptor.getTripId(), stopSequence));
                     arrivalTimeFromHopEdge = Instant.ofEpochMilli(t.label.currentTime);
-                    updatedArrival = arrivalTimeFromHopEdge.plus(getArrivalDelay(stopSequence), SECONDS);
+                    updatedArrival = getArrivalDelay(stopSequence).map(delay -> arrivalTimeFromHopEdge.plus(delay, SECONDS));
                     break;
                 }
                 case DWELL: {
                     Instant plannedDeparture = Instant.ofEpochMilli(t.label.currentTime);
-                    Instant updatedDeparture = plannedDeparture.plus(getDepartureDelay(stopTime.stop_sequence), SECONDS);
+                    Optional<Instant> updatedDeparture = getDepartureDelay(stopTime.stop_sequence).map(delay -> plannedDeparture.plus(delay, SECONDS));
                     Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(updatedArrival), Date.from(updatedDeparture)));
+                    stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), updatedArrival.map(Date::from).orElse(Date.from(arrivalTimeFromHopEdge)), Date.from(arrivalTimeFromHopEdge), updatedArrival.map(Date::from).orElse(null), updatedDeparture.map(Date::from).orElse(Date.from(plannedDeparture)), Date.from(plannedDeparture), updatedDeparture.map(Date::from).orElse(null)));
                     break;
                 }
                 default: {
@@ -236,34 +240,48 @@ void next(Label.Transition t) {
             }
         }
 
-        private long getArrivalDelay(int stopSequence) {
+        private Optional<Integer> getArrivalDelay(int stopSequence) {
             if (tripUpdate != null) {
-                int arrival_time = tripUpdate.stopTimes.get(stopSequence - 1).arrival_time;
+                int arrival_time = tripUpdate.stopTimes.stream().filter(st -> st.stop_sequence == stopSequence).findFirst().orElseThrow(() -> new RuntimeException("Stop time not found.")).arrival_time;
                 logger.trace("stop_sequence {} scheduled arrival {} updated arrival {}", stopSequence, stopTime.arrival_time, arrival_time);
-                return arrival_time - stopTime.arrival_time;
+                return Optional.of(arrival_time - stopTime.arrival_time);
             } else {
-                return 0;
+                return Optional.empty();
             }
         }
 
-        private int getDepartureDelay(int stopSequence) {
+        private Optional<Integer> getDepartureDelay(int stopSequence) {
             if (tripUpdate != null) {
-                int departure_time = tripUpdate.stopTimes.get(stopSequence - 1).departure_time;
+                int departure_time = tripUpdate.stopTimes.stream().filter(st -> st.stop_sequence == stopSequence).findFirst().orElseThrow(() -> new RuntimeException("Stop time not found.")).departure_time;
                 logger.trace("stop_sequence {} scheduled departure {} updated departure {}", stopSequence, stopTime.departure_time, departure_time);
-                return departure_time - stopTime.departure_time;
+                return Optional.of(departure_time - stopTime.departure_time);
             } else {
-                return 0;
+                return Optional.empty();
             }
         }
 
         void finish() {
             Stop stop = gtfsFeed.stops.get(stopTime.stop_id);
-            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), Date.from(updatedArrival), null));
+            stops.add(new Trip.Stop(stop.stop_id, stop.stop_name, geometryFactory.createPoint(new Coordinate(stop.stop_lon, stop.stop_lat)), updatedArrival.map(Date::from).orElse(Date.from(arrivalTimeFromHopEdge)), Date.from(arrivalTimeFromHopEdge), updatedArrival.map(Date::from).orElse(null), null, null, null));
             for (Trip.Stop tripStop : stops) {
                 logger.trace("{}", tripStop);
             }
         }
 
+        private void validateTripUpdate(GtfsReader.TripWithStopTimes tripUpdate) {
+            com.conveyal.gtfs.model.Trip originalTrip = gtfsFeed.trips.get(tripUpdate.trip.trip_id);
+            try {
+                Iterable<StopTime> interpolatedStopTimesForTrip = gtfsFeed.getInterpolatedStopTimesForTrip(tripUpdate.trip.trip_id);
+                long nStopTimes = StreamSupport.stream(interpolatedStopTimesForTrip.spliterator(), false).count();
+                logger.trace("Original stop times: {} Updated stop times: {}", nStopTimes, tripUpdate.stopTimes.size());
+                if (nStopTimes != tripUpdate.stopTimes.size()) {
+                    logger.error("Original stop times: {} Updated stop times: {}", nStopTimes, tripUpdate.stopTimes.size());
+                }
+            } catch (GTFSFeed.FirstAndLastStopsDoNotHaveTimes firstAndLastStopsDoNotHaveTimes) {
+                throw new RuntimeException(firstAndLastStopsDoNotHaveTimes);
+            }
+        }
+
     }
 
     // We are parsing a string of edges into a hierarchical trip.
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 4f47b7a04f..be8b1476a6 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -262,9 +262,11 @@ public void testZeroDelay() {
         GHResponse responseWithRealtimeUpdate = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, responseWithRealtimeUpdate.getAll().size());
 
-        PathWrapper responseWithRealtimeUpdateBest = responseWithRealtimeUpdate.getBest();
-        PathWrapper responseWithoutRealtimeUpdateBest = responseWithoutRealtimeUpdate.getBest();
-        assertEquals("My line run is 0 minutes late, doesn't matter.", time(0, 5), responseWithRealtimeUpdateBest.getTime(), 0.1);
+        Trip.PtLeg responseWithRealtimeUpdateBest = (Trip.PtLeg) responseWithRealtimeUpdate.getBest().getLegs().get(responseWithRealtimeUpdate.getBest().getLegs().size()-2);
+        Trip.PtLeg responseWithoutRealtimeUpdateBest = (Trip.PtLeg) responseWithoutRealtimeUpdate.getBest().getLegs().get(responseWithoutRealtimeUpdate.getBest().getLegs().size()-2);
+        assertEquals("My planned arrival time is correct.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), responseWithRealtimeUpdateBest.stops.get(responseWithRealtimeUpdateBest.stops.size()-1).plannedArrivalTime.toInstant());
+        assertEquals("My expected arrival time is the same.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), responseWithRealtimeUpdateBest.stops.get(responseWithRealtimeUpdateBest.stops.size()-1).predictedArrivalTime.toInstant());
+        assertEquals("The trip without realtime update does not have an expected arrival time.", null, responseWithoutRealtimeUpdateBest.stops.get(responseWithoutRealtimeUpdateBest.stops.size()-1).predictedArrivalTime);
 
 //        assertEquals(responseWithoutRealtimeUpdateBest.toString(), responseWithRealtimeUpdateBest.toString());
     }
@@ -341,7 +343,9 @@ public void testDelayFromBeginningWithoutTransfer() {
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build()).route(ghRequest);
         assertEquals(1, response.getAll().size());
 
-        assertEquals("My line run is 3 minutes late.", LocalDateTime.parse("2007-01-01T06:52:00").atZone(zoneId).toInstant(), response.getBest().getLegs().get(response.getBest().getLegs().size() - 1).getArrivalTime().toInstant());
+        Trip.PtLeg ptLeg = ((Trip.PtLeg) response.getBest().getLegs().get(response.getBest().getLegs().size() - 2));
+        assertEquals("My line run is 3 minutes late.", LocalDateTime.parse("2007-01-01T06:52:00").atZone(zoneId).toInstant(), ptLeg.getArrivalTime().toInstant());
+        assertEquals("It is still reporting its original, scheduled time.", LocalDateTime.parse("2007-01-01T06:49:00").atZone(zoneId).toInstant(), ptLeg.stops.get(ptLeg.stops.size()-1).plannedArrivalTime.toInstant());
     }
 
     @Test
