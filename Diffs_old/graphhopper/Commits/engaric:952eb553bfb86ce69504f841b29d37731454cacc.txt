diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index ae76e32ae9..32d05307a6 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -17,6 +17,7 @@
  */
 package com.graphhopper.routing;
 
+import com.graphhopper.routing.util.DefaultEdgeFilter;
 import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
@@ -34,6 +35,7 @@
  * <p/>
  * @author Peter Karich
  * @author Ottavio Campana
+ * @author jan soe
  */
 public class Path
 {
@@ -384,22 +386,28 @@ public InstructionList calcInstructions( final Translation tr )
              */
             private double prevLat = nodeAccess.getLatitude(tmpNode);
             private double prevLon = nodeAccess.getLongitude(tmpNode);
+            private double doublePrevLat, doublePrevLong; // Lat and Lon of node t-2
             private double prevOrientation;
             private Instruction prevInstruction;
-            private PointList points = new PointList(10, nodeAccess.is3D());
-            private String name = null;
-            private InstructionAnnotation annotation;
+            private boolean prevInRoundabout = false;
+            private String name, prevName = null;
+            private InstructionAnnotation annotation, prevAnnotation;
+            private EdgeExplorer outEdgeExplorer = graph.createEdgeExplorer(new DefaultEdgeFilter(encoder, false, true));
 
             @Override
             public void next( EdgeIteratorState edge, int index )
             {
                 // baseNode is the current node and adjNode is the next
                 int adjNode = edge.getAdjNode();
+                int baseNode = edge.getBaseNode();
                 long flags = edge.getFlags();
                 double adjLat = nodeAccess.getLatitude(adjNode);
                 double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
+
                 PointList wayGeo = edge.fetchWayGeometry(3);
+                boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
+
                 if (wayGeo.getSize() <= 2)
                 {
                     latitude = adjLat;
@@ -408,86 +416,161 @@ public void next( EdgeIteratorState edge, int index )
                 {
                     latitude = wayGeo.getLatitude(1);
                     longitude = wayGeo.getLongitude(1);
-
-                    // overwrite previous lat,lon
-                    int baseNode = edge.getBaseNode();
-                    prevLat = nodeAccess.getLatitude(baseNode);
-                    prevLon = nodeAccess.getLongitude(baseNode);
+                    assert java.lang.Double.compare(prevLat, nodeAccess.getLatitude(baseNode)) == 0;
+                    assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                 }
 
-                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
-                if (name == null)
+                name = edge.getName();
+                annotation = encoder.getAnnotation(flags, tr);
+
+                if ((prevName == null) && (!isRoundabout))
+                // very first instruction (if not in Roundabout)
                 {
-                    // very first instruction
-                    name = edge.getName();
-                    annotation = encoder.getAnnotation(flags, tr);
-                    prevInstruction = new Instruction(Instruction.CONTINUE_ON_STREET, name, annotation, points);
-                    updatePointsAndInstruction(edge, wayGeo);
+                    int sign = Instruction.CONTINUE_ON_STREET;
+                    prevInstruction = new Instruction(sign, name, annotation, new PointList(10, nodeAccess.is3D()), 0);
                     ways.add(prevInstruction);
+                    prevName = name;
+                    prevAnnotation = annotation;
+
                 } else
                 {
-                    double tmpOrientation = ac.alignOrientation(prevOrientation, orientation);
-                    String tmpName = edge.getName();
-                    InstructionAnnotation tmpAnnotation = encoder.getAnnotation(flags, tr);
-                    if ((!name.equals(tmpName))
-                            || (!annotation.equals(tmpAnnotation)))
+                    if (isRoundabout)
+                        // remark: names and annotations within roundabout are ignored
+                    {
+                        if (!prevInRoundabout) //just entered roundabout
+                        {
+                            int sign = Instruction.USE_ROUNDABOUT;
+                            prevInstruction = new RoundaboutInstruction(sign, name, annotation,
+                                    new PointList(10, nodeAccess.is3D()), 0);
+
+                            if (prevName != null)
+                            {
+                                // previous orientation is last orientation before entering roundabout
+                                prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+
+                                // calculate direction of entrance turn to determine direction of rotation
+                                // right turn == counterclockwise and vice versa
+                                double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                                orientation = ac.alignOrientation(prevOrientation, orientation);
+                                double delta = (orientation - prevOrientation);
+                                prevInstruction = ((RoundaboutInstruction) prevInstruction).setDirOfRotation(delta);
+
+                            } else // first instructions is roundabout instruction
+                            {
+                                prevOrientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                            }
+                        }
+
+                        // Add passed exits to instruction. There is an exit if there are
+                        // at least 2 out-going edges (one continuing in the roundabout)
+                        // This could lead to problems if there are non-complete roundabouts!
+                        EdgeIterator edgeIter = outEdgeExplorer.setBaseNode(adjNode);
+                        edgeIter.next();
+                        if (edgeIter.next()) {((RoundaboutInstruction) prevInstruction).increaseExitNr();}
+
+                    } else if (prevInRoundabout){ //previously in roundabout but not anymore
+
+                        prevInstruction.setName(name);
+
+                        // calc angle between roundabout entrance and exit
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = (orientation - prevOrientation);
+                        prevInstruction.setRadian(delta);
+
+                        // calculate direction of exit turn to determine direction of rotation
+                        // right turn == counterclockwise and vice versa
+                        double recentOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(recentOrientation, orientation);
+                        delta = (orientation - recentOrientation);
+
+                        prevInstruction = ((RoundaboutInstruction) prevInstruction)
+                            .setContinuedStreet(!Helper.isEmpty(name) && (prevName.equals(name)))
+                            .setDirOfRotation(delta)
+                            .setFinished();
+
+
+                        ways.add(prevInstruction);
+
+                        prevName = name;
+                        prevAnnotation = annotation;
+
+                    } else if ((!name.equals(prevName)) || (!annotation.equals(prevAnnotation)))
                     {
-                        points = new PointList(10, nodeAccess.is3D());
-                        name = tmpName;
-                        annotation = tmpAnnotation;
-                        double delta = Math.abs(tmpOrientation - prevOrientation);
+                        prevOrientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        double orientation = ac.calcOrientation(prevLat, prevLon, latitude, longitude);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = orientation - prevOrientation;
+                        double absDelta = Math.abs(delta);
                         int sign;
-                        if (delta < 0.2)
+
+                        if (absDelta < 0.2)
                         {
                             // 0.2 ~= 11°
                             sign = Instruction.CONTINUE_ON_STREET;
 
-                        } else if (delta < 0.8)
+                        } else if (absDelta < 0.8)
                         {
                             // 0.8 ~= 40°
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SLIGHT_LEFT;
                             else
                                 sign = Instruction.TURN_SLIGHT_RIGHT;
 
-                        } else if (delta < 1.8)
+                        } else if (absDelta < 1.8)
                         {
                             // 1.8 ~= 103°
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_LEFT;
                             else
                                 sign = Instruction.TURN_RIGHT;
 
                         } else
                         {
-                            if (tmpOrientation > prevOrientation)
+                            if (delta > 0)
                                 sign = Instruction.TURN_SHARP_LEFT;
                             else
                                 sign = Instruction.TURN_SHARP_RIGHT;
 
                         }
-
-                        prevInstruction = new Instruction(sign, name, annotation, points);
+                        prevInstruction = new Instruction(sign, name, annotation,
+                                                          new PointList(10, nodeAccess.is3D()), delta);
                         ways.add(prevInstruction);
+                        prevName = name;
+                        prevAnnotation = annotation;
                     }
-
-                    updatePointsAndInstruction(edge, wayGeo);
                 }
 
-                prevLat = adjLat;
-                prevLon = adjLon;
-                if (wayGeo.getSize() <= 2)
-                    prevOrientation = orientation;
+                updatePointsAndInstruction(edge, wayGeo);
+
+                if (wayGeo.getSize() <= 2) {
+                    doublePrevLat = prevLat;
+                    doublePrevLong = prevLon;
+                }
                 else
                 {
                     int beforeLast = wayGeo.getSize() - 2;
-                    prevOrientation = ac.calcOrientation(wayGeo.getLatitude(beforeLast), wayGeo.getLongitude(beforeLast),
-                            adjLat, adjLon);
+                    doublePrevLat = wayGeo.getLatitude(beforeLast);
+                    doublePrevLong =  wayGeo.getLongitude(beforeLast);
                 }
+                prevInRoundabout = isRoundabout;
+                prevLat = adjLat;
+                prevLon = adjLon;
 
                 boolean lastEdge = index == edgeIds.size() - 1;
                 if (lastEdge)
+                {
+                    if (isRoundabout)
+                    {
+                        // calc angle between roundabout entrance and finish
+                        double orientation = ac.calcOrientation(doublePrevLat, doublePrevLong, prevLat, prevLon);
+                        orientation = ac.alignOrientation(prevOrientation, orientation);
+                        double delta = (orientation - prevOrientation);
+                        prevInstruction.setRadian(delta);
+                        ways.add(prevInstruction);
+                    }
                     ways.add(new FinishInstruction(nodeAccess, adjNode));
+                }
             }
 
             private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
@@ -496,7 +579,7 @@ private void updatePointsAndInstruction( EdgeIteratorState edge, PointList pl )
                 int len = pl.size() - 1;
                 for (int i = 0; i < len; i++)
                 {
-                    points.add(pl, i);
+                    prevInstruction.getPoints().add(pl, i);
                 }
                 double newDist = edge.getDistance();
                 prevInstruction.setDistance(newDist + prevInstruction.getDistance());
diff --git a/core/src/main/java/com/graphhopper/util/FinishInstruction.java b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
index b59f453b7b..78de314c35 100644
--- a/core/src/main/java/com/graphhopper/util/FinishInstruction.java
+++ b/core/src/main/java/com/graphhopper/util/FinishInstruction.java
@@ -33,7 +33,8 @@ public FinishInstruction( final double lat, final double lon, final double ele )
             {
                 add(lat, lon, ele);
             }
-        });
+        },
+        0);
     }
 
     public FinishInstruction( NodeAccess nodeAccess, int node )
diff --git a/core/src/main/java/com/graphhopper/util/Instruction.java b/core/src/main/java/com/graphhopper/util/Instruction.java
index b5792db8c4..d43ae6465d 100644
--- a/core/src/main/java/com/graphhopper/util/Instruction.java
+++ b/core/src/main/java/com/graphhopper/util/Instruction.java
@@ -17,11 +17,14 @@
  */
 package com.graphhopper.util;
 
+import java.util.HashMap;
 import java.util.List;
 
 public class Instruction
 {
     private static final AngleCalc ac = new AngleCalc();
+
+    public static final int LEAVE_ROUNDABOUT = -6; // for future use
     public static final int TURN_SHARP_LEFT = -3;
     public static final int TURN_LEFT = -2;
     public static final int TURN_SLIGHT_LEFT = -1;
@@ -31,23 +34,27 @@
     public static final int TURN_SHARP_RIGHT = 3;
     public static final int FINISH = 4;
     public static final int REACHED_VIA = 5;
+    public static final int USE_ROUNDABOUT = 6;
+
     protected int sign;
-    private final String name;
-    private double distance;
-    private long time;
-    final PointList points;
-    private final InstructionAnnotation annotation;
+    protected String name;
+    protected double radian;
+    protected double distance;
+    protected long time;
+    protected final PointList points;
+    protected final InstructionAnnotation annotation;
 
     /**
      * The points, distances and times have exactly the same count. The last point of this
      * instruction is not duplicated here and should be in the next one.
      */
-    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl )
+    public Instruction( int sign, String name, InstructionAnnotation ia, PointList pl, double radian)
     {
         this.sign = sign;
         this.name = name;
         this.points = pl;
         this.annotation = ia;
+        this.radian = radian;
     }
 
     public InstructionAnnotation getAnnotation()
@@ -55,19 +62,39 @@ public InstructionAnnotation getAnnotation()
         return annotation;
     }
 
+    /**
+     * The instruction for the person/driver to execute.
+     */
     public int getSign()
     {
         return sign;
     }
 
-    /**
-     * The instruction for the person/driver to execute.
-     */
+    public void changeSing(int newSign)
+    {
+        this.sign = newSign;
+    }
+
     public String getName()
     {
         return name;
     }
 
+    public void setName(String name)
+    {
+        this.name = name;
+    }
+
+    public double getRadian()
+    {
+        return radian;
+    }
+
+    public void setRadian(double radian)
+    {
+        this.radian = radian;
+    }
+
     public Instruction setDistance( double distance )
     {
         this.distance = distance;
@@ -223,7 +250,7 @@ void checkOne()
     public String getTurnDescription( Translation tr )
     {
         String str;
-        String n = getName();
+        String streetName = getName();
         int indi = getSign();
         if (indi == Instruction.FINISH)
         {
@@ -233,7 +260,7 @@ public String getTurnDescription( Translation tr )
             str = tr.tr("stopover", ((FinishInstruction) this).getViaPosition());
         } else if (indi == Instruction.CONTINUE_ON_STREET)
         {
-            str = Helper.isEmpty(n) ? tr.tr("continue") : tr.tr("continue_onto", n);
+            str = Helper.isEmpty(streetName) ? tr.tr("continue") : tr.tr("continue_onto", streetName);
         } else
         {
             String dir = null;
@@ -261,7 +288,7 @@ public String getTurnDescription( Translation tr )
             if (dir == null)
                 throw new IllegalStateException("Indication not found " + indi);
 
-            str = Helper.isEmpty(n) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, n);
+            str = Helper.isEmpty(streetName) ? tr.tr("turn", dir) : tr.tr("turn_onto", dir, streetName);
         }
         return str;
     }
diff --git a/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
new file mode 100644
index 0000000000..e45ae7c1d1
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/util/RoundaboutInstruction.java
@@ -0,0 +1,99 @@
+package com.graphhopper.util;
+
+/**
+ * Created by jan on 02.02.15.
+ *
+ * @author jansoe
+ */
+public class RoundaboutInstruction extends Instruction {
+
+    private int exitNr = 0;
+    private boolean continuedStreet = false;
+    private int clockwise = 0; // 0 undetermined, 1 clockwise, -1 counterclockwise, -2 inconsistent
+    private boolean unfinished = true;
+
+    public RoundaboutInstruction(int sign, String name, InstructionAnnotation ia, PointList pl, double radian) {
+        super(sign, name, ia, pl, radian);
+    }
+
+    public boolean getContinuedStreet()
+    {
+        return continuedStreet;
+    }
+
+    /**
+    * indicates whether on continues on the same street as before after roundabout
+    **/
+    public RoundaboutInstruction setContinuedStreet(boolean continued)
+    {
+        this.continuedStreet = continued;
+        return this;
+    }
+
+    public RoundaboutInstruction increaseExitNr() {
+        this.exitNr += 1;
+        return this;
+    }
+
+    public RoundaboutInstruction setDirOfRotation(double deltaIn)
+    {
+        if (clockwise == 0) {
+            clockwise = deltaIn > 0 ? 1 : -1;
+        }
+        else
+        {
+            int clockwise2 = deltaIn > 0 ? 1 : -1;
+            if (clockwise != clockwise2) {
+                clockwise = 2;
+            }
+        }
+        return this;
+    }
+
+    public RoundaboutInstruction setFinished()
+    {
+        unfinished = false;
+        return this;
+    }
+
+    public int getExitNr() {
+        if (exitNr == 0) {
+            throw new IllegalStateException("RoundaboutInstruction must contain exitNr>0");
+        }
+        return exitNr;
+    }
+
+    @Override
+    public double getRadian() {
+        if (Math.abs(clockwise) != 1) {
+            throw new IllegalStateException("Roundabout direction of rotation is not determined");
+        }
+        double tmpRadian = Math.PI - clockwise*radian;
+        return tmpRadian;
+    }
+
+    @Override
+    public String getTurnDescription(Translation tr) {
+        String str;
+        String streetName = getName();
+        int indi = getSign();
+        if (indi == Instruction.USE_ROUNDABOUT)
+        {
+            if (unfinished)
+            {
+                //str = tr.tr("roundaboutEntering");
+                str = tr.tr("roundaboutInstruction", 0);
+            } else if (continuedStreet)
+            {
+                //str = tr.tr("roundaboutInstructionContinue", getExitNr());
+                str = tr.tr("roundaboutInstructionWithDir", getExitNr(), streetName);
+            } else {
+                str = Helper.isEmpty(streetName) ? tr.tr("roundaboutInstruction", getExitNr()) :
+                        tr.tr("roundaboutInstructionWithDir", getExitNr(), streetName);
+            }
+        } else {
+            throw new IllegalStateException(indi + "no Roundabout indication");
+        }
+        return str;
+    }
+}
\ No newline at end of file
diff --git a/core/src/test/java/com/graphhopper/routing/PathTest.java b/core/src/test/java/com/graphhopper/routing/PathTest.java
index 4e6b9e423f..f9c93fac8e 100644
--- a/core/src/test/java/com/graphhopper/routing/PathTest.java
+++ b/core/src/test/java/com/graphhopper/routing/PathTest.java
@@ -17,9 +17,7 @@
  */
 package com.graphhopper.routing;
 
-import com.graphhopper.routing.util.Bike2WeightFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
 import com.graphhopper.util.Helper;
 import static com.graphhopper.storage.AbstractGraphStorageTester.*;
@@ -28,9 +26,8 @@
 import com.graphhopper.util.InstructionList;
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.util.*;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
+import java.util.*;
+
 import org.junit.Test;
 import static org.junit.Assert.*;
 
@@ -41,7 +38,7 @@
 public class PathTest
 {
     private final EncodingManager carManager = new EncodingManager("CAR");
-    private final FlagEncoder encoder = new EncodingManager("CAR").getEncoder("CAR");
+    private final FlagEncoder encoder = carManager.getEncoder("CAR");
     private final TranslationMap trMap = TranslationMapTest.SINGLETON;
     private final Translation tr = trMap.getWithFallBack(Locale.US);
 
@@ -213,4 +210,159 @@ public void testFindInstruction()
         assertNull(il.find(50.8, 50.25, 1000));
     }
 
+    @Test
+    public void testCalcInstructionsRoundabout()
+    {
+        final AngleCalc ac = new AngleCalc();
+        EdgeIteratorState tmpEdge, edge2change;
+        EncodingManager carManager = new EncodingManager("CAR");
+
+        // counterclockwise roundabout
+        //
+        //         8
+        //         |
+        //         5
+        //       /  \
+        //  1 - 2    4 - 7
+        //       \  /
+        //        3
+        //        |
+        //        6
+
+        Graph g = new GraphBuilder(carManager).create();
+        NodeAccess na = g.getNodeAccess();
+        na.setNode(1, 52.514321,13.34826);
+        na.setNode(2, 52.514432,13.349032);
+        na.setNode(3, 52.513857,13.350255);
+        na.setNode(4, 52.514536,13.351178);
+        na.setNode(5, 52.51502, 13.349333);
+        na.setNode(6, 52.513322,13.350363);
+        na.setNode(7, 52.514562,13.351886);
+        na.setNode(8, 52.51545, 13.348024);
+
+        tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(2, 3, 5, false).setName("2-3");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(3, 4, 5, false).setName("3-4");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 5, 5, false).setName("4-5");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(5, 2, 5, false).setName("5-2");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+        edge2change = tmpEdge.detach(false);
+
+        double inOrientation = ac.calcOrientation(na.getLat(1), na.getLon(1), na.getLat(2), na.getLon(2));
+        Path p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        InstructionList wayList = p.calcInstructions(tr);
+        // Test instructions
+        List<String> tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                                    "Enter roundabout and use exit 3 in direction 5-8",
+                                    "Finish!"),
+                     tmpList);
+        // Test Radian
+        double outOrientation = ac.calcOrientation(na.getLat(5), na.getLon(5), na.getLat(8), na.getLon(8));
+        outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+        double delta = (inOrientation - outOrientation);
+        delta = Math.PI - delta;
+        assertEquals(wayList.get(1).getRadian(), delta, 0.01);
+
+        // case of continuing a street through a roundabout
+        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 7);
+        wayList = p.calcInstructions(tr);
+        tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                                    "Enter roundabout and use exit 2 in direction MainStreet",
+                                    "Finish!"),
+                tmpList);
+        // Test Radian
+        outOrientation = ac.calcOrientation(na.getLat(4), na.getLon(4), na.getLat(7), na.getLon(7));
+        outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+        delta = (inOrientation - outOrientation);
+        delta = Math.PI - delta;
+        assertEquals(wayList.get(1).getRadian(), delta, 0.01);
+
+        // case with one edge being not an exit
+        edge2change.setFlags(encoder.setBool(edge2change.getFlags(), FlagEncoder.K_FORWARD, false));
+        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        wayList = p.calcInstructions(tr);
+        tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                        "Enter roundabout and use exit 2 in direction 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        outOrientation = ac.calcOrientation(na.getLat(5), na.getLon(5), na.getLat(8), na.getLon(8));
+        outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+        delta = (inOrientation - outOrientation);
+        delta = Math.PI - delta;
+        assertEquals(wayList.get(1).getRadian(), delta, 0.01);
+
+
+
+        // clockwise roundabout
+        //
+        //         8
+        //         |
+        //         5
+        //       /  \
+        //  1 - 2    4 - 7
+        //       \  /
+        //        3
+        //        |
+        //        6
+
+        g = new GraphBuilder(carManager).create();
+        na = g.getNodeAccess();
+        na.setNode(1, 52.514321,13.34826);
+        na.setNode(2, 52.514432,13.349032);
+        na.setNode(3, 52.513857,13.350255);
+        na.setNode(4, 52.514536,13.351178);
+        na.setNode(5, 52.51502, 13.349333);
+        na.setNode(6, 52.513322,13.350363);
+        na.setNode(7, 52.514562,13.351886);
+        na.setNode(8, 52.51545, 13.348024);
+
+        tmpEdge = g.edge(1, 2, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(2, 5, 5, false).setName("2-3");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(5, 4, 5, false).setName("3-4");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 3, 5, false).setName("4-5");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(3, 2, 5, false).setName("5-2");
+        tmpEdge.setFlags(encoder.setBool(tmpEdge.getFlags(), FlagEncoder.K_ROUNDABOUT, true));
+        tmpEdge = g.edge(4, 7, 5, true).setName("MainStreet");
+        tmpEdge = g.edge(5, 8, 5, true).setName("5-8");
+        tmpEdge = g.edge(3, 6, 5, true).setName("3-6");
+
+        p = new Dijkstra(g, carManager.getSingle(), new ShortestWeighting(), TraversalMode.NODE_BASED).calcPath(1, 8);
+        wayList = p.calcInstructions(tr);
+        tmpList = pick("text", wayList.createJson());
+        assertEquals(Arrays.asList( "Continue onto MainStreet",
+                        "Enter roundabout and use exit 1 in direction 5-8",
+                        "Finish!"),
+                tmpList);
+        // Test Radian
+        outOrientation = ac.calcOrientation(na.getLat(5), na.getLon(5), na.getLat(8), na.getLon(8));
+        outOrientation = ac.alignOrientation(inOrientation, outOrientation);
+        delta = (inOrientation - outOrientation);
+        delta = Math.PI + delta;
+        assertEquals(wayList.get(1).getRadian(), delta, 0.01);
+    }
+
+    List<String> pick( String key, List<Map<String, Object>> instructionJson )
+    {
+        List<String> list = new ArrayList<String>();
+
+        for (Map<String, Object> json : instructionJson)
+        {
+            list.add(json.get(key).toString());
+        }
+        return list;
+    }
+
 }
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index d2a841bce0..fd8c6225d9 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -373,15 +373,15 @@ public void testCreateGPX()
         PointList pl = new PointList();
         pl.add(49.942576, 11.580384);
         pl.add(49.941858, 11.582422);
-        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl).setDistance(240).setTime(15000));
+        instructions.add(new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl, 0).setDistance(240).setTime(15000));
 
         pl = new PointList();
         pl.add(49.941575, 11.583501);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(4000));
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl, 1.5).setDistance(25).setTime(4000));
 
         pl = new PointList();
         pl.add(49.941389, 11.584311);
-        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl).setDistance(25).setTime(3000));
+        instructions.add(new Instruction(Instruction.TURN_LEFT, "temp2", ea, pl, 1.5).setDistance(25).setTime(3000));
         instructions.add(new FinishInstruction(49.941029, 11.584514, 0));
 
         List<GPXEntry> result = instructions.createGPXList();
diff --git a/core/src/test/java/com/graphhopper/util/InstructionTest.java b/core/src/test/java/com/graphhopper/util/InstructionTest.java
index f65170813b..3be86ce716 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionTest.java
@@ -35,8 +35,8 @@ public void testCalcAzimuthAndGetDirection()
         
         PointList nextPl = new PointList();
         nextPl.add(49.942, 11.582);
-        Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl);
-        Instruction nextI = new Instruction(Instruction.CONTINUE_ON_STREET, "next", ea, nextPl);
+        Instruction currI = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, pl, 0);
+        Instruction nextI = new Instruction(Instruction.CONTINUE_ON_STREET, "next", ea, nextPl, 0);
 
         assertEquals(270, currI.calcAzimuth(nextI), .1);
         assertEquals("W", currI.calcDirection(nextI));
@@ -44,7 +44,7 @@ public void testCalcAzimuthAndGetDirection()
         PointList p2 = new PointList();
         p2.add(49.942, 11.580);
         p2.add(49.944, 11.582);
-        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2);
+        Instruction i2 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p2, 0);
 
         assertEquals(45, i2.calcAzimuth(null), .1);
         assertEquals("NE", i2.calcDirection(null));
@@ -52,7 +52,7 @@ public void testCalcAzimuthAndGetDirection()
         PointList p3 = new PointList();
         p3.add(49.942, 11.580);
         p3.add(49.944, 11.580);
-        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3);
+        Instruction i3 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p3, 0);
 
         assertEquals(0, i3.calcAzimuth(null), .1);
         assertEquals("N", i3.calcDirection(null));
@@ -60,13 +60,13 @@ public void testCalcAzimuthAndGetDirection()
         PointList p4 = new PointList();
         p4.add(49.940, 11.580);
         p4.add(49.920, 11.586);
-        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4);
+        Instruction i4 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p4, 0);
 
         assertEquals("S", i4.calcDirection(null));
 
         PointList p5 = new PointList();
         p5.add(49.940, 11.580);
-        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5);
+        Instruction i5 = new Instruction(Instruction.CONTINUE_ON_STREET, "temp", ea, p5, 0);
 
         assertTrue(Double.isNaN(i5.calcAzimuth(null)));
         assertEquals("", i5.calcDirection(null));
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
index c1445d9616..821aba3064 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperWeb.java
@@ -212,7 +212,7 @@ public GHResponse route( GHRequest request )
                         }
 
                         // TODO way and payment type
-                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL).
+                        Instruction instr = new Instruction(sign, text, InstructionAnnotation.EMPTY, instPL, 0).
                                 setDistance(instDist).setTime(instTime);
                         il.add(instr);
                     }
