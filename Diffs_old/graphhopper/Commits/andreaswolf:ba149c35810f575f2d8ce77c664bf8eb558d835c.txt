diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index b047f17bed..4a578fbdff 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -26,6 +26,7 @@
 import com.graphhopper.routing.ch.PrepareContractionHierarchies;
 import com.graphhopper.routing.util.*;
 import com.graphhopper.storage.*;
+import com.graphhopper.storage.extensions.RoadSignExtension;
 import com.graphhopper.storage.index.*;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
@@ -733,7 +734,7 @@ public boolean load( String graphHopperFolder )
 
         GHDirectory dir = new GHDirectory(ghLocation, dataAccessType);
         if (chEnabled)
-            graph = new LevelGraphStorage(dir, encodingManager, hasElevation());
+            graph = new LevelGraphStorage(dir, encodingManager, hasElevation(), new RoadSignExtension());
         else if (encodingManager.needsTurnCostsSupport())
             graph = new GraphHopperStorage(dir, encodingManager, hasElevation(), new TurnCostExtension());
         else
diff --git a/core/src/main/java/com/graphhopper/reader/OSMReader.java b/core/src/main/java/com/graphhopper/reader/OSMReader.java
index 80fa41b353..f41f4b66b9 100644
--- a/core/src/main/java/com/graphhopper/reader/OSMReader.java
+++ b/core/src/main/java/com/graphhopper/reader/OSMReader.java
@@ -18,6 +18,7 @@
 package com.graphhopper.reader;
 
 import static com.graphhopper.util.Helper.nf;
+import com.graphhopper.storage.extensions.RoadSignEncoder;
 import gnu.trove.list.TLongList;
 import gnu.trove.list.array.TLongArrayList;
 import gnu.trove.map.TIntLongMap;
@@ -118,6 +119,8 @@
     private File osmFile;
     private Map<FlagEncoder, EdgeExplorer> outExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
     private Map<FlagEncoder, EdgeExplorer> inExplorerMap = new HashMap<FlagEncoder, EdgeExplorer>();
+    private RoadSignEncoder roadSigns;
+
 
     public OSMReader( GraphStorage storage )
     {
@@ -128,6 +131,7 @@ public OSMReader( GraphStorage storage )
         osmNodeIdToNodeFlagsMap = new TLongLongHashMap(200, .5f, 0, 0);
         osmWayIdToRouteWeightMap = new TLongLongHashMap(200, .5f, 0, 0);
         pillarInfo = new PillarInfo(nodeAccess.is3D(), graphStorage.getDirectory());
+        roadSigns = new RoadSignEncoder(graphStorage);
     }
 
     @Override
@@ -564,9 +568,15 @@ private void processNode( OSMNode node )
             // analyze node tags for barriers
             if (node.hasTags())
             {
+                if (node.hasTag("highway", "traffic_signals"))
+                {
+                    // TODO WTF? get node id in a sane way hereâ€¦
+                    roadSigns.markTrafficLight(-getNodeMap().get(node.getId())-3, true);
+                }
                 long nodeFlags = encodingManager.handleNodeTags(node);
                 if (nodeFlags != 0)
                     getNodeFlagsMap().put(node.getId(), nodeFlags);
+
             }
 
             locations++;
@@ -585,7 +595,7 @@ boolean addNode( OSMNode node )
         double lat = node.getLat();
         double lon = node.getLon();
         double ele = getElevation(node);
-        if (nodeType == TOWER_NODE)
+        if (nodeType == TOWER_NODE || node.hasTag("highway", "traffic_signals"))
         {
             addTowerNode(node.getId(), lat, lon, ele);
         } else if (nodeType == PILLAR_NODE)
diff --git a/core/src/main/java/com/graphhopper/routing/Path.java b/core/src/main/java/com/graphhopper/routing/Path.java
index a96c414f44..7432893fee 100644
--- a/core/src/main/java/com/graphhopper/routing/Path.java
+++ b/core/src/main/java/com/graphhopper/routing/Path.java
@@ -22,6 +22,7 @@
 import com.graphhopper.storage.EdgeEntry;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.extensions.RoadSignEncoder;
 import com.graphhopper.util.*;
 import gnu.trove.list.TIntList;
 import gnu.trove.list.array.TIntArrayList;
@@ -370,6 +371,8 @@ public InstructionList calcInstructions( final Translation tr )
             return ways;
         }
 
+        final RoadSignEncoder signEncoder = new RoadSignEncoder(graph);
+
         final int tmpNode = getFromNode();
         forEveryEdge(new EdgeVisitor()
         {
@@ -415,6 +418,7 @@ public void next( EdgeIteratorState edge, int index )
                 double adjLon = nodeAccess.getLongitude(adjNode);
                 double latitude, longitude;
 
+                System.out.println("Edge: " + edge.getName() + "; " + baseNode + "-" + adjNode);
                 PointList wayGeo = edge.fetchWayGeometry(3);
                 boolean isRoundabout = encoder.isBool(flags, encoder.K_ROUNDABOUT);
 
@@ -430,6 +434,7 @@ public void next( EdgeIteratorState edge, int index )
                     assert java.lang.Double.compare(prevLon, nodeAccess.getLongitude(baseNode)) == 0;
                 }
 
+                // TODO how to find out if this way is traversed forward or backward?
                 name = edge.getName();
                 annotation = encoder.getAnnotation(flags, tr);
 
diff --git a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
index a4f7477a90..a8a274ff62 100644
--- a/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
+++ b/core/src/main/java/com/graphhopper/storage/LevelGraphStorage.java
@@ -50,6 +50,12 @@ public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolea
         baseGraph = new BaseGraph(this);
     }
 
+    public LevelGraphStorage( Directory dir, EncodingManager encodingManager, boolean enabled3D, GraphExtension storageExtension )
+    {
+        super(dir, encodingManager, enabled3D, storageExtension);
+        baseGraph = new BaseGraph(this);
+    }
+
     @Override
     public boolean isShortcut( int edgeId )
     {
diff --git a/core/src/main/java/com/graphhopper/storage/extensions/RoadSignEncoder.java b/core/src/main/java/com/graphhopper/storage/extensions/RoadSignEncoder.java
new file mode 100644
index 0000000000..3c824e60a1
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/extensions/RoadSignEncoder.java
@@ -0,0 +1,65 @@
+package com.graphhopper.storage.extensions;
+
+import com.graphhopper.storage.Graph;
+import com.graphhopper.storage.NodeAccess;
+
+
+public class RoadSignEncoder
+{
+    /**
+     * Positions of bits for encoding various pieces of information
+     */
+    final byte TRAFFIC_LIGHT_BIT = 1;
+
+    RoadSignExtension storage;
+
+    NodeAccess nodes;
+
+    public RoadSignEncoder(Graph graph)
+    {
+        if (!(graph.getExtension() instanceof RoadSignExtension))
+        {
+            throw new IllegalArgumentException("Wrong type of storage extension");
+        }
+        storage = (RoadSignExtension)graph.getExtension();
+        nodes = graph.getNodeAccess();
+    }
+
+    public boolean hasTrafficLight(int nodeId)
+    {
+        int nodeFieldValue = nodes.getAdditionalNodeField(nodeId);
+
+        return hasBitSet(nodeFieldValue, TRAFFIC_LIGHT_BIT);
+    }
+
+    public int markTrafficLight(int nodeId, boolean value)
+    {
+        int nodeFieldValue = nodes.getAdditionalNodeField(nodeId);
+        nodeFieldValue = setBitInField(nodeFieldValue, TRAFFIC_LIGHT_BIT, value);
+        nodes.setAdditionalNodeField(nodeId, nodeFieldValue);
+
+        return nodeFieldValue;
+    }
+
+    private boolean hasBitSet(int value, byte bitPosition)
+    {
+        return ((value >>> bitPosition - 1) & 1) != 0;
+    }
+
+    private int setBitInField(int currentValue, byte bitPosition, boolean value)
+    {
+        int mask = 1 << (bitPosition - 1);
+
+        // clear bit
+        currentValue &= ~mask;
+
+        // set bit if necessary
+        if (value)
+        {
+            currentValue |= mask;
+        }
+
+        return currentValue;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/storage/extensions/RoadSignExtension.java b/core/src/main/java/com/graphhopper/storage/extensions/RoadSignExtension.java
new file mode 100644
index 0000000000..d4897e37ff
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/storage/extensions/RoadSignExtension.java
@@ -0,0 +1,132 @@
+package com.graphhopper.storage.extensions;
+
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphStorage;
+import com.graphhopper.storage.NodeAccess;
+
+/**
+ * Storage extension to hold road signs, e.g. stop signs or traffic lights.
+ *
+ * We might extend this to also hold speed bumps etc.
+ */
+public class RoadSignExtension implements GraphExtension
+{
+    /**
+     * Positions of header definitions within the storage
+     */
+    final int HEADER_BYTES_PER_ENTRY = 0;
+    final int HEADER_ENTRY_COUNT = 4;
+
+    private int bytesPerEntry;
+    private int entryCount = 0;
+
+    /**
+     * The storage that does the actual work for us
+     */
+    private DataAccess storage;
+
+    private GraphStorage graph;
+    private NodeAccess nodeAccess;
+
+    @Override
+    public boolean isRequireNodeField()
+    {
+        return true;
+    }
+
+    @Override
+    public boolean isRequireEdgeField()
+    {
+        return false;
+    }
+
+    @Override
+    public int getDefaultNodeFieldValue()
+    {
+        return 0;
+    }
+
+    @Override
+    public int getDefaultEdgeFieldValue()
+    {
+        return 0;
+    }
+
+    @Override
+    public void init(GraphStorage graph)
+    {
+        if (entryCount > 0)
+            throw new AssertionError("The road sign extension must be initialized only once.");
+
+        this.graph = graph;
+        this.nodeAccess = graph.getNodeAccess();
+        this.storage = this.graph.getDirectory().find("road_signs");
+    }
+
+    @Override
+    public void setSegmentSize(int bytes)
+    {
+        storage.setSegmentSize(bytes);
+    }
+
+    @Override
+    public GraphExtension copyTo(GraphExtension extStorage)
+    {
+        if (!(extStorage instanceof RoadSignExtension))
+        {
+            throw new IllegalStateException("the extended storage to clone must be the same");
+        }
+
+        RoadSignExtension clonedTC = (RoadSignExtension) extStorage;
+
+        storage.copyTo(clonedTC.storage);
+        clonedTC.entryCount = entryCount;
+
+        return extStorage;
+    }
+
+    @Override
+    public boolean loadExisting()
+    {
+        if (!storage.loadExisting())
+            return false;
+
+        bytesPerEntry = storage.getHeader(0);
+        entryCount = storage.getHeader(4);
+        return true;
+    }
+
+    @Override
+    public GraphExtension create(long byteCount)
+    {
+        storage.create(byteCount * bytesPerEntry);
+        return this;
+    }
+
+    @Override
+    public void flush()
+    {
+        storage.setHeader(HEADER_BYTES_PER_ENTRY, bytesPerEntry);
+        storage.setHeader(HEADER_ENTRY_COUNT, entryCount);
+        storage.flush();
+    }
+
+    @Override
+    public void close()
+    {
+        storage.close();
+    }
+
+    @Override
+    public boolean isClosed()
+    {
+        return storage.isClosed();
+    }
+
+    @Override
+    public long getCapacity()
+    {
+        return storage.getCapacity();
+    }
+}
