diff --git a/.travis.yml b/.travis.yml
index ac6a9d0113..e068803c58 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,5 +1,5 @@
 language: java
-sudo: false
+sudo: true
 dist: trusty
 
 env:
@@ -21,7 +21,7 @@ matrix:
 install: true
 
 # store them into travis via https://dracoblue.net/dev/uploading-snapshots-and-releases-to-maven-central-with-travis/
-# gpg -a --export-secret-keys your@email.org | base64 -w 0
+# gpg --export-secret-keys <keyID> | base64 -w 0
 # gpg --export-ownertrust | base64 -w 0
 before_install:
   - if [ ! -z "$GPG_SECRET_KEYS" ]; then echo $GPG_SECRET_KEYS | base64 --decode | $GPG_EXECUTABLE --import; fi
@@ -54,7 +54,7 @@ after_success:
 
 notifications:
   email:
-    - secure: l7/fjqL0c/9UcULXdhaKxsroZMg07nfNDiOHRBf7YKf8wrKdH52Z5kP7E10+a8iD/ieLD+ZaZPlom1bE7HymE1bVkp3d17Ezha47W5sdyOOb3NBDpg8olS4TkehOKo3AQhLXSfF6QGtipxY8Iy9QknXHngQOrcoGYiOlzCZ3BTQ=
+    - $EMAIL
 
 cache:
   directories:
diff --git a/Dockerfile b/Dockerfile
index 19d70fc819..fb274b8fcc 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,7 +1,6 @@
 FROM openjdk:8-jdk
 
-ENV JETTY_PORT 11111
-ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
+ENV JAVA_OPTS "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M -Ddw.server.applicationConnectors[0].bindHost=0.0.0.0 -Ddw.server.applicationConnectors[0].port=11111"
 
 RUN mkdir -p /data && \
     mkdir -p /graphhopper
@@ -10,7 +9,7 @@ COPY . /graphhopper/
 
 WORKDIR /graphhopper
 
-RUN ./graphhopper.sh buildweb
+RUN ./graphhopper.sh build
 
 VOLUME [ "/data" ]
 
diff --git a/README.md b/README.md
index b344fcdd9c..02600c653a 100644
--- a/README.md
+++ b/README.md
@@ -46,6 +46,17 @@ There are subprojects to make GraphHopper working offline
 on [Android](https://github.com/graphhopper/graphhopper/tree/master/android)
 and [iOS](http://github.com/graphhopper/graphhopper-ios)
 
+## For Analysis
+
+There is the isochrone subproject to calculate and visualize the reachable area for a certain travel mode
+
+**[Isochrone Web API](./docs/web/api-doc.md#isochrone)**
+
+[![Isochrone API image](./docs/isochrone/images/isochrone.png)](./docs/web/api-doc.md#isochrone)
+
+**[Isochrone Experiments](//www.graphhopper.com/blog/2018/07/04/high-precision-reachability/)**
+
+[![high precision reachability image](https://www.graphhopper.com/wp-content/uploads/2018/06/berlin-reachability-768x401.png)](https://www.graphhopper.com/blog/2018/07/04/high-precision-reachability/)
 
 # Technical Overview
 
@@ -94,7 +105,7 @@ Embed GraphHopper with OpenStreetMap support into your Java application via the
 <dependency>
     <groupId>com.graphhopper</groupId>
     <artifactId>graphhopper-reader-osm</artifactId>
-    <version>[LATEST-VERSION]/version>
+    <version>[LATEST-VERSION]</version>
 </dependency>
 ```
 
@@ -148,6 +159,13 @@ cd core/files/
 docker-compose up -d
 ```
 
+If you don't want to use docker-compose you can do the following:
+```bash
+docker build -t graphhopper:master .
+docker run -d --name graphhopper -v <path_data_directory>/data:/data -p 11111:11111 graphhopper:master
+```
+
+
 # Features
 
 Here is a list of the more detailed features including a link to the documentation:
@@ -174,3 +192,4 @@ Here is a list of the more detailed features including a link to the documentati
  * Scales from small indoor-sized to world-wide-sized graphs
  * Find nearest point on street e.g. to get elevation or 'snapp to road'
  * Do [map matching](https://github.com/graphhopper/map-matching) with GraphHopper
+ * Calculate [isochrones](./docs/web/api-doc.md#isochrone) with GraphHopper
diff --git a/api/src/main/java/com/graphhopper/util/Parameters.java b/api/src/main/java/com/graphhopper/util/Parameters.java
index 58dcffcb0d..0ec9de5fc3 100644
--- a/api/src/main/java/com/graphhopper/util/Parameters.java
+++ b/api/src/main/java/com/graphhopper/util/Parameters.java
@@ -207,7 +207,6 @@
         public static final String IGNORE_TRANSFERS = "pt.ignore_transfers";
         public static final String WALK_SPEED = "pt.walk_speed";
         public static final String MAX_WALK_DISTANCE_PER_LEG = "pt.max_walk_distance_per_leg";
-        public static final String MAX_TRANSFER_DISTANCE_PER_LEG = "pt.max_transfer_distance_per_leg";
         public static final String LIMIT_SOLUTIONS = "pt.limit_solutions";
         public static final String BLOCKED_ROUTE_TYPES = "pt.blocked_route_types";
     }
diff --git a/api/src/main/java/com/graphhopper/util/PointList.java b/api/src/main/java/com/graphhopper/util/PointList.java
index 4891a52781..2dca1d6f65 100644
--- a/api/src/main/java/com/graphhopper/util/PointList.java
+++ b/api/src/main/java/com/graphhopper/util/PointList.java
@@ -29,9 +29,7 @@
 
 /**
  * Slim list to store several points (without the need for a point object). Be aware that the PointList is closely
- * coupled with the {@link ShallowImmutablePointList} if you change it or extend it, you should make sure that your
- * changes play well with the ShallowImmutablePointList to avoid unexpected issues.
- * <p>
+ * coupled with the {@link ShallowImmutablePointList} both are not designed for inheritance (but final is not possible if we keep it simple).
  *
  * @author Peter Karich
  */
@@ -402,7 +400,7 @@ public static PointList fromLineString(LineString lineString) {
 
     public LineString toLineString(boolean includeElevation) {
         GeometryFactory gf = new GeometryFactory();
-        Coordinate[] coordinates = new Coordinate[getSize()];
+        Coordinate[] coordinates = new Coordinate[getSize() == 1 ? 2 : getSize()];
         for (int i = 0; i < getSize(); i++) {
             coordinates[i] = includeElevation ?
                     new Coordinate(
@@ -413,6 +411,10 @@ public LineString toLineString(boolean includeElevation) {
                             round6(getLongitude(i)),
                             round6(getLatitude(i)));
         }
+
+        // special case as just 1 point is not supported in the specification #1412
+        if (getSize() == 1)
+            coordinates[1] = coordinates[0];
         return gf.createLineString(coordinates);
     }
 
@@ -490,28 +492,34 @@ public PointList copy(int from, int end) {
         if (from < 0 || end > getSize())
             throw new IllegalArgumentException("Illegal interval: " + from + ", " + end + ", size:" + getSize());
 
-        PointList copyPL = new PointList(end - from, is3D());
-        if (is3D())
-            for (int i = from; i < end; i++) {
-                copyPL.add(getLatitude(i), getLongitude(i), getElevation(i));
-            }
-        else
-            for (int i = from; i < end; i++) {
-                copyPL.add(getLatitude(i), getLongitude(i), Double.NaN);
-            }
 
+        PointList thisPL = this;
+        if (this instanceof ShallowImmutablePointList) {
+            ShallowImmutablePointList spl = (ShallowImmutablePointList) this;
+            thisPL = spl.wrappedPointList;
+            from = spl.fromOffset + from;
+            end = spl.fromOffset + end;
+        }
+
+        int len = end - from;
+        PointList copyPL = new PointList(len, is3D());
+        copyPL.size = len;
+        copyPL.isImmutable = isImmutable();
+        System.arraycopy(thisPL.latitudes, from, copyPL.latitudes, 0, len);
+        System.arraycopy(thisPL.longitudes, from, copyPL.longitudes, 0, len);
+        if (is3D())
+            System.arraycopy(thisPL.elevations, from, copyPL.elevations, 0, len);
         return copyPL;
     }
 
     /**
      * Create a shallow copy of this Pointlist from from to end, excluding end.
-     * <p>
-     * The <code>ensureConsistency</code> parameter makes this PointList immutable, so the shallow copy will stay
-     * consistent with this object. If you don't ensure the consistency it might happen that due to changes of this
-     * object, the shallow copy might contain incorrect or corrupt data.
+     *
+     * @param makeImmutable makes this PointList immutable. If you don't ensure the consistency it might happen that due to changes of this
+     *                      object, the shallow copy might contain incorrect or corrupt data.
      */
-    public PointList shallowCopy(final int from, final int end, boolean ensureConsistency) {
-        if (ensureConsistency)
+    public PointList shallowCopy(final int from, final int end, boolean makeImmutable) {
+        if (makeImmutable)
             this.makeImmutable();
         return new ShallowImmutablePointList(from, end, this);
     }
diff --git a/api/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java b/api/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
index f729b49bb2..648f88c888 100644
--- a/api/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
+++ b/api/src/main/java/com/graphhopper/util/ShallowImmutablePointList.java
@@ -17,8 +17,6 @@
  */
 package com.graphhopper.util;
 
-import java.util.List;
-
 /**
  * This is a shallow copy of a PointList. This class can be used to create a memory efficient copy of a PointList.
  * You have to be aware, that if the wrapped PointList changes, the shallow copy will change as well. This can lead to
@@ -30,9 +28,9 @@
 
     private final static String IMMUTABLE_ERR = "This class is immutable, you are not allowed to change it";
 
-    private final int fromOffset;
-    private final int toOffset;
-    private final PointList wrappedPointList;
+    final int fromOffset;
+    final int toOffset;
+    final PointList wrappedPointList;
 
     public ShallowImmutablePointList(int fromOffset, int toOffset, PointList wrappedPointList) {
         if (fromOffset > toOffset)
diff --git a/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java b/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
index 5114177228..38f435675d 100644
--- a/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
+++ b/api/src/main/java/com/graphhopper/util/shapes/GHPoint.java
@@ -53,7 +53,10 @@ public static GHPoint fromJson(double[] xy) {
 
     private static GHPoint fromString(String str, boolean lonLatOrder) {
         String[] fromStrs = str.split(",");
-        if (fromStrs.length == 2) {
+        if (fromStrs.length != 2)
+            throw new IllegalArgumentException("Cannot parse point '" + str + "'");
+
+        try {
             double fromLat = Double.parseDouble(fromStrs[0]);
             double fromLon = Double.parseDouble(fromStrs[1]);
             if (lonLatOrder) {
@@ -61,8 +64,8 @@ private static GHPoint fromString(String str, boolean lonLatOrder) {
             } else {
                 return new GHPoint(fromLat, fromLon);
             }
-        } else {
-            throw new IllegalArgumentException(str);
+        } catch (NumberFormatException ex) {
+            throw new IllegalArgumentException("Cannot parse point '" + str + "'");
         }
     }
 
@@ -91,8 +94,7 @@ public boolean equals(Object obj) {
         if (obj == null)
             return false;
 
-        @SuppressWarnings("unchecked")
-        final GHPoint other = (GHPoint) obj;
+        @SuppressWarnings("unchecked") final GHPoint other = (GHPoint) obj;
         return NumHelper.equalsEps(lat, other.lat) && NumHelper.equalsEps(lon, other.lon);
     }
 
diff --git a/api/src/test/java/com/graphhopper/util/PointListTest.java b/api/src/test/java/com/graphhopper/util/PointListTest.java
index f401da7cb7..3991cda12a 100644
--- a/api/src/test/java/com/graphhopper/util/PointListTest.java
+++ b/api/src/test/java/com/graphhopper/util/PointListTest.java
@@ -239,7 +239,9 @@ public void testToGeoJson() {
         assertEquals(2, pl.shallowCopy(1, 3, false).toLineString(true).getNumPoints());
 
         assertEquals(0, PointList.EMPTY.toLineString(false).getNumPoints());
-    }
-
 
+        PointList oneLength = new PointList(3, true);
+        oneLength.add(0, 0, 0);
+        assertEquals(2, oneLength.toLineString(false).getNumPoints());
+    }
 }
diff --git a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
index 070a32eac2..e88385a674 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GHMatrixAbstractRequester.java
@@ -61,18 +61,24 @@ public OkHttpClient getDownloader() {
 
     protected String getJson(String url) throws IOException {
         Request okRequest = new Request.Builder().url(url).build();
-        ResponseBody body = downloader.newCall(okRequest).execute().body();
-        String str = body.string();
-        body.close();
-        return str;
+        ResponseBody body = null;
+        try {
+            body = downloader.newCall(okRequest).execute().body();
+            return body.string();
+        } finally {
+            Helper.close(body);
+        }
     }
 
     protected String postJson(String url, JsonNode data) throws IOException {
         Request okRequest = new Request.Builder().url(url).post(RequestBody.create(MT_JSON, data.toString())).build();
-        ResponseBody body = downloader.newCall(okRequest).execute().body();
-        String str = body.string();
-        body.close();
-        return str;
+        ResponseBody body = null;
+        try {
+            body = downloader.newCall(okRequest).execute().body();
+            return body.string();
+        } finally {
+            Helper.close(body);
+        }
     }
 
     protected JsonNode toJSON(String url, String str) {
diff --git a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
index 7253f480d9..485da03c52 100644
--- a/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
+++ b/client-hc/src/main/java/com/graphhopper/api/GraphHopperWeb.java
@@ -351,11 +351,11 @@ public GraphHopperWeb setOptimize(String optimize) {
 
     @Override
     public GHResponse route(GHRequest request) {
+        ResponseBody rspBody = null;
         try {
             Request okRequest = createRequest(request);
-            ResponseBody rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
+            rspBody = getClientForRequest(request).newCall(okRequest).execute().body();
             JsonNode json = objectMapper.reader().readTree(rspBody.byteStream());
-            rspBody.close();
 
             GHResponse res = new GHResponse();
             res.addErrors(readErrors(json));
@@ -376,6 +376,8 @@ public GHResponse route(GHRequest request) {
 
         } catch (Exception ex) {
             throw new RuntimeException("Problem while fetching path " + request.getPoints() + ": " + ex.getMessage(), ex);
+        } finally {
+            Helper.close(rspBody);
         }
     }
 
diff --git a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
index 2b5e819f4e..3f8de6f3ea 100644
--- a/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
+++ b/client-hc/src/test/java/com/graphhopper/api/AbstractGraphHopperMatrixWebIntegrationTester.java
@@ -57,7 +57,7 @@ public void testBikeMatrix() {
         req.addOutArray("times");
 
         MatrixResponse res = ghMatrix.route(req);
-        assertEquals(2450, res.getTime(1, 2) / 1000, 110);
+        assertEquals(2200, res.getTime(1, 2) / 1000, 200);
     }
 
     @Test
@@ -81,23 +81,25 @@ public void testPOSTMatrixQueryWithPointHints() {
         req.addPoint(new GHPoint(52.516848, 13.424606));
         req.addOutArray("distances");
         MatrixResponse res = ghMatrix.route(req);
-        assertEquals(4833, res.getDistance(1, 2), 50);
+        assertEquals(4833, res.getDistance(1, 2), 30);
+        assertEquals(5162, res.getDistance(2, 1), 30);
 
         req = new GHMRequest();
         req.addPoint(new GHPoint(52.517004, 13.389416));
         req.addPoint(new GHPoint(52.485707, 13.435249));
         req.addPoint(new GHPoint(52.516848, 13.424606));
         req.addOutArray("distances");
-        req.setPointHints(Arrays.asList("", "singerstr", ""));
+        req.setPointHints(Arrays.asList("", "", "ifflandstr"));
         res = ghMatrix.route(req);
-        assertEquals(3900, res.getDistance(1, 2), 50);
+        assertEquals(4953, res.getDistance(1, 2), 30);
+        assertEquals(4927, res.getDistance(2, 1), 30);
 
         req = new GHMRequest();
         req.addPoint(new GHPoint(52.517004, 13.389416));
         req.addPoint(new GHPoint(52.485707, 13.435249));
         req.addPoint(new GHPoint(52.516848, 13.424606));
         // wrong count
-        req.setPointHints(Arrays.asList("", "singerstr"));
+        req.setPointHints(Arrays.asList("", "ifflandstr"));
         res = ghMatrix.route(req);
         assertTrue(res.hasErrors());
         assertEquals("Array length of point_hints must match length of points (or from/to equivalent)", res.getErrors().get(0).getMessage());
diff --git a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
index df6a5fad67..82a9261c05 100644
--- a/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
+++ b/client-hc/src/test/java/com/graphhopper/api/GraphHopperWebIT.java
@@ -34,9 +34,8 @@
 
     @Before
     public void setUp() {
-        String key = System.getProperty("graphhopper.key", KEY);
-        gh.setKey(key);
-        ghMatrix.setKey(key);
+        gh.setKey(KEY);
+        ghMatrix.setKey(KEY);
     }
 
     @Test
@@ -57,7 +56,6 @@ public void testSimpleRoute() {
         isBetween(180, 200, alt.getDescend());
         isBetween(1000, 1500, alt.getRouteWeight());
 
-
         // change vehicle
         res = gh.route(new GHRequest(49.6724, 11.3494, 49.6550, 11.4180).
                 setVehicle("bike"));
diff --git a/config-example.yml b/config-example.yml
index 67841f998f..ebebcccd84 100644
--- a/config-example.yml
+++ b/config-example.yml
@@ -91,15 +91,6 @@ graphhopper:
   routing.non_ch.max_waypoint_distance: 1000000
 
 
-
-  ##### Web #####
-
-
-  # if you want to support jsonp response type you need to add it explicitly here. By default it is disabled for stronger security.
-  # web.jsonp_allowed: true
-
-
-
   ##### Storage #####
 
 
diff --git a/core/files/docker-compose.yml b/core/files/docker-compose.yml
index ff9d1f7c7c..0a88726ecb 100644
--- a/core/files/docker-compose.yml
+++ b/core/files/docker-compose.yml
@@ -6,8 +6,7 @@ services:
         volumes:
             - ../../data:/data
         environment:
-            JETTY_PORT: 11111
-            JAVA_OPTS: "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M"
+            JAVA_OPTS: "-server -Xconcurrentio -Xmx1g -Xms1g -XX:+UseG1GC -XX:MetaspaceSize=100M -Ddw.server.applicationConnectors[0].bindHost=0.0.0.0 -Ddw.server.applicationConnectors[0].port=11111"
         ports:
             - "11111:11111"
         command: /data/europe_germany_berlin.pbf
diff --git a/core/files/findbugs-exclude.xml b/core/files/findbugs-exclude.xml
index 7c021c200f..aaea34ce60 100644
--- a/core/files/findbugs-exclude.xml
+++ b/core/files/findbugs-exclude.xml
@@ -2,4 +2,5 @@
 <FindBugsFilter>
     <!-- documentation about findbug's rule match clauses can be found here:
          http://findbugs.sourceforge.net/manual/filter.html -->
+         
 </FindBugsFilter>
\ No newline at end of file
diff --git a/core/pom.xml b/core/pom.xml
index 973b6dd543..0bfd37bedc 100644
--- a/core/pom.xml
+++ b/core/pom.xml
@@ -44,7 +44,7 @@
         <dependency>
             <groupId>com.carrotsearch</groupId>
             <artifactId>hppc</artifactId>
-            <version>0.7.2</version>
+            <version>0.8.1</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
@@ -56,7 +56,7 @@
         <dependency>
             <groupId>org.apache.xmlgraphics</groupId>
             <artifactId>xmlgraphics-commons</artifactId>
-            <version>2.1</version>
+            <version>2.3</version>
             <exclusions>
                 <exclusion>
                     <groupId>commons-logging</groupId>
@@ -94,23 +94,11 @@
     <build>
         <pluginManagement>
             <plugins>
-                <plugin>
-                    <groupId>org.apache.maven.plugins</groupId>
-                    <artifactId>maven-assembly-plugin</artifactId>
-                    <version>2.6</version>
-                    <configuration>
-                        <!-- for usage on android -->
-                        <descriptors>
-                            <descriptor>src/main/assembly/android.xml</descriptor>
-                        </descriptors>
-                    </configuration>
-                </plugin>
-
                 <!-- create jar with test classes to be reused in other projects like external or our reader-osm -->
                 <plugin>
                     <groupId>org.apache.maven.plugins</groupId>
                     <artifactId>maven-jar-plugin</artifactId>
-                    <version>3.0.2</version>
+                    <version>3.1.0</version>
                     <executions>
                         <execution>
                             <goals>
diff --git a/core/src/main/assembly/android.xml b/core/src/main/assembly/android.xml
deleted file mode 100644
index 1e663f25c3..0000000000
--- a/core/src/main/assembly/android.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
-    <id>android</id>
-    <formats>
-        <format>jar</format>
-    </formats>
-    <includeBaseDirectory>false</includeBaseDirectory>
-    <dependencySets>
-        <dependencySet>            
-            <outputDirectory>/</outputDirectory>
-            <useProjectArtifact>true</useProjectArtifact>
-            <unpack>true</unpack>
-            <scope>runtime</scope>
-            <excludes>
-                <exclude>org.apache.xmlgraphics:xmlgraphics-commons</exclude>
-            </excludes>
-        </dependencySet>
-    </dependencySets>
-</assembly>
diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index bdff2dc5e8..3ed6365439 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -514,9 +514,8 @@ public FlagEncoderFactory getFlagEncoderFactory() {
     }
 
     /**
-     * Reads configuration from a CmdArgs object. Which can be manually filled, or via main(String[]
-     * args) ala CmdArgs.read(args) or via configuration file ala
-     * CmdArgs.readFromConfig("config.properties", "graphhopper.config")
+     * Reads the configuration from a CmdArgs object which can be manually filled, or via 
+     * CmdArgs.read(String[] args)
      */
     public GraphHopper init(CmdArgs args) {
         args.merge(CmdArgs.readFromSystemProperties());
@@ -977,8 +976,7 @@ public GHResponse route(GHRequest request) {
         readLock.lock();
         try {
             if (!encodingManager.supports(vehicle))
-                throw new IllegalArgumentException("Vehicle " + vehicle + " unsupported. "
-                        + "Supported are: " + getEncodingManager());
+                throw new IllegalArgumentException("Vehicle not supported: " + vehicle + ". Supported are: " + encodingManager.toString());
 
             HintsMap hints = request.getHints();
             String tModeStr = hints.get("traversal_mode", traversalMode.toString());
diff --git a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
index fbc5fe19bf..dda4d93f6a 100644
--- a/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
+++ b/core/src/main/java/com/graphhopper/coll/GHTreeMapComposed.java
@@ -19,11 +19,12 @@
 
 import com.graphhopper.util.BitUtil;
 
+import java.util.Comparator;
 import java.util.TreeMap;
 
 /**
- * A priority queue implemented by a TreeMap. As the tree map does not allow duplicated we compose
- * the key via priority | nodeId.
+ * A priority queue for integer-float key-value pairs implemented by a TreeMap. As the tree map does not allow multiple
+ * values for the same key we store the value inside the key which is composed as value | key.
  * <p>
  *
  * @author Peter Karich
@@ -34,39 +35,60 @@
     private final TreeMap<Long, Integer> map;
 
     public GHTreeMapComposed() {
-        map = new TreeMap<>();
+        map = new TreeMap<>(new Comparator<Long>() {
+            //  we cannot just use the long sorting because the values are floats
+            @Override
+            public int compare(Long o1, Long o2) {
+                // for two entries to be equal both value and key must be equal
+                if (o1.equals(o2)) return 0;
+                int value1 = bitUtil.getIntHigh(o1);
+                int value2 = bitUtil.getIntHigh(o2);
+                if (value1 == value2) {
+                    // we enforce a deterministic order by looking at the size of the key (although there is no real
+                    // reason to prefer one entry over the other)
+                    int key1 = bitUtil.getIntLow(o1);
+                    int key2 = bitUtil.getIntLow(o2);
+                    if (key1 == key2) return 0;
+                    return key1 < key2 ? -1 : 1;
+                }
+                float f1 = Float.intBitsToFloat(value1);
+                float f2 = Float.intBitsToFloat(value2);
+                return Float.compare(f1, f2);
+            }
+        });
     }
 
     public void clear() {
         map.clear();
     }
 
-    void remove(int key, int value) {
-        long v = bitUtil.toLong(value, key);
-        if (!map.remove(v).equals(NOT_EMPTY)) {
+    void remove(int key, float value) {
+        long v = bitUtil.toLong(Float.floatToRawIntBits(value), key);
+        Integer prev = map.remove(v);
+        if (prev == null) {
             throw new IllegalStateException("cannot remove key " + key + " with value " + value
-                    + " - did you insert " + key + "," + value + " before?");
+                    + " - did you insert this key with this value before ?");
         }
     }
 
-    public void update(int key, int oldValue, int value) {
+    public void update(int key, float oldValue, float value) {
         remove(key, oldValue);
         insert(key, value);
     }
 
-    public void insert(int key, int value) {
-        long v = bitUtil.toLong(value, key);
+    public void insert(int key, float value) {
+        long v = bitUtil.toLong(Float.floatToRawIntBits(value), key);
         map.put(v, NOT_EMPTY);
     }
 
-    public int peekValue() {
+    public float peekValue() {
         long key = map.firstEntry().getKey();
-        return (int) (key >> 32);
+        return Float.intBitsToFloat(bitUtil.getIntHigh(key));
     }
 
     public int peekKey() {
         long key = map.firstEntry().getKey();
-        return (int) (key & 0xFFFFFFFFL);
+        return bitUtil.getIntLow(key);
     }
 
     /**
@@ -77,7 +99,7 @@ public int pollKey() {
             throw new IllegalStateException("Cannot poll collection is empty!");
 
         long key = map.pollFirstEntry().getKey();
-        return (int) (key & 0xFFFFFFFFL);
+        return bitUtil.getIntLow(key);
     }
 
     public int getSize() {
diff --git a/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java
new file mode 100644
index 0000000000..9ce66debd0
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/AbstractNodeContractor.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.FlagEncoder;
+import com.graphhopper.routing.weighting.AbstractWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.storage.DataAccess;
+import com.graphhopper.storage.Directory;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.util.CHEdgeExplorer;
+
+abstract class AbstractNodeContractor implements NodeContractor {
+    private final GraphHopperStorage ghStorage;
+    final CHGraph prepareGraph;
+    final FlagEncoder encoder;
+    CHEdgeExplorer inEdgeExplorer;
+    CHEdgeExplorer outEdgeExplorer;
+    private final DataAccess originalEdges;
+    int maxLevel;
+    private int maxEdgesCount;
+
+    public AbstractNodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting) {
+        this.ghStorage = ghStorage;
+        this.prepareGraph = prepareGraph;
+        this.encoder = weighting.getFlagEncoder();
+        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
+        originalEdges.create(1000);
+    }
+
+    @Override
+    public void initFromGraph() {
+        inEdgeExplorer = prepareGraph.createEdgeExplorer(DefaultEdgeFilter.inEdges(encoder));
+        outEdgeExplorer = prepareGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(encoder));
+        maxLevel = prepareGraph.getNodes();
+        maxEdgesCount = ghStorage.getAllEdges().length();
+    }
+
+    @Override
+    public void close() {
+        originalEdges.close();
+    }
+
+    boolean isContracted(int node) {
+        return prepareGraph.getLevel(node) != maxLevel;
+    }
+
+    void setOrigEdgeCount(int edgeId, int value) {
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0) {
+            // ignore setting as every normal edge has original edge count of 1
+            if (value != 1)
+                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
+                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" +
+                        prepareGraph.getAllEdges().length());
+            return;
+        }
+
+        long tmp = (long) edgeId * 4;
+        originalEdges.ensureCapacity(tmp + 4);
+        originalEdges.setInt(tmp, value);
+    }
+
+    int getOrigEdgeCount(int edgeId) {
+        edgeId -= maxEdgesCount;
+        if (edgeId < 0)
+            return 1;
+
+        long tmp = (long) edgeId * 4;
+        originalEdges.ensureCapacity(tmp + 4);
+        return originalEdges.getInt(tmp);
+    }
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
new file mode 100644
index 0000000000..44c7a59d44
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeBasedNodeContractor.java
@@ -0,0 +1,441 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.graphhopper.routing.ch;
+
+import com.graphhopper.routing.DijkstraOneToMany;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.*;
+import com.graphhopper.util.*;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import static com.graphhopper.util.Helper.nf;
+
+class NodeBasedNodeContractor extends AbstractNodeContractor {
+    private final PreparationWeighting prepareWeighting;
+    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<>();
+    private final AddShortcutHandler addScHandler = new AddShortcutHandler();
+    private final CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
+    private CHEdgeExplorer remainingEdgeExplorer;
+    private IgnoreNodeFilter ignoreNodeFilter;
+    private DijkstraOneToMany prepareAlgo;
+    private int addedShortcutsCount;
+    private long dijkstraCount;
+    private StopWatch dijkstraSW = new StopWatch();
+    // meanDegree is the number of edges / number of nodes ratio of the graph, not really the average degree, because
+    // each edge can exist in both directions
+    private double meanDegree;
+
+    NodeBasedNodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting) {
+        super(dir, ghStorage, prepareGraph, weighting);
+        this.prepareWeighting = new PreparationWeighting(weighting);
+    }
+
+    @Override
+    public void initFromGraph() {
+        super.initFromGraph();
+        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
+        final EdgeFilter allFilter = DefaultEdgeFilter.allEdges(encoder);
+        final EdgeFilter remainingNodesFilter = new LevelEdgeFilter(prepareGraph) {
+            @Override
+            public final boolean accept(EdgeIteratorState edgeState) {
+                return super.accept(edgeState) && allFilter.accept(edgeState);
+            }
+        };
+        remainingEdgeExplorer = prepareGraph.createEdgeExplorer(remainingNodesFilter);
+        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, TraversalMode.NODE_BASED);
+    }
+
+    @Override
+    public void prepareContraction() {
+        // todo: initializing meanDegree here instead of in initFromGraph() means that in the first round of calculating
+        // node priorities all shortcut searches are cancelled immediately and all possible shortcuts are counted because
+        // no witness path can be found. this is not really what we want, but changing it requires re-optimizing the
+        // graph contraction parameters, because it affects the node contraction order.
+        // when this is done there should be no need for this method any longer.
+        meanDegree = prepareGraph.getAllEdges().length() / prepareGraph.getNodes();
+    }
+
+    @Override
+    public void close() {
+        super.close();
+        prepareAlgo.close();
+    }
+
+    /**
+     * Warning: the calculated priority must NOT depend on priority(v) and therefore findShortcuts should also not
+     * depend on the priority(v). Otherwise updating the priority before contracting in contractNodes() could lead to
+     * a slowish or even endless loop.
+     */
+    @Override
+    public float calculatePriority(int node) {
+        CalcShortcutsResult calcShortcutsResult = calcShortcutCount(node);
+
+        // # huge influence: the bigger the less shortcuts gets created and the faster is the preparation
+        //
+        // every adjNode has an 'original edge' number associated. initially it is r=1
+        // when a new shortcut is introduced then r of the associated edges is summed up:
+        // r(u,w)=r(u,v)+r(v,w) now we can define
+        // originalEdgesCount = σ(v) := sum_{ (u,w) ∈ shortcuts(v) } of r(u, w)
+        int originalEdgesCount = calcShortcutsResult.originalEdgesCount;
+
+        // # lowest influence on preparation speed or shortcut creation count
+        // (but according to paper should speed up queries)
+        //
+        // number of already contracted neighbors of v
+        int contractedNeighbors = 0;
+        int degree = 0;
+        CHEdgeIterator iter = remainingEdgeExplorer.setBaseNode(node);
+        while (iter.next()) {
+            degree++;
+            if (iter.isShortcut())
+                contractedNeighbors++;
+        }
+
+        // from shortcuts we can compute the edgeDifference
+        // # low influence: with it the shortcut creation is slightly faster
+        //
+        // |shortcuts(v)| − |{(u, v) | v uncontracted}| − |{(v, w) | v uncontracted}|
+        // meanDegree is used instead of outDegree+inDegree as if one adjNode is in both directions
+        // only one bucket memory is used. Additionally one shortcut could also stand for two directions.
+        int edgeDifference = calcShortcutsResult.shortcutsCount - degree;
+
+        // according to the paper do a simple linear combination of the properties to get the priority.
+        // this is the current optimum for unterfranken:
+        return 10 * edgeDifference + originalEdgesCount + contractedNeighbors;
+    }
+
+    @Override
+    public void contractNode(int node) {
+        shortcuts.clear();
+        long degree = findShortcuts(addScHandler.setNode(node));
+        addedShortcutsCount += addShortcuts(shortcuts.keySet());
+        // put weight factor on meanDegree instead of taking the average => meanDegree is more stable
+        meanDegree = (meanDegree * 2 + degree) / 3;
+    }
+
+    @Override
+    public String getStatisticsString() {
+        return String.format(Locale.ROOT, "meanDegree: %.2f, dijkstras: %10s, mem: %10s",
+                meanDegree, nf(dijkstraCount), prepareAlgo.getMemoryUsageAsString());
+    }
+
+    /**
+     * Searches for shortcuts and calls the given handler on each shortcut that is found. The graph is not directly
+     * changed by this method.
+     * Returns the 'degree' of the handler's node (disregarding edges from/to already contracted nodes). Note that
+     * here the degree is not the total number of adjacent edges, but only the number of incoming edges
+     */
+    private long findShortcuts(ShortcutHandler sch) {
+        int maxVisitedNodes = getMaxVisitedNodesEstimate();
+        long degree = 0;
+        EdgeIterator incomingEdges = inEdgeExplorer.setBaseNode(sch.getNode());
+        // collect outgoing nodes (goal-nodes) only once
+        while (incomingEdges.next()) {
+            int fromNode = incomingEdges.getAdjNode();
+            // accept only uncontracted nodes
+            if (isContracted(fromNode))
+                continue;
+
+            final double incomingEdgeDistance = incomingEdges.getDistance();
+            double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
+            int incomingEdge = incomingEdges.getEdge();
+            int inOrigEdgeCount = getOrigEdgeCount(incomingEdge);
+            // collect outgoing nodes (goal-nodes) only once
+            EdgeIterator outgoingEdges = outEdgeExplorer.setBaseNode(sch.getNode());
+            // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
+            prepareAlgo.clear();
+            degree++;
+            while (outgoingEdges.next()) {
+                int toNode = outgoingEdges.getAdjNode();
+                // add only uncontracted nodes
+                if (isContracted(toNode) || fromNode == toNode)
+                    continue;
+
+                // Limit weight as ferries or forbidden edges can increase local search too much.
+                // If we decrease the correct weight we only explore less and introduce more shortcuts.
+                // I.e. no change to accuracy is made.
+                double existingDirectWeight = incomingEdgeWeight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
+                if (Double.isNaN(existingDirectWeight))
+                    throw new IllegalStateException("Weighting should never return NaN values"
+                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
+                            + ", dist:" + outgoingEdges.getDistance());
+
+                if (Double.isInfinite(existingDirectWeight))
+                    continue;
+
+                final double existingDistSum = incomingEdgeDistance + outgoingEdges.getDistance();
+                prepareAlgo.setWeightLimit(existingDirectWeight);
+                prepareAlgo.setMaxVisitedNodes(maxVisitedNodes);
+                prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
+
+                dijkstraSW.start();
+                dijkstraCount++;
+                int endNode = prepareAlgo.findEndNode(fromNode, toNode);
+                dijkstraSW.stop();
+
+                // compare end node as the limit could force dijkstra to finish earlier
+                if (endNode == toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
+                    // FOUND witness path, so do not add shortcut
+                    continue;
+
+                sch.foundShortcut(fromNode, toNode,
+                        existingDirectWeight, existingDistSum,
+                        outgoingEdges.getEdge(), getOrigEdgeCount(outgoingEdges.getEdge()),
+                        incomingEdge, inOrigEdgeCount);
+            }
+        }
+        return degree;
+    }
+
+    /**
+     * Adds the given shortcuts to the graph.
+     *
+     * @return the actual number of shortcuts that were added to the graph
+     */
+    private int addShortcuts(Collection<Shortcut> shortcuts) {
+        int tmpNewShortcuts = 0;
+        NEXT_SC:
+        for (Shortcut sc : shortcuts) {
+            boolean updatedInGraph = false;
+            // check if we need to update some existing shortcut in the graph
+            CHEdgeIterator iter = outEdgeExplorer.setBaseNode(sc.from);
+            while (iter.next()) {
+                if (iter.isShortcut() && iter.getAdjNode() == sc.to) {
+                    int status = iter.getMergeStatus(sc.flags);
+                    if (status == 0)
+                        continue;
+
+                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE)) {
+                        // special case if a bidirectional shortcut has worse weight and still has to be added as otherwise the opposite direction would be missing
+                        // see testShortcutMergeBug
+                        if (status == 2)
+                            break;
+
+                        continue NEXT_SC;
+                    }
+
+                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
+                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
+                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
+                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
+                                + ", sc:" + sc
+                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
+                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
+                                + ", neighbors:" + GHUtility.getNeighbors(iter));
+                    }
+
+                    // note: flags overwrite weight => call first
+                    iter.setFlags(sc.flags);
+                    iter.setWeight(sc.weight);
+                    iter.setDistance(sc.dist);
+                    iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
+                    setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
+                    updatedInGraph = true;
+                    break;
+                }
+            }
+
+            if (!updatedInGraph) {
+                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
+                // note: flags overwrite weight => call first
+                edgeState.setFlags(sc.flags);
+                edgeState.setWeight(sc.weight);
+                edgeState.setDistance(sc.dist);
+                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
+                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
+                tmpNewShortcuts++;
+            }
+        }
+        return tmpNewShortcuts;
+    }
+
+    private CalcShortcutsResult calcShortcutCount(int node) {
+        findShortcuts(calcScHandler.setNode(node));
+        return calcScHandler.calcShortcutsResult;
+    }
+
+    private String getCoords(EdgeIteratorState edge, Graph graph) {
+        NodeAccess na = graph.getNodeAccess();
+        int base = edge.getBaseNode();
+        int adj = edge.getAdjNode();
+        return base + "->" + adj + " (" + edge.getEdge() + "); "
+                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
+    }
+
+    @Override
+    public long getAddedShortcutsCount() {
+        return addedShortcutsCount;
+    }
+
+    @Override
+    public long getDijkstraCount() {
+        return dijkstraCount;
+    }
+
+    @Override
+    public float getDijkstraSeconds() {
+        return dijkstraSW.getCurrentSeconds();
+    }
+
+    private int getMaxVisitedNodesEstimate() {
+        // todo: we return 0 here if meanDegree is < 1, which is not really what we want, but changing this changes
+        // the node contraction order and requires re-optimizing the parameters of the graph contraction
+        return (int) meanDegree * 100;
+    }
+
+    private static class Shortcut {
+        int from;
+        int to;
+        int skippedEdge1;
+        int skippedEdge2;
+        double dist;
+        double weight;
+        int originalEdges;
+        long flags = PrepareEncoder.getScFwdDir();
+
+        public Shortcut(int from, int to, double weight, double dist) {
+            this.from = from;
+            this.to = to;
+            this.weight = weight;
+            this.dist = dist;
+        }
+
+        @Override
+        public int hashCode() {
+            int hash = 5;
+            hash = 23 * hash + from;
+            hash = 23 * hash + to;
+            return 23 * hash
+                    + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == null || getClass() != obj.getClass())
+                return false;
+
+            final Shortcut other = (Shortcut) obj;
+            return this.from == other.from && this.to == other.to &&
+                    Double.doubleToLongBits(this.weight) == Double.doubleToLongBits(other.weight);
+
+        }
+
+        @Override
+        public String toString() {
+            String str;
+            if (flags == PrepareEncoder.getScDirMask())
+                str = from + "<->";
+            else
+                str = from + "->";
+
+            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
+        }
+    }
+
+    private interface ShortcutHandler {
+        void foundShortcut(int fromNode, int toNode,
+                           double existingDirectWeight, double distance,
+                           int outgoingEdge, int outOrigEdgeCount,
+                           int incomingEdge, int inOrigEdgeCount);
+
+        int getNode();
+    }
+
+    private class CalcShortcutHandler implements ShortcutHandler {
+        int node;
+        CalcShortcutsResult calcShortcutsResult = new CalcShortcutsResult();
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public CalcShortcutHandler setNode(int node) {
+            this.node = node;
+            calcShortcutsResult.originalEdgesCount = 0;
+            calcShortcutsResult.shortcutsCount = 0;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int fromNode, int toNode,
+                                  double existingDirectWeight, double distance,
+                                  int outgoingEdge, int outOrigEdgeCount,
+                                  int incomingEdge, int inOrigEdgeCount) {
+            calcShortcutsResult.shortcutsCount++;
+            calcShortcutsResult.originalEdgesCount += inOrigEdgeCount + outOrigEdgeCount;
+        }
+    }
+
+    private class AddShortcutHandler implements ShortcutHandler {
+        int node;
+
+        @Override
+        public int getNode() {
+            return node;
+        }
+
+        public AddShortcutHandler setNode(int node) {
+            shortcuts.clear();
+            this.node = node;
+            return this;
+        }
+
+        @Override
+        public void foundShortcut(int fromNode, int toNode,
+                                  double existingDirectWeight, double existingDistSum,
+                                  int outgoingEdge, int outOrigEdgeCount,
+                                  int incomingEdge, int inOrigEdgeCount) {
+            // FOUND shortcut
+            // but be sure that it is the only shortcut in the collection
+            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
+            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
+            // know yet the levels so we need to determine the correct direction or if both directions
+            Shortcut sc = new Shortcut(fromNode, toNode, existingDirectWeight, existingDistSum);
+            if (shortcuts.containsKey(sc))
+                return;
+
+            Shortcut tmpSc = new Shortcut(toNode, fromNode, existingDirectWeight, existingDistSum);
+            Shortcut tmpRetSc = shortcuts.get(tmpSc);
+            // overwrite flags only if skipped edges are identical
+            if (tmpRetSc != null && tmpRetSc.skippedEdge2 == incomingEdge && tmpRetSc.skippedEdge1 == outgoingEdge) {
+                tmpRetSc.flags = PrepareEncoder.getScDirMask();
+                return;
+            }
+
+            Shortcut old = shortcuts.put(sc, sc);
+            if (old != null)
+                throw new IllegalStateException("Shortcut did not exist (" + sc + ") but was overwriting another one? " + old);
+
+            sc.skippedEdge1 = incomingEdge;
+            sc.skippedEdge2 = outgoingEdge;
+            sc.originalEdges = inOrigEdgeCount + outOrigEdgeCount;
+        }
+    }
+
+    private static class CalcShortcutsResult {
+        int originalEdgesCount;
+        int shortcutsCount;
+    }
+
+}
diff --git a/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java b/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
index 48b47280ea..5f329b0c85 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/NodeContractor.java
@@ -15,428 +15,31 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.routing.ch;
-
-import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.util.DefaultEdgeFilter;
-import com.graphhopper.routing.util.EdgeFilter;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.weighting.AbstractWeighting;
-import com.graphhopper.routing.weighting.Weighting;
-import com.graphhopper.storage.*;
-import com.graphhopper.util.*;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
-class NodeContractor {
-    private final GraphHopperStorage ghStorage;
-    private final CHGraph prepareGraph;
-    private final PreparationWeighting prepareWeighting;
-    // todo: so far node contraction can only be done for node-based graph traversal
-    private final TraversalMode traversalMode;
-    private final DataAccess originalEdges;
-    private final Map<Shortcut, Shortcut> shortcuts = new HashMap<>();
-    private final AddShortcutHandler addScHandler = new AddShortcutHandler();
-    private final CalcShortcutHandler calcScHandler = new CalcShortcutHandler();
-    private CHEdgeExplorer vehicleInExplorer;
-    private CHEdgeExplorer vehicleOutExplorer;
-    private IgnoreNodeFilter ignoreNodeFilter;
-    private DijkstraOneToMany prepareAlgo;
-    private int addedShortcutsCount;
-    private long dijkstraCount;
-    private int maxVisitedNodes = Integer.MAX_VALUE;
-    private StopWatch dijkstraSW = new StopWatch();
-    private int maxEdgesCount;
-    private int maxLevel;
-
-    NodeContractor(Directory dir, GraphHopperStorage ghStorage, CHGraph prepareGraph, Weighting weighting,
-                   TraversalMode traversalMode) {
-        if (traversalMode.isEdgeBased()) {
-            throw new IllegalArgumentException("Contraction Hierarchies only support node based traversal so far, given: " + traversalMode);
-        }
-        // todo: it would be nice to check if ghStorage is frozen here
-        this.ghStorage = ghStorage;
-        this.prepareGraph = prepareGraph;
-        this.prepareWeighting = new PreparationWeighting(weighting);
-        this.traversalMode = traversalMode;
-        originalEdges = dir.find("original_edges_" + AbstractWeighting.weightingToFileName(weighting));
-        originalEdges.create(1000);
-    }
-
-    void initFromGraph() {
-        // todo: do we really need this method ? the problem is that ghStorage/prepareGraph can potentially be modified
-        // between the constructor call and contractNode,calcShortcutCount etc. ...
-        maxLevel = prepareGraph.getNodes();
-        maxEdgesCount = ghStorage.getAllEdges().length();
-        ignoreNodeFilter = new IgnoreNodeFilter(prepareGraph, maxLevel);
-        FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
-        vehicleInExplorer = prepareGraph.createEdgeExplorer(DefaultEdgeFilter.inEdges(prepareFlagEncoder));
-        vehicleOutExplorer = prepareGraph.createEdgeExplorer(DefaultEdgeFilter.outEdges(prepareFlagEncoder));
-        prepareAlgo = new DijkstraOneToMany(prepareGraph, prepareWeighting, traversalMode);
-    }
-
-    void close() {
-        prepareAlgo.close();
-        originalEdges.close();
-    }
 
-    void setMaxVisitedNodes(int maxVisitedNodes) {
-        this.maxVisitedNodes = maxVisitedNodes;
-    }
+package com.graphhopper.routing.ch;
 
-    long contractNode(int node) {
-        shortcuts.clear();
-        long degree = findShortcuts(addScHandler.setNode(node));
-        addedShortcutsCount += addShortcuts(shortcuts.keySet());
-        return degree;
-    }
+public interface NodeContractor {
+    void initFromGraph();
 
-    CalcShortcutsResult calcShortcutCount(int node) {
-        findShortcuts(calcScHandler.setNode(node));
-        return calcScHandler.calcShortcutsResult;
-    }
+    void close();
 
     /**
-     * Searches for shortcuts and calls the given handler on each shortcut that is found. The graph is not directly
-     * changed by this method.
-     * Returns the 'degree' of the handler's node (disregarding edges from/to already contracted nodes). Note that 
-     * here the degree is not the total number of adjacent edges, but only the number of incoming edges
+     * Calculates the priority of a node without changing the graph. Lower (!!) priority nodes are contracted first.
      */
-    private long findShortcuts(ShortcutHandler sch) {
-        long degree = 0;
-        EdgeIterator incomingEdges = vehicleInExplorer.setBaseNode(sch.getNode());
-        // collect outgoing nodes (goal-nodes) only once
-        while (incomingEdges.next()) {
-            int fromNode = incomingEdges.getAdjNode();
-            // accept only uncontracted nodes
-            if (prepareGraph.getLevel(fromNode) != maxLevel)
-                continue;
-
-            final double incomingEdgeDistance = incomingEdges.getDistance();
-            double incomingEdgeWeight = prepareWeighting.calcWeight(incomingEdges, true, EdgeIterator.NO_EDGE);
-            int incomingEdge = incomingEdges.getEdge();
-            int incomingEdgeOrigCount = getOrigEdgeCount(incomingEdge);
-            // collect outgoing nodes (goal-nodes) only once
-            EdgeIterator outgoingEdges = vehicleOutExplorer.setBaseNode(sch.getNode());
-            // force fresh maps etc as this cannot be determined by from node alone (e.g. same from node but different avoidNode)
-            prepareAlgo.clear();
-            degree++;
-            while (outgoingEdges.next()) {
-                int toNode = outgoingEdges.getAdjNode();
-                // add only uncontracted nodes
-                if (prepareGraph.getLevel(toNode) != maxLevel || fromNode == toNode)
-                    continue;
-
-                // Limit weight as ferries or forbidden edges can increase local search too much.
-                // If we decrease the correct weight we only explore less and introduce more shortcuts.
-                // I.e. no change to accuracy is made.
-                double existingDirectWeight = incomingEdgeWeight + prepareWeighting.calcWeight(outgoingEdges, false, incomingEdges.getEdge());
-                if (Double.isNaN(existingDirectWeight))
-                    throw new IllegalStateException("Weighting should never return NaN values"
-                            + ", in:" + getCoords(incomingEdges, prepareGraph) + ", out:" + getCoords(outgoingEdges, prepareGraph)
-                            + ", dist:" + outgoingEdges.getDistance());
-
-                if (Double.isInfinite(existingDirectWeight))
-                    continue;
-
-                final double existingDistSum = incomingEdgeDistance + outgoingEdges.getDistance();
-                prepareAlgo.setWeightLimit(existingDirectWeight);
-                prepareAlgo.setMaxVisitedNodes(maxVisitedNodes);
-                prepareAlgo.setEdgeFilter(ignoreNodeFilter.setAvoidNode(sch.getNode()));
-
-                dijkstraSW.start();
-                dijkstraCount++;
-                int endNode = prepareAlgo.findEndNode(fromNode, toNode);
-                dijkstraSW.stop();
-
-                // compare end node as the limit could force dijkstra to finish earlier
-                if (endNode == toNode && prepareAlgo.getWeight(endNode) <= existingDirectWeight)
-                    // FOUND witness path, so do not add shortcut
-                    continue;
-
-                sch.foundShortcut(fromNode, toNode,
-                        existingDirectWeight, existingDistSum,
-                        outgoingEdges.getEdge(), getOrigEdgeCount(outgoingEdges.getEdge()),
-                        incomingEdge, incomingEdgeOrigCount);
-            }
-        }
-        return degree;
-    }
+    float calculatePriority(int node);
 
     /**
-     * Adds the given shortcuts to the graph.
-     *
-     * @return the actual number of shortcuts that were added to the graph
+     * Adds the required shortcuts for the given node.
      */
-    private int addShortcuts(Collection<Shortcut> shortcuts) {
-        int tmpNewShortcuts = 0;
-        NEXT_SC:
-        for (Shortcut sc : shortcuts) {
-            boolean updatedInGraph = false;
-            // check if we need to update some existing shortcut in the graph
-            CHEdgeIterator iter = vehicleOutExplorer.setBaseNode(sc.from);
-            while (iter.next()) {
-                if (iter.isShortcut() && iter.getAdjNode() == sc.to) {
-                    int status = iter.getMergeStatus(sc.flags);
-                    if (status == 0)
-                        continue;
-
-                    if (sc.weight >= prepareWeighting.calcWeight(iter, false, EdgeIterator.NO_EDGE)) {
-                        // special case if a bidirectional shortcut has worse weight and still has to be added as otherwise the opposite direction would be missing
-                        // see testShortcutMergeBug
-                        if (status == 2)
-                            break;
-
-                        continue NEXT_SC;
-                    }
-
-                    if (iter.getEdge() == sc.skippedEdge1 || iter.getEdge() == sc.skippedEdge2) {
-                        throw new IllegalStateException("Shortcut cannot update itself! " + iter.getEdge()
-                                + ", skipEdge1:" + sc.skippedEdge1 + ", skipEdge2:" + sc.skippedEdge2
-                                + ", edge " + iter + ":" + getCoords(iter, prepareGraph)
-                                + ", sc:" + sc
-                                + ", skippedEdge1: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge1, sc.from), prepareGraph)
-                                + ", skippedEdge2: " + getCoords(prepareGraph.getEdgeIteratorState(sc.skippedEdge2, sc.to), prepareGraph)
-                                + ", neighbors:" + GHUtility.getNeighbors(iter));
-                    }
-
-                    // note: flags overwrite weight => call first
-                    iter.setFlags(sc.flags);
-                    iter.setWeight(sc.weight);
-                    iter.setDistance(sc.dist);
-                    iter.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                    setOrigEdgeCount(iter.getEdge(), sc.originalEdges);
-                    updatedInGraph = true;
-                    break;
-                }
-            }
-
-            if (!updatedInGraph) {
-                CHEdgeIteratorState edgeState = prepareGraph.shortcut(sc.from, sc.to);
-                // note: flags overwrite weight => call first
-                edgeState.setFlags(sc.flags);
-                edgeState.setWeight(sc.weight);
-                edgeState.setDistance(sc.dist);
-                edgeState.setSkippedEdges(sc.skippedEdge1, sc.skippedEdge2);
-                setOrigEdgeCount(edgeState.getEdge(), sc.originalEdges);
-                tmpNewShortcuts++;
-            }
-        }
-        return tmpNewShortcuts;
-    }
-
-    private String getCoords(EdgeIteratorState edge, Graph graph) {
-        NodeAccess na = graph.getNodeAccess();
-        int base = edge.getBaseNode();
-        int adj = edge.getAdjNode();
-        return base + "->" + adj + " (" + edge.getEdge() + "); "
-                + na.getLat(base) + "," + na.getLon(base) + " -> " + na.getLat(adj) + "," + na.getLon(adj);
-    }
-
-    int getAddedShortcutsCount() {
-        return addedShortcutsCount;
-    }
-
-    private void setOrigEdgeCount(int edgeId, int value) {
-        edgeId -= maxEdgesCount;
-        if (edgeId < 0) {
-            // ignore setting as every normal edge has original edge count of 1
-            if (value != 1)
-                throw new IllegalStateException("Trying to set original edge count for normal edge to a value = " + value
-                        + ", edge:" + (edgeId + maxEdgesCount) + ", max:" + maxEdgesCount + ", graph.max:" +
-                        prepareGraph.getAllEdges().length());
-            return;
-        }
-
-        long tmp = (long) edgeId * 4;
-        originalEdges.ensureCapacity(tmp + 4);
-        originalEdges.setInt(tmp, value);
-    }
-
-    private int getOrigEdgeCount(int edgeId) {
-        edgeId -= maxEdgesCount;
-        if (edgeId < 0)
-            return 1;
-
-        long tmp = (long) edgeId * 4;
-        originalEdges.ensureCapacity(tmp + 4);
-        return originalEdges.getInt(tmp);
-    }
-
-    String getPrepareAlgoMemoryUsage() {
-        return prepareAlgo.getMemoryUsageAsString();
-    }
-
-    long getDijkstraCount() {
-        return dijkstraCount;
-    }
-
-    void resetDijkstraTime() {
-        dijkstraSW = new StopWatch();
-    }
-
-    float getDijkstraSeconds() {
-        return dijkstraSW.getSeconds();
-    }
-
-    static class IgnoreNodeFilter implements EdgeFilter {
-        int avoidNode;
-        int maxLevel;
-        CHGraph graph;
-
-        IgnoreNodeFilter(CHGraph chGraph, int maxLevel) {
-            this.graph = chGraph;
-            this.maxLevel = maxLevel;
-        }
-
-        IgnoreNodeFilter setAvoidNode(int node) {
-            this.avoidNode = node;
-            return this;
-        }
-
-        @Override
-        public final boolean accept(EdgeIteratorState iter) {
-            // ignore if it is skipNode or adjNode is already contracted
-            int node = iter.getAdjNode();
-            return avoidNode != node && graph.getLevel(node) == maxLevel;
-        }
-    }
-
-    static class Shortcut {
-        int from;
-        int to;
-        int skippedEdge1;
-        int skippedEdge2;
-        double dist;
-        double weight;
-        int originalEdges;
-        long flags = PrepareEncoder.getScFwdDir();
-
-        public Shortcut(int from, int to, double weight, double dist) {
-            this.from = from;
-            this.to = to;
-            this.weight = weight;
-            this.dist = dist;
-        }
-
-        @Override
-        public int hashCode() {
-            int hash = 5;
-            hash = 23 * hash + from;
-            hash = 23 * hash + to;
-            return 23 * hash
-                    + (int) (Double.doubleToLongBits(this.weight) ^ (Double.doubleToLongBits(this.weight) >>> 32));
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            if (obj == null || getClass() != obj.getClass())
-                return false;
-
-            final Shortcut other = (Shortcut) obj;
-            return this.from == other.from && this.to == other.to &&
-                    Double.doubleToLongBits(this.weight) == Double.doubleToLongBits(other.weight);
-
-        }
-
-        @Override
-        public String toString() {
-            String str;
-            if (flags == PrepareEncoder.getScDirMask())
-                str = from + "<->";
-            else
-                str = from + "->";
-
-            return str + to + ", weight:" + weight + " (" + skippedEdge1 + "," + skippedEdge2 + ")";
-        }
-    }
-
-    interface ShortcutHandler {
-        void foundShortcut(int fromNode, int toNode,
-                           double existingDirectWeight, double distance,
-                           int outgoingEdge, int outgoingEdgeOrigCount,
-                           int incomingEdge, int incomingEdgeOrigCount);
-
-        int getNode();
-    }
-
-    class CalcShortcutHandler implements ShortcutHandler {
-        int node;
-        CalcShortcutsResult calcShortcutsResult = new CalcShortcutsResult();
-
-        @Override
-        public int getNode() {
-            return node;
-        }
-
-        public CalcShortcutHandler setNode(int node) {
-            this.node = node;
-            calcShortcutsResult.originalEdgesCount = 0;
-            calcShortcutsResult.shortcutsCount = 0;
-            return this;
-        }
-
-        @Override
-        public void foundShortcut(int fromNode, int toNode,
-                                  double existingDirectWeight, double distance,
-                                  int outgoingEdge, int outgoingEdgeOrigCount,
-                                  int incomingEdge, int incomingEdgeOrigCount) {
-            calcShortcutsResult.shortcutsCount++;
-            calcShortcutsResult.originalEdgesCount += incomingEdgeOrigCount + outgoingEdgeOrigCount;
-        }
-    }
-
-    class AddShortcutHandler implements ShortcutHandler {
-        int node;
-
-        @Override
-        public int getNode() {
-            return node;
-        }
-
-        public AddShortcutHandler setNode(int node) {
-            shortcuts.clear();
-            this.node = node;
-            return this;
-        }
+    void contractNode(int node);
 
-        @Override
-        public void foundShortcut(int fromNode, int toNode,
-                                  double existingDirectWeight, double existingDistSum,
-                                  int outgoingEdge, int outgoingEdgeOrigCount,
-                                  int incomingEdge, int incomingEdgeOrigCount) {
-            // FOUND shortcut
-            // but be sure that it is the only shortcut in the collection
-            // and also in the graph for u->w. If existing AND identical weight => update setProperties.
-            // Hint: shortcuts are always one-way due to distinct level of every node but we don't
-            // know yet the levels so we need to determine the correct direction or if both directions
-            Shortcut sc = new Shortcut(fromNode, toNode, existingDirectWeight, existingDistSum);
-            if (shortcuts.containsKey(sc))
-                return;
+    long getAddedShortcutsCount();
 
-            Shortcut tmpSc = new Shortcut(toNode, fromNode, existingDirectWeight, existingDistSum);
-            Shortcut tmpRetSc = shortcuts.get(tmpSc);
-            // overwrite flags only if skipped edges are identical
-            if (tmpRetSc != null && tmpRetSc.skippedEdge2 == incomingEdge && tmpRetSc.skippedEdge1 == outgoingEdge) {
-                tmpRetSc.flags = PrepareEncoder.getScDirMask();
-                return;
-            }
+    String getStatisticsString();
 
-            Shortcut old = shortcuts.put(sc, sc);
-            if (old != null)
-                throw new IllegalStateException("Shortcut did not exist (" + sc + ") but was overwriting another one? " + old);
+    long getDijkstraCount();
 
-            sc.skippedEdge1 = incomingEdge;
-            sc.skippedEdge2 = outgoingEdge;
-            sc.originalEdges = incomingEdgeOrigCount + outgoingEdgeOrigCount;
-        }
-    }
+    float getDijkstraSeconds();
 
-    static class CalcShortcutsResult {
-        int originalEdgesCount;
-        int shortcutsCount;
-    }
+    void prepareContraction();
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
index 8988b4fdde..e00171d7c2 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/Path4CH.java
@@ -18,7 +18,6 @@
 package com.graphhopper.routing.ch;
 
 import com.graphhopper.routing.PathBidirRef;
-import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.CHEdgeIteratorState;
@@ -40,60 +39,42 @@ public Path4CH(Graph routingGraph, Graph baseGraph, Weighting weighting) {
     }
 
     @Override
-    protected final void processEdge(int tmpEdge, int endNode, int prevEdgeId) {
+    protected final void processEdge(int edgeId, int endNode, int prevEdgeId) {
         // Shortcuts do only contain valid weight so first expand before adding
         // to distance and time
-        expandEdge((CHEdgeIteratorState) routingGraph.getEdgeIteratorState(tmpEdge, endNode), false);
+        expandEdge(getEdge(edgeId, endNode), false);
     }
 
-    private void expandEdge(CHEdgeIteratorState mainEdgeState, boolean reverse) {
-        if (!mainEdgeState.isShortcut()) {
-            distance += mainEdgeState.getDistance();
-            time += weighting.calcMillis(mainEdgeState, reverse, EdgeIterator.NO_EDGE);
-            addEdge(mainEdgeState.getEdge());
+    private void expandEdge(CHEdgeIteratorState edge, boolean reverse) {
+        if (!edge.isShortcut()) {
+            distance += edge.getDistance();
+            time += weighting.calcMillis(edge, reverse, EdgeIterator.NO_EDGE);
+            addEdge(edge.getEdge());
             return;
         }
+        expandSkippedEdges(edge.getSkippedEdge1(), edge.getSkippedEdge2(), edge.getBaseNode(), edge.getAdjNode(), reverse);
+    }
 
-        int skippedEdge1 = mainEdgeState.getSkippedEdge1();
-        int skippedEdge2 = mainEdgeState.getSkippedEdge2();
-        int from = mainEdgeState.getBaseNode(), to = mainEdgeState.getAdjNode();
-
+    private void expandSkippedEdges(int skippedEdge1, int skippedEdge2, int from, int to, boolean reverse) {
         // get properties like speed of the edge in the correct direction
-        if (reverse) {
+        if (reverseOrder == reverse) {
             int tmp = from;
             from = to;
             to = tmp;
         }
 
         // getEdgeProps could possibly return an empty edge if the shortcut is available for both directions
-        if (reverseOrder) {
-            CHEdgeIteratorState edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
-            boolean empty = edgeState == null;
-            if (empty)
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
-
-            expandEdge(edgeState, false);
-
-            if (empty)
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
-            else
-                edgeState = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
-
-            expandEdge(edgeState, true);
+        CHEdgeIteratorState sk2to = getEdge(skippedEdge2, to);
+        if (sk2to != null) {
+            expandEdge(sk2to, !reverseOrder);
+            expandEdge(getEdge(skippedEdge1, from), reverseOrder);
         } else {
-            CHEdgeIteratorState iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, from);
-            boolean empty = iter == null;
-            if (empty)
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, from);
-
-            expandEdge(iter, true);
-
-            if (empty)
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge1, to);
-            else
-                iter = (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(skippedEdge2, to);
-
-            expandEdge(iter, false);
+            expandEdge(getEdge(skippedEdge1, to), !reverseOrder);
+            expandEdge(getEdge(skippedEdge2, from), reverseOrder);
         }
     }
+
+    private CHEdgeIteratorState getEdge(int edgeId, int adjNode) {
+        return (CHEdgeIteratorState) routingGraph.getEdgeIteratorState(edgeId, adjNode);
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
index 8629ec3dc9..31b993fc8c 100644
--- a/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
+++ b/core/src/main/java/com/graphhopper/routing/ch/PrepareContractionHierarchies.java
@@ -22,11 +22,15 @@
 import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
-import com.graphhopper.util.*;
+import com.graphhopper.util.CHEdgeExplorer;
+import com.graphhopper.util.CHEdgeIterator;
+import com.graphhopper.util.Helper;
+import com.graphhopper.util.StopWatch;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.*;
+import java.util.Locale;
+import java.util.Random;
 
 import static com.graphhopper.util.Helper.nf;
 import static com.graphhopper.util.Parameters.Algorithms.ASTAR_BI;
@@ -55,25 +59,24 @@
     private final CHGraphImpl prepareGraph;
     private final Random rand = new Random(123);
     private final StopWatch allSW = new StopWatch();
+    private final StopWatch periodicUpdateSW = new StopWatch();
+    private final StopWatch lazyUpdateSW = new StopWatch();
+    private final StopWatch neighborUpdateSW = new StopWatch();
+    private final StopWatch contractionSW = new StopWatch();
     private NodeContractor nodeContractor;
     private CHEdgeExplorer vehicleAllExplorer;
     private CHEdgeExplorer vehicleAllTmpExplorer;
-    private CHEdgeExplorer calcPrioAllExplorer;
     private int maxLevel;
     // nodes with highest priority come last
     private GHTreeMapComposed sortedNodes;
-    private int oldPriorities[];
-    private double meanDegree;
+    private float oldPriorities[];
     private int periodicUpdatesPercentage = 20;
     private int lastNodesLazyUpdatePercentage = 10;
     private int neighborUpdatePercentage = 20;
     private double nodesContractedPercentage = 100;
     private double logMessagesPercentage = 20;
-    private double dijkstraTime;
-    private double periodTime;
-    private double lazyTime;
-    private double neighborTime;
     private int initSize;
+    private int checkCounter;
 
     public PrepareContractionHierarchies(Directory dir, GraphHopperStorage ghStorage, CHGraph chGraph,
                                          Weighting weighting, TraversalMode traversalMode) {
@@ -165,14 +168,13 @@ public void doSpecificWork() {
 
         logger.info("took:" + (int) allSW.stop().getSeconds() + "s "
                 + ", new shortcuts: " + nf(nodeContractor.getAddedShortcutsCount())
-                + ", " + prepareWeighting
-                + ", dijkstras:" + nf(nodeContractor.getDijkstraCount())
-                + ", " + getTimesAsString()
-                + ", meanDegree:" + (long) meanDegree
                 + ", initSize:" + nf(initSize)
+                + ", " + prepareWeighting
                 + ", periodic:" + periodicUpdatesPercentage
                 + ", lazy:" + lastNodesLazyUpdatePercentage
                 + ", neighbor:" + neighborUpdatePercentage
+                + ", " + getTimesAsString()
+                + ", lazy-overhead: " + (int) (100 * ((checkCounter / (double) initSize) - 1)) + "%"
                 + ", " + Helper.getMemInfo());
 
         int edgeCount = ghStorage.getAllEdges().length();
@@ -188,42 +190,34 @@ protected void runGraphContraction() {
 
     @Override
     public RoutingAlgorithm createAlgo(Graph graph, AlgorithmOptions opts) {
-        AbstractBidirAlgo algo;
+        AbstractBidirAlgo algo = doCreateAlgo(graph, opts);
+        algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
+        algo.setMaxVisitedNodes(opts.getMaxVisitedNodes());
+        return algo;
+    }
+
+    private AbstractBidirAlgo doCreateAlgo(Graph graph, AlgorithmOptions opts) {
         if (ASTAR_BI.equals(opts.getAlgorithm())) {
-            AStarBidirection tmpAlgo = new AStarBidirectionCH(graph, prepareWeighting, traversalMode);
-            tmpAlgo.setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
-            algo = tmpAlgo;
+            return new AStarBidirectionCH(graph, prepareWeighting, traversalMode)
+                    .setApproximation(RoutingAlgorithmFactorySimple.getApproximation(ASTAR_BI, opts, graph.getNodeAccess()));
         } else if (DIJKSTRA_BI.equals(opts.getAlgorithm())) {
             if (opts.getHints().getBool("stall_on_demand", true)) {
-                algo = new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
+                return new DijkstraBidirectionCH(graph, prepareWeighting, traversalMode);
             } else {
-                algo = new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
+                return new DijkstraBidirectionCHNoSOD(graph, prepareWeighting, traversalMode);
             }
         } else {
             throw new IllegalArgumentException("Algorithm " + opts.getAlgorithm() + " not supported for Contraction Hierarchies. Try with ch.disable=true");
         }
-
-        algo.setMaxVisitedNodes(opts.getMaxVisitedNodes());
-        algo.setEdgeFilter(new LevelEdgeFilter(prepareGraph));
-        return algo;
     }
 
     private void initFromGraph() {
         ghStorage.freeze();
         FlagEncoder prepareFlagEncoder = prepareWeighting.getFlagEncoder();
         final EdgeFilter allFilter = DefaultEdgeFilter.allEdges(prepareFlagEncoder);
-        // filter by vehicle and level number
-        final EdgeFilter accessWithLevelFilter = new LevelEdgeFilter(prepareGraph) {
-            @Override
-            public final boolean accept(EdgeIteratorState edgeState) {
-                return super.accept(edgeState) && allFilter.accept(edgeState);
-            }
-        };
-
         maxLevel = prepareGraph.getNodes();
         vehicleAllExplorer = prepareGraph.createEdgeExplorer(allFilter);
         vehicleAllTmpExplorer = prepareGraph.createEdgeExplorer(allFilter);
-        calcPrioAllExplorer = prepareGraph.createEdgeExplorer(accessWithLevelFilter);
 
         // Use an alternative to PriorityQueue as it has some advantages:
         //   1. Gets automatically smaller if less entries are stored => less total RAM used.
@@ -231,8 +225,8 @@ public final boolean accept(EdgeIteratorState edgeState) {
         //   2. is slightly faster
         //   but we need the additional oldPriorities array to keep the old value which is necessary for the update method
         sortedNodes = new GHTreeMapComposed();
-        oldPriorities = new int[prepareGraph.getNodes()];
-        nodeContractor = new NodeContractor(dir, ghStorage, prepareGraph, weighting, traversalMode);
+        oldPriorities = new float[prepareGraph.getNodes()];
+        nodeContractor = new NodeBasedNodeContractor(dir, ghStorage, prepareGraph, weighting);
         nodeContractor.initFromGraph();
     }
 
@@ -241,26 +235,21 @@ private boolean prepareNodes() {
         for (int node = 0; node < nodes; node++) {
             prepareGraph.setLevel(node, maxLevel);
         }
-
+        periodicUpdateSW.start();
         for (int node = 0; node < nodes; node++) {
-            int priority = oldPriorities[node] = calculatePriority(node);
+            float priority = oldPriorities[node] = calculatePriority(node);
             sortedNodes.insert(node, priority);
         }
+        periodicUpdateSW.stop();
 
         return !sortedNodes.isEmpty();
     }
 
     private void contractNodes() {
-        // meanDegree is the number of edges / number of nodes ratio of the graph, not really the average degree, because
-        // each edge can exist in both directions
-        // todo: initializing meanDegree here instead of in initFromGraph() means that in the first round of calculating
-        // node priorities all shortcut searches are cancelled immediately and all possible shortcuts are counted because
-        // no witness path can be found. this is not really what we want, but changing it requires re-optimizing the
-        // graph contraction parameters, because it affects the node contraction order.
-        meanDegree = prepareGraph.getAllEdges().length() / prepareGraph.getNodes();
+        nodeContractor.prepareContraction();
         initSize = sortedNodes.getSize();
         int level = 0;
-        long counter = 0;
+        checkCounter = 0;
         long logSize = Math.round(Math.max(10, initSize / 100d * logMessagesPercentage));
         if (logMessagesPercentage == 0)
             logSize = Integer.MAX_VALUE;
@@ -268,7 +257,6 @@ private void contractNodes() {
         // preparation takes longer but queries are slightly faster with preparation
         // => enable it but call not so often
         boolean periodicUpdate = true;
-        StopWatch periodSW = new StopWatch();
         int updateCounter = 0;
         long periodicUpdatesCount = Math.round(Math.max(10, sortedNodes.getSize() / 100d * periodicUpdatesPercentage));
         if (periodicUpdatesPercentage == 0)
@@ -281,7 +269,6 @@ private void contractNodes() {
         // according to paper "Polynomial-time Construction of Contraction Hierarchies for Multi-criteria Objectives" by Funke and Storandt
         // we don't need to wait for all nodes to be contracted
         long nodesToAvoidContract = Math.round((100 - nodesContractedPercentage) / 100d * sortedNodes.getSize());
-        StopWatch lazySW = new StopWatch();
 
         // Recompute priority of uncontracted neighbors.
         // Without neighbor updates preparation is faster but we need them
@@ -290,62 +277,49 @@ private void contractNodes() {
         if (neighborUpdatePercentage == 0)
             neighborUpdate = false;
 
-        StopWatch neighborSW = new StopWatch();
         while (!sortedNodes.isEmpty()) {
             // periodically update priorities of ALL nodes
-            if (periodicUpdate && counter > 0 && counter % periodicUpdatesCount == 0) {
-                periodSW.start();
+            if (periodicUpdate && checkCounter > 0 && checkCounter % periodicUpdatesCount == 0) {
+                periodicUpdateSW.start();
                 sortedNodes.clear();
-                int len = prepareGraph.getNodes();
-                for (int node = 0; node < len; node++) {
+                for (int node = 0; node < prepareGraph.getNodes(); node++) {
                     if (prepareGraph.getLevel(node) != maxLevel)
                         continue;
 
-                    int priority = oldPriorities[node] = calculatePriority(node);
+                    float priority = oldPriorities[node] = calculatePriority(node);
                     sortedNodes.insert(node, priority);
                 }
-                periodSW.stop();
+                periodicUpdateSW.stop();
                 updateCounter++;
                 if (sortedNodes.isEmpty())
                     throw new IllegalStateException("Cannot prepare as no unprepared nodes where found. Called preparation twice?");
             }
 
-            if (counter % logSize == 0) {
-                dijkstraTime += nodeContractor.getDijkstraSeconds();
-                periodTime += periodSW.getSeconds();
-                lazyTime += lazySW.getSeconds();
-                neighborTime += neighborSW.getSeconds();
-
-                logStats(counter, updateCounter);
-
-                nodeContractor.resetDijkstraTime();
-                periodSW = new StopWatch();
-                lazySW = new StopWatch();
-                neighborSW = new StopWatch();
+            if (checkCounter % logSize == 0) {
+                logStats(updateCounter);
             }
 
-            counter++;
+            checkCounter++;
             int polledNode = sortedNodes.pollKey();
 
             if (!sortedNodes.isEmpty() && sortedNodes.getSize() < lastNodesLazyUpdates) {
-                lazySW.start();
-                int priority = oldPriorities[polledNode] = calculatePriority(polledNode);
+                lazyUpdateSW.start();
+                float priority = oldPriorities[polledNode] = calculatePriority(polledNode);
                 if (priority > sortedNodes.peekValue()) {
                     // current node got more important => insert as new value and contract it later
                     sortedNodes.insert(polledNode, priority);
-                    lazySW.stop();
+                    lazyUpdateSW.stop();
                     continue;
                 }
-                lazySW.stop();
+                lazyUpdateSW.stop();
             }
 
             // contract node v!
-            nodeContractor.setMaxVisitedNodes(getMaxVisitedNodesEstimate());
-            long degree = nodeContractor.contractNode(polledNode);
-            // put weight factor on meanDegree instead of taking the average => meanDegree is more stable
-            meanDegree = (meanDegree * 2 + degree) / 3;
+            contractionSW.start();
+            nodeContractor.contractNode(polledNode);
             prepareGraph.setLevel(polledNode, level);
             level++;
+            contractionSW.stop();
 
             if (sortedNodes.getSize() < nodesToAvoidContract)
                 // skipped nodes are already set to maxLevel
@@ -363,24 +337,20 @@ private void contractNodes() {
                     continue;
 
                 if (neighborUpdate && rand.nextInt(100) < neighborUpdatePercentage) {
-                    neighborSW.start();
-                    int oldPrio = oldPriorities[nn];
-                    int priority = oldPriorities[nn] = calculatePriority(nn);
+                    neighborUpdateSW.start();
+                    float oldPrio = oldPriorities[nn];
+                    float priority = oldPriorities[nn] = calculatePriority(nn);
                     if (priority != oldPrio)
                         sortedNodes.update(nn, oldPrio, priority);
 
-                    neighborSW.stop();
+                    neighborUpdateSW.stop();
                 }
 
                 prepareGraph.disconnect(vehicleAllTmpExplorer, iter);
             }
         }
 
-        dijkstraTime += nodeContractor.getDijkstraSeconds();
-        periodTime += periodSW.getSeconds();
-        lazyTime += lazySW.getSeconds();
-        neighborTime += neighborSW.getSeconds();
-        logStats(counter, updateCounter);
+        logStats(updateCounter);
 
         // Preparation works only once so we can release temporary data.
         // The preparation object itself has to be intact to create the algorithm.
@@ -397,24 +367,20 @@ public long getDijkstraCount() {
         return nodeContractor.getDijkstraCount();
     }
 
-    public int getShortcuts() {
+    public long getShortcuts() {
         return nodeContractor.getAddedShortcutsCount();
     }
 
     public double getLazyTime() {
-        return lazyTime;
+        return lazyUpdateSW.getCurrentSeconds();
     }
 
     public double getPeriodTime() {
-        return periodTime;
-    }
-
-    public double getDijkstraTime() {
-        return dijkstraTime;
+        return periodicUpdateSW.getCurrentSeconds();
     }
 
     public double getNeighborTime() {
-        return neighborTime;
+        return neighborUpdateSW.getCurrentSeconds();
     }
 
     public Weighting getWeighting() {
@@ -422,59 +388,21 @@ public Weighting getWeighting() {
     }
 
     private String getTimesAsString() {
+        float totalTime = allSW.getCurrentSeconds();
+        float periodicUpdateTime = periodicUpdateSW.getCurrentSeconds();
+        float lazyUpdateTime = lazyUpdateSW.getCurrentSeconds();
+        float neighborUpdateTime = neighborUpdateSW.getCurrentSeconds();
+        float contractionTime = contractionSW.getCurrentSeconds();
+        float otherTime = totalTime - (periodicUpdateTime + lazyUpdateTime + neighborUpdateTime + contractionTime);
+        // dijkstra time is included in the others
+        float dijkstraTime = nodeContractor.getDijkstraSeconds();
         return String.format(Locale.ROOT,
-                "t(dijk): %6.2f, t(period): %6.2f, t(lazy): %6.2f, t(neighbor): %6.2f",
-                dijkstraTime, periodTime, lazyTime, neighborTime);
-    }
-
-    /**
-     * Calculates the priority of a node v without changing the graph. Warning: the calculated
-     * priority must NOT depend on priority(v) and therefore findShortcuts should also not depend on
-     * the priority(v). Otherwise updating the priority before contracting in contractNodes() could
-     * lead to a slowish or even endless loop.
-     */
-    private int calculatePriority(int node) {
-        nodeContractor.setMaxVisitedNodes(getMaxVisitedNodesEstimate());
-        NodeContractor.CalcShortcutsResult calcShortcutsResult = nodeContractor.calcShortcutCount(node);
-
-        // # huge influence: the bigger the less shortcuts gets created and the faster is the preparation
-        //
-        // every adjNode has an 'original edge' number associated. initially it is r=1
-        // when a new shortcut is introduced then r of the associated edges is summed up:
-        // r(u,w)=r(u,v)+r(v,w) now we can define
-        // originalEdgesCount = σ(v) := sum_{ (u,w) ∈ shortcuts(v) } of r(u, w)
-        int originalEdgesCount = calcShortcutsResult.originalEdgesCount;
-
-        // # lowest influence on preparation speed or shortcut creation count
-        // (but according to paper should speed up queries)
-        //
-        // number of already contracted neighbors of v
-        int contractedNeighbors = 0;
-        int degree = 0;
-        CHEdgeIterator iter = calcPrioAllExplorer.setBaseNode(node);
-        while (iter.next()) {
-            degree++;
-            if (iter.isShortcut())
-                contractedNeighbors++;
-        }
-
-        // from shortcuts we can compute the edgeDifference
-        // # low influence: with it the shortcut creation is slightly faster
-        //
-        // |shortcuts(v)| − |{(u, v) | v uncontracted}| − |{(v, w) | v uncontracted}|
-        // meanDegree is used instead of outDegree+inDegree as if one adjNode is in both directions
-        // only one bucket memory is used. Additionally one shortcut could also stand for two directions.
-        int edgeDifference = calcShortcutsResult.shortcutsCount - degree;
-
-        // according to the paper do a simple linear combination of the properties to get the priority.
-        // this is the current optimum for unterfranken:
-        return 10 * edgeDifference + originalEdgesCount + contractedNeighbors;
+                "t(total): %6.2f,  t(period): %6.2f, t(lazy): %6.2f, t(neighbor): %6.2f, t(contr): %6.2f, t(other) : %6.2f, t(dijk): %6.2f",
+                totalTime, periodicUpdateTime, lazyUpdateTime, neighborUpdateTime, contractionTime, otherTime, dijkstraTime);
     }
 
-    private int getMaxVisitedNodesEstimate() {
-        // todo: we return 0 here if meanDegree is < 1, which is not really what we want, but changing this changes
-        // the node contraction order and requires re-optimizing the parameters of the graph contraction
-        return (int) meanDegree * 100;
+    private float calculatePriority(int node) {
+        return nodeContractor.calculatePriority(node);
     }
 
     @Override
@@ -482,12 +410,15 @@ public String toString() {
         return "prepare|dijkstrabi|ch";
     }
 
-    private void logStats(long counter, int updateCounter) {
+    private void logStats(int updateCounter) {
         logger.info(String.format(Locale.ROOT,
-                "%10s, updates: %2d, nodes: %10s, shortcuts: %10s, dijkstras: %10s, %s, meanDegree: %2d, %s, %s",
-                nf(counter), updateCounter, nf(sortedNodes.getSize()),
-                nf(nodeContractor.getAddedShortcutsCount()), nf(nodeContractor.getDijkstraCount()),
-                getTimesAsString(), (long) meanDegree, nodeContractor.getPrepareAlgoMemoryUsage(),
+                "nodes: %10s, shortcuts: %10s, updates: %2d, checked-nodes: %10s, %s, %s, %s",
+                nf(sortedNodes.getSize()),
+                nf(nodeContractor.getAddedShortcutsCount()),
+                updateCounter,
+                nf(checkCounter),
+                getTimesAsString(),
+                nodeContractor.getStatisticsString(),
                 Helper.getMemInfo()));
     }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
index 826b979359..0c97372fee 100644
--- a/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
+++ b/core/src/main/java/com/graphhopper/routing/lm/LandmarkStorage.java
@@ -823,7 +823,7 @@ public void apply(int nodeId, SPTEntry b) {
             if ((double) maxedout.get() / map.size() > 0.1) {
                 LOGGER.warn("landmark " + lmIdx + " (" + nodeAccess.getLatitude(lmNodeId) + "," + nodeAccess.getLongitude(lmNodeId) + "): " +
                         "too many weights were maxed out (" + maxedout.get() + "/" + map.size() + "). Use a bigger factor than " + lms.factor
-                        + ". For example use the following in the config.properties: weighting=" + weighting.getName() + "|maximum=" + finalMaxWeight.getValue() * 1.2);
+                        + ". For example use the following in the config.yml: weighting=" + weighting.getName() + "|maximum=" + finalMaxWeight.getValue() * 1.2);
             }
         }
     }
diff --git a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
index 9fb185cbb4..9d2d91462c 100644
--- a/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
+++ b/core/src/main/java/com/graphhopper/routing/util/AbstractFlagEncoder.java
@@ -70,9 +70,6 @@
     // This value determines the maximal possible speed of any road regardless the maxspeed value
     // lower values allow more compact representation of the routing graph
     protected int maxPossibleSpeed;
-    /* processing properties (to be initialized lazy when needed) */
-    protected EdgeExplorer edgeOutExplorer;
-    protected EdgeExplorer edgeInExplorer;
     /* Edge Flag Encoder fields */
     private long nodeBitMask;
     private long wayBitMask;
diff --git a/core/src/main/java/com/graphhopper/search/Geocoding.java b/core/src/main/java/com/graphhopper/routing/util/IgnoreNodeFilter.java
similarity index 51%
rename from core/src/main/java/com/graphhopper/search/Geocoding.java
rename to core/src/main/java/com/graphhopper/routing/util/IgnoreNodeFilter.java
index cbfce2c9a6..9e1bf9fd9d 100644
--- a/core/src/main/java/com/graphhopper/search/Geocoding.java
+++ b/core/src/main/java/com/graphhopper/routing/util/IgnoreNodeFilter.java
@@ -15,21 +15,30 @@
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  */
-package com.graphhopper.search;
+package com.graphhopper.routing.util;
 
-import com.graphhopper.util.shapes.GHPlace;
+import com.graphhopper.storage.CHGraph;
+import com.graphhopper.util.EdgeIteratorState;
 
-import java.util.List;
+public class IgnoreNodeFilter implements EdgeFilter {
+    private int avoidNode;
+    private CHGraph graph;
+    private int maxLevel;
 
-/**
- * Interface to convert from place names to points.
- * <p>
- *
- * @author Peter Karich
- */
-public interface Geocoding {
-    /**
-     * Returns a list of matching points for the specified place query string.
-     */
-    List<GHPlace> names2places(GHPlace... place);
+    public IgnoreNodeFilter(CHGraph chGraph, int maxLevel) {
+        this.graph = chGraph;
+        this.maxLevel = maxLevel;
+    }
+
+    public IgnoreNodeFilter setAvoidNode(int node) {
+        this.avoidNode = node;
+        return this;
+    }
+
+    @Override
+    public final boolean accept(EdgeIteratorState iter) {
+        // ignore if it is skipNode or adjNode is already contracted
+        int node = iter.getAdjNode();
+        return avoidNode != node && graph.getLevel(node) == maxLevel;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java b/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
deleted file mode 100644
index fb09949704..0000000000
--- a/core/src/main/java/com/graphhopper/search/ReverseGeocoding.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.search;
-
-import com.graphhopper.util.shapes.GHPlace;
-
-import java.util.List;
-
-/**
- * Interface to convert from points to place names or node ids.
- * <p>
- *
- * @author Peter Karich
- */
-public interface ReverseGeocoding {
-    /**
-     * Tries to retrieve a locational string from the specified points (list of lat,lon).
-     */
-    List<GHPlace> places2names(GHPlace... points);
-}
diff --git a/core/src/main/java/com/graphhopper/storage/BaseGraph.java b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
index 9f62a9dc76..2adbf52393 100644
--- a/core/src/main/java/com/graphhopper/storage/BaseGraph.java
+++ b/core/src/main/java/com/graphhopper/storage/BaseGraph.java
@@ -32,6 +32,8 @@
 
 import static com.graphhopper.util.Helper.nf;
 
+import java.util.Locale;
+
 /**
  * The base graph handles nodes and edges file format. It can be used with different Directory
  * implementations like RAMDirectory for fast access or via MMapDirectory for virtual-memory and not
@@ -375,6 +377,35 @@ String toDetailsString() {
                 + "bounds:" + bounds;
     }
 
+    public void debugPrint() {
+        final int printMax = 100;
+        System.out.println("nodes:");
+        String formatNodes = "%12s | %12s | %12s | %12s \n";
+        System.out.format(Locale.ROOT, formatNodes, "#", "N_EDGE_REF", "N_LAT", "N_LON");
+        NodeAccess nodeAccess = getNodeAccess();
+        for (int i = 0; i < Math.min(nodeCount, printMax); ++i) {
+            System.out.format(Locale.ROOT, formatNodes, i, edgeAccess.getEdgeRef(i), nodeAccess.getLat(i), nodeAccess.getLon(i));
+        }
+        if (nodeCount > printMax) {
+            System.out.format(Locale.ROOT, " ... %d more nodes\n", nodeCount - printMax);
+        }
+        System.out.println("edges:");
+        String formatEdges = "%12s | %12s | %12s | %12s | %12s | %12s | %12s \n";
+        System.out.format(Locale.ROOT, formatEdges, "#", "E_NODEA", "E_NODEB", "E_LINKA", "E_LINKB", "E_DIST", "E_FLAGS");
+        for (int i = 0; i < Math.min(edgeCount, printMax); ++i) {
+            System.out.format(Locale.ROOT, formatEdges, i,
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_NODEA),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_NODEB),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_LINKA),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_LINKB),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_DIST),
+                    edges.getInt((long) (i * edgeEntryBytes) + edgeAccess.E_FLAGS));
+        }
+        if (edgeCount > printMax) {
+            System.out.printf(Locale.ROOT, " ... %d more edges", edgeCount - printMax);
+        }
+    }
+
     void flush() {
         setNodesHeader();
         setEdgesHeader();
diff --git a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
index 067bf08da4..c9b69f8e88 100644
--- a/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/NativeFSLockFactory.java
@@ -107,7 +107,7 @@ public synchronized boolean tryLock() {
             // on-the-fly: make sure directory exists
             if (!lockDir.exists()) {
                 if (!lockDir.mkdirs())
-                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
+                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot be created to place lock file there: " + lockFile);
             }
 
             if (!lockDir.isDirectory())
diff --git a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
index 1e18b1eece..a337175edc 100644
--- a/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
+++ b/core/src/main/java/com/graphhopper/storage/SimpleFSLockFactory.java
@@ -76,7 +76,7 @@ public synchronized boolean tryLock() {
             // make sure directory exists, do it on-the-fly (not possible when setLockDir is called)
             if (!lockDir.exists()) {
                 if (!lockDir.mkdirs())
-                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot created to place lock file there: " + lockFile);
+                    throw new RuntimeException("Directory " + lockDir + " does not exist and cannot be created to place lock file there: " + lockFile);
             }
 
             // this test can only be performed after the dir has created!
diff --git a/core/src/main/java/com/graphhopper/util/StopWatch.java b/core/src/main/java/com/graphhopper/util/StopWatch.java
index a597a096d1..8d7007cada 100644
--- a/core/src/main/java/com/graphhopper/util/StopWatch.java
+++ b/core/src/main/java/com/graphhopper/util/StopWatch.java
@@ -25,7 +25,7 @@
  */
 public class StopWatch {
     private long lastTime;
-    private long nanoTime;
+    private long elapsedNanos;
     private String name = "";
 
     public StopWatch(String name) {
@@ -49,20 +49,32 @@ public StopWatch stop() {
         if (lastTime < 0)
             return this;
 
-        nanoTime += System.nanoTime() - lastTime;
+        elapsedNanos += System.nanoTime() - lastTime;
         lastTime = -1;
         return this;
     }
 
+    public float getSeconds() {
+        return elapsedNanos / 1e9f;
+    }
+
     /**
-     * @return the time delta in milliseconds
+     * returns the total elapsed time on this stopwatch without the need of stopping it
      */
-    public long getTime() {
-        return nanoTime / 1_000_000;
+    public float getCurrentSeconds() {
+        if (notStarted()) {
+            return 0;
+        }
+        long lastNanos = lastTime < 0 ? 0 : System.nanoTime() - lastTime;
+        return (elapsedNanos + lastNanos) / 1e9f;
+    }
+
+    public long getMillis() {
+        return elapsedNanos / 1_000_000;
     }
 
     public long getNanos() {
-        return nanoTime;
+        return elapsedNanos;
     }
 
     @Override
@@ -75,7 +87,7 @@ public String toString() {
         return str + "time:" + getSeconds();
     }
 
-    public float getSeconds() {
-        return nanoTime / 1e9f;
+    private boolean notStarted() {
+        return lastTime == 0 && elapsedNanos == 0;
     }
 }
diff --git a/core/src/main/resources/com/graphhopper/util/ar.txt b/core/src/main/resources/com/graphhopper/util/ar.txt
index 9f7213dff4..2001ff7a2e 100644
--- a/core/src/main/resources/com/graphhopper/util/ar.txt
+++ b/core/src/main/resources/com/graphhopper/util/ar.txt
@@ -1,7 +1,7 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
 continue=استمر
-continue_onto=%1$s استمر في 
+continue_onto=استمر في %1$s 
 turn_left=اتجه يساراً
 turn_right=اتجه يميناً
 turn_slight_left=إستدر لليسار قليلا
@@ -10,7 +10,7 @@ turn_sharp_left=اتجه قليلاً لليسار
 turn_sharp_right=اتجه قليلاً لليمين
 keep_left=احفظ الشمال
 keep_right=احفظ اليمين
-turn_onto=%1$s خلال %1$s
+turn_onto=%1$s خلال %2$s
 u_turn=الدوران للإتجاه المعاكس
 unknown=علامة غير معرفة  '%1$s' 
 web.search_button=ابحث
@@ -20,7 +20,7 @@ web.to_hint=إلي
 web.more_button=المزيد
 web.gpx_export_button=GPX التصدير
 web.route_info=%1$s ستاخذ %2$s
-web.pt_route_info=وصول سعت %1$s من خلال %2$s انتقال (%3$s)
+web.pt_route_info=وصول سعت %1$s مع %2$s انتقال (%3$s)
 web.pt_route_info_walking=الوصول عند %1$s مشياً (%2$s)
 web.locations_not_found=لا يوجد طريق من هذه المنطقة
 web.bike=دراجة
diff --git a/core/src/main/resources/com/graphhopper/util/eo.txt b/core/src/main/resources/com/graphhopper/util/eo.txt
index f18e6d98ce..f58d542327 100644
--- a/core/src/main/resources/com/graphhopper/util/eo.txt
+++ b/core/src/main/resources/com/graphhopper/util/eo.txt
@@ -11,8 +11,8 @@ turn_sharp_right=turniĝegu dekstren
 keep_left=veturu ĉe maldekstra flanko
 keep_right=veturu ĉe dekstra fllanko
 turn_onto=%1$s al %2$s
-u_turn=faru ĝiradon U-forma
-unknown=nekonata instrukcio ‘%1$s’
+u_turn=turniĝu malantaŭen
+unknown=nekonata instrukcio “%1$s”
 web.search_button=Serĉi
 web.from_hint=El
 web.via_hint=Tra
diff --git a/core/src/main/resources/com/graphhopper/util/hu_HU.txt b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
index 0cde07e4b0..bb38a659d5 100644
--- a/core/src/main/resources/com/graphhopper/util/hu_HU.txt
+++ b/core/src/main/resources/com/graphhopper/util/hu_HU.txt
@@ -1,79 +1,79 @@
 # do not edit manually, instead use spreadsheet https://t.co/f086oJXAEI and script ./core/files/update-translations.sh
 
-continue=Haladjon tovább
-continue_onto=%1$s haladjon tovább
-turn_left=Forduljon balra
-turn_right=Forduljon jobbra
-turn_slight_left=Forduljon enyhén balra
-turn_slight_right=Forduljon enyhén jobbra
-turn_sharp_left=Forduljon élesen balra
-turn_sharp_right=Forduljon élesen jobbra
-keep_left=
-keep_right=
-turn_onto=%1$s forduljon be %2$s
-u_turn=
-unknown=
+continue=haladjon tovább
+continue_onto=haladjon tovább erre: %1$s
+turn_left=forduljon balra
+turn_right=forduljon jobbra
+turn_slight_left=forduljon enyhén balra
+turn_slight_right=forduljon enyhén jobbra
+turn_sharp_left=forduljon élesen balra
+turn_sharp_right=forduljon élesen jobbra
+keep_left=tartson balra
+keep_right=tartson jobbra
+turn_onto=%1$s erre: %2$s
+u_turn=forduljon meg
+unknown=ismeretlen jelzőtábla: %1$s
 web.search_button=Keresés
-web.from_hint=Honnan
-web.via_hint=Keresztül
-web.to_hint=Hova
-web.more_button=Több
+web.from_hint=Innen
+web.via_hint=Ezen keresztül
+web.to_hint=Ide
+web.more_button=tovább
 web.gpx_export_button=GPX export
-web.route_info=%1$s tart %2$s
-web.pt_route_info=
-web.pt_route_info_walking=
-web.locations_not_found=Útvonaltervezés nem lehetséges.A megadott hely(ek) nem található(ak).
-web.bike=Bicikli
-web.racingbike=Verseny bicikli
-web.mtb=Terep bicikli
+web.route_info=%1$s ennyi ideig tart: %2$s
+web.pt_route_info=érkezés %1$s órakor, %2$s átszállással (%3$s)
+web.pt_route_info_walking=érkezés %1$s órakor, csak gyalog (%2$s)
+web.locations_not_found=Útvonaltervezés nem lehetséges. A megadott hely(ek) nem található(k) meg a területen.
+web.bike=Kerékpár
+web.racingbike=Versenykerékpár
+web.mtb=Hegyi kerékpár
 web.car=Autó
-web.foot=Gyalog
-web.hike=
-web.small_truck=
-web.bus=
-web.truck=
+web.foot=Gyalogos
+web.hike=Túrázás
+web.small_truck=Kisteherautó
+web.bus=Busz
+web.truck=Teherautó
 web.staticlink=Statikus hivatkozás
-web.motorcycle=Motor
-via=át
-finish=Megérekezett!
+web.motorcycle=Motorkerékpár
+via=ezen át:
+finish=érkezés a célponthoz
 hour_abbr=óra
 day_abbr=nap
 min_abbr=perc
-km_abbr=kilométer
-m_abbr=méter
+km_abbr=km
+m_abbr=m
 mi_abbr=mérföld
-ft_abbr=lépés
-road=Országút
-off_bike=Tolva folytathatja
-cycleway=Kerékpár út
-way=Út
-small_way=
-paved=Kövezett út
-unpaved=Földes út
-stopover=Meg kell állni %1$s
+ft_abbr=láb
+road=út
+off_bike=szálljon le a kerékpárról
+cycleway=kerékpárút
+way=út
+small_way=gyalogút
+paved=burkolt út
+unpaved=burkolatlan út
+stopover=%1$s. útpont
 roundabout_enter=Hajtson be a körforgalomba
-roundabout_exit=Hagyja el a körförgalmat, kihajtó %1$s
-roundabout_exit_onto=Hagyja el a körförgalmat, kihajtó %1$s, aztán hajtson rá %2$s
-total_ascend=
-total_descend=
-way_contains_ford=
-pt_start_trip=
-pt_end_trip=
-pt_transfer_to=
-web.start_label=
-web.intermediate_label=
-web.end_label=
-web.set_start=
-web.set_intermediate=
-web.set_end=
-web.center_map=
-web.show_coords=
-web.route=
-web.delete_from_route=
-web.marker=
-web.gh_offline_info=
-web.refresh_button=
-web.server_status=
-web.zoom_in=
-web.zoom_out=
-web.drag_to_reorder=
+roundabout_exit=Hajtson ki a körforgalomból itt: %1$s. kijárat
+roundabout_exit_onto=Hajtson ki a körforgalomból itt: %1$s. kijárat, majd hajtson rá erre: %2$s
+total_ascend=Összes szintemelkedés: %1$s
+total_descend=Összes szintcsökkenés: %1$s
+way_contains_ford=gázló van az útvonalon
+pt_start_trip=szálljon fel erre: %1$s
+pt_end_trip=szálljon le erről: %1$s
+pt_transfer_to=szálljon át erre: %1$s
+web.start_label=Indulás
+web.intermediate_label=Köztes célpont
+web.end_label=Célpont
+web.set_start=Beállítás köztes célpontnak
+web.set_intermediate=Beállítás kiindulási pontnak
+web.set_end=Beállítás célpontnak
+web.center_map=Beállítás a térkép középpontjának
+web.show_coords=Pozíció megjelenítése
+web.route=Útvonal
+web.delete_from_route=Eltávolítás az útvonalról
+web.marker=Jelölő
+web.gh_offline_info=Lehet, hogy a GraphHopper API nem érhető el?
+web.refresh_button=Oldal frissítése
+web.server_status=Állapot
+web.zoom_in=Nagyítás
+web.zoom_out=Kicsinyítés
+web.drag_to_reorder=Húzza el az átrendezéshez
diff --git a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
index 6b4da6c7d6..3af796d31c 100644
--- a/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
+++ b/core/src/test/java/com/graphhopper/coll/GHTreeMapComposedTest.java
@@ -25,18 +25,64 @@
  * @author Peter Karich
  */
 public class GHTreeMapComposedTest {
+
+    private GHTreeMapComposed instance = new GHTreeMapComposed();
+
     @Test
     public void testInsert() {
-        GHTreeMapComposed instance = new GHTreeMapComposed();
-        instance.insert(1, 100);
+        instance.insert(1, 100.001f);
         assertEquals(1, instance.peekKey());
-        assertEquals(100, instance.peekValue());
+        assertEquals(100.001, instance.peekValue(), 1.e-4);
 
-        instance.insert(2, 99);
-        instance.insert(3, 101);
+        instance.insert(2, 99.7f);
+        instance.insert(3, 101.4f);
         assertEquals(2, instance.peekKey());
-        assertEquals(99, instance.peekValue());
+        assertEquals(99.7, instance.peekValue(), 1.e-4);
 
         assertEquals(2, instance.pollKey());
     }
+
+    @Test
+    public void testDifferentValuesSameKey() {
+        instance.insert(0, -4.0f);
+        instance.insert(0, -24.0f);
+        assertEquals(2, instance.getSize());
+        assertEquals(0, instance.peekKey());
+        assertEquals(-24.0f, instance.peekValue(), 1.e-4);
+
+        assertEquals(0, instance.pollKey());
+        assertEquals(0, instance.pollKey());
+    }
+
+    @Test
+    public void testDifferentKeysSameValue() {
+        instance.insert(0, -4.0f);
+        instance.insert(1, -4.0f);
+        assertEquals(2, instance.getSize());
+    }
+
+    @Test
+    public void testUpdate() {
+        instance.insert(34302, 26.25f);
+        instance.update(34302, 26.25f, 5.6f);
+        assertEquals(5.6f, instance.peekValue(), 1.e-4);
+        assertEquals(34302, instance.pollKey());
+    }
+
+    @Test
+    public void testUpdateDuplicateValues() {
+        instance.insert(34302, 26.25f);
+        instance.insert(160654, 26.25f);
+        instance.insert(34302, 26.25f);
+        instance.insert(160654, 26.25f);
+        assertEquals(2, instance.getSize());
+        instance.remove(34302, 26.25f);
+        assertEquals(1, instance.getSize());
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testRemovingNonExistentKeyThrows() {
+        instance.insert(5, 1.1f);
+        instance.remove(5, 2.2f);
+    }
 }
diff --git a/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
similarity index 95%
rename from core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java
rename to core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
index 27bfbd79f9..2b56086672 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/NodeContractorTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/NodeBasedNodeContractorTest.java
@@ -19,10 +19,7 @@
 
 import com.graphhopper.routing.Dijkstra;
 import com.graphhopper.routing.DijkstraOneToMany;
-import com.graphhopper.routing.util.AllCHEdgesIterator;
-import com.graphhopper.routing.util.CarFlagEncoder;
-import com.graphhopper.routing.util.EncodingManager;
-import com.graphhopper.routing.util.TraversalMode;
+import com.graphhopper.routing.util.*;
 import com.graphhopper.routing.weighting.ShortestWeighting;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.*;
@@ -39,7 +36,7 @@
 
 import static org.junit.Assert.*;
 
-public class NodeContractorTest {
+public class NodeBasedNodeContractorTest {
     private final CarFlagEncoder encoder = new CarFlagEncoder();
     private final EncodingManager encodingManager = new EncodingManager(encoder);
     private final Weighting weighting = new ShortestWeighting(encoder);
@@ -54,8 +51,9 @@ public void setUp() {
     }
 
     private NodeContractor createNodeContractor() {
-        NodeContractor nodeContractor = new NodeContractor(dir, graph, lg, weighting, traversalMode);
+        NodeContractor nodeContractor = new NodeBasedNodeContractor(dir, graph, lg, weighting);
         nodeContractor.initFromGraph();
+        nodeContractor.prepareContraction();
         return nodeContractor;
     }
 
@@ -85,7 +83,7 @@ public void testShortestPathSkipNode() {
 
         setMaxLevelOnAllNodes();
 
-        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes()).setAvoidNode(3));
+        algo.setEdgeFilter(createIgnoreNodeFilter(3));
         algo.setWeightLimit(100);
         int nodeEntry = algo.findEndNode(4, 2);
         assertTrue(algo.getWeight(nodeEntry) > normalDist);
@@ -105,7 +103,7 @@ public void testShortestPathSkipNode2() {
 
         setMaxLevelOnAllNodes();
 
-        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes()).setAvoidNode(3));
+        algo.setEdgeFilter(createIgnoreNodeFilter(3));
         algo.setWeightLimit(10);
         int nodeEntry = algo.findEndNode(4, 2);
         assertEquals(4, algo.getWeight(nodeEntry), 1e-5);
@@ -121,7 +119,7 @@ public void testShortestPathLimit() {
 
         setMaxLevelOnAllNodes();
 
-        algo.setEdgeFilter(new NodeContractor.IgnoreNodeFilter(lg, graph.getNodes()).setAvoidNode(0));
+        algo.setEdgeFilter(createIgnoreNodeFilter(0));
         algo.setWeightLimit(2);
         int endNode = algo.findEndNode(4, 1);
         // did not reach endNode
@@ -337,6 +335,10 @@ private void setMaxLevelOnAllNodes() {
         }
     }
 
+    private IgnoreNodeFilter createIgnoreNodeFilter(int node) {
+        return new IgnoreNodeFilter(lg, graph.getNodes()).setAvoidNode(node);
+    }
+
     private static class Shortcut {
         int baseNode;
         int adjNode;
diff --git a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
index 04d7cf1c33..104132d0bd 100644
--- a/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
+++ b/core/src/test/java/com/graphhopper/routing/ch/PrepareContractionHierarchiesTest.java
@@ -208,7 +208,7 @@ public void testDirectedGraph2() {
         assertEquals(oldCount, g.getAllEdges().length());
         assertEquals(oldCount, GHUtility.count(g.getAllEdges()));
 
-        int numShortcuts = 9;
+        long numShortcuts = 9;
         assertEquals(numShortcuts, prepare.getShortcuts());
         assertEquals(oldCount + numShortcuts, lg.getAllEdges().length());
         assertEquals(oldCount + numShortcuts, GHUtility.count(lg.getAllEdges()));
diff --git a/docs/core/elevation.md b/docs/core/elevation.md
index 349e816816..5d31ab1c2c 100644
--- a/docs/core/elevation.md
+++ b/docs/core/elevation.md
@@ -1,7 +1,7 @@
 # Elevation
 
 Per default elevation is disabled. But you can easily enable it e.g. via
-`graph.elevation.provider=cgiar`. Or use other possibilities `srtm`, `gmted`
+`graph.elevation.provider: cgiar`. Or use other possibilities `srtm`, `gmted`
 or `multi` (combined cgiar and gmted).
 
 Then GraphHopper will automatically download the necessary data for the area and include elevation 
@@ -9,7 +9,7 @@ for all vehicles - making also the distances a bit more precise.
 
 The default cache directory `/tmp/<provider name>` will be used. For large areas it is highly recommended to 
 use a SSD disc, thus you need to specify the cache directory:
-`graph.elevation.cache_dir=/myssd/ele_cache/`
+`graph.elevation.cache_dir: /myssd/ele_cache/`
 
 ## What to download and where to store it? 
 
@@ -23,7 +23,7 @@ where the last one is only accessibly if you specify the
 [full zip file](http://srtm.csi.cgiar.org/SRT-ZIP/SRTM_V41/SRTM_Data_GeoTiff/srtm_01_02.zip)
 
 If the geographical area is small and you need a faster import you can change the default MMAP setting to:
-`graph.elevation.dataaccess=RAM_STORE`
+`graph.elevation.dataaccess: RAM_STORE`
 
 ## CGIAR vs. SRTM
 
@@ -36,4 +36,4 @@ Using SRTM instead CGIAR has the minor advantage of a faster download, especiall
 
 Integrating your own elevation data is easy and just requires you to implement the
 ElevationProvider interface and then specify it via GraphHopper.setElevationProvider.
-Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
\ No newline at end of file
+Have a look in the existing implementations for a simple overview of caching and DataAccess usage.
diff --git a/docs/core/quickstart-from-source.md b/docs/core/quickstart-from-source.md
index bf3b188868..4189c69686 100644
--- a/docs/core/quickstart-from-source.md
+++ b/docs/core/quickstart-from-source.md
@@ -32,7 +32,7 @@ $ ./graphhopper.sh -a web -i north-america_us_new-york.pbf -o new-york-gh
 
 For larger maps you might need to allow the JVM to access more memory. For example for 2GB you can do this using:
 ```bash
-$ export JAVA_OPTS="-Xmx=2g -Xms=2g"
+$ export JAVA_OPTS="-Xmx2g -Xms2g"
 ```
 before running `graphhopper.sh`.
 
diff --git a/docs/index.md b/docs/index.md
index fbf43ffd10..27bf02ebe4 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -62,7 +62,9 @@ Various topics are explained in more detail separately:
  * [Create new FlagEncoder](./core/create-new-flagencoder.md): Documentation to create new routing profiles to influence which ways to favor and how the track-time is calculated.
  * [Spatial Rules](./core/spatial-rules.md): Instruction on how to use and create new SpatialRules. SpatialRules are used to enforce country-specific routing rules.
  * [Turn Restrictions](./core/turn-restrictions.md): Details on how to enable and use turn restrictions.
- * [Postgis query script](../core/files/postgis)
+ * [Isochrone generation in Java](./isochrone/java.md): Instruction on how to create isochrones using the low-level Java API.
+ * [Postgis query script](./core/files/postgis)
+
 
 #### Other links
 
diff --git a/docs/isochrone/images/isochrone.png b/docs/isochrone/images/isochrone.png
new file mode 100644
index 0000000000..0c35554113
Binary files /dev/null and b/docs/isochrone/images/isochrone.png differ
diff --git a/docs/isochrone/java.md b/docs/isochrone/java.md
new file mode 100644
index 0000000000..a115815283
--- /dev/null
+++ b/docs/isochrone/java.md
@@ -0,0 +1,35 @@
+# Isochrone via Java API
+
+To use the following examples you need to specify the dependency in
+your [Maven config](/README.md#maven) correctly.
+
+To create an isochrone in Java code:
+
+You'll first need to build off an existing Graphhopper instance for [routing](/../core/routing.md).
+
+Next, compute the isochrone itself.
+```java
+
+// get encoder from GraphHopper instance
+EncodingManager encodingManager = hopper.getEncodingManager();
+FlagEncoder encoder = encodingManager.getEncoder("car");
+
+// pick the closest point on the graph to the query point and generate a query graph
+QueryResult qr = hopper.getLocationIndex().findClosest(lat, lon, DefaultEdgeFilter.allEdges(encoder));
+
+Graph graph = hopper.getGraphHopperStorage();
+QueryGraph queryGraph = new QueryGraph(graph);
+queryGraph.lookup(Collections.singletonList(qr));
+
+// calculate isochrone from query graph
+PMap pMap = new PMap();
+Isochrone isochrone = new Isochrone(queryGraph, new FastestWeighting(carEncoder, pmap), false);
+isochrone.setTimeLimit(60);
+
+List<List<Double[]>> res = isochrone.searchGPS(qr.getClosestNode(), 1L);
+```
+
+The returned list will represent a point list. It can also be converted into a polygon.
+
+See [GraphHopper's servlet](https://github.com/graphhopper/graphhopper/blob/master/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java)
+for more comprehensive construction of an isochrone.
diff --git a/docs/web/api-doc.md b/docs/web/api-doc.md
index 84d45222b7..8b06a1cbf9 100644
--- a/docs/web/api-doc.md
+++ b/docs/web/api-doc.md
@@ -6,9 +6,9 @@ server you need to understand how to use it. There is a separate [JavaScript](ht
 ### A simple example
 [http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959](http://localhost:8989/route?point=45.752193%2C-0.686646&point=46.229253%2C-0.32959)
 
-The end point of the local instance is [http://localhost:8989](http://localhost:8989)
+The URL path of the local instance is [http://localhost:8989](http://localhost:8989)
 
-The URL path to obtain the route is `/route`
+The endpoint to obtain the route is `/route`
 
 ## Parameters
 
@@ -24,7 +24,7 @@ elevation   | false   | If `true` a third dimension - the elevation - is include
 points_encoded   | true    | If `false` the coordinates in `point` and `snapped_waypoints` are returned as array using the order [lon,lat,elevation] for every point. If `true` the coordinates will be encoded as string leading to less bandwith usage. You'll need a special handling for the decoding of this string on the client-side. We provide open source code in [Java](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/java/com/graphhopper/http/WebHelper.java#L43) and [JavaScript](https://github.com/graphhopper/graphhopper/blob/d70b63660ac5200b03c38ba3406b8f93976628a6/web/src/main/webapp/js/ghrequest.js#L139). It is especially important to use no 3rd party client if you set `elevation=true`!
 debug            | false   | If true, the output will be formated.
 calc_points      | true    | If the points for the route should be calculated at all printing out only distance and time.
-type             | json    | Specifies the resulting format of the route, for `json` the content type will be application/json. Other possible format options: <br> `jsonp` you'll need to provide the callback function via the callback parameter. The content type will be application/javascript<br> `gpx`, the content type will be application/gpx+xml, see below for more parameters.
+type             | json    | Specifies the resulting format of the route, for `json` the content type will be application/json. Other possible format options: <br> `gpx`, the content type will be application/gpx+xml, see below for more parameters.
 point_hint       | -       | Optional parameter. Specifies a hint for each `point` parameter to prefer a certain street for the closest location lookup. E.g. if there is an address or house with two or more neighboring streets you can control for which street the closest location is looked up.
 details          | -       | Optional parameter. You can request additional details for the route: `average_speed`, `street_name`, `edge_id`, and `time`. The returned format for one details is `[fromRef, toRef, value]`. The `ref` references the points of the response.
 
@@ -220,3 +220,21 @@ HTTP error code | Reason
 500             | Internal server error. It is strongly recommended to send us the message and the link to it, as it is very likely a bug in our system.
 501             | Only a special list of vehicles is supported
 400             | Something was wrong in your request
+
+## Isochrone
+
+In addition to routing, the end point to obtain an isochrone is `/isochrone`.
+
+[http://localhost:8989/isochrone](http://localhost:8989/isochrone)
+
+All parameters are shown in the following table.
+
+Parameter                   | Default | Description
+:---------------------------|:--------|:-----------
+vehicle                     | car     | The vehicle for which the route should be calculated. Other vehicles are foot, bike, motorcycle, hike, ...
+buckets                     | 1       | Number by which to divide the given `time_limit` to create `buckets` nested isochrones of time intervals `time_limit/buckets`, `time_limit/(buckets - 1)`, ... , `time_limit`. Applies analogously to `distance_limit`.
+reverse_flow                | false   | If false the flow goes from point to the polygon, if true the flow goes from the polygon inside to the point. Example usage for false: *How many potential customer can be reached within 30min travel time from your store* vs. true: *How many customers can reach your store within 30min travel time.* (optional, default to false)
+point                       |         | Specify the start coordinate (required). A string organized as `latitude,longitude`.
+result                      | polygon | Can be "pointlist" or "polygon".
+time_limit                  | 600     | Specify which time the vehicle should travel. In seconds. (optional, default to 600)
+distance_limit              | -1      | Specify which distance the vehicle should travel. In meter. (optional, default to -1)
diff --git a/graphhopper.sh b/graphhopper.sh
index 80b1d52e9c..4e76798c63 100755
--- a/graphhopper.sh
+++ b/graphhopper.sh
@@ -224,14 +224,14 @@ LINK=$(echo $NAME | tr '_' '/')
 if [ "$FILE" == "-" ]; then
    LINK=
 elif [ ${FILE: -4} == ".osm" ]; then 
-   LINK="https://download.geofabrik.de/$LINK-latest.osm.bz2"
+   LINK="http://download.geofabrik.de/$LINK-latest.osm.bz2"
 elif [ ${FILE: -4} == ".ghz" ]; then
    LINK="https://graphhopper.com/public/maps/0.1/$FILE"
 elif [ ${FILE: -4} == ".pbf" ]; then
-   LINK="https://download.geofabrik.de/$LINK-latest.osm.pbf"
+   LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 else
    # e.g. if directory ends on '-gh'
-   LINK="https://download.geofabrik.de/$LINK-latest.osm.pbf"
+   LINK="http://download.geofabrik.de/$LINK-latest.osm.pbf"
 fi
 
 : "${JAVA_OPTS:=-Xmx1000m -Xms1000m}"
diff --git a/isochrone/pom.xml b/isochrone/pom.xml
index 803a338902..dd9569004d 100644
--- a/isochrone/pom.xml
+++ b/isochrone/pom.xml
@@ -24,6 +24,19 @@
             <version>${project.parent.version}</version>
         </dependency>
 
+        <dependency>
+            <groupId>org.slf4j</groupId>
+            <artifactId>slf4j-log4j12</artifactId>
+            <version>${slf4j.version}</version>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>log4j</groupId>
+            <artifactId>log4j</artifactId>
+            <version>${log4j.version}</version>
+            <scope>test</scope>
+        </dependency>
+
         <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
diff --git a/pom.xml b/pom.xml
index afa59cce1f..45649938b8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -17,8 +17,10 @@
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
         <slf4j.version>1.7.25</slf4j.version>
         <log4j.version>1.2.17</log4j.version>
-        <commons-compress.version>1.12</commons-compress.version>
-        <jackson.version>2.9.1</jackson.version>
+        <commons-compress.version>1.15</commons-compress.version>
+        <jackson.version>2.9.6</jackson.version>
+        <dropwizard.version>1.3.5</dropwizard.version>
+        <directions-api-client.version>0.10.1-3</directions-api-client.version>
         <maven.compiler.target>1.8</maven.compiler.target>
 
         <org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>4</org-netbeans-modules-editor-indent.CodeStyle.project.indent-shift-width>
@@ -130,7 +132,7 @@
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-assembly-plugin</artifactId>
-                <version>3.0.0</version>
+                <version>3.1.0</version>
             </plugin>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
diff --git a/reader-gtfs/files/sample-feed.zip b/reader-gtfs/files/sample-feed.zip
index 8047a41b77..ac51e28a03 100644
Binary files a/reader-gtfs/files/sample-feed.zip and b/reader-gtfs/files/sample-feed.zip differ
diff --git a/reader-gtfs/pom.xml b/reader-gtfs/pom.xml
index 2809f303fb..51011d4c04 100644
--- a/reader-gtfs/pom.xml
+++ b/reader-gtfs/pom.xml
@@ -93,6 +93,12 @@
             <version>3.6.2</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <version>1.10.19</version>
+            <scope>test</scope>
+        </dependency>
     </dependencies>
     <build>
         <plugins>
@@ -113,22 +119,6 @@
                     <target>1.8</target>
                 </configuration>
             </plugin>
-            <plugin>
-                <groupId>org.apache.maven.plugins</groupId>
-                <artifactId>maven-assembly-plugin</artifactId>                
-                <configuration>
-                    <archive>
-                        <manifest>
-                            <mainClass>com.graphhopper.import.osm.Import</mainClass>
-                        </manifest>
-                    </archive>
-                        	                    
-                    <!-- for standalone usage -->
-                    <descriptorRefs>
-                        <descriptorRef>jar-with-dependencies</descriptorRef>
-                    </descriptorRefs>
-                </configuration>
-            </plugin>
             <plugin>                
                 <groupId>org.apache.maven.plugins</groupId>
                 <artifactId>maven-surefire-plugin</artifactId>
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/FakeWalkNetworkBuilder.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/FakeWalkNetworkBuilder.java
deleted file mode 100644
index 9be65b36ba..0000000000
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/FakeWalkNetworkBuilder.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for
- *  additional information regarding copyright ownership.
- *
- *  GraphHopper GmbH licenses this file to you under the Apache License,
- *  Version 2.0 (the "License"); you may not use this file except in
- *  compliance with the License. You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-package com.graphhopper.reader.gtfs;
-
-import com.conveyal.gtfs.GTFSFeed;
-import com.graphhopper.storage.GraphHopperStorage;
-import com.graphhopper.util.DistanceCalc;
-import com.graphhopper.util.EdgeIteratorState;
-import com.vividsolutions.jts.geom.Coordinate;
-import com.vividsolutions.jts.triangulate.ConformingDelaunayTriangulator;
-import com.vividsolutions.jts.triangulate.ConstraintVertex;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdge;
-import com.vividsolutions.jts.triangulate.quadedge.QuadEdgeSubdivision;
-import com.vividsolutions.jts.triangulate.quadedge.Vertex;
-
-import java.util.*;
-
-class FakeWalkNetworkBuilder {
-
-    static void buildWalkNetwork(Collection<GTFSFeed> feeds, GraphHopperStorage graph, PtFlagEncoder encoder, DistanceCalc distCalc) {
-        Collection<ConstraintVertex> sites = new ArrayList<>();
-        Map<Vertex, Integer> vertex2nodeId = new HashMap<>();
-        feeds.stream().flatMap(feed -> feed.stops.values().stream()).forEach( stop -> {
-            int i = graph.getNodes();
-            graph.getNodeAccess().setNode(i++, stop.stop_lat, stop.stop_lon);
-            ConstraintVertex site = new ConstraintVertex(new Coordinate(stop.stop_lon,stop.stop_lat));
-            sites.add(site);
-            vertex2nodeId.put(site, i-1);
-        });
-        ConformingDelaunayTriangulator conformingDelaunayTriangulator = new ConformingDelaunayTriangulator(sites, 0.0);
-        conformingDelaunayTriangulator.setConstraints(new ArrayList(), new ArrayList());
-        conformingDelaunayTriangulator.formInitialDelaunay();
-        QuadEdgeSubdivision tin = conformingDelaunayTriangulator.getSubdivision();
-        List<QuadEdge> edges = tin.getPrimaryEdges(false);
-        for (QuadEdge edge : edges) {
-            EdgeIteratorState ghEdge = graph.edge(vertex2nodeId.get(edge.orig()), vertex2nodeId.get(edge.dest()));
-            double distance = distCalc.calcDist(
-                    edge.orig().getY(),
-                    edge.orig().getX(),
-                    edge.dest().getY(),
-                    edge.dest().getX());
-            ghEdge.setDistance(distance);
-            ghEdge.setFlags(encoder.setSpeed(ghEdge.getFlags(), 5.0));
-            ghEdge.setFlags(encoder.setAccess(ghEdge.getFlags(), true, true));
-        }
-    }
-
-
-}
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
index 7fd7ab57a2..56023505cd 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphExplorer.java
@@ -21,6 +21,8 @@
 import com.google.common.collect.ArrayListMultimap;
 import com.graphhopper.routing.VirtualEdgeIteratorState;
 import com.graphhopper.routing.util.DefaultEdgeFilter;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.EdgeExplorer;
@@ -49,13 +51,21 @@
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesBySource = ArrayListMultimap.create();
     private final ArrayListMultimap<Integer, VirtualEdgeIteratorState> extraEdgesByDestination = ArrayListMultimap.create();
     private final Graph graph;
+    private final Weighting accessEgressWeighting;
     private final boolean walkOnly;
     private double walkSpeedKmH;
 
 
-    GraphExplorer(Graph graph, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, double walkSpeedKmh) {
+    GraphExplorer(Graph graph, Weighting accessEgressWeighting, PtFlagEncoder flagEncoder, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed, boolean reverse, List<VirtualEdgeIteratorState> extraEdges, boolean walkOnly, double walkSpeedKmh) {
         this.graph = graph;
-        this.edgeExplorer = graph.createEdgeExplorer(reverse ? DefaultEdgeFilter.inEdges(flagEncoder) : DefaultEdgeFilter.outEdges(flagEncoder));
+        this.accessEgressWeighting = accessEgressWeighting;
+        DefaultEdgeFilter accessEgressIn = DefaultEdgeFilter.inEdges(accessEgressWeighting.getFlagEncoder());
+        DefaultEdgeFilter accessEgressOut = DefaultEdgeFilter.outEdges(accessEgressWeighting.getFlagEncoder());
+        DefaultEdgeFilter ptIn = DefaultEdgeFilter.inEdges(flagEncoder);
+        DefaultEdgeFilter ptOut = DefaultEdgeFilter.outEdges(flagEncoder);
+        EdgeFilter in = edgeState -> accessEgressIn.accept(edgeState) || ptIn.accept(edgeState);
+        EdgeFilter out = edgeState -> accessEgressOut.accept(edgeState) || ptOut.accept(edgeState);
+        this.edgeExplorer = graph.createEdgeExplorer(reverse ? in : out);
         this.flagEncoder = flagEncoder;
         this.gtfsStorage = gtfsStorage;
         this.realtimeFeed = realtimeFeed;
@@ -100,7 +110,7 @@ long calcTravelTimeMillis(EdgeIteratorState edge, long earliestStartTime) {
         GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
         switch (edgeType) {
             case HIGHWAY:
-                return (long) (getWalkDistance(edge) * 3.6 / walkSpeedKmH) * 1000;
+                return (long) (accessEgressWeighting.calcMillis(edge, reverse, -1) * (5.0 / walkSpeedKmH));
             case ENTER_TIME_EXPANDED_NETWORK:
                 if (reverse) {
                     return 0;
@@ -131,12 +141,13 @@ long getDelayFromAlightEdge(EdgeIteratorState edge, long currentTime) {
     }
 
     private long waitingTime(EdgeIteratorState edge, long earliestStartTime) {
-        return flagEncoder.getTime(edge.getFlags()) * 1000 - millisOnTravelDay(edge, earliestStartTime);
-    }
-
-    private int secondsOnTrafficDay(EdgeIteratorState edge, long instant) {
-        final ZoneId zoneId = gtfsStorage.getTimeZones().get(flagEncoder.getValidityId(edge.getFlags())).zoneId;
-        return Instant.ofEpochMilli(instant).atZone(zoneId).toLocalTime().toSecondOfDay();
+        long l = flagEncoder.getTime(edge.getFlags()) * 1000 - millisOnTravelDay(edge, earliestStartTime);
+        if (!reverse) {
+            if (l < 0) l = l + 24*60*60*1000;
+        } else {
+            if (l > 0) l = l - 24*60*60*1000;
+        }
+        return l;
     }
 
     private long millisOnTravelDay(EdgeIteratorState edge, long instant) {
@@ -160,26 +171,23 @@ int calcNTransfers(EdgeIteratorState edge) {
         return flagEncoder.getTransfers(edge.getFlags());
     }
 
-    double getWalkDistance(EdgeIteratorState edge) {
-        GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
-        switch (edgeType) {
-            case HIGHWAY:
-                return edge.getDistance();
-            case ENTER_PT:
-            case EXIT_PT:
-                return 10.0;
-            default:
-                return 0.0;
-        }
-    }
-
     EdgeIteratorState getEdgeIteratorState(int edgeId, int adjNode) {
         if (edgeId == -1) {
             throw new RuntimeException();
         }
-        return extraEdges.stream()
-                .filter(edge -> edge.getEdge() == edgeId)
-                .findFirst().orElseGet(() -> graph.getEdgeIteratorState(edgeId, adjNode));
+        for (EdgeIteratorState extraEdge : extraEdges) {
+            if (extraEdge.getEdge() == edgeId) {
+                if (extraEdge.getAdjNode() != adjNode) {
+                    throw new IllegalStateException();
+                }
+                return extraEdge;
+            }
+        }
+        EdgeIteratorState edge = graph.getEdgeIteratorState(edgeId, adjNode);
+        if (edge.getAdjNode() != adjNode) {
+            throw new IllegalStateException();
+        }
+        return edge;
     }
 
     NodeAccess getNodeAccess() {
@@ -202,7 +210,14 @@ public Graph getGraph() {
         @Override
         public boolean test(EdgeIteratorState edgeIterator) {
             final GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edgeIterator.getFlags());
-            if (walkOnly && edgeType != GtfsStorage.EdgeType.HIGHWAY && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
+            if (edgeType == GtfsStorage.EdgeType.HIGHWAY) {
+                if (reverse) {
+                    return accessEgressWeighting.getFlagEncoder().isBackward(edgeIterator.getFlags());
+                } else {
+                    return accessEgressWeighting.getFlagEncoder().isForward(edgeIterator.getFlags());
+                }
+            }
+            if (walkOnly && edgeType != (reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT)) {
                 return false;
             }
             if (!isValidOn(edgeIterator, label.currentTime)) {
@@ -211,15 +226,6 @@ public boolean test(EdgeIteratorState edgeIterator) {
             if (edgeType == GtfsStorage.EdgeType.WAIT_ARRIVAL && !reverse) {
                 return false;
             }
-            if (edgeType == GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK && !reverse) {
-                if (secondsOnTrafficDay(edgeIterator, label.currentTime) > flagEncoder.getTime(edgeIterator.getFlags())) {
-                    return false;
-                }
-            } else if (edgeType == GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK && reverse) {
-                if (secondsOnTrafficDay(edgeIterator, label.currentTime) < flagEncoder.getTime(edgeIterator.getFlags())) {
-                    return false;
-                }
-            }
             return true;
         }
     }
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
index f1f41e7cbe..66920608c4 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GraphHopperGtfs.java
@@ -84,6 +84,7 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
 
     private final TranslationMap translationMap;
     private final PtFlagEncoder flagEncoder;
+    private final Weighting accessEgressWeighting;
     private final GraphHopperStorage graphHopperStorage;
     private final LocationIndex locationIndex;
     private final GtfsStorage gtfsStorage;
@@ -95,29 +96,30 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
         private final int limitSolutions;
         private final Instant initialTime;
         private final boolean profileQuery;
-        private final boolean separateWalkQuery = true;
         private final boolean arriveBy;
         private final boolean ignoreTransfers;
+        private final double betaTransfers;
+        private final double betaWalkTime;
         private final double walkSpeedKmH;
         private final double maxWalkDistancePerLeg;
-        private final double maxTransferDistancePerLeg;
         private final int blockedRouteTypes;
-        private final Weighting weighting;
         private final GHPoint enter;
         private final GHPoint exit;
         private final Translation translation;
         private final List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>(realtimeFeed.getAdditionalEdges());
-        private final Map<Integer, PathWrapper> walkPaths = new HashMap<>();
 
         private final GHResponse response = new GHResponse();
         private final Graph graphWithExtraEdges = new WrapperGraph(graphHopperStorage, extraEdges);
         private QueryGraph queryGraph = new QueryGraph(graphWithExtraEdges);
         private GraphExplorer graphExplorer;
+        private int visitedNodes;
 
         RequestHandler(GHRequest request) {
             maxVisitedNodesForRequest = request.getHints().getInt(Parameters.Routing.MAX_VISITED_NODES, 1_000_000);
             profileQuery = request.getHints().getBool(PROFILE_QUERY, false);
             ignoreTransfers = request.getHints().getBool(Parameters.PT.IGNORE_TRANSFERS, profileQuery);
+            betaTransfers = request.getHints().getDouble("beta_transfers", 0.0);
+            betaWalkTime = request.getHints().getDouble("beta_walk_time", 1.0);
             limitSolutions = request.getHints().getInt(Parameters.PT.LIMIT_SOLUTIONS, profileQuery ? 5 : ignoreTransfers ? 1 : Integer.MAX_VALUE);
             final String departureTimeString = request.getHints().get(Parameters.PT.EARLIEST_DEPARTURE_TIME, "");
             try {
@@ -127,16 +129,14 @@ public static Factory createFactory(PtFlagEncoder flagEncoder, TranslationMap tr
             }
             arriveBy = request.getHints().getBool(Parameters.PT.ARRIVE_BY, false);
             walkSpeedKmH = request.getHints().getDouble(Parameters.PT.WALK_SPEED, 5.0);
-            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, 1000.0);
-            maxTransferDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_TRANSFER_DISTANCE_PER_LEG, Double.MAX_VALUE);
             blockedRouteTypes = request.getHints().getInt(Parameters.PT.BLOCKED_ROUTE_TYPES, 0);
-            weighting = new FastestWeighting(graphHopperStorage.getEncodingManager().getEncoder("foot"));
             translation = translationMap.getWithFallBack(request.getLocale());
             if (request.getPoints().size() != 2) {
                 throw new IllegalArgumentException("Exactly 2 points have to be specified, but was:" + request.getPoints().size());
             }
             enter = request.getPoints().get(0);
             exit = request.getPoints().get(1);
+            maxWalkDistancePerLeg = request.getHints().getDouble(Parameters.PT.MAX_WALK_DISTANCE_PER_LEG, Integer.MAX_VALUE);
         }
 
         GHResponse route() {
@@ -153,11 +153,6 @@ GHResponse route() {
             PointList startAndEndpoint = pointListFrom(Arrays.asList(source, dest));
             response.addDebugInfo("idLookup:" + stopWatch.stop().getSeconds() + "s");
 
-            if (separateWalkQuery) {
-                substitutePointWithVirtualNode(0, false, enter, allQueryResults);
-                substitutePointWithVirtualNode(1, true, exit, allQueryResults);
-            }
-
             int startNode;
             int destNode;
             if (arriveBy) {
@@ -167,52 +162,11 @@ GHResponse route() {
                 startNode = allQueryResults.get(0).getClosestNode();
                 destNode = allQueryResults.get(1).getClosestNode();
             }
-            List<Label> solutions = findPaths(startNode, destNode);
+            List<List<Label.Transition>> solutions = findPaths(startNode, destNode);
             parseSolutionsAndAddToResponse(solutions, startAndEndpoint);
             return response;
         }
 
-        private void substitutePointWithVirtualNode(int index, boolean reverse, GHPoint ghPoint, ArrayList<QueryResult> allQueryResults) {
-            final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, flagEncoder, gtfsStorage, realtimeFeed, reverse, extraEdges, true, walkSpeedKmH);
-            int nextNodeId = graphWithExtraEdges.getNodes() + 2 + index; // FIXME: A number bigger than the number of nodes QueryGraph adds
-            int nextEdgeId = graphWithExtraEdges.getAllEdges().length() + 100; // FIXME: A number bigger than the number of edges QueryGraph adds
-
-            final List<Label> stationNodes = findStationNodes(graphExplorer, allQueryResults.get(index).getClosestNode(), reverse);
-            for (Label stationNode : stationNodes) {
-                final PathWrapper pathWrapper = stationNode.parent.parent != null ?
-                        tripFromLabel.parseSolutionIntoPath(reverse, flagEncoder, translation, graphExplorer, weighting, stationNode.parent, new PointList()) :
-                        new PathWrapper();
-                final VirtualEdgeIteratorState newEdge = new VirtualEdgeIteratorState(stationNode.edge,
-                        nextEdgeId++, reverse ? stationNode.adjNode : nextNodeId, reverse ? nextNodeId : stationNode.adjNode, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
-                final VirtualEdgeIteratorState reverseNewEdge = new VirtualEdgeIteratorState(stationNode.edge,
-                        nextEdgeId++, reverse ? nextNodeId : stationNode.adjNode, reverse ? stationNode.adjNode : nextNodeId, pathWrapper.getDistance(), 0, "", pathWrapper.getPoints());
-                newEdge.setFlags(flagEncoder.setEdgeType(newEdge.getFlags(), reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT));
-                final long time = pathWrapper.getTime() / 1000;
-                newEdge.setFlags(flagEncoder.setTime(newEdge.getFlags(), time));
-                newEdge.setFlags(flagEncoder.setValidityId(newEdge.getFlags(), flagEncoder.getValidityId(graphExplorer.getEdgeIteratorState(stationNode.edge, Integer.MIN_VALUE).getFlags())));
-                reverseNewEdge.setFlags(newEdge.getFlags());
-                newEdge.setReverseEdge(reverseNewEdge);
-                reverseNewEdge.setReverseEdge(newEdge);
-                newEdge.setDistance(pathWrapper.getDistance());
-                extraEdges.add(newEdge);
-                extraEdges.add(reverseNewEdge);
-                walkPaths.put(stationNode.adjNode, pathWrapper);
-            }
-
-            final QueryResult virtualNode = new QueryResult(ghPoint.getLat(), ghPoint.getLon());
-            virtualNode.setClosestNode(nextNodeId);
-            allQueryResults.set(index, virtualNode);
-        }
-
-        private List<Label> findStationNodes(GraphExplorer graphExplorer, int node, boolean reverse) {
-            GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
-            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, reverse, maxWalkDistancePerLeg, maxTransferDistancePerLeg, false, false, maxVisitedNodesForRequest);
-            final Stream<Label> labels = router.calcLabels(node, -1, initialTime, blockedRouteTypes);
-            return labels
-                    .filter(current -> current.edge != -1 && flagEncoder.getEdgeType(graphExplorer.getEdgeIteratorState(current.edge, current.adjNode).getFlags()) == edgeType)
-                    .collect(Collectors.toList());
-        }
-
         private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
             final EdgeFilter filter = DefaultEdgeFilter.allEdges(graphHopperStorage.getEncodingManager().getEncoder("foot"));
             QueryResult source = locationIndex.findClosest(point.lat, point.lon, filter);
@@ -225,17 +179,12 @@ private QueryResult findClosest(GHPoint point, int indexForErrorMessage) {
             return source;
         }
 
-        private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList waypoints) {
-            for (Label solution : solutions) {
-                final List<Trip.Leg> legs = tripFromLabel.getTrip(arriveBy, flagEncoder, translation, graphExplorer, weighting, solution);
-                if (separateWalkQuery) {
-                    legs.addAll(0, walkPaths.get(accessNode(solution)).getLegs());
-                    legs.addAll(walkPaths.get(egressNode(solution)).getLegs());
-                }
+        private void parseSolutionsAndAddToResponse(List<List<Label.Transition>> solutions, PointList waypoints) {
+            for (List<Label.Transition> solution : solutions) {
+                final List<Trip.Leg> legs = tripFromLabel.getTrip(translation, graphExplorer, accessEgressWeighting, solution);
                 final PathWrapper pathWrapper = tripFromLabel.createPathWrapper(translation, waypoints, legs);
-                pathWrapper.setImpossible(isImpossible(solution));
-                // TODO: remove
-                pathWrapper.setTime((solution.currentTime - initialTime.toEpochMilli()) * (arriveBy ? -1 : 1));
+                pathWrapper.setImpossible(solution.stream().anyMatch(t -> t.label.impossible));
+                pathWrapper.setTime((solution.get(solution.size()-1).label.currentTime - solution.get(0).label.currentTime));
                 response.add(pathWrapper);
             }
             Comparator<PathWrapper> c = Comparator.comparingInt(p -> (p.isImpossible() ? 1 : 0));
@@ -243,61 +192,117 @@ private void parseSolutionsAndAddToResponse(List<Label> solutions, PointList way
             response.getAll().sort(c.thenComparing(d));
         }
 
-        private boolean isImpossible(Label solution) {
-            for (Label i = solution; i != null; i = i.parent) {
-                if (i.impossible) {
-                    return true;
+        private List<List<Label.Transition>> findPaths(int startNode, int destNode) {
+            StopWatch stopWatch = new StopWatch().start();
+            final GraphExplorer accessEgressGraphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, !arriveBy, extraEdges, true, walkSpeedKmH);
+            boolean reverse = !arriveBy;
+            GtfsStorage.EdgeType edgeType = reverse ? GtfsStorage.EdgeType.EXIT_PT : GtfsStorage.EdgeType.ENTER_PT;
+            MultiCriteriaLabelSetting stationRouter = new MultiCriteriaLabelSetting(accessEgressGraphExplorer, flagEncoder, reverse, maxWalkDistancePerLeg, false, false, false, maxVisitedNodesForRequest, new ArrayList<>());
+            stationRouter.setBetaWalkTime(betaWalkTime);
+            Iterator<Label> stationIterator = stationRouter.calcLabels(destNode, startNode, initialTime, blockedRouteTypes).iterator();
+            List<Label> stationLabels = new ArrayList<>();
+            while (stationIterator.hasNext()) {
+                Label label = stationIterator.next();
+                if (label.adjNode == startNode) {
+                    stationLabels.add(label);
+                    break;
+                } else if (label.edge != -1 && flagEncoder.getEdgeType(accessEgressGraphExplorer.getEdgeIteratorState(label.edge, label.parent.adjNode).getFlags()) == edgeType) {
+                    stationLabels.add(label);
                 }
             }
-            return false;
-        }
+            visitedNodes += stationRouter.getVisitedNodes();
 
-        private int accessNode(Label solution) {
-            if (!arriveBy) {
-                while (solution.parent.parent != null) {
-                    solution = solution.parent;
-                }
-                return solution.adjNode;
-            } else {
-                return solution.parent.adjNode;
+            Map<Integer, Label> reverseSettledSet = new HashMap<>();
+            for (Label stationLabel : stationLabels) {
+                reverseSettledSet.put(stationLabel.adjNode, stationLabel);
             }
-        }
 
-        private int egressNode(Label solution) {
-            if (!arriveBy) {
-                return solution.parent.adjNode;
+            graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false, walkSpeedKmH);
+            List<Label> discoveredSolutions = new ArrayList<>();
+            final long smallestStationLabelWeight;
+            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, arriveBy, maxWalkDistancePerLeg, true, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest, discoveredSolutions);
+            router.setBetaTransfers(betaTransfers);
+            router.setBetaWalkTime(betaWalkTime);
+            if (!stationLabels.isEmpty()) {
+                smallestStationLabelWeight = stationRouter.weight(stationLabels.get(0));
             } else {
-                while(solution.parent.parent != null) {
-                    solution = solution.parent;
+                smallestStationLabelWeight = Long.MAX_VALUE;
+            }
+            Iterator<Label> iterator = router.calcLabels(startNode, destNode, initialTime, blockedRouteTypes).iterator();
+            Map<Label, Label> originalSolutions = new HashMap<>();
+
+            long highestWeightForDominationTest = Long.MAX_VALUE;
+            while (iterator.hasNext()) {
+                Label label = iterator.next();
+                final long weight = router.weight(label);
+                if ( (!profileQuery || discoveredSolutions.size() >= limitSolutions) && weight + smallestStationLabelWeight > highestWeightForDominationTest) {
+                    break;
+                }
+                Label reverseLabel = reverseSettledSet.get(label.adjNode);
+                if (reverseLabel != null) {
+                    Label combinedSolution = new Label(label.currentTime - reverseLabel.currentTime + initialTime.toEpochMilli(), -1, label.adjNode, label.nTransfers + reverseLabel.nTransfers, label.nWalkDistanceConstraintViolations + reverseLabel.nWalkDistanceConstraintViolations, label.walkDistanceOnCurrentLeg + reverseLabel.walkDistanceOnCurrentLeg, label.departureTime, label.walkTime + reverseLabel.walkTime, 0, label.impossible, null);
+                    if (router.isNotDominatedByAnyOf(combinedSolution, discoveredSolutions)) {
+                        router.removeDominated(combinedSolution, discoveredSolutions);
+                        if (discoveredSolutions.size() < limitSolutions) {
+                            discoveredSolutions.add(combinedSolution);
+                            originalSolutions.put(combinedSolution, label);
+                            if (profileQuery) {
+                                highestWeightForDominationTest = router.weight(discoveredSolutions.get(discoveredSolutions.size()-1));
+                            } else {
+                                highestWeightForDominationTest = discoveredSolutions.stream().filter(s -> !s.impossible && (ignoreTransfers || s.nTransfers <= 1)).mapToLong(router::weight).min().orElse(Long.MAX_VALUE);
+                            }
+                        }
+                    }
                 }
-                return solution.adjNode;
             }
-        }
 
-        private List<Label> findPaths(int startNode, int destNode) {
-            StopWatch stopWatch = new StopWatch().start();
-            graphExplorer = new GraphExplorer(queryGraph, flagEncoder, gtfsStorage, realtimeFeed, arriveBy, extraEdges, false, walkSpeedKmH);
-            MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, arriveBy, maxWalkDistancePerLeg, -1, !ignoreTransfers, profileQuery, maxVisitedNodesForRequest);
-            final Stream<Label> labels = router.calcLabels(startNode, destNode, initialTime, 0);
-            List<Label> solutions = labels
-                    .filter(current -> destNode == current.adjNode)
-                    .limit(limitSolutions)
-                    .collect(Collectors.toList());
+            List<List<Label.Transition>> pathsToStations = discoveredSolutions.stream()
+                    .map(originalSolutions::get)
+                    .map(l -> new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(arriveBy, flagEncoder, graphExplorer, l)).collect(Collectors.toList());
+
+            List<List<Label.Transition>> paths = pathsToStations.stream().map(p -> {
+                if (arriveBy) {
+                    List<Label.Transition> pp = new ArrayList<>(p.subList(1, p.size()));
+                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(0).label.adjNode));
+                    long diff = p.get(0).label.currentTime - pathFromStation.get(pathFromStation.size() - 1).label.currentTime;
+                    List<Label.Transition> patchedPathFromStation = pathFromStation.stream().map(t -> {
+                        return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
+                    }).collect(Collectors.toList());
+                    pp.addAll(0, patchedPathFromStation);
+                    return pp;
+                } else {
+                    List<Label.Transition> pp = new ArrayList<>(p);
+                    List<Label.Transition> pathFromStation = pathFromStation(accessEgressGraphExplorer, reverseSettledSet.get(p.get(p.size() - 1).label.adjNode));
+                    long diff = p.get(p.size() - 1).label.currentTime - pathFromStation.get(0).label.currentTime;
+                    List<Label.Transition> patchedPathFromStation = pathFromStation.subList(1, pathFromStation.size()).stream().map(t -> {
+                        return new Label.Transition(new Label(t.label.currentTime + diff, t.label.edge, t.label.adjNode, t.label.nTransfers, t.label.nWalkDistanceConstraintViolations, t.label.walkDistanceOnCurrentLeg, t.label.departureTime, t.label.walkTime, t.label.residualDelay, t.label.impossible, null), t.edge);
+                    }).collect(Collectors.toList());
+                    pp.addAll(patchedPathFromStation);
+                    return pp;
+                }
+            }).collect(Collectors.toList());
+
+            visitedNodes += router.getVisitedNodes();
             response.addDebugInfo("routing:" + stopWatch.stop().getSeconds() + "s");
-            if (solutions.isEmpty() && router.getVisitedNodes() >= maxVisitedNodesForRequest) {
+            if (discoveredSolutions.isEmpty() && router.getVisitedNodes() >= maxVisitedNodesForRequest) {
                 throw new IllegalArgumentException("No path found - maximum number of nodes exceeded: " + maxVisitedNodesForRequest);
             }
-            response.getHints().put("visited_nodes.sum", router.getVisitedNodes());
-            response.getHints().put("visited_nodes.average", router.getVisitedNodes());
-            if (solutions.isEmpty()) {
+            response.getHints().put("visited_nodes.sum", visitedNodes);
+            response.getHints().put("visited_nodes.average", visitedNodes);
+            if (discoveredSolutions.isEmpty()) {
                 response.addError(new RuntimeException("No route found"));
             }
-            return solutions;
+            return paths;
+        }
+
+        private List<Label.Transition> pathFromStation(GraphExplorer accessEgressGraphExplorer, Label l) {
+            return new TripFromLabel(gtfsStorage, realtimeFeed).getTransitions(!arriveBy, flagEncoder, accessEgressGraphExplorer, l);
         }
     }
 
     public GraphHopperGtfs(PtFlagEncoder flagEncoder, TranslationMap translationMap, GraphHopperStorage graphHopperStorage, LocationIndex locationIndex, GtfsStorage gtfsStorage, RealtimeFeed realtimeFeed) {
         this.flagEncoder = flagEncoder;
+        this.accessEgressWeighting = new FastestWeighting(graphHopperStorage.getEncodingManager().getEncoder("foot"));
         this.translationMap = translationMap;
         this.graphHopperStorage = graphHopperStorage;
         this.locationIndex = locationIndex;
@@ -318,7 +323,7 @@ public static TranslationMap createTranslationMap() {
         return new TranslationMap().doImport();
     }
 
-    public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingManager encodingManager, PtFlagEncoder ptFlagEncoder, GtfsStorage gtfsStorage, boolean createWalkNetwork, Collection<String> gtfsFiles, Collection<String> osmFiles) {
+    public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingManager encodingManager, PtFlagEncoder ptFlagEncoder, GtfsStorage gtfsStorage, Collection<String> gtfsFiles, Collection<String> osmFiles) {
         GraphHopperStorage graphHopperStorage = new GraphHopperStorage(directory, encodingManager, false, gtfsStorage);
         if (graphHopperStorage.loadExisting()) {
             return graphHopperStorage;
@@ -334,7 +339,7 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                     throw new RuntimeException(e);
                 }
             }
-            new PrepareRoutingSubnetworks(graphHopperStorage, Collections.singletonList(ptFlagEncoder)).doWork();
+            new PrepareRoutingSubnetworks(graphHopperStorage, Collections.singletonList(encodingManager.getEncoder("foot"))).doWork();
 
             int id = 0;
             for (String gtfsFile : gtfsFiles) {
@@ -344,9 +349,6 @@ public static GraphHopperStorage createOrLoad(GHDirectory directory, EncodingMan
                     throw new RuntimeException(e);
                 }
             }
-            if (createWalkNetwork) {
-                FakeWalkNetworkBuilder.buildWalkNetwork(((GtfsStorage) graphHopperStorage.getExtension()).getGtfsFeeds().values(), graphHopperStorage, ptFlagEncoder, Helper.DIST_EARTH);
-            }
             LocationIndex walkNetworkIndex;
             if (graphHopperStorage.getNodes() > 0) {
                 walkNetworkIndex = new LocationIndexTree(graphHopperStorage, new RAMDirectory()).prepareIndex();
@@ -415,9 +417,9 @@ public GHResponse route(GHRequest request) {
 
                     QueryGraph queryGraph = new QueryGraph(graphHopperStorage);
                     queryGraph.lookup(Collections.emptyList());
-                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, flagEncoder, gtfsStorage, realtimeFeed, false, Collections.emptyList(), true, 5.0);
+                    final GraphExplorer graphExplorer = new GraphExplorer(queryGraph, accessEgressWeighting, flagEncoder, gtfsStorage, realtimeFeed, false, Collections.emptyList(), true, 5.0);
 
-                    MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, false, Double.MAX_VALUE, Double.MAX_VALUE, false, false, Integer.MAX_VALUE);
+                    MultiCriteriaLabelSetting router = new MultiCriteriaLabelSetting(graphExplorer, flagEncoder, false, Double.MAX_VALUE, false, false, false, Integer.MAX_VALUE, new ArrayList<>());
                     final Stream<Label> labels = router.calcLabels(fromnode, tonode, Instant.ofEpochMilli(0), 0);
                     List<Label> solutions = labels
                             .filter(current -> tonode == current.adjNode)
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
index 3a7aefb3c5..bf0290d28e 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/GtfsReader.java
@@ -155,6 +155,7 @@ void connectStopsToStreetNetwork() {
                 EdgeIteratorState edge = graph.edge(streetNode, streetNode);
                 edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                 edge.setFlags(footEncoder.setAccess(edge.getFlags(), true, false));
+                edge.setFlags(footEncoder.setSpeed(edge.getFlags(), 5.0));
             } else {
                 streetNode = locationQueryResult.getClosestNode();
             }
@@ -222,7 +223,7 @@ void wireUpStops() {
 
                         EdgeIteratorState exitEdge = graph.edge(stopExitNode, streetNode);
                         exitEdge.setFlags(encoder.setAccess(exitEdge.getFlags(), true, false));
-                        setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
+                        setEdgeTypeAndClearDistance(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
                         exitEdge.setFlags(encoder.setValidityId(exitEdge.getFlags(), route.route_type));
                         exitEdge.setName(stop.stop_name);
                         gtfsStorage.getRoutes().put(exitEdge.getEdge(), routeId);
@@ -244,7 +245,7 @@ void wireUpStops() {
 
                         EdgeIteratorState entryEdge = graph.edge(streetNode, stopEnterNode);
                         entryEdge.setFlags(encoder.setAccess(entryEdge.getFlags(), true, false));
-                        setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
+                        setEdgeTypeAndClearDistance(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
                         entryEdge.setFlags(encoder.setValidityId(entryEdge.getFlags(), route.route_type));
                         entryEdge.setName(stop.stop_name);
                         gtfsStorage.getRoutes().put(entryEdge.getEdge(), routeId);
@@ -274,7 +275,7 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                             Fun.Tuple2<Integer, Integer> before = headSet.last();
                             EdgeIteratorState edge = graph.edge(before.b, timelineNode.b);
                             edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                            setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
+                            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
                             edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a-before.a));
                         }
                         SortedSet<Fun.Tuple2<Integer, Integer>> tailSet = staticTimelineNodesForRoute.tailSet(timelineNode);
@@ -282,7 +283,7 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                             Fun.Tuple2<Integer, Integer> after = tailSet.first();
                             EdgeIteratorState edge = graph.edge(timelineNode.b, after.b);
                             edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                            setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
+                            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
                             edge.setFlags(encoder.setTime(edge.getFlags(), after.a-timelineNode.a));
 
 //                            System.out.println(" "+ after);
@@ -297,7 +298,7 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
 
                         EdgeIteratorState edge = graph.edge(platformNode, timelineNode.b);
                         edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                        setEdgeType(edge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
+                        setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
                         edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
                         setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
                     });
@@ -307,7 +308,7 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                     nodeAccess.setAdditionalNodeField(stopEnterNode, NodeType.STOP_ENTER_NODE.ordinal());
                     EdgeIteratorState entryEdge = graph.edge(stationNode, stopEnterNode);
                     entryEdge.setFlags(encoder.setAccess(entryEdge.getFlags(), true, false));
-                    setEdgeType(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
+                    setEdgeTypeAndClearDistance(entryEdge, GtfsStorage.EdgeType.ENTER_PT);
                     entryEdge.setName(stop.stop_name);
                     NavigableSet<Fun.Tuple2<Integer, Integer>> timeNodes = sorted(timelineNodesWithTripId);
                     wireUpAndAndConnectDepartureTimeline(stop, routeId,stopEnterNode, timeNodes);
@@ -323,7 +324,7 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                     realtimeTimelineIterator.forEachRemaining(timelineNode -> {
                         EdgeIteratorState edge = graph.edge(timelineNode.b, platformNode);
                         edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                        setEdgeType(edge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
+                        setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
                         edge.setFlags(encoder.setTime(edge.getFlags(), timelineNode.a));
                         setFeedIdWithTimezone(edge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
                     });
@@ -333,7 +334,7 @@ void wireUpAdditionalDepartures(ZoneId zoneId) {
                     nodeAccess.setAdditionalNodeField(stopExitNode, NodeType.STOP_EXIT_NODE.ordinal());
                     EdgeIteratorState exitEdge = graph.edge(stopExitNode, stationNode);
                     exitEdge.setFlags(encoder.setAccess(exitEdge.getFlags(), true, false));
-                    setEdgeType(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
+                    setEdgeTypeAndClearDistance(exitEdge, GtfsStorage.EdgeType.EXIT_PT);
                     exitEdge.setName(stop.stop_name);
                     wireUpAndAndConnectArrivalTimeline(stop, routeId,stopExitNode, timeNodes);
                 }
@@ -459,7 +460,7 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
                 edge.setDistance(distance);
                 edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
                 edge.setName(stop.stop_name);
-                setEdgeType(edge, GtfsStorage.EdgeType.HOP);
+                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.HOP);
                 edge.setFlags(encoder.setTime(edge.getFlags(), stopTime.arrival_time - prev.departure_time));
                 gtfsStorage.getStopSequences().put(edge.getEdge(), stopTime.stop_sequence);
             }
@@ -490,7 +491,7 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
             EdgeIteratorState boardEdge = graph.edge(departureTimelineNode, departureNode);
             boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
             boardEdge.setName(getRouteName(feed, trip.trip));
-            setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
+            setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
             while (boardEdges.size() < stopTime.stop_sequence) {
                 boardEdges.add(-1); // Padding, so that index == stop_sequence
             }
@@ -503,7 +504,7 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
             EdgeIteratorState alightEdge = graph.edge(arrivalNode, arrivalTimelineNode);
             alightEdge.setFlags(encoder.setAccess(alightEdge.getFlags(), true, false));
             alightEdge.setName(getRouteName(feed, trip.trip));
-            setEdgeType(alightEdge, GtfsStorage.EdgeType.ALIGHT);
+            setEdgeTypeAndClearDistance(alightEdge, GtfsStorage.EdgeType.ALIGHT);
             while (alightEdges.size() < stopTime.stop_sequence) {
                 alightEdges.add(-1);
             }
@@ -517,7 +518,7 @@ void addTrip(ZoneId zoneId, int time, List<TripWithStopTimeAndArrivalNode> arriv
             EdgeIteratorState dwellEdge = graph.edge(arrivalNode, departureNode);
             dwellEdge.setFlags(encoder.setAccess(dwellEdge.getFlags(), true, false));
             dwellEdge.setName(getRouteName(feed, trip.trip));
-            setEdgeType(dwellEdge, GtfsStorage.EdgeType.DWELL);
+            setEdgeTypeAndClearDistance(dwellEdge, GtfsStorage.EdgeType.DWELL);
             dwellEdge.setFlags(encoder.setTime(dwellEdge.getFlags(), stopTime.departure_time - stopTime.arrival_time));
             if (prev == null) {
                 insertInboundBlockTransfers(arrivalNodes, tripDescriptor, departureNode, stopTime, stop, validOn, zoneId);
@@ -555,7 +556,7 @@ int addDelayedBoardEdge(ZoneId zoneId, GtfsRealtime.TripDescriptor tripDescripto
         EdgeIteratorState boardEdge = graph.edge(departureTimelineNode, departureNode);
         boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
         boardEdge.setName(getRouteName(feed, trip));
-        setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
+        setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
         gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopSequence);
         gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
         boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), validityId));
@@ -570,14 +571,14 @@ private void wireUpAndAndConnectArrivalTimeline(Stop toStop, String routeId, int
         for (Fun.Tuple2<Integer, Integer> e : timeNodes.descendingSet()) {
             EdgeIteratorState leaveTimeExpandedNetworkEdge = graph.edge(e.b, stopExitNode);
             leaveTimeExpandedNetworkEdge.setFlags(encoder.setAccess(leaveTimeExpandedNetworkEdge.getFlags(), true, false));
-            setEdgeType(leaveTimeExpandedNetworkEdge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
+            setEdgeTypeAndClearDistance(leaveTimeExpandedNetworkEdge, GtfsStorage.EdgeType.LEAVE_TIME_EXPANDED_NETWORK);
             int arrivalTime = e.a;
             leaveTimeExpandedNetworkEdge.setFlags(encoder.setTime(leaveTimeExpandedNetworkEdge.getFlags(), arrivalTime));
             setFeedIdWithTimezone(leaveTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
             if (prev != -1) {
                 EdgeIteratorState edge = graph.edge(e.b, prev);
                 edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                setEdgeType(edge, GtfsStorage.EdgeType.WAIT_ARRIVAL);
+                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT_ARRIVAL);
                 edge.setName(toStop.stop_name);
                 edge.setFlags(encoder.setTime(edge.getFlags(), time-e.a));
             }
@@ -605,13 +606,13 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
             EdgeIteratorState enterTimeExpandedNetworkEdge = graph.edge(stopEnterNode, e.b);
             enterTimeExpandedNetworkEdge.setFlags(encoder.setAccess(enterTimeExpandedNetworkEdge.getFlags(), true, false));
             enterTimeExpandedNetworkEdge.setName(toStop.stop_name);
-            setEdgeType(enterTimeExpandedNetworkEdge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
+            setEdgeTypeAndClearDistance(enterTimeExpandedNetworkEdge, GtfsStorage.EdgeType.ENTER_TIME_EXPANDED_NETWORK);
             enterTimeExpandedNetworkEdge.setFlags(encoder.setTime(enterTimeExpandedNetworkEdge.getFlags(), e.a));
             setFeedIdWithTimezone(enterTimeExpandedNetworkEdge, new GtfsStorage.FeedIdWithTimezone(id, zoneId));
             if (prev != -1) {
                 EdgeIteratorState edge = graph.edge(e.b, prev);
                 edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                setEdgeType(edge, GtfsStorage.EdgeType.WAIT);
+                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.WAIT);
                 edge.setName(toStop.stop_name);
                 edge.setFlags(encoder.setTime(edge.getFlags(), time-e.a));
             }
@@ -622,7 +623,7 @@ private void wireUpAndAndConnectDepartureTimeline(Stop toStop, String toRouteId,
             EdgeIteratorState edge = graph.edge(timeNodes.last().b, timeNodes.first().b);
             edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
             int rolloverTime = 24 * 60 * 60 - timeNodes.last().a + timeNodes.first().a;
-            setEdgeType(edge, GtfsStorage.EdgeType.OVERNIGHT);
+            setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.OVERNIGHT);
             edge.setName(toStop.stop_name);
             edge.setFlags(encoder.setTime(edge.getFlags(), rolloverTime));
         }
@@ -651,11 +652,11 @@ private void insertInboundBlockTransfers(List<TripWithStopTimeAndArrivalNode> ar
                 nodeAccess.setAdditionalNodeField(i-1, NodeType.INTERNAL_PT.ordinal());
                 EdgeIteratorState transferEdge = graph.edge(lastTrip.arrivalNode,i-1);
                 transferEdge.setFlags(encoder.setAccess(transferEdge.getFlags(), true, false));
-                setEdgeType(transferEdge, GtfsStorage.EdgeType.TRANSFER);
+                setEdgeTypeAndClearDistance(transferEdge, GtfsStorage.EdgeType.TRANSFER);
                 transferEdge.setFlags(encoder.setTime(transferEdge.getFlags(), dwellTime));
                 EdgeIteratorState boardEdge = graph.edge(i-1, departureNode);
                 boardEdge.setFlags(encoder.setAccess(boardEdge.getFlags(), true, false));
-                setEdgeType(boardEdge, GtfsStorage.EdgeType.BOARD);
+                setEdgeTypeAndClearDistance(boardEdge, GtfsStorage.EdgeType.BOARD);
                 boardEdge.setFlags(encoder.setValidityId(boardEdge.getFlags(), blockTransferValidityId));
                 gtfsStorage.getStopSequences().put(boardEdge.getEdge(), stopTime.stop_sequence);
                 gtfsStorage.getTripDescriptors().put(boardEdge.getEdge(), tripDescriptor.toByteArray());
@@ -690,7 +691,7 @@ private void insertInboundTransfers(String fromStopId, String from_route_id, int
                                 Fun.Tuple2<Integer, Integer> e = tailSet.first();
                                 EdgeIteratorState edge = graph.edge(j.getAdjNode(), e.b);
                                 edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                                setEdgeType(edge, GtfsStorage.EdgeType.TRANSFER);
+                                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.TRANSFER);
                                 edge.setFlags(encoder.setTime(edge.getFlags(), e.a - arrivalTime));
                             }
                         }
@@ -719,7 +720,7 @@ private void insertOutboundTransfers(String toStopId, String toRouteId, int mini
                                 }
                                 EdgeIteratorState edge = graph.edge(e.b, j.getAdjNode());
                                 edge.setFlags(encoder.setAccess(edge.getFlags(), true, false));
-                                setEdgeType(edge, GtfsStorage.EdgeType.TRANSFER);
+                                setEdgeTypeAndClearDistance(edge, GtfsStorage.EdgeType.TRANSFER);
                                 edge.setFlags(encoder.setTime(edge.getFlags(), departureTime - e.a));
                                 break;
                             }
@@ -735,7 +736,8 @@ private String getRouteName(GTFSFeed feed, Trip trip) {
         return (route.route_long_name != null ? route.route_long_name : route.route_short_name) + " " + trip.trip_headsign;
     }
 
-    private void setEdgeType(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
+    private void setEdgeTypeAndClearDistance(EdgeIteratorState edge, GtfsStorage.EdgeType edgeType) {
+        edge.setDistance(0.0);
         edge.setFlags(encoder.setEdgeType(edge.getFlags(), edgeType));
     }
 
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
index 1d1bdfc816..4a9ea82d7e 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/Label.java
@@ -117,7 +117,14 @@ public Transition next() {
                             return new Transition(label, null);
                         } else {
                             EdgeIteratorState edgeIteratorState = label.parent == null ? null :
-                                    graph.getEdgeIteratorState(label.edge, label.parent.adjNode).detach(reverseEdgeFlags);
+                                    graph.getEdgeIteratorState(label.edge, reverseEdgeFlags ? label.adjNode : label.parent.adjNode).detach(false);
+                            if (reverseEdgeFlags && edgeIteratorState != null && (edgeIteratorState.getBaseNode() != label.parent.adjNode || edgeIteratorState.getAdjNode() != label.adjNode)) {
+                                throw new IllegalStateException();
+                            }
+                            if (!reverseEdgeFlags && edgeIteratorState != null && (edgeIteratorState.getAdjNode() != label.parent.adjNode || edgeIteratorState.getBaseNode() != label.adjNode)) {
+                                throw new IllegalStateException();
+                            }
+
                             Transition transition;
                             if (reverseEdgeFlags) {
                                 transition = new Transition(label, edgeIteratorState != null ? getEdgeLabel(edgeIteratorState, flagEncoder) : null);
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
index fd5d8e6dec..89afa87e61 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/MultiCriteriaLabelSetting.java
@@ -40,6 +40,7 @@
 class MultiCriteriaLabelSetting {
 
     private final Comparator<Label> queueComparator;
+    private final List<Label> targetLabels;
     private long startTime;
     private int blockedRouteTypes;
     private final PtFlagEncoder flagEncoder;
@@ -48,27 +49,29 @@
     private final int maxVisitedNodes;
     private final boolean reverse;
     private final double maxWalkDistancePerLeg;
-    private final double maxTransferDistancePerLeg;
+    private final boolean ptOnly;
     private final boolean mindTransfers;
     private final boolean profileQuery;
     private int visitedNodes;
     private final GraphExplorer explorer;
+    private double betaTransfers;
+    private double betaWalkTime = 1.0;
 
-    MultiCriteriaLabelSetting(GraphExplorer explorer, PtFlagEncoder flagEncoder, boolean reverse, double maxWalkDistancePerLeg, double maxTransferDistancePerLeg, boolean mindTransfers, boolean profileQuery, int maxVisitedNodes) {
+    MultiCriteriaLabelSetting(GraphExplorer explorer, PtFlagEncoder flagEncoder, boolean reverse, double maxWalkDistancePerLeg, boolean ptOnly, boolean mindTransfers, boolean profileQuery, int maxVisitedNodes, List<Label> solutions) {
         this.flagEncoder = flagEncoder;
         this.maxVisitedNodes = maxVisitedNodes;
         this.explorer = explorer;
         this.reverse = reverse;
         this.maxWalkDistancePerLeg = maxWalkDistancePerLeg;
-        this.maxTransferDistancePerLeg = maxTransferDistancePerLeg;
+        this.ptOnly = ptOnly;
         this.mindTransfers = mindTransfers;
         this.profileQuery = profileQuery;
+        this.targetLabels = solutions;
 
-        queueComparator = Comparator.<Label>comparingLong(l2 -> l2.impossible ? 1 : 0)
-                .thenComparing(Comparator.comparingLong(l2 -> currentTimeCriterion(l2)))
+        queueComparator = Comparator.<Label>comparingLong(l2 -> weight(l2))
                 .thenComparing(Comparator.comparingLong(l1 -> l1.nTransfers))
-                .thenComparing(Comparator.comparingLong(l1 -> l1.nWalkDistanceConstraintViolations))
-                .thenComparing(Comparator.comparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0));
+                .thenComparing(Comparator.comparingLong(l -> departureTimeCriterion(l) != null ? departureTimeCriterion(l) : 0))
+                .thenComparing(Comparator.comparingLong(l2 -> l2.impossible ? 1 : 0));
         fromHeap = new PriorityQueue<>(queueComparator);
         fromMap = ArrayListMultimap.create();
     }
@@ -81,23 +84,28 @@
                 .peek(label -> visitedNodes++);
     }
 
+    // experimental
+    void setBetaTransfers(double betaTransfers) {
+        this.betaTransfers = betaTransfers;
+    }
+
+    // experimental
+    void setBetaWalkTime(double betaWalkTime) {
+        this.betaWalkTime = betaWalkTime;
+    }
+
     private class MultiCriteriaLabelSettingSpliterator extends Spliterators.AbstractSpliterator<Label> {
 
         private final int from;
         private final int to;
-        private final Collection<Label> targetLabels;
 
         MultiCriteriaLabelSettingSpliterator(int from, int to) {
             super(0, 0);
             this.from = from;
             this.to = to;
-            targetLabels = new ArrayList<>();
             Label label = new Label(startTime, EdgeIterator.NO_EDGE, from, 0, 0, 0.0, null, 0, 0,false,null);
             fromMap.put(from, label);
             fromHeap.add(label);
-            if (to == from) {
-                targetLabels.add(label);
-            }
         }
 
         @Override
@@ -109,9 +117,8 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                 action.accept(label);
                 explorer.exploreEdgesAround(label).forEach(edge -> {
                     GtfsStorage.EdgeType edgeType = flagEncoder.getEdgeType(edge.getFlags());
-                    if (edgeType == GtfsStorage.EdgeType.HIGHWAY && maxTransferDistancePerLeg <= 0.0) return;
-                    if (edgeType == GtfsStorage.EdgeType.ENTER_PT && ((reverse?edge.getAdjNode():edge.getBaseNode()) != (reverse?to:from)) && maxTransferDistancePerLeg <= 0.0) return;
-                    if (edgeType == GtfsStorage.EdgeType.EXIT_PT && ((reverse?edge.getBaseNode():edge.getAdjNode()) != (reverse?from:to)) && maxTransferDistancePerLeg <= 0.0) return;
+                    if (edgeType == GtfsStorage.EdgeType.ENTER_PT && reverse && ptOnly) return;
+                    if (edgeType == GtfsStorage.EdgeType.EXIT_PT && !reverse && ptOnly) return;
                     if ((edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT) && (blockedRouteTypes & (1 << flagEncoder.getValidityId(edge.getFlags()))) != 0) return;
                     long nextTime;
                     if (reverse) {
@@ -130,11 +137,11 @@ public boolean tryAdvance(Consumer<? super Label> action) {
                             firstPtDepartureTime = nextTime - label.walkTime;
                         }
                     }
-                    double walkDistanceOnCurrentLeg = (!reverse && edgeType == GtfsStorage.EdgeType.BOARD || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT) ? 0 : (label.walkDistanceOnCurrentLeg + explorer.getWalkDistance(edge));
-                    boolean isTryingToReEnterPtAfterTransferWalking = (!reverse && edgeType == GtfsStorage.EdgeType.ENTER_PT || reverse && edgeType == GtfsStorage.EdgeType.EXIT_PT) && label.nTransfers > 0 && label.walkDistanceOnCurrentLeg > maxTransferDistancePerLeg;
-                    long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY || edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT ? nextTime - label.currentTime : 0);
+                    double walkDistanceOnCurrentLeg = (!reverse && edgeType == GtfsStorage.EdgeType.BOARD || reverse && edgeType == GtfsStorage.EdgeType.ALIGHT) ? 0 : (label.walkDistanceOnCurrentLeg + edge.getDistance());
+                    boolean isTryingToReEnterPtAfterWalking = (!reverse && edgeType == GtfsStorage.EdgeType.ENTER_PT || reverse && edgeType == GtfsStorage.EdgeType.EXIT_PT) && label.nTransfers > 0;
+                    long walkTime = label.walkTime + (edgeType == GtfsStorage.EdgeType.HIGHWAY || edgeType == GtfsStorage.EdgeType.ENTER_PT || edgeType == GtfsStorage.EdgeType.EXIT_PT ? ((reverse ? -1 : 1) * (nextTime - label.currentTime)) : 0);
                     int nWalkDistanceConstraintViolations = Math.min(1, label.nWalkDistanceConstraintViolations + (
-                            isTryingToReEnterPtAfterTransferWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
+                            isTryingToReEnterPtAfterWalking ? 1 : (label.walkDistanceOnCurrentLeg <= maxWalkDistancePerLeg && walkDistanceOnCurrentLeg > maxWalkDistancePerLeg ? 1 : 0)));
                     Collection<Label> sptEntries = fromMap.get(edge.getAdjNode());
                     boolean impossible = label.impossible
                             || explorer.isBlocked(edge)
@@ -174,22 +181,18 @@ public boolean tryAdvance(Consumer<? super Label> action) {
             }
         }
 
-        private void insertIfNotDominated(EdgeIteratorState edge, Collection<Label> sptEntries, Label nEdge) {
-            if (isNotDominatedByAnyOf(nEdge, sptEntries) && isNotDominatedByAnyOf(nEdge, targetLabels)) {
-                removeDominated(nEdge, sptEntries);
-                if (to == edge.getAdjNode()) {
-                    removeDominated(nEdge, targetLabels);
-                }
-                fromMap.put(edge.getAdjNode(), nEdge);
-                if (to == edge.getAdjNode()) {
-                    targetLabels.add(nEdge);
+        private void insertIfNotDominated(EdgeIteratorState edge, Collection<Label> sptEntries, Label label) {
+            if (isNotDominatedByAnyOf(label, sptEntries)) {
+                if (isNotDominatedByAnyOf(label, targetLabels)) {
+                    removeDominated(label, sptEntries);
+                    fromMap.put(edge.getAdjNode(), label);
+                    fromHeap.add(label);
                 }
-                fromHeap.add(nEdge);
             }
         }
     }
 
-    private boolean isNotDominatedByAnyOf(Label me, Collection<Label> sptEntries) {
+    boolean isNotDominatedByAnyOf(Label me, Collection<Label> sptEntries) {
         if (me.nWalkDistanceConstraintViolations > 0) {
             return false;
         }
@@ -202,7 +205,7 @@ private boolean isNotDominatedByAnyOf(Label me, Collection<Label> sptEntries) {
     }
 
 
-    private void removeDominated(Label me, Collection<Label> sptEntries) {
+    void removeDominated(Label me, Collection<Label> sptEntries) {
         for (Iterator<Label> iterator = sptEntries.iterator(); iterator.hasNext();) {
             Label sptEntry = iterator.next();
             if (dominates(me, sptEntry)) {
@@ -213,19 +216,17 @@ private void removeDominated(Label me, Collection<Label> sptEntries) {
     }
 
     private boolean dominates(Label me, Label they) {
+        if (weight(me) > weight(they))
+            return false;
+
         if (profileQuery) {
             if (me.departureTime != null && they.departureTime != null) {
-                if (currentTimeCriterion(me) > currentTimeCriterion(they))
-                    return false;
                 if (departureTimeCriterion(me) > departureTimeCriterion(they))
                     return false;
             } else {
                 if (travelTimeCriterion(me) > travelTimeCriterion(they))
                     return false;
             }
-        } else {
-            if (currentTimeCriterion(me) > currentTimeCriterion(they))
-                return false;
         }
 
         if (mindTransfers && me.nTransfers > they.nTransfers)
@@ -235,19 +236,16 @@ private boolean dominates(Label me, Label they) {
         if (me.impossible && !they.impossible)
             return false;
 
+        if (weight(me) < weight(they))
+            return true;
         if (profileQuery) {
             if (me.departureTime != null && they.departureTime != null) {
-                if (currentTimeCriterion(me) < currentTimeCriterion(they))
-                    return true;
                 if (departureTimeCriterion(me) < departureTimeCriterion(they))
                     return true;
             } else {
                 if (travelTimeCriterion(me) < travelTimeCriterion(they))
                     return true;
             }
-        } else {
-            if (currentTimeCriterion(me) < currentTimeCriterion(they))
-                return true;
         }
         if (mindTransfers && me.nTransfers  < they.nTransfers)
             return true;
@@ -261,8 +259,8 @@ private Long departureTimeCriterion(Label label) {
         return label.departureTime == null ? null : reverse ? label.departureTime : -label.departureTime;
     }
 
-    private long currentTimeCriterion(Label label) {
-        return reverse ? -label.currentTime : label.currentTime;
+    long weight(Label label) {
+        return (reverse ? -1 : 1) * (label.currentTime - startTime) + (long) (label.nTransfers * betaTransfers) + (long) (label.walkTime * (betaWalkTime - 1.0));
     }
 
     private long travelTimeCriterion(Label label) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
index dd1cb35e1e..e0a9ecf87d 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/PtFlagEncoder.java
@@ -23,11 +23,9 @@
 import com.graphhopper.routing.util.AbstractFlagEncoder;
 import com.graphhopper.routing.util.EncodedDoubleValue;
 import com.graphhopper.routing.util.EncodedValue;
-import com.graphhopper.routing.util.FootFlagEncoder;
 
 public class PtFlagEncoder extends AbstractFlagEncoder {
 
-	private final FootFlagEncoder footFlagEncoder;
 	private EncodedValue time;
 	private EncodedValue transfers;
 	private EncodedValue validityId;
@@ -35,14 +33,6 @@
 
 	public PtFlagEncoder() {
 		super(0, 1, 0);
-
-		// I use the foot flag encoder only as a delegate to filter by OSM tags,
-		// not to encode flags.
-		footFlagEncoder = new FootFlagEncoder();
-		// Still, I have to do this. Otherwise 'acceptWay' returns 0 even though
-		// it wants to accept. Basically, I have to tell it what 'true' means.
-		footFlagEncoder.defineWayBits(1, 0);
-		footFlagEncoder.defineRelationBits(1, 0);
 	}
 
 	@Override
@@ -68,17 +58,17 @@ public int defineWayBits(int index, int shift) {
 
 	@Override
 	public long handleRelationTags(ReaderRelation relation, long oldRelationFlags) {
-		return footFlagEncoder.handleRelationTags(relation, oldRelationFlags);
+		return oldRelationFlags;
 	}
 
 	@Override
 	public long acceptWay(ReaderWay way) {
-		return footFlagEncoder.acceptWay(way);
+		return 0;
 	}
 
 	@Override
 	public long handleWayTags(ReaderWay way, long allowed, long relationFlags) {
-		return footFlagEncoder.handleWayTags(way, allowed, relationFlags);
+		return 0;
 	}
 
 	long getTime(long flags) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
index 2a45fa86c1..714f7436d8 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/RealtimeFeed.java
@@ -61,6 +61,7 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 import java.util.stream.StreamSupport;
 
 import static com.google.transit.realtime.GtfsRealtime.TripUpdate.StopTimeUpdate.ScheduleRelationship.NO_DATA;
@@ -112,7 +113,6 @@ public static RealtimeFeed fromProtobuf(GraphHopperStorage graphHopperStorage, G
         final IntLongHashMap delaysForAlightEdges = new IntLongHashMap();
         final LinkedList<VirtualEdgeIteratorState> additionalEdges = new LinkedList<>();
         final Graph overlayGraph = new Graph() {
-            int nNodes = 0;
             int firstEdge = graphHopperStorage.getAllEdges().length();
             final NodeAccess nodeAccess = new NodeAccess() {
                 IntIntHashMap additionalNodeFields = new IntIntHashMap();
@@ -189,7 +189,10 @@ public Graph getBaseGraph() {
 
             @Override
             public int getNodes() {
-                return graphHopperStorage.getNodes() + nNodes;
+                return IntStream.concat(
+                        IntStream.of(graphHopperStorage.getNodes()-1),
+                        additionalEdges.stream().flatMapToInt(edge -> IntStream.of(edge.getBaseNode(), edge.getAdjNode())))
+                        .max().getAsInt()+1;
             }
 
             @Override
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
index d668033935..70b9f4550e 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/TripFromLabel.java
@@ -120,6 +120,17 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
     }
 
     List<Trip.Leg> getTrip(boolean arriveBy, PtFlagEncoder encoder, Translation tr, GraphExplorer queryGraph, Weighting weighting, Label solution) {
+        List<Label.Transition> transitions = getTransitions(arriveBy, encoder, queryGraph, solution);
+        return getTrip(tr, queryGraph, weighting, transitions);
+    }
+
+    List<Trip.Leg> getTrip(Translation tr, GraphExplorer queryGraph, Weighting weighting, List<Label.Transition> transitions) {
+        final List<List<Label.Transition>> partitions = getPartitions(transitions);
+        final List<Trip.Leg> legs = getLegs(tr, queryGraph, weighting, partitions);
+        return legs;
+    }
+
+    List<Label.Transition> getTransitions(boolean arriveBy, PtFlagEncoder encoder, GraphExplorer queryGraph, Label solution) {
         List<Label.Transition> transitions = new ArrayList<>();
         if (arriveBy) {
             reverseEdges(solution, queryGraph, encoder, false)
@@ -129,11 +140,7 @@ PathWrapper createPathWrapper(Translation tr, PointList waypoints, List<Trip.Leg
                     .forEach(transitions::add);
             Collections.reverse(transitions);
         }
-
-
-        final List<List<Label.Transition>> partitions = getPartitions(transitions);
-        final List<Trip.Leg> legs = getLegs(tr, queryGraph, weighting, partitions);
-        return legs;
+        return transitions;
     }
 
     private List<List<Label.Transition>> getPartitions(List<Label.Transition> transitions) {
diff --git a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
index 3473ed84ae..3255171196 100644
--- a/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
+++ b/reader-gtfs/src/main/java/com/graphhopper/reader/gtfs/WrapperGraph.java
@@ -87,7 +87,7 @@ public AllEdgesIterator getAllEdges() {
             @Override
             public int length() {
                 return IntStream.concat(
-                        IntStream.of(baseGraph.getAllEdges().length()),
+                        IntStream.of(baseGraph.getAllEdges().length() - 1),
                         extraEdges.stream().mapToInt(VirtualEdgeIteratorState::getEdge))
                         .max().getAsInt();
             }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
index ece1abf017..686e1c46b2 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/AnotherAgencyIT.java
@@ -58,7 +58,7 @@ public static void init() {
         EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Arrays.asList("files/sample-feed.zip", "files/another-sample-feed.zip"), Collections.emptyList());
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Arrays.asList("files/sample-feed.zip", "files/another-sample-feed.zip"), Collections.emptyList());
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
index 2952deddbf..dc19f9e50f 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperGtfsIT.java
@@ -31,6 +31,7 @@
 import com.graphhopper.util.Instruction;
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
+import org.junit.Assume;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -69,7 +70,7 @@ public static void init() {
         EncodingManager encodingManager = new EncodingManager(Arrays.asList(carFlagEncoder, footFlagEncoder, ptFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
@@ -213,6 +214,31 @@ public void testRoute1ProfileEarliestArrival() {
         assertEquals(expectedDepartureTimes, actualDepartureTimes);
     }
 
+    @Test
+    public void testRoute1ProfileOvernight() {
+        final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
+        final double TO_LAT = 36.914944, TO_LON = -116.761472; // NANAA stop
+        GHRequest ghRequest = new GHRequest(
+                FROM_LAT, FROM_LON,
+                TO_LAT, TO_LON
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,23,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 21);
+
+        GHResponse response = graphHopper.route(ghRequest);
+        List<LocalTime> actualDepartureTimes = response.getAll().stream()
+                .map(path -> LocalTime.from(((Trip.PtLeg) path.getLegs().get(0)).getDepartureTime().toInstant().atZone(zoneId)))
+                .collect(Collectors.toList());
+        List<LocalTime> expectedDepartureTimes = Stream.of(
+                "06:44", "07:14", "07:44", "08:14", "08:44", "08:54", "09:04", "09:14", "09:24", "09:34", "09:44", "09:54",
+                "10:04", "10:14", "10:24", "10:34", "10:44", "11:14", "11:44", "12:14", "12:44")
+                .map(LocalTime::parse)
+                .collect(Collectors.toList());
+        assertEquals(expectedDepartureTimes, actualDepartureTimes);
+    }
+
     @Test
     public void testRoute1ProfileLatestDeparture() {
         final double FROM_LAT = 36.914893, FROM_LON = -116.76821; // NADAV stop
@@ -489,6 +515,43 @@ public void testTransferByArrival() {
         assertEquals("Arrive at 7:20", LocalDateTime.parse("2007-01-01T07:20:00").atZone(zoneId).toInstant(), lastStop.plannedArrivalTime.toInstant());
     }
 
+    @Test
+    public void testCustomObjectiveFunction() {
+        GHRequest ghRequest = new GHRequest(
+                36.868446,-116.784582,  // BEATTY_AIRPORT stop
+                36.425288,-117.133162       // FUR_CREEK_RES stop
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,14,0,0).atZone(zoneId).toInstant());
+
+        GHResponse response = graphHopper.route(ghRequest);
+
+        PathWrapper solutionWithTransfer = response.getAll().get(0);
+        PathWrapper solutionWithoutTransfer = response.getAll().get(1);
+
+        Assume.assumeTrue("First solution has one transfer",solutionWithTransfer.getNumChanges() == 1);
+        Assume.assumeTrue("Second solution has no transfers", solutionWithoutTransfer.getNumChanges() == 0);
+        Assume.assumeTrue("With transfers is faster than without", solutionWithTransfer.getTime() < solutionWithoutTransfer.getTime());
 
+        // If one transfer is worth beta_transfers milliseconds of travel time savings
+        // to me, I will be indifferent when choosing between the two routes.
+        // Wiggle it by epsilon, and I should prefer one over the other.
+        double betaTransfers = solutionWithoutTransfer.getTime() - solutionWithTransfer.getTime();
+
+        ghRequest.getHints().put(Parameters.PT.IGNORE_TRANSFERS, true);
+        // Well, not actually ignore them, but don't do multi-criteria search
+
+        ghRequest.getHints().put("beta_transfers", betaTransfers - 10);
+        response = graphHopper.route(ghRequest);
+
+        assertEquals("Get exactly one solution",1, response.getAll().size());
+        assertEquals("Prefer solution with transfers when I give the smaller beta", solutionWithTransfer.getTime(), response.getBest().getTime());
+
+        ghRequest.getHints().put("beta_transfers", betaTransfers + 10);
+
+        response = graphHopper.route(ghRequest);
+
+        assertEquals("Get exactly one solution",1, response.getAll().size());
+        assertEquals("Prefer solution without transfers when I give the higher beta", solutionWithoutTransfer.getTime(), response.getBest().getTime());
+    }
 
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
index c305f9bacd..82ab0d73fc 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/GraphHopperMultimodalIT.java
@@ -29,16 +29,19 @@
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
 import org.junit.AfterClass;
+import org.junit.Assume;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import java.io.File;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.ZoneId;
 import java.util.Arrays;
 import java.util.Collections;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 
 public class GraphHopperMultimodalIT {
 
@@ -55,7 +58,7 @@ public static void init() {
         EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder()), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, false, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.singleton("files/beatty.osm"));
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopper = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage)
                 .createWithoutRealtimeFeed();
@@ -67,6 +70,27 @@ public static void close() {
         locationIndex.close();
     }
 
+    @Test
+    public void testDepartureTimeOfAccessLegInProfileQuery() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+
+        GHResponse response = graphHopper.route(ghRequest);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(247);
+
+        PathWrapper firstTransitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get(); // There can be a walk-only trip.
+        assertThat(firstTransitSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:41:04.834"));
+        assertThat(firstTransitSolution.getLegs().get(0).getArrivalTime().toInstant())
+                .isEqualTo(firstTransitSolution.getLegs().get(1).getDepartureTime().toInstant());
+        assertThat(firstTransitSolution.getLegs().get(2).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:52:02.728"));
+    }
+
     @Test
     public void testDepartureTimeOfAccessLeg() {
         GHRequest ghRequest = new GHRequest(
@@ -74,14 +98,117 @@ public void testDepartureTimeOfAccessLeg() {
                 36.91260259593356,-116.76149368286134
         );
         ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put("beta_walk_time", 2.0); // I somewhat dislike walking
+
+        GHResponse response = graphHopper.route(ghRequest);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(130);
+
+        PathWrapper firstTransitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get(); // There can be a walk-only trip.
+        assertThat(firstTransitSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:41:04.834"));
+        assertThat(firstTransitSolution.getLegs().get(0).getArrivalTime().toInstant())
+                .isEqualTo(firstTransitSolution.getLegs().get(1).getDepartureTime().toInstant());
+        assertThat(firstTransitSolution.getLegs().get(2).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:52:02.728"));
+
+        PathWrapper walkSolution = response.getAll().stream().filter(p -> p.getLegs().size() == 1).findFirst().get();
+        assertThat(walkSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:40"));
+        // In principle, this would dominate the transit solution, since it's faster, but
+        // by default, walking gets a slight penalty.
+        assertThat(walkSolution.getLegs().get(0).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:51:10.367"));
+        assertThat(walkSolution.getLegs().size()).isEqualTo(1);
+        assertThat(walkSolution.getNumChanges()).isEqualTo(-1);
+
+        // I like walking exactly as I like riding a bus (per travel time unit)
+        // Now, the walk solution dominates, and we get no transit solution.
+        ghRequest.getHints().put("beta_walk_time",1.0);
+        response = graphHopper.route(ghRequest);
+        assertThat(response.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(139);
+        assertThat(response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst()).isEmpty();
+    }
+
+    @Test
+    public void testFastWalking() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+
+        GHResponse response = graphHopper.route(ghRequest);
+
+        PathWrapper walkSolution = response.getAll().stream().filter(p -> p.getLegs().size() == 1).findFirst().get();
+        assertThat(walkSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:40"));
+        assertThat(walkSolution.getLegs().get(0).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:41:07.031"));
+        assertThat(walkSolution.getLegs().size()).isEqualTo(1);
+        assertThat(walkSolution.getNumChanges()).isEqualTo(-1);
+    }
+
+    @Test
+    public void testFastWalkingInProfileQuery() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
+
+        GHResponse response = graphHopper.route(ghRequest);
+
+        PathWrapper walkSolution = response.getAll().get(0);
+        assertThat(walkSolution.getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:40"));
+        assertThat(walkSolution.getLegs().get(0).getArrivalTime().toInstant().atZone(zoneId).toLocalTime())
+                .isEqualTo(LocalTime.parse("06:41:07.031"));
+        assertThat(walkSolution.getLegs().size()).isEqualTo(1);
+        assertThat(walkSolution.getNumChanges()).isEqualTo(-1);
+    }
+
+    @Test
+    public void testProfileQueryDoesntEndPrematurely() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        // Provoke a situation where solutions which are later dominated will be found early.
+        // If everything is right, the n-th solution should be the same, no matter if I ask for n, or for n+m solutions.
+        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 1); // No, I cannot walk very fast, 1 km/h. Problem?
         ghRequest.getHints().put(Parameters.PT.PROFILE_QUERY, true);
 
+        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 1);
+        GHResponse response1 = graphHopper.route(ghRequest);
+        assertThat(response1.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(143);
+        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 3);
+        GHResponse response3 = graphHopper.route(ghRequest);
+        assertThat(response3.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(248);
+        assertThat(response1.getAll().get(0).getTime()).isEqualTo(response3.getAll().get(0).getTime());
+        ghRequest.getHints().put(Parameters.PT.LIMIT_SOLUTIONS, 5);
+        GHResponse response5 = graphHopper.route(ghRequest);
+        assertThat(response5.getHints().getInt("visited_nodes.sum", Integer.MAX_VALUE)).isLessThanOrEqualTo(362);
+        assertThat(response3.getAll().get(2).getTime()).isEqualTo(response5.getAll().get(2).getTime());
+    }
+
+    @Test
+    public void testHighDisutilityOfWalking() {
+        GHRequest ghRequest = new GHRequest(
+                36.91311729030539,-116.76769495010377,
+                36.91260259593356,-116.76149368286134
+        );
+        ghRequest.getHints().put(Parameters.PT.EARLIEST_DEPARTURE_TIME, LocalDateTime.of(2007,1,1,6,40,0).atZone(zoneId).toInstant());
+        ghRequest.getHints().put(Parameters.PT.WALK_SPEED, 50); // Yes, I can walk very fast, 50 km/h. Problem?
+        ghRequest.getHints().put("beta_walk_time", 20); // But I dislike walking a lot.
+
         GHResponse response = graphHopper.route(ghRequest);
 
-        assertThat(response.getAll().get(0).getLegs().get(0).getDepartureTime().toInstant().atZone(zoneId).toLocalTime())
-                .isEqualTo("06:41:06");
-        assertThat(response.getAll().get(0).getLegs().get(0).getArrivalTime().toInstant())
-                .isEqualTo(response.getAll().get(0).getLegs().get(1).getDepartureTime().toInstant());
+        PathWrapper transitSolution = response.getAll().stream().filter(p -> p.getLegs().size() > 1).findFirst().get();
+        assertThat(transitSolution.getLegs().size()).isEqualTo(3);
     }
 
 }
diff --git a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
index 283e3d9ddb..9b8988f323 100644
--- a/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
+++ b/reader-gtfs/src/test/java/com/graphhopper/RealtimeIT.java
@@ -68,13 +68,13 @@ public static void init() {
         EncodingManager encodingManager = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new FootFlagEncoder(), ptFlagEncoder), 8);
         GHDirectory directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
         GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopperStorage.close();
         locationIndex.close();
         // Re-load read only
         directory = GraphHopperGtfs.createGHDirectory(GRAPH_LOC);
-        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, true, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
+        graphHopperStorage = GraphHopperGtfs.createOrLoad(directory, encodingManager, ptFlagEncoder, gtfsStorage, Collections.singleton("files/sample-feed.zip"), Collections.emptyList());
         locationIndex = GraphHopperGtfs.createOrLoadIndex(directory, graphHopperStorage);
         graphHopperFactory = GraphHopperGtfs.createFactory(ptFlagEncoder, GraphHopperGtfs.createTranslationMap(), graphHopperStorage, locationIndex, gtfsStorage);
     }
@@ -113,14 +113,12 @@ public void testSkipDepartureStop() {
                 .setScheduleRelationship(SKIPPED);
 
         GHResponse response = graphHopperFactory.createWith(feedMessageBuilder.build(), agencyId).route(ghRequest);
-        assertEquals(2, response.getAll().size());
 
-        PathWrapper possibleAlternative = response.getAll().get(0);
-        assertFalse(possibleAlternative.isImpossible());
+        PathWrapper possibleAlternative = response.getAll().stream().filter(a -> !a.isImpossible()).findFirst().get();
         assertFalse(((Trip.PtLeg) possibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
         assertEquals("I have to wait half an hour for the next one (and ride 5 minutes)", time(0, 35), possibleAlternative.getTime(), 0.1);
 
-        PathWrapper impossibleAlternative = response.getAll().get(1);
+        PathWrapper impossibleAlternative = response.getAll().stream().filter(a -> a.isImpossible()).findFirst().get();
         assertTrue(impossibleAlternative.isImpossible());
         assertTrue(((Trip.PtLeg) impossibleAlternative.getLegs().get(0)).stops.get(0).departureCancelled);
     }
@@ -300,8 +298,8 @@ public void testExtraTrip() {
                 .setStopSequence(5)
                 .setScheduleRelationship(SKIPPED);
 
-        // Add a few more trips (but we only need the first one)
-        for (int i=0; i<3; i++){
+        // Add a few more trips (but we only need the first one; add more because there used to be a bug with something like an index overflow)
+        for (int i=0; i<100; i++){
             final GtfsRealtime.TripUpdate.Builder extraTripUpdate = feedMessageBuilder.addEntityBuilder()
                     .setId("2")
                     .getTripUpdateBuilder()
@@ -310,14 +308,14 @@ public void testExtraTrip() {
                     .addStopTimeUpdateBuilder()
                     .setStopSequence(1)
                     .setStopId("NADAV")
-                    .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45+i).atZone(zoneId).toEpochSecond()))
-                    .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45+i).atZone(zoneId).toEpochSecond()));
+                    .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).plusMinutes(i).atZone(zoneId).toEpochSecond()))
+                    .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,6,45).plusMinutes(i).atZone(zoneId).toEpochSecond()));
             extraTripUpdate
                     .addStopTimeUpdateBuilder()
                     .setStopSequence(2)
                     .setStopId("BEATTY_AIRPORT")
-                    .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15+i).atZone(zoneId).toEpochSecond()))
-                    .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15+i).atZone(zoneId).toEpochSecond()));
+                    .setArrival(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).plusMinutes(i).atZone(zoneId).toEpochSecond()))
+                    .setDeparture(GtfsRealtime.TripUpdate.StopTimeEvent.newBuilder().setTime(LocalDateTime.of(2007,1,1,7,15).plusMinutes(i).atZone(zoneId).toEpochSecond()));
 
         }
 
diff --git a/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
new file mode 100644
index 0000000000..6a5a2edf28
--- /dev/null
+++ b/reader-gtfs/src/test/java/com/graphhopper/reader/gtfs/GraphExplorerTest.java
@@ -0,0 +1,213 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.reader.gtfs;
+
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.VirtualEdgeIteratorState;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FootFlagEncoder;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.storage.GraphExtension;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.RAMDirectory;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.DistanceCalc2D;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.PointList;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.hamcrest.collection.IsEmptyIterable.emptyIterable;
+import static org.hamcrest.collection.IsIterableContainingInOrder.contains;
+import static org.hamcrest.core.StringContains.containsString;
+import static org.junit.Assert.assertThat;
+import static org.mockito.Mockito.mock;
+
+public class GraphExplorerTest {
+
+    private final PtFlagEncoder pt;
+    private final FootFlagEncoder foot;
+    private final EncodingManager encodingManager;
+
+    public GraphExplorerTest() {
+        pt = new PtFlagEncoder();
+        foot = new FootFlagEncoder();
+        encodingManager = new EncodingManager(Arrays.asList(pt, foot), 8);
+    }
+
+    @Test
+    public void testEverythingEmpty() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        assertThat((Iterable<EdgeIteratorState>) () -> testee.exploreEdgesAround(new Label(0, 0, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).iterator(),
+                emptyIterable());
+    }
+
+    @Test
+    public void testNonEmptyGraph() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        graph.create(0);
+        EdgeIteratorState d = graph.edge(4, 5);
+        d.setFlags(pt.setAccess(d.getFlags(), true, false));
+        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+
+        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(d.toString()));
+    }
+
+    @Test
+    public void testExtraEdgesWithEmptyGraph() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(0, 0, 0, 1, 0.0, 0L, "", new PointList());
+        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        extraEdges.add(e);
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(1, 1, 1, 2, 0.0, 0L, "", new PointList());
+        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        extraEdges.add(f);
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(2, 2, 1, 3, 0.0, 0L, "", new PointList());
+        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        extraEdges.add(g);
+
+        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(e.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(f.toString(), g.toString()));
+
+    }
+
+    @Test
+    public void testExtraEdgesWithNonEmptyGraph() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        graph.create(0);
+        EdgeIteratorState d = graph.edge(4, 5);
+        d.setFlags(pt.setAccess(d.getFlags(), true, false));
+        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+
+        int edgeId = graph.getAllEdges().length();
+
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(-1, edgeId++, 0, 1, 0.0, 0L, "", new PointList());
+        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        extraEdges.add(e);
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(-1, edgeId++, 1, 2, 0.0, 0L, "", new PointList());
+        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        extraEdges.add(f);
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(-1, edgeId++, 1, 3, 0.0, 0L, "", new PointList());
+        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        extraEdges.add(g);
+        VirtualEdgeIteratorState h = new VirtualEdgeIteratorState(-1, edgeId++, 4, 7, 0.0, 0L, "", new PointList());
+        h.setFlags(foot.setAccess(h.getFlags(), true, false));
+        extraEdges.add(h);
+
+        GraphExplorer testee = new GraphExplorer(graph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(e.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(f.toString(), g.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(d.toString(), h.toString()));
+    }
+
+    @Test
+    public void testExtraEdgesWithNonEmptyGraphAndQueryGraph() {
+        GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory("wurst"), encodingManager, false, new GraphExtension.NoOpExtension());
+        graph.create(0);
+        EdgeIteratorState c = graph.edge(4, 3);
+        c.setFlags(pt.setAccess(c.getFlags(), true, false));
+        c.setFlags(foot.setAccess(c.getFlags(), true, false));
+        PointList cp = new PointList();
+        c.setWayGeometry(cp);
+        EdgeIteratorState d = graph.edge(4, 5);
+        d.setFlags(pt.setAccess(d.getFlags(), true, false));
+        d.setFlags(foot.setAccess(d.getFlags(), true, false));
+        PointList dp = new PointList();
+        d.setWayGeometry(dp);
+        graph.getNodeAccess().setNode(3, 3.0, 3.0);
+        graph.getNodeAccess().setNode(4, 4.0, 4.0);
+        graph.getNodeAccess().setNode(5, 5.0, 5.0);
+
+
+        int edgeId = graph.getAllEdges().length();
+
+        GtfsStorage gtfsStorage = mock(GtfsStorage.class);
+        RealtimeFeed realtimeFeed = mock(RealtimeFeed.class);
+        List<VirtualEdgeIteratorState> extraEdges = new ArrayList<>();
+        VirtualEdgeIteratorState e = new VirtualEdgeIteratorState(-1, edgeId++, 0, 1, 0.0, 0L, "", new PointList());
+        e.setFlags(foot.setAccess(e.getFlags(), true, false));
+        extraEdges.add(e);
+        VirtualEdgeIteratorState f = new VirtualEdgeIteratorState(-1, edgeId++, 1, 2, 0.0, 0L, "", new PointList());
+        f.setFlags(foot.setAccess(f.getFlags(), true, false));
+        extraEdges.add(f);
+        VirtualEdgeIteratorState g = new VirtualEdgeIteratorState(-1, edgeId++, 1, 3, 0.0, 0L, "", new PointList());
+        g.setFlags(foot.setAccess(g.getFlags(), true, false));
+        extraEdges.add(g);
+        VirtualEdgeIteratorState h = new VirtualEdgeIteratorState(-1, edgeId++, 4, 7, 0.0, 0L, "", new PointList());
+        h.setFlags(foot.setAccess(h.getFlags(), true, false));
+        extraEdges.add(h);
+
+        WrapperGraph wrapperGraph = new WrapperGraph(graph, extraEdges);
+        QueryGraph queryGraph = new QueryGraph(wrapperGraph);
+
+        QueryResult point1 = new QueryResult(3.5, 3.5);
+        QueryResult point2 = new QueryResult(4.5, 4.5);
+        point1.setClosestEdge(c);
+        point1.setQueryDistance(0.0);
+        point1.setWayIndex(0);
+        point1.setSnappedPosition(QueryResult.Position.EDGE);
+        point1.calcSnappedPoint(new DistanceCalc2D());
+        point2.setClosestEdge(d);
+        point2.setQueryDistance(0.0);
+        point2.setWayIndex(0);
+        point2.setSnappedPosition(QueryResult.Position.EDGE);
+        point2.calcSnappedPoint(new DistanceCalc2D());
+        queryGraph.lookup(point1, point2);
+
+        GraphExplorer testee = new GraphExplorer(queryGraph, new FastestWeighting(foot), pt, gtfsStorage, realtimeFeed, false, extraEdges, false, 5.0);
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 0, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(e.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 1, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(f.toString(), g.toString()));
+        assertThat(() -> testee.exploreEdgesAround(new Label(0, -1, 4, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                contains(containsString("4->8"), containsString("4->9"), containsString("4->7")));
+        assertThat((Iterable<String>) () -> testee.exploreEdgesAround(new Label(0, -1, 7, 0, 0, 0.0, 0L, 0, 0, false, null)).map(Object::toString).iterator(),
+                emptyIterable());
+
+    }
+
+
+}
diff --git a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
index f5c21baa0b..befe7ae6aa 100644
--- a/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
+++ b/reader-osm/src/test/java/com/graphhopper/reader/osm/GraphHopperOSMTest.java
@@ -789,7 +789,7 @@ public boolean isEnabled() {
 
     @Test
     public void testMultipleCHPreparationsInParallel() {
-        HashMap<String, Integer> shortcutCountMap = new HashMap<>();
+        HashMap<String, Long> shortcutCountMap = new HashMap<>();
         // try all parallelization modes        
         for (int threadCount = 1; threadCount < 6; threadCount++) {
             EncodingManager em = new EncodingManager(Arrays.asList(new CarFlagEncoder(), new MotorcycleFlagEncoder(),
@@ -810,11 +810,11 @@ public void testMultipleCHPreparationsInParallel() {
                 assertTrue("Preparation wasn't run! [" + threadCount + "]", pch.isPrepared());
 
                 String name = AbstractWeighting.weightingToFileName(pch.getWeighting());
-                Integer singleThreadShortcutCount = shortcutCountMap.get(name);
+                Long singleThreadShortcutCount = shortcutCountMap.get(name);
                 if (singleThreadShortcutCount == null)
                     shortcutCountMap.put(name, pch.getShortcuts());
                 else
-                    assertEquals((int) singleThreadShortcutCount, pch.getShortcuts());
+                    assertEquals((long) singleThreadShortcutCount, pch.getShortcuts());
 
                 String keyError = Parameters.CH.PREPARE + "error." + name;
                 String valueError = tmpGH.getGraphHopperStorage().getProperties().get(keyError);
diff --git a/tools/src/main/java/com/graphhopper/tools/Measurement.java b/tools/src/main/java/com/graphhopper/tools/Measurement.java
index 94047ed948..c6d7fbedd0 100644
--- a/tools/src/main/java/com/graphhopper/tools/Measurement.java
+++ b/tools/src/main/java/com/graphhopper/tools/Measurement.java
@@ -90,7 +90,7 @@ void start(CmdArgs args) {
             protected void prepareCH() {
                 StopWatch sw = new StopWatch().start();
                 super.prepareCH();
-                put(Parameters.CH.PREPARE + "time", sw.stop().getTime());
+                put(Parameters.CH.PREPARE + "time", sw.stop().getMillis());
                 int edges = getGraphHopperStorage().getAllEdges().length();
                 if (getCHFactoryDecorator().hasWeightings()) {
                     Weighting weighting = getCHFactoryDecorator().getWeightings().get(0);
@@ -103,7 +103,7 @@ protected void prepareCH() {
             protected void loadOrPrepareLM() {
                 StopWatch sw = new StopWatch().start();
                 super.loadOrPrepareLM();
-                put(Parameters.Landmark.PREPARE + "time", sw.stop().getTime());
+                put(Parameters.Landmark.PREPARE + "time", sw.stop().getMillis());
             }
 
             @Override
@@ -178,7 +178,7 @@ protected DataReader importData() throws IOException {
             put("measurement.gitinfo", gitCommit);
             put("measurement.count", count);
             put("measurement.seed", seed);
-            put("measurement.time", sw.stop().getTime());
+            put("measurement.time", sw.stop().getMillis());
             System.gc();
             put("measurement.totalMB", getTotalMB());
             put("measurement.usedMB", getUsedMB());
diff --git a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
index 0a507aa149..30db0529cc 100644
--- a/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
+++ b/tools/src/main/java/com/graphhopper/ui/DebugAStarBi.java
@@ -17,7 +17,6 @@
  */
 package com.graphhopper.ui;
 
-import com.graphhopper.routing.AStar;
 import com.graphhopper.routing.AStarBidirection;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
diff --git a/web-api/pom.xml b/web-api/pom.xml
index 89c3cbecfe..b26859400f 100644
--- a/web-api/pom.xml
+++ b/web-api/pom.xml
@@ -23,9 +23,14 @@
             <version>${project.parent.version}</version>
         </dependency>
         <dependency>
-            <groupId>io.dropwizard</groupId>
-            <artifactId>dropwizard-jackson</artifactId>
-            <version>1.3.2</version>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-core</artifactId>
+            <version>${jackson.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+            <version>${jackson.version}</version>
         </dependency>
         <dependency>
             <groupId>com.bedatadriven</groupId>
@@ -49,7 +54,7 @@
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-testing</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
             <scope>test</scope>
         </dependency>
         <dependency>
diff --git a/web-api/src/main/java/com/graphhopper/http/WebHelper.java b/web-api/src/main/java/com/graphhopper/http/WebHelper.java
index 84aeac6fd0..4d2e4d179c 100644
--- a/web-api/src/main/java/com/graphhopper/http/WebHelper.java
+++ b/web-api/src/main/java/com/graphhopper/http/WebHelper.java
@@ -102,16 +102,20 @@ public static String encodePolyline(PointList poly) {
     }
 
     public static String encodePolyline(PointList poly, boolean includeElevation) {
+        return encodePolyline(poly, includeElevation, 1e5);
+    }
+
+    public static String encodePolyline(PointList poly, boolean includeElevation, double precision) {
         StringBuilder sb = new StringBuilder();
         int size = poly.getSize();
         int prevLat = 0;
         int prevLon = 0;
         int prevEle = 0;
         for (int i = 0; i < size; i++) {
-            int num = (int) Math.floor(poly.getLatitude(i) * 1e5);
+            int num = (int) Math.floor(poly.getLatitude(i) * precision);
             encodeNumber(sb, num - prevLat);
             prevLat = num;
-            num = (int) Math.floor(poly.getLongitude(i) * 1e5);
+            num = (int) Math.floor(poly.getLongitude(i) * precision);
             encodeNumber(sb, num - prevLon);
             prevLon = num;
             if (includeElevation) {
diff --git a/web-api/src/main/java/com/graphhopper/jackson/Jackson.java b/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
index 1663d4cc12..73305a2e69 100644
--- a/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
+++ b/web-api/src/main/java/com/graphhopper/jackson/Jackson.java
@@ -22,7 +22,7 @@
 
 public class Jackson {
     public static ObjectMapper newObjectMapper() {
-        ObjectMapper objectMapper = io.dropwizard.jackson.Jackson.newObjectMapper();
+        ObjectMapper objectMapper = new ObjectMapper();
         objectMapper.registerModule(new GraphHopperModule());
         objectMapper.registerModule(new JtsModule());
         return objectMapper;
diff --git a/web-api/src/test/java/com/graphhopper/http/WebHelperTest.java b/web-api/src/test/java/com/graphhopper/http/WebHelperTest.java
index 2661cad3e7..e78c4c302f 100644
--- a/web-api/src/test/java/com/graphhopper/http/WebHelperTest.java
+++ b/web-api/src/test/java/com/graphhopper/http/WebHelperTest.java
@@ -74,4 +74,9 @@ public void testEncode3D() throws Exception {
         assertEquals("_p~iF~ps|Uo}@_ulLnnqC_anF_mqNvxq`@?", WebHelper.encodePolyline(
                 Helper.createPointList3D(38.5, -120.2, 10, 40.7, -120.95, 1234, 43.252, -126.453, 1234)));
     }
+
+    @Test
+    public void testEncode1e6() throws Exception {
+        assertEquals("ohdfzAgt}bVoEL", WebHelper.encodePolyline(Helper.createPointList(47.827608, 12.123476, 47.827712, 12.123469), false, 1e6));
+    }
 }
diff --git a/web-bundle/pom.xml b/web-bundle/pom.xml
index e0d305d8f4..8550a06300 100644
--- a/web-bundle/pom.xml
+++ b/web-bundle/pom.xml
@@ -49,17 +49,17 @@
         <dependency>
             <groupId>com.google.guava</groupId>
             <artifactId>guava</artifactId>
-            <version>21.0</version>
+            <version>24.0-jre</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-core</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-testing</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
             <scope>test</scope>
         </dependency>
 
@@ -73,7 +73,7 @@
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>directions-api-client</artifactId>
-            <version>0.10.0</version>
+            <version>${directions-api-client.version}</version>
             <scope>test</scope>
         </dependency>
 
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GHPointConverterProvider.java b/web-bundle/src/main/java/com/graphhopper/http/GHPointConverterProvider.java
new file mode 100644
index 0000000000..7ebca5dac4
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/http/GHPointConverterProvider.java
@@ -0,0 +1,57 @@
+/*
+ *  Licensed to GraphHopper GmbH under one or more contributor
+ *  license agreements. See the NOTICE file distributed with this work for
+ *  additional information regarding copyright ownership.
+ *
+ *  GraphHopper GmbH licenses this file to you under the Apache License,
+ *  Version 2.0 (the "License"); you may not use this file except in
+ *  compliance with the License. You may obtain a copy of the License at
+ *
+ *       http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package com.graphhopper.http;
+
+import com.graphhopper.MultiException;
+import com.graphhopper.util.shapes.GHPoint;
+
+import javax.ws.rs.WebApplicationException;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ParamConverter;
+import javax.ws.rs.ext.ParamConverterProvider;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+
+public class GHPointConverterProvider implements ParamConverterProvider {
+
+    @Override
+    public <T> ParamConverter<T> getConverter(Class<T> rawType, Type genericType, Annotation[] annotations) {
+        if (rawType.equals(GHPoint.class)) {
+            return new ParamConverter<T>() {
+                @Override
+                public T fromString(String value) {
+                    try {
+                        return (T) GHPoint.fromString(value);
+                    } catch (IllegalArgumentException ex) {
+                        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST)
+                                .entity(new MultiException(ex))
+                                .build());
+                    }
+                }
+
+                @Override
+                public String toString(T value) {
+                    return value.toString();
+                }
+            };
+        }
+        return null;
+    }
+}
+
diff --git a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
index 8756484716..ce9f5e0250 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/GraphHopperBundle.java
@@ -197,6 +197,9 @@ public void run(GraphHopperBundleConfiguration configuration, Environment enviro
         environment.jersey().register(new MultiExceptionMapper());
         environment.jersey().register(new MultiExceptionGPXMessageBodyWriter());
 
+        environment.jersey().register(new IllegalArgumentExceptionMapper());
+        environment.jersey().register(new GHPointConverterProvider());
+
         if (configuration.getGraphHopperConfiguration().has("gtfs.file")) {
             // switch to different API implementation when using Pt
             runPtGraphHopper(configuration.getGraphHopperConfiguration(), environment);
@@ -211,7 +214,6 @@ private void runPtGraphHopper(CmdArgs configuration, Environment environment) {
         final GtfsStorage gtfsStorage = GraphHopperGtfs.createGtfsStorage();
         final EncodingManager encodingManager = new EncodingManager(Arrays.asList(ptFlagEncoder, new FootFlagEncoder(), new CarFlagEncoder()), 8);
         final GraphHopperStorage graphHopperStorage = GraphHopperGtfs.createOrLoad(ghDirectory, encodingManager, ptFlagEncoder, gtfsStorage,
-                configuration.getBool("gtfs.createwalknetwork", false),
                 configuration.has("gtfs.file") ? Arrays.asList(configuration.get("gtfs.file", "").split(",")) : Collections.emptyList(),
                 configuration.has("datareader.file") ? Arrays.asList(configuration.get("datareader.file", "").split(",")) : Collections.emptyList());
         final TranslationMap translationMap = GraphHopperGtfs.createTranslationMap();
diff --git a/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java b/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java
new file mode 100644
index 0000000000..f548ffc1ff
--- /dev/null
+++ b/web-bundle/src/main/java/com/graphhopper/http/IllegalArgumentExceptionMapper.java
@@ -0,0 +1,16 @@
+package com.graphhopper.http;
+
+import com.graphhopper.MultiException;
+
+import javax.ws.rs.core.Response;
+import javax.ws.rs.ext.ExceptionMapper;
+
+public class IllegalArgumentExceptionMapper implements ExceptionMapper<IllegalArgumentException> {
+
+    @Override
+    public Response toResponse(IllegalArgumentException e) {
+        return Response.status(Response.Status.BAD_REQUEST)
+                .entity(new MultiException(e))
+                .build();
+    }
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
index 237daee611..03c87e3819 100644
--- a/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
+++ b/web-bundle/src/main/java/com/graphhopper/http/MultiExceptionMapper.java
@@ -28,6 +28,6 @@
 public class MultiExceptionMapper implements ExceptionMapper<MultiException> {
     @Override
     public Response toResponse(MultiException exception) {
-        return Response.status(400).entity(exception).build();
+        return Response.status(Response.Status.BAD_REQUEST).entity(exception).build();
     }
 }
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java b/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
index 9f7dbbc725..dcf060a784 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/InfoResource.java
@@ -1,6 +1,6 @@
 /*
  *  Licensed to GraphHopper GmbH under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
+ *  license agreements. See the NOTICE file distributed with this work for
  *  additional information regarding copyright ownership.
  *
  *  GraphHopper GmbH licenses this file to you under the Apache License,
@@ -65,7 +65,8 @@ public InfoResource(GraphHopperStorage storage, @Named("hasElevation") Boolean h
     @GET
     public Info getInfo() {
         final Info info = new Info();
-        info.bbox = storage.getBounds();
+        // use bbox always without elevation (for backward compatibility)
+        info.bbox = new BBox(storage.getBounds().minLon, storage.getBounds().maxLon, storage.getBounds().minLat, storage.getBounds().maxLat);
         info.supported_vehicles = storage.getEncodingManager().toString().split(",");
         for (String v : info.supported_vehicles) {
             Info.PerVehicle perVehicleJson = new Info.PerVehicle();
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
index df5185257a..4281e8fe46 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/IsochroneResource.java
@@ -1,6 +1,5 @@
 package com.graphhopper.resources;
 
-import com.fasterxml.jackson.databind.node.ArrayNode;
 import com.fasterxml.jackson.databind.node.JsonNodeFactory;
 import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.graphhopper.GraphHopper;
@@ -13,7 +12,6 @@
 import com.graphhopper.storage.index.LocationIndex;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.StopWatch;
-import com.graphhopper.util.exceptions.GHException;
 import com.graphhopper.util.shapes.GHPoint;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -30,8 +28,6 @@
 import java.util.HashMap;
 import java.util.List;
 
-import static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;
-
 @Path("isochrone")
 public class IsochroneResource {
 
@@ -54,7 +50,6 @@ public Response doGet(
             @Context HttpServletRequest httpReq,
             @Context UriInfo uriInfo,
             @QueryParam("vehicle") @DefaultValue("car") String vehicle,
-            @QueryParam("weighting") @DefaultValue("fastest") String weightingStr,
             @QueryParam("buckets") @DefaultValue("1") int buckets,
             @QueryParam("reverse_flow") @DefaultValue("false") boolean reverseFlow,
             @QueryParam("point") GHPoint point,
@@ -63,22 +58,22 @@ public Response doGet(
             @QueryParam("distance_limit") @DefaultValue("-1") double distanceInMeter) {
 
         if (buckets > 20 || buckets < 1)
-            throwArgExc("Number of buckets has to be in the range [1, 20]");
+            throw new IllegalArgumentException("Number of buckets has to be in the range [1, 20]");
 
         if (point == null)
-            throwArgExc("point parameter cannot be null");
+            throw new IllegalArgumentException("point parameter cannot be null");
 
         StopWatch sw = new StopWatch().start();
 
         if (!encodingManager.supports(vehicle))
-            throwArgExc("vehicle not supported:" + vehicle);
+            throw new IllegalArgumentException("vehicle not supported:" + vehicle);
 
         FlagEncoder encoder = encodingManager.getEncoder(vehicle);
         EdgeFilter edgeFilter = DefaultEdgeFilter.allEdges(encoder);
         LocationIndex locationIndex = graphHopper.getLocationIndex();
         QueryResult qr = locationIndex.findClosest(point.lat, point.lon, edgeFilter);
         if (!qr.isValid())
-            throwArgExc("Point not found:" + point);
+            throw new IllegalArgumentException("Point not found:" + point);
 
         Graph graph = graphHopper.getGraphHopperStorage();
         QueryGraph queryGraph = new QueryGraph(graph);
@@ -93,31 +88,31 @@ public Response doGet(
         if (distanceInMeter > 0) {
             double maxMeter = 50 * 1000;
             if (distanceInMeter > maxMeter)
-                throwArgExc("Specify a limit of less than " + maxMeter / 1000f + "km");
+                throw new IllegalArgumentException("Specify a limit of less than " + maxMeter / 1000f + "km");
             if (buckets > (distanceInMeter / 500))
-                throwArgExc("Specify buckets less than the number of explored kilometers");
+                throw new IllegalArgumentException("Specify buckets less than the number of explored kilometers");
 
             isochrone.setDistanceLimit(distanceInMeter);
         } else {
 
             long maxSeconds = 80 * 60;
             if (timeLimitInSeconds > maxSeconds)
-                throwArgExc("Specify a limit of less than " + maxSeconds + " seconds");
+                throw new IllegalArgumentException("Specify a limit of less than " + maxSeconds + " seconds");
             if (buckets > (timeLimitInSeconds / 60))
-                throwArgExc("Specify buckets less than the number of explored minutes");
+                throw new IllegalArgumentException("Specify buckets less than the number of explored minutes");
 
             isochrone.setTimeLimit(timeLimitInSeconds);
         }
 
         List<List<Double[]>> list = isochrone.searchGPS(qr.getClosestNode(), buckets);
         if (isochrone.getVisitedNodes() > graphHopper.getMaxVisitedNodes() / 5) {
-            throwArgExc("Server side reset: too many junction nodes would have to explored (" + isochrone.getVisitedNodes() + "). Let us know if you need this increased.");
+            throw new IllegalArgumentException("Server side reset: too many junction nodes would have to explored (" + isochrone.getVisitedNodes() + "). Let us know if you need this increased.");
         }
 
         int counter = 0;
         for (List<Double[]> tmp : list) {
             if (tmp.size() < 2) {
-                throwArgExc("Too few points found for bucket " + counter + ". "
+                throw new IllegalArgumentException("Too few points found for bucket " + counter + ". "
                         + "Please try a different 'point', a smaller 'buckets' count or a larger 'time_limit'. "
                         + "And let us know if you think this is a bug!");
             }
@@ -150,7 +145,7 @@ public Response doGet(
             }
             calcRes = polyList;
         } else {
-            throw new WebApplicationException(jsonErrorResponse(Collections.singletonList(new IllegalArgumentException("type not supported:" + resultStr))));
+            throw new IllegalArgumentException("type not supported:" + resultStr);
         }
 
         logger.info("took: " + sw.getSeconds() + ", visited nodes:" + isochrone.getVisitedNodes() + ", " + uriInfo.getQueryParameters());
@@ -159,33 +154,6 @@ public Response doGet(
                 .build();
     }
 
-    private void throwArgExc(String msg) {
-        throw new WebApplicationException(jsonErrorResponse(Collections.singletonList(new IllegalArgumentException(msg))));
-    }
-
-
-    private Response jsonErrorResponse(List<Throwable> errors) {
-        ObjectNode json = JsonNodeFactory.instance.objectNode();
-        json.put("message", getMessage(errors.get(0)));
-        ArrayNode errorHintList = json.putArray("hints");
-        for (Throwable t : errors) {
-            ObjectNode error = errorHintList.addObject();
-            error.put("message", getMessage(t));
-            error.put("details", t.getClass().getName());
-            if (t instanceof GHException) {
-                ((GHException) t).getDetails().forEach(error::putPOJO);
-            }
-        }
-        return Response.status(SC_BAD_REQUEST).entity(json).build();
-    }
-
-    private String getMessage(Throwable t) {
-        if (t.getMessage() == null)
-            return t.getClass().getSimpleName();
-        else
-            return t.getMessage();
-    }
-
     private Response jsonSuccessResponse(Object result, float took) {
         ObjectNode json = JsonNodeFactory.instance.objectNode();
         json.putPOJO("polygons", result);
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index aca3bdbfcb..517bbb51ee 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -25,6 +25,7 @@
 import com.graphhopper.routing.util.EncodingManager;
 import com.graphhopper.routing.util.HintsMap;
 import com.graphhopper.util.Constants;
+import com.graphhopper.util.Helper;
 import com.graphhopper.util.Parameters;
 import com.graphhopper.util.StopWatch;
 import com.graphhopper.util.shapes.GHPoint;
@@ -37,7 +38,10 @@
 import javax.ws.rs.*;
 import javax.ws.rs.container.ContainerRequestContext;
 import javax.ws.rs.core.*;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
 
 import static com.graphhopper.util.Parameters.Routing.*;
 
@@ -54,13 +58,11 @@
     private static final Logger logger = LoggerFactory.getLogger(RouteResource.class);
 
     private final GraphHopperAPI graphHopper;
-    private final EncodingManager encodingManager;
     private final Boolean hasElevation;
 
     @Inject
-    public RouteResource(GraphHopperAPI graphHopper, EncodingManager encodingManager, @Named("hasElevation") Boolean hasElevation) {
+    public RouteResource(GraphHopperAPI graphHopper, @Named("hasElevation") Boolean hasElevation) {
         this.graphHopper = graphHopper;
-        this.encodingManager = encodingManager;
         this.hasElevation = hasElevation;
     }
 
@@ -70,7 +72,7 @@ public Response doGet(
             @Context HttpServletRequest httpReq,
             @Context UriInfo uriInfo,
             @Context ContainerRequestContext rc,
-            @QueryParam(WAY_POINT_MAX_DISTANCE)@DefaultValue("1") double minPathPrecision,
+            @QueryParam(WAY_POINT_MAX_DISTANCE) @DefaultValue("1") double minPathPrecision,
             @QueryParam("point") List<GHPoint> requestPoints,
             @QueryParam("type") @DefaultValue("json") String type,
             @QueryParam(INSTRUCTIONS) @DefaultValue("true") boolean instructions,
@@ -94,22 +96,15 @@ public Response doGet(
 
         StopWatch sw = new StopWatch().start();
 
-        if(requestPoints.isEmpty()) {
-            throw new MultiException(new IllegalArgumentException("You have to pass at least one point"));
-        }
-
-        if (!encodingManager.supports(vehicleStr)) {
-            throw new MultiException(new IllegalArgumentException("Vehicle not supported: " + vehicleStr));
-        } else if (enableElevation && !hasElevation) {
-            throw new MultiException(new IllegalArgumentException("Elevation not supported!"));
-        } else if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size()) {
-            throw new MultiException(new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
-                    + "or equal to the number of points (" + requestPoints.size() + ")"));
-        }
-
-        if (pointHints.size() > 0 && pointHints.size() != requestPoints.size()) {
-            throw new MultiException(new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored"));
-        }
+        if (requestPoints.isEmpty())
+            throw new IllegalArgumentException("You have to pass at least one point");
+        if (enableElevation && !hasElevation)
+            throw new IllegalArgumentException("Elevation not supported!");
+        if (favoredHeadings.size() > 1 && favoredHeadings.size() != requestPoints.size())
+            throw new IllegalArgumentException("The number of 'heading' parameters must be <= 1 "
+                    + "or equal to the number of points (" + requestPoints.size() + ")");
+        if (pointHints.size() > 0 && pointHints.size() != requestPoints.size())
+            throw new IllegalArgumentException("If you pass " + POINT_HINT + ", you need to pass a hint for every point, empty hints will be ignored");
 
         GHRequest request;
         if (favoredHeadings.size() > 0) {
@@ -126,7 +121,7 @@ public Response doGet(
         }
 
         initHints(request.getHints(), uriInfo.getQueryParameters());
-        request.setVehicle(encodingManager.getEncoder(vehicleStr).toString()).
+        request.setVehicle(vehicleStr).
                 setWeighting(weighting).
                 setAlgorithm(algoStr).
                 setLocale(localeStr).
@@ -151,6 +146,7 @@ public Response doGet(
         } else {
             logger.info(logStr + ", alternatives: " + ghResponse.getAll().size()
                     + ", distance0: " + ghResponse.getBest().getDistance()
+                    + ", weight0: " + ghResponse.getBest().getRouteWeight()
                     + ", time0: " + Math.round(ghResponse.getBest().getTime() / 60000f) + "min"
                     + ", points0: " + ghResponse.getBest().getPoints().getSize()
                     + ", debugInfo: " + ghResponse.getDebugInfo());
@@ -165,9 +161,10 @@ public Response doGet(
         }
     }
 
-    private static Response.ResponseBuilder gpxSuccessResponseBuilder(GHResponse ghRsp, String timeString, String trackName, boolean enableElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
+    private static Response.ResponseBuilder gpxSuccessResponseBuilder(GHResponse ghRsp, String timeString, String
+            trackName, boolean enableElevation, boolean withRoute, boolean withTrack, boolean withWayPoints, String version) {
         if (ghRsp.getAll().size() > 1) {
-            throw new MultiException(new IllegalArgumentException("Alternatives are currently not yet supported for GPX"));
+            throw new IllegalArgumentException("Alternatives are currently not yet supported for GPX");
         }
 
         long time = timeString != null ? Long.parseLong(timeString) : System.currentTimeMillis();
diff --git a/web/pom.xml b/web/pom.xml
index c9e48ef4b7..801f3f2da8 100644
--- a/web/pom.xml
+++ b/web/pom.xml
@@ -28,7 +28,7 @@
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-core</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
             <groupId>com.graphhopper</groupId>
@@ -38,12 +38,12 @@
         <dependency>
             <groupId>io.dropwizard-bundles</groupId>
             <artifactId>dropwizard-configurable-assets-bundle</artifactId>
-            <version>1.2.2</version>
+            <version>${dropwizard.version}</version>
         </dependency>
         <dependency>
             <groupId>io.dropwizard</groupId>
             <artifactId>dropwizard-testing</artifactId>
-            <version>1.3.2</version>
+            <version>${dropwizard.version}</version>
             <scope>test</scope>
         </dependency>
 
@@ -57,7 +57,7 @@
         <dependency>
             <groupId>com.graphhopper</groupId>
             <artifactId>directions-api-client</artifactId>
-            <version>0.10.0</version>
+            <version>${directions-api-client.version}</version>
             <scope>test</scope>
         </dependency>
 
diff --git a/web/src/main/assembly/jar.xml b/web/src/main/assembly/jar.xml
deleted file mode 100644
index 9deb284f62..0000000000
--- a/web/src/main/assembly/jar.xml
+++ /dev/null
@@ -1,39 +0,0 @@
-<?xml version='1.0' encoding='UTF-8'?>
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one
-  or more contributor license agreements.  See the NOTICE file
-  distributed with this work for additional information
-  regarding copyright ownership.  The ASF licenses this file
-  to you under the Apache License, Version 2.0 (the
-  "License"); you may not use this file except in compliance
-  with the License.  You may obtain a copy of the License at
-
-  http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing,
-  software distributed under the License is distributed on an
-  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-  KIND, either express or implied.  See the License for the
-  specific language governing permissions and limitations
-  under the License.
--->
-
-<!-- START SNIPPET: jar-with-dependencies -->
-<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/${mdoVersion}" 
-          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/${mdoVersion} http://maven.apache.org/xsd/assembly-${mdoVersion}.xsd">
-    <id>with-dep</id>
-    <formats>
-        <format>jar</format>
-    </formats>
-    <includeBaseDirectory>false</includeBaseDirectory>
-    <dependencySets>
-        <dependencySet>
-            <outputDirectory>/</outputDirectory>
-            <useProjectArtifact>true</useProjectArtifact>
-            <unpack>true</unpack>
-            <scope>runtime</scope>
-        </dependencySet>
-    </dependencySets>
-</assembly>
-<!-- END SNIPPET: jar-with-dependencies -->
diff --git a/web/src/main/assembly/zip.xml b/web/src/main/assembly/zip.xml
deleted file mode 100644
index 278b9a9dc6..0000000000
--- a/web/src/main/assembly/zip.xml
+++ /dev/null
@@ -1,35 +0,0 @@
-<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"
-          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-          xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
-    <id>bin</id>
-    <formats>
-        <format>zip</format>
-    </formats>
-    <includeBaseDirectory>false</includeBaseDirectory>
-    <fileSets>
-        <fileSet>
-            <directory>${project.basedir}/src/main/</directory>
-            <outputDirectory/>
-            <includes>
-                <include>resources/assets/**</include>
-            </includes>
-        </fileSet>
-        <fileSet>
-            <directory>${project.basedir}/..</directory>
-            <outputDirectory/>
-            <includes>
-                <include>NOTICE*</include>
-                <include>LICENSE*</include>
-                <include>CONTRIBUTORS*</include>
-                <include>config-example.properties</include>
-            </includes>
-        </fileSet>
-        <fileSet>
-            <directory>${project.build.directory}</directory>
-            <outputDirectory/>
-            <includes>
-                <include>*-with-dep.jar</include>
-            </includes>
-        </fileSet>
-    </fileSets>
-</assembly>
diff --git a/web/src/main/java/com/graphhopper/http/CORSFilter.java b/web/src/main/java/com/graphhopper/http/CORSFilter.java
index 3e1d9a24cb..31c081afc2 100644
--- a/web/src/main/java/com/graphhopper/http/CORSFilter.java
+++ b/web/src/main/java/com/graphhopper/http/CORSFilter.java
@@ -27,13 +27,11 @@
 public class CORSFilter implements Filter {
     @Override
     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
-        if (!"jsonp".equals(request.getParameter("type"))) {
-            HttpServletResponse rsp = (HttpServletResponse) response;
-            rsp.setHeader("Access-Control-Allow-Methods", "GET, POST, HEAD, OPTIONS");
-            rsp.setHeader("Access-Control-Allow-Headers", "Origin,Accept,X-Requested-With,"
-                    + "Content-Type,Access-Control-Request-Method,Access-Control-Request-Headers");
-            rsp.setHeader("Access-Control-Allow-Origin", "*");
-        }
+        HttpServletResponse rsp = (HttpServletResponse) response;
+        rsp.setHeader("Access-Control-Allow-Methods", "GET, POST, HEAD, OPTIONS");
+        rsp.setHeader("Access-Control-Allow-Headers", "Origin,Accept,X-Requested-With,"
+                + "Content-Type,Access-Control-Request-Method,Access-Control-Request-Headers");
+        rsp.setHeader("Access-Control-Allow-Origin", "*");
 
         chain.doFilter(request, response);
     }
diff --git a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
index 825343644d..601643b45d 100644
--- a/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
+++ b/web/src/main/java/com/graphhopper/http/GraphHopperApplication.java
@@ -41,7 +41,7 @@ public void initialize(Bootstrap<GraphHopperServerConfiguration> bootstrap) {
     }
 
     @Override
-    public void run(GraphHopperServerConfiguration configuration, Environment environment) throws Exception {
+    public void run(GraphHopperServerConfiguration configuration, Environment environment) {
         environment.jersey().register(new RootResource());
         environment.servlets().addFilter("cors", CORSFilter.class).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
         environment.servlets().addFilter("ipfilter", new IPFilter(configuration.getGraphHopperConfiguration().get("jetty.whiteips", ""), configuration.getGraphHopperConfiguration().get("jetty.blackips", ""))).addMappingForUrlPatterns(EnumSet.allOf(DispatcherType.class), false, "*");
diff --git a/web/src/main/resources/assets/js/autocomplete.js b/web/src/main/resources/assets/js/autocomplete.js
index def693032b..b8e3ee00d0 100644
--- a/web/src/main/resources/assets/js/autocomplete.js
+++ b/web/src/main/resources/assets/js/autocomplete.js
@@ -104,7 +104,6 @@ AutoComplete.prototype.showListForIndex = function (ghRequest, routeIfAllResolve
 
     var options = {
         containerClass: "autocomplete",
-        /* as we use can potentially use jsonp we need to set the timeout to a small value */
         timeout: 1000,
         /* avoid too many requests when typing quickly */
         deferRequestBy: 5,
diff --git a/web/src/main/resources/assets/js/graphhopper/GHRequest.js b/web/src/main/resources/assets/js/graphhopper/GHRequest.js
index 3ca0dbcb34..a91f8f6b18 100644
--- a/web/src/main/resources/assets/js/graphhopper/GHRequest.js
+++ b/web/src/main/resources/assets/js/graphhopper/GHRequest.js
@@ -36,7 +36,6 @@ var GHRequest = function (host, api_key) {
 
     this.do_zoom = true;
     this.useMiles = false;
-    // use jsonp here if host allows CORS
     this.dataType = "json";
     this.api_params = {"locale": "en", "vehicle": "car", "weighting": "fastest", "elevation": false,
         "key": api_key, "pt": {}};
@@ -258,8 +257,6 @@ GHRequest.prototype.doRequest = function (url, callback) {
             callback(json);
         },
         error: function (err) {
-            // problematic: this callback is not invoked when using JSONP!
-            // http://stackoverflow.com/questions/19035557/jsonp-request-error-handling
             var msg = "API did not respond! ";
             var json;
 
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
similarity index 96%
rename from web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java
rename to web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
index 8838374ac1..609935761c 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperDataflagEncoderSpatialRulesIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperDataFlagEncoderSpatialRulesTest.java
@@ -31,11 +31,11 @@
 import static org.junit.Assert.*;
 
 /**
- * Tests the DataFlagencoder with the SpatialRuleLookup enabled
+ * Tests the DataFlagEncoder with the SpatialRuleLookup enabled
  *
  * @author Robin Boldt
  */
-public class GraphHopperDataflagEncoderSpatialRulesIT {
+public class GraphHopperDataFlagEncoderSpatialRulesTest {
     private static final String DIR = "./target/north-bayreuth-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java b/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
rename to web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
index 427ee6e923..a98ab0a243 100644
--- a/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksIT.java
+++ b/web/src/test/java/com/graphhopper/http/GraphHopperLandmarksTest.java
@@ -36,7 +36,7 @@
  *
  * @author Robin Boldt
  */
-public class GraphHopperLandmarksIT {
+public class GraphHopperLandmarksTest {
     private static final String DIR = "./target/landmark-test-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java b/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
similarity index 75%
rename from web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java
rename to web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
index d8d7d930dd..a4ee7df810 100644
--- a/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/isochrone/IsochroneResourceTest.java
@@ -13,6 +13,7 @@
 import org.junit.ClassRule;
 import org.junit.Test;
 
+import javax.ws.rs.core.Response;
 import java.io.File;
 import java.util.List;
 
@@ -20,7 +21,7 @@
 import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertEquals;
 
-public class IsochroneResourceIT {
+public class IsochroneResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
@@ -49,7 +50,7 @@ public static void cleanUp() {
     @Test
     public void requestByTimeLimit() throws Exception {
         IsochroneResponse rsp = client.isochroneGet("42.531073,1.573792", "no_key_necessary",
-                5 * 60, -1, "car", 2, false);
+                5 * 60, -1, "car", 2, false, "fastest");
         assertEquals(2, rsp.getPolygons().size());
         List polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
         List polygon1 = rsp.getPolygons().get(1).getGeometry().getCoordinates().get(0);
@@ -64,7 +65,7 @@ public void requestByTimeLimit() throws Exception {
     @Test
     public void requestByDistanceLimit() throws Exception {
         IsochroneResponse rsp = client.isochroneGet("42.531073,1.573792", "no_key_necessary", -1,
-                3_000, "car", 2, false);
+                3_000, "car", 2, false, "fastest");
         assertEquals(2, rsp.getPolygons().size());
         List polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
         List polygon1 = rsp.getPolygons().get(1).getGeometry().getCoordinates().get(0);
@@ -79,7 +80,7 @@ public void requestByDistanceLimit() throws Exception {
     @Test
     public void requestReverseFlow() throws Exception {
         IsochroneResponse rsp = client.isochroneGet("42.531073,1.573792", "no_key_necessary",
-                5 * 60, -1, "car", 2, true);
+                5 * 60, -1, "car", 2, true, "fastest");
         assertEquals(2, rsp.getPolygons().size());
         List polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
         List polygon1 = rsp.getPolygons().get(1).getGeometry().getCoordinates().get(0);
@@ -91,6 +92,29 @@ public void requestReverseFlow() throws Exception {
         assertFalse(contains(polygon1, 42.53841, 1.635246));
     }
 
+    @Test
+    public void requestBadRequest() {
+        Response response = app.client().target("http://localhost:8080/route?point=-1.816719,51.557148").request().buildGet().invoke();
+        assertEquals(400, response.getStatus());
+    }
+  
+    public void requestWithShortest() throws Exception {
+        IsochroneResponse rsp = client.isochroneGet("42.509644,1.540554", "no_key_necessary", 130,
+                -1, "car", 1, false, "shortest");
+        assertEquals(1, rsp.getPolygons().size());
+        List polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
+
+        assertTrue(contains(polygon0, 42.507145, 1.527057));
+        assertFalse(contains(polygon0, 42.507081, 1.525404));
+
+        // more like a circle => shorter is expected
+        assertTrue(polygon0.size() < 185);
+        rsp = client.isochroneGet("42.509644,1.540554", "no_key_necessary", 130,
+                -1, "car", 1, false, "fastest");
+        polygon0 = rsp.getPolygons().get(0).getGeometry().getCoordinates().get(0);
+        assertTrue(polygon0.size() >= 190);
+    }
+
     private boolean contains(List polygon, double lat, double lon) {
         int index = 0;
         double lats[] = new double[polygon.size()];
diff --git a/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
index 8a0674a3d9..e156867450 100644
--- a/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/ChangeGraphResourceTest.java
@@ -37,7 +37,7 @@
 /**
  * @author Peter Karich
  */
-public class ChangeGraphResourceIT {
+public class ChangeGraphResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java
similarity index 98%
rename from web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java
index c1182e26bb..60387208a4 100644
--- a/web/src/test/java/com/graphhopper/http/resources/I18nResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/I18nResourceTest.java
@@ -15,7 +15,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-public class I18nResourceIT {
+public class I18nResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
similarity index 98%
rename from web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
index eb6aa7c260..f27ecb63c3 100644
--- a/web/src/test/java/com/graphhopper/http/resources/NearestResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/NearestResourceTest.java
@@ -36,7 +36,7 @@
 /**
  * @author svantulden
  */
-public class NearestResourceIT {
+public class NearestResourceTest {
     private static final String dir = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java b/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java
rename to web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
index 42d45ea2d8..eb016196a2 100644
--- a/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/NearestResourceWithEleTest.java
@@ -37,7 +37,7 @@
 /**
  * @author svantulden
  */
-public class NearestResourceWithEleIT {
+public class NearestResourceWithEleTest {
     private static final String dir = "./target/monaco-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
similarity index 93%
rename from web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java
rename to web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
index 80b61063f3..f2872157f1 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceTest.java
@@ -25,7 +25,6 @@
 import com.graphhopper.api.GraphHopperWeb;
 import com.graphhopper.http.GraphHopperApplication;
 import com.graphhopper.http.GraphHopperServerConfiguration;
-import com.graphhopper.resources.NearestResource;
 import com.graphhopper.util.CmdArgs;
 import com.graphhopper.util.Helper;
 import com.graphhopper.util.details.PathDetail;
@@ -47,7 +46,7 @@
 /**
  * @author Peter Karich
  */
-public class RouteResourceIT {
+public class RouteResourceTest {
     private static final String DIR = "./target/andorra-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
@@ -72,7 +71,7 @@ public static void cleanUp() {
     }
 
     @Test
-    public void testBasicQuery() throws Exception {
+    public void testBasicQuery() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
@@ -84,6 +83,14 @@ public void testBasicQuery() throws Exception {
         assertTrue("distance wasn't correct:" + distance, distance < 9500);
     }
 
+    @Test
+    public void testWrongPointFormat() {
+        final Response response = app.client().target("http://localhost:8080/route?point=1234&point=42.510071,1.548128").request().buildGet().invoke();
+        assertEquals(400, response.getStatus());
+        JsonNode json = response.readEntity(JsonNode.class);
+        assertTrue("There should be an error " + json.get("message"), json.get("message").asText().contains("Cannot parse point '1234'"));
+    }
+
     @Test
     public void testQueryWithDirections() throws Exception {
         // Note, in general specifying directions does not work with CH, but this is an example where it works
@@ -100,7 +107,7 @@ public void testQueryWithDirections() throws Exception {
 
     @Test
     public void testQueryWithStraightVia() throws Exception {
-        // Note, in general specifying straightvia does not work with CH, but this is an example where it works
+        // Note, in general specifying pass_through does not work with CH, but this is an example where it works
         final Response response = app.client().target("http://localhost:8080/route?point=42.534133,1.581473&point=42.534781,1.582149&point=42.535042,1.582514&pass_through=true").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         JsonNode json = response.readEntity(JsonNode.class);
@@ -190,7 +197,7 @@ public void testPathDetails() throws Exception {
         long expectedTime = rsp.getBest().getTime();
         long actualTime = 0;
         List<PathDetail> timeDetails = pathDetails.get("time");
-        for (PathDetail pd: timeDetails) {
+        for (PathDetail pd : timeDetails) {
             actualTime += (Long) pd.getValue();
         }
 
@@ -237,7 +244,7 @@ public void testPathDetailsWithoutGraphHopperWeb() throws Exception {
         assertTrue(details.has("edge_id"));
         JsonNode edgeIds = details.get("edge_id");
         int firstLink = edgeIds.get(0).get(2).asInt();
-        int lastLink = edgeIds.get(edgeIds.size()-1).get(2).asInt();
+        int lastLink = edgeIds.get(edgeIds.size() - 1).get(2).asInt();
         assertEquals(880, firstLink);
         assertEquals(1419, lastLink);
     }
@@ -284,10 +291,16 @@ public void testGraphHopperWebRealExceptions() {
         ex = rsp.getErrors().get(0);
         assertTrue("Wrong exception found: " + ex.getClass().getName()
                 + ", IllegalArgumentException expected.", ex instanceof IllegalArgumentException);
+
+        // an IllegalArgumentException from inside the core is written as JSON
+        final Response response = app.client().target("http://localhost:8080/route?vehicle=SPACE-SHUTTLE&point=42.554851,1.536198&point=42.510071,1.548128").request().buildGet().invoke();
+        assertEquals(400, response.getStatus());
+        String msg = (String) response.readEntity(Map.class).get("message");
+        assertTrue(msg, msg.contains("Vehicle not supported:"));
     }
 
     @Test
-    public void testGPX() throws Exception {
+    public void testGPX() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&point=42.510071,1.548128&type=gpx").request().buildGet().invoke();
         assertEquals(200, response.getStatus());
         String str = response.readEntity(String.class);
@@ -318,7 +331,7 @@ public void testGPXWithTrackAndWaypointsSelection() throws Exception {
     }
 
     @Test
-    public void testGPXWithError() throws Exception {
+    public void testGPXWithError() {
         final Response response = app.client().target("http://localhost:8080/route?point=42.554851,1.536198&type=gpx").request().buildGet().invoke();
         assertEquals(400, response.getStatus());
         String str = response.readEntity(String.class);
diff --git a/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java b/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
similarity index 99%
rename from web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java
rename to web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
index 4c3165e774..cb13a5c894 100644
--- a/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleIT.java
+++ b/web/src/test/java/com/graphhopper/http/resources/RouteResourceWithEleTest.java
@@ -36,7 +36,7 @@
 /**
  * @author Peter Karich
  */
-public class RouteResourceWithEleIT {
+public class RouteResourceWithEleTest {
     private static final String dir = "./target/monaco-gh/";
 
     private static final GraphHopperServerConfiguration config = new GraphHopperServerConfiguration();
