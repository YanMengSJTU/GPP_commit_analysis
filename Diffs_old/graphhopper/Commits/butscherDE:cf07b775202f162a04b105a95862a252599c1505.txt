diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 2c275cdc53..507538c8c9 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1008,28 +1008,15 @@ public GHResponse route(GHRequest request) {
                 QueryGraph queryGraph;
 
                 if (chFactoryDecorator.isEnabled() && !disableCH) {
-                    boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
-                    if (!forceCHHeading && request.hasFavoredHeading(0)) {
+                    BuilderForQueryGraphAndWeightingWithCHEnabled builderForQueryGraphAndWeightingWithCHEnabled = new BuilderForQueryGraphAndWeightingWithCHEnabled(request, ghRsp, hints, qResults, tmpAlgoFactory).invoke();
+                    if (builderForQueryGraphAndWeightingWithCHEnabled.is())
                         return addIllegalArgumentExceptionAndReturnEmptyCollection(ghRsp, "Heading is not (fully) supported for CHGraph. See issue #483");
-                    }
-
-                    // if LM is enabled we have the LMFactory with the CH algo!
-                    RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;
-                    if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory)
-                        chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();
-
-                    if (chAlgoFactory instanceof PrepareContractionHierarchies)
-                        weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();
-                    else
-                        throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
-
-                    queryGraph = new QueryGraph(ghStorage.getCHGraph(weighting));
-                    queryGraph.lookup(qResults);
+                    weighting = builderForQueryGraphAndWeightingWithCHEnabled.getWeighting();
+                    queryGraph = builderForQueryGraphAndWeightingWithCHEnabled.getQueryGraph();
                 } else {
-                    checkNonChMaxWaypointDistance(points);
-                    queryGraph = new QueryGraph(ghStorage);
-                    queryGraph.lookup(qResults);
-                    weighting = createWeighting(hints, encoder, queryGraph);
+                    BuilderForQueryGraphAndWeightingWithCHDisabled builderForQueryGraphAndWeightingWithCHDisabled = new BuilderForQueryGraphAndWeightingWithCHDisabled(hints, encoder, points, qResults).invoke();
+                    weighting = builderForQueryGraphAndWeightingWithCHDisabled.getWeighting();
+                    queryGraph = builderForQueryGraphAndWeightingWithCHDisabled.getQueryGraph();
                 }
                 ghRsp.addDebugInfo("tmode:" + tMode.toString());
 
@@ -1167,27 +1154,6 @@ private void checkIfPointsAreInBounds(List<GHPoint> points) {
         }
     }
 
-    private void checkNonChMaxWaypointDistance(List<GHPoint> points) {
-        if (nonChMaxWaypointDistance == Integer.MAX_VALUE) {
-            return;
-        }
-        GHPoint lastPoint = points.get(0);
-        GHPoint point;
-        double dist;
-        DistanceCalc calc = DIST_3D;
-        for (int i = 1; i < points.size(); i++) {
-            point = points.get(i);
-            dist = calc.calcDist(lastPoint.getLat(), lastPoint.getLon(), point.getLat(), point.getLon());
-            if (dist > nonChMaxWaypointDistance) {
-                Map<String, Object> detailMap = new HashMap<>(2);
-                detailMap.put("from", i - 1);
-                detailMap.put("to", i);
-                throw new PointDistanceExceededException("Point " + i + " is too far from Point " + (i - 1) + ": " + point, detailMap);
-            }
-            lastPoint = point;
-        }
-    }
-
     protected LocationIndex createLocationIndex(Directory dir) {
         LocationIndexTree tmpIndex = new LocationIndexTree(ghStorage, dir);
         tmpIndex.setResolution(preciseIndexResolution);
@@ -1312,4 +1278,110 @@ public void setNonChMaxWaypointDistance(int nonChMaxWaypointDistance) {
         this.nonChMaxWaypointDistance = nonChMaxWaypointDistance;
     }
 
+    private class BuilderForQueryGraphAndWeightingWithCHEnabled {
+        private boolean myResult;
+        private GHRequest request;
+        private GHResponse ghRsp;
+        private HintsMap hints;
+        private List<QueryResult> qResults;
+        private RoutingAlgorithmFactory tmpAlgoFactory;
+        private Weighting weighting;
+        private QueryGraph queryGraph;
+
+        public BuilderForQueryGraphAndWeightingWithCHEnabled(GHRequest request, GHResponse ghRsp, HintsMap hints, List<QueryResult> qResults, RoutingAlgorithmFactory tmpAlgoFactory) {
+            this.request = request;
+            this.ghRsp = ghRsp;
+            this.hints = hints;
+            this.qResults = qResults;
+            this.tmpAlgoFactory = tmpAlgoFactory;
+        }
+
+        boolean is() {
+            return myResult;
+        }
+
+        public Weighting getWeighting() {
+            return weighting;
+        }
+
+        public QueryGraph getQueryGraph() {
+            return queryGraph;
+        }
+
+        public BuilderForQueryGraphAndWeightingWithCHEnabled invoke() {
+            boolean forceCHHeading = hints.getBool(CH.FORCE_HEADING, false);
+            if (!forceCHHeading && request.hasFavoredHeading(0)) {
+                myResult = true;
+                return this;
+            }
+
+            // if LM is enabled we have the LMFactory with the CH algo!
+            RoutingAlgorithmFactory chAlgoFactory = tmpAlgoFactory;
+            if (tmpAlgoFactory instanceof LMAlgoFactoryDecorator.LMRAFactory)
+                chAlgoFactory = ((LMAlgoFactoryDecorator.LMRAFactory) tmpAlgoFactory).getDefaultAlgoFactory();
+
+            if (chAlgoFactory instanceof PrepareContractionHierarchies)
+                weighting = ((PrepareContractionHierarchies) chAlgoFactory).getWeighting();
+            else
+                throw new IllegalStateException("Although CH was enabled a non-CH algorithm factory was returned " + tmpAlgoFactory);
+
+            queryGraph = new QueryGraph(ghStorage.getCHGraph(weighting));
+            queryGraph.lookup(qResults);
+            myResult = false;
+            return this;
+        }
+    }
+
+    private class BuilderForQueryGraphAndWeightingWithCHDisabled {
+        private HintsMap hints;
+        private FlagEncoder encoder;
+        private List<GHPoint> points;
+        private List<QueryResult> qResults;
+        private Weighting weighting;
+        private QueryGraph queryGraph;
+
+        public BuilderForQueryGraphAndWeightingWithCHDisabled(HintsMap hints, FlagEncoder encoder, List<GHPoint> points, List<QueryResult> qResults) {
+            this.hints = hints;
+            this.encoder = encoder;
+            this.points = points;
+            this.qResults = qResults;
+        }
+
+        public Weighting getWeighting() {
+            return weighting;
+        }
+
+        public QueryGraph getQueryGraph() {
+            return queryGraph;
+        }
+
+        public BuilderForQueryGraphAndWeightingWithCHDisabled invoke() {
+            checkNonChMaxWaypointDistance(points);
+            queryGraph = new QueryGraph(ghStorage);
+            queryGraph.lookup(qResults);
+            weighting = createWeighting(hints, encoder, queryGraph);
+            return this;
+        }
+
+        private void checkNonChMaxWaypointDistance(List<GHPoint> points) {
+            if (nonChMaxWaypointDistance == Integer.MAX_VALUE) {
+                return;
+            }
+            GHPoint lastPoint = points.get(0);
+            GHPoint point;
+            double dist;
+            DistanceCalc calc = DIST_3D;
+            for (int i = 1; i < points.size(); i++) {
+                point = points.get(i);
+                dist = calc.calcDist(lastPoint.getLat(), lastPoint.getLon(), point.getLat(), point.getLon());
+                if (dist > nonChMaxWaypointDistance) {
+                    Map<String, Object> detailMap = new HashMap<>(2);
+                    detailMap.put("from", i - 1);
+                    detailMap.put("to", i);
+                    throw new PointDistanceExceededException("Point " + i + " is too far from Point " + (i - 1) + ": " + point, detailMap);
+                }
+                lastPoint = point;
+            }
+        }
+    }
 }
