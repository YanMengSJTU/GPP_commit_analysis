diff --git a/core/ColorInfo.xlsx b/core/ColorInfo.xlsx
index ca150d3d25..885b9fbd48 100644
Binary files a/core/ColorInfo.xlsx and b/core/ColorInfo.xlsx differ
diff --git a/core/graphhopper/temp/edges b/core/graphhopper/temp/edges
new file mode 100644
index 0000000000..17804c7a54
Binary files /dev/null and b/core/graphhopper/temp/edges differ
diff --git a/core/graphhopper/temp/geometry b/core/graphhopper/temp/geometry
new file mode 100644
index 0000000000..754f1ebe0a
Binary files /dev/null and b/core/graphhopper/temp/geometry differ
diff --git a/core/graphhopper/temp/location_index b/core/graphhopper/temp/location_index
new file mode 100644
index 0000000000..a4be5940a5
Binary files /dev/null and b/core/graphhopper/temp/location_index differ
diff --git a/core/graphhopper/temp/names b/core/graphhopper/temp/names
new file mode 100644
index 0000000000..e08d50a4b7
Binary files /dev/null and b/core/graphhopper/temp/names differ
diff --git a/core/graphhopper/temp/nodes b/core/graphhopper/temp/nodes
new file mode 100644
index 0000000000..f6c16153bd
Binary files /dev/null and b/core/graphhopper/temp/nodes differ
diff --git a/core/graphhopper/temp/properties b/core/graphhopper/temp/properties
new file mode 100644
index 0000000000..544e7c7fe2
Binary files /dev/null and b/core/graphhopper/temp/properties differ
diff --git a/core/src/main/java/com/graphhopper/Main.java b/core/src/main/java/com/graphhopper/Main.java
new file mode 100644
index 0000000000..744bf09889
--- /dev/null
+++ b/core/src/main/java/com/graphhopper/Main.java
@@ -0,0 +1,45 @@
+package com.graphhopper;
+
+import java.util.List;
+import java.util.Map;
+
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.util.Instruction;
+import com.graphhopper.util.InstructionList;
+import com.graphhopper.util.PointList;
+
+public class Main {
+	public static void main(String[] args) {
+		GraphHopper hopper = new GraphHopper().forServer();
+		hopper.setCHEnable(false);
+		hopper.setOSMFile("map1.osm");
+		hopper.setGraphHopperLocation("graphhopper/temp");
+		hopper.setEncodingManager(new EncodingManager("bike"));
+
+		hopper.importOrLoad();
+
+		GHRequest req = new GHRequest(40.3495705, -74.662466, 40.3502235, -74.6601703).
+		    setVehicle("bike").setAlgorithm(AlgorithmOptions.ASTAR);
+		GHResponse res = hopper.route(req);
+		
+		// use the best path, see the GHResponse class for more possibilities.
+		PathWrapper path = res.getBest();
+
+		// points, distance in meters and time in millis of the full path
+		PointList pointList = path.getPoints();
+		double distance = path.getDistance();
+		long timeInMs = path.getTime();
+
+		InstructionList il = path.getInstructions();
+		// iterate over every turn instruction
+		for(Instruction instruction : il) {
+		   instruction.getDistance();
+		   System.out.println(instruction);
+		}
+
+		// or get the json
+		List<Map<String, Object>> iList = il.createJson();
+
+	}
+}
diff --git a/core/src/main/java/com/graphhopper/routing/Dijkstra.java b/core/src/main/java/com/graphhopper/routing/Dijkstra.java
deleted file mode 100644
index 1ee9257e84..0000000000
--- a/core/src/main/java/com/graphhopper/routing/Dijkstra.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-
-import java.util.PriorityQueue;
-
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.SPTEntry;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-
-/**
- * Implements a single source shortest path algorithm
- * http://en.wikipedia.org/wiki/Dijkstra's_algorithm
- * <p>
- * @author Peter Karich
- */
-public class Dijkstra extends AbstractRoutingAlgorithm
-{
-    protected TIntObjectMap<SPTEntry> fromMap;
-    protected PriorityQueue<SPTEntry> fromHeap;
-    protected SPTEntry currEdge;
-    private int visitedNodes;
-    private int to = -1;
-
-    public Dijkstra( Graph g, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        super(g, encoder, weighting, tMode);
-        initCollections(1000);
-    }
-
-    protected void initCollections( int size )
-    {
-        fromHeap = new PriorityQueue<SPTEntry>(size);
-        fromMap = new TIntObjectHashMap<SPTEntry>(size);
-    }
-
-    @Override
-    public Path calcPath( int from, int to )
-    {
-        checkAlreadyRun();
-        this.to = to;
-        currEdge = createSPTEntry(from, 0);
-        if (!traversalMode.isEdgeBased())
-        {
-            fromMap.put(from, currEdge);
-        }
-        runAlgo();
-        return extractPath();
-    }
-
-    protected void runAlgo()
-    {
-        EdgeExplorer explorer = outEdgeExplorer;
-        while (true)
-        {
-            visitedNodes++;
-            if (isWeightLimitExceeded() || finished() || isMaxVisitedNodesExceeded())
-                break;
-
-            int startNode = currEdge.adjNode;
-            EdgeIterator iter = explorer.setBaseNode(startNode);
-            while (iter.next())
-            {
-                if (!accept(iter, currEdge.edge))
-                    continue;
-
-                int traversalId = traversalMode.createTraversalId(iter, false);
-                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;
-                if (Double.isInfinite(tmpWeight))
-                    continue;
-
-                SPTEntry nEdge = fromMap.get(traversalId);
-                if (nEdge == null)
-                {
-                    nEdge = new SPTEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
-                    nEdge.parent = currEdge;
-                    fromMap.put(traversalId, nEdge);
-                    fromHeap.add(nEdge);
-                } else if (nEdge.weight > tmpWeight)
-                {
-                    fromHeap.remove(nEdge);
-                    nEdge.edge = iter.getEdge();
-                    nEdge.weight = tmpWeight;
-                    nEdge.parent = currEdge;
-                    fromHeap.add(nEdge);
-                } else
-                    continue;
-
-                updateBestPath(iter, nEdge, traversalId);
-            }
-
-            if (fromHeap.isEmpty())
-                break;
-
-            currEdge = fromHeap.poll();
-            if (currEdge == null)
-                throw new AssertionError("Empty edge cannot happen");
-        }
-    }
-
-    @Override
-    protected boolean finished()
-    {
-        return currEdge.adjNode == to;
-    }
-
-    @Override
-    protected Path extractPath()
-    {
-        if (currEdge == null || isWeightLimitExceeded() || !finished())
-            return createEmptyPath();
-
-        return new Path(graph, flagEncoder).setWeight(currEdge.weight).setSPTEntry(currEdge).extract();
-    }
-
-    @Override
-    public int getVisitedNodes()
-    {
-        return visitedNodes;
-    }
-
-    @Override
-    protected boolean isWeightLimitExceeded()
-    {
-        return currEdge.weight > weightLimit;
-    }
-
-    @Override
-    public String getName()
-    {
-        return AlgorithmOptions.DIJKSTRA;
-    }
-}
diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java b/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
deleted file mode 100644
index 527d050aba..0000000000
--- a/core/src/main/java/com/graphhopper/routing/DijkstraBidirectionRef.java
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- *  Licensed to GraphHopper and Peter Karich under one or more contributor
- *  license agreements. See the NOTICE file distributed with this work for 
- *  additional information regarding copyright ownership.
- * 
- *  GraphHopper licenses this file to you under the Apache License, 
- *  Version 2.0 (the "License"); you may not use this file except in 
- *  compliance with the License. You may obtain a copy of the License at
- * 
- *       http://www.apache.org/licenses/LICENSE-2.0
- * 
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-package com.graphhopper.routing;
-
-import gnu.trove.map.TIntObjectMap;
-import gnu.trove.map.hash.TIntObjectHashMap;
-
-import java.util.HashMap;
-import java.util.PriorityQueue;
-
-import com.graphhopper.routing.safety.ColorMapParser;
-import com.graphhopper.routing.safety.NodeInformation;
-import com.graphhopper.routing.safety.OSMParser;
-import com.graphhopper.routing.safety.Way;
-import com.graphhopper.routing.util.FlagEncoder;
-import com.graphhopper.routing.util.TraversalMode;
-import com.graphhopper.routing.util.Weighting;
-import com.graphhopper.storage.SPTEntry;
-import com.graphhopper.storage.Graph;
-import com.graphhopper.util.EdgeExplorer;
-import com.graphhopper.util.EdgeIterator;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.GHUtility;
-
-/**
- * Calculates best path in bidirectional way.
- * <p>
- * 'Ref' stands for reference implementation and is using the normal Java-'reference'-way.
- * <p>
- * @author Peter Karich
- */
-public class DijkstraBidirectionRef extends AbstractBidirAlgo
-{
-    private PriorityQueue<SPTEntry> openSetFrom;
-    private PriorityQueue<SPTEntry> openSetTo;
-    protected TIntObjectMap<SPTEntry> bestWeightMapFrom;
-    protected TIntObjectMap<SPTEntry> bestWeightMapTo;
-    protected TIntObjectMap<SPTEntry> bestWeightMapOther;
-    protected SPTEntry currFrom;
-    protected SPTEntry currTo;
-    protected PathBidirRef bestPath;
-    private boolean updateBestPath = true;
-
-    public DijkstraBidirectionRef( Graph graph, FlagEncoder encoder, Weighting weighting, TraversalMode tMode )
-    {
-        super(graph, encoder, weighting, tMode);
-        initCollections(1000);
-    }
-
-    protected void initCollections( int nodes )
-    {
-        openSetFrom = new PriorityQueue<SPTEntry>(nodes / 10);
-        bestWeightMapFrom = new TIntObjectHashMap<SPTEntry>(nodes / 10);
-
-        openSetTo = new PriorityQueue<SPTEntry>(nodes / 10);
-        bestWeightMapTo = new TIntObjectHashMap<SPTEntry>(nodes / 10);
-    }
-
-    @Override
-    public void initFrom( int from, double weight )
-    {
-        currFrom = createSPTEntry(from, weight);
-        openSetFrom.add(currFrom);
-        if (!traversalMode.isEdgeBased())
-        {
-            bestWeightMapFrom.put(from, currFrom);
-            if (currTo != null)
-            {
-                bestWeightMapOther = bestWeightMapTo;
-                updateBestPath(GHUtility.getEdge(graph, from, currTo.adjNode), currTo, from);
-            }
-        } else
-        {
-            if (currTo != null && currTo.adjNode == from)
-            {
-                // special case of identical start and end
-                bestPath.sptEntry = currFrom;
-                bestPath.edgeTo = currTo;
-                finishedFrom = true;
-                finishedTo = true;
-            }
-        }
-    }
-
-    @Override
-    public void initTo( int to, double weight )
-    {
-        currTo = createSPTEntry(to, weight);
-        openSetTo.add(currTo);
-        if (!traversalMode.isEdgeBased())
-        {
-            bestWeightMapTo.put(to, currTo);
-            if (currFrom != null)
-            {
-                bestWeightMapOther = bestWeightMapFrom;
-                updateBestPath(GHUtility.getEdge(graph, currFrom.adjNode, to), currFrom, to);
-            }
-        } else
-        {
-            if (currFrom != null && currFrom.adjNode == to)
-            {
-                // special case of identical start and end
-                bestPath.sptEntry = currFrom;
-                bestPath.edgeTo = currTo;
-                finishedFrom = true;
-                finishedTo = true;
-            }
-        }
-    }
-
-    @Override
-    protected Path createAndInitPath()
-    {
-        bestPath = new PathBidirRef(graph, flagEncoder);
-        return bestPath;
-    }
-
-    @Override
-    protected Path extractPath()
-    {
-        if (finished())
-            return bestPath.extract();
-        
-        return bestPath;
-    }
-
-    @Override
-    protected double getCurrentFromWeight()
-    {
-        return currFrom.weight;
-    }
-
-    @Override
-    protected double getCurrentToWeight()
-    {
-        return currTo.weight;
-    }
-
-    @Override
-    public boolean fillEdgesFrom()
-    {
-        if (openSetFrom.isEmpty())
-            return false;
-
-        currFrom = openSetFrom.poll();
-        bestWeightMapOther = bestWeightMapTo;
-        fillEdges(currFrom, openSetFrom, bestWeightMapFrom, outEdgeExplorer, false);
-        visitedCountFrom++;
-        return true;
-    }
-
-    @Override
-    public boolean fillEdgesTo()
-    {
-        if (openSetTo.isEmpty())
-            return false;
-        currTo = openSetTo.poll();
-        bestWeightMapOther = bestWeightMapFrom;
-        fillEdges(currTo, openSetTo, bestWeightMapTo, inEdgeExplorer, true);
-        visitedCountTo++;
-        return true;
-    }
-
-    // http://www.cs.princeton.edu/courses/archive/spr06/cos423/Handouts/EPP%20shortest%20path%20algorithms.pdf
-    // a node from overlap may not be on the best path!
-    // => when scanning an arc (v, w) in the forward search and w is scanned in the reverseOrder 
-    //    search, update extractPath = μ if df (v) + (v, w) + dr (w) < μ            
-    @Override
-    public boolean finished()
-    {
-        if (finishedFrom || finishedTo)
-            return true;
-
-        return currFrom.weight + currTo.weight >= bestPath.getWeight();
-    }
-
-    @Override
-    protected boolean isWeightLimitExceeded()
-    {
-        return currFrom.weight + currTo.weight > weightLimit;
-    }
-
-    void fillEdges( SPTEntry currEdge, PriorityQueue<SPTEntry> prioQueue,
-                    TIntObjectMap<SPTEntry> shortestWeightMap, EdgeExplorer explorer, boolean reverse )
-    {        
-        EdgeIterator iter = explorer.setBaseNode(currEdge.adjNode);
-        while (iter.next())
-        {
-            if (!accept(iter, currEdge.edge))
-                continue;
-            
-            int traversalId = traversalMode.createTraversalId(iter, reverse);
-            
-            HashMap<Long, NodeInformation> nodeMap = new HashMap<Long, NodeInformation>();
-            HashMap<Long, Way> wayMap = new HashMap<Long, Way>();
-            HashMap<Long, HashMap<Long, Integer>> scores = new HashMap<Long, HashMap<Long, Integer>>();
-            double maxLong = -74.65986;
-            double minLat = 40.34993;
-            double minLong = -74.66236;
-            double maxLat = 40.35111;
-            OSMParser.parseFile(minLong, minLat, maxLong, maxLat, nodeMap, wayMap);
-            ColorMapParser.parseFile(nodeMap, wayMap, scores);
-            int safetyWeight = ColorMapParser.getSafetyWeight((long) iter.getAdjNode(),
-                    (long) currEdge.adjNode, scores);
-            System.out.println(safetyWeight);
-
-            double tmpWeight = (weighting.calcWeight(iter, reverse, currEdge.edge))*safetyWeight + currEdge.weight;
-            if (Double.isInfinite(tmpWeight))
-                continue;
-
-            SPTEntry ee = shortestWeightMap.get(traversalId);
-            if (ee == null)
-            {
-                ee = new SPTEntry(iter.getEdge(), iter.getAdjNode(), tmpWeight);
-                ee.parent = currEdge;
-                shortestWeightMap.put(traversalId, ee);
-                prioQueue.add(ee);
-            } else if (ee.weight > tmpWeight)
-            {
-                prioQueue.remove(ee);
-                ee.edge = iter.getEdge();
-                ee.weight = tmpWeight;
-                ee.parent = currEdge;
-                prioQueue.add(ee);
-            } else
-                continue;
-
-            if (updateBestPath)
-                updateBestPath(iter, ee, traversalId);
-        }
-    }
-
-    @Override
-    protected void updateBestPath( EdgeIteratorState edgeState, SPTEntry entryCurrent, int traversalId )
-    {
-        SPTEntry entryOther = bestWeightMapOther.get(traversalId);
-        if (entryOther == null)
-            return;
-
-        boolean reverse = bestWeightMapFrom == bestWeightMapOther;
-
-        // update μ
-        double newWeight = entryCurrent.weight + entryOther.weight;
-        if (traversalMode.isEdgeBased())
-        {
-            if (entryOther.edge != entryCurrent.edge)
-                throw new IllegalStateException("cannot happen for edge based execution of " + getName());
-
-            if (entryOther.adjNode != entryCurrent.adjNode)
-            {
-                // prevents the path to contain the edge at the meeting point twice and subtract the weight (excluding turn weight => no previous edge)
-                entryCurrent = entryCurrent.parent;
-                newWeight -= weighting.calcWeight(edgeState, reverse, EdgeIterator.NO_EDGE);
-            } else
-            {
-                // we detected a u-turn at meeting point, skip if not supported
-                if (!traversalMode.hasUTurnSupport())
-                    return;
-            }
-        }
-
-        if (newWeight < bestPath.getWeight())
-        {
-            bestPath.setSwitchToFrom(reverse);
-            bestPath.setSPTEntry(entryCurrent);
-            bestPath.setWeight(newWeight);
-            bestPath.setSPTEntryTo(entryOther);
-        }
-    }
-
-    TIntObjectMap<SPTEntry> getBestFromMap()
-    {
-        return bestWeightMapFrom;
-    }
-
-    TIntObjectMap<SPTEntry> getBestToMap()
-    {
-        return bestWeightMapTo;
-    }
-
-    void setBestOtherMap( TIntObjectMap<SPTEntry> other )
-    {
-        bestWeightMapOther = other;
-    }
-
-    void setFromDataStructures( DijkstraBidirectionRef dijkstra )
-    {
-        openSetFrom = dijkstra.openSetFrom;
-        bestWeightMapFrom = dijkstra.bestWeightMapFrom;
-        finishedFrom = dijkstra.finishedFrom;
-        currFrom = dijkstra.currFrom;
-        visitedCountFrom = dijkstra.visitedCountFrom;
-        // outEdgeExplorer
-    }
-
-    void setToDataStructures( DijkstraBidirectionRef dijkstra )
-    {
-        openSetTo = dijkstra.openSetTo;
-        bestWeightMapTo = dijkstra.bestWeightMapTo;
-        finishedTo = dijkstra.finishedTo;
-        currTo = dijkstra.currTo;
-        visitedCountTo = dijkstra.visitedCountTo;
-        // inEdgeExplorer
-    }
-
-    void setUpdateBestPath( boolean b )
-    {
-        updateBestPath = b;
-    }
-
-    void setBestPath( PathBidirRef bestPath )
-    {
-        this.bestPath = bestPath;
-    }
-
-    @Override
-    public String getName()
-    {
-        return AlgorithmOptions.DIJKSTRA_BI;
-    }
-}
diff --git a/core/src/test/java/com/graphhopper/util/InstructionListTest.java b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
index 367ddba68a..fee5031897 100644
--- a/core/src/test/java/com/graphhopper/util/InstructionListTest.java
+++ b/core/src/test/java/com/graphhopper/util/InstructionListTest.java
@@ -475,7 +475,7 @@ public void testEmptyList()
 
     public void verifyGPX( String gpx )
     {
-        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.DEFAULT_NS_PREFIX);
         Schema schema = null;
         try
         {
