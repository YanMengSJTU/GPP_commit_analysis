diff --git a/core/src/main/java/com/graphhopper/routing/DijkstraManyToMany.java b/core/src/main/java/com/graphhopper/routing/DijkstraManyToMany.java
index 297adb35fb..56acec6464 100644
--- a/core/src/main/java/com/graphhopper/routing/DijkstraManyToMany.java
+++ b/core/src/main/java/com/graphhopper/routing/DijkstraManyToMany.java
@@ -1,13 +1,17 @@
 package com.graphhopper.routing;
 
+import com.carrotsearch.hppc.IntIndexedContainer;
 import com.graphhopper.routing.util.TraversalMode;
 import com.graphhopper.routing.weighting.Weighting;
 import com.graphhopper.storage.Graph;
 import com.graphhopper.util.EdgeIteratorState;
+import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
-import java.util.LinkedList;
-import java.util.List;
+import java.util.*;
 
+/**
+ * Implements a many to many Dijkstra Search that serves the purpose of building a path skeleton of Professor Storandts Region-Aware Route Planning paper.
+ */
 public class DijkstraManyToMany extends DijkstraOneToMany {
     private final List<Integer> interiorGraphNode;
     private final List<Integer> entryExitPoints;
@@ -36,15 +40,34 @@ public void findAllPathsBetweenEntryExitPoints() {
 
         for (int from : entryExitPoints) {
             pathsOneToMany(from);
+            this.clear();
         }
     }
 
     private void pathsOneToMany(int from) {
-        for (int to: entryExitPoints) {
+        for (int to : entryExitPoints) {
             this.currentTo = to;
 
             Path newPath = this.calcPath(from, to);
             allPaths.add(newPath);
         }
     }
+
+    public List<Integer> buildPathSkeleton() {
+        Set<Integer> unionedNodesFromPaths = new HashSet<>(allPaths.size() * 10);
+
+        for (Path path : allPaths) {
+            addPathNodesToSet(unionedNodesFromPaths, path);
+        }
+
+        return new ArrayList<>(unionedNodesFromPaths);
+    }
+
+    private void addPathNodesToSet(Set<Integer> unionedNodesFromPaths, Path path) {
+        IntIndexedContainer nodesInPath = path.calcNodes();
+        for (int i = 0; i < nodesInPath.size(); i++) {
+            int node = nodesInPath.get(i);
+            unionedNodesFromPaths.add(node);
+        }
+    }
 }
