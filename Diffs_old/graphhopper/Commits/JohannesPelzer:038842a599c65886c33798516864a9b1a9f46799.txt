diff --git a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
index 6e7509b121..e8bf93402f 100644
--- a/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
+++ b/core/src/main/java/com/graphhopper/storage/index/LocationIndexTree.java
@@ -28,6 +28,7 @@
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.iterator.TIntIterator;
 import gnu.trove.list.array.TIntArrayList;
 import gnu.trove.procedure.TIntProcedure;
@@ -599,17 +600,96 @@ final long createReverseKey( long key )
     {
         return BitUtil.BIG.reverse(key, keyAlgo.getBits());
     }
+
+    /**
+     * calculate the distance to the nearest tile border for a given lat/lon coordinate in the
+     * context of a spatial key tile.
+     * <p>
+     */
+    double calculateRMin( double lat, double lon )
+    {
+        return calculateRMin(lat, lon, 0);
+    }
+
+    /**
+     * calculate distance to the nearest area border, where area is rectangular region with
+     * dimension 2*paddingtiles+1 and where the centertile contains the given lat/lon coordinate
+     */
+    double calculateRMin( double lat, double lon, int paddingtiles )
+    {
+        GHPoint query = new GHPoint(lat, lon);
+        long key = keyAlgo.encode(query);
+        GHPoint center = new GHPoint();
+        keyAlgo.decode(key, center);
+
+        // deltaLat and deltaLon comes from the LocationIndex:
+        double minLat = center.lat - deltaLat / 2 - (paddingtiles * deltaLat);
+        double maxLat = center.lat + deltaLat / 2 + (paddingtiles * deltaLat);
+        double minLon = center.lon - deltaLon / 2 - (paddingtiles * deltaLon);
+        double maxLon = center.lon + deltaLon / 2 + (paddingtiles * deltaLon);
+        
+        double dSouthernLat = query.lat - minLat;
+        double dNorthernLat = maxLat - query.lat;
+        double dWesternLon = query.lon - minLon;
+        double dEasternLon = maxLon - query.lon;
+
+        // convert degree deltas into a radius in meter
+        double dMinLat, dMinLon;
+        if (dSouthernLat < dNorthernLat)
+        {
+            dMinLat = distCalc.calcDist(query.lat, query.lon, minLat, query.lon);
+        } else
+        {
+            dMinLat = distCalc.calcDist(query.lat, query.lon, maxLat, query.lon);
+        }
+
+        if (dWesternLon < dEasternLon)
+        {
+            dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, minLon);
+        } else
+        {
+            dMinLon = distCalc.calcDist(query.lat, query.lon, query.lat, maxLon);
+        }
+
+        double rMin = Math.min(dMinLat, dMinLon);
+        return rMin;
+    }
+
+    /**
+     * Provide info about tilesize for testing / visualization
+     */
+    public double getDeltaLat()
+    {
+        return deltaLat;
+    }
+
+    public double getDeltaLon()
+    {
+        return deltaLon;
+    }
     
-    
-    protected TIntHashSet findNetworkEntries( double queryLat, double queryLon)
+
+    public GHPoint getCenter( double lat, double lon )
     {
-        TIntHashSet resultEntries = new TIntHashSet(); 
-        TIntHashSet foundEntries = new TIntHashSet();
+        GHPoint query = new GHPoint(lat, lon);
+        long key = keyAlgo.encode(query);
+        GHPoint center = new GHPoint();
+        keyAlgo.decode(key, center);
+        return center;
+    }
 
+    protected TIntHashSet findNetworkEntries( double queryLat, double queryLon )
+    {
+        TIntHashSet foundEntries = new TIntHashSet();
         int maxiteration = 32;
-        for (int iteration = 0; iteration < maxiteration; iteration++)
+
+        if (!regionSearch)
         {
+            maxiteration = 1;
+        }
 
+        for (int iteration = 0; iteration < maxiteration; iteration++)
+        {
             // find entries in border of searchbox
             for (int yreg = -iteration; yreg <= iteration; yreg++)
             {
@@ -617,9 +697,12 @@ protected TIntHashSet findNetworkEntries( double queryLat, double queryLon)
                 double subqueryLonA = queryLon - iteration * deltaLon;
                 double subqueryLonB = queryLon + iteration * deltaLon;
                 foundEntries.addAll(findNetworkEntriesSingleRegion(subqueryLat, subqueryLonA));
-                foundEntries.addAll(findNetworkEntriesSingleRegion(subqueryLat, subqueryLonB));
-
+                if (iteration > 0)
+                {
+                    foundEntries.addAll(findNetworkEntriesSingleRegion(subqueryLat, subqueryLonB));
+                }
             }
+
             for (int xreg = -iteration + 1; xreg <= iteration - 1; xreg++)
             {
                 double subqueryLon = queryLon + xreg * deltaLon;
@@ -629,75 +712,47 @@ protected TIntHashSet findNetworkEntries( double queryLat, double queryLon)
                 foundEntries.addAll(findNetworkEntriesSingleRegion(subqueryLatB, subqueryLon));
             }
 
-          // filter entries, to get only those which are located in a circle
-            if (iteration > 0) // filter only, when scope was already expanded
-            {  
-                double mindelta = (deltaLat < deltaLon) ? deltaLat : deltaLon;
-                double radius = mindelta * (iteration + 0.5);
-                resultEntries = circleFilter(foundEntries, radius, queryLat, queryLon);
-            } else {
-                resultEntries = foundEntries;
-            }
-
-            // Good if something was found. Else repeat whole proces with wider search area. 
-            if (resultEntries.size() > 0)
+            // Check if something was found already...
+            if (foundEntries.size() > 0)
             {
-                break;
+                double rMin = calculateRMin(queryLat, queryLon, iteration);
+                double minDistance = getMinDistance(queryLat, queryLon, foundEntries);
+
+                if (minDistance < rMin)
+                {   // resultEntries contains a nearest node for sure
+                    break;
+                } //else {
+                // we are not finished yet: an undetected nearer node may sit in a neighbour tile
+                // now calculate how far we have to look outside to find any hidden nearest nodes
+                // and repeat whole process with wider search area until this distance is covered 
             }
         }
-        return resultEntries;
+        return foundEntries;
     }
 
-    protected TIntHashSet circleFilter( TIntHashSet input, double radius, double queryLat, double queryLon )
+    protected double getMinDistance( double queryLat, double queryLon, TIntHashSet pointset )
     {
-        TIntHashSet output = new TIntHashSet();
-          //double mindelta = (deltaLat < deltaLon) ? deltaLat : deltaLon;
-        //double radius = mindelta * (iteration + 0.5);
-
-        TIntIterator itr = input.iterator();
+        double min = Double.MAX_VALUE;
+        TIntIterator itr = pointset.iterator();
         while (itr.hasNext())
         {
             int element = itr.next();
-            double eLat = nodeAccess.getLat(element);
-            double eLon = nodeAccess.getLon(element);
-            if (insideCircle(eLat - queryLat, eLon - queryLon, radius))
+            double elementLat = nodeAccess.getLat(element);
+            double elementLon = nodeAccess.getLon(element);
+            double dist = distCalc.calcDist(queryLat, queryLon, elementLat, elementLon);
+            if (min < dist)
             {
-                output.add(element);
+                min = dist;
             }
         }
-        return output;
-    }
-
-    /**
-     * Quick test if coordinate x|y is inside a circle with certain radius (inclusive border)
-     */
-    private boolean insideCircle( double x, double y, double radius )
-    {
-        return (x * x + y * y) <= (radius * radius);
+        return min;
     }
 
     protected TIntHashSet findNetworkEntriesSingleRegion( double queryLat, double queryLon )
     {
         TIntHashSet storedNetworkEntryIds = new TIntHashSet();
-        if (regionSearch)
-        {
-            // search all rasters around minResolutionInMeter as we did not fill empty entries
-            double maxLat = queryLat + 1.5 * deltaLat;
-            double maxLon = queryLon + 1.5 * deltaLon;
-            for (double tmpLat = queryLat - deltaLat; tmpLat < maxLat; tmpLat += deltaLat)
-            {
-                for (double tmpLon = queryLon - deltaLon; tmpLon < maxLon; tmpLon += deltaLon)
-                {
-                    long keyPart = createReverseKey(tmpLat, tmpLon);
-                    // System.out.println(BitUtilLittle.toBitString(key, keyAlgo.bits()));
-                    fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
-                }
-            }
-        } else
-        {
-            long keyPart = createReverseKey(queryLat, queryLon);
-            fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
-        }
+        long keyPart = createReverseKey(queryLat, queryLon);
+        fillIDs(keyPart, START_POINTER, storedNetworkEntryIds, 0);
         return storedNetworkEntryIds;
     }
 
diff --git a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
index 81933c26b5..5bd5f88ca9 100644
--- a/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
+++ b/core/src/test/java/com/graphhopper/storage/index/LocationIndexTreeTest.java
@@ -23,9 +23,7 @@
 import com.graphhopper.storage.Graph;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.RAMDirectory;
-import com.graphhopper.util.BitUtil;
-import com.graphhopper.util.EdgeIteratorState;
-import com.graphhopper.util.Helper;
+import com.graphhopper.util.*;
 import com.graphhopper.util.shapes.GHPoint;
 import gnu.trove.set.hash.TIntHashSet;
 import org.junit.Test;
@@ -305,51 +303,6 @@ public boolean accept( EdgeIteratorState iter )
             }
         }).getClosestNode());
     }
-    
-    @Test
-    public void testCircleFilter()
-    {
-        Graph graph = createGraph(encodingManager);
-        NodeAccess na = graph.getNodeAccess();
-        // inside
-        na.setNode(0, 20.0, 10.0);  // center
-        na.setNode(1, 10.0, 10.0);
-        na.setNode(2, 20.0, -5.0);
-        na.setNode(3, 30.0, 20.0);
-
-        // border
-        na.setNode(4, 0.0, 10.0);
-
-        // outside
-        na.setNode(5, 0.0, 0.0);
-        na.setNode(6, 20.0, -15.0);
-        na.setNode(7, 40.0, 0.0);
-        na.setNode(8, 40.0, 30.0);
-
-        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
-
-        TIntHashSet in = new TIntHashSet();
-        in.add(0);
-        in.add(1);
-        in.add(2);
-        in.add(3);
-        in.add(4);
-        in.add(5);
-        in.add(6);
-        in.add(7);
-        in.add(8);
-
-        TIntHashSet out = index.circleFilter(in, 20.0, 20.0, 10.0);
-        assertTrue(out.contains(0));
-        assertTrue(out.contains(1));
-        assertTrue(out.contains(2));
-        assertTrue(out.contains(3));
-        assertTrue(out.contains(4));
-        assertFalse(out.contains(5));
-        assertFalse(out.contains(6));
-        assertFalse(out.contains(7));
-        assertFalse(out.contains(8));
-    }
 
     // see testgraph2.jpg
     Graph createTestGraph2()
@@ -445,5 +398,37 @@ Graph createTestGraph2()
         graph.edge(27, 33, 10, true);
         graph.edge(28, 34, 10, true);
         return graph;
-    }   
+    }
+
+    @Test
+    public void testRMin()
+    {
+        Graph graph = createTestGraph();
+        LocationIndexTree index = new LocationIndexTree(graph, new RAMDirectory());
+        index.setMinResolutionInMeter(50000).prepareAlgo();
+        LocationIndexTree.InMemConstructionIndex inMemIndex = index.getPrepareInMemIndex();
+        index.dataAccess.create(10);
+        inMemIndex.store(inMemIndex.root, LocationIndexTree.START_POINTER);
+        index.setSearchRegion(false);
+        TIntHashSet set = new TIntHashSet();
+        set.add(0);
+
+        //query: 0.05 | -0.3
+        DistanceCalc distCalc = new DistancePlaneProjection();
+
+        double rmin = index.calculateRMin(0.05, -0.3);
+        double check = distCalc.calcDist(0.05, Math.abs(graph.getNodeAccess().getLon(2)) - index.getDeltaLon(), -0.3, -0.3);
+
+        assertTrue((rmin - check) < 0.0001);
+
+        double rmin2 = index.calculateRMin(0.05, -0.3, 1);
+        double check2 = distCalc.calcDist(0.05, Math.abs(graph.getNodeAccess().getLat(0)), -0.3, -0.3);
+
+        assertTrue((rmin2 - check2) < 0.0001);
+
+        /*GraphVisualizer gv = new GraphVisualizer(graph, index.getDeltaLat(), index.getDeltaLon(), index.getCenter(0, 0).lat, index.getCenter(0, 0).lon);
+         try {
+         Thread.sleep(4000);
+         } catch(InterruptedException ie) {}*/
+    }
 }
