diff --git a/core/src/main/java/com/graphhopper/GraphHopper.java b/core/src/main/java/com/graphhopper/GraphHopper.java
index 3f0d8cba9c..b746028b62 100644
--- a/core/src/main/java/com/graphhopper/GraphHopper.java
+++ b/core/src/main/java/com/graphhopper/GraphHopper.java
@@ -1152,7 +1152,8 @@ private RoutingTemplate buildRoutingTemplate(GHRequest request, GHResponse ghRsp
         } else if (ALT_ROUTE.equalsIgnoreCase(algoStr)) {
             routingTemplate = new AlternativeRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
         } else if (validPolygonInRequest(request)) {
-            routingTemplate = new PolygonThroughRoutingTemplate(request, ghRsp, locationIndex, this, encodingManager);
+            routingTemplate =
+                    new PolygonThroughRoutingTemplate(request, ghRsp, locationIndex, this.getGraphHopperStorage().getNodeAccess(), this.getGraphHopperStorage(), encodingManager);
         } else {
             routingTemplate = new ViaRoutingTemplate(request, ghRsp, locationIndex, encodingManager);
         }
diff --git a/core/src/main/java/com/graphhopper/routing/template/AbstractRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/AbstractRoutingTemplate.java
index d2c2fae262..ca15e6678a 100644
--- a/core/src/main/java/com/graphhopper/routing/template/AbstractRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/AbstractRoutingTemplate.java
@@ -1,5 +1,7 @@
 package com.graphhopper.routing.template;
 
+import com.graphhopper.GHRequest;
+import com.graphhopper.routing.Path;
 import com.graphhopper.storage.index.QueryResult;
 import com.graphhopper.util.PointList;
 
@@ -19,4 +21,9 @@ protected PointList getWaypoints() {
         }
         return pointList;
     }
+
+    public void failOnNumPathsInvalid(final GHRequest ghrequest, final List<Path> paths) {
+        if (ghrequest.getPoints().size() - 1 != paths.size())
+            throw new RuntimeException("There should be exactly one more points than paths. points:" + ghrequest.getPoints().size() + ", paths:" + paths.size());
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
index e01d880236..e24847435a 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonRoutingTemplate.java
@@ -2,59 +2,89 @@
 
 import com.graphhopper.GHRequest;
 import com.graphhopper.GHResponse;
-import com.graphhopper.GraphHopper;
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidate;
 import com.graphhopper.routing.template.PolygonRoutingUtil.RouteCandidateList;
 import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.routing.util.FlagEncoder;
 import com.graphhopper.storage.GraphHopperStorage;
 import com.graphhopper.storage.NodeAccess;
 import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.PathMerger;
+import com.graphhopper.util.Translation;
+import com.graphhopper.util.shapes.GHPoint;
 import com.graphhopper.util.shapes.Polygon;
+import sun.reflect.generics.reflectiveObjects.NotImplementedException;
 
 import java.util.List;
 
 public abstract class PolygonRoutingTemplate extends ViaRoutingTemplate {
     final GHRequest ghRequest;
     final Polygon polygon;
-    final GraphHopper gh;
     final GraphHopperStorage ghStorage;
     final NodeAccess nodeAccess;
+    final LocationIndex locationIndex;
     QueryGraph queryGraph;
     AlgorithmOptions algorithmOptions;
     RoutingAlgorithmFactory algoFactory;
     RoutingAlgorithm routingAlgorithm;
     RouteCandidateList routeCandidates;
 
-    public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, GraphHopper gh,
+    public PolygonRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, NodeAccess nodeAccess, GraphHopperStorage ghStorage,
                                          EncodingManager encodingManager) {
         super(ghRequest, ghRsp, locationIndex, encodingManager);
         this.ghRequest = ghRequest;
         this.polygon = ghRequest.getPolygon();
-        this.gh = gh;
-        this.ghStorage = this.gh.getGraphHopperStorage();
-        this.nodeAccess = this.ghStorage.getNodeAccess();
+        this.ghStorage = ghStorage;
+        this.nodeAccess = nodeAccess;
+        this.locationIndex = locationIndex;
     }
 
     @Override
     public List<Path> calcPaths(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
+        if (this.ghRequest.getPoints().size() != 2) {
+            // TODO implement for more than start & endpoint
+            throw new NotImplementedException();
+        }
+        this.setCalcPathsParams(queryGraph, algoFactory, algoOpts);
+        return routeWithPolygon();
+    }
+
+    private void setCalcPathsParams(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
         this.queryGraph = queryGraph;
+        this.lookupPoints();
         this.algoFactory = algoFactory;
         this.algorithmOptions = algoOpts;
         this.routingAlgorithm = algoFactory.createAlgo(queryGraph, algoOpts);
         this.routeCandidates = RouteCandidateList.createEmptyCandidateList();
-        return routeWithPolygon();
+    }
+
+    private void lookupPoints() {
+        List<GHPoint> points = this.ghRequest.getPoints();
+        FlagEncoder flagEncoder = this.encodingManager.getEncoder(ghRequest.getVehicle());
+        List<QueryResult> lookupResults = super.lookup(points, flagEncoder);
+        queryGraph.lookup(lookupResults);
     }
 
     private List<Path> routeWithPolygon() {
-        this.findCandidateRoutes();
-        this.pruneDominatedCandidateRoutes();
-        this.pruneLowerQuantileInROIcandidateRoutes();
+        prepareRouteCandidateList();
+        extractBestPathCandidate();
 
+        return this.pathList;
+    }
 
+    private void extractBestPathCandidate() {
         // TODO Maybe more? Dont know what happens in the gui then.
         this.routeCandidates.sortByGainAscending();
-        return this.routeCandidates.getFirstAsPathList(1, this.queryGraph, this.algorithmOptions);
+        final List<Path> bestPath = this.routeCandidates.getFirstAsPathList(1, this.queryGraph, this.algorithmOptions);
+        this.pathList.addAll(bestPath);
+    }
+
+    private void prepareRouteCandidateList() {
+        this.findCandidateRoutes();
+        this.pruneDominatedCandidateRoutes();
+        this.pruneLowerQuantileInROIcandidateRoutes();
     }
 
     // Do it in a skyline problem pruning fashion
@@ -113,4 +143,20 @@ private void pruneLowerQuantileInROIcandidateRoutes() {
     }
 
     abstract RouteCandidateList findCandidateRoutes();
+
+    @Override
+    public boolean isReady(PathMerger pathMerger, Translation translation) {
+        this.failOnNumPathsInvalid(this.ghRequest, this.pathList);
+
+        // TODO check if all waypoints have been queried. Respectively: The entry exit points: Are they queried? Do They have to be queried or mustnt they be queried?
+        this.altResponse.setWaypoints(getWaypoints());
+        this.ghResponse.add(this.altResponse);
+        pathMerger.doWork(this.altResponse, this.pathList, this.encodingManager, translation);
+        return true;
+    }
+
+    @Override
+    public GHRequest getGhRequest() {
+        return this.ghRequest;
+    }
 }
diff --git a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
index c93797e522..c0f927f58e 100644
--- a/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplate.java
@@ -23,9 +23,9 @@
     private DijkstraOneToMany dijkstraForLOTNodes;
     private DijkstraManyToMany dijkstraForPathSkeleton;
 
-    public PolygonThroughRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, GraphHopper gh,
+    public PolygonThroughRoutingTemplate(GHRequest ghRequest, GHResponse ghRsp, LocationIndex locationIndex, NodeAccess nodeAccess, GraphHopperStorage ghStorage,
                                          EncodingManager encodingManager) {
-        super(ghRequest, ghRsp, locationIndex, gh, encodingManager);
+        super(ghRequest, ghRsp, locationIndex, nodeAccess, ghStorage, encodingManager);
     }
 
     private boolean isInvalidParameterSet(QueryGraph queryGraph, RoutingAlgorithmFactory algoFactory, AlgorithmOptions algoOpts) {
@@ -66,11 +66,13 @@ private RouteCandidate buildCandidatePath(int currentPointID, int nextPointID, i
     }
 
     private void lookUpStartEndNodes(int pointsIndex) {
+        // TODO Check if this is necessary since we already have node ids and we would add additional via points to the queryGraph result cache. This could have an impact.
         final GHPoint currentPoint = this.ghRequest.getPoints().get(pointsIndex);
         final GHPoint nextPoint = this.ghRequest.getPoints().get(pointsIndex + 1);
 
         List<GHPoint> LOTNodesGHPoints = Arrays.asList(currentPoint, nextPoint);
-        super.lookup(LOTNodesGHPoints, this.encodingManager.getEncoder(this.ghRequest.getVehicle()));
+        List<QueryResult> lookupResults = super.lookup(LOTNodesGHPoints, this.encodingManager.getEncoder(this.ghRequest.getVehicle()));
+        this.queryGraph.lookup(lookupResults);
     }
 
     // Definition 6 in Storandts paper Region-Aware Routing Planning
@@ -179,11 +181,10 @@ private void addToEntryExitIfNotExistentAndNotInPolygon(List<Integer> nodesInPol
 
     private List<Integer> getNodesInPolygon() {
         final Polygon polygon = this.getGhRequest().getPolygon();
-        final NodeAccess nodeAccess = gh.getGraphHopperStorage().getNodeAccess();
 
         BBox minimumPolygonBoundingBox = BBox.createMinimalBoundingBoxFromPolygon(polygon);
         final NodesInPolygonFindingVisitor visitor = new NodesInPolygonFindingVisitor(polygon, nodeAccess);
-        this.gh.getLocationIndex().query(minimumPolygonBoundingBox, visitor);
+        this.locationIndex.query(minimumPolygonBoundingBox, visitor);
         return visitor.getNodesInPolygon();
     }
 
diff --git a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
index 93e83cb4e4..d45aa045f0 100644
--- a/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
+++ b/core/src/main/java/com/graphhopper/routing/template/ViaRoutingTemplate.java
@@ -156,8 +156,7 @@ else if (getGhRequest().hasSnapPreventions())
 
     @Override
     public boolean isReady(PathMerger pathMerger, Translation tr) {
-        if (getGhRequest().getPoints().size() - 1 != pathList.size())
-            throw new RuntimeException("There should be exactly one more points than paths. points:" + getGhRequest().getPoints().size() + ", paths:" + pathList.size());
+        failOnNumPathsInvalid(this.ghRequest, this.pathList);
 
         altResponse.setWaypoints(getWaypoints());
         ghResponse.add(altResponse);
diff --git a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
index 3da0516de2..ba6a697213 100644
--- a/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
+++ b/core/src/test/java/com/graphhopper/routing/AlternativeRouteTest.java
@@ -61,7 +61,7 @@ public AlternativeRouteTest(TraversalMode tMode) {
         });
     }
 
-    public GraphHopperStorage createTestGraph(boolean fullGraph, EncodingManager tmpEM) {
+    public GraphHopperStorage createSimpleTestGraph(boolean fullGraph, EncodingManager tmpEM) {
         GraphHopperStorage graph = new GraphHopperStorage(new RAMDirectory(), tmpEM, false, turnCostExtension);
         graph.create(1000);
 
@@ -70,7 +70,7 @@ public GraphHopperStorage createTestGraph(boolean fullGraph, EncodingManager tmp
          1  2-3-4-10
          \   /   \
          5--6-7---8
-        
+
          */
         graph.edge(1, 9, 1, true);
         graph.edge(9, 2, 1, true);
@@ -105,7 +105,7 @@ public GraphHopperStorage createTestGraph(boolean fullGraph, EncodingManager tmp
 
     @Test
     public void testCalcAlternatives() {
-        GraphHopperStorage g = createTestGraph(true, em);
+        GraphHopperStorage g = createSimpleTestGraph(true, em);
         AlternativeRoute altDijkstra = new AlternativeRoute(g, weighting, traversalMode);
         altDijkstra.setMaxShareFactor(0.5);
         altDijkstra.setMaxWeightFactor(2);
@@ -133,7 +133,7 @@ public void testCalcAlternatives() {
 
     @Test
     public void testCalcAlternatives2() {
-        Graph g = createTestGraph(true, em);
+        Graph g = createSimpleTestGraph(true, em);
         AlternativeRoute altDijkstra = new AlternativeRoute(g, weighting, traversalMode);
         altDijkstra.setMaxPaths(3);
         altDijkstra.setMaxShareFactor(0.7);
@@ -169,7 +169,7 @@ private void checkAlternatives(List<AlternativeRoute.AlternativeInfo> alternativ
 
     @Test
     public void testDisconnectedAreas() {
-        Graph g = createTestGraph(true, em);
+        Graph g = createSimpleTestGraph(true, em);
 
         // one single disconnected node
         updateDistancesFor(g, 20, 0.00, -0.01);
diff --git a/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
new file mode 100644
index 0000000000..1c3cf37530
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/template/PolygonThroughRoutingTemplateTest.java
@@ -0,0 +1,164 @@
+package com.graphhopper.routing.template;
+
+import com.graphhopper.GHRequest;
+import com.graphhopper.GHResponse;
+import com.graphhopper.routing.AlgorithmOptions;
+import com.graphhopper.routing.QueryGraph;
+import com.graphhopper.routing.RoutingAlgorithmFactory;
+import com.graphhopper.routing.RoutingAlgorithmFactorySimple;
+import com.graphhopper.routing.profiles.*;
+import com.graphhopper.routing.template.util.PolygonRoutingTestGraphs;
+import com.graphhopper.routing.util.*;
+import com.graphhopper.routing.weighting.FastestWeighting;
+import com.graphhopper.routing.weighting.Weighting;
+import com.graphhopper.storage.GraphHopperStorage;
+import com.graphhopper.storage.IntsRef;
+import com.graphhopper.storage.NodeAccess;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.util.InstructionAnnotation;
+import com.graphhopper.util.Parameters;
+import com.graphhopper.util.Translation;
+import com.graphhopper.util.shapes.GHPoint;
+import com.graphhopper.util.shapes.Polygon;
+import org.junit.Before;
+import org.junit.Test;
+
+import javax.management.Query;
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.graphhopper.util.Parameters.Routing.*;
+
+public class PolygonThroughRoutingTemplateTest {
+    private PolygonRoutingTestGraphs testGraphCreator = new PolygonRoutingTestGraphs();
+    private EncodingManager encodingManager;
+    private GraphHopperStorage testGraph;
+    private Polygon polygon;
+    private LocationIndex locationIndex;
+    private NodeAccess nodeAccess;
+    private TraversalMode traversalMode;
+    private String algorithmName;
+    private HintsMap algorithmHints;
+    private FlagEncoder flagEncoder;
+    private Weighting weighting;
+
+    @Before
+    public void initVariables() {
+        this.createEncodingManager();
+        this.createTestGraph();
+        this.createTestPolygon();
+        this.createLocationIndex();
+        this.getNodeAccess();
+        this.setTraversalMode();
+        this.setAlgorithmName();
+        this.buildHintsMap();
+        this.setWeighting();
+    }
+
+
+    private void createEncodingManager() {
+        final FlagEncoder carFlagEncoder = new CarFlagEncoder();
+        this.flagEncoder = carFlagEncoder;
+        this.encodingManager = EncodingManager.create(carFlagEncoder);
+    }
+
+    private void createTestGraph() {
+        this.testGraph = this.testGraphCreator.createPolygonTestGraph(encodingManager);
+    }
+
+    private void createTestPolygon() {
+        this.polygon = new PolygonRoutingTestGraphs().createPolygon();
+    }
+
+    private void createLocationIndex() {
+        this.locationIndex = this.testGraphCreator.getCorrespondingIndex();
+    }
+
+    private void getNodeAccess() {
+        this.nodeAccess = this.testGraph.getNodeAccess();
+    }
+
+    private void setTraversalMode() {
+        this.traversalMode = TraversalMode.NODE_BASED;
+    }
+
+    private void setAlgorithmName() {
+        this.algorithmName = "dijkstrabi";
+    }
+
+    private void buildHintsMap() {
+        this.algorithmHints = new HintsMap();
+        this.algorithmHints.put("elevation", "false");
+        this.algorithmHints.put("instructions", "true");
+        this.algorithmHints.put("way_point_max_distance", "1.0");
+        this.algorithmHints.put("calc_points", "true");
+        this.algorithmHints.put("type", "json");
+        this.algorithmHints.put("locale", "de-DE");
+        this.algorithmHints.put("weighting", "fastest");
+        this.algorithmHints.put("key", "");
+        this.algorithmHints.put("vehicle", "car");
+    }
+
+    private void setWeighting() {
+        this.weighting = new FastestWeighting(this.flagEncoder, this.algorithmHints);
+    }
+
+    @Test
+    public void quickStartingTest() {
+        // Just to let something run
+        GHRequest request = buildRequest(new GHPoint(25, 0), new GHPoint(25, 46));
+        GHResponse response = new GHResponse();
+        final int maxVisitedNodes = this.algorithmHints.getInt(MAX_VISITED_NODES, Integer.MAX_VALUE);
+
+        RoutingTemplate routingTemplate = new PolygonThroughRoutingTemplate(request, response, this.locationIndex, this.nodeAccess, this.testGraph, this.encodingManager);
+        RoutingAlgorithmFactory algorithmFactory = new RoutingAlgorithmFactorySimple();
+        AlgorithmOptions algorithmOptions = buildAlgorithmOptions(algorithmHints, this.traversalMode, this.algorithmName, this.weighting, maxVisitedNodes);
+
+        routingTemplate.calcPaths(new QueryGraph(this.testGraph), algorithmFactory, algorithmOptions);
+    }
+
+    private AlgorithmOptions buildAlgorithmOptions(HintsMap hints, TraversalMode tMode, String algoStr, Weighting weighting, int maxVisitedNodesForRequest) {
+        return AlgorithmOptions.start().
+                algorithm(algoStr).traversalMode(tMode).weighting(weighting).
+                maxVisitedNodes(maxVisitedNodesForRequest).
+                hints(hints).
+                build();
+    }
+
+    private GHRequest buildRequest(GHPoint... startViaEndPoints) {
+        List<GHPoint> startViaEndPointList = convertPointsToListFormat(startViaEndPoints);
+        List<Double> favoredHeadings = new ArrayList<>(0);
+        String vehicleStr = "car";
+        String weighting = "fastest";
+        String algoStr = "";
+        String localeStr = "de-DE";
+        boolean calcPoints = true;
+        boolean instructions = true;
+        double minPathPrecision = 1.0;
+
+        GHRequest request = new GHRequest(startViaEndPointList);
+        request.setVehicle(vehicleStr).
+                setWeighting(weighting).
+                setAlgorithm(algoStr).
+                setLocale(localeStr).
+                setPointHints(new ArrayList<String>()).
+                setSnapPreventions(new ArrayList<String>()).
+                setPathDetails(new ArrayList<String>()).
+                setPolygon(this.polygon).
+                getHints().
+                put(CALC_POINTS, calcPoints).
+                put(INSTRUCTIONS, instructions).
+                put(WAY_POINT_MAX_DISTANCE, minPathPrecision);
+        return request;
+    }
+
+    private static List<GHPoint> convertPointsToListFormat(GHPoint[] startViaEndPoints) {
+        List<GHPoint> startViaEndPointList = new ArrayList<GHPoint>();
+        for (GHPoint point : startViaEndPoints) {
+            startViaEndPointList.add(point);
+        }
+
+        return startViaEndPointList;
+    }
+
+}
diff --git a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
index 57d62929d4..d048e3a040 100644
--- a/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/RoundTripRoutingTemplateTest.java
@@ -137,14 +137,14 @@ public void testCalcRoundTrip() throws Exception {
     }
 
     private Graph createTestGraph(boolean fullGraph) {
-        return new AlternativeRouteTest(tMode).createTestGraph(fullGraph, em);
+        return new AlternativeRouteTest(tMode).createSimpleTestGraph(fullGraph, em);
     }
 
     private Graph createSquareGraph() {
         // simple square
-        //  1 | 0 1 2      
+        //  1 | 0 1 2
         //  0 | 7   3
-        // -1 | 6 5 4 
+        // -1 | 6 5 4
         // ---|------
         //    |-1 0 1
         GraphHopperStorage graph =
diff --git a/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java b/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java
new file mode 100644
index 0000000000..e4181ca6e5
--- /dev/null
+++ b/core/src/test/java/com/graphhopper/routing/template/util/PolygonRoutingTestGraphs.java
@@ -0,0 +1,395 @@
+package com.graphhopper.routing.template.util;
+
+import com.graphhopper.routing.AbstractRoutingAlgorithmTester;
+import com.graphhopper.routing.util.EdgeFilter;
+import com.graphhopper.routing.util.EncodingManager;
+import com.graphhopper.storage.*;
+import com.graphhopper.storage.index.LocationIndex;
+import com.graphhopper.storage.index.QueryResult;
+import com.graphhopper.util.DistanceCalc2D;
+import com.graphhopper.util.EdgeExplorer;
+import com.graphhopper.util.EdgeIteratorState;
+import com.graphhopper.util.shapes.BBox;
+import com.graphhopper.util.shapes.Polygon;
+import sun.reflect.generics.reflectiveObjects.NotImplementedException;
+
+public class PolygonRoutingTestGraphs {
+    private final TurnCostExtension turnCostExtension;
+    private GraphHopperStorage graph;
+    private Node[] nodes;
+    private DistanceCalc2D distanceCalculator;
+
+    public PolygonRoutingTestGraphs() {
+        this.turnCostExtension = new TurnCostExtension();
+        this.distanceCalculator = new DistanceCalc2D();
+    }
+
+    public GraphHopperStorage createPolygonTestGraph(EncodingManager tmpEM) {
+        this.graph = new GraphHopperStorage(new RAMDirectory(), tmpEM, false, turnCostExtension);
+        this.graph.create(1000);
+
+        // Exterior this.graph including to Entry / Exit nodes
+        buildEdges();
+        buildNodes();
+
+
+        return graph;
+    }
+
+    private void buildNodes() {
+        getNodeList();
+        setDistanceToEuclidean();
+    }
+
+    private void getNodeList() {
+        this.nodes = new Node[]{new Node(0, 25, 0),
+                                new Node(1, 25, 8),
+                                new Node(2, 25, 16),
+                                new Node(3, 25, 25),
+                                new Node(4, 25, 34),
+                                new Node(5, 25, 43),
+                                new Node(6, 25, 46),
+                                new Node(7, 20, 3),
+                                new Node(8, 22, 8),
+                                new Node(9, 22, 29),
+                                new Node(10, 21, 35),
+                                new Node(11, 20, 42),
+                                new Node(12, 16, 34),
+                                new Node(13, 17, 38),
+                                new Node(14, 15, 43),
+                                new Node(15, 11, 34),
+                                new Node(16, 12, 38),
+                                new Node(17, 7, 32),
+                                new Node(18, 7, 38),
+                                new Node(19, 7, 1),
+                                new Node(20, 1, 1),
+                                new Node(21, 3, 7),
+                                new Node(22, 2, 13),
+                                new Node(23, 0, 16),
+                                new Node(24, 0, 21),
+                                new Node(25, 2, 25),
+                                new Node(26, 3, 33),
+                                new Node(27, 2, 36),
+                                new Node(28, 22, 16),
+                                new Node(29, 22, 20),
+                                new Node(30, 21, 23),
+                                new Node(31, 19, 25),
+                                new Node(32, 14, 30),
+                                new Node(33, 11, 30),
+                                new Node(34, 7, 27),
+                                new Node(35, 6, 25),
+                                new Node(36, 5, 22),
+                                new Node(37, 5, 20),
+                                new Node(38, 5, 17),
+                                new Node(39, 6, 14),
+                                new Node(40, 7, 11),
+                                new Node(41, 10, 10),
+                                new Node(42, 13, 9),
+                                new Node(43, 15, 9),
+                                new Node(44, 19, 10),
+                                new Node(45, 21, 12),
+                                new Node(46, 17, 16),
+                                new Node(47, 18, 19),
+                                new Node(48, 17, 22),
+                                new Node(49, 14, 23),
+                                new Node(50, 11, 22),
+                                new Node(51, 10, 19),
+                                new Node(52, 11, 16),
+                                new Node(53, 14, 15),
+                                new Node(54, 15, 18),
+                                new Node(56, 15, 20),
+                                new Node(57, 13, 20),
+                                new Node(58, 13, 18)};
+    }
+
+    private void setDistanceToEuclidean() {
+        for (Node node : nodes) {
+            node.updateDistance(this.graph);
+        }
+    }
+
+    private void buildEdges() {
+        this.graph.edge(0, 1, 1, true);
+        this.graph.edge(0, 7, 1, true);
+        this.graph.edge(0, 19, 1, true);
+        this.graph.edge(1, 2, 1, true);
+        this.graph.edge(1, 7, 1, true);
+        this.graph.edge(1, 8, 1, true);
+        this.graph.edge(1, 45, 1, true);
+        this.graph.edge(1, 28, 1, true);
+        this.graph.edge(2, 3, 1, true);
+        this.graph.edge(2, 28, 1, true);
+        this.graph.edge(2, 29, 1, true);
+        this.graph.edge(3, 4, 1, true);
+        this.graph.edge(3, 29, 1, true);
+        this.graph.edge(3, 30, 1, true);
+        this.graph.edge(3, 9, 1, true);
+        this.graph.edge(4, 5, 1, true);
+        this.graph.edge(4, 9, 1, true);
+        this.graph.edge(4, 10, 1, true);
+        this.graph.edge(4, 13, 1, true);
+        this.graph.edge(5, 10, 1, true);
+        this.graph.edge(5, 11, 1, true);
+        this.graph.edge(5, 13, 1, true);
+        this.graph.edge(5, 14, 1, true);
+        this.graph.edge(6, 14, 1, true);
+        this.graph.edge(7, 19, 1, true);
+        this.graph.edge(7, 43, 1, true);
+        this.graph.edge(7, 48, 1, true);
+        this.graph.edge(8, 44, 1, true);
+        this.graph.edge(8, 45, 1, true);
+        this.graph.edge(9, 30, 1, true);
+        this.graph.edge(9, 31, 1, true);
+        this.graph.edge(10, 12, 1, true);
+        this.graph.edge(11, 16, 1, true);
+        this.graph.edge(12, 13, 1, true);
+        this.graph.edge(12, 15, 1, true);
+        this.graph.edge(12, 32, 1, true);
+        this.graph.edge(13, 15, 1, true);
+        this.graph.edge(13, 16, 1, true);
+        this.graph.edge(14, 16, 1, true);
+        this.graph.edge(14, 18, 1, true);
+        this.graph.edge(15, 16, 1, true);
+        this.graph.edge(15, 17, 1, true);
+        this.graph.edge(15, 18, 1, true);
+        this.graph.edge(15, 33, 1, true);
+        this.graph.edge(15, 34, 1, true);
+        this.graph.edge(17, 18, 1, true);
+        this.graph.edge(17, 26, 1, true);
+        this.graph.edge(17, 34, 1, true);
+        this.graph.edge(17, 35, 1, true);
+        this.graph.edge(18, 26, 1, true);
+        this.graph.edge(18, 27, 1, true);
+        this.graph.edge(19, 20, 1, true);
+        this.graph.edge(19, 21, 1, true);
+        this.graph.edge(19, 41, 1, true);
+        this.graph.edge(19, 42, 1, true);
+        this.graph.edge(20, 21, 1, true);
+        this.graph.edge(20, 23, 1, true);
+        this.graph.edge(21, 22, 1, true);
+        this.graph.edge(21, 39, 1, true);
+        this.graph.edge(21, 40, 1, true);
+        this.graph.edge(22, 23, 1, true);
+        this.graph.edge(22, 25, 1, true);
+        this.graph.edge(22, 39, 1, true);
+        this.graph.edge(23, 24, 1, true);
+        this.graph.edge(23, 38, 1, true);
+        this.graph.edge(24, 25, 1, true);
+        this.graph.edge(24, 37, 1, true);
+        this.graph.edge(25, 27, 1, true);
+        this.graph.edge(25, 35, 1, true);
+        this.graph.edge(25, 36, 1, true);
+        this.graph.edge(25, 37, 1, true);
+        this.graph.edge(26, 35, 1, true);
+
+        // Entry/Exit to Interior this.graph
+        this.graph.edge(28, 29, 1, true);
+        this.graph.edge(28, 46, 1, true);
+        this.graph.edge(28, 47, 1, true);
+        this.graph.edge(29, 30, 1, true);
+        this.graph.edge(29, 48, 1, true);
+        this.graph.edge(30, 31, 1, true);
+        this.graph.edge(30, 47, 1, true);
+        this.graph.edge(30, 48, 1, true);
+        this.graph.edge(31, 48, 1, true);
+        this.graph.edge(31, 49, 1, true);
+        this.graph.edge(32, 33, 1, true);
+        this.graph.edge(32, 49, 1, true);
+        this.graph.edge(33, 49, 1, true);
+        this.graph.edge(34, 35, 1, true);
+        this.graph.edge(34, 50, 1, true);
+        this.graph.edge(35, 36, 1, true);
+        this.graph.edge(36, 37, 1, true);
+        this.graph.edge(36, 50, 1, true);
+        this.graph.edge(37, 38, 1, true);
+        this.graph.edge(37, 51, 1, true);
+        this.graph.edge(38, 39, 1, true);
+        this.graph.edge(38, 50, 1, true);
+        this.graph.edge(39, 40, 1, true);
+        this.graph.edge(39, 51, 1, true);
+        this.graph.edge(40, 52, 1, true);
+        this.graph.edge(41, 52, 1, true);
+        this.graph.edge(41, 53, 1, true);
+        this.graph.edge(42, 53, 1, true);
+        this.graph.edge(43, 44, 1, true);
+        this.graph.edge(43, 46, 53, true);
+        this.graph.edge(43, 53, 1, true);
+        this.graph.edge(44, 45, 1, true);
+        this.graph.edge(44, 46, 1, true);
+        this.graph.edge(44, 53, 1, true);
+        this.graph.edge(45, 46, 1, true);
+
+        // Interior this.graph
+        this.graph.edge(46, 47, 1, true);
+        this.graph.edge(46, 53, 1, true);
+        this.graph.edge(46, 54, 1, true);
+        this.graph.edge(47, 48, 1, true);
+        this.graph.edge(47, 54, 1, true);
+        this.graph.edge(47, 55, 1, true);
+        this.graph.edge(48, 49, 1, true);
+        this.graph.edge(48, 55, 1, true);
+        this.graph.edge(49, 50, 1, true);
+        this.graph.edge(49, 55, 1, true);
+        this.graph.edge(49, 56, 1, true);
+        this.graph.edge(50, 51, 1, true);
+        this.graph.edge(50, 56, 1, true);
+        this.graph.edge(51, 52, 1, true);
+        this.graph.edge(51, 56, 1, true);
+        this.graph.edge(51, 57, 1, true);
+        this.graph.edge(52, 53, 1, true);
+        this.graph.edge(52, 57, 1, true);
+        this.graph.edge(53, 57, 1, true);
+        this.graph.edge(53, 54, 1, true);
+        this.graph.edge(54, 55, 1, true);
+        this.graph.edge(54, 56, 1, true);
+        this.graph.edge(54, 57, 1, true);
+        this.graph.edge(55, 56, 1, true);
+        this.graph.edge(55, 57, 1, true);
+        this.graph.edge(56, 57, 1, true);
+    }
+
+    public Polygon createPolygon() {
+        final Polygon polygon = new Polygon(new double[]{19, 19, 8, 8}, new double[]{14, 24, 24, 14});
+        return polygon;
+    }
+
+    public LocationIndex getCorrespondingIndex() {
+        return new LocationIndex() {
+            @Override
+            public LocationIndex setResolution(int resolution) {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public LocationIndex prepareIndex() {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public QueryResult findClosest(double lat, double lon, EdgeFilter edgeFilter) {
+                MinDistanceNodeFinder minDistanceNodeFinder = new MinDistanceNodeFinder(lat, lon).invoke();
+
+                double minDistance = minDistanceNodeFinder.getMinDistance();
+                Node minNode = minDistanceNodeFinder.getMinNode();
+                EdgeIteratorState firstEdgeAdjacentToMinNode = findClosestEdge(minNode);
+
+                QueryResult result = createQueryResult(minDistance, minNode, firstEdgeAdjacentToMinNode);
+
+                return result;
+            }
+
+            private EdgeIteratorState findClosestEdge(Node minNode) {
+                EdgeExplorer edgeExplorer = graph.createEdgeExplorer();
+                return edgeExplorer.setBaseNode(minNode.id);
+            }
+
+            private QueryResult createQueryResult(double minDistance, Node minNode, EdgeIteratorState firstEdgeAdjacentToMinNode) {
+                QueryResult result = new QueryResult(minNode.latitude, minNode.longitude);
+                result.setClosestNode(minNode.id);
+                result.setQueryDistance(minDistance);
+                result.setClosestEdge(firstEdgeAdjacentToMinNode);
+                return result;
+            }
+
+            @Override
+            public LocationIndex setApproximation(boolean approxDist) {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public void setSegmentSize(int bytes) {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public void query(BBox queryBBox, Visitor function) {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public boolean loadExisting() {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public LocationIndex create(long byteCount) {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public void flush() {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public void close() {
+                throw new NotImplementedException();
+            }
+
+            @Override
+            public boolean isClosed() {
+                return false;
+            }
+
+            @Override
+            public long getCapacity() {
+                return 0;
+            }
+        };
+    }
+
+    public NodeAccess getCorrespondingNodeAccess() {
+        return this.graph.getNodeAccess();
+    }
+
+    private class Node {
+        public final int id;
+        public final double latitude;
+        public final double longitude;
+
+        public Node(final int id, final double latitude, final double longitude) {
+            this.id = id;
+            this.latitude = latitude;
+            this.longitude = longitude;
+        }
+
+        public void updateDistance(final GraphHopperStorage ghs) {
+            AbstractRoutingAlgorithmTester.updateDistancesFor(graph, this.id, this.latitude, this.longitude);
+        }
+    }
+
+    private class MinDistanceNodeFinder {
+        private double lat;
+        private double lon;
+        private double minDistance;
+        private Node minNode;
+
+        public MinDistanceNodeFinder(double lat, double lon) {
+            this.lat = lat;
+            this.lon = lon;
+        }
+
+        public double getMinDistance() {
+            return minDistance;
+        }
+
+        public Node getMinNode() {
+            return minNode;
+        }
+
+        public MinDistanceNodeFinder invoke() {
+            minDistance = Double.MAX_VALUE;
+            minNode = null;
+
+            for (final Node node : nodes) {
+                final double distanceToThisNode = distanceCalculator.calcNormalizedDist(lat, lon, node.latitude, node.longitude);
+
+                if (minDistance > distanceToThisNode) {
+                    minDistance = distanceToThisNode;
+                    minNode = node;
+                }
+            }
+            return this;
+        }
+    }
+}
diff --git a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
index dddb42402a..f10ba69946 100644
--- a/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
+++ b/web-bundle/src/main/java/com/graphhopper/resources/RouteResource.java
@@ -269,6 +269,7 @@ private void exceptionOnNoPointsRequested(@QueryParam("point") List<GHPoint> req
     }
 
     static void initHints(HintsMap m, MultivaluedMap<String, String> parameterMap) {
+        // TODO Output parameters are bad practice, especially if the return type is void
         for (Map.Entry<String, List<String>> e : parameterMap.entrySet()) {
             if (e.getValue().size() == 1) {
                 m.put(e.getKey(), e.getValue().get(0));
