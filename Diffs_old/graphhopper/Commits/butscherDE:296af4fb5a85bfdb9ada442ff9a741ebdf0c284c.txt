diff --git a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
index b96d36af40..e04a1ec1af 100644
--- a/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
+++ b/core/src/main/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidatePolygon.java
@@ -2,6 +2,10 @@
 
 import com.graphhopper.routing.*;
 import com.graphhopper.routing.template.PolygonRoutingTemplate;
+import com.graphhopper.util.EdgeIteratorState;
+
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * A route candidate as in Prof. Dr. Sabine Storandts Paper Region-Aware Route Planning.
@@ -14,6 +18,7 @@
     final PolygonRoutingTemplate polygonRoutingTemplate;
     RoutingAlgorithm routingAlgorithm;
     final int startNodeID, endNodeID, polygonEntryNodeID, polygonExitNodeID;
+    PathMerge mergedPath = null;
 
     public RouteCandidatePolygon(final PolygonRoutingTemplate polygonRoutingTemplate, final int startNodeID, final int endNodeID, final int polygonEntryNodeID,
                                  final int polygonExitNodeID) {
@@ -33,6 +38,12 @@ void calcDirectRouteFromStartToEnd() {
     }
 
     public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
+        mergePathIfNotDone(queryGraph, algoOpts);
+
+        return this.mergedPath;
+    }
+
+    private void mergePath(QueryGraph queryGraph, AlgorithmOptions algoOpts) {
         PathMerge completePathCandidate = new PathMerge(queryGraph, algoOpts.getWeighting());
 
         completePathCandidate.addPath(startToDetourEntry);
@@ -42,7 +53,7 @@ public Path getMergedPath(final QueryGraph queryGraph, final AlgorithmOptions al
         completePathCandidate.setFromNode(startNodeID);
         completePathCandidate.extract();
 
-        return completePathCandidate;
+        this.mergedPath = completePathCandidate;
     }
 
     public double getDistance() {
@@ -77,11 +88,33 @@ public double getDetourDistance() {
      *
      * @return true if at least one intersection occurs and false otherwise.
      */
-    public boolean isDetourSelfIntersecting() {
-        return false;
+    public boolean isDetourSelfIntersecting(final QueryGraph queryGraph, final AlgorithmOptions algoOpts) {
+        mergePathIfNotDone(queryGraph, algoOpts);
+
+        return checkForRedundantNodes();
         // TODO: Selfintersecting: Complete route or detour part?
     }
 
+    private void mergePathIfNotDone(QueryGraph queryGraph, AlgorithmOptions algoOpts) {
+        if (mergedPath == null) {
+            mergePath(queryGraph, algoOpts);
+        }
+    }
+
+    private boolean checkForRedundantNodes() {
+        Map<Integer, Boolean> foundNodes = new HashMap<>();
+
+        for (final int node : this.mergedPath.getNodesInPathOrder()) {
+            if (foundNodes.get(node) == null) {
+                foundNodes.put(node, true);
+            } else {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
     @Override
     public int compareTo(RouteCandidatePolygon o) {
         final double thisGain = this.getGain();
diff --git a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
index 3673fb5169..423835b6c0 100644
--- a/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
+++ b/core/src/test/java/com/graphhopper/routing/template/polygonRoutingUtil/RouteCandidateTest.java
@@ -1,14 +1,18 @@
 package com.graphhopper.routing.template.polygonRoutingUtil;
 
 import com.graphhopper.GHRequest;
+import com.graphhopper.routing.AlgorithmOptions;
 import com.graphhopper.routing.Path;
 import com.graphhopper.routing.PathMerge;
+import com.graphhopper.routing.QueryGraph;
 import com.graphhopper.routing.template.PolygonThroughRoutingTemplate;
 import com.graphhopper.routing.template.util.PolygonRoutingTestGraph;
 import com.graphhopper.util.shapes.Polygon;
 import org.junit.Test;
 
+import static junit.framework.TestCase.assertTrue;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 
 public class RouteCandidateTest {
     private final GHRequest ghRequest = new GHRequest(0, 0, 10, 10).setPolygon(new Polygon(new double [] {5, 10, 10, 5}, new double [] {5, 5, 10, 10}));
@@ -48,40 +52,90 @@ public void testCorrectComparision() {
         assertEquals(-1, comparisionResult);
     }
 
+    private RouteCandidatePolygon setupSmallerRouteCandidate() {
+        RouteCandidatePolygon test = new RouteCandidatePolygonThrough(routingTemplate, 1, 3, 28, 29);
+
+        test.startToDetourEntry = createTestSubPath(7, 28, 1);
+        test.detourEntryToDetourExit = createTestSubPath(72, 29, 1).setFromNode(0);
+        test.detourExitToEnd = createTestSubPath(12, 3, 1);
+        test.directRouteStartEnd = createDirectRoute(2);
+
+        return test;
+    }
+
     private RouteCandidatePolygon setupGreaterRouteCandidate() {
-        RouteCandidatePolygon test = new RouteCandidatePolygonThrough(routingTemplate, 0, 3, 1, 2);
+        RouteCandidatePolygon test = new RouteCandidatePolygonThrough(routingTemplate, 1, 3, 28, 29);
+
         test.startToDetourEntry = createTestSubPath(7, 28, 2);
-        test.detourEntryToDetourExit = createTestSubPath(72, 29, 2);
+        test.detourEntryToDetourExit = createTestSubPath(72, 29, 2).setFromNode(0);
         test.detourExitToEnd = createTestSubPath(12, 3, 2);
         test.directRouteStartEnd = createDirectRoute(5);
-        return test;
-    }
 
-    private RouteCandidatePolygon setupSmallerRouteCandidate() {
-        RouteCandidatePolygon test = new RouteCandidatePolygonThrough(routingTemplate, 0, 3, 1, 2);
-        test.startToDetourEntry = createTestSubPath(7, 28, 1);
-        test.detourEntryToDetourExit = createTestSubPath(72, 29, 1);
-        test.detourExitToEnd = createTestSubPath(12, 3, 1);
-        test.directRouteStartEnd = createDirectRoute(2);
         return test;
     }
 
     private Path createTestSubPath(int edgeId, int endNode, int distance) {
         Path startPolygon = new PathMerge(graphMocker.graph, graphMocker.weighting);
+
         startPolygon.addEdge(edgeId);
         startPolygon.setEndNode(endNode);
         startPolygon.setDistance(distance);
         startPolygon.setFound(true);
+
         return startPolygon;
     }
 
     private Path createDirectRoute(int distance) {
         Path directRoute = new PathMerge(graphMocker.graph, graphMocker.weighting);
+
         directRoute.addEdge(3);
         directRoute.addEdge(8);
         directRoute.setEndNode(3);
         directRoute.setDistance(distance);
         directRoute.setFound(true);
+
         return directRoute;
     }
+
+    @Test
+    public void testSelfintersection() {
+        final RouteCandidatePolygon testNonSelfintersecting = setupNonSelfintersectingRouteCandidate();
+        final RouteCandidatePolygon testSelfintersecting = setupSelfintersectingRouteCandidate();
+
+        final QueryGraph queryGraph = new QueryGraph(graphMocker.graph);
+        final AlgorithmOptions algorithmOptions = new AlgorithmOptions("dijkstrabi", graphMocker.weighting);
+
+        assertFalse(testNonSelfintersecting.isDetourSelfIntersecting(queryGraph, algorithmOptions));
+        assertTrue(testSelfintersecting.isDetourSelfIntersecting(queryGraph, algorithmOptions));
+    }
+
+    private RouteCandidatePolygon setupNonSelfintersectingRouteCandidate() {
+        return createSimpleMergedCandidate(0,3, 0, 3, 8);
+    }
+
+    private RouteCandidatePolygon setupSelfintersectingRouteCandidate() {
+        return createSimpleMergedCandidate(0,3, 0, 3, 9, 73, 10, 8);
+    }
+
+    private RouteCandidatePolygon createSimpleMergedCandidate(final int from, final int to, final int... edgeIds) {
+        RouteCandidatePolygon candidate = createRouteCandidateWithMergedPath(from, to);
+        setupRouteCandidatesParameters(from, to, candidate, edgeIds);
+
+        return candidate;
+    }
+
+    private RouteCandidatePolygon createRouteCandidateWithMergedPath(int from, int to) {
+        RouteCandidatePolygon candidate = new RouteCandidatePolygonThrough(routingTemplate, from, to, -1, -1);
+        candidate.mergedPath = new PathMerge(graphMocker.graph, graphMocker.weighting);
+        return candidate;
+    }
+
+    private void setupRouteCandidatesParameters(int from, int to, RouteCandidatePolygon candidate, int[] edgeIds) {
+        for (final int edgeId : edgeIds) {
+            candidate.mergedPath.addEdge(edgeId);
+        }
+        candidate.mergedPath.setFromNode(from);
+        candidate.mergedPath.setEndNode(to);
+        candidate.mergedPath.extract();
+    }
 }
